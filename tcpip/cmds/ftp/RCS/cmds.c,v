head	1.8;
access;
symbols
	Helios_1_3_1:1.6
	Helios_C40_1_3_Official_Release:1.6
	Alenia_release:1.5
	Helios1_3:1.5
	C40_Field_Test_2:1.5
	Helios13_beta:1.5
	Helios1_2_2:1.3
	Helios1_2_2Beta:1.3
	Helios1_2_1:1.3;
locks; strict;
comment	@ * @;


1.8
date	94.03.31.08.53.30;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	94.03.20.13.06.50;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	93.02.26.11.49.11;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	92.06.18.10.27.05;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	92.06.11.09.14.30;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	91.03.18.17.30.43;	author al;	state Exp;
branches;
next	1.2;

1.2
date	91.02.14.18.14.09;	author al;	state Exp;
branches;
next	1.1;

1.1
date	91.02.12.18.56.49;	author nick;	state Exp;
branches;
next	;


desc
@@


1.8
log
@fixed compile time warnings
@
text
@/*
 * Copyright (c) 1985, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifdef lint
static char sccsid[] = "@@(#)cmds.c	5.14.1.2 (Berkeley) 3/1/89";
#endif /* not lint */

/*
 * FTP User Program -- Command Routines.
 */
#include <sys/param.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/socket.h>

#include <arpa/ftp.h>
#include <netinet/in.h>

#include <signal.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <ctype.h>
#include <time.h>
#ifdef __STDC__
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#endif

#ifdef __HELIOS
#include <helios.h>
#endif

#include "ftp_var.h"

#ifdef __STDC__
char *_gets(char *s)
{
	fflush(stdout);
	return gets(s);
}
#define gets(x) _gets(x)
#endif

extern char *	globerr;
extern char  	reply_string[];
extern char *	home;

extern char **	glob( char * );
extern char *	getwd( char * );
extern char *	getpass( char * );
extern char *	hookup( char *, int );
extern int	login( char * host );
extern int	command( char * fmt, ... );
extern void	sendrequest( char * cmd, char * local, char * remote );
extern void	recvrequest( char * cmd, char * local, char * remote, char * mode );
extern void	pswitch( int flag );
extern int	getreply( int expecteof );
extern void	blkfree( char ** );
extern void	makeargv( void );
extern void	call( VoidFnPtr, ... );


char *		mname;
jmp_buf		jabort;

char *		remglob( char * argv[],	int doswitch );
char *		domap( char * name );
char *		dotrans( char * name );
int		confirm( char * cmd, char * file );
int		globulize( char ** cpp );


/*
 * Connect to peer server and
 * auto-login, if possible.
 */
void
setpeer(int argc,char *argv[] )
{
  char *host;
  
	int port;

	
	if (connected)
	  {
	    printf( "Already connected to %s, use close first.\n", hostname);
	    code = -1;
	    return;
	  }
	
	if (argc < 2)
	  {
		(void) strcat(line, " ");
		printf("(to) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	      }
	
	if (argc > 3) {
		printf("usage: %s host-name [port]\n", argv[0]);
		code = -1;
		return;
	}
	
	port = sp->s_port;
	
	if (argc > 2)
	  {
		port = atoi(argv[2]);
		
		if (port <= 0)
		  {
			printf("%s: bad port number-- %s\n", argv[1], argv[2]);
			printf ("usage: %s host-name [port]\n", argv[0]);
			code = -1;
			return;
		}
		port = htons(port);
	}
	
	host = hookup(argv[1], port);
	
	if (host)
	  {
	    connected = 1;
	    
	    if (autologin)
	      {
#if defined(unix) && NBBY == 8
		int overbose;
#endif
			
		(void) login(argv[1]);

#if defined(unix) && NBBY == 8
/*
 * this ifdef is to keep someone form "porting" this to an incompatible
 * system and not checking this out. This way they have to think about it.
 */
			overbose = verbose;
			if (debug == 0)
				verbose = -1;
			if (command("SYST") == COMPLETE && overbose) {
				register char *cp, c;
				cp = index(reply_string+4, ' ');
				if (cp == NULL)
					cp = index(reply_string+4, '\r');
				if (cp) {
					if (cp[-1] == '.')
						cp--;
					c = *cp;
					*cp = '\0';
				}

				printf("Remote system type is %s.\n",
					reply_string+4);
				if (cp)
					*cp = c;
			}
			if (!strncmp(reply_string, "215 UNIX Type: L8", 17)) {
				setbinary();
				if (overbose)
				    printf("Using %s mode to transfer files.\n",
					typename);
			} else if (overbose && 
			    !strncmp(reply_string, "215 TOPS20", 10)) {
				printf(
"Remember to set tenex mode when transfering binary files from this machine.\n");
			}
			verbose = overbose;
#endif /* unix */
		}
	}
}

struct	types {
	char	*t_name;
	char	*t_mode;
	int	t_type;
	char	*t_arg;
} types[] = {
	{ "ascii",	"A",	TYPE_A,	0 },
	{ "binary",	"I",	TYPE_I,	0 },
	{ "image",	"I",	TYPE_I,	0 },
	{ "ebcdic",	"E",	TYPE_E,	0 },
	{ "tenex",	"L",	TYPE_L,	bytename },
	0
};

/*
 * Set transfer type.
 */
void
settype( int argc, char * argv[] )
{
	register struct types *p;
	int comret;

	if (argc > 2) {
		char *sep;

		printf("usage: %s [", argv[0]);
		sep = " ";
		for (p = types; p->t_name; p++) {
			printf("%s%s", sep, p->t_name);
			if (*sep == ' ')
				sep = " | ";
		}
		printf(" ]\n");
		code = -1;
		return;
	}
	if (argc < 2) {
		printf("Using %s mode to transfer files.\n", typename);
		code = 0;
		return;
	}
	for (p = types; p->t_name; p++)
		if (strcmp(argv[1], p->t_name) == 0)
			break;
	if (p->t_name == 0) {
		printf("%s: unknown mode\n", argv[1]);
		code = -1;
		return;
	}
	if ((p->t_arg != NULL) && (*(p->t_arg) != '\0'))
		comret = command ("TYPE %s %s", p->t_mode, p->t_arg);
	else
		comret = command("TYPE %s", p->t_mode);
	if (comret == COMPLETE) {
		(void) strcpy(typename, p->t_name);
		type = p->t_type;
	}
}

/*
 * Set binary transfer type.
 */
/*VARARGS*/
void
setbinary()
{

	call(settype, "type", "binary", 0);
}

/*
 * Set ascii transfer type.
 */
/*VARARGS*/
void
setascii()
{

	call(settype, "type", "ascii", 0);
}

/*
 * Set tenex transfer type.
 */
/*VARARGS*/
void
settenex()
{

	call(settype, "type", "tenex", 0);
}

/*
 * Set ebcdic transfer type.
 */
/*VARARGS*/
void
setebcdic()
{

	call(settype, "type", "ebcdic", 0);
}

/*
 * Set file transfer mode.
 */
/*ARGSUSED*/
void
setmode(int	      argc, char *      argv[] )
{

  printf("We only support %s mode, sorry.\n", modename);
  code = -1;

  return;

  argc = argc;
  argv = argv;  
}

/*
 * Set file transfer format.
 */
/*ARGSUSED*/
void
setform( int argc, char * argv[] )
{
  printf("We only support %s format, sorry.\n", formname);
  code = -1;

  return;

  argc = argc;
  argv = argv;
}

/*
 * Set file transfer structure.
 */
/*ARGSUSED*/
void
setstruct( int argc, char * argv[] )
{

	printf("We only support %s structure, sorry.\n", structname);
	code = -1;

	return;

	argc = argc;
	argv = argv;
}

/*
 * Send a single file.
 */
void
put(int argc,char *argv[] )
{
	char *cmd;
	int loc = 0;
	char *oldargv1;

	if (argc == 2) {
		argc++;
		argv[2] = argv[1];
		loc++;
	}
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(local-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
usage:
		printf("usage:%s local-file remote-file\n", argv[0]);
		code = -1;
		return;
	}
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(remote-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) 
		goto usage;
	oldargv1 = argv[1];
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	/*
	 * If "globulize" modifies argv[1], and argv[2] is a copy of
	 * the old argv[1], make it a copy of the new argv[1].
	 */
	if (argv[1] != oldargv1 && argv[2] == oldargv1) {
		argv[2] = argv[1];
	}
	cmd = (argv[0][0] == 'a') ? "APPE" : ((sunique) ? "STOU" : "STOR");
	if (loc && ntflag) {
		argv[2] = dotrans(argv[2]);
	}
	if (loc && mapflag) {
		argv[2] = domap(argv[2]);
	}
	sendrequest(cmd, argv[1], argv[2]);
}

void
mabort( int a )
{
	int ointer;
	extern jmp_buf jabort;

	printf("\n");
	(void) fflush(stdout);
	if (mflag && fromatty) {
		ointer = interactive;
		interactive = 1;
		if (confirm("Continue with", mname)) {
			interactive = ointer;
			longjmp(jabort,0);
		}
		interactive = ointer;
	}
	mflag = 0;
	longjmp(jabort,0);
	a=a;
}

/*
 * Send multiple files.
 */
void
mput( int argc, char * argv[] )
{
	register int i;
	int ointer;
	void (*oldintr)();
	extern jmp_buf jabort;
	char *tp;
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(local-files) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s local-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT, mabort);
	(void) setjmp(jabort);
	if (proxy) {
		char *cp, *tp2, tmpbuf[MAXPATHLEN];
		while ((cp = remglob(argv,0)) != NULL) {
			if (*cp == 0) {
				mflag = 0;
				continue;
			}
			if (mflag && confirm(argv[0], cp)) {
				tp = cp;
				if (mcase) {
					while (*tp && !islower(*tp)) {
						tp++;
					}
					if (!*tp) {
						tp = cp;
						tp2 = tmpbuf;
						while ((*tp2 = *tp) != NULL) {
						     if (isupper(*tp2)) {
						        *tp2 = 'a' + *tp2 - 'A';
						     }
						     tp++;
						     tp2++;
						}
					}
					tp = tmpbuf;
				}
				if (ntflag) {
					tp = dotrans(tp);
				}
				if (mapflag) {
					tp = domap(tp);
				}
				sendrequest((sunique) ? "STOU" : "STOR", cp,tp);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with","mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
		}
		(void) signal(SIGINT, oldintr);
		mflag = 0;
		return;
	}
	for (i = 1; i < argc; i++) {
		register char **cpp, **gargs;
		if (!doglob) {
			if (mflag && confirm(argv[0], argv[i])) {
				tp = (ntflag) ? dotrans(argv[i]) : argv[i];
				tp = (mapflag) ? domap(tp) : tp;
				sendrequest((sunique) ? "STOU" : "STOR",
				            argv[i], tp);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with","mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
			continue;
		}
		gargs = glob(argv[i]);
		if (globerr != NULL) {
			printf("%s\n", globerr);
			if (gargs) {
				blkfree(gargs);
				free(gargs);
			}
			continue;
		}
		for (cpp = gargs; cpp && *cpp != NULL; cpp++) {
			if (mflag && confirm(argv[0], *cpp)) {
				tp = (ntflag) ? dotrans(*cpp) : *cpp;
				tp = (mapflag) ? domap(tp) : tp;
				sendrequest((sunique) ? "STOU" : "STOR",
					   *cpp, tp);
				if (!mflag && fromatty) {
					ointer = interactive;
					interactive = 1;
					if (confirm("Continue with","mput")) {
						mflag++;
					}
					interactive = ointer;
				}
			}
		}
		if (gargs != NULL) {
			blkfree(gargs);
			free(gargs);
		}
	}
	(void) signal(SIGINT, oldintr);
	mflag = 0;
}


/*
 * Receive one file.
 */
void
get( int argc, char *  argv[] )
{
	int loc = 0;

	if (argc == 2) {
		argc++;
		argv[2] = argv[1];
		loc++;
	}
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
usage:
		printf("usage: %s remote-file [ local-file ]\n", argv[0]);
		code = -1;
		return;
	}
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(local-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) 
		goto usage;
	if (!globulize(&argv[2])) {
		code = -1;
		return;
	}
	if (loc && mcase) {
		char *tp = argv[1], *tp2, tmpbuf[MAXPATHLEN];

		while (*tp && !islower(*tp)) {
			tp++;
		}
		if (!*tp) {
			tp = argv[2];
			tp2 = tmpbuf;
			while ((*tp2 = *tp) != NULL) {
				if (isupper(*tp2)) {
					*tp2 = 'a' + *tp2 - 'A';
				}
				tp++;
				tp2++;
			}
			argv[2] = tmpbuf;
		}
	}
	if (loc && ntflag)
		argv[2] = dotrans(argv[2]);
	if (loc && mapflag)
		argv[2] = domap(argv[2]);
	
	recvrequest("RETR", argv[2], argv[1], "w");

	return;
}


/*
 * Get multiple files.
 */
void
mget( int argc, char * argv[] )
{
	char *cp, *tp, *tp2, tmpbuf[MAXPATHLEN];
	int ointer;
	void (*oldintr)();
	extern jmp_buf jabort;

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-files) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s remote-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT,mabort);
	(void) setjmp(jabort);

	while ((cp = remglob(argv,proxy)) != NULL) {
		if (*cp == '\0') {
			mflag = 0;
			continue;
		}
		if (mflag && confirm(argv[0], cp)) {
			tp = cp;
			if (mcase) {
				while (*tp && !islower(*tp)) {
					tp++;
				}
				if (!*tp) {
					tp = cp;
					tp2 = tmpbuf;
					while ((*tp2 = *tp) != NULL) {
						if (isupper(*tp2)) {
							*tp2 = 'a' + *tp2 - 'A';
						}
						tp++;
						tp2++;
					}
				}
				tp = tmpbuf;
			}
			if (ntflag) {
				tp = dotrans(tp);
			}
			if (mapflag) {
				tp = domap(tp);
			}
			recvrequest("RETR", tp, cp, "w");
			if (!mflag && fromatty) {
				ointer = interactive;
				interactive = 1;
				if (confirm("Continue with","mget")) {
					mflag++;
				}
				interactive = ointer;
			}
		}
	}

	(void) signal(SIGINT,oldintr);
	mflag = 0;
}

char *
remglob(char *argv[],
	int doswitch )
{
	static char temp[64];
	static char buf[MAXPATHLEN];
	static FILE *ftemp = NULL;
	static char **args;
	int oldverbose, oldhash;
	char *cp, *mode;

	if (!mflag) {
		if (!doglob) {
			args = NULL;
		}
		else {
			if (ftemp) {
				(void) fclose(ftemp);
				ftemp = NULL;
			}
		}
		return(NULL);
	}
	if (!doglob) {
		if (args == NULL)
			args = argv;
		if ((cp = *++args) == NULL)
			args = NULL;
		return (cp);
	}
	if (ftemp == NULL) {
#ifdef __STDC__
		tmpnam(temp);
#else
		(void) strcpy(temp, "/tmp/ftpXXXXXX");
		(void) mktemp(temp);
#endif
		oldverbose = verbose, verbose = 0;
		oldhash = hash, hash = 0;
		
		if (doswitch) {
			pswitch(!proxy);
		}
		for (mode = "w"; *++argv != NULL; mode = "a") 
			recvrequest ("NLST", temp, *argv, mode);
		if (doswitch) {
			pswitch(!proxy);
		}

		verbose = oldverbose; hash = oldhash;
		ftemp = fopen(temp, "r");
#ifndef __HELIOS
		(void) unlink(temp);
#endif
		if (ftemp == NULL) {
			printf("can't find list of remote files, oopsy\n");
			return (NULL);
		}
	}
	if (fgets(buf, sizeof (buf), ftemp) == NULL) {
		(void) fclose(ftemp), ftemp = NULL;
#ifdef __HELIOS
		(void) unlink(temp);	/* Ensure tmp file deleted */
#endif
		return (NULL);
	}
	if ((cp = index(buf, '\n')) != NULL)
		*cp = '\0';
#ifdef __HELIOS
	if (feof(ftemp) || !strcmp(buf,"")) {/* Delete if EOF or Null reached */
		(void) unlink(temp);
	}
#endif
	return (buf);
}

char *
onoff( int on )
{

	return (on ? "on" : "off");
}

/*
 * Show status.
 */
/*ARGSUSED*/
void
status(int	     argc, char *     argv[] )
{
	int i;

	if (connected)
		printf("Connected to %s.\n", hostname);
	else
		printf("Not connected.\n");
	if (!proxy) {
		pswitch(1);
		if (connected) {
			printf("Connected for proxy commands to %s.\n", hostname);
		}
		else {
			printf("No proxy connection.\n");
		}
		pswitch(0);
	}
	printf("Mode: %s; Type: %s; Form: %s; Structure: %s\n",
		modename, typename, formname, structname);
	printf("Verbose: %s; Bell: %s; Prompting: %s; Globbing: %s\n", 
		onoff(verbose), onoff(bell), onoff(interactive),
		onoff(doglob));
	printf("Store unique: %s; Receive unique: %s\n", onoff(sunique),
		onoff(runique));
	printf("Case: %s; CR stripping: %s\n",onoff(mcase),onoff(crflag));
	if (ntflag) {
		printf("Ntrans: (in) %s (out) %s\n", ntin,ntout);
	}
	else {
		printf("Ntrans: off\n");
	}
	if (mapflag) {
		printf("Nmap: (in) %s (out) %s\n", mapin, mapout);
	}
	else {
		printf("Nmap: off\n");
	}
	printf("Hash mark printing: %s; Use of PORT cmds: %s\n",
		onoff(hash), onoff(sendport));
	if (macnum > 0) {
		printf("Macros:\n");
		for (i=0; i<macnum; i++) {
			printf("\t%s\n",macros[i].mac_name);
		}
	}
	code = 0;
}

/*
 * Set beep on cmd completed mode.
 */
/*VARARGS*/
void
setbell()
{

	bell = !bell;
	printf("Bell mode %s.\n", onoff(bell));
	code = bell;
}

/*
 * Turn on packet tracing.
 */
/*VARARGS*/
void
settrace()
{

	trace = !trace;
	printf("Packet tracing %s.\n", onoff(trace));
	code = trace;
}

/*
 * Toggle hash mark printing during transfers.
 */
/*VARARGS*/
void
sethash()
{

	hash = !hash;
	printf("Hash mark printing %s", onoff(hash));
	code = hash;
	if (hash)
		printf(" (%d bytes/hash mark)", BUFSIZ);
	printf(".\n");
}

/*
 * Turn on printing of server echo's.
 */
/*VARARGS*/
void
setverbose()
{

	verbose = !verbose;
	printf("Verbose mode %s.\n", onoff(verbose));
	code = verbose;
}

/*
 * Toggle PORT cmd use before each data connection.
 */
/*VARARGS*/
void
setport()
{

	sendport = !sendport;
	printf("Use of PORT cmds %s.\n", onoff(sendport));
	code = sendport;
}

/*
 * Turn on interactive prompting
 * during mget, mput, and mdelete.
 */
/*VARARGS*/
void
setprompt()
{

	interactive = !interactive;
	printf("Interactive mode %s.\n", onoff(interactive));
	code = interactive;
}

/*
 * Toggle metacharacter interpretation
 * on local file names.
 */
/*VARARGS*/
void
setglob()
{
	
	doglob = !doglob;
	printf("Globbing %s.\n", onoff(doglob));
	code = doglob;
}

/*
 * Set debugging mode on/off and/or
 * set level of debugging.
 */
/*VARARGS*/
void
setdebug(int	       argc, char *       argv[] )
{
	int val;

	if (argc > 1) {
		val = atoi(argv[1]);
		if (val < 0) {
			printf("%s: bad debugging value.\n", argv[1]);
			code = -1;
			return;
		}
	} else
		val = !debug;
	debug = val;
	if (debug)
		options |= SO_DEBUG;
	else
		options &= ~SO_DEBUG;
	printf("Debugging %s (debug=%d).\n", onoff(debug), debug);
	code = debug > 0;
}

/*
 * Set current working directory
 * on remote machine.
 */
void
cd(int	 argc, char * argv[] )
{

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-directory) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s remote-directory\n", argv[0]);
		code = -1;
		return;
	}
	(void) command("CWD %s", argv[1]);
}

/*
 * Set current working directory
 * on local machine.
 */
void
lcd(int	  argc, char *  argv[] )
{
	char buf[MAXPATHLEN];

	if (argc < 2)
		argc++, argv[1] = home;
	if (argc != 2) {
		printf("usage:%s local-directory\n", argv[0]);
		code = -1;
		return;
	}
	if (!globulize(&argv[1])) {
		code = -1;
		return;
	}
	if (chdir(argv[1]) < 0) {
		perror(argv[1]);
		code = -1;
		return;
	}
	printf("Local directory now %s\n", getwd(buf));
	code = 0;
}

/*
 * Delete a single file.
 */
void
MyDelete(int	     argc, char *     argv[] )
{

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s remote-file\n", argv[0]);
		code = -1;
		return;
	}
	(void) command("DELE %s", argv[1]);
}

/*
 * Delete multiple files.
 */
void
mdelete(int	      argc, char *      argv[] )
{
	char *cp;
	int ointer;
	void (*oldintr)();
	extern jmp_buf jabort;

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-files) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s remote-files\n", argv[0]);
		code = -1;
		return;
	}
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT, mabort);
	(void) setjmp(jabort);
	while ((cp = remglob(argv,0)) != NULL) {
		if (*cp == '\0') {
			mflag = 0;
			continue;
		}
		if (mflag && confirm(argv[0], cp)) {
			(void) command("DELE %s", cp);
			if (!mflag && fromatty) {
				ointer = interactive;
				interactive = 1;
				if (confirm("Continue with", "mdelete")) {
					mflag++;
				}
				interactive = ointer;
			}
		}
	}
	(void) signal(SIGINT, oldintr);
	mflag = 0;
}

/*
 * Rename a remote file.
 */
void
renamefile(int		 argc, char *	 argv[] )
{

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(from-name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
usage:
		printf("%s from-name to-name\n", argv[0]);
		code = -1;
		return;
	}
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(to-name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) 
		goto usage;
	if (command("RNFR %s", argv[1]) == CONTINUE)
		(void) command("RNTO %s", argv[2]);
}

/*
 * Get a directory listing
 * of remote files.
 */
void
ls(int	 argc, char * argv[] )
{
	char *cmd;

	if (argc < 2)
		argc++, argv[1] = NULL;
	if (argc < 3)
		argc++, argv[2] = "-";
	if (argc > 3) {
		printf("usage: %s remote-directory local-file\n", argv[0]);
		code = -1;
		return;
	}
	cmd = argv[0][0] == 'n' ? "NLST" : "LIST";
	if (strcmp(argv[2], "-") && !globulize(&argv[2])) {
		code = -1;
		return;
	}
	if (strcmp(argv[2], "-") && *argv[2] != '|')
		if (!globulize(&argv[2]) || !confirm("output to local-file:", argv[2])) {
			code = -1;
			return;
	}
	recvrequest(cmd, argv[2], argv[1], "w");
}

/*
 * Get a directory listing
 * of multiple remote files.
 */
void
mls(int	  argc, char *  argv[] )
{
	char *cmd, mode[1], *dest;
	int ointer, i;
	void (*oldintr)();
	extern jmp_buf jabort;

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(remote-files) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(local-file) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) {
		printf("usage:%s remote-files local-file\n", argv[0]);
		code = -1;
		return;
	}
	dest = argv[argc - 1];
	argv[argc - 1] = NULL;
	if (strcmp(dest, "-") && *dest != '|')
		if (!globulize(&dest) || !confirm("output to local-file:", dest)) {
			code = -1;
			return;
	}
	cmd = argv[0][1] == 'l' ? "NLST" : "LIST";
	mname = argv[0];
	mflag = 1;
	oldintr = signal(SIGINT, mabort);
	(void) setjmp(jabort);
	for (i = 1; mflag && i < argc-1; ++i) {
		*mode = (i == 1) ? 'w' : 'a';
		recvrequest(cmd, dest, argv[i], mode);
		if (!mflag && fromatty) {
			ointer = interactive;
			interactive = 1;
			if (confirm("Continue with", argv[0])) {
				mflag ++;
			}
			interactive = ointer;
		}
	}
	(void) signal(SIGINT, oldintr);
	mflag = 0;
}

/*
 * Do a shell escape
 */
/*ARGSUSED*/
int
shell(int	    argc, char *    argv[] )
{
	int pid;
	void (*old1)(), (*old2)();
	char shellnam[40], *shell, *namep; 
	union wait status;

	old1 = signal (SIGINT, SIG_IGN);
	old2 = signal (SIGQUIT, SIG_IGN);
	if ((pid = vfork()) == 0) {
		for (pid = 3; pid < 20; pid++)
			(void) close(pid);
		(void) signal(SIGINT, SIG_DFL);
		(void) signal(SIGQUIT, SIG_DFL);
		shell = getenv("SHELL");
		if (shell == NULL)
#ifdef __HELIOS
			shell = "/helios/bin/shell";
#else
			shell = "/bin/sh";
#endif
		namep = rindex(shell,'/');
		if (namep == NULL)
			namep = shell;
		(void) strcpy(shellnam,"-");
		(void) strcat(shellnam, ++namep);
		if (strcmp(namep, "sh") != 0)
			shellnam[0] = '+';
		if (debug) {
			printf ("%s\n", shell);
			(void) fflush (stdout);
		}
		if (argc > 1) {
			execl(shell,shellnam,"-c",altarg,(char *)0);
		}
		else {
			execl(shell,shellnam,(char *)0);
		}
		perror(shell);
		code = -1;
		exit(1);
		}
	if (pid > 0)
		while (wait((int *)&status) != pid)
			;
	(void) signal(SIGINT, old1);
	(void) signal(SIGQUIT, old2);
	if (pid == -1) {
		perror("Try again later");
		code = -1;
	}
	else {
		code = 0;
	}
	return (0);
}

/*
 * Send new user information (re-login)
 */
int
user(int argc,char **argv )
{
	char acct[80];
	int n, aflag = 0;

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(username) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc > 4) {
		printf("usage: %s username [password] [account]\n", argv[0]);
		code = -1;
		return (0);
	}
	n = command("USER %s", argv[1]);
	if (n == CONTINUE) {
		if (argc < 3 )
			argv[2] = getpass("Password: "), argc++;
		n = command("PASS %s", argv[2]);
	}
	if (n == CONTINUE) {
		if (argc < 4) {
			printf("Account: "); (void) fflush(stdout);
			(void) fgets(acct, sizeof(acct) - 1, stdin);
			acct[strlen(acct) - 1] = '\0';
			argv[3] = acct; argc++;
		}
		n = command("ACCT %s", argv[3]);
		aflag++;
	}
	if (n != COMPLETE) {
		fprintf(stdout, "Login failed.\n");
		return (0);
	}
	if (!aflag && argc == 4) {
		(void) command("ACCT %s", argv[3]);
	}
	return (1);
}

/*
 * Print working directory.
 */
void
pwd()
{

	(void) command("PWD");
}

/*
 * Make a directory.
 */
void
makedir(int argc, char *argv[] )
{

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(directory-name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage: %s directory-name\n", argv[0]);
		code = -1;
		return;
	}
	(void) command("MKD %s", argv[1]);
}

/*
 * Remove a directory.
 */
void
removedir(int	argc, char *argv[] )
{

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(directory-name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage: %s directory-name\n", argv[0]);
		code = -1;
		return;
	}
	(void) command("RMD %s", argv[1]);
}

/*
 * Send a line, verbatim, to the remote machine.
 */
void
quote(int argc, char *argv[] )
{
	int i;
	char buf[BUFSIZ];

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(command line to send) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage: %s line-to-send\n", argv[0]);
		code = -1;
		return;
	}
	(void) strcpy(buf, argv[1]);
	for (i = 2; i < argc; i++) {
		(void) strcat(buf, " ");
		(void) strcat(buf, argv[i]);
	}
	if (command(buf) == PRELIM) {
		while (getreply(0) == PRELIM);
	}
}

/*
 * Ask the other side for help.
 */
void
rmthelp(int argc, char *argv[] )
{
	int oldverbose = verbose;

	verbose = 1;
	(void) command(argc == 1 ? "HELP" : "HELP %s", argv[1]);
	verbose = oldverbose;
}

/*
 * Terminate session, but don't exit.
 */
void
disconnect()
{
	extern FILE *cout;
	extern int data;

	if (!connected)
		return;
	(void) command("QUIT");
	if (cout) {
		(void) fclose(cout);
	}
	cout = NULL;
	connected = 0;
	data = -1;
	if (!proxy) {
		macnum = 0;
	}
}


/*
 * Terminate session and exit.
 */
/*VARARGS*/
void
quit()
{

	if (connected)
		disconnect();
	pswitch(1);
	if (connected) {
		disconnect();
	}
	exit(0);
}


int
confirm(
	char *	cmd,
	char *	file )
{
	char line[BUFSIZ];

	if (!interactive)
		return (1);
	printf("%s %s? ", cmd, file);
	(void) fflush(stdout);
	(void) gets(line);
	return (*line != 'n' && *line != 'N');
}

void
fatal(char *msg)
{

	fprintf(stderr, "ftp: %s\n", msg);
	exit(1);
}

/*
 * Glob a local file name specification with
 * the expectation of a single return value.
 * Can't control multiple values being expanded
 * from the expression, we return only the first.
 */

int
globulize(char **cpp)
{
	char **globbed;

	if (!doglob)
		return (1);
	globbed = glob(*cpp);
	if (globerr != NULL) {
		printf("%s: %s\n", *cpp, globerr);
		if (globbed) {
			blkfree(globbed);
			free(globbed);
		}
		return (0);
	}
	if (globbed) {
		*cpp = *globbed++;
		/* don't waste too much memory */
		if (*globbed) {
			blkfree(globbed);
			free(globbed);
		}
	}
	return (1);
}

void
account(int argc,char **argv )
{
	char acct[50], *ap;

	if (argc > 1) {
		++argv;
		--argc;
		(void) strncpy(acct,*argv,49);
		acct[49] = '\0';
		while (argc > 1) {
			--argc;
			++argv;
			(void) strncat(acct,*argv, 49-strlen(acct));
		}
		ap = acct;
	}
	else {
		ap = getpass("Account:");
	}
	(void) command("ACCT %s", ap);
}

jmp_buf abortprox;

void
proxabort(int a)
{
	extern int proxy;

	if (!proxy) {
		pswitch(1);
	}
	if (connected) {
		proxflag = 1;
	}
	else {
		proxflag = 0;
	}
	pswitch(0);
	longjmp(abortprox,1);
}

void
doproxy(int argc,char *argv[] )
{
	void (*oldintr)();
	register struct cmd *c;
	struct cmd *getcmd( char *);
	extern jmp_buf abortprox;

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(command) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s command\n", argv[0]);
		code = -1;
		return;
	}
	c = getcmd(argv[1]);
	if (c == (struct cmd *) -1) {
		printf("?Ambiguous command\n");
		(void) fflush(stdout);
		code = -1;
		return;
	}
	if (c == 0) {
		printf("?Invalid command\n");
		(void) fflush(stdout);
		code = -1;
		return;
	}
	if (!c->c_proxy) {
		printf("?Invalid proxy command\n");
		(void) fflush(stdout);
		code = -1;
		return;
	}
	if (setjmp(abortprox)) {
		code = -1;
		return;
	}
	oldintr = signal(SIGINT, proxabort);
	pswitch(1);
	if (c->c_conn && !connected) {
		printf("Not connected\n");
		(void) fflush(stdout);
		pswitch(0);
		(void) signal(SIGINT, oldintr);
		code = -1;
		return;
	}
	(*c->c_handler)(argc-1, argv+1);
	if (connected) {
		proxflag = 1;
	}
	else {
		proxflag = 0;
	}
	pswitch(0);
	(void) signal(SIGINT, oldintr);
}

void
setcase()
{
	mcase = !mcase;
	printf("Case mapping %s.\n", onoff(mcase));
	code = mcase;
}

void
setcr()
{
	crflag = !crflag;
	printf("Carriage Return stripping %s.\n", onoff(crflag));
	code = crflag;
}

void
setntrans(int argc,char *argv[] )
{
	if (argc == 1) {
		ntflag = 0;
		printf("Ntrans off.\n");
		code = ntflag;
		return;
	}
	ntflag++;
	code = ntflag;
	(void) strncpy(ntin, argv[1], 16);
	ntin[16] = '\0';
	if (argc == 2) {
		ntout[0] = '\0';
		return;
	}
	(void) strncpy(ntout, argv[2], 16);
	ntout[16] = '\0';
}

char *
dotrans(char *name)
{
	static char New[MAXPATHLEN];
	char *cp1, *cp2 = New;
	register int i, ostop, found;

	for (ostop = 0; *(ntout + ostop) && ostop < 16; ostop++);
	for (cp1 = name; *cp1; cp1++) {
		found = 0;
		for (i = 0; *(ntin + i) && i < 16; i++) {
			if (*cp1 == *(ntin + i)) {
				found++;
				if (i < ostop) {
					*cp2++ = *(ntout + i);
				}
				break;
			}
		}
		if (!found) {
			*cp2++ = *cp1;
		}
	}
	*cp2 = '\0';
	return(New);
}

void
setnmap(int argc,char *argv[] )
{
	char *cp;

	if (argc == 1) {
		mapflag = 0;
		printf("Nmap off.\n");
		code = mapflag;
		return;
	}
	if (argc < 3) {
		(void) strcat(line, " ");
		printf("(mapout) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 3) {
		printf("Usage: %s [mapin mapout]\n",argv[0]);
		code = -1;
		return;
	}
	mapflag = 1;
	code = 1;
	cp = index(altarg, ' ');
	if (proxy) {
		while(*++cp == ' ');
		altarg = cp;
		cp = index(altarg, ' ');
	}
	*cp = '\0';
	(void) strncpy(mapin, altarg, MAXPATHLEN - 1);
	while (*++cp == ' ');
	(void) strncpy(mapout, cp, MAXPATHLEN - 1);
}

char *
domap(char *name)
{
	static char New[MAXPATHLEN];
	register char *cp1 = name, *cp2 = mapin;
	char *tp[9], *te[9];
	int i, toks[9], toknum = 0, match = 1;

	for (i=0; i < 9; ++i) {
		toks[i] = 0;
	}
	while (match && *cp1 && *cp2) {
		switch (*cp2) {
			case '\\':
				if (*++cp2 != *cp1) {
					match = 0;
				}
				break;
			case '$':
				if (*(cp2+1) >= '1' && (*cp2+1) <= '9') {
					if (*cp1 != *(++cp2+1)) {
						toks[toknum = *cp2 - '1']++;
						tp[toknum] = cp1;
						while (*++cp1 && *(cp2+1)
							!= *cp1);
						te[toknum] = cp1;
					}
					cp2++;
					break;
				}
				/* FALLTHROUGH */
			default:
				if (*cp2 != *cp1) {
					match = 0;
				}
				break;
		}
		if (match && *cp1) {
			cp1++;
		}
		if (match && *cp2) {
			cp2++;
		}
	}
	if (!match && *cp1) /* last token mismatch */
	{
		toks[toknum] = 0;
	}
	cp1 = New;
	*cp1 = '\0';
	cp2 = mapout;
	while (*cp2) {
		match = 0;
		switch (*cp2) {
			case '\\':
				if (*(cp2 + 1)) {
					*cp1++ = *++cp2;
				}
				break;
			case '[':
LOOP:
				if (*++cp2 == '$' && isdigit(*(cp2+1))) { 
					if (*++cp2 == '0') {
						char *cp3 = name;

						while (*cp3) {
							*cp1++ = *cp3++;
						}
						match = 1;
					}
					else if (toks[toknum = *cp2 - '1']) {
						char *cp3 = tp[toknum];

						while (cp3 != te[toknum]) {
							*cp1++ = *cp3++;
						}
						match = 1;
					}
				}
				else {
					while (*cp2 && *cp2 != ',' && 
					    *cp2 != ']') {
						if (*cp2 == '\\') {
							cp2++;
						}
						else if (*cp2 == '$' &&
   						        isdigit(*(cp2+1))) {
							if (*++cp2 == '0') {
							   char *cp3 = name;

							   while (*cp3) {
								*cp1++ = *cp3++;
							   }
							}
							else if (toks[toknum =
							    *cp2 - '1']) {
							   char *cp3=tp[toknum];

							   while (cp3 !=
								  te[toknum]) {
								*cp1++ = *cp3++;
							   }
							}
						}
						else if (*cp2) {
							*cp1++ = *cp2++;
						}
					}
					if (!*cp2) {
						printf("nmap: unbalanced brackets\n");
						return(name);
					}
					match = 1;
					cp2--;
				}
				if (match) {
					while (*++cp2 && *cp2 != ']') {
					      if (*cp2 == '\\' && *(cp2 + 1)) {
							cp2++;
					      }
					}
					if (!*cp2) {
						printf("nmap: unbalanced brackets\n");
						return(name);
					}
					break;
				}
				switch (*++cp2) {
					case ',':
						goto LOOP;
					case ']':
						break;
					default:
						cp2--;
						goto LOOP;
				}
				break;
			case '$':
				if (isdigit(*(cp2 + 1))) {
					if (*++cp2 == '0') {
						char *cp3 = name;

						while (*cp3) {
							*cp1++ = *cp3++;
						}
					}
					else if (toks[toknum = *cp2 - '1']) {
						char *cp3 = tp[toknum];

						while (cp3 != te[toknum]) {
							*cp1++ = *cp3++;
						}
					}
					break;
				}
				/* intentional drop through */
			default:
				*cp1++ = *cp2;
				break;
		}
		cp2++;
	}
	*cp1 = '\0';
	if (!*New) {
		return(name);
	}
	return(New);
}

void
setsunique()
{
	sunique = !sunique;
	printf("Store unique %s.\n", onoff(sunique));
	code = sunique;
}

void
setrunique()
{
	runique = !runique;
	printf("Receive unique %s.\n", onoff(runique));
	code = runique;
}

/* change directory to perent directory */

void
cdup()
{
	(void) command("CDUP");
}


/* show remote system type */
void
syst()
{
	(void) command("SYST");
}

void
macdef(int argc,char *argv[] )
{
	char *tmp;
	int c;

	if (macnum == 16) {
		printf("Limit of 16 macros have already been defined\n");
		code = -1;
		return;
	}
	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(macro name) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc != 2) {
		printf("Usage: %s macro_name\n",argv[0]);
		code = -1;
		return;
	}
	if (interactive) {
		printf("Enter macro line by line, terminating it with a null line\n");
	}
	(void) strncpy(macros[macnum].mac_name, argv[1], 8);
	if (macnum == 0) {
		macros[macnum].mac_start = macbuf;
	}
	else {
		macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
	}
	tmp = macros[macnum].mac_start;
	while (tmp != macbuf+4096) {
		if ((c = getchar()) == EOF) {
			printf("macdef:end of file encountered\n");
			code = -1;
			return;
		}
		if ((*tmp = c) == '\n') {
			if (tmp == macros[macnum].mac_start) {
				macros[macnum++].mac_end = tmp;
				code = 0;
				return;
			}
			if (*(tmp-1) == '\0') {
				macros[macnum++].mac_end = tmp - 1;
				code = 0;
				return;
			}
			*tmp = '\0';
		}
		tmp++;
	}
	while (1) {
		while ((c = getchar()) != '\n' && c != EOF)
			/* LOOP */;
		if (c == EOF || getchar() == '\n') {
			printf("Macro not defined - 4k buffer exceeded\n");
			code = -1;
			return;
		}
	}
}

/*
 * get size of file on remote machine
 */
void
sizecmd(int argc, char *argv[] )
{

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(filename) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s filename\n", argv[0]);
		code = -1;
		return;
	}
	(void) command("SIZE %s", argv[1]);
}

/*
 * get last modification time of file on remote machine
 */
void
modtime(int argc, char *argv[] )
{
	int overbose;

	if (argc < 2) {
		(void) strcat(line, " ");
		printf("(filename) ");
		(void) gets(&line[strlen(line)]);
		makeargv();
		argc = margc;
		argv = margv;
	}
	if (argc < 2) {
		printf("usage:%s filename\n", argv[0]);
		code = -1;
		return;
	}
	overbose = verbose;
	if (debug == 0)
		verbose = -1;
	if (command("MDTM %s", argv[1]) == COMPLETE) {
		int yy, mo, day, hour, min, sec;
		sscanf(reply_string, "%*s %04d%02d%02d%02d%02d%02d", &yy, &mo,
			&day, &hour, &min, &sec);
		/* might want to print this in local time */
		printf("%s\t%02d/%02d/%04d %02d:%02d:%02d GMT\n", argv[1],
			mo, day, yy, hour, min, sec);
	} else
		fputs(reply_string, stdout);
	verbose = overbose;
}

/*
 * show status on remote machine
 */
void
rmtstatus(int argc, char *argv[] )
{
	(void) command(argc > 1 ? "STAT %s" : "STAT" , argv[1]);
}
@


1.7
log
@fixed compile time warnings
@
text
@d94 1
a94 3
setpeer(argc, argv)  
	int argc;
	char *argv[];
d213 1
a213 3
settype(argc, argv)
  int	      argc;  
  char *      argv[];
d304 1
a304 3
setmode(argc, argv)
  int	      argc;
  char *      argv[];
d321 1
a321 3
setform(argc, argv)
  int	      argc;  
  char *      argv[];
d337 1
a337 3
setstruct(argc, argv)
  int		argc;  
  char *	argv[];
d353 1
a353 3
put(argc, argv)
	int argc;
	char *argv[];
d436 1
a436 3
mput(argc, argv)
  int	   argc;  
  char *   argv[];
d565 1
a565 3
get(argc, argv)
  int	  argc;  
  char *  argv[];
d636 1
a636 3
mget(argc, argv)
  int	   argc;  
  char *   argv[];
d708 2
a709 3
remglob(argv,doswitch)
	char *argv[];
	int doswitch;
d784 1
a784 2
onoff( on )
	int on;
d795 1
a795 3
status(argc, argv)
  int	     argc;
  char *     argv[];
d946 1
a946 3
setdebug(argc, argv)
  int	       argc;
  char *       argv[];
d973 1
a973 3
cd(argc, argv)
  int	 argc;  
  char * argv[];
d997 1
a997 3
lcd(argc, argv)
  int	  argc;
  char *  argv[];
d1025 1
a1025 3
MyDelete(argc, argv)
  int	     argc;
  char *     argv[];
d1048 1
a1048 3
mdelete(argc, argv)
  int	      argc;  
  char *      argv[];
d1097 1
a1097 3
renamefile(argc, argv)
  int		 argc;
  char *	 argv[];
d1133 1
a1133 3
ls(argc, argv)
  int	 argc;  
  char * argv[];
d1164 1
a1164 3
mls(argc, argv)
  int	  argc;
  char *  argv[];
d1225 1
a1225 3
shell(argc, argv)
  int	    argc;  
  char *    argv[];
d1286 1
a1286 3
user(argc, argv)
	int argc;
	char **argv;
d1344 1
a1344 3
makedir(argc, argv)
  int argc;  
  char *argv[];
d1367 1
a1367 3
removedir(argc, argv)
  int	argc;  
  char *argv[];
d1390 1
a1390 3
quote(argc, argv)
  int argc;  
  char *argv[];
d1422 1
a1422 3
rmthelp(argc, argv)
  int argc;
  char *argv[];
d1474 3
a1476 2
confirm(cmd, file)
	char *cmd, *file;
d1489 1
a1489 2
fatal(msg)
	char *msg;
d1504 1
a1504 2
globulize(cpp)
	char **cpp;
d1531 1
a1531 3
account(argc,argv)
	int argc;
	char **argv;
d1574 1
a1574 3
doproxy(argc,argv)
	int argc;
	char *argv[];
d1655 1
a1655 3
setntrans(argc,argv)
	int argc;
	char *argv[];
d1676 1
a1676 2
dotrans(name)
	char *name;
d1703 1
a1703 3
setnmap(argc, argv)
	int argc;
	char *argv[];
d1741 1
a1741 2
domap(name)
	char *name;
d1942 1
a1942 3
macdef(argc, argv)
	int argc;
	char *argv[];
d2012 1
a2012 3
sizecmd(argc, argv)
  int argc;  
  char *argv[];
d2035 1
a2035 3
modtime(argc, argv)
  int argc;
  char *argv[];
d2071 1
a2071 3
rmtstatus(argc, argv)
  int argc;
  char *argv[];
@


1.6
log
@fix for ARM port
@
text
@d1053 1
a1053 1
delete(argc, argv)
d1736 2
a1737 2
	static char new[MAXPATHLEN];
	char *cp1, *cp2 = new;
d1757 1
a1757 1
	return(new);
d1804 1
a1804 1
	static char new[MAXPATHLEN];
d1849 1
a1849 1
	cp1 = new;
d1964 1
a1964 1
	if (!*new) {
d1967 1
a1967 1
	return(new);
@


1.5
log
@removed compiler warnings
@
text
@d45 4
@


1.4
log
@fixed compiler detected errors
@
text
@d41 2
d58 1
d60 1
a60 4
extern char **	glob();
extern char *	home;
extern char *	remglob();
extern char *	getenv();
d62 21
a82 1

a83 3
char *mname;
jmp_buf jabort;
char *dotrans(), *domap();
d94 2
a95 1
	char *host, *hookup();
d98 10
a107 7
	if (connected) {
		printf("Already connected to %s, use close first.\n",
			hostname);
		code = -1;
		return;
	}
	if (argc < 2) {
d114 2
a115 1
	}
d121 1
d123 3
a125 1
	if (argc > 2) {
d127 3
a129 1
		if (port <= 0) {
d137 1
d139 7
a145 3
	if (host) {
		connected = 1;
		if (autologin) {
d147 1
a147 1
			int overbose;
d150 2
a151 1
			(void) login(argv[1]);
d418 22
d450 1
a450 1
	void (*oldintr)(), mabort();
d637 1
d639 2
a642 20
void
mabort()
{
	int ointer;
	extern jmp_buf jabort;

	printf("\n");
	(void) fflush(stdout);
	if (mflag && fromatty) {
		ointer = interactive;
		interactive = 1;
		if (confirm("Continue with", mname)) {
			interactive = ointer;
			longjmp(jabort,0);
		}
		interactive = ointer;
	}
	mflag = 0;
	longjmp(jabort,0);
}
d654 1
a654 1
	void (*oldintr)(), mabort();
a655 1
	int i;
d1080 1
a1080 1
	void (*oldintr)(), mabort();
d1202 1
a1202 1
	void (*oldintr)(), mabort();
d1277 3
d1281 1
d1326 1
a1326 1
	char acct[80], *getpass();
d1582 1
a1582 1
	char acct[50], *getpass(), *ap;
@


1.3
log
@ifdef __HELIOS added for deletion correction (Deleting file before it has
been fully read - MSDOS and HELIOS complain).
Also if a null string is encountered, the tmp file is deleted since
the EOF wont be reached and the mget/mput terminate, leaving the tmp
file in the tmp directory.  If the /helios/tmp directory is not cleared
regularly, this gets quite messy.  Also the char temp[] was made static
to preserve the file name for eventual deletion.
@
text
@d18 1
a18 1
#ifndef lint
d54 2
a55 6
extern	char *globerr;
extern	char **glob();
extern	char *home;
extern	char *remglob();
extern	char *getenv();
extern char reply_string[];
d57 7
d72 2
a73 1
setpeer(argc, argv)
d114 1
d116 2
a117 1

d177 1
d179 2
a180 1
	char *argv[];
d226 1
d237 1
d248 1
d259 1
d270 1
d272 2
a273 1
	char *argv[];
d276 7
a282 2
	printf("We only support %s mode, sorry.\n", modename);
	code = -1;
d289 1
d291 2
a292 1
	char *argv[];
d294 4
d299 2
a300 2
	printf("We only support %s format, sorry.\n", formname);
	code = -1;
d307 1
d309 2
a310 1
	char *argv[];
d315 5
d325 1
d388 1
d390 2
a391 1
	char *argv[];
d394 2
a395 1
	int ointer, (*oldintr)(), mabort();
d519 1
d521 2
a522 1
	char *argv[];
d585 1
d609 1
d611 2
a612 1
	char *argv[];
d615 2
a616 1
	int ointer, (*oldintr)(), mabort();
d762 2
a763 2
onoff(bool)
	int bool;
d766 1
a766 1
	return (bool ? "on" : "off");
d773 1
d775 2
a776 1
	char *argv[];
d829 1
d842 1
d855 1
d871 1
d884 1
d898 1
d912 1
d926 1
d928 2
a929 1
	char *argv[];
d955 1
d957 2
a958 1
	char *argv[];
d981 1
d983 2
a984 1
	char *argv[];
d1011 1
d1013 2
a1014 1
	char *argv[];
d1036 1
d1038 2
a1039 1
	char *argv[];
d1042 2
a1043 1
	int ointer, (*oldintr)(), mabort();
d1087 1
d1089 2
a1090 1
	char *argv[];
d1125 1
d1127 2
a1128 1
	char *argv[];
d1158 1
d1160 2
a1161 1
	char *argv[];
d1164 2
a1165 1
	int ointer, i, (*oldintr)(), mabort();
d1221 1
d1223 2
a1224 1
	char *argv[];
d1226 2
a1227 1
	int pid, (*old1)(), (*old2)();
d1263 1
a1263 1
		while (wait(&status) != pid)
d1280 1
d1330 1
a1330 1
/*VARARGS*/
d1340 1
d1342 2
a1343 1
	char *argv[];
d1365 1
d1367 2
a1368 1
	char *argv[];
d1390 1
d1392 2
a1393 1
	char *argv[];
d1424 1
d1426 2
a1427 1
	char *argv[];
a1436 16
 * Terminate session and exit.
 */
/*VARARGS*/
quit()
{

	if (connected)
		disconnect();
	pswitch(1);
	if (connected) {
		disconnect();
	}
	exit(0);
}

/*
d1439 1
d1459 20
d1492 1
d1507 2
d1536 1
d1563 2
a1564 1
proxabort()
d1581 1
d1586 1
a1586 1
	int (*oldintr)(), proxabort();
d1588 1
a1588 2
	struct cmd *getcmd();
	extern struct cmd cmdtab[];
d1648 1
d1656 1
d1664 1
d1715 1
d1925 1
d1933 1
d1942 2
d1951 1
d1957 1
d2029 1
d2031 2
a2032 1
	char *argv[];
d2054 1
d2056 2
a2057 1
	char *argv[];
d2092 1
d2094 2
a2095 1
	char *argv[];
@


1.2
log
@When dealing with multiple files (MGET, MPUT etc) the temporary file used
to store each file name found matching the arguments was deleted
before it was finished being read.  This caused problems under DOS.
The fix was to actually delete the temporary file once the end of the file
had been reached, and not before as previosly implemented.
@
text
@d647 1
a647 1
	char temp[64];
d694 3
a696 1
		/* (void) unlink(temp); */
d704 3
d709 4
a712 1
	if (feof(ftemp)) {               /*  Only delete if EOF reached */
d715 1
a715 4

	if ((cp = index(buf, '\n')) != NULL)
		*cp = '\0';
	
@


1.1
log
@Initial revision
@
text
@a650 1
	static int delflag = 0;		/* Added for DOS compatability -AMS */
d694 1
a694 1
		delflag = 1;   /* (void) unlink(temp); */
d704 1
a704 1
	if (delflag) {			/* Delete after file read */
a705 1
		delflag=0;
d707 1
@
