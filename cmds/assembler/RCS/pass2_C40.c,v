head	1.7;
access;
symbols
	Helios_1_3_1:1.7
	Helios_C40_1_3_Official_Release:1.6
	Alenia_release:1.6
	C40_Field_Test_2:1.5;
locks; strict;
comment	@ * @;


1.7
date	93.06.22.16.58.53;	author paul;	state Exp;
branches;
next	1.6;

1.6
date	92.10.24.17.27.42;	author craig;	state Exp;
branches;
next	1.5;

1.5
date	92.10.11.16.37.17;	author craig;	state Exp;
branches;
next	1.4;

1.4
date	92.10.05.17.15.51;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	92.09.02.18.20.01;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	92.07.21.09.23.01;	author paul;	state Exp;
branches;
next	1.1;

1.1
date	92.03.12.21.16.01;	author paul;	state Exp;
branches;
next	;


desc
@@


1.7
log
@integrated latest ARM assembler with C40 - made floting point support
generic. ARM compiler has various fixes and ARM6 mneumonic support
@
text
@/*
 * File:	pass2_C40.c
 * Author:	P.A.Beskeen
 * Date:	Sept '91
 *
 * Description: This module implements pass two of the 'C40 assembler. The
 *		Pass2 function is passed the instruction structure that the
 *		first pass of the 'C40 assembler produced. It uses the
 *		WriteCodeByte/Short/Word() functions to pass the fully
 *		assembled instruction binary on to the object code specific
 *		formatter. This allows the second pass to be used with
 *		different object code formats.
 *
 * RcsId: $Id: pass2_C40.c,v 1.6 1992/10/24 17:27:42 craig Exp paul $
 *
 * (C) Copyright 1991 Perihelion Software Ltd.
 * 
 * $RcsLog$
 *
 */

/* Include Files: */

#include "gasm.h"
#include "ghof.h"
#include <stdio.h>


/* print fatal error and exit */

void FatalNullExpr(void)
{
	Fatal("NULL indirect immediate displacement value");
}


/****************************************************************/
/* Pass2							*/
/*								*/
/* Execute 'C40 second pass on an instruction.			*/
/* The Instruction structure was created by the first pass 'C40	*/
/* specific parser. This parser noted where instructions had	*/
/* to have delayed evaluation expression operands evaluated,	*/
/* what limit checks to perform and where to insert the		*/
/* resulting value into the binary instruction.			*/
/* optexpr and combine define the first operand that the parser	*/
/* saw, and optexpr2 and combine2 hold any second operand.	*/
/*								*/
/****************************************************************/

/* @@@@@@ can probably coalesce the processing of the indirect 1/0	*/
/* style combine commands */

void Pass2(Instruction *instr, int pc)
{
	Expression	*expr = instr->optexpr;
	int		opcode = instr->opcode;
	int		result = 0;

	if (instr->combine == 0) {
		/* no post processesing required */
		/* pass opcode straight to the object formatter */
		WriteCodeWord(opcode);
		return;
	}

	switch (instr->combine) {

	/* diadic combine commands					*/
	/* All these commands will only use combine, NOT combine2	*/

	/* Register addressing doesn't need to be checked		*/
	case COM_DIA_REG:
		/* do nothing */
		break;

	/* Check signed immediate <= 16 bits and insert int bits 0-15	*/
	case COM_DIA_IMM:
		result = Eval(expr, pc);
		if (!fits_in_16_bits(result)) {
			char Err[80];

			sprintf(Err, "signed immediate value (%d) will not fit in 16 bits", result);
			Error(Err);
		}
		opcode |= result & 0xffff;
		break;

	/* Check UNsigned immediate <= 16 bits and insert int bits 0-15	*/
	case COM_DIA_IMM_UNSIGNED:
		result = Eval(expr, pc);
		if (!fits_in_16_bits_unsigned(result)) {
			char Err[80];

			sprintf(Err, "unsigned immediate value (%#x) will not fit in 16 bits", result);
			Error(Err);
		}
		opcode |= result;
		break;

	/* Shift immediate >> 16 and insert int bits 0-15		*/
	case COM_DIA_IMM_LDP:
		opcode |= (Eval(expr, pc) >> 16) & 0xffff;
		break;

	/* Check unsigned disp <= 8 bits and insert into bits 0-7	*/
	case COM_DIA_IND:
		result = Eval(expr, pc);
		if (!fits_in_8_bits_unsigned(result)) {
			char Err[80];

			sprintf(Err, "unsigned indirect displacement (%d) is too large to be held in 8 bits", result);
			Error(Err);
		}

		opcode |= result;
		break;

	/* Check direct unsigned offset <= 16 bits and insert into bits 0-15 */
	case COM_DIA_DIR:
		result = Eval(expr, pc);
		if (!fits_in_16_bits_unsigned(result)) {
			char Err[80];

			sprintf(Err, "unsigned direct offset of (%d) cannot be held in 16 bits", result);
			Error(Err);
		}
		opcode |= result;
		break;

	/* Check signed immediate is <= 5 bits and insert into bits 16-20 */
	case COM_STIK_IMM:
		result = Eval(expr, pc);
		if (!fits_in_5_bits(result)) {
			char Err[80];

			sprintf(Err, "STIK signed immediate value (%d) cannot be held in 5 bits", result);
			Error(Err);
		}
		opcode |= (result & B_11111) << 16;
		break;


	/* triadic combine commands					*/
	/* Notes arg position by: _A1 = bits 0-7, _A2 = bits 8-15	*/

	/* Triadic type 1 indirect addressing, args 1 and 2		*/
	/* If instr->optexpr is NULL then there is no need to check the	*/
	/* displacement as it will be an index reg.			*/
	/* Check displacement is only 1 or 0.				*/
	/* If displacement is 0, then convert mod to 0b11000:		*/
	/*	(*+ARn(0) -> *ARn)					*/

	case COM_TRI_IND1_A1:		/* mod = bits 3-7 */
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~B_11111000) | B_11000000;
		}
		break;

	case COM_TRI_IND1_A2:		/* mod = bits 11-15 */
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~(B_11111000 << 8)) | (B_11000000 << 8);
		}
		break;

	/* Triadic type 2 indirect addressing, args 1 and 2		*/
	/* Check unsigned displacement is <= 5 bits and insert disp. 	*/
	/* into bits 11-15 or 3-7					*/

	case COM_TRI_IND2_A1:		/* bits 3-7 */
		if (expr != NULL) {
			result = Eval(expr, pc);
			if (!fits_in_5_bits_unsigned(result)) {
				char Err[80];

				sprintf(Err, "indirect displacement value (%d) cannot be held in 5 bits", result);
				Error(Err);
			}

#if 0	/* @@@@@@ opt syntax #4 - would also have to convert T field */
			if (result == 0) {
				/* convert to a type 1, *ARn type indirection */
				/* preserving ARn - opt syntax #4 */
				opcode = ((opcode & ~TRI_TYPE_2) & ~B_11111000) | B_11000000;
			}
			else
#endif
				/* insert 5bit displacement into mod field */
				opcode = (opcode & ~B_11111000) | (result << 3);
		}
		else
			FatalNullExpr();
		break;
	
	case COM_TRI_IND2_A2:		/* bits 11-15 */
		if (expr != NULL) {
			result = Eval(expr, pc);
			if (!fits_in_5_bits_unsigned(result)) {
				char Err[80];

				sprintf(Err, "unsigned indirect displacement value (%d) cannot be held in 5 bits", result);
				Error(Err);
			}

#if 0	/* @@@@@@ opt syntax #4 - would also have to convert T field */
			if (result == 0) {
				/* convert to a type 1, *ARn type indirection */
				/* preserving ARn - opt syntax #4 */
				opcode = ((opcode & ~TRI_TYPE_2) & ~(B_11111000 << 8)) | (B_11000000 << 8);
			}
			else
#endif
				opcode = (opcode & ~(B_11111000 << 8)) | (result << 11);
		}
		else
			FatalNullExpr();
		break;
	
	/* Triadic type 2 immediate addressing, arg 1 only		*/
	/* Check immediate <= eight bits and insert into bits 0-7 of	*/
	/* instruction.							*/

	case COM_TRI_IMM_A1:
		if (expr != NULL) {
			result = Eval(expr, pc);
			if (!fits_in_8_bits(result)) {
				char Err[80];

				sprintf(Err, "signed immediate value (%d) cannot be held in 8 bits", result);
				Error(Err);
			}
			opcode |= (result & 0xff);
		}
		break;

	case COM_TRI_IMM_A1_UNSIGNED:
		if (expr != NULL) {
			result = Eval(expr, pc);
			if (!fits_in_8_bits_unsigned(result)) {
				char Err[80];

				sprintf(Err, "unsigned immediate value (%d) cannot be held in 8 bits", result);
				Error(Err);
			}
			opcode |= result;
		}
		break;
	
	/* parallel store combine commands				*/
	/* Check displacement is only 1 or 0, If displacement is 0,	*/
	/* then convert mod to 0b11000 (*+ARn(0) -> *ARn)		*/

	case COM_PST_IND_S1:	/* 1st src operand: mod = bits 3-7	*/
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~B_11111000) | B_11000000;
		}
		break;

	case COM_PST_IND_D2:	/* Store dest operand: mod = bits 11-15	*/
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~(B_11111000 << 8)) | (B_11000000 << 8);
		}
		break;

	/* parallel multiply add/sub combine commands			*/
	/* Check displacement is only 1 or 0, If displacement is 0, 	*/
	/* then convert mod to 0b11000 (*+ARn(0) -> *ARn)		*/

	case COM_PMPY_IND1:	/* mod bits 11-15 */
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~(B_11111000 << 8)) | (B_11000000 << 8);
		}
		break;

	case COM_PMPY_IND2:	/* mod bits 3-7 */
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~B_11111000) | B_11000000;
		}
		break;


	/* branch combine commands					*/

	/* If operation is a delayed branch then subtract 3 from the	*/
	/* offset before inserting it into the instruction, otherwise	*/
	/* subtract 1. These combine commands will only ever occur in	*/
	/* the first ->combine						*/

	/* Check PC relative offset <= 16 bits and insert into 		*/
	/* bits 0-15. Used in conditional branch instructions.		*/
	/* Bit 21 specifies if it is a delayed branch.			*/

	case COM_CBR_PCREL:	/* default for pcrel mode */
		/* pipeline adjustment for normal or delayed branch */
		if ( opcode & (1 << 21))
			result = -3;
		else
			result = -1;

		if (expr->what == E_Str) { /* possible imported label ? */
			Symbol *s = FindSymb(expr->type.name);

			if (s != NULL && s->what == HT_IMPORT) {
				/* output instruction with codestub patch */

				FlushCodeBuffer();

				/* assume word sized instruction */
				GHOFEncode(GHOF_WORD);

				/* output the machine specific patch */
				GHOFEncode(PATCH_C40MASK16ADD);

				/* output the assembled instruction as the */
				/* patches data */
				opcode |= result & 0xffff;
				GHOFEncode(opcode);

				/* For the C40 we have to shift the labelref */
				/* value to a word pointer */
				GHOFEncode(PATCH_SHIFT);
				GHOFEncode(-2);

				/* Other machines may use labelrefs if they */
				/* have not implemented linker codestubs */
				GHOFEncode(GHOF_CODESTUB);
				ObjWrite(s->name, strlen(s->name)+1);

				return;
			}
		}

		result += Eval(expr, pc);

		if (!fits_in_16_bits(result)) {
			char Err[80];

			sprintf(Err,"pc relative offset (%#x) is larger than can be held in 16 bits", result);
			Error(Err);
		}

		opcode |= result & 0xffff;
		break;

	/* Check PC relative offset < 24 bits and insert into bits 0-23 */
	/* Used in UNconditional branch instructions and RPTB(D) */
	/* Bit 24 specifies if it is a delayed branch */
	case COM_BR_PCREL:
		if ( opcode & (1 << 24))
			result = -3;
		else
			result = -1;

		if (expr->what == E_Str) { /* possible imported label ? */
		/* pipeline adjustment for normal or delayed branch */
			Symbol *s = FindSymb(expr->type.name);

			if (s != NULL && s->what == HT_IMPORT) {
				/* output instruction with codestub patch */

				FlushCodeBuffer();

				/* assume word sized instruction */
				GHOFEncode(GHOF_WORD);

				/* output the machine specific patch */
				GHOFEncode(PATCH_C40MASK24ADD);

				/* output the assembled instruction as the */
				/* patches data */
				opcode |= result & 0xffffff;
				GHOFEncode(opcode);

				/* For the C40 we have to shift the labelref */
				/* value to a word pointer */
				GHOFEncode(PATCH_SHIFT);
				GHOFEncode(-2);

				/* Other machines may use labelrefs if they */
				/* have not implemented linker codestubs */
				GHOFEncode(GHOF_CODESTUB);
				ObjWrite(s->name, strlen(s->name)+1);

				return;
			}
		}

		result += Eval(expr, pc);

		if (!fits_in_24_bits(result)) {
			char Err[80];

			sprintf(Err, "pc relative offset (%#x) is larger than can be held in 24 bits", result);
			Error(Err);
		}

		opcode |= result & 0x00ffffff;
		break;

	/* Check immediate value is <= 9 bits and insert into bits 0-8 */
	case COM_TRAP:
		if ((result = Eval(expr, pc)) & ~(B_111111111))
			Error("cannot have a trap vector higher than 511");

		opcode |= result;
		break;

	default:
		{
			char Err[80];

			sprintf(Err, "Unknown combine 1 command (%d) in second pass", \
				instr->combine);
			Fatal(Err);
			break;
		}
	}


	if (instr->combine2 == 0) {
		/* no second operand to post process */
		/* pass opcode on to the object formatter */
		WriteCodeWord(opcode);
		return;
	}

	/* now check for combine commands on a second operand */
	expr = instr->optexpr2;

	switch (instr->combine2) {

	/* triadic combine commands					*/
	/* Notes arg position by: _A1 = bits 0-7, _A2 = bits 8-15	*/

	/* Triadic type 1 indirect addressing, args 1 and 2		*/
	/* Check displacement is only 1 or 0.				*/
	/* If displacement is 0, then convert mod to 0b11000:		*/
	/*	(*+ARn(0) -> *ARn)					*/

	case COM_TRI_IND1_A1:		/* mod = bits 3-7 */
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~B_11111000) | B_11000000;
		}
		break;

	case COM_TRI_IND1_A2:		/* mod = bits 11-15 */
		if (expr != NULL) {
			if ((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~(B_11111000 << 8)) | (B_11000000 << 8);
		}
		break;

	/* Triadic type 2 indirect addressing, args 1 and 2		*/
	/* Check displacement is <= 5 bits and insert disp. into	*/
	/* bits 11-15 or 3-7						*/

	case COM_TRI_IND2_A1:		/* bits 3-7 */
		if (expr != NULL) {
			result = Eval(expr, pc);
			if (!fits_in_5_bits_unsigned(result)) {
				char Err[80];

				sprintf(Err, "indirect displacement value (%d) cannot be held in 5 bits", result);
				Error(Err);
			}

#if 0	/* would also have to convert T field */
			if (result == 0) {
				/* convert to a type 1, *ARn type indirection */
				/* preserving ARn - opt syntax #4 */
				opcode = ((opcode & ~TRI_TYPE_2) & ~B_11111000) | B_11000000;
			}
			else
#endif
				opcode = (opcode & ~B_11111000) | (result << 3);
		}
		else
			FatalNullExpr();
		break;

	case COM_TRI_IND2_A2:		/* bits 11-15 */
		if (expr != NULL) {
			result = Eval(expr, pc);
			if (!fits_in_5_bits_unsigned(result)) {
				char Err[80];

				sprintf(Err, "indirect displacement value (%d) will not fit into 5 bits", result);
				Error(Err);
			}

#if 0	/* would also have to convert T field */
			if (result == 0) {
				/* convert to a type 1, *ARn type indirection */
				/* preserving ARn - opt syntax #4 */
				opcode = ((opcode & ~TRI_TYPE_2) & ~(B_11111000 << 8)) | (B_11000000 << 8);
			}
			else
#endif
				opcode = (opcode & ~(B_11111000 << 8)) | (result << 11);
		}
		else
			FatalNullExpr();
		break;


	/* parallel store combine commands				*/
	/* Check displacement is only 1 or 0, If displacement is 0,	*/
	/* then convert mod to 0b11000 (*+ARn(0) -> *ARn)		*/

	case COM_PST_IND_S1:	/* 1st src operand: mod = bits 3-7	*/
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~B_11111000) | B_11000000;
		}
		break;

	case COM_PST_IND_D2:	/* Store dest operand: mod = bits 11-15	*/
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~(B_11111000 << 8)) | (B_11000000 << 8);
		}
		break;

	/* parallel multiply add/sub combine commands			*/
	/* Check displacement is only 1 or 0, If displacement is 0, 	*/
	/* then convert mod to 0b11000 (*+ARn(0) -> *ARn)		*/

	case COM_PMPY_IND1:	/* mod bits 11-15 */
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~B_11111000) | B_11000000;
		}
		break;

	case COM_PMPY_IND2:	/* mod bits 3-7 */
		if (expr != NULL) {
			if((result = Eval(expr, pc)) > 1 || result < 0)
				Error("indirect displacement value should only be 1 or 0");

			if (result == 0)
				/* convert to a *ARn type indirection preserving ARn */
				opcode = (opcode & ~(B_11111000 << 8)) | (B_11000000 << 8);
		}
		break;

	/* Following two commands should only get into second combine */
	/* if used with a STIK instruction */
	/* Check unsigned disp <= 8 bits and insert into bits 0-7	*/
	case COM_DIA_IND:
		result = Eval(expr, pc);
		if (!fits_in_8_bits_unsigned(result)) {
			char Err[80];

			sprintf(Err, "indirect displacement of (%d) will not fit into 8 bits", result);
			Error(Err);
		}

		opcode |= result;
		break;


	/* Check direct unsigned offset <= 16 bits and insert into bits 0-15 */
	case COM_DIA_DIR:
		result = Eval(expr, pc);
		if (!fits_in_16_bits_unsigned(result)) {
			char Err[128];
			sprintf(Err, "direct offset of (%d) cannot be held in 16 bits", result);
			Error(Err);
		}
		opcode |= result;
		break;

	default:
		{
			char Err[80];

			sprintf(Err, "Unknown combine 2 command (%d) in second pass", \
				instr->combine2);
			Fatal(Err);
			break;
		}
	}

	/* pass opcode on to the object formatter */
	WriteCodeWord(opcode);
}


/*
-- Floating point conversion routines
--
-- crf: October 1992
--
-- @@@@@@ 
-- Note: Conversion from higher- to lower-precision representations 
-- (e.g. C40_32 --> C40_16) does not currently perform any rounding.
-- The sequence of conversion in getting to a short (16 bit) representation
-- is :
--        (round)		      (truncate)
-- IEEE_64  --->  IEEE_32  --->  C40_32  --->  C40_16
-- The above rounding and truncating should preferably be swapped around :
--       (truncate)		       (round)
-- IEEE_64  --->  IEEE_32  --->  C40_32  --->  C40_16
-- Whether this is really necessary is debatable ...
-- @@@@@@ 
*/

/* extract components */

#define EXTRACT_C40_32			\
	e = (val >> 24) & 0xff ;	\
	s = (val >> 23) & 1 ;		\
	f = val & ((1 << 23) - 1)

#define EXTRACT_IEEE_32			\
	e = (val >> 23) & 0xff ;	\
	s = (val >> 31) & 1 ;		\
	f = val & ((1 << 23) - 1)

/* build number from components */

#define BUILD_C40_32	\
	((e << 24) | (s << 23) | (f & ((1 << 23) - 1)))
	
#define BUILD_C40_16	\
	((e << 12) | (s << 11) | (f & ((1 << 11) - 1))) & 0x0000ffff

/*
-- 32 bit C40 --> 16 bit C40
*/

int32 C40_32ToC40_16 (int32 val)
{
	int32 e ;
	int32 f ;
	int32 s ;

	EXTRACT_C40_32 ;

/*
-- If the C40_32 value passed in is zero, have to catch it here and return
-- the short (C40_16) reprentation
-- 0 (C40_32): e = -128, s = 0, f = 0
-- 0 (C40_16): e = -8, s = 0, f = 0
*/
	if (e == 0x80 && s == 0 && f == 0)
	{
		e = 0x8 ;
		return BUILD_C40_16 ;
	}

	if ((int8) e > 7)
		Fatal ("value too large to represent in short floating point format") ;

	if ((int8) e < -7)
	{
		Warn ("small floating point value converted to 0.0") ;
		e = 0x8 ; s = 0 ; f = 0 ;
		return BUILD_C40_16 ;
	}

	e = e & 0x0f ;
	f = f >> 12 ;
	return BUILD_C40_16 ;
}

/*
-- 32 bit IEEE --> 32 bit C40
*/

#ifdef HOST_SUPPORTS_IEEE
int32 IEEE_32ToC40_32 (float flt)
#else
int32 IEEE_32ToC40_32 (int32 val)
#endif
{
	int32 e ;
	int32 f ;
	int32 s ;

#ifdef HOST_SUPPORTS_IEEE
	int32 val ;
	union {
		int32 w ;
		float f ;
	} fw ;

	fw.f = flt ;
	val = fw.w ;
#endif

	EXTRACT_IEEE_32 ;

	/* decode - this algorithm is taken from the TMS320C4x User's Guide, page 4-12 */
	
	if (e == 0xff)
	{
		if (s == 0)
		{
			e = 0x7f ;
			/* s = 0 ; */
			f = 0x7fffff ;
		}
		else
		{
			e = 0x7f ;
			/* s = 1 ; */
			f = 0 ;
		}
	}
	else if (e == 0)
	{
		e = 0x80 ;
		s = 0 ;
		f = 0 ;
	}
	else
	{
		if (s == 0)
			e -= 0x7f ; /* s = 0 ; f = f ; */
		else
		{
			if (f == 0)
				e -= 0x80 ; /* s = 1 ; f = 0 ; */
			else
			{
				e -= 0x7f ;
				/* s = 1 ; */
				f = ((~f) + 1) ;
			}
		}
	}
	return BUILD_C40_32 ;
}

/*
-- 64 bit IEEE --> 32 bit C40
-- @@@@@@
-- Note: Conversion from 64 to 32 bit representation involves rounding - this
-- may or may not be desirable (refer earlier comments on conversion from
-- IEEE 64 --> C40 16)
-- @@@@@@
*/

#ifndef HOST_SUPPORTS_IEEE
#define IEEE_64ToIEEE_32(d,f)	\
	(void) fltrep_narrow_round (d,f)
#endif

int32 IEEE_64ToC40_32 (Dble d)
{
#ifdef HOST_SUPPORTS_IEEE
	return IEEE_32ToC40_32 ((float) d) ;
#else
	FloatBin f ;
	IEEE_64ToIEEE_32 (&d, &f) ;
	return (IEEE_32ToC40_32 (f.val)) ;
#endif
}

/*
-- 64 bit IEEE --> 16 bit C40
*/

int32 IEEE_64ToC40_16 (Dble d)
{
#ifdef HOST_SUPPORTS_IEEE
	int32 C40_32 = IEEE_32ToC40_32 ((float) d) ;
	return (C40_32ToC40_16 (C40_32)) ;
#else
	FloatBin f ;
	int32 C40_32 ;
	IEEE_64ToIEEE_32 (&d, &f) ;
	C40_32 = IEEE_32ToC40_32 (f.val) ;
	return (C40_32ToC40_16 (C40_32)) ;
#endif
}

#if 0 /* Available, not currently used */

/* extract components */

#define EXTRACT_C40_16			\
	e = (val >> 12) & 0xf ;		\
	s = (val >> 11) & 1 ; 		\
	f = val & ((1 << 11) - 1)

/* build number from components */

#define BUILD_IEEE_32	\
	((s << 31) | ((e & 0xff) << 23) | (f & ((1 << 23) - 1))) ;


/*
-- 16 bit C40 --> 32 bit C40
*/

int32 C40_16ToC40_32 (int32 val)
{
	int32 e ;
	int32 f ;
	int32 s ;

	if (val & 0xffff0000)
		Fatal ("invalid short floating point representation") ;

	EXTRACT_C40_16 ;

/*
-- If the C40_16 value passed in is zero, have to catch it here and return
-- the short (C40_32) reprentation
-- 0 (C40_32): e = -128, s = 0, f = 0
-- 0 (C40_16): e = -8, s = 0, f = 0
*/

	if (e == 0x8 && s == 0 && f == 0)
	{
		e = 0x80 ; /* s = 0 ; f = 0 */
		return BUILD_C40_32 ;
	}

	if (e & 0x8)
		e |= 0xf0 ; /* sign extend */
	f = f << 12 ;
	return BUILD_C40_32 ;
}

/*
-- 32 bit C40 --> 32 bit IEEE
*/

#ifdef HOST_SUPPORTS_IEEE
float C40_32ToIEEE_32 (int32 val)
#else
int32 C40_32ToIEEE_32 (int32 val)
#endif
{
	int32 e ;
	int32 f ;
	int32 s ;

#ifdef HOST_SUPPORTS_IEEE
	union {
		int32 w ;
		float f ;
	} fw ;
#endif

	EXTRACT_C40_32 ;

	/* decode - this algorithm is taken from the TMS320C4x User's Guide, page 4-13 */

	switch (e)
	{
		case 0x80:		/* e = -128 */
		case 0x81:		/* e = -127 */
			e = 0 ;
			s = 0 ;
			f = 0 ;
			break ;
		case 0x7f:		/* e = 127 */
			if (s == 1 && f == 0)
			{
				e = 0xff ; /* s = 1 ; f = 0 ; */
				break ;
			}
			/* otherwise, continue ... */
		default:		/* -126 <= e <= 127 */
			if (s == 0)
				e += 0x7f ; /* s = 0 ; f = f ; */
			else
			{
				if (f != 0)
				{
					e += 0x7f ;
/*
-- Note: printing error in TMS320C4x User's Guide, page 4-13 ! (s = 0)
*/
					/* s = 1 ; */
					f = ((~f) + 1) ;
				}
				else /* s == 1, f == 0 */
/*
-- Note: printing error in TMS320C4x User's Guide, page 4-13 ! (e += 0x7e)
*/
					e += 0x80 ; /* s = 1 ; f = 0 ; */
			}
			break ;
	}
#ifdef HOST_SUPPORTS_IEEE
	fw.w = BUILD_IEEE_32 ;
	return fw.f ;
#else
	return BUILD_IEEE_32 ;
#endif
}

#endif /* Available, not currently used */



/* pass2_C40.c */

@


1.6
log
@IEEE 64 bit FP support
@
text
@d14 1
a14 1
 * RcsId: $Id: pass2_C40.c,v 1.22 1992/10/23 16:32:10 craig Exp $
d722 3
a724 1
#ifndef HP /* Host does not support IEEE FP */
d726 1
a726 3
#else /* HP (supports IEEE FP) */
int32 IEEE_32ToC40_32 (float flt)
#endif /* HP (supports IEEE FP) */
d732 1
a732 1
#ifdef HP /* Host supports IEEE FP */
d741 1
a741 1
#endif /* HP (supports IEEE FP) */
d796 1
a796 1
#ifndef HP /* Host does not support IEEE FP */
d799 1
a799 1
#endif /* ! HP (does not support IEEE FP) */
d803 3
a805 1
#ifndef HP /* Host does not support IEEE FP */
d809 1
a809 3
#else /* HP (supports IEEE FP) */
	return IEEE_32ToC40_32 ((float) d) ;
#endif /* HP (supports IEEE FP) */
d818 4
a821 1
#ifndef HP /* Host does not support IEEE FP */
d827 1
a827 4
#else /* HP (supports IEEE FP) */
	int32 C40_32 = IEEE_32ToC40_32 ((float) d) ;
	return (C40_32ToC40_16 (C40_32)) ;
#endif /* HP (supports IEEE FP) */
d883 3
a885 1
#ifndef HP /* Host does not support IEEE FP */
d887 1
a887 3
#else /* HP (supports IEEE FP) */
float C40_32ToIEEE_32 (int32 val)
#endif /* HP (supports IEEE FP) */
d893 1
a893 1
#ifdef HP /* Host supports IEEE FP */
d898 1
a898 1
#endif /* HP (supports IEEE FP) */
d941 1
a941 3
#ifndef HP /* Host does not support IEEE FP */
	return BUILD_IEEE_32 ;
#else /* HP (supports IEEE FP) */
d944 3
a946 1
#endif /* HP (supports IEEE FP) */
a951 910
#ifndef HP /* Host does not support IEEE FP */
/*
-- IEEE 64 bit integer arithmetic routines
--
-- These routines lifted from the C compiler: mip/ieeeflt.c
--
-- Description: encodes, and performs arithmetic on IEEE values,
-- irrespective of the host hardware, by using integer-only arithmetic.
--
-- Apart from various #defines and #ifdefs, the code itself has not been
-- touched.
-- crf: 21/10/92 - Well, not quite. I have encountered a nasty feature 
-- associated with shifting numbers. In this code, it can happen that a 
-- number will be shifted by 32 bits to the left or right (the result of 
-- which, if the number is unsigned, I believe should be zero). Now, if you're
-- compiling on the Transputer or C40, the result of shifting by 32 bits is in
-- fact zero. However, if you're compiling on a Spark or HP Snake, this 
-- operation leaves the number unchanged (Note: when compiling on the snake,
-- the -Aa (ANSI mode) causes the latter result (i.e. result unchanged).
-- Compiling without this option returns 0).
-- I have introduced 2 macros, L_SHIFT() and R_SHIFT() which return 0 if the
-- size of the shift exceeds 31.
*/

/*
-- Replace all	(x << rshift)	with	L_SHIFT(x,rshift)
-- 		(x >> shift)	with	R_SHIFT(x,shift)
*/
#define L_SHIFT(x,shift)	(shift > 31) ? 0 : x << shift
#define R_SHIFT(x,shift)	(shift > 31) ? 0 : x >> shift


#include <ctype.h>

#define cc_err(s)	Fatal(s)
#define cc_rerr(s)	Warn(s)

/*
-- modified from mip/miperrs.h:
*/
#define fp_err_very_big "overlarge floating point value"
#define fp_err_big_single \
        "overlarge (single precision) floating point value"
#define fp_rerr_very_small "small floating point value converted to 0.0"
#define fp_rerr_small_single \
        "small (single precision) floating value converted to 0.0"

/*
-- extracted from mip/util.h:
*/
#define intofdigit(c) ((c)-'0')          /* turns oct or dec digit to int */

/*
-- extracted from mip/defaults.h
*/
#define signed_rightshift_(a,b) \
         ((int32)((int32)(a)>=0 ? (a)>>(b) : ~((~(unsigned32)(a)) >> (b))))


void fltrep_stod(const char *s, DbleBin *p)
{
/* s is a string containing a floating point number (syntax has been     */
/* checked already). p points to two words of store into which the IEEE  */
/* representation of the number must be pushed. Do the packing using     */
/* only integer arithmetic to (a) guarantee good rounding and (b) ensure */
/* that this compiler works even when FPE is not active.                 */
    int32 ds, dh, dm, dl, bx;     /* floating point result in pieces       */
    int32 th, tm, tl, x, x1, ch, dot;

    ds = 0;
    
    switch (ch = *s++)
    {
case '-':
        ds = (unsigned long) 0x80000000;
case '+':
        ch = *s++;
default:
        break;
    }
    
    dh = dm = dl = bx = 0;
    
/* I keep a 3-word value (th, tm, tl) to be 10**(-n) where n digits have */
/* been read so far, and add toint(ch)*t into (dh, dm, dl) at each step  */
    th = 0x00100000;
    tm = tl = x = x1 = dot = 0;
    while (ch=='0') ch = *s++;
    if (ch=='.')
    {   dot = 1;
        while ((ch = *s++)=='0') x -= 1;
    }
/* Now I have dealt with all the leading zeros and so I can used fixed   */
/* point arithmetic to assemble the number.                              */

    for (;;)
    {   if (!dot && ch=='.') ch = *s++, dot = 1;
        else if (isdigit(ch))
        {   int32 carry = ((th % 10)<<24) + tm;
            th = th / 10;
            tm = carry / 10;
            tl = (((carry % 10)<<24) + tl) / 10;
            ch = intofdigit(ch);
            dl += ch*tl;
            dm += ch*tm + ((dl>>24) & 0xff);
            dh += ch*th + ((dm>>24) & 0xff);
            dl &= 0x00ffffff;
            dm &= 0x00ffffff;
            if (!dot) x += 1;
            ch = *s++;
        }
        else break;
    }
    
    if (dh==0)      /* result = 0.0? : normalization => test on dh is OK */
    {   p->msd = 0;
        p->lsd = 0;

        return;
    }
    
    if (ch=='e' || ch=='E')
    {   int32 sx = 0;

        switch (ch = *s++)
        {
    case '-':
            sx = 1;
    case '+':
            ch = *s++;
    default:
            break;
        }
        while (isdigit(ch))             /* read an exponent              */
        {   x1 = 10*x1 + intofdigit(ch);
            ch = *s++;
        }
        if (sx) x -= x1;
        else x += x1;
    }
/* Now I have to multiply or divide the number by some power of 10       */
        while (x>0)
        {   dl *= 10;
            dm = 10*dm + ((dl>>24) & 0xff);
            dh = 10*dh + ((dm>>24) & 0xff);
            dl &= 0x00ffffff;
            dm &= 0x00ffffff;
            while ((dh & (unsigned long) 0xffe00000)!=0)
            {   dl = (dl>>1) | ((dm&1)<<23);
                dm = (dm>>1) | ((dh&1)<<23);
                dh = dh>>1;
                bx += 1;
            }
            x -= 1;
        }
        while (x<0)
        {   int32 carry = ((dh % 10)<<24) + dm;
            dh /= 10;
            dm = carry / 10;
            dl = (dl + ((carry % 10)<<24)) / 10;
            dm += ((dl>>24) & 0xff);
            dh += ((dm>>24) & 0xff);
            dl &= 0x00ffffff;
            dm &= 0x00ffffff;
            while ((dh & (unsigned long) 0xfff00000)==0)
            {   dh = (dh<<1) | ((dm>>23)&1);
                dm = ((dm<<1) | ((dl>>23)&1)) & 0x00ffffff;
                dl = (dl<<1) & 0x00ffffff;
                bx -= 1;
            }
            x += 1;
        }
    
    /* postnormalize to ensure that bit 0x00100000 is the MSB            */
    
    for (;;)
      {
	while ((dh & (unsigned long) 0xfff00000)==0)
	  {
	    dh = (dh<<1) | ((dm>>23)&1);
            dm = ((dm<<1) | ((dl>>23)&1)) & 0x00ffffff;
            dl = (dl<<1) & 0x00ffffff;
            bx -= 1;
	  }

        while ((dh & (unsigned long) 0xffe00000)!=0)
	  {
	    dl = (dl>>1) | ((dm&1)<<23);
            dm = (dm>>1) | ((dh&1)<<23);
            dh = dh>>1;
            bx += 1;
	  }
	
	/* Round up if necessary, using 8 guard bits.                            */
	
	
        if ((dl & 0xff00)>0x8000)
	  {
	    dl += 0x00010000;
            dm += (dl >> 24) & 0xff;
            dh += (dm >> 24) & 0xff;
            dl &= 0x00ff0000;
            dm &= 0x00ffffff;

	    continue;           /* may need more normalization           */
	  }
        else if ((dl & 0xff00)==0x8000)  /* force zero in middle case    */
	  {
            dl &= 0x00fe0000;
	  }
	
        break;
    }
    
    bx += 0x3ff;            /* assemble final exponent                   */
    
    if (bx<=0)
    {
      cc_rerr(fp_rerr_very_small);
        p->msd = 0;
        p->lsd = 0;
        return;
    }
    if (bx>0x7ff)
    {   cc_err(fp_err_very_big);
        bx = 0x7ff;             /* overflow -> 'infinity'                */
        dh = dm = dl = 0;
    }
    dh = ds | (bx<<20) | (dh & 0x000fffff);
    dm = (dm<<8) | ((dl>>16) & 0xff);
    p->msd = dh;
    p->lsd = dm;
    
    return;
}

bool fltrep_narrow(DbleBin *d, FloatBin *e)
/* this is now a function so that caller can report errors soon */
{   int32 hi = d->msd, lo = d->lsd;
    int32 x = (hi>>20) & 0x7ff;
    int32 m = hi & 0x000fffff;
    if (x==0)                   /* value is zero - treat specially       */
    {   e->val = 0;
        return 0;               /* OK */
    }
    else if (x==0x7ff)          /* value is 'infinity'.                  */
    {   e->val = (hi & (unsigned long) 0x80000000) | 0x7f800000;
        return 0;
    }
    m = (m << 3) | ((lo >> 29) & 0x7);
    lo = lo << 3;
    if (lo < 0 && (lo!=(unsigned long) 0x80000000 || (m & 1)!=0))
        if ((m += 1) == 0x00800000)     /* round up & renormalize        */
        {   m = 0;
            x += 1;
        }
    x = x - 0x3ff + 0x7f;
    if (x >= 0xff)
    {   cc_err(fp_err_big_single);
        e->val = (hi & (unsigned long) 0x80000000) | (0xffL << 23);
        return 1;                /* overflow */
    }
    else if (x <= 0)
    {   cc_rerr(fp_rerr_small_single);
        e->val = (hi & (unsigned long) 0x80000000) | (0L << 23);   /* preserve sign */
        return -1;               /* underflow */
    }
    e->val = (hi & (unsigned long) 0x80000000) | (x << 23) | m;
    return 0;
}

bool fltrep_narrow_round(DbleBin *d, FloatBin *e)
{
    return fltrep_narrow(d, e);
}

#if 0 /* UNUSED */
void fltrep_widen(FloatBin *e, DbleBin *d)
{
    unsigned32 e0 = e->val;
    int32 x = (e0>>23) & 0xff;
    int32 s = e0 & (unsigned long) 0x80000000;
    if (x==0)                   /* value is zero - preserve sign, why?   */
        d->msd = s, d->lsd = 0;
    else if (x==0xff)           /* value is 'infinity' - preserve sign.  */
        d->msd = s | 0x7ff00000, d->lsd = 0;
    else
        d->msd = s | ((x - 0x7f + 0x3ff) << 20) | ((e0 & 0x7fffff) >> 3),
        d->lsd = e0 << 29;
}
#endif /* UNUSED */

/* The following procedures implement IEEE format arithmetic without any */
/* reliance on the Acorn FPE. They exist here so that I can use this as  */
/* a cross-compiler, running on machines without floating point or with  */
/* floating point that does not agree with the ARM's version.            */

/* There is no support here for denormalized numbers, and infinities etc */
/* are viewed as error cases rather than as valid data.                  */

/* flt_compare returns -1, 0 or +1 for *a<*b, *a==*b or *a>*b. The other */
/* routines return a flag that is 0 if the procedure detected overflow   */
/* or division by zero, or if the operand was out of range for           */
/* conversion to an integral type.                                       */


/* Coded without concern about speed, and so quite dreadfully slow.      */
/* Also coded without concern about code density, so rather repetitive   */
/* and bulky. Memory is supposed to be cheap these days.                 */


static bool flt_sum(DbleBin *a, unsigned32 bh, unsigned32 bl,
                    unsigned32 ch, unsigned32 cl)
{
    unsigned32 guard=0, w;
    int32 bx, cx;
    int32 shift;
    bx = (bh >> 20) & 0x7ff;
    cx = (ch >> 20) & 0x7ff;
    shift = bx - cx;
    if (shift < -54 || bx == 0)
    {   a->msd = ch;
        a->lsd = cl;
        return 1;
    }
    if (shift > 54 || cx == 0)
    {   a->msd = bh;
        a->lsd = bl;
        return 1;
    }
    bh = (bh & 0xfffff) | 0x100000;
    ch = (ch & 0xfffff) | 0x100000;
/* Now I need to align the operands                                      */
    if (shift > 0)
    {   int32 rshift;
        if (shift > 32)
        {   guard = cl;
            cl = ch;
            ch = 0;
            shift -= 32;
        }
        rshift = 32 - shift;
        if (guard == 0) guard = L_SHIFT(cl,rshift);
        else guard = (L_SHIFT(cl,rshift)) | 1;
        cl = (L_SHIFT(ch,rshift)) | (R_SHIFT(cl,shift));
        ch = R_SHIFT(ch,shift);
    }
    else if (shift < 0)
    {   int32 rshift;
        if (shift < -32)
        {   guard = bl;
            bl = bh;
            bh = 0;
            shift += 32;
        }
        shift = -shift;
        rshift = 32 - shift;
        if (guard == 0) guard = L_SHIFT(bl,rshift);
        else guard = (L_SHIFT(bl,rshift)) | 1;
        bl = (L_SHIFT(bh,rshift)) | (R_SHIFT(bl,shift));
        bh = R_SHIFT(bh,shift);
        bx = cx;
    }
    else guard = 0;
    w = (bl & 0xff) + (cl & 0xff);
    bl = (bl >> 8) + (cl >> 8) + (w >> 8);
    bh += ch + (bl >> 24);
    bl = (bl << 8) + (w & 0xff);
    if (bh & 0x00200000)
    {   guard = (bl << 31) | (guard >> 1);
        bl = (bh << 31) | (bl >> 1);
        bh = bh >> 1;
        bx += 1;
        if (bx >= 0x7ff) return 0;          /* Overflow case             */
    }
/* The magic rules about when and how to round are implemented here      */
#define ieee_carry(g, l) (g & (unsigned long) 0x80000000) && ((l & 1)!=0 || g!= (unsigned long) 0x80000000)
    if (ieee_carry(guard, bl))
    {   if (bl == (unsigned long)0xffffffff)
        {   bl = 0;
            bh += 1;
            if (bh & 0x00200000)
            {   bh = 0x00100000;
                bx += 1;
                if (bx >= 0x7ff) return 0;      /* Overflow case         */
            }
        }
        else bl += 1;
    }
    a->msd = (bh & ~0x00100000) | (bx << 20);
    a->lsd = bl;
    return 1;
}

static bool flt_difference(DbleBin *a, unsigned32 bh, unsigned32 bl,
                           unsigned32 ch, unsigned32 cl)
{
    unsigned32 bg=0, cg=0, w, resultsign;
    int32 bx, cx;
    int32 shift;
    bx = (bh >> 20) & 0x7ff;
    cx = (ch >> 20) & 0x7ff;
    shift = bx - cx;
    if (shift < -54 || bx == 0)
    {   a->msd = ch ^ (unsigned long) 0x80000000;
        a->lsd = cl;
        return 1;
    }
    if (shift > 54 || cx == 0)
    {   a->msd = bh;
        a->lsd = bl;
        return 1;
    }
    bh = (bh & 0xfffff) | 0x100000;
    ch = (ch & 0xfffff) | 0x100000;
/* Now I need to align the operands                                      */
    if (shift > 0)
    {   int32 rshift;
        if (shift > 32)
        {   cg = cl;
            cl = ch;
            ch = 0;
            shift -= 32;
        }
        rshift = 32 - shift;
        if (cg == 0) cg = L_SHIFT(cl,rshift);
        else cg = (L_SHIFT(cl,rshift)) | 1;
        cl = (L_SHIFT(ch,rshift)) | (R_SHIFT(cl,shift));
        ch = R_SHIFT(ch,shift);
        bg = 0;
    }
    else if (shift < 0)
    {   int32 rshift;
        if (shift < -32)
        {   bg = bl;
            bl = bh;
            bh = 0;
            shift += 32;
        }
        shift = -shift;
        rshift = 32 - shift;
        if (bg == 0) bg = L_SHIFT(bl,rshift);
        else bg = (L_SHIFT(bl,rshift)) | 1;
        bl = (L_SHIFT(bh,rshift)) | (R_SHIFT(bl,shift));
        bh = R_SHIFT(bh,shift);
        cg = 0;
        bx = cx;
    }
    else bg = cg = 0;
/* Now for a subtraction, taking account of signs. Ugh.                  */
/* I rely on right shifts on signed types being arithmetic in struggles  */
/* to implement multiple precision arithmetic without a proper add-carry */
/* operator in my language.                                              */
    w = (bg & 0xff) - (cg & 0xff);
    bg = (bg >> 8) - (cg >> 8) + signed_rightshift_(w,8);
    cg = signed_rightshift_(bg,24);
    bg = (bg << 8) | (w & 0xff);
    w = (bl & 0xff) - (cl & 0xff) + cg;
    bl = (bl >> 8) - (cl >> 8) + signed_rightshift_(w,8);
    cg = signed_rightshift_(bl,24);
    bl = (bl << 8) | (w & 0xff);
    bh = bh - ch + cg;
/* Subtraction complete in 2s complement form.                           */
    if (bh & (unsigned long) 0x80000000)  /* Sign of result must be negative             */
    {   if (bg == 0)
        {   if (bl == 0) bh = -bh;
            else
            {   bl = -bl;
                bh = ~bh;
            }
        }
        else
        {   bg = -bg;
            bl = ~bl;
            bh = ~bh;
        }
        resultsign = (unsigned long) 0x80000000;
    }
    else resultsign = 0;
/* Subtraction now complete in sign & magnitude form                     */
    if (bh == 0 && bl == 0 && bg == 0)
    {   a->msd = a->lsd = 0;           /* Result is absolutely zero          */
        return 1;
    }
/* Must have a normalized result.                                        */
    if ((bh & 0x00300000)==0)       /* need to renormalize?              */
    {   while (bh == 0)
        {   bh = bl >> 11;
            bl = (bl << 21) | (bg >> 11);
            bg = bg << 21;
            bx -= 21;
            if (bx <= 0)
            {   a->msd = a->lsd = 0;
                return 1;
            }
        }
        while ((bh & 0x001fe000) == 0)
        {   bh = (bh << 8) | (bl >> 24);
            bl = (bl << 8) | (bg >> 24);
            bg = bg << 8;
            bx -= 8;
            if (bx <= 0)
            {   a->msd = a->lsd = 0;
                return 1;
            }
        }
        while ((bh & 0x001c0000) == 0)
        {   bh = (bh << 3) | (bl >> 29);
            bl = (bl << 3) | (bg >> 29);
            bg = bg << 3;
            bx -= 3;
            if (bx <= 0)
            {   a->msd = a->lsd = 0;
                return 1;
            }
        }
        while ((bh & 0x00100000) == 0)
        {   bh = (bh << 1) | (bl >> 31);
            bl = (bl << 1) | (bg >> 31);
            bg = bg << 1;
            bx -= 1;
            if (bx <= 0)
            {   a->msd = a->lsd = 0;
                return 1;
            }
        }
    }
    else if (bh & 0x00200000)
    {   bg = (bl << 31) | (bg >> 1);
        bl = (bh << 31) | (bl >> 1);
        bh = bh >> 1;
        bx += 1;
        if (bx >= 0x7ff) return 0;      /* Overflow case                 */
    }
/* The magic rules about when and how to round are implemented here      */
    if (ieee_carry(bg, bl))
    {   if (bl == (unsigned long) 0xffffffff)
        {   bl = 0;
            bh += 1;
            if (bh & 0x00200000)
            {   bh = 0x00100000;
                bx += 1;
                if (bx >= 0x7ff) return 0;      /* Overflow case         */
            }
        }
        else bl += 1;
    }
    a->msd = (bh & ~0x00100000) | (bx << 20) | resultsign;
    a->lsd = bl;
    return 1;
}

bool flt_add(DbleBin *a, DbleBin *b, DbleBin *c)
/*   *a = *b + *c    */
{
    unsigned32 bh = b->msd;
    unsigned32 bl = b->lsd;
    unsigned32 ch = c->msd;
    unsigned32 cl = c->lsd;
    bool ok;
/* Do a case analysis on signs to end up with arithmetic on unsigned floats */
    if (bh & (unsigned long) 0x80000000)
    {   if (ch & (unsigned long) 0x80000000)
        {   ok = flt_sum(a, bh & 0x7fffffff, bl, ch & 0x7fffffff, cl);
            a->msd ^= (unsigned long) 0x80000000;
        }
        else ok = flt_difference(a, ch, cl, bh & 0x7fffffff, bl);
    }
    else if (ch & (unsigned long)0x80000000)
        ok = flt_difference(a, bh, bl, ch & 0x7fffffff, cl);
    else ok = flt_sum(a, bh, bl, ch, cl);
    return ok;
}

bool flt_subtract(DbleBin *a, DbleBin *b, DbleBin *c)
/*  *a = *b - *c  */
{
    unsigned32 bh = b->msd;
    unsigned32 bl = b->lsd;
    unsigned32 ch = c->msd;
    unsigned32 cl = c->lsd;
    bool ok;
    if (bh & (unsigned long) 0x80000000)
    {   if (ch & (unsigned long) 0x80000000)
            ok = flt_difference(a, ch & 0x7fffffff, cl, bh & 0x7fffffff, bl);
        else
        {   ok = flt_sum(a, bh & 0x7fffffff, bl, ch, cl);
            a->msd ^= (unsigned long) 0x80000000;
        }
    }
    else if (ch & (unsigned long) 0x80000000)
        ok = flt_sum(a, bh, bl, ch & 0x7fffffff, cl);
    else ok = flt_difference(a, bh, bl, ch, cl);
    return ok;
}

bool flt_multiply(DbleBin *a, DbleBin *b, DbleBin *c)
/*  *a = *b * *c  */
{
    unsigned32 bh = b->msd;
    unsigned32 bl = b->lsd;
    unsigned32 ch = c->msd;
    unsigned32 cl = c->lsd;
    int32 ax, bx, cx, as;
    unsigned32 ah, al, carry;
    unsigned32 aa[7], bb[4], cc[4];
    int32 i, j;
    as = (bh ^ ch) & (unsigned long) 0x80000000;    /* sign for result */
    bx = (bh >> 20) & 0x7ff;
    cx = (ch >> 20) & 0x7ff;
    if (bx==0 || cx==0)
    {   a->msd = as;    /* multiplication by 0.0         */
        a->lsd = 0;     /* note treatment of sign.       */
        return 1;
    }
    bh = (bh & 0xfffff) | 0x100000;
    ch = (ch & 0xfffff) | 0x100000;
/* I split the operands into 14-bit chunks and do a long multiplication. */
/* As coded here I put more effort than might really be needed into the  */
/* low order bits of the product, but for now I am more concerned with   */
/* ease of coding and accuracy of results than with absolute speed.      */
/* On the ARM it MIGHT be that a shift-and-add long multiply coded at    */
/* the level would be faster?                                            */
    bb[0] = bh >> 7;
    bb[1] = ((bh & 0x7f) << 7) | (bl >> 25);
    bb[2] = (bl >> 11) & ~0x003fc000;
    bb[3] = (bl << 3) & 0x3fff;
    cc[0] = ch >> 7;
    cc[1] = ((ch & 0x7f) << 7) | (cl >> 25);
    cc[2] = (cl >> 11) & ~0x003fc000;
    cc[3] = (cl << 3) & 0x3fff;
    aa[0] = aa[1] = aa[2] = aa[3] = aa[4] = aa[5] = aa[6] = 0;
    for (i=0; i<4; i++)
        for (j=0; j<4; j++)
            aa[i+j] += bb[i] * cc[j];
    carry = 0;
    for (i=6; i!=0; i--)
    {   unsigned32 w = aa[i] + carry;
        aa[i] = w & 0x3fff;
        carry = w >> 14;
    }
    carry = aa[0] + carry;
    ax = bx + cx - 0x3fe;
    if ((carry & 0x08000000) == 0)
    {   carry = (carry << 1) | (aa[1] >> 13);
        aa[1] = ((aa[1] << 1) & ~0xc000) | (aa[2] >> 13);
        aa[2] = ((aa[2] << 1) & ~0xc000) | (aa[3] >> 13);
/* aa[3] to aa[6] are guard digits and do not need shifting here (!)     */
        ax -= 1;
    }
    ah = carry >> 7;
    al = ((carry & 0x7f) << 25) | (aa[1] << 11) | (aa[2] >> 3);
    carry = ((aa[2] & 0x3) | aa[3] | aa[4] | aa[5] | aa[6]) |
            ((aa[2] & 0x4) << 29);
/* The magic rules about when and how to round are implemented here      */
    if (ieee_carry(carry, al))
    {   if (al == (unsigned long) 0xffffffff)
        {   al = 0;
            ah += 1;
            if (ah & 0x00200000)
            {   ah = 0x00100000;
                ax += 1;
            }
        }
        else al += 1;
    }
    if (ax >= 0x7ff) return 0;      /* Overflow */
    else if (ax <= 0)
    {   a->msd = as;  /* N.B. keep sign on underflow     */
        a->lsd = 0;
        return 1;
    }
    a->msd = (ah & ~0x00100000) | (ax << 20) | as;
    a->lsd = al;
    return 1;
}

bool flt_divide(DbleBin *a, DbleBin *b, DbleBin *c)
/*  *a = *b / *c   */
{
    unsigned32 bh = b->msd;
    unsigned32 bl = b->lsd;
    unsigned32 ch = c->msd;
    unsigned32 cl = c->lsd;
    unsigned32 ah, al, as = (bh ^ ch) & (unsigned long) 0x80000000;
    int32 ax, bx, cx, i;
    bx = (bh >> 20) & 0x7ff;
    cx = (ch >> 20) & 0x7ff;
    if (cx == 0) return 0;              /* division by zero              */
    if (bx == 0)
    {   a->msd = as;    /*  0.0 / anything  = 0.0        */
        a->lsd = 0;
        return 1;
    }
    bh = (bh & 0xfffff) | 0x00100000;
    ch = (ch & 0xfffff) | 0x00100000;
    ax = bx - cx + 0x3fe;
    ah = al = 0;
/* Do the division by test-and-subtract                                  */
    for (i = 0; i<55; i++)
    {   if (bh > ch || (bh == ch && bl >= cl))
        {   unsigned32 w = (bl & 0xff) - (cl & 0xff);
/* Do a double length subtraction (oh the carry is a misery)             */
            bl = (bl >> 8) - (cl >> 8) + signed_rightshift_(w,8);
            bh = bh - ch + signed_rightshift_(bl,24);
            bl = (bl << 8) | (w & 0xff);
            ah = (ah << 1) | (al >> 31);
            al = (al << 1) | 1;
        }
        else
        {   ah = (ah << 1) | (al >> 31);
            al = al << 1;
        }
        bh = (bh << 1) | (bl >> 31);
        bl = bl << 1;
    }
    bh |= bl;                                    /* sticky bits now here */
    bh = (bh & 0xff) | (bh >> 8);                /* top bit clear.       */
    if (ah & 0x00400000)
    {   bh |= al & 1;
        al = (al >> 1) | (ah << 31);
        ah = ah >> 1;
        ax += 1;
    }
    bh = bh | (al << 31);
    al = (al >> 1) | (ah << 31);
    ah = ah >> 1;
/* The magic rules about when and how to round are implemented here      */
    if (ieee_carry(bh, al))
    {   if (al == (unsigned long) 0xffffffff)
        {   al = 0;
            ah += 1;
            if (ah & 0x00200000)
            {   ah = 0x00100000;
                ax += 1;
            }
        }
        else al += 1;
    }
    if (ax >= 0x7ff) return 0;      /* Overflow on the division          */
    else if (ax <= 0)
    {   a->msd = as;  /* N.B. keep sign on underflow     */
        a->lsd = 0;
        return 1;
    }
    a->msd = (ah & ~0x00100000) | (ax << 20) | as;
    a->lsd = al;
    return 1;
}

#if 0 /* UNUSED */
int flt_compare(DbleBin *b, DbleBin *c)
/* (int32)sign(*b-*c)  */
{
/* Integer comparison of the 64bit values almost gives the answer I want */
    int32 bh = b->msd;
    unsigned32 bl = b->lsd;
    int32 ch = c->msd;
    unsigned32 cl = c->lsd;
/* +0.0 is equal to -0.0                                                 */
    if ((bh & 0x7ff00000)==0 && (ch & 0x7ff00000)==0) return 0;
    if (bh < 0 && ch >= 0) return -1;
    else if (bh >= 0 && ch < 0) return 1;
    else if (bh < 0)
    {   int32 temp = bh;
        bh = ch & 0x7fffffff;
        ch = temp & 0x7fffffff;
        temp = bl;
        bl = cl;
        cl = temp;
    }
    if (bh < ch) return -1;
    else if (bh > ch) return 1;
    else if (bl < cl) return -1;
    else if (bl > cl) return 1;
    else return 0;
}

bool flt_move(DbleBin *a, DbleBin *b)
/*   *a = *b         */
{
    a->msd = b->msd;
    a->lsd = b->lsd;
    return 1;
}
#endif /* UNUSED */

bool flt_negate(DbleBin *a, DbleBin *b)
/*   *a = - *b       */
{
    a->msd = b->msd ^ (unsigned long) 0x80000000;
    a->lsd = b->lsd;
    return 1;                   /* can never fail                        */
}

/*#ifdef INT_TO_FLOAT_NEEDED*/

bool flt_itod(DbleBin *a, int32 n)
/*   *a = (double) n */
{
    unsigned32 ah, al;
    int32 as, ax;
    if (n==0)
    {   a->msd = 0;
        a->lsd = 0;
        return 1;
    }
    else if (n>0) as = 0;
    else
    {   as = 0x80000000;
        n = -n;             /* from here on n is thought of as unsigned  */
    }
    ah = 0;
    al = n;
    ax = 0x400 + 51;
    while ((ah & 0x00100000)==0)
    {   ah = (ah << 1) | (al >> 31);
        al = al << 1;
        ax -= 1;
    }
    a->msd = (ah & ~0x00100000) | (ax << 20) | as;
    a->lsd = al;
    return 1;
}

#if 0 /* UNUSED */
bool flt_utod(DbleBin *a, unsigned n)
/*   *a = (double) u */
{
    unsigned32 ah, al;
    int32 ax;
    if (n==0)
    {   a->msd = 0;
        a->lsd = 0;
        return 1;
    }
    ah = 0;
    al = n;
    ax = 0x400 + 53;
    while ((ah & 0x00100000)==0)
    {   ah = (ah << 1) | (al >> 31);
        al = al << 1;
        ax -= 1;
    }
    a->msd = (ah & ~0x00100000) | (ax << 20);
    a->lsd = al;
    return 1;
}

/*#endif*/

bool flt_dtoi(int32 *n, DbleBin *a)
/*   *n = (int32) *a   */
{
    unsigned32 ah, al;
    int32 sign, ax;
    ah = a->msd;
    al = a->lsd;
    if (ah & (unsigned long) 0x80000000)
    {   ah &= ~(unsigned long) 0x80000000;
        sign = 1;
    }
    else sign = 0;
    ax = ah >> 20;
    ah = (ah & 0x000fffff) | 0x00100000;
    if (ax < 0x3fe)                     /* arg < 0.5 ... result 0        */
    {   *n = 0;
        return 1;
    }
    else if (ax > 0x400 + 51) return 0; /* overflow certainly            */
    while (ax != 0x400 + 51)
    {   al = (al >> 1) | (ah << 31);
        ah = ah >> 1;
        ax += 1;
    }
    if (sign)
    {   if (al > (unsigned long) 0x80000000) return 0;
        al = -al;
    }
    else if (al >= (unsigned long) 0x80000000) return 0;
    *n = al;
    return 1;
}

bool flt_dtou(unsigned32 *u, DbleBin *a)
/*   *u = (unsigned) *a */
{
    unsigned32 ah, al;
    int32 ax;
    ah = a->msd;
    al = a->lsd;
    ax = (ah >> 20) & 0x7ff;
    if ((ah & (unsigned long) 0x80000000)!=0 && ax!=0) return 0;    /* negative nonzero  */
    ah = (ah & 0x000fffff) | 0x00100000;
    if (ax < 0x3fe)                     /* arg < 0.5 ... result 0        */
    {   *u = 0;
        return 1;
    }
    else if (ax > 0x400 + 51) return 0; /* overflow certainly            */
    while (ax != 0x400 + 51)
    {   al = (al >> 1) | (ah << 31);
        ah = ah >> 1;
        ax += 1;
    }
    *u = al;
    return 1;
}
#endif /* UNUSED */

#endif /* ! HP (does not support IEEE FP) */
@


1.5
log
@Added floating point conversion routines
@
text
@d14 1
a14 1
 * RcsId: $Id: pass2_C40.c,v 1.4 1992/10/05 17:15:51 paul Exp $
d642 15
a665 5
#define EXTRACT_C40_16			\
	e = (val >> 12) & 0xf ;		\
	s = (val >> 11) & 1 ; 		\
	f = val & ((1 << 11) - 1)

a678 3
#define BUILD_IEEE_32	\
	((s << 31) | ((e & 0xff) << 23) | (f & ((1 << 23) - 1))) ;

d683 1
a683 1
int C40_32ToC40_16 (int val)
d685 3
a687 3
	int e ;
	int f ;
	int s ;
d692 1
a692 1
-- If the C40_32 value passed in zero, have to catch it here and return
d703 9
a711 5
/*
-- will exponent fit into 4 bits ?
*/
	if (abs ((signed char) e) > 7)
		Fatal ("Cannot represent exponent in short format") ;
a718 37
-- 16 bit C40 --> 32 bit C40
*/

int C40_16ToC40_32 (int val)
{
	int e ;
	int f ;
	int s ;

	if (val & 0xffff0000)
		Fatal ("Invalid short floating point representation") ;

	EXTRACT_C40_16 ;

/*
-- If the C40_16 value passed in zero, have to catch it here and return
-- the short (C40_32) reprentation
-- 0 (C40_32): e = -128, s = 0, f = 0
-- 0 (C40_16): e = -8, s = 0, f = 0
*/

	if (e == 0x8 && s == 0 && f == 0)
	{
		e = 0x80 ; /* s = 0 ; f = 0 */
		return BUILD_C40_32 ;
	}

	if (e & 0x8)
		e |= 0xf0 ; /* sign extend */
	f = f << 12 ;
	return BUILD_C40_32 ;
}

/* Convert IEEE double into 32 bit C40 floating point representation. */
/* The number returned will be inserted into the code. */

/*
d722 5
a726 1
int IEEE_32ToC40_32 (double d)
d728 3
a730 3
	int e ;
	int f ;
	int s ;
d732 2
a733 1
	int val ;
d735 1
a735 1
		int w ;
d739 1
a739 1
	fw.f = (float) d ;
d741 2
a742 1
	
d788 92
d883 5
a887 1
double C40_32ToIEEE_32 (int val)
d889 5
d895 1
a895 1
		int w ;
d898 1
a898 4

	int e ;
	int f ;
	int s ;
d941 3
d945 2
a946 1
	return (double) fw.f ;
d949 54
a1002 4
/* Convert IEEE double into 16 bit C40 floating point representation. */
/* The number returned will be inserted directly into a C40 instructions 16 */
/* bit immediate data field and therefore must not extend past the 16th */
/* bit. */
d1005 1
a1005 1
-- 32 bit IEEE --> 16 bit C40
d1007 241
d1249 502
a1750 1
int IEEE_32ToC40_16 (double d)
d1752 23
a1774 3
	int C40_32 = IEEE_32ToC40_32 (d) ;
	int C40_16 = C40_32ToC40_16 (C40_32) ;
	return C40_16 ;
d1777 58
d1836 27
d1864 1
@


1.4
log
@added floating point expressions
@
text
@d14 1
a14 1
 * RcsId: $Id: pass2_C40.c,v 1.3 1992/09/02 18:20:01 paul Exp $
d640 37
a676 5
/* Convert IEEE double into 16 bit C40 floating point representation. */
/* The number returned will be inserted directly into a C40 instructions 16 */
/* bit immediate data field and therefore must not extend past the 16th */
/* bit. */
int	IEEE_32ToC40_16(double d)
d678 27
a704 1
	return 0;
d707 34
d743 6
a748 1
int	IEEE_32ToC40_32(double d)
d750 55
a804 1
	return 0;
d807 75
@


1.3
log
@fixed duplicate calls to Eval as it was used by macro that used same arg
more than once.
@
text
@d14 1
a14 1
 * RcsId: $Id: pass2_C40.c,v 1.2 1992/07/21 09:23:01 paul Exp $
d638 18
@


1.2
log
@added support for import directive
@
text
@d14 1
a14 1
 * RcsId: $Id: pass2_C40.c,v 1.1 1992/03/12 21:16:01 paul Exp $
d79 2
a80 1
		if (!fits_in_16_bits(result = Eval(expr, pc))) {
d91 2
a92 1
		if (!fits_in_16_bits_unsigned(result = Eval(expr, pc))) {
d108 2
a109 1
		if (!fits_in_8_bits_unsigned(result = Eval(expr, pc))) {
d121 2
a122 1
		if (!fits_in_16_bits_unsigned(result = Eval(expr, pc))) {
d133 2
a134 1
		if (!fits_in_5_bits(result = Eval(expr, pc))) {
d182 2
a183 1
			if(!fits_in_5_bits_unsigned(result = Eval(expr, pc))) {
d207 2
a208 1
			if(!fits_in_5_bits_unsigned(result = Eval(expr, pc))) {
d235 2
a236 1
			if (!fits_in_8_bits(result = Eval(expr, pc))) {
d248 2
a249 1
			if (!fits_in_8_bits_unsigned(result = Eval(expr, pc))) {
d483 1
a483 1
			if((result = Eval(expr, pc)) > 1 || result < 0)
d498 2
a499 1
			if(!fits_in_5_bits_unsigned(result = Eval(expr, pc))) {
d522 2
a523 1
			if(!fits_in_5_bits_unsigned(result = Eval(expr, pc))) {
d601 2
a602 1
		if (!fits_in_8_bits_unsigned(result = Eval(expr, pc))) {
d615 2
a616 1
		if (!fits_in_16_bits_unsigned(result = Eval(expr, pc))) {
@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
 * RcsId: $Id$
d25 1
a314 2
		result = Eval(expr, pc);

d317 1
a317 1
			result -= 3;
d319 20
a338 1
			result -= 1;
d340 16
d370 4
a373 1
		result = Eval(expr, pc);
d375 1
d377 33
a409 4
		if ( opcode & (1 << 24))
			result -= 3;
		else
			result -= 1;
@
