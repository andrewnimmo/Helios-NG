head	1.9;
access;
symbols
	Helios_1_3_1:1.9
	Helios_C40_1_3_Official_Release:1.8
	Alenia_release:1.7
	Helios1_3:1.1;
locks; strict;
comment	@# @;


1.9
date	93.08.11.14.11.40;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	93.04.05.10.44.46;	author judith;	state Exp;
branches;
next	1.7;

1.7
date	92.12.04.18.33.26;	author judith;	state Exp;
branches;
next	1.6;

1.6
date	92.12.01.08.59.45;	author judith;	state Exp;
branches;
next	1.5;

1.5
date	92.11.20.19.22.35;	author craig;	state Exp;
branches;
next	1.4;

1.4
date	92.11.20.19.06.21;	author craig;	state Exp;
branches;
next	1.3;

1.3
date	92.11.16.11.49.54;	author craig;	state Exp;
branches;
next	1.2;

1.2
date	92.11.10.17.52.45;	author craig;	state Exp;
branches;
next	1.1;

1.1
date	92.10.29.18.14.23;	author martyn;	state Exp;
branches;
next	;


desc
@C40 specific help pages.
@


1.9
log
@Clean up table of Contents
@
text
@#
*n AllocSpecial\System library
*P Allocates memory from one of the special memory pools
*I <memory.h>
*F Carrier *AllocSpecial( word size, word type, Pool *pool );
*A %ssize%s - Size of memory to allocate
*A %stype%s - Type of memory to allocate
*A %spool%s - Pointer to pool that is to receive the allocated block
*R Pointer to a RAM carrier structure, or NULL
*D This function allocates memory from one of the special memory pools
which may exist. NULL is returned if the requested memory cannot be allocated.
The %btype%b field indicates which special pool the
memory should be allocated from: it is a bitwise OR of the
following property flags:
*c=RAMType_Dynamic         Slower or dynamic RAM.
*c=
*c=RAMType_Static          Faster or static RAM.
*c=
*c=
*c=RAMType_Direct          Directly addressable from C programs.
*c=
*c=RAMType_Indirect        Only addressable via machine pointers.
*c=
*c=
*c=RAMType_Local           Memory is on local processor Bus.
*c=
*c=RAMType_Global          Memory is on global processor Bus.
*p Only one option from each pair should be given. Note that memory which
is denoted %bGlobal%b is not necessarily shared with other processors. If 
an option from one of the pairs is not selected, %bAllocSpecial%b
defaults to the first option defined for each pair.
*p For compatibility, the %bAllocFast()%b function is equivalent to 
%bAllocSpecial()%b for %bStatic/Direct/Local%b type RAM. 
*p %bAllocSpecial%b will only allocate memory that is not being used for the
standard memory allocator. Usually all local RAM (except for on-chip
RAM) is used by the standard allocator, and can be accessed by means of
the various Helios memory allocation functions such as %bmalloc%b.
*p The result of this function is a pointer to a %bCarrier%b structure:
*c=struct Carrier {
*c=      MPtr		Addr;	/* Machine pointer of RAM block		*/
*c=      Size		Size;	/* Size of RAM block			*/
*c=      Word		Type;	/* Type of memory in RAM block		*/
*c=};
*p The %bAddr%b field will always be a machine address, which may be converted
into a normal data pointer only if the memory has the %bDirect%b property.
*p The %bsize%b argument to %bAllocSpecial()%b and the %bSize%b field of the
carrier both indicate the memory block's size in multiples of it's
allocation unit. On the Transputer this will always be in bytes, but on the
C40 this is a %bword%b count.
*p Special memory may be freed by passing the carrier pointer to %bFreeMem()%b.
*x AllocFast
*x AllocMem
*x FreeMem
*x LowAllocMem
*x Malloc
*x MallocFree
*q Allocating memory
*q Memory allocation - see also %bAllocSpecial%b
#
*n as\Helios command
*P Assembles an assembler file into object code.
*F as [<option>...] [<input>...]
*D Given a file containing assembler code, %bas%b will assemble the contents
   into object code and send the object code to stdout or to the file
   specified by the %b-o%b option.
*p If no options or files are provided with
   the command, input is expected from stdin.
*p The options are as follows:
*l %b-h%b
*t provides help information for this command.
*l %b-n modulename%b
*t supplies the module name, rather than using the object file name.
This option is only useful for shared library construction.
*l %b-d%b
*t disables module header / tailer generation.
*l %b-v moduleversion%b
*t sets version number other than 1. This option is only useful for 
shared library construction.
*l %b-x moduleno%b
*t fixes module table slot number. This option is only useful for shared
library construction.
*l %b-o%b
*t redirects the output to an object file.
*x disas
*x ampp
*x ld
*x objdump
*p Refer to the %sHelios-C40 Assembler%s document for detailed information
   on the assembler program.
*k C40
#
*n DataToFuncConvert\C library function
*P Converts a pointer to data into a pointer to a function.
*I <helios.h>
*F VoidFnPtr _DataToFuncConvert(void *ptr);
*A %sptr%s - pointer to data.
*R pointer to a function or a NULL pointer.
*E If the pointer could not be converted, returns NULL.
*D The C compiler for Helios running on a C40 stores pointers to
   functions and pointers to data in different ways.  This function is provided to
   allow conversion between the two formats.  This kind of conversion cannot be
   achieved using unions.
*x FuncToDataConvert
*x C40CAddress
*x C40WordAddress
*p Refer to : %sHelios-C40%s, section 4.4 %sByte versus machine pointers%s and section 
4.5.2 %sMachine pointers%s.
*k C40
#
*n C40CAddress\C library function
*P Converts a machine pointer into a C pointer.
*I <helios.h>
*F void * C40CAddress(MPtr mp);
*A %smp%s - machine pointer to data.
*R C pointer or a NULL pointer.
*E If the pointer could not be converted, returns NULL.
*D This function converts a machine pointer to a C pointer.  If %smp%s is not
   within the C addressability range, the result is NULL.
*x FuncToDataConvert
*x DataToFuncConvert
*x C40WordAddress
*p Refer to : %sHelios-C40%s, section 4.4 %sByte versus machine pointers%s and section 4.5.2 %sMachine pointers%s.
*k C40
#
*n C40WordAddress\C library function
*P Converts a C pointer into a machine pointer.
*I <helios.h>
*F MPtr C40WordAddress(void *ptr);
*A %sptr%s - C pointer to data.
*R a machine pointer.
*D This function converts a C pointer into a machine pointer.  This will always
   work, but may of course lose some byte selection information.
*x FuncToDataConvert
*x DataToFuncConvert
*x C40CAddress
*p Refer to : %sHelios-C40%s, section 4.4 %sByte versus machine pointers%s and section 4.5.2 %sMachine pointers%s.
*k C40
#
*n disas\Helios command
*P Disassembles executable files into text representing assembler code.
*F disas [- bBptThH][help][?][-][--] [<file>...]
*D %bdisas%b, given an executable file, will output a textual
   representation of the contents. By default, the address in words, the ASCII
   equivalent and the assembler mnemonics are output for each word.
   If no options or files are provided with the command, input is expected from
   stdin. The options are as follows:
*l %b-b%b
*t Enables branch tracing (default).
*l %b-B%b
*t Disables branch tracing.
*l %b-p%b
*t Displays PCS register aliases.
*l %b-t%b
*t Provides output compatible with TI assembler.
*l %b-T%b
*t Disables TI compatibility format (default).
*l %b-h%b
*t Assumes the code is in Helios executable format which
   contains special characters to distinguish such things as file
   name and function names (default).
*l %b-H%b
*t Disables the Helios executable format.
*l %b-help%b
*t Provides help information for this command.
*l %b-?%b
*t Provides help information for this command.
*l %b-%b
*t (Dash symbol) disassembles from stdin.
*l %b- -%b
*t (Two dash symbols) treats all further command line options as file names to
   disassemble.
*x as
*x objdump
*k C40
#
*n FuncToDataConvert\C library function
*P Converts a pointer to a function into an equivalent pointer to data.
*I <helios.h>
*F void* _FuncToDataConvert(VoidFnPtr ptr);
*A %sptr%s - pointer to function.
*R pointer to data or a NULL pointer.
*E If the pointer could not be converted, returns NULL.
*D The C compiler for Helios running on a C40 stores pointers to
   functions and pointers to data in different ways.  Conversion between two types
   of pointers cannot be achieved by casting the pointers, or by using unions, and so
   this function is provided to enable the conversion to take place.
*x DataToFuncConvert
*x C40CAddress
*x C40WordAddress
*p Refer to : %sHelios-C40%s, section 4.4 %sByte versus machine pointers%s and section 4.5.2 %sMachine pointers%s.
*k C40
#
*n GetIDROM\System library
*P Returns the pointer to the saved IDROM structure.
*I <c40.h>
*F IDROM *GetIDROM(void);
*D %bGetIDROM%b returns the pointer to the saved IDROM structure.
   This structure is read only and describes the configuration of the processor.
   This function is only implemented on C40 processors. This structure is as
   follows:
*c= typedef struct IDROM {
*c= word size;              /*self inclusive size of this block      */
*c= short MAN_ID;           /*TIM-40 module manufacturers ID         */
*c= byte CPU_ID;            /*CPU type (00=C40)                      */
*c= byte CPU_CLK;           /*CPU cycle time (60ns = 59)             */
*c= short MODEL_NO;         /*TIM-40 module model number             */
*c= byte REV_LVL;           /*module revision level                  */
*c= byte RESERVED;          /*currently unused (align word boundary) */
*c= word GBASE0;            /*address base of global bus strobe 0    */
*c= word GBASE1;            /*address base of global bus strobe 1    */
*c= word LBASE0;            /*address base of local bus strobe 0     */
*c= word LBASE1;            /*address base of local bus strobe 1     */
*c= word GSIZE0; /*size in words of memory of global bus strobe 0    */
*c= word GSIZE1; /*size in words of memory of global bus strobe 1    */
*c= word LSIZE0; /*size in words of memory of local bus strobe 0     */
*c= word LSIZE1; /*size in words of memory of local bus strobe 1     */
*c= word FSIZE;  /*size in words of fast ram pool
*c=             (including on-chip RAM)                              */
*c=
*c= /* Each of the following bytes contain 2 nibbles, one for        */
*c= /* strobe 0 and one for strobe 1.  The nibbles define how many   */
*c= /* cycles it takes to read a word from that strobe's associated  */
*c= /* memory*/
*c=
*c= byte WAIT_G;        /* within page on global bus                  */
*c= byte WAIT_L;        /* within page on local bus                   */
*c= byte PWAIT_G;       /* outside page on global bus                 */
*c= byte PWAIT_L;       /* outside page on local bus                  */
*c= word TIMER0_PERIOD; /* period time for 1ms interval on timer 0    */
*c= word TIMER1_PERIOD; /* period for DRAM refresh timer (optional)   */
*c= word TIMER0_CTRL;   /* contents set TCLK0 to access RAM not IDROM */
*c= word TIMER1_CTRL;   /* sets up timer to refresh DRAM (optional)   */
*c= word GBCR;          /* global bus control register                */
*c= word LBCR;          /* local bus control register                 */
*c= word AINIT_SIZE;    /* total size of auto-initialization data     */
*c= } IDROM;
*x idrom
*k C40
#
*n idrom\Helios command
*P Prints contents of IDROM structure in user-readable form.
*F idrom
*D %bidrom%b prints contents of the IDROM structure on stdout.
   This structure contains information that characterizes the C40 system. Its
   format is defined by the TIM-40 standard.  This command is only implemented
   on Helios-C40.
*x GetIDROM
*p Refer to : %sTMS320C4x Module Specification%s, Draft 0.232, published by Texas Instruments Ltd.
*k C40
#
*n JTAGHalt\System library
*P Forces an emulator halt.
*I <c40.h>
*F void JTAGHalt(void);
*D %bJTAGHalt%b causes an emulator halt (if the Texas Instruments XDS510
hardware debugger is   connected to the system).  This function implements
the C40 %bSWI%b software interrupt instruction.  This function is only 
implemented on Helios-C40.
*k C40
#
*n ncc\Helios command
*P This command compiles C files into object code.
*F ncc [-dijwefscECgLUZ][-list][<inputfile>]
*D %bncc%b compiles C source code into C40 object code.  By default this
   command will read C source code from the stdin device and put out object code
   to the stdout device.  The source code can be obtained from a file by specifying
   a filename %b<inputfile>%b as an argument.  Object code can also be sent to a file
   by specifying the appropriate compiler option.
*p The options are as follows:
*l %b-d%b%s<symbol>%s
*t As %b#define%b %ssymbol%s 1 at start of file.
*l %b-d%b%s<symbol>=<vl>%s
*t As %b#define%b %ssymbol vl%s at start of file.
*l %b-i%b%s<dr1>...,<drn>%s
*t Lists where to scan for %b#include ``xxx''%b. %sdr%s indicates directory
   name followed by %b/%b.
*l %b-j%b%s<dr1>...,<drn>%s
*t Lists where to scan for %b#include <xxx>%b. %sdr%s indicates directory
   name followed by %b/%b.
*l %b-w%b%s<letters>%s
*t Suppresses various  warnings (when):
*l a
*t `=' occurs in condition context.
*l d
*t (some) deprecated features are used.
*l f
*t functions are implicitly declared as %bextern int%b.
*l i
*t pointers are explicitly cast into integers.
*l o
*t old style K&R function headers are used.
*l u
*t an unused variable is encountered.
*l v
*t void functions are written without void
*l x
*t doubles are passed to functions which take a variable number of arguments.
*l %b-e%b%s<letters>%s
*t Suppresses various non-serious errors when:
*l c
*t ANSI disallowed casts are used.
*l p
*t junk occurs after %b#else%b and %b#endif%b.
*l z
*t zero sized arrays occur.
*l %b-f%b%s<letters>%s
*t Enables various extra features:
*l b
*t enables support for the %b_backtrace()%b function.
*l d
*t forces all external calls from the module to indirect through the module
   table.  Also forces the generation of %bcodetable%b directives and codetable
   initialization code.
*l f
*t suppresses insertion of function names in code image (reduces the output
   information  given by %b_backtrace()%b and %b_mapstore()%b if an untrapped
   exception occurs but typically saves 5 per cent of code size).
*l h
*t for policing software quality requirements: requires all %bextern%b function
   definitions to be preceded  by a declaration (presumably from a header file)
   thus ensuring consistency, and reports on all forward static declarations
   which are unused when the function is defined.
*l i
*t includes the contents of %b#include "..."%b files in the listing output
   produced by the %b-list%b command line option.
*l j
*t includes the contents of %b#include <...>%b files in the listing output.
*l m
*t gives one warning for each %b#defined%b but unused macro.
*l o
*t produces  warnings whenever old style  K&R function headers are encountered.
*l p
*t produces warnings whenever a pointer  is explicitly cast  to an integer.
*l s
*t produces extra annotation with the assembler output from the %b-s%b command
   line option.
*l u
*t includes preprocessor  directives in the listing output from the %b-list%b
   command line option.
*l v
*t gives one warning for each declared but unused variable  or function.
*l %b-s%b%s<filename>%s
*t Sends assembly code to named file.
*l %b-list%b
*t Produces a listing output of the compiled source code.
*l %b-c%b
*t Compiles, but does not link the resulting object file(s).
*l %b-E%b
*t Preprocesses, but does not compile.
*l %b-C%b
*t Prevents %b-E%b option from removing comments from its output.
*l %b-g%b
*t Produces code compatible with the Helios Source Level Debugger.
*l %b-fussy%b
*t Is even more pedantic about possible errors in the code.
*l %b-l%b%s<libraries>%s
*t Specifies a comma-separated list of libraries to link with instead of the
   standard libraries.
*l %b-U%b%s<symbol>%s
*t Undefines symbol at start of file (this is the complement of the -d option).
*l %b-Z%b%s<letters>%s
*t Enables various special compiler features:
*l p %s<letter><int>%s
*t simulates %b#pragma%b %sletter int%s
*l q %s<letter>%s
*t enables compiler debugging features.
*l l
*t produces code suitable for shared libraries.
*l r
*t produces code suitable for device drivers.
*l s
*t disables split module table output.
*l c
*t assumes that %bchar%b is signed.
*l i %s<file>%s
*t pre-includes %sfile%s before processing source files.
*p %bNote%b: The %bncc%b command is not available in all versions of Helios.
*x as
*x ld
*x objed
*x objdump
*k C40
#
*n rboot\Helios command
*q rboot, network command
*P Boots a c40 processor by hand.
*F rboot [-l<link>] <link> <myname> <childname> [<link modes> <memory limit>]
*D The %brboot%b command is used to boot up processors by
   hand, usually when the network is too small to warrant running all of the
   networking software. The command must be executed on an active processor
   adjacent to the one being booted. The first argument specifies the link
   used for the bootstrap, an integer between 0 and 5 in the case of C40s.
   The second argument is
   the name of the processor doing the booting. The third argument is the
   name of the processor being booted. Then there are two optional arguments:
   %slink modes%s and %smemory limit%s. The %slink modes%s argument specifies the modes
   of the four links of the newly booted processor: 0 means not connected; 1
   means dumb; 2 means intelligent and active; 3 means intelligent but
   pending. The final argument is rarely required: it specifies the amount of
   memory to be used on the newly booted processor. This option is necessary
   if the target processor has some memory mapped hardware such as video
   memory adjacent to normal memory, which could cause the kernel to use that
   video memory for memory allocation. For example, if the processor has one
   megabyte of normal memory immediately followed by one megabyte of video
   memory, a size of 0x1000000 could be used.
*p If the target processor is being booted through any link other than its
   link 0, it is necessary to specify the target link. For example,
   if processor 00 link 2 goes to processor 01 link 1, the command
   to boot processor 01 is:
*c= rboot -l1 2 /00 /01
*p Note that the C40 must have an ID ROM for this command to work.
*x clink
*k C40
#
*n MP_BusyWait\System library
*P wait on a counting semaphore (spin lock) in 
   shared memory
*I <c40.h>
*F word MP_BusyWait(MPtr countaddr);
*A %scountaddr%s - machine address of semaphore
*R the value of new semaphore count
*D This function busy waits while the semaphore count is zero, 
   then decrements the semaphore count and returns.
*p All accesses to the semaphore are interlocked with LDII/STII
instructions. The semaphore should be initialized to the number of
concurrent %bMP_BusyWait%b s that will succeed before the first %bMP_Signal%b 
on this semaphore is
executed. %bMP_BusyWait%b / %bMP_signal%b should not share the semaphore with
other threads on the same processor unless they are called by means of
the %bSystem%b function.
*x MP_Signal
*x System
#
*n MP_GetData\System library
*P copy data from a machine address to a byte address
*I <c40.h>
*F void MP_GetData(void *dstbytepointer, MPtr addr, word wordoffset, word 
   numwords);
*A %sdstbytepointer%s - C pointer to destination byte address
*A %saddr%s - source machine address
*A %swordoffset%s - added to %saddr%s
*A %snumwords%s - number of words to copy
*D %bMP_GetWord%b, %bMP_PutWord%b, %bMP_GetData%b and %bMP_PutData%b 
   are full address range access functions that provide the means to access data
   anywhere on either address bus.
*p %bMP_GetData%b copies %snumwords%s words of data from the specified machine 
   address to the destination byte address. Note that the 
   byte address is assumed to be word aligned.
*x MP_GetWord
*x MP_PutWord
*x MP_PutData
#
*n MP_GetWord\System library
*P get a word of data from a machine address
*I <c40.h>
*F word MP_GetWord(MPtr addr, word wordoffset);
*A %saddr%s - source machine address
*A %swordoffset%s - added to %saddr%s
*R the value of word at specified machine address
*D %bMP_GetWord%b, %bMP_PutWord%b, %bMP_GetData%b and %bMP_PutData%b 
   are full address range access functions that provide the means to access data
   anywhere on either address bus.
*p %bMP_GetWord%b returns the value of the word at the specified machine
   address.
*x MP_PutWord
*x MP_GetData
*x MP_PutData
#
*n MP_PutData\System library
*P copy data from a byte address to a machine address
*I <c40.h>
*F void MP_PutData(MPtr addr, word wordoffset, void *src, word 
   wordcount);
*A %saddr%s - destination machine address
*A %swordoffset%s - added to %saddr%s
*A %ssrcbytepointer%s - C pointer to source byte address
*A %swordcount%s - number of words to copy
*D %bMP_GetWord()%b, %bMP_PutWord%b, %bMP_GetData%b and %bMP_PutData%b 
   are full address range access functions that provide the means to access data
   anywhere on either address bus.
*p %bMP_PutData%b copies %swordcount%s words of data from the specified byte 
   address to the destination machine address. Note that the byte
   address is assumed to be word-aligned.
*x MP_GetWord
*x MP_PutWord
*x MP_GetData
#
*n MP_PutWord\System library
*P write a word of data to a machine address
*I <c40.h>
*F void MP_PutWord(MPtr addr, word wordoffset, word data);
*A %saddr%s - machine address
*A %swordoffset%s - added to %saddr%s
*A %sdata%s - integer value
*D %bMP_GetWord%b, %bMP_PutWord%b, %bMP_GetData%b and %bMP_PutData%b 
   are full address range access functions that provide the means to access data
   anywhere on either address bus.
*p %bMP_PutWord%b writes the value of the %sdata%s word to the specified 
   machine address.
*x MP_GetWord
*x MP_GetData
*x MP_PutData
#
*n MP_ReadFPLock\System library
*P lock shared memory and read a single precision floating 
   point number
*I <c40.h>
*F float MP_ReadFPLock(MPtr lockaddr);
*A %slockaddr%s - machine address
*R the value of floating point number at specified machine address
*D %bMP_ReadFPLock%b locks shared memory and returns the value
   of the single precision floating point number at the specified machine 
   address. This is a C implementation of the C40 LDFI instruction.
*x MP_Readlock
*x MP_WriteUnlock
*x MP_WriteFPUnlock
*x MP_Signal
*x MP_BusyWait
#
*n MP_ReadLock\System library
*P lock shared memory and read an integer
*I <c40.h>
*F word MP_ReadLock(MPtr lockaddr);
*A %slockaddr%s - machine address
*R the value of integer at specified machine address
*D %bMP_ReadLock%b locks shared memory and returns the value of
   the word at the specified machine address. This is a C implementation
of the C40 LDII instruction.
*x MP_ReadFPLock
*x MP_WriteUnlock
*x MP_WriteFPUnlock
*x MP_Signal
*x MP_BusyWait
#
*n MP_Signal\System library
*P signal a counting semaphore (spin lock) in 
   shared memory
*I <c40.h>
*F word MP_Signal(MPtr countaddr);
*A %scountaddr%s - machine address of semaphore
*R the value of new semaphore count
*D %bMP_Signal%b increments the semaphore count and returns the 
   new current count value. All accesses to the semaphore are
interlocked with LDII/STII instructions. The semaphore should be
initialized to the number of concurrent %bMP_BusyWait%bs that will succeed
before the first %bMP_Signal%b is executed. %bMP_Busywait%b / %bMP_Signal%b should not
share the semaphore with other threads on the same processor unless these 
functions are called by means of the %bSystem%b function.
*x MP_BusyWait
#
*n MP_WriteFPUnlock\System library
*P write a single precision floating point number and unlock 
   shared memory
*I <c40.h>
*F void MP_WriteFPUnlock(MPtr lockaddr, float data);
*A %slockaddr%s - machine address
*A %sdata%s - floating point value
*D %bMP_WriteFPUnlock%b writes the value of the single precision
   floating point argument to the specified machine address and unlocks 
   shared memory. This is a C implementation of the C40 STFI instruction.
*x MP_Readlock
*x MP_ReadFPLock
*x MP_WriteUnlock
*x MP_Signal
#
*n MP_WriteUnlock\System library
*P write an integer and unlock shared memory
*I <c40.h>
*F void MP_WriteUnlock(MPtr lockaddr, word data);
*A %slockaddr%s - machine address
*A %sdata%s - integer value
*D %bMP_WriteUnlock%b writes the value of the data word to the 
   specified machine address and unlocks shared memory. This is a C
implementation of the C40 STII instruction.
*x MP_Readlock 
*x MP_ReadFPLock
*x MP_WriteFPUnlock
*x MP_Signal
*x MP_BusyWait
#
*n MP_LinkIn\System library
*P Transfers data from a link
*I <link.h>
*F word MP_LinkIn(word size, word link, MPtr buf, word timeout);
*A size - Number of words to transfer
*A link - Link to use
*A buf - Machine address of data
*A timeout - Transfer timeout in microseconds
*R Error code
*D This function transfers %ssize%s words of data from a link to the specified
machine address (see %bMP_LinkOut()%b
for details on how to transfer data to a link). An error result is
returned if %slink%s is invalid, the link is not in DUMB mode, or the
transfer took more than the given time. The link should have been
previously reserved with %bAllocLink()%b.
*p Although %stimeout%s must be specified in microseconds, Helios converts
this timeout to a multiple of one second, with a minimum timeout of two
seconds.
*x AllocLink
*x FreeLink
*x LinkIn
*x MP_LinkOut
*q Link dumb mode
*q Dumb link mode
*q Link - transfer data through
*q Data transfer through link
*q Transfer data through link
#
*n MP_LinkOut\System library
*P Transfers data to a link
*I <link.h>
*F word MP_LinkOut(word size, word link, MPtr buf, word timeout);
*A size - Number of words to transfer
*A link - Link to use
*A buf - Machine address of data
*A timeout - Transfer timeout in microseconds
*R Error code
*D This function transfers %ssize%s words of data from the specified machine
address to a link (for details on how
to transfer data from a link, see %bMP_LinkIn()%b). An error result is
returned if %slink%s is invalid, the link is not in DUMB mode, or the
transfer took more than the given time. The link should have been
previously reserved with %bAllocLink()%b.
*p Although %stimeout%s must be specified in microseconds, Helios converts
this timeout to a multiple of one second, with a minimum timeout of two
seconds.
*x AllocLink
*x FreeLink
*x LinkOut
*x MP_LinkIn
*q Transfer data through a link
*q Data transfer through link
*q Link - transfer data through
@


1.8
log
@Made many modifications for the C40 release
@
text
@d2 1
a2 1
*n AllocSpecial\System library function
d193 1
a193 1
*n GetIDROM\C40 library function
d251 1
a251 1
*n JTAGHalt\C40 library function
d415 1
a415 1
*n MP_BusyWait\System library function
d434 1
a434 1
*n MP_GetData\System library function
d453 1
a453 1
*n MP_GetWord\System library function
d469 1
a469 1
*n MP_PutData\System library function
d488 1
a488 1
*n MP_PutWord\System library function
d504 1
a504 1
*n MP_ReadFPLock\System library function
d520 1
a520 1
*n MP_ReadLock\System library function
d535 1
a535 1
*n MP_Signal\System library function
d551 1
a551 1
*n MP_WriteFPUnlock\System library function
d566 1
a566 1
*n MP_WriteUnlock\System library function
d581 1
a581 1
*n MP_LinkIn\System library function
d609 1
a609 1
*n MP_LinkOut\System library function
@


1.7
log
@lots of changes for C40 release
@
text
@d79 2
a80 2
*l %b-x modulenumber%b
*t fixes module table slot number .This option is only useful for shared
d106 2
a107 2
*p Refer to : %sHelios-C40%s, section 4.4 Byte versus machine pointers and section 
5.2 Machine pointers.
d113 1
a113 1
*F Void * C40CAddress(MPtr mp);
d115 1
a115 1
*R c pointer or a NULL pointer.
d122 1
a122 1
*p Refer to : %sHelios-C40%s, section 4.4 Byte versus machine pointers and section 5.2 Machine pointers.
a130 1
*E If the pointer could not be converted, returns NULL.
d136 1
a136 1
*p Refer to : %sHelios-C40%s, section 4.4 Byte versus machine pointers and section 5.2 Machine pointers.
d170 1
a170 1
*t (Double dash symbol) treats all further command line options as file names to
d190 1
a190 1
*p Refer to : %sHelios-C40%s, section 4.4 Byte versus machine pointers and section 5.2 Machine pointers.
d220 3
a222 3
*c= /* Each of the following bytes contain 2 nibbles, one for      */
*c= /* strobe 0 and one for strobe 1.  The nibbles define how many */
*c= /* cycles it takes to read a word from that strobe's associated */
d272 4
a275 4
*l %b-d%b%s<symbol>=<value>%s
*t As %b#define%b %ssymbol value%s at start of file.
*l %b-i%b%s<dir1>...,<dirn>%s
*t Lists where to scan for %b#include ``xxx''%b. %sdir%s indicates directory
d277 2
a278 2
*l %b-j%b%s<dir1>...,<dirn>%s
*t Lists where to scan for %b#include <xxx>%b. %sdir%s indicates directory
d349 1
a349 1
*t Preprocesses, but does not link.
d354 1
a354 1
*l %bfussy%b
d356 1
a356 1
*l %b-L%b%s<libraries>%s
d419 2
a420 2
*F word MP_BusyWait(sem countaddr);
*A %semaddr%s - machine address of semaphore
d443 1
a443 1
*D %bMP_GetWord%b, %bMP_PutWord%b, %bMP_GetData%b and also %bMP_PutData%b 
d447 1
a447 1
   address to the destination byte address. Notice that the 
d460 1
a460 1
*D %bMP_GetWord%b, %bMP_PutWord%b, %bMP_GetData%b and also %bMP_PutData%b 
d472 1
a472 1
*F void MP_PutData(MPtr addr, word wordoffset, void *srcbytepointer, word 
d478 1
a478 1
*D %bMP_GetWord()%b, %bMP_PutWord%b, %bMP_GetData%b and also %bMP_PutData%b 
d481 2
a482 2
*p %bMP_PutData%b copies %swordcount%s words of data from the specified byte (local
   bus) address to the destination machine address. Notice that the byte
d495 1
a495 1
*D %bMP_GetWord%b, %bMP_PutWord%b, %bMP_GetData%b and also %bMP_PutData%b 
d545 1
a545 1
initialized to the number of concurrent %bMP_BusyWait%b s that will succeed
d560 1
a560 1
   shared memory. This is a C implementation of the C40 STII instruction.
d625 1
a625 1
this timeouts to a multiple of one second, with a minimum timeout of two
@


1.6
log
@added AllocSpecial
@
text
@d6 3
a8 3
*A size - Size of memory to allocate
*A type - Type of memory to allocate
*A pool - Pointer to pool that is to receive the allocated block
d11 3
a13 2
which may exist. The %btype%b field indicates which special pool the
memory should be allocated from, it should be a bitwise OR of the
d15 1
a15 1
*c=RAMType_Dynamic	Slower or dynamic RAM.
d17 1
a17 1
*c=RAMType_Static	Faster or static RAM.
d20 1
a20 1
*c=RAMType_Direct	Directly addressable from C programs.
d22 1
a22 1
*c=RAMType_Indirect	Only addressable via machine pointers.
d25 1
a25 1
*c=RAMType_Local	Memory is on local processor Bus.
d27 1
a27 1
*c=RAMType_Global	Memory is on global processor Bus.
d29 9
a37 3
is denoted %bGlobal%b is not necessarily shared with other processors.
For compatibility, the %bAllocFast()%b function is equivalent to 
%bAllocSpecial()%b for %bStatic/Direct/Local%b type RAM.
d46 1
a46 1
*pThe %bsize% argument to %bAllocSpecial()%b and the %bSize%b field of the
d48 1
a48 1
allocation unit. On the transputer this will always be in bytes, but on the
d54 3
d58 1
a58 1
*q Memory allocation - see also AllocSpecial
d61 1
a61 1
*P Assembles a C40 assembler file into object code.
d69 15
a83 12
*l -h
*t Provides help information for this command.
*l -d
*t Disable module header / tailer generation.
*l -n modulename
*t Supply module name, rather than use objectfile name.
*l -v moduleversion
*t Set version number other than 1.
*l -x modulenumber
*t Fix module table slot number.
*l -o
*t Redirects the output to an object file.
d87 1
a91 201
*n AvoidEvents\Event library function
*P Executes the given function with no interrupt.
*I <event.h>
*F word AvoidEvents(WordFnPtr fn, ...);
*A %sfn%s - function to be executed.
*D %bAvoidEvents%b accepts a function pointer and a list of arguments to
   pass to the function.  It executes the function disabling the interrupts
   for the duration of the call.  Once the function terminates the interrupts
   are re-enabled.
*x SetEvent
*x HardenedSignal
*x HardenedWait
*p Also refer to %b_word()%b in %sThe Helios C Manual%s.
*k C40
#
*n c\Helios command
*P Runs the Helios compiler driver for the C40
*F c [opts] <filename> [<filename> ...]
*D The %bc%b command is used to compile and link a program. It
   takes a list of files and decides what to do with them according to their
   suffix. The file names supported are as follows:
*l Suffix
*t Meaning
*l %b.a%b
*t Macro assembly language (AMPP) source file
*l %b.c%b
*t C language source file
*l %b.i%b
*t C language source file (pre-processed version)
*l %b.f%b
*t FORTRAN language source file
*l %b.o%b
*t Assembled file, ready for linking
*l %b.p%b
*t Assembled file, ready for linking
*l %b.s%b
*t Assembly language source file
*l %b.def%b
*t Modula-2 definition source file
*l %b.mod%b
*t Modula-2 program source file
*l %b.mod%b
*t Modula-2 program source file
*l %b.lib%b
*t Scanned library
*p If no other arguments are given, the program compiles the programs for
   the languages specified as .c or .f, assembles any .s files and then links
   all the resulting binaries along with any supplied .o files into an
   executable program called a.out, removing the intermediary -s files.
*p The following options can be used to alter the behaviour of the program:
*l Option
*t Action
*l %b-a%b %s<text>%s
*t Pass %s<text>%s as an option to assembler.
*l %b-b%b
*t Don't link with standard maths libraries (fplib and fpclib).
*l %b-c%b
*t Compile/Assemble only, don't link.
*l %b-d%b%s<name>%s
*t Specify output file name for library .def compilations.
*l %b-e[6|7]%b
*t Enforce Fortran standard.
*l %b-f%b %s<name>%s
*t Specify filename for assembler's virtual memory system.
*l %b-g%b
*t Compiler for debugging.
*l %b-h%b%s<val> %s
*t Specify heap size of program.
*l %b-j%b
*t Create scanned library
*l %b-l%b%s<name>%s
*t Link with library <name>
*l %b-m%b
*t Compile code for libraries.
*l %b-n%b
*t Don't actually execute commands (implies -v).
*l %b-n%b%s<string>%s
*t Specify object name of program.
*l %b-o%b%s<name>%s
*t Specify output name (default *.o or "a.out") ("-" is stdout)
*l %b-p%b
*t Compile code for profiling.
*l %b-q%b%s<opt>%s
*t Enable compiler debugging features (where the %sopt%ss are
   abdfghimopqrstuwxyz).
*l %b-r%b
*t Compile code for device drivers.
*l %b-s%b%s<val>%s
*t Specify stack size of program.
*l %b-t%b
*t Compile code for tracing.
*l %b-u%b
*t Prevent removal of intermediary files.
*l %b-v%b
*t Verify command being executed.
*l %b-w[Aacdfpsvz]%b
*t Suppress warnings.
*l %b-y%b%s<text>%s
*t Pass <text> as an option to the macro pre-processor
*l %b-z%b %s<text>%s
*t Pass %stext%s as an option to C compiler.
*l %b-A%b%s<text>%s
*t Pass <text> as an option to linker.
*l %b-B%b
*t Do not link with any libraries. Do not perform objed.
*l %b-C%b
*t Perform memory checking
*l %b-C40%b
*t Compile code for the C40 if cross-compiling.
*l %b-D%b%s<name>%s
*t #define <name>
*l %b-D%b%s<name>=<val>%s
*t #define <name> to be <val> (default <val> is 1).
*l %b-E%b
*t Pre-process only. Do not compile.
*l %b-F[Afghmsv]%b
*t Enable compiler features (`s' turns off stack checking and `g' removes
   procedure names; `A' switches on `s' and `g').
*l %b-I%b%s<dir>%s
*t Specify a directory to be searched for #include or M2 symbol files.
*l %b-J%b
*t Append to a scanned library.
*l %b-L%b%s<name>%s
*t Link with library <name>
*l %b-M%b%s<name>%s
*t Produce map file <name> (F77).
*l %b-O%b
*t Optimise code, perform full link.
*l %b-P%b%s<text>%s
*t Pass <text> as an option to the pre-processor
*l %b-R%b
*t Force use of RAM disc for temporary FORTRAN and Modula-2 files, even if
   RAM disc is not loaded.
*l %b-S%b
*t Produce textual assembler output from *.c in *.s, don't link.
*l %b-T[4|8]%b
*t Specify Transputer type.
*l %b-V%b
*t Pass on verbose flag to executed commands.
*l %b-W%b%s<val>%s
*t Specify warning level (F77).
*l %b-X%b%s<val>%s
*t Specify cross reference width (F77).
*l %b-Z%b%s<text>%s
*t Pass %s<text>%s as an option to FORTRAN compiler.
*l %b-help%b
*t Display list of options supported by c.
*p For example, suppose you have a program called %stest%s, you might type:
*c= c -o test test.c
*p and using c for debugging, you might type:
*c= c -g -ld -o test test.c
*p %bc%b uses the following environment variables, if present:
*l C_COMPILER
*t Pathname of the C compiler
*l PRE_PROCESSOR
*t Pathname of the pre-processor
*l ASSEMBLER
*t Pathname of the assembler
*l LINKER
*t Pathname of the linker
*l REMOVER
*t Pathname of the file removal program
*l MACDIR
*t Pathname of the standard AMPP macro directory
*l MACRO
*t Pathname of the AMPP
*l C_LIBDIR
*t Pathname of the library directory
*l C_INCDIR
*t Pathname of the standard C header directory
*l LINK_HELIOS
*t Name of the standard Helios link library
*l LINK_CSTART
*t Name of the C startup file
*l LINK_CLIB
*t Name of the standard C link library
*l NEW_NCC
*t If set, this informs %bc%b which version of the C compiler is being used.
*l OBJNAME
*t Default name of output file
*l MACHINENAME
*t Name of the destination hardware, passed on by %b-D%b.
*p The following constants are also defined by %bc%b when compiling C code:
*l helios
*l __HELIOS
*l __C40
*l __HELIOSC40
*l %s<MACHINENAME>%s
*p Further details can be found in the latest edition of the %sHelios C Manual%s.
*q helios
*q __HELIOS
*q C40
*q __C40
*q __HELIOSC40
*q <MACHINENAME>
*q c
*q Compiler driver
*q AMPP
*x ncc
*k C40
#
d102 1
a102 1
   done by using unions.
d104 4
d110 30
d145 1
a145 1
   equivalent and the assembler mnemonics are provided.
d147 2
a148 3
   the stdin.
*p The options are as follows:
*l -b
d150 1
a150 1
*l -B
d152 1
a152 1
*l -p
d154 1
a154 1
*l -t
d156 1
a156 1
*l -T
d158 1
a158 1
*l -h
d162 1
a162 1
*l -H
d164 1
a164 1
*l -help
d166 6
a171 6
*l -?
*t Provides help information for this command..
*l -
*t Disassembles from stdin.
*l --
*t Treats all further command line options as file names to
d185 3
a187 3
   functions and pointers to data in different ways.  Converting between two types
   of pointers cannot be done by casting the pointers, or by using unions, and so
   this function is provided in order to enable the conversion to take place.
d189 3
d199 1
a199 1
   This structure is read only and represents the configuration of the C40 ROM.
a240 41
*n GetPhysPriRange\Process library function
*P Returns the lowest physical priority level available.
*I <process.h>
*F word GetPhysPriRange(void);
*D %bGetPhysPriRange%b returns the lowest physical priority available.
   %bGetPhysPriRange() + 1%b is therefore the number of physical priority levels
   implemented on this version of Helios.  For example, the Helios-C40 scheduler
   currently implements 8 physical priority levels and so will return 7, whereas
   the transputer implementation will return 1.
*x SetPriority
*k C40
#
*n HardenedSignal\Semaphore library function
*P Signals a semaphore within an interrupt routine.
*I <sem.h>
*F void HardenedSignal(Semaphore *sem);
*A %ssem%s - semaphore to signal.
*D %bHardenedSignal%b increments the semaphore's count by one and
   restarts the first waiting process, if any.  This function is designed to be called
   from within an interrupt routine.  This function is only implemented on non-
   transputer implementations of Helios.
*p Semaphores should not be shared between hardened and non-hardened versions
   of %bWait()%b and %bSignal()%b.
*x HardenedWait
*x SetEvent
*k C40
#
*n HardenedWait\Semaphore library function
*P Waits on a semaphore to be signalled from an interrupt routine.
*I <sem.h>
*F void HardenedWait(Semaphore *sem);
*A %ssem%s - semaphore to wait on.
*D %bHardenedWait%b decrements the semaphore counter.  If the result
   is less than zero, it suspends the process until a HardenedSignal is performed.
   This function is only implemented on non-transputer processors.
*p %bHardenedWait%b and %bHardenedSignal%b are used to signal user-level threads that
   an interrupt has been handled.  Data from the interrupting device may now be
   available to read.
*x HardenedSignal
*k C40
#
d244 1
a244 1
*D %bidrom%b prints the contents of the IDROM structure on stdout.
d247 1
a247 1
   on C40-Helios implementations.
d256 4
a259 4
*D %bJTAGHalt%b causes an emulator halt (only if the XDS510 is
   connected to the system).  This function implements the C40 %bSWI%b software
   interrupt instruction.  This function is only implemented on C40-Helios
   implementations.
a261 66
*n ld\Helios command
*P Links together multiple C40 object files.
*F ld [-x] [-v [errfile]] [-n progname] [-s stksize] [-h heapsize] [-] [-?]
   [-STMN] [-help] [-o imgfile] [-l libfile] [objfiles]
*D %bld%b combines multiple object files into a single executable image
   file.  It resolves all of the external module table references, patching the correct
   values into the code.  Library definition files %b(.def)%b may also be included in the
   command line to enable object files to be linked with shared libraries.
*p The options are as follows:
*l -x
*t Outputs the image file in hexadecimal format.
*l -v
*t Switches to verbose reporting.  The optional %berrfile%b causes
   messages to be redirected to that file.
*l -n
*t Inserts %bprogname%b into the program module header.
*l -s
*t Inserts the default stack size into the program module header.
*l -h
*t Inserts the default heap size into the program module header.
*l -o
*t Sends the resulting image file to %bimgfile%b.  If the option is not
   specified, the image file is sent to stdout.
*l -l
*t Reads in a link library file, %blibfile%b.  If any of the library
   modules are not referenced anywhere in the object files, the
   particular module is not linked into the resulting image file.
   This option also stops the linker from complaining about
   multiply defined symbols, allowing you to replace resident
   library functions with your own code.
*l
*t Scanned libraries differ from shared libraries in that their code
   is physically included in the program's image file, rather than
   being linked into the program at run-time.  Scanned libraries
   therefore cannot be used to shared code.
*l -
*t Causes the linker to read form stdin.
*l -?
*t Describes the command and its options.
*l -STMN
*t Disables support for shared module tables.
*l -help
*t Describes the command and its options.
*x as
*x ncc
*x objdump
*k C40
#
*n MachineType\System library function
*P Obtains the type of the current processor.
*I <syslib.h>
*F word MachineType(void);
*R
*f 800\=\T800 transputer
*f 414\=\T414 transputer
*f 425\=\T425 transputer
*f 805\=\T805 transputer
*f 801\=\T801 transputer
*f 400\=\T400 transputer
*f 0xA2\=\ARM2
*f 0xA3\=\ARM3
*f 0x320C40\=\TMS320C40
*f 0x860\=\i860
*D %bMachineType%b returns the current processor type.
*k C40
#
d317 2
a318 2
   information  given by _backtrace() and _mapstore() if an untrapped
   exception occurs but typically saves 5% of code size).
d356 1
a356 1
*t Be even more pedantic about possible errors in the code.
d378 1
a378 1
*p Note: The %bncc%b command is not available in all versions of Helios.
a384 33
*n objdump\Helios command
*P This command dumps object files to stdout.
*F objdump [-dphiln][+<n>][<file>...]
*D %bobjdump%b, given a file containing object code, will dump a
   user-readable representation of its contents to stdout.  By default, the code
   is represented in hexadecimal with its word address and the linker directives
   are presented in user-readable form.  The image static data area and
   codetable sizes are provided.

*p If no options or files are provided with the command, help information is
   displayed.
*p The options are as follows:
*l %b-d%b
*t Provides the full disassembly of the contents of the code sections.
*l %b-p%b
*t Displays PCS register aliases.
*l %b-h%b
*t Provides help information for this command.
*l %b-i%b
*t Provides size information on the image, static table and the code table only.
*l %b-l%b
*t Provides similar output to the default, but all the code is displayed.
*l %b-n%b
*t Provides only the symbol definition information.
*l %b+<n>%b
*t Provides an offset which is used as the base address when printing the
   output.  n is specified in terms of bytes and therefore should be
   multiplied by four on the C40 to give the correct offset.
*x as
*x disas
*x ld
*k C40
#
d387 1
a387 1
*P Boots a processor by hand
d397 1
a397 1
   link modes and memory limit. The link modes argument specifies the modes
d407 3
a409 3
*p If the target processor is being booted via any link other than its
   link 0 then it is necessary to specify the target link. For example,
   if processor 00 link 2 goes to processor 01 link 1 then the command
d412 1
a412 1
*p Note that the C40 must have an ID ROM in order for this command to work.
d416 2
a417 245
*n RestoreCPUState\CPU state library function
*P Restores the state of the CPU.
*I <cpustate.h>
*F void RestoreCPUState(SaveState *threadstate);
*A %sthreadstate%s - pointer to %bSaveState%s structure.
*D %bRestoreCPUState%b restores the state of the CPU from the contents
   of the %bSaveState%b data structure causing control to return to the point
   where the %bSaveCPUState%b function was called.  This is similar to the C
   language longjmp function.
*p The use of the %bSaveCPUState%b and %bRestoreCPUState%b functions require
   careful coding.  A routine that calls the %bSaveCPUState%b and then
   returns before %bRestoreCPUState%b is called, is likely to cause problems.
   The stack frame that existed when %bSaveCPUState%b was called will no
   longer exist, and so any call to %bRestoreCPUState%b will corrupt the
   execution stack.  The contents of the %bSaveState%b structure may be
   modified before a %bRestoreCPUState%b function is called.  These functions
   can be used for a variety of purposes, for example, creating a coroutine
   library.
*p %bRestoreCPUState%b is not available on transputer implementations of Helios.
*p For example, the C40 %bSaveState%b structure is as follows:
*c= typedef struct SaveState {
*c= struct SaveState *next;        /*for queuing on run q's       */
*c=                                /*next must be first elem't    */
*c= struct SaveState *nextknown    /*for exec housekeeping        */
*c= struct SaveState *stdsavearea  /*permanent save area          */
*c= word priority;                 /*thread priority              */
*c= uword endtime;                 /*wakeup time if Sleep()ing    */
*c= word status;                   /*thread status                */
*c= word CPUtime;                  /*milliseconds of CPU time used*/
*c= VoidFnPtr InitialFn;           /*root fn of thread            */
*c= struct CPURegs CPUcontext;     /*CPU state of this thread     */
*c= } SaveState;
*c=
*c= typedef struct CPURegs {
*c= /*C PCS BINDING NAME*/
*c=                   /*C40 REGISTER NAME*/
*c=                                        /*FUNCTION          */
*c= word PC;          /* PC of sliced thread*/
*c= word R_ST;        /* st:status reg*/
*c=                                       /*C ADDRESS REGS    */
*c= word R_ADDR1;     /* ar0:*/
*c= word R_ADDR2;     /* ar1:*/
*c= word R_ADDR3;     /* ar2:*/
*c= word R_ADDR4;     /* ar3: */
*c=                                        /*MISC ADDRESS REGS */
*c= word R_MT;        /* ar4: module table pointer*/
*c= word R_ATMP;      /* ar5: temp address reg*/
*c= word R_USP;       /* ar6: user stack pointer*/
*c= word R_FP;        /* ar7: frame pointer*/
*c=                                        /*REGISTER ARGUMENTS*/
*c= word R_A1;        /* r0: first arg and result reg*/
*c= word R_A1f        /* r0: fp extension to 32bit reg*/
*c= word R_A2;        /* r1: 32bits*/
*c= word R_A2f;       /* r1: fpext*/
*c= word R_A3;        /* r2: 32bits*/
*c= word R_A3f;       /* r2: fpext*/
*c= word R_A4;        /* r3: 32bits*/
*c= word R_A4f;       /* r3: fpext*/
*c=                                        /*REGISTER VARIABLES*/
*c= word R_FV1;       /* r4: 32bits*/
*c= word R_FV1f;      /* r4: fpext*/
*c= word R_FV2;       /* r5: 32bits*/
*c= word R_FV2f;      /* r5: fpext*/
*c= word R_FT1;       /* r6: 32bits*/
*c= word R_FT1f;      /* r6: fpext*/
*c= word R_FT2;       /* r7: 32bits*/
*c= word R_FT2f;      /* r7: fpext*/
*c=                                            /*TEMP REGISTERS*/
*c= word R_V3;        /* r8: 32bits*/
*c= word R_V3f;       /* r8: fpext*/
*c= word R_V4;        /* r9: 32bits*/
*c= word R_V4f;       /* r9: fpext*/
*c= word R_T1;        /* r10: 32bits*/
*c= word R_T1f;       /* r10: fpext*/
*c=                                           /*MISC REGISTERS*/
*c= word R_LR;        /* r11: link register*/
*c= word R_LRf;       /* r11: fpext*/
*c= word R_V1;        /* dp: data page pointer*/
*c= word R_BASE;      /* ir0: byte address base*/
*c= word R_USE;       /* ir1: user stack end pointer*/
*c= word R_V2;        /* bk: temp register*/
*c=                                        /*TEMP BACK-END REGS*/
*c= word R_TMP1;      /* rs: */
*c= word R_TMP2;      /* re: */
*c= word R_TMP3;      /* rc: */
*c= /* Note that iie, iif, die and system stack */
*c= /* pointer (sp) are never saved by SaveCPUState */
*c= }CPURegs
*x SaveCPUState
*k C40
#
*n SaveCPUState\CPU state library function
*P Saves the state of the CPU.
*I <cpustate.h>
*F bool SaveCPUState(SaveState *threadstate);
*A %sthreadstate%s - pointer to %bSaveState%b structure.
*D %bSaveCPUState%b saves the current CPU context into the %bSaveState%b data
   structure passed.  The CPU context can be restored by the %bRestoreCPUState%b
   function.  If %bSaveCPUState%b returns %bTRUE%b, the function is returning
   as a result of a %bRestoreCPUState%b function call.  If %bFALSE%b is returned,
   the function exited as normal after saving the current state of the CPU into
   the %bSaveState%b structure passed to it.
*p The use of the %bSaveCPUState%b and %bRestoreCPUState%b functions requires
   careful coding.  A routine that calls the %bSaveCPUState%b and then
   returns before %bRestoreCPUState%b is called, is likely to cause problems.
   The stack frame that existed when %bSaveCPUState%b was called will no
   longer exist, and so any call to %bRestoreCPUState%b will corrupt the
   execution stack.  The contents of the %bSaveState%b structure may be
   modified before a %bRestoreCPUState%b function is called.  These functions
   can be used for a variety of purposes, for example, creating a coroutine
   library.
*p %bSaveCPUState%b is not available on transputer implementations of Helios.
*x RestoreCPUState
*k C40
#
*n slice\Helios command
*P Time slicing.
*F slice [on off]
*D slice provides the facility to disable and re-enable time slicing
   (scheduling) of threads in the processor.  The command used with no options
   simply displays whether slicing is currently on or off.
*p The options are as follows:
*l %bon%b
*t Reactivates the time slicing of threads in the processor.
*l %boff%b
*t Deactivates the time slicing facility.  This reduces the system overhead
   on the processor and thus speeds up execution of threads.  All Helios
   commands and facilities will continue to function.
*p %bNote:%b if any of your programs use busy waiting (polling), this command
   may cause severe system degradation.  As a rule, Helios programs should
   never poll.  They should either suspend themselves temporarily each time
   around the polling loop or be implemented so that they block until the
   required events takes place.  This can usually be accomplished with
   semaphores.
*x SliceQuantum
*x SliceState
*k C40
#
*n SliceQuantum\Process library function
*P Sets length of timeslice.
*I <process.h>
*F int SliceQuantum(int usecs);
*A %susecs%s - length of timeslice.
*D %bSliceQuantum%b sets the period of time each thread receives to run in a
   timeslice.  Although the argument takes a microsecond value, timeslicing
   is only implemented to a millisecond resolution on Helios-C40. If %busecs%b
   is zero, the timeslice is not set and the current quantum is returned.
*p Default timeslice is 1/10 of a second (100 milliseconds).
*p %bExample:%b
*c= SliceQuantum(OneSec/20);
*p This example gives each thread a timeslice of 1/20 of a second (50
   milliseconds).
*x SliceState
*x slice
*k C40
#
*n SliceState\Process library function
*P Enables, disables or reports the status of timeslicing.
*I <process.h>
*F int SliceState(int state);
*A %sstate%s - state of timeslice.
*D %bSliceState%b enables, disables or reports the status of timeslicing on
   the current processor depending on the value of state, which may be one of
   the following:
*l SLICE_DISABLE
*t enables timeslicing
*l SLICE_ENABLE
*t disables timeslicing
*l SLICE_REPORT
*t returns the latest status
*x SliceQuantum
*x slice
*k C40
#
*n System\Process library function
*P Executes a function without timeslicing.
*I <process.h>
*F word System(WordFnPtr fn, ...);
*A %sfn%s - function to execute.
*D %bSystem%b accepts a function pointer and a list of arguments to pass to
   the function.  It executes the function at the highest physical priority
   level (priority = 0).  The executing function is never timesliced, but the
   thread can be blocked as normal.
*p The %bSystem%b function is used to enter priority zero and it can be used to
   implement critical regions without recourse to semaphores.
*p Use of the %bSystem%b function should be limited as it can block the rest
   of the system completely.
*k C40
#
*n threadps\Helios command
*P The command displays information on each thread.
*F threadps [-lr]
*D %bthreadps%b displays information on all the threads in the system, whether
   they are in a timer or run queue or currently descheduled.  The thread
   task name is displayed together with initial function of the thread and the
   current status of the thread.  If the thread is blocked, the cause of the
   block is given.
*p The options are as follows:
*l %b-l%b
*t Provides more information on each thread such as the program counter and
   the stack pointer
*l %b-r%b
*t Provides thread information continuously.
*p The thread information is displayed in the following groups:
*p * threads on the timer queue
*p * threads on the run queue
*p * all threads in the system
*p Information on each thread in each group is displayed on a single line in
   the following format:
*c= <task-name> : <function-name> : <thread-state>
*p The %b<task-name>%b represents the name of the task.  For each task there
   are at least three threads:
*p * the main function of the task
*p * the signal handler for the task
*p * the procman IOC that the task uses to communicate with the rest of the system.
*p Tasks labelled %bSystem%b are internal.
*p The %b<function-name>%b represents the name of the function that was the
   entry point for the thread, in other words the first function that was
   called in the thread.
*p The contents of %b<thread-state>%b depends on the group of threads.  In the
   timer queue, %b<thread-state>%b displays the time at which the thread will
   be re-scheduled.  In the run queue, %b<thread-state>%b displays whether
   the thread has been rescheduled or whether it is getting its next
   timeslice quantum.  In the %ball threads%b queue,  %b<thread-state>%b
   displays the current state of the thread such as whether it has been
   rescheduled or the reason why it has been blocked, for example waiting on
   a semaphore.
*x ps
*k C40
#
*n TimedWait\Semaphore library function
*P Waits on a semaphore for signal or timeout.
*I <sem.h>
*F bool TimedWait(Semaphore *sem, word timeout);
*A %ssem%s - semaphore to wait on.
*A %stimeout%s - timeout on waiting semaphore.
*D %bTimedWait%b decrements the semaphore counter.  If the result is less
   than zero, it suspends the process until either a %bSignal%b is performed on
   that semaphore or the timeout expires.  If %bTimedWait%b returns %bFALSE%b,
   the wait was aborted because of a timeout rather than a %bSignal%b. This
   function is only implemented on non-transputer implementations of Helios.
*k C40
#
*n WP_BusyWait()\System library function
*P wait on a word addressed counting semaphore (spin lock) in 
d420 2
a421 2
*F word WP_BusyWait(word countaddr);
*A %scountaddr%s - physical word address of semaphore
d424 10
a433 7
   then decrements the semaphore count and returns the new current semaphore 
   count.
*x WP_Readlock
*x WP_ReadFPLock
*x WP_WriteUnlock
*x WP_WriteFPUnlock
*x WP_Signal
d435 2
a436 2
*n WP_GetData\System library function
*P copy data from a physical word address to a byte address
d438 1
a438 1
*F void WP_GetData(char *dstbytepointer, word addr, word wordoffset, word 
d441 2
a442 2
*A %saddr%s - source physical word address
*A %swordoffset%s - added to addr
d444 1
a444 1
*D %bWP_GetWord()%b, %bWP_PutWord()%b, %bWP_GetData()%b and %bWP_PutData()%b 
d447 2
a448 2
*p %bWP_GetData()%b copies numwords words of data from the specified physical 
   word address to the destination byte (local bus) address. Notice that the 
d450 3
a452 3
*x WP_GetWord
*x WP_PutWord
*x WP_PutData
d454 2
a455 2
*n WP_GetWord\System library function
*P get a word of data from a physical word address
d457 5
a461 5
*F word WP_GetWord(word addr, word wordoffset);
*A %saddr%s - physical word address
*A %swordoffset%s - added to addr
*R the value of word at specified word address
*D %bWP_GetWord()%b, %bWP_PutWord()%b, %bWP_GetData()%b and %bWP_PutData()%b 
d464 1
a464 1
*p %bWP_GetWord()%b returns the value of the word at the specified physical word
d466 3
a468 3
*x WP_PutWord
*x WP_GetData
*x WP_PutData
d470 2
a471 2
*n WP_PutData\System library function
*P copy data from a byte address to a word physical address
d473 1
a473 1
*F void WP_PutData(word addr, word wordoffset, char *srcbytepointer, word 
d475 2
a476 2
*A %saddr%s - destination physical word address
*A %swordoffset%s - added to addr
d479 1
a479 1
*D %bWP_GetWord()%b, %bWP_PutWord()%b, %bWP_GetData()%b and %bWP_PutData()%b 
d482 6
a487 6
*p %bWP_PutData()%b copies numwords words of data from the specified byte (local
   bus) address to the destination physical word address. Notice that the byte
   address is assumed to be word aligned.
*x WP_GetWord
*x WP_PutWord
*x WP_GetData
d489 2
a490 2
*n WP_PutWord\System library function
*P write a word of data to a physical word address
d492 3
a494 3
*F void WP_PutWord(word addr, word wordoffset, word data);
*A %saddr%s - physical word address
*A %swordoffset%s - added to addr
d496 1
a496 1
*D %bWP_GetWord()%b, %bWP_PutWord()%b, %bWP_GetData()%b and %bWP_PutData()%b 
d499 5
a503 5
*p %bWP_PutWord()%b writes the value of the data word to the specified 
   physical word address.
*x WP_GetWord
*x WP_GetData
*x WP_PutData
d505 1
a505 1
*n WP_ReadFPLock\System library function
d509 11
a519 11
*F float WP_ReadFPLock(word lockaddr);
*A %slockaddr%s - physical word address
*R the value of floating point number at specified word address
*D %bWP_ReadFPLock()%b locks shared memory and returns the value
   of the single precision floating point number at the specified physical word 
   address.
*x WP_Readlock
*x WP_WriteUnlock
*x WP_WriteFPUnlock
*x WP_Signal
*x WP_BusyWait
d521 1
a521 1
*n WP_ReadLock\System library function
d524 11
a534 10
*F word WP_ReadLock(word lockaddr);
*A %slockaddr%s - physical word address
*R the value of integer at specified word address
*D %bWP_ReadLock()%b locks shared memory and returns the value of
   the word at the specified physical word address.
*x WP_ReadFPLock
*x WP_WriteUnlock
*x WP_WriteFPUnlock
*x WP_Signal
*x WP_BusyWait
d536 2
a537 2
*n WP_Signal()\System library function
*P signal a word addressed counting semaphore (spin lock) in 
d540 2
a541 2
*F word WP_Signal(word countaddr);
*A %scountaddr%s - physical word address of semaphore
d543 8
a550 7
*D %bWP_Signal()%b increments the semaphore count and returns the 
   new current count value
*x WP_Readlock
*x WP_ReadFPLock
*x WP_WriteUnlock
*x WP_WriteFPUnlock,
*x WP_BusyWait
d552 1
a552 1
*n WP_WriteFPUnlock()\System library function
d556 2
a557 2
*F void WP_WriteFPUnlock(word lockaddr, float data);
*A %slockaddr%s - physical word address
d559 7
a565 8
*D %bWP_WriteFPUnlock()%b writes the value of the single precision
   floating point argument to the specified physical word address and unlocks 
   shared memory.
*x WP_Readlock
*x WP_ReadFPLock
*x WP_WriteUnlock
*x WP_Signal
*x WP_BusyWait
d567 1
a567 1
*n WP_WriteUnlock()\System library function
d570 2
a571 2
*F void WP_WriteUnlock(word lockaddr, word data);
*A %slockaddr%s - physical word address
d573 8
a580 7
*D %sWP_WriteUnlock()%s writes the value of the data word to the 
   specified physical word address and unlocks shared memory.
*x WP_Readlock 
*x WP_ReadFPLock
*x WP_WriteFPUnlock
*x WP_Signal
*x WP_BusyWait
d582 53
a634 1

@


1.5
log
@oops, forgot to remove (+)s from as options
@
text
@d2 48
@


1.4
log
@Added new as options
@
text
@d16 1
a16 1
*t Supply module name, rather than use objectfile name (+).
d18 1
a18 1
*t Set version number other than 1 (+).
d20 1
a20 1
*t Fix module table slot number (+).
@


1.3
log
@Additional material (WP_stuff)
@
text
@d4 1
a4 1
*F as [-h] [-o object file] [source file]
d13 8
@


1.2
log
@Judith/Ian's latest changes
@
text
@d37 186
d620 31
d671 12
a682 12
*c=typedef struct SaveState {
*c=struct SaveState *next;        /*for queuing on run q's       */
*c=                               /*next must be first elem't    */
*c=struct SaveState *nextknown    /*for exec housekeeping        */
*c=struct SaveState *stdsavearea  /*permanent save area          */
*c=word priority;                 /*thread priority              */
*c=uword endtime;                 /*wakeup time if Sleep()ing    */
*c=word status;                   /*thread status                */
*c=word CPUtime;                  /*milliseconds of CPU time used*/
*c=VoidFnPtr InitialFn;           /*root fn of thread            */
*c=struct CPURegs CPUcontext;     /*CPU state of this thread     */
*c=} SaveState;
d684 6
a689 6
*c=typedef struct CPURegs {
*c=/*C PCS BINDING NAME*/
*c=                  /*C40 REGISTER NAME*/
*c=                                       /*FUNCTION          */
*c=word PC;          /* PC of sliced thread*/
*c=word R_ST;        /* st:status reg*/
d691 34
a724 34
*c=word R_ADDR1;     /* ar0:*/
*c=word R_ADDR2;     /* ar1:*/
*c=word R_ADDR3;     /* ar2:*/
*c=word R_ADDR4;     /* ar3: */
*c=                                       /*MISC ADDRESS REGS */
*c=word R_MT;        /* ar4: module table pointer*/
*c=word R_ATMP;      /* ar5: temp address reg*/
*c=word R_USP;       /* ar6: user stack pointer*/
*c=word R_FP;        /* ar7: frame pointer*/
*c=                                       /*REGISTER ARGUMENTS*/
*c=word R_A1;        /* r0: first arg and result reg*/
*c=word R_A1f        /* r0: fp extension to 32bit reg*/
*c=word R_A2;        /* r1: 32bits*/
*c=word R_A2f;       /* r1: fpext*/
*c=word R_A3;        /* r2: 32bits*/
*c=word R_A3f;       /* r2: fpext*/
*c=word R_A4;        /* r3: 32bits*/
*c=word R_A4f;       /* r3: fpext*/
*c=                                       /*REGISTER VARIABLES*/
*c=word R_FV1;       /* r4: 32bits*/
*c=word R_FV1f;      /* r4: fpext*/
*c=word R_FV2;       /* r5: 32bits*/
*c=word R_FV2f;      /* r5: fpext*/
*c=word R_FT1;       /* r6: 32bits*/
*c=word R_FT1f;      /* r6: fpext*/
*c=word R_FT2;       /* r7: 32bits*/
*c=word R_FT2f;      /* r7: fpext*/
*c=                                           /*TEMP REGISTERS*/
*c=word R_V3;        /* r8: 32bits*/
*c=word R_V3f;       /* r8: fpext*/
*c=word R_V4;        /* r9: 32bits*/
*c=word R_V4f;       /* r9: fpext*/
*c=word R_T1;        /* r10: 32bits*/
*c=word R_T1f;       /* r10: fpext*/
d726 13
a738 13
*c=word R_LR;        /* r11: link register*/
*c=word R_LRf;       /* r11: fpext*/
*c=word R_V1;        /* dp: data page pointer*/
*c=word R_BASE;      /* ir0: byte address base*/
*c=word R_USE;       /* ir1: user stack end pointer*/
*c=word R_V2;        /* bk: temp register*/
*c=                                       /*TEMP BACK-END REGS*/
*c=word R_TMP1;      /* rs: */
*c=word R_TMP2;      /* re: */
*c=word R_TMP3;      /* rc: */
*c=/* Note that iie, iif, die and system stack */
*c=/* pointer (sp) are never saved by SaveCPUState */
*c=}CPURegs
d888 4
a891 4
than zero, it suspends the process until either a %bSignal%b is performed on
that semaphore or the timeout expires.  If %bTimedWait%b returns %bFALSE%b,
the wait was aborted because of a timeout rather than a %bSignal%b. This
function is only implemented on non-transputer implementations of Helios.
d894 15
a908 185
*n c\Helios command
*P Runs the Helios compiler driver for the C40
*F c [opts] <filename> [<filename> ...]
*D The %bc%b command is used to compile and link a program. It
takes a list of files and decides what to do with them according to their
suffix. The file names supported are as follows:
*l Suffix
*t Meaning
*l %b.a%b
*t Macro assembly language (AMPP) source file
*l %b.c%b
*t C language source file
*l %b.i%b
*t C language source file (pre-processed version)
*l %b.f%b
*t FORTRAN language source file
*l %b.o%b
*t Assembled file, ready for linking
*l %b.p%b
*t Assembled file, ready for linking
*l %b.s%b
*t Assembly language source file
*l %b.def%b
*t Modula-2 definition source file
*l %b.mod%b
*t Modula-2 program source file
*l %b.mod%b
*t Modula-2 program source file
*l %b.lib%b
*t Scanned library
*p If no other arguments are given, the program compiles the programs for
the languages specified as .c or .f, assembles any .s files and then links
all the resulting binaries along with any supplied .o files into an
executable program called a.out, removing the intermediary -s files.
*p The following options can be used to alter the behaviour of the program:
*l Option
*t Action
*l %b-a%b %s<text>%s
*t Pass %s<text>%s as an option to assembler.
*l %b-b%b
*t Don't link with standard maths libraries (fplib and fpclib).
*l %b-c%b
*t Compile/Assemble only, don't link.
*l %b-d%b%s<name>%s
*t Specify output file name for library .def compilations.
*l %b-e[6|7]%b
*t Enforce Fortran standard.
*l %b-f%b %s<name>%s
*t Specify filename for assembler's virtual memory system.
*l %b-g%b
*t Compiler for debugging.
*l %b-h%b%s<val> %s
*t Specify heap size of program.
*l %b-j%b
*t Create scanned library
*l %b-l%b%s<name>%s
*t Link with library <name>
*l %b-m%b
*t Compile code for libraries.
*l %b-n%b
*t Don't actually execute commands (implies -v).
*l %b-n%b%s<string>%s
*t Specify object name of program.
*l %b-o%b%s<name>%s
*t Specify output name (default *.o or "a.out") ("-" is stdout)
*l %b-p%b
*t Compile code for profiling.
*l %b-q%b%s<opt>%s
*t Enable compiler debugging features (where the %sopt%ss are
abdfghimopqrstuwxyz).
*l %b-r%b
*t Compile code for device drivers.
*l %b-s%b%s<val>%s
*t Specify stack size of program.
*l %b-t%b
*t Compile code for tracing.
*l %b-u%b
*t Prevent removal of intermediary files.
*l %b-v%b
*t Verify command being executed.
*l %b-w[Aacdfpsvz]%b
*t Suppress warnings.
*l %b-y%b%s<text>%s
*t Pass <text> as an option to the macro pre-processor
*l %b-z%b %s<text>%s
*t Pass %stext%s as an option to C compiler.
*l %b-A%b%s<text>%s
*t Pass <text> as an option to linker.
*l %b-B%b
*t Do not link with any libraries. Do not perform objed.
*l %b-C%b
*t Perform memory checking
*l %b-C40%b
*t Compile code for the C40 if cross-compiling.
*l %b-D%b%s<name>%s
*t #define <name>
*l %b-D%b%s<name>=<val>%s
*t #define <name> to be <val> (default <val> is 1).
*l %b-E%b
*t Pre-process only. Do not compile.
*l %b-F[Afghmsv]%b
*t Enable compiler features (`s' turns off stack checking and `g' removes
procedure names; `A' switches on `s' and `g').
*l %b-I%b%s<dir>%s
*t Specify a directory to be searched for #include or M2 symbol files.
*l %b-J%b
*t Append to a scanned library.
*l %b-L%b%s<name>%s
*t Link with library <name>
*l %b-M%b%s<name>%s
*t Produce map file <name> (F77).
*l %b-O%b
*t Optimise code, perform full link.
*l %b-P%b%s<text>%s
*t Pass <text> as an option to the pre-processor
*l %b-R%b
*t Force use of RAM disc for temporary FORTRAN and Modula-2 files, even if
RAM disc is not loaded.
*l %b-S%b
*t Produce textual assembler output from *.c in *.s, don't link.
*l %b-T[4|8]%b
*t Specify Transputer type.
*l %b-V%b
*t Pass on verbose flag to executed commands.
*l %b-W%b%s<val>%s
*t Specify warning level (F77).
*l %b-X%b%s<val>%s
*t Specify cross reference width (F77).
*l %b-Z%b%s<text>%s
*t Pass %s<text>%s as an option to FORTRAN compiler.
*l %b-help%b
*t Display list of options supported by c.
*p For example, suppose you have a program called %stest%s, you might type:
*c=c -o test test.c
*p and using c for debugging, you might type:
*c=c -g -ld -o test test.c
*p %bc%b uses the following environment variables, if present:
*l C_COMPILER
*t Pathname of the C compiler
*l PRE_PROCESSOR
*t Pathname of the pre-processor
*l ASSEMBLER
*t Pathname of the assembler
*l LINKER
*t Pathname of the linker
*l REMOVER
*t Pathname of the file removal program
*l MACDIR
*t Pathname of the standard AMPP macro directory
*l MACRO
*t Pathname of the AMPP
*l C_LIBDIR
*t Pathname of the library directory
*l C_INCDIR
*t Pathname of the standard C header directory
*l LINK_HELIOS
*t Name of the standard Helios link library
*l LINK_CSTART
*t Name of the C startup file
*l LINK_CLIB
*t Name of the standard C link library
*l NEW_NCC
*t If set, this informs %bc%b which version of the C compiler is being used.
*l OBJNAME
*t Default name of output file
*l MACHINENAME
*t Name of the destination hardware, passed on by %b-D%b.
*p The following constants are also defined by %bc%b when compiling C code:
*l helios
*l __HELIOS
*l __C40
*l __HELIOSC40
*l %s<MACHINENAME>%s
*p Further details can be found in the latest edition of the %sHelios C Manual%s.
*q helios
*q __HELIOS
*q C40
*q __C40
*q __HELIOSC40
*q <MACHINENAME>
*q c
*q Compiler driver
*q AMPP
*x ncc
*k C40
d910 146
a1055 30
*n rboot\Helios command
*q rboot, network command
*P Boots a processor by hand
*F rboot [-l<link>] <link> <myname> <childname> [<link modes> <memory limit>]
*D The %brboot%b command is used to boot up processors by
hand, usually when the network is too small to warrant running all of the
networking software. The command must be executed on an active processor
adjacent to the one being booted. The first argument specifies the link
used for the bootstrap, an integer between 0 and 5 in the case of C40s.
The second argument is
the name of the processor doing the booting. The third argument is the
name of the processor being booted. Then there are two optional arguments:
link modes and memory limit. The link modes argument specifies the modes
of the four links of the newly booted processor: 0 means not connected; 1
means dumb; 2 means intelligent and active; 3 means intelligent but
pending. The final argument is rarely required: it specifies the amount of
memory to be used on the newly booted processor. This option is necessary
if the target processor has some memory mapped hardware such as video
memory adjacent to normal memory, which could cause the kernel to use that
video memory for memory allocation. For example, if the processor has one
megabyte of normal memory immediately followed by one megabyte of video
memory, a size of 0x1000000 could be used.
*p If the target processor is being booted via any link other than its
link 0 then it is necessary to specify the target link. For example,
if processor 00 link 2 goes to processor 01 link 1 then the command
to boot processor 01 is:
*c=rboot -l1 2 /00 /01
*p Note that the C40 must have an ID ROM in order for this command to work.
*x clink
*k C40
@


1.1
log
@Initial revision
@
text
@d53 1
a53 1
*F disas [- bBtThH][help][?][-][--] [<file>...]
d64 2
d403 1
a403 1
*F objdump [-dhiln][+<n>][<file>...]
d415 2
d645 2
a646 2
   are three entries:
*p * the entry point of the task
d651 2
a652 2
   entry point for the task, in other words the first function that was
   called in the task.
@
