head	1.18;
access;
symbols
	Jamie_17_Aug:1.15;
locks; strict;
comment	@ * @;


1.18
date	94.01.11.11.31.26;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	93.09.13.13.42.20;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	93.08.27.12.03.37;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	93.08.16.13.46.26;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	93.08.06.14.55.01;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	93.08.05.08.31.06;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	93.08.04.10.31.08;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	93.08.03.15.24.25;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	93.07.27.14.10.43;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	93.07.27.10.14.50;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	93.07.27.09.20.49;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	93.07.26.11.44.42;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	93.07.22.08.19.34;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	93.07.20.15.01.44;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	93.07.15.16.47.13;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	93.07.15.13.35.36;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	93.07.15.09.52.52;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	93.07.14.14.41.44;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.18
log
@propogated fix from cc350 world
@
text
@/*{{{  Comments  */

/*
 * C compiler file heliobj.c
 * Copyright (C) Perihelion Software Ltd, 1988 - 1994
 * Adapted by Codemist Ltd, 1989
 * Tidied up by NC 1991-1993
 * 68K and ARM code reiniserted by NC 1993
 */

/* #define STIK_NOW_WORKS_ON_HARDWARE 1 */

/* AM Apr 89: change 'stublist' so that items are merely marked deleted */
/* (by having xr_defloc/xr_defext) instead of physical removeal.        */
/*
 * This was once called heliosobj.c, but to keep file component makes
 * short (e.g. for when we want to host on an MSDOS machine, yuk) it has
 * been contracted to heliobj.c
 */

/*}}}*/
/*{{{  Headers   */

# ifdef __STDC__
# include <string.h>
# else
# include <strings.h>
# endif

#include <stddef.h>
#include <errno.h>

#ifndef SEEK_SET
#define SEEK_SET  0
#endif

#include </hsrc/include/helios.h>
#include </hsrc/include/module.h>

#include "host.h"
#include "globals.h"
#include "mcdep.h"
#include "mcdpriv.h"
#include "xrefs.h"
#include "store.h"
#include "codebuf.h"
#include "mipvsn.h"
#include "jopcode.h"
#include "ops.h"            /* For R_ADDR1 etc */
#include "regalloc.h"       /* for regmask */
#include "cg.h"             /* for procflags */
#include "errors.h"

#ifdef TARGET_IS_C40
#include "peep.h"
#endif

/*}}}*/
/*{{{  Macros    */

#define xr_definition			(xr_defloc | xr_defext)
#define xr_external_code		(xr_code   | xr_defext)

#define extflags_( x )			((x)->extflags)
#define extsym_( x )			((x)->extsym)
#define extcdr_( x )			((x)->extcdr)
#define extoffset_( x )			((x)->extoffset)

#define is_defined( x )			 (extflags_(x) & xr_definition)
#define is_defined_( flags )		 ((flags)      & xr_definition)
#define is_code( x )			 (extflags_(x) & xr_code)
#define is_code_( flags )		 ((flags)      & xr_code)
#define is_data( x )			 (extflags_(x) & xr_data)
#define is_external_code( x )		((extflags_(x) & xr_external_code) == xr_external_code)
#define is_local( x )			 (extflags_(x) & xr_defloc)
#define is_global( x )			 (extflags_(x) & xr_defext)
#define is_bss( x )			 (extflags_(x) & xr_bss)

#ifndef offsetof
#define offsetof( type, member ) ((char *)&(((type *)0)->member) - (char *)0)
#endif

#ifndef TARGET_IS_C40
#define asmf( str ) 	if (asmstream) fprintf( asmstream, str )
#endif

/*}}}*/
/*{{{  Constants */

#define OBJCODE      	0x01
#define OBJBSS        	0x02
#define OBJINIT       	0x03

#define OBJBYTE       	0x09	   	/* ls 3 bits = size      */
#define OBJSHORT      	0x0a
#define OBJWORD       	0x0c

#define OBJCODESYMB   	0x0d		/* was funcref   */
#define OBJMODSIZE  	0x0e		/* was imagesize */
#define OBJLABELREF   	0x0f		/* was labeloff  */
#define OBJDATASYMB   	0x10		/* was dataref   */
#define OBJDATAMODULE 	0x11
#define OBJMODNUM     	0x12

#define OBJPATCH      	0x13   		/* PATCHES are 0x13 - 0x1f */
#define OBJPATCHMAX   	0x1f

#define OBJMODULE     	0x20
#define OBJBYTESEX	0x21

#define OBJGLOBAL     	0x22
#define OBJLABEL      	0x23
#define OBJDATA       	0x24
#define OBJCOMMON     	0x25
#define OBJCODETABLE  	0x26
#define OBJREF        	0x27		/* force reference to another library */
#define OBJCODESTUB	0x28		/* address of fn or stub */
#define OBJADDRSTUB	0x29		/* stub returning address of fn */

#define OBJNEWSEG	0x30
#define OBJEND		0x31
#define OBJLITERAL	0x32	   	/* OBJCODE of <= 4 bytes */

#define PATCHADD  	0x13 		/* patch = val1 +  val2 */
#define PATCHSHIFT	0x14 		/* patch = val2 << val1 */ /* right shift for -ve val1 */
#define PATCHSWAP	0x1E		/* patch = byte_swap( val1 ) */
#define PATCHOR		0x1f		/* patch = val1 | val2 */

#ifdef TARGET_IS_ARM
#define PATCHARMLDR    0x15		/* aka armdt		*/
#define PATCHARMADD    0x16		/* aka armdp 		*/
#define PATCHARMBL     0x17		/* aka armjp 		*/
#define PATCHARMADDLO  0x18		/* aka armdplsb 	*/
#define PATCHARMADDHI  0x19		/* aka armdprest 	*/
#define PATCHARMADDMID 0x1a		/* aka armdpmid 	*/
#endif

#ifdef TARGET_IS_C40
#define PATCHC40DATAMODULE1	0x15
#define PATCHC40DATAMODULE2	0x16
#define PATCHC40DATAMODULE3	0x17
#define PATCHC40DATAMODULE4	0x18
#define PATCHC40DATAMODULE5	0x19
#define PATCHC40MASK24ADD	0x1a
#define PATCHC40MASK16ADD	0x1b
#define PATCHC40MASK8ADD	0x1c
#endif

#ifndef NUM_BITS_PER_BYTE
#define NUM_BITS_PER_BYTE 8
#endif

#ifndef R_ATMP
#ifdef TARGET_IS_ARM
#define R_ATMP R_AS
#else
#define R_ATMP R_AS2
#endif
#endif

/*}}}*/
/*{{{  Types     */

typedef struct GSymlist
  {
    struct GSymlist *	cdr;
    Symstr *		sym;
  }
GSymlist;

typedef struct Stub
  {
    struct Stub *	stubcdr;
    Symstr *		stubsym;
  }
Stub;

/*}}}*/
/*{{{  Variables */

ExtRef *		obj_symlist;
CodeXref *		codexrefs;
ExtRef *		datasymbols;
int	      		suppress_module;
FILE *		   	objstream;
LabelNumber *		exporting_routines = NULL;

static Stub *		stublist;
static GSymlist *	global_symbols;
#ifdef TARGET_USES_NEW_STUBS
static GSymlist *	stub_symbols;
static GSymlist *	addr_stub_symbols;
#endif
static int32 		obj_symcount;
static ExtRef **	obj_symlistend;
static int32     	codesize;
static int32     	codesizepos;
static int32     	datasize;              /* only for obj file use */
static int32     	datasizepos;
static int32     	maxcodep;
static int32     	maxcodeppos;
static LabelNumber *	datainitlab;

/*}}}*/
/*{{{  Functions */

/*{{{  mask_and_sign_extend_word */

#if defined TARGET_IS_68000 || defined TARGET_IS_68020
/*
 * extracts the bits specified by 'mask' from the word 'value'
 * if necessary the resulting word is sign extended.
 * 'mask' must be a contigous set of bits starting from
 * the least significant bit
 */

static signed long
mask_and_sign_extend_word(
			  unsigned long	value,
			  unsigned long	mask )
{
  value &= mask;

  if (value & ((mask + 1) >> 1))
    {
      value |= ~mask;
    }

  return (signed long)value;
  
} /* mask_and_sign_extend_word */

#endif /* TARGET_IS_ 68000 or 68020 */

/*}}}*/
/*{{{  objbyte */

static void
objbyte( int32 b )
{
  if (objstream == NULL)
    {
      fprintf( stderr, "WARNING: objbyte has no output stream, wanted to write byte %ld\n", b );
      
      return;
    }

  putc( (char)b, objstream );
    
  return;
  
} /* objbyte */

/*}}}*/
/*{{{  objword */

static void
objword( int32 x )
{
  unsigned char	val;
  
#ifdef TARGET_IS_LITTLE_ENDIAN
  val = (unsigned char)(x & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char)((x >> 8) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char)((x >> 16) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char)((x >> 24) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
#else /* ! TARGET_IS_LITTLE_ENDIAN */
  
  val = (unsigned char) ((x >> 24) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char) ((x >> 16) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char) ((x >> 8) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char) (x & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
#endif /* TARGET_IS_LITTLE_ENDIAN */
  
  return;
  
} /* objword */

/*}}}*/
/*{{{  objnum */

#define bitmask( n ) ((1 << (n)) - 1)

static void
objnum( int32 n )
{
  int32 	i;
  int32 	nflag = (n < 0)? n = -n, 1 : 0;
  int32 	mask7 = bitmask( 7 );
  
#define NFLAG 0x40
#define MORE  0x80
  
  /* The prefix notation expressed in this function is described */
  /* in Nick Garnett's description of the Helios Link Format for */
  /* Non-Transputer Processors                                   */
  
  for (i = 28; i != 0; i -= 7)
    if ((n & (mask7 << i)) != 0)
      break;
  
  if ((n >> i) & NFLAG)
    i += 7;
  
  objbyte( (n >> i) | (nflag ? NFLAG : 0) | (i > 0 ? MORE : 0) );
  
  for (i -= 7; i >= 0; i -= 7)
    objbyte( ((n >> i) & mask7) | (i > 0 ? MORE : 0) );
  
  return;
  
} /* objnum */

/*}}}*/
/*{{{  objsymbol */

static void
objsymbol(
	  char		prefix,
	  char *	s )
{
  objbyte( prefix );
    
  fputs( s, objstream );
  
  objbyte( '\0' );
  
  return;
  
} /* objsymbol */

/*}}}*/
/*{{{  globalise */

static void
globalise( Symstr * s )
{
  GSymlist *	g;

  
  for (g = global_symbols; g != NULL; g = g->cdr)
    if (g->sym == s)
      return;
    
  global_symbols = (GSymlist *)global_cons2( SU_Other, global_symbols, s );
    
  return;
  
} /* globalise */

/*}}}*/
/*{{{  dumpglobals */

static void
dumpglobals( void )
{
  GSymlist *	g;
  

  for (g = global_symbols; g != NULL; g = g->cdr)
    {
      objbyte( OBJGLOBAL );

#ifdef TARGET_USES_NEW_STUBS
      if (new_stubs && is_code( symext_( g->sym )))
	objsymbol( '.', symname_( g->sym ) );
      else
#endif
	objsymbol( '_', symname_( g->sym ) );
    }
  
  return;
  
} /* dumpglobals */

/*}}}*/
/*{{{  request_addr_stub */

#ifdef TARGET_USES_NEW_STUBS

void
request_addr_stub( Symstr * s )
{
  GSymlist *	a;
  
  
  for (a = addr_stub_symbols; a != NULL; a = a->cdr)
    if (a->sym == s)
      return;
  
  addr_stub_symbols = (GSymlist *)global_cons2( SU_Other, addr_stub_symbols, s );
  
  return;
  
} /* request_addr_stub */

#endif /*TARGET_USES_NEW_STUBS */

/*}}}*/
/*{{{  request_new_stub  */
#ifdef TARGET_USES_NEW_STUBS
void
request_new_stub( Symstr * s )
{
  GSymlist *	g;
    
  
  for (g = stub_symbols; g != NULL; g = g->cdr)
    if (g->sym == s)
      return;
  
  stub_symbols = (GSymlist *)global_cons2( SU_Other, stub_symbols, s );
  
  return;
  
} /* request_new_stub */
#endif /* TARGET_USES_NEW_STUBS */
/*}}}*/
/*{{{  dump_new_stubs */
#ifdef TARGET_USES_NEW_STUBS
static void
dump_new_stubs( void )
{
  GSymlist *	g;
  
  
  for (g = stub_symbols; g != NULL; g = g->cdr)
    {
      objbyte( OBJGLOBAL );
      
      objsymbol( '.', symname_( g->sym ) );
      
      objbyte( OBJREF );
      
      objsymbol( '_', symname_( g->sym ) );
    }
  
  for (g = addr_stub_symbols; g != NULL; g = g->cdr)
    {
      objbyte( OBJGLOBAL );
      
      fputs( ".addr", objstream );
      
      objsymbol( '.', symname_( g->sym ) );
      
      /*
       * We must generate a REF to the original function name
       * in order to ensure that the module containing the function
       * is linked, even if the function itself is never called.
       */
      
      objbyte( OBJREF );
      
      objsymbol( '.', symname_( g->sym ) );
    }
  
  return;
  
} /* dump_new_stubs */
#endif /* TARGET_USES_NEW_STUBS */
/*}}}*/
/*{{{  objdirective */

/*
 * This functions handles the cross reference directive 'xrtype'
 * and issues suitable linker instructions to ensure the correct
 * patching is performed.  The symbol 'sym' (if needed) is the
 * symbol refered to by the cross reference.  The word 'code'
 * is the instruction that is being patched.
 *
 * The function returns the number of bytes that have been altered
 * in the output file
 */

#if defined TARGET_IS_C40

/*{{{  C40 */

static int32
objdirective(
	     int32	xrtype,
	     Symstr *	sym,
	     int32	code )
{
  switch (xrtype)
    {
    case X_Modnum:				/* see load_static_data_ptr() in c40/gen.c */
      /*
       * take code word and add in module number,
       * shifted up to be a word offset.  (If we
       * are using split modules then there is a
       * two word structure for each module table
       * entry so we make module number be a two
       * word offset).  Note that for the 'C40
       * we are loading a WORD offset, not a BYTE
       * offset, so we may not need to shift at all
       */
      
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( few_modules ? PATCHC40MASK8ADD :
	      PATCHC40MASK16ADD );		/* ... adding into the bottom 8 or 16 bits of ... */
      objnum( code );				/* ... the current word op code ... */
      if (split_module_table)
	{
	  objbyte( PATCHSHIFT );		/* ... the result of shifting ... */
	  objnum( 1 );				/* ... up by 1 bit ... */
	}
      objbyte( OBJMODNUM );			/* ... the current module number */
      break;
      
    case X_DataAddr:				/* see load_address_constant in c40/gen.c */
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -16 );				/* ... right by 16 bits ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( 14 );				/* ... left by 14 bits ... */
      if (is_function( sym ))
	{
	  objbyte(
#ifdef TARGET_USES_NEW_STUBS
		  new_stubs ? OBJCODESTUB :
		  OBJLABELREF );		/* ... the offset of ... */
	  objsymbol( new_stubs ? '.' : '#'
		    , symname_( sym ) );	/* ... the symbol */
#else
	  objbyte( OBJLABELREF );		/* ... the offset of ... */
	  objsymbol( '.', symname_( sym ) );	/* ... the symbol */
#endif
	}
      else
	{
	  objbyte( OBJLABELREF );
	  objsymbol( '_', symname_( sym ) );
	}
      break;
      
    case X_DataAddr1:				/* high part of previous patch, see c40/gen.c */
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -18 );				/* ... right by 18 bits ... */
      objbyte( PATCHADD );			/* ... the result of adding ... */
      objnum( -3 * sizeof_int );		/* ... -3 * sizeof_int to ... */
      if (is_function( sym ))
	{
	  objbyte(
#ifdef TARGET_USES_NEW_STUBS
		  new_stubs ? OBJCODESTUB :
		  OBJLABELREF );		/* ... the offset of ... */
	  objsymbol( new_stubs ? '.' : '#',
		    symname_( sym ) );	/* ... the symbol */
#else
	  objbyte( OBJLABELREF );		/* ... the offset of ... */
	  objsymbol( '.', symname_( sym ) );	/* ... the symbol */
#endif
	}	  
      else
	{
	  objbyte( OBJLABELREF );
	  objsymbol( '_', symname_( sym ) );
	}	  
      break;
      
    case X_FuncAddr:				/* see load_address_constant in c40/gen.c */
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40MASK24ADD );		/* ... adding into the bottom 24 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting right ... */
      objnum( -2 );				/* ... by two bits ... */
      objbyte( OBJADDRSTUB );			/* ... the offset of ... */
      fputs( ".addr", objstream );		/* ... the address obtaining function for ... */
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_PCreloc:				/* see call() in c40/gen.c */
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40MASK24ADD );		/* ... adding into the bottom 24 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... right by two bits ... */
      objbyte(
#ifdef TARGET_USES_NEW_STUBS
	      new_stubs ? OBJCODESTUB :
	      OBJLABELREF );			/* ... the offset of ... */
      objsymbol( new_stubs ? '.' : '#',
		symname_( sym ) );		/* ... the symbol */
#else
      objbyte( OBJLABELREF );			/* ... the offset of ... */
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
#endif
      break;
      
    case X_PCreloc2:				/* see routine_entry() in c40/gen.c */
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... right by two bits ... */
      objbyte(
#ifdef TARGET_USES_NEW_STUBS
	      new_stubs ? OBJCODESTUB :
	      OBJLABELREF );			/* ... the offset of ... */
      objsymbol( new_stubs ? '.' : '#',
		symname_( sym ) );		/* ... the symbol */
#else
      objbyte( OBJLABELREF );			/* ... the offset of ... */
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
#endif
      break;
      
    case X_DataModule:				/* see load_address_constant in c40/gen.c */
      
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( few_modules ? PATCHC40MASK8ADD :
	      PATCHC40MASK16ADD );	      	/* ... adding into the bottom 8 or 16 bits of... */	
      objnum( code );				/* ... the current word op code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... down by two bits ... */
      objbyte( OBJDATAMODULE );			/* ... the module number of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataModule1:
      
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40DATAMODULE1 );		/* ... applying 'C40 specific patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... down by two bits ... */
      objbyte( OBJDATAMODULE );			/* ... the module number of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the specified symbol */
      break;
      
    case X_DataModule2:
      objbyte( OBJWORD );			/* patch the folllowing word by ... */
      objbyte( PATCHC40DATAMODULE2 );		/* ... applying 'C40 specific patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      if (is_function( sym ))
	{
	  objbyte( PATCHSHIFT );		/* ... the result of shifting ... */
	  objnum( -2 );				/* ... down by 2 bits ... */
	}
      objbyte( split_module_table ?
	      OBJCODESYMB : OBJDATASYMB );	/* ... the offset into the module of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataModule3:
      
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40DATAMODULE3 );		/* ... applying 'C40 specific patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      objbyte( OBJMODNUM );			/* ... another dummy value */
      break;
      
    case X_DataModule4:
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40DATAMODULE4 );		/* ... applying a 'C40 specific patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      objbyte( OBJMODNUM );			/* ... another dummy value */            
      break;
      
    case X_DataModule5:
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40DATAMODULE5 );		/* ... applying a 'C40 specific patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      objbyte( OBJMODNUM );			/* ... another dummy value */
      break;
      
    case X_DataSymbHi:
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
      objnum( code );				/* ... the current word op code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      if (split_module_table && is_function( sym ))
	{
	  objnum( -18 );			/* ... down by 18 bits ... */
	  objbyte( OBJCODESYMB );		/* ... the offset into the codetable of ... */
	}
      else					/* ... or ... */
	{	  
	  objnum( -16 );			/* ... down by 16 bits ... */
	  objbyte( OBJDATASYMB );		/* ... the offset into the data area of ... */
	}
      objsymbol( '_', symname_( sym ) );	/* ... the specified symbol */
      break;
      
    case X_DataSymbLo:
      
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of... */
      objnum( code );				/* ... the current word op code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -16 );				/* ... down by 16 bits ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      if (split_module_table && is_function( sym ))
	{
	  objnum( 14 );				/* ... up by 14 bits ... */
	  objbyte( OBJCODESYMB );		/* ... the offset into the codetable of ... */
	}
      else					/* ... or ... */
	{	  
	  objnum( 16 );				/* ... up by 16 bits ... */
	  objbyte( OBJDATASYMB );		/* ... the offset into the data area of ... */
	}
      objsymbol( '_', symname_( sym ) );	/* ... the specified symbol */
      break;
      
    case X_DataSymb:				/* see load_address_constant in c40/gen.c */
      
      objbyte( OBJWORD );			/* patch the following word by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of... */
      objnum( code );				/* ... the current word op code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... down by 2 bits ... */
      if (split_module_table)
	{
	  objbyte( OBJCODESYMB );		/* ... the offset into the code table of ... */
	}
      else					/* ... or ... */
	{	  
	  objbyte( OBJDATASYMB );		/* ... the offset into the data area of ... */
	}
      objsymbol( '_', symname_( sym ) );	/* ... the specified symbol */
      break;
      
#ifdef TARGET_HAS_DEBUGGER
    case X_Debug_Modnum:
      objbyte( OBJWORD );			/* patch the following word by inserting ... */
      objbyte( OBJMODNUM );			/* ... the current module number */
      break;
      
    case X_Debug_Offset:
      objbyte( OBJWORD );			/* patch the following word by inserting ... */
      objbyte( split_module_table ?
	      OBJCODESYMB : OBJDATASYMB );	/* ... the offset in the module table of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the function specified by symbol */
      break;
      
    case X_Debug_Ref:
      objbyte( OBJWORD );			/* patch the following word by inserting ... */
      objbyte( OBJLABELREF );			/* ... the offset of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the specified symbol */
      break;
      
#endif /* TARGET_HAS_DEBUGGER */
      
    case X_Init:
      objbyte( OBJINIT );
      break;
      
    default:
      syserr( syserr_heliobj_bad_xref, sym, (long)xrtype );
      
    case X_absreloc:
      return 0;
    }
  
  return 4;
  
} /* objdirective */

/*}}}*/

#elif defined TARGET_IS_68000 || defined TARGET_IS_68020

/*{{{  68K */

static int32
objdirective(
	     int32	xrtype,
	     Symstr *	sym,
	     int32	code )
{
  /*
   * obj_outcode reads in 4 bytes for the code field,
   * but we actually only use the bottom 2 bytes.  The
   * top two bytes are bogus, (and could be anything),
   * so mask them out here
   */
  
  code = mask_and_sign_extend_word( code, 0x0000FFFF );
  
  switch (xrtype)
    {
    case X_Modnum:
      objbyte( OBJSHORT );			/* patch by ... */
      if (code != 0)
	{
	  objbyte( PATCHADD );			/* ... adding in to ... */
	  objnum( code );			/* ... the current op code ... */
	}
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( split_module_table ? 3 : 2 );	/* ... up by 2 or 3 bits ... */
      objbyte( OBJMODNUM );			/* ... the current module number */
      break;
      
    case X_PCreloc:
      objbyte( OBJSHORT );			/* patch by ... */
      if (code != 0)
	{
	  objbyte( PATCHADD );			/* ... adding into ... */
	  objnum( code );			/* ... the current op code ... */
	}
      objbyte( OBJLABELREF );			/* ... the offset of ... */
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataModule:
      
      objbyte( OBJSHORT );			/* patch by ... */
      if (code != 0)
	{
	  objbyte( PATCHADD );			/* ... adding into ... */
	  objnum( code );			/* ... the current op code ... */
	}
      objbyte( OBJDATAMODULE );			/* ... the module number of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataSymb:
      
      objbyte( OBJSHORT );			/* patch by ... */
      if (code != 0)
	{
	  objbyte( PATCHADD );			/* ... adding into ... */
	  objnum( code );			/* ... the current op code ... */
	}
      objbyte( OBJDATASYMB );			/* ... the offset of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_Init:
      objbyte( OBJINIT );
      
      return 4;
      
    default:
      syserr( syserr_heliobj_bad_xref, sym, (long)xrtype );
      
      return 0;
    }
  
  return 2;
  
} /* objdirective */

/*}}}*/

#elif defined TARGET_IS_ARM

/*{{{  ARM */

static int32
objdirective(
	     int32	xrtype,
	     Symstr *	sym,
	     int32	code )
{
  switch (xrtype)
    {
    case X_Modnum:
      objbyte( OBJWORD );
      /*
       * For module numbers I will stick to 12 bit offsets for now.
       */
      objbyte( PATCHARMLDR );       /* Only format used is LDR xx, [dp, #modnum] */
      objnum(  code );
      objbyte( PATCHSHIFT );
      objnum(  split_module_table ? 3 : 2 );
      objbyte( OBJMODNUM );
      
      return 4;
      
    case X_PCreloc:
      objbyte( OBJWORD );
      objbyte( PATCHARMBL );
      objnum(  code );
      objbyte( OBJLABELREF );
      
      objsymbol( '.', symname_( sym ) );
      break;
      
    case X_PCreloc2:                /* Patch an ADD instruction */
      objbyte( OBJWORD );
      objbyte( PATCHARMADDLO );
      objnum(  code );
      objbyte( OBJLABELREF );
      
      objsymbol( '.', symname_( sym ) );
      break;
      
    case X_DataSymb2:
      objbyte( OBJWORD );
      objbyte( PATCHARMADDLO );
      objnum(  code );
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
      break;

    case X_PCreloc3:                /* Patch an ADD instruction */
      objbyte( OBJWORD );
      objbyte( PATCHARMADDHI );
      objnum(  code );
      objbyte( OBJLABELREF );
      
      objsymbol( '.', symname_( sym ) );
      break;
      
    case X_DataSymb3:
      objbyte( OBJWORD );
      objbyte( PATCHARMADDHI );
      objnum(  code );
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
      break;

    case X_DataSymb6:
      objbyte( OBJWORD );
      objbyte( PATCHARMADDMID );
      objnum(  code );
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
      break;

    case X_DataModule:
      objbyte( OBJWORD );
      objbyte( PATCHARMLDR );
      objnum(  code );
      objbyte( OBJDATAMODULE );
      
      objsymbol( '_', symname_( sym ) );
      break;
      
    case X_DataSymb:
      objbyte( OBJWORD );
      objbyte( PATCHARMLDR );
      objnum(  code );
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
      break;
      
    case X_Init:
      objbyte( OBJINIT );
      break;

    default:
      syserr( syserr_heliobj_bad_xref, sym, (long)xrtype );
      
      return 0;
    }
  
  return 4;
      
} /* objdirective */

/*}}}*/

#else /* not C40, 68K, or ARM */

#error Unknown target processor

#endif /* machine specific versions of objdirective */

/*}}}*/
/*{{{  startcode */

static void
startcode( int32 n )
{
  if (n == 0 || objstream == NULL)
    return;

  objbyte( OBJCODE );
  
  objnum( n );

  return;
  
} /* startcode */

/*}}}*/
/*{{{  startdata */

static void
startdata(
	  int32		n,
	  char *	name )
{
  if (objstream)
    {
      objbyte( OBJDATA );
      
      objnum( n );
      
      objsymbol( '_', name );
    }
  
  datasize += n;

  return;

} /* startdata */

/*}}}*/
/*{{{  startcodetable */

static void
startcodetable(
	       int32	n,
	       char *	name )
{
  if (objstream)
    {
      objbyte( split_module_table ? OBJCODETABLE : OBJDATA );
      
      if (!split_module_table)
	objnum( n );
      
      objsymbol( '_', name );
    }
  
  maxcodep += n;

  return;
  
} /* startcodetable */

/*}}}*/
/*{{{  objlabel */

static void
objlabel(
	 char	prefix,
	 char *	name )
{
  if (objstream)
    {
      /*
       * This guard seems necessary since objlabel is called from obj_symref
       * which itself gets called even when an object file is not needed.
       */
      
      objbyte( OBJLABEL );
      
      objsymbol( prefix, name );
    }

  return;
  
} /* objlabel */

/*}}}*/
/*{{{  obj_outcode */

/* Since an object directive might take us over the end of     */
/* the buffer we are actually outputting this routine returns  */
/* the number of bytes it has encroached into the next buffer. */

static int32
obj_outcode(
	    char *		buff,
	    CodeFlag_t *	flag,
	    int32 		nbytes,
	    int32		segbase )
{
  static bool	inited    = FALSE;
  static long	must_swap = FALSE;
  int32 	i;
  int32 	b = 0;
  int32		n;

  
  IGNORE( flag );               /* i.e. no cross-sex compilation */

  if (!inited)
    {
      int	a = 0x12345678;

	  
      if (((char *)&a)[ 0 ] == 0x12)
	{
#ifdef TARGET_IS_BIG_ENDIAN
	  must_swap = FALSE;
#else
	  must_swap = TRUE;	  
#endif
	}
      else
	{
#ifdef TARGET_IS_BIG_ENDIAN
	  must_swap = TRUE;
#else
	  must_swap = FALSE;
#endif
	}      

      inited = TRUE;
    }

  for (b = 0; b < nbytes; b += n)
    {
      bool	xrflag = 0;
      int32	xrtype = 0;
      int32	xcode  = 0;


      if (codexrefs)
        {
	  int32		x = codexrefs->codexroff & 0x00ffffffU;
	  
	  
	  if (x < segbase + nbytes)
            {
	      xrflag = 1;
	      xrtype = codexrefs->codexroff & 0xff000000U;
	      n      = x - segbase - b;
            }
	  else
	    {
	      n = nbytes - b;
	    }
        }
      else
	{
	  n = nbytes - b;
	}
      
      startcode( n );

      if (must_swap)
	{
	  for (i = b; i < (b + n); i++)
	    {
	      objbyte( buff[ (i & ~3) + (3 - (i & 3)) ] );
	    }

	  xcode  =  (int32)(buff[ i++ ]) << 24;
	  xcode |= ((int32)(buff[ i++ ]) << 16) & 0x00ff0000;
	  xcode |= ((int32)(buff[ i++ ]) << 8)  & 0x0000ff00;
	  xcode |= ((int32)(buff[ i++ ]))       & 0x000000ff;
	}
      else
	{
	  for (i = b; i < (b + n); i++)
	    {
	      objbyte( buff[ i ] );
	    }
	  
	  xcode  = buff[ i++ ];
	  xcode |= (int32)buff[ i++ ] << 8;
	  xcode |= (int32)buff[ i++ ] << 16;
	  xcode |= (int32)buff[ i++ ] << 24;
	}
      
      if (xrflag)
        {
	  CodeXref *	c = codexrefs;


	  codexrefs = c->codexrcdr;

	  switch (xrtype)
            {
	    case X_absreloc:
	      xcode += c->codexrcode;
	      break;
	      
	    case X_DataSymb:
	    case X_PCreloc:
#ifndef TARGET_IS_C40
	      /*
	       * pick up offset coded into 4th field
	       * (ie by using global_list4)
	       */
	      
	      if (c->codexrcode > 0xffff)
		cc_warn( heliobj_warn_16bits, (long)c->codexrcode );
	      
	      xcode += c->codexrcode;
#endif
	      break;

#ifdef TARGET_IS_ARM
	    case X_PCreloc2:    /* These involve 2 ADD instrns so can cover 16 bits */
	    case X_PCreloc3:

	      if (c->codexrcode > 0xffff)
		cc_warn( heliobj_warn_16bits, (long)c->codexrcode );
	      
	      xcode += c->codexrcode;

	      break;

	    case X_DataSymb2:
	    case X_DataSymb3:
	    case X_DataSymb6:

	      if (c->codexrcode > 0xfff)
		cc_warn( heliobj_warn_12bits, (long)c->codexrcode );
	      
	      xcode += c->codexrcode;

	      break;
#endif
	    default:
	      fprintf( stderr, "heliobj: unknown cross reference type %lx\n", xrtype );

	      break;
	      
#ifdef TARGET_IS_C40
	    case X_DataModule1:
	    case X_DataModule2:
	    case X_DataModule3:
	    case X_DataModule4:
	    case X_DataModule5:
	    case X_DataSymbHi:
	    case X_DataSymbLo:
	    case X_DataAddr1:
	    case X_FuncAddr:
	    case X_PCreloc2:
#endif /* TARGET_IS_C40 */
	      
#ifdef TARGET_HAS_DEBUGGER
	    case X_Debug_Modnum:
	    case X_Debug_Offset:
	    case X_Debug_Ref:
#endif
	    case X_DataAddr:
	    case X_DataModule:
	    case X_Modnum:
	      break;
            }

	  n += objdirective( xrtype, c->codexrsym, xcode );
        }
    }

  return (b - nbytes);

} /* obj_outcode */

/*}}}*/
/*{{{  obj_codewrite */

void
obj_codewrite( Symstr * name )
{
  int32 	i       = 0;
  int32 	overrun = 0;
  int32 	segbase = codebase;

  
  if (codep == 0)
    {
      return;
    }  

  if (codexrefs != NULL)
    {
      /* Odd how the list ALL gets reversed every routine? */
  
      codexrefs = (CodeXref *)dreverse( (List *)codexrefs );
    }
      
  while ((codep / sizeof (int)) - CODEVECSEGSIZE * i > CODEVECSEGSIZE)
    {
      overrun = obj_outcode( (char *)code_instvec_( i ) + overrun, code_flagvec_( i ),
                               CODEVECSEGSIZE * sizeof (int) - overrun, segbase );
      
      segbase += CODEVECSEGSIZE * sizeof (int) + overrun;
      
      i++;
    }

  obj_outcode( (char *)code_instvec_( i ) + overrun, code_flagvec_( i ),
                (codep - CODEVECSEGSIZE * i * sizeof (int)) - overrun, segbase );
  
  codesize += codep;

#if defined TARGET_IS_C40 && defined NEVER
  /*
   * XXX
   *
   * one day we would like to align the start of
   * functions (and the initialisation code) to 128
   * byte boundaries to optimize the use of the 'C40's
   * op code cache.  Unfortuanetly this would upset the
   * compiler's calculation of intra function offsets
   * so that these would have to be recoded.
   */
  
  if (name == NULL)
    {
      int32	x = codesize;

      
      /* ensure that code is padded to a 128 byte boundary */
      
      x &= (128 - 1);

      if (x)
	{
	  x = 128 - x;
	  
	  objbyte( OBJBSS );
      
	  objnum( x );

	  codesize += x;
	}
    }
#endif /* TARGET_IS_C40 */
  
  return;

  name = name;
  
} /* obj_codewrite */

/*}}}*/
/*{{{  request_stub */

void
request_stub( Symstr * name )
{
  Stub *	s;


  for (s = stublist; (s != NULL); s = s->stubcdr)
    {
#ifdef TARGET_IS_ARM		/* JGS: 910213 : Deal with our special exception stubs */
      
      if (((Symstr *)((int32)(s->stubsym) & ~(1UL << 31))) == name)
	return;
      
#else /* not TARGET_IS_ARM */
      
      if (s->stubsym == name)
	return;
      
#endif /* TARGET_IS_ARM */
    }
  
  stublist = (Stub *)global_cons2( SU_Other, stublist, name );

  return;
  
} /* request_stub */

/*}}}*/
/*{{{  request_exception_stub */

#ifdef TARGET_IS_ARM
/* JGS: 910213
 *	This is required to register a special exception handling stub. These
 *	stubs will NOT corrupt any registers. This introduces an unnecessary
 *	performance hit for normal PCS conforming functions, but is required
 *	for certain exceptional cases (eg. stack overflow).
 */

void
request_exception_stub( Symstr * name )
{
  Stub *	s;


  /* JGS: 910213 : Deal with our special exception stubs */

  for (s = stublist; (s != NULL); s = s->stubcdr)
    if (((Symstr *)((int32)(s->stubsym) & ~(1UL << 31))) == name)
      return ;
  
  /* We need to use a special marker to highlight that this is an exception */
  
  stublist = (Stub *)global_cons2( SU_Other, stublist, ((int32) name | (1UL << 31)) );

  return;
  
} /* request_exception_stub */

#endif /* TARGET_IS_ARM */

/*}}}*/
/*{{{  show_stubs */

static void
show_stubs( void )
{
  Stub *	s;
  VRegInt 	vr1, vr2, vm;


#ifdef TARGET_USES_NEW_STUBS
  if (!new_stubs)
#endif
    {
      asmf( ";\n; Function Stubs\n" );
  
      in_stubs = YES;

      codebuf_reinit2();
  
      localcg_reinit();
  
      vr1.r = vr2.r = GAP; vm.i = 0;
  
      procflags = 0;

      show_instruction( J_ENTER, vr1, vr2, vm );      
    }

  for (s = stublist; s != NULL; s = s->stubcdr)
    {
      Symstr *	sym = s->stubsym;

#ifdef TARGET_IS_ARM
      /* JGS: 910213
       * We have encoded the exceptional flag in the top bit of the symbol
       * pointer. This assumes things about the environment the compiler
       * is executing under. If we are an exceptional stub, we should generate
       * code that preserve all the registers over the stub call.
       */
     
      if (((int32)sym & (1UL << 31)) != 0)
	{
	  sym = (Symstr *)((int32)sym & ~(1UL << 31)) ; /* clear the flag bit */
	}
#endif /* TARGET_IS_ARM */

      if (!is_defined( symext_( sym ) ))
	{
	  if (debugging( DEBUG_OBJ ))
	   cc_msg( "Stub for $r\n", s );
	  
#ifdef TARGET_USES_NEW_STUBS
	  if (new_stubs)
	    {
	      /*
	       * If 'sym' is not defined locally then make it global
	       */
	     
	      request_new_stub( sym );
	    }
	  else
#endif /* TARGET_USES_NEW_STUBS */
	    {
	      /*
	       * CGS: Changed from show_entry because that makes the symbol defined.
	       * I do not want it defined because when we come to do the init sequence
	       * it will think that the label is defined and would put a pointer
	       * to the stub into the data area. (viz. X problem).
	       * All we do is define the label to the linker and let that worry about
	       * patching up the forward references from the code.
	       */
#if defined TARGET_USES_NEW_STUBS
	     if (new_stubs)
	       {
		 objlabel( '.', symname_( sym ) );
	       }
	     else
	       {
		 objlabel( '#', symname_( sym ) );

		 /*
		  * force a reference to the .<name> so that the
		  * relevant scanned library will be linked in
		  */
		 
		 objbyte( OBJREF );
      
		 objsymbol( '.', symname_( sym ) );
	       }
#else
	      objlabel( '.', symname_( sym ) );
#endif
	     
	      /*
	       * Note that the two values passed in the r1 and r2 fields here are a
	       * bit suspect, but something is certainly needed...
	       */
	     
	      /* Beware the sym on the next line -- it probably needs to be a      */
	      /* slighly different Symstr.                                         */
	     
	      vr1.rr = R_A1;
	      vr2.i  = 0;
	      vm.sym = sym;
	     
	      show_instruction( J_TAILCALLK, vr1, vr2, vm );
	     
	      vr1.r = vr2.r = GAP;
	      vm.i  = 0;
	      
	      show_instruction( J_ENDPROC, vr1, vr2, vm );
	      
	      show_code( sym );
	      
	      asm_lablist = NULL;
	    }
	}
    }

#ifndef TARGET_USES_NEW_STUBS
  in_stubs = NO;
#endif
  
  return;

} /* show_stubs */

/*}}}*/
/*{{{  export_routines */

static void
export_routines( void )
{
  ExtRef *	x;
#ifndef TARGET_IS_C40
  VRegInt	vr1, vr2, vm;
#endif


  for (x = obj_symlist; x != NULL; x = extcdr_( x ))
    {
      if (is_external_code( x ))
	{
	  if (objstream)
	    {
	      globalise( extsym_( x ) );
	      
	      startcodetable( 4, symname_( extsym_( x ) ) );
	    }

#ifdef TARGET_IS_C40
	  export_function( extsym_( x ), R_ATMP );
#else
	  /*
	   * get the address of symbol 'x' into the register '_RADDR1'
	   */
	  
	  vr1.rr = R_ADDR1;
	  vr2.i  = 0;
	  vm.sym = extsym_( x );
	  
	  show_instruction( J_ADCON, vr1, vr2, vm );

	  /*
	   * store the address in the word pointed to by R_ATMP
	   * (which contains the address of the current module's
	   *  data area)
	   */
	  
	  vr2.rr = R_ATMP;
	  vm.i   = 0;
	  
	  show_instruction( J_STRK,  vr1, vr2, vm );

	  /*
	   * increase R_ATMP to point to the next word
	   */
	  
	  vr1.rr = R_ATMP;
	  vm.i   = sizeof_int;

	  show_instruction( J_ADDK,  vr1, vr2, vm );
#endif /* TARGET_IS_C40 */
	}
    }

  return;
  
} /* export_routines */

/*}}}*/
/*{{{  output_symbol */

static void
output_symbol(
	      Symstr *	sym,
	      int32	size )
{
  if (objstream)
    {
      if (sym != NULL)
        {
	  if (is_global( symext_( sym ) ))
	    globalise( sym );
        }
    }

  /* AM: NULL changed to "" next line Apr 89.  Why is sym ever 0? */

  startdata( size, sym ? symname_( sym ) : "" );

  return;
  
} /* output_symbol */

/*}}}*/
/*{{{  loopstart */

#ifndef TARGET_IS_C40 

static LabelNumber *
loopstart( int32 rpt )
{
  LabelNumber *	l;
  VRegInt	vr1;
  VRegInt	vr2;
  VRegInt	vm;


  vr1.rr = R_A1;
  vr2.r  = GAP;
  vm.i   = rpt;

  show_instruction( J_MOVK, vr1, vr2, vm );

  l = nextlabel();

  vr1.r = GAP;
  vm.l  = l;

  show_instruction( J_LABEL, vr1, vr2, vm );

  return l;
  
} /* loopstart */

/*}}}*/
/*{{{  loopend */

static void
loopend( LabelNumber * l )
{
  VRegInt vr1;
  VRegInt vr2;
  VRegInt vm;

  
  vr1.rr = vr2.rr = R_A1;
  vm.i   = 1;

  show_instruction( J_SUBK, vr1, vr2, vm );

  vr1.r = GAP;
  vm.i  = 0;

  show_instruction( J_CMPK + Q_NE, vr1, vr2, vm );

  vr2.r = GAP;
  vm.l  = l;

  show_instruction( J_B | Q_NE, vr1, vr2, vm );

  return;
  
} /* loopend */

#endif /* not TARGET_IS_C40 */

/*}}}*/
/*{{{  show_init_entry */

static void
show_init_entry( void )
{
  VRegInt	vr1, vr2, vm;


  datainitlab = nextlabel();

  /* XXX - turn off stack checking and back tracing in initialisation rouitnes */
  
  var_no_stack_checks   = 1;
#ifdef TARGET_IS_C40
  var_backtrace_enabled = 0;
#endif
  
  codebuf_reinit2();                  /* needed before show_inst etc. */
  
  localcg_reinit();
  
  if (objstream != NULL)
    {
      objbyte( OBJINIT );

      codesize += sizeof_int;      
    }
  
  asmf( ";\n; Data / Function Table Initialisation\n" );
  
  codebase += sizeof_int;

  /*
   * register usage not thought out here yet ...
   */

  regmask  = 0;            /* regbit(R_ADDR1); ??? */

#ifdef TARGET_IS_C40
  /* no registers used by init code ! */
  
  memclr( (VoidStar)&usedmaskvec, sizeof(RealRegSet) );
#endif

#ifdef TARGET_HAS_DEBUGGER
  /* no debugging for init code ! */
  
  usrdbgmask = 0;
#endif
  
  vr1.r = vr2.r = GAP;
  vm.i  = 0;
  
  procflags = 0;

  show_instruction( J_ENTER, vr1, vr2, vm );

  /*  show_instruction( J_MOVR, R_A2, GAP, R_DP ); (DP seem not to get corrupted) */
  
  if (split_module_table)
    {
#ifdef TARGET_IS_C40
      DataInit * p;


      /* see if we are going to have to initialise any data */
      
      for (p = datainitp; p != NULL; p = p->datacdr)
	if (p->sort != LIT_LABEL)
	  break;
      
      prepare_for_initialisation( p != NULL, datainitlab );

#else /* ! TARGET_IS_C40 */
      
      vr1.r  = GAP;
      vr2.rr = R_A1;
      vm.i   = 2;
      
      show_instruction( J_CMPK | Q_NE, vr1, vr2, vm );
      
      vr2.r = GAP;
      vm.l  = datainitlab;
      
      show_instruction( J_B | Q_NE, vr1, vr2, vm );

#endif /* TARGET_IS_C40 */
    }

#ifndef TARGET_IS_C40
  load_static_data_ptr( R_ATMP, split_module_table );
#endif
  
  return;
  
} /* show_init_entry */

/*}}}*/
/*{{{  show_init_return */

static void
show_init_return( void )
{
  VRegInt vr1, vr2, vm;


  /*  show_instruction( J_MOVR, R_DP, GAP, R_A2 );          */

  vr1.r = vr2.r = GAP;
  vm.l  = RETLAB;

  show_instruction( J_B | Q_AL, vr1, vr2, vm );

#ifndef TARGET_IS_C40  
  vm.i = 0;

  show_instruction( J_ENDPROC, vr1, vr2, vm );

  asm_lablist = NULL;

  show_code( 0 );
  
#endif /* not TARGET_IS_C40 */
  
  return;
  
} /* show_init_return */

/*}}}*/
/*{{{  IEEE convert */

#ifdef TARGET_IS_C40
/*
 * XXX - WARNING
 *
 * The following code is now highly C40 specific.
 * Subvert at your own risk
 */

/*{{{  IEEE_to_single_float */

/*
 * converts a 32 bit IEEE format floating point value into
 * a C40 format 32 bit floating point value
 */

int32
IEEE_to_single_float( int32 val )
{
  int32	e;
  int32	f;
  int32	s;

  
  /* extract components */
  
  e = (val >> 23) & 0xff;
  s = val & (1U << 31);
  f = val & ((1U << 23) - 1);

  /* decode - this algorithm is taken from the TMS320C4x User's Guide, page 4-12 */
  
  if (e == 0xff)
    {
      if (s == 0)
	{
	  e = 0x7f;
	  /* s = 0; */
	  f = 0x7fffff;
	}
      else
	{
	  e = 0x7f;
	  s = 1;
	  f = 0;
	}
    }
  else if (e == 0)
    {
      e = 0x80;
      s = 0;
      f = 0;
    }
  else
    {
      if (s == 0)
	{
	  e -= 0x7f;
	  /* s = 0; */
	  /* f = f; */
	}
      else
	{
	  if (f == 0)
	    {
	      e -= 0x80;
	      s  = 1;
	      /* f  = 0; */
	    }
	  else
	    {
	      e -= 0x7f;
	      s  = 1;
	      f  = ((~f) + 1);
	    }
	}
    }
  
  return (e << 24) | (s << 23) | (f & ((1 << 23) - 1));
  
} /* IEEE_to_single_float */

/*}}}*/
/*{{{  IEEE_to_extended_float */

/*
 * converts a 64 bit IEEE format number into a 40 bit C40 number
 * returns the most signifcant 32 bits of the result
 */

int32
IEEE_to_extended_float(
		       int32		high,		/* most  significant 32 bits of 64 bit IEEE number */
		       unsigned32	low,		/* least significant 32 bits of 64 bit IEEE number */
		       int32 *		low_return )  	/* least significant 32 bits of the result         */
{
  int32		e;
  unsigned32	f;
  unsigned32	s;


  /*
   * extract components
   *
   * IEEE double precision format is
   *
   *
   *    63 62          52 51                          0
   *    __ ______________ _____________________________
   *   |  |              |                             |
   *   |s | exponent     | mantissa                    |
   *   |__|______________|_____________________________|
   * or                              |
   *    31 30          20 19        0|31              0
   *                                 |
   *
   * C40 extended precision format is
   *
   *              39        32 31 30                 0
   *              ____________ __ ____________________
   *             |            |  |                    |
   *             | exponent   |s | mantissa           |
   *             |____________|__|____________________|
   *   
   */
  
  e = (high >> 20) & 0x7ff;
  s = high & (1U << 31);
  f = (high << (31 - 19)) | (low >> 20);

  /* debug( "converting IEEE number %x (high) %x (low), e = %x, s = %x, f = %x", high, low, e, s, f ); */
  
  /* decode - this algorithm is based on the one in the TMS320C4x User's Guide, page 4-12 */

  e -= 0x3ff;

  if (e > 127)
    {
      if (e < 0x3ff || f != 0xffffffffU)
	{
	  cc_warn( "floating point accuracy completely lost!" );
	}
		
      e = 0x7f;
	      
      if (s == 0)
	{
	  /* largest positive value */
	  
	  f = 0x7fffffffU;
	}
      else
	{
	  /* largest negative value */
	  
	  f = 0;
	}
    }
  else if (e == -1023)
    {
      e = 0x80;
      s = 0;
      f = 0;
    }
  else if (e < -128)
    {
      if (e != 0xfffff400U || f != 0x0U)
	{
	  cc_warn( "floating point accuracy completely lost! (e = 0x%lx, s = 0x%lx, f = 0x%lx)",
		  e + 0x3ff, s, f );
	}
		
      if (s == 0)
	{
	  /* smallest positive value */
	  
	  e = 0x81;	/* beware of 0.0 */
	  f = 0x0;
	}
      else
	{
	  /* smallest negative value */
	  
	  e = 0x80;
	  f = 0x7fffffffU;
	}
    }
  else
    {
      if (s != 0)
	{
	  if (f == 0)
	    {
	      e -= 1;
	    }
	  else
	    {
	      f = ((~f) + 1);
	    }
	}
    }

  /* debug( "after conversion, e = %x, s = %x, f = %x", e, s, f ); */
  
  if (low_return != NULL)
    {
      if (s == 0)
	{
	  /* round towards nearest */

	  if (!(++f))
	    ++e;
	  
	  *low_return = (f >> 1);
	}
      else
	{
	  /* already rounded when converting from two's complement */
	  
	  *low_return = (1U << 31) | (f >> 1);
	}
      
      /* debug( "low return = %x", *low_return ); */
    }

  if (s == 0)
    {
      return (e << 24) | ((f >> 9) & ((1 << 23) - 1));
    }
  else
    {
      return (e << 24) | (1 << 23) | ((f >> 9) & ((1 << 23) - 1));
    }
  
} /* IEEE_to_extended_float */

/*}}}*/

#endif /* TARGET_IS_C40 */
  

/*}}}*/
/*{{{  PHASED data generation */

#ifdef TARGET_IS_C40

/*{{{  Variables */

static int32		skip	     = 0;
static int32		block_size   = 0;
static unsigned32	curdsize     = 0;
static unsigned32	dataslot     = 0;
static unsigned32	old_dataslot = 0;
static unsigned32	words_out    = 0;
static ExtRef *		dsymb        = NULL;
static ExtRef *		curdsymb     = NULL;

/*}}}*/

/*{{{  init_phase */

/*
 * initialise the static variables, (and possibly
 * generate some code), at the start of a phase
 */

static void
init_phase(
	   int 		first_phase,	/* non-0 if this is the first phase */
	   ExtRef *	datasymbols,	/* pointer to the start of the list of data symbols */
	   bool		need_label )	/* non-0 if code will be generated, only valid during first phase */
{
  static LabelNumber *	l;

  
  if (first_phase)
    {
      if (need_label)
	{
	  l = nextlabel();
      
	  prepare_for_block_copying( l );
	}
      else
	{
	  l = NULL;
	}
      
      curdsize     = 0;
      dataslot	   = 0;
      old_dataslot = 0;

      dsymb        = datasymbols;
      curdsymb	   = NULL;
    }
  else
    {
      show_init_return();

      if (l)
	{
	  setlabel( l );

	  words_out = 0;
	}
      else
	{
	  words_out = 1;
	}
    }

  return;

} /* init_phase */

/*}}}*/
/*{{{  phase_export_block */

/*
 * Export a block of data.  The size of the
 * block is 'block_size' words.  The block's
 * source address is held in AR0 and the
 * block's destination address is in AR5
 */

static void
phase_export_block( void )
{
  if (block_size != 0)
    {
      block_copy_data( block_size );

      curdsize += block_size;
      
      block_size = 0;
    }

  return;
  
} /* phase_export_block */
  

/*}}}*/
/*{{{  phase_skip_block */

/*
 * Skip a block of zero data
 */

static void
phase_skip_block( void )
{
  if (skip)
    {
      VRegInt	vr1;
      VRegInt	vr2;
      VRegInt	vm;

	      
      vr1.rr = vr2.rr = R_ATMP;
      vm.i   = skip;
      
      show_instruction( J_ADDK, vr1, vr2, vm );

      curdsize += skip;
      
      skip = 0;
    }

  return;
  
} /* phase_skip_block */

/*}}}*/
/*{{{  phase_export_symbols */

/*
 * perform whatever actions are appropriate
 * so that the exported symbols are registered
 * with the linker
 */

static void
phase_export_symbols(
		     int 	first_phase,
		     int32	length,
		     int32	repeat )
{
  /*
   * Generate directives to allocate space
   * and a label for an exported data symbol
   */
	      
  if (first_phase)
    {
      /* if we have any exported data left */

      if (dsymb != NULL)
	{
	  int32	dataoff = dsymb->extoffset;
		  

	  /* have we reached the location of the next symbol to be exported  ? */
	  
	  if (dataslot == dataoff)
	    {
	      /* do we have a previous symbol to export ? */
	      
	      if (curdsymb != NULL)
		{
		  /*
		   * Export the previous symbol.
		   *
		   * The size of the symbol is not its own size, but
		   * distance between where it is defined and where
		   * the current symbol is defined.  This is because
		   * strings in the code segment must be copied into
		   * the data segment, but they do not have labels
		   * associated with them, and so no symbol is created
		   * for them.  Thus the space used by strings is
		   * amalgamated into the space used by the previous
		   * data symbol.
		   */

		  output_symbol( extsym_( curdsymb ), dataslot - old_dataslot );
		}

	      /* export all but the last symbol with this offset */
	      
	      for (; extcdr_( dsymb ) && extoffset_( extcdr_( dsymb ) ) == dataoff; dsymb = extcdr_( dsymb ) )
		{
		  output_symbol( extsym_( dsymb ), 0 );
		}

	      /* remember the last symbol at this offset, and the size of the data segment at this point */
	      
	      old_dataslot = dataslot;
	      curdsymb     = dsymb;

	      /* point to the next symbol in the list */
	      
	      dsymb = extcdr_( dsymb );

	      if (dsymb != NULL && extoffset_( dsymb ) < dataoff)
		{
		  syserr( heliobj_misplaced_offsets,
			 symname_( extsym_( dsymb ) ),    extoffset_( dsymb ),
			 symname_( extsym_( curdsymb ) ), extoffset_( curdsymb ) );
		}	      
	    }
	  else if (dataoff < dataslot)
	    {
	      /* oh dear - we have mislaid a symbol */

	      debug( "dataoff = %lx, dataslot = %lx", dataoff, dataslot );
	      
	      syserr( syserr_heliobj_dataseggen );
	    }
	}

      /* keep track of how much data has been generated */
      
      dataslot += length * repeat;
    }

  return;
  
} /* phase_export_symbols */
  

/*}}}*/
/*{{{  phase_store */

/*
 * perform whatever actions are appropriate for
 * storing the word 'value', 'repeat' times into
 * the data segment
 */

static void
phase_store(
	    int			first_phase,	/* non-0 iff this is the first phase 			*/
	    unsigned32		value,		/* the word to be stored in the data area 		*/
	    int32		repeat )	/* the number of times this word is to be stored	*/
{
  /* possibly export data symbols */
	      
  phase_export_symbols( first_phase, sizeof_long, repeat );
	      
  if (first_phase)
    {
      /* generate code to do the initialisation */

      if (value == 0)
	{
	  if (block_size != 0)
	    {
	      /*
	       * we have come to the end of a block of non-zero data,
	       * so generate the block
	       */
	      
	      phase_export_block();
	    }
	  	  
	  /* data area is pre-initialised to zero, so just skip over it */

	  skip += repeat;
	}
      else
	{
	  if (skip)
	    {
	      /*
	       * we are about to output some code, so adjust the destination
	       * pointer to allow for the blanks skipped
	       */

	      phase_skip_block();
	    }
	  
	  /*
	   * count the number of words to emit, and generate the code
	   * at the end of the block
	   */

	  block_size += repeat;
	}
    }
  else
    {
      if (value != 0)
	{
	  words_out = 1;
	  
	  while (repeat--)
	    {
	      outcodeword( value, LIT_NUMBER );
	    }
	}
    }

  return;
  
} /* phase_store */

/*}}}*/
/*{{{  phase_store_address_constant */

/*
 * perform whatever actions are appropriate for
 * storing an address constant into the data segment
 */

static void
phase_store_address_constant(
			     int	first_phase,	/* non-0 if this is the first phase		   */
			     Symstr *	symbol,		/* the symbols whoes address is to be stored	   */
			     int32	offset )	/* the offset to be added to this symbol's address */
{
  /* possibly export data symbols */
  
  phase_export_symbols( first_phase, sizeof_ptr, 1 );
	      
  if (first_phase)
    {
      if (skip)
	{
	  phase_skip_block();
	}
      
      if (block_size)
	{
	  phase_export_block();
	}

      export_data_symbol( symbol, offset, curdsize );

      curdsize++;
    }
  else
    {
      /* pretend we are storing 0, so that non-0 blocks are flushed */
      
      phase_store( first_phase, 0, 1 );
    }  

  return;
  
} /* phase_store_address_constant */

/*}}}*/
/*{{{  finish_phase */

static void
finish_phase(
	     int 	first_phase,	/* non-0 if this the end of the first phase */
	     bool	need_label )	/* non-0 if a label was needed */
{
  if (first_phase)
    {
      /* ignore any trailing skip */

      skip = 0;

      /* copy the last block, if there is one */
      
      if (block_size)
	{
	  phase_export_block();
	}

      /* if there is a remaining data symbol to export then do so */
      
      if (curdsymb)
	{
	  output_symbol( extsym_( curdsymb ), dataslot - old_dataslot );
	}
    }
  else
    {
      if (need_label && words_out == 0)
	{
	  /*
	   * we have generated a label, but we have
	   * not actually put any code to follow this
	   * label!  Hence we emit a dummy value, just
	   * to keep the object code formatter happy
	   */
	  
	  outcodeword( 0, LIT_NUMBER );
	}
    }  
  
  return;
  
} /* finish_phase */

/*}}}*/

#endif /* TARGET_IS_C40 */
  

/*}}}*/
/*{{{  insert_dlist */

/*
 * inserts the cross refence for the given data item into
 * the data list, maintaining the ordering of the list.
 */

static void
insert_dlist( ExtRef * x )
{
  ExtRef *	ptr;
  ExtRef *	prev = NULL;
  

  prev = NULL;
  
  for (ptr = datasymbols; ptr != NULL; ptr = ptr->extcdr)
    {
      if (ptr->extoffset > x->extoffset)
	{
	  /* insert before ptr */

	  if (prev == NULL)
	    {
	      x->extcdr = datasymbols->extcdr;
	      
	      datasymbols = x;
	    }
	  else
	    {
	      prev->extcdr = x;
	      x->extcdr    = ptr;
	    }
	  
	  return;	  
	}

      prev = ptr;
    }

  /* append to end of list */
  
  if (prev == NULL)
    {
      datasymbols = x;
    }
  else
    {
      prev->extcdr = x;
    }

  x->extcdr = NULL;
  
  return;
  
} /* insert_dlist */

/*}}}*/
/*{{{  export_functions */

#ifdef TARGET_IS_C40
static void
export_functions( void )
{
  ExtRef *	x;


  if (objstream == NULL)
    return;
  
  for (x = obj_symlist; x != NULL; x = extcdr_( x ) )
    {
      if (is_external_code( x ))
	{
	  globalise( extsym_( x ) );

	  if (
#ifdef TARGET_USES_NEW_STUBS
	      !new_stubs ||
#endif
	      usrdbg( DBG_ANY ))
	    startcodetable( 4, symname_( extsym_( x ) ) );
	}
    }

  return;
  
} /* export_functions */
#endif /* TARGET_IS_C40 */

/*}}}*/
/*{{{  dumpdata */

/*
 * generate code to initialise the module's static data area
 */

static void
dumpdata( void )
{
  static bool	inited  = FALSE;
  static long	big_end = FALSE;
  DataInit *	p;
  
#ifdef TARGET_IS_C40
  
  int		phase;
  bool		need_label;
  
#else
  
  ExtRef *	dsymb;
  ExtRef *	curdsymb    = NULL;
  int32		dataslot    = 0;
  int32		curdsize    = 0;
  int32		justloaded  = 0;
  bool		justvalid   = NO;
  VRegInt	vr1;
  VRegInt	vr2;
  VRegInt	vm;

#endif /* not TARGET_IS_C40 */

  
  if (datainitp == NULL && suppress_module)
    return;

  if (!inited)
    {
      int	a = 0x12345678;

	  
      if (((char *)&a)[ 0 ] == 0x12)
	{
	  big_end = TRUE;
	}

      inited = TRUE;
    }

  /* With any luck the symbols should be in obj_symlist in increasing */
  /* order so all I have to do is fetch the data symbols which are    */
  /* in obj_symlist and append them onto datasymbols to get them in   */
  /* the right order   (ascending order of extoffset)                 */
  
  /*
   * XXX - NC - 8/6/92
   *
   * Unfortunatelty this is not true.
   *
   * What can happen is that a symbol (X) is declared as external,
   * so it gains a place in the obj_symlist, with an offset of zero.
   * Other, normal symbols (Y, Z), are then declared, so they gain later
   * places in obj_symlist with increasing (non-zero) offsets.  Then the
   * external symbol (X) is in fact declared as being defined in the
   * current module!.  (Bad C practice, but legal).  This then gives
   * X a non-zero offset which is greater than Y or Z's, but with X
   * being declared before Y or Z in the obj_symlist.
   */

    {
      ExtRef **	flist;
      ExtRef *	x;
      
      
      datasymbols = NULL;
      flist       = &obj_symlist;

      /* scan linked list of symbols */
      
      for (x = obj_symlist; x != NULL;)
	{
	  ExtRef *	succ;

	  
	  succ = x->extcdr;

	  if (is_data( x ) && is_defined( x ))
	    {
	      /* insert data items into data list */
	      
	      insert_dlist( x );	      
	    }
	  else
	    {
	      /* append function names to function list (these are always sorted) */
	      
	      *flist = x;
	      flist  = &x->extcdr;
	    }

	  x = succ;	  
	}
    }
  
  /* At this point we generate the code to initialise the static data section. */

  codebuf_reinit2();
  
  show_init_entry();

#ifdef TARGET_IS_C40
/*{{{  C40 data exporting */

  if (
#ifdef TARGET_USES_NEW_STUBS
      new_stubs &&
#endif
      !usrdbg( DBG_ANY ))
    {
      export_functions();
    }
  else
    {
      if (!suppress_module)
	{
	  prepare_for_function_exporting();

	  /* generate a label for function address calculation */

	  if (asmstream != NULL)
	    {
	      flush_peepholer( DBG( "generating asm label" ) );
	      
	      exporting_routines = nextlabel();
	      
	      setlabel( exporting_routines );
	    }
	  
	  load_static_data_ptr( R_ATMP, split_module_table, NULL );

	  export_routines();
	}

      /*
       * XXX - beware of assumption of split_module_table == TRUE here
       */
  
      if (!suppress_module)
	{
	  VRegInt	vr1;
	  VRegInt	vr2;
	  VRegInt	vm;

      
	  vr1.r = vr2.r = GAP;
	  vm.l  = RETLAB;
      
	  show_instruction( J_B | Q_AL, vr1, vr2, vm );
	}
    }

  /*
   * scan the data list to see if we are going to have to produce
   * code for data initialisation
   */

  need_label = FALSE;
  phase      = -1;	/* flag used to inidicate if any data needs initialisation */
  
  for (p = datainitp; p != NULL; p = p->datacdr)
    {
      if (p->sort == LIT_LABEL)
	continue;

      phase = 0;	/* we are going to initialise data */
      
      if (p->sort == LIT_ADCON)
	continue;

      if (p->sort == LIT_FPNUM)
	{
	  if (p->len == sizeof_float && ((FloatCon *)p->val)->floatbin.fb.val == 0)
	    continue;

	  if (p->len == sizeof_double 		         &&
	      ((FloatCon *)p->val)->floatbin.db.msd == 0 &&
	      ((FloatCon *)p->val)->floatbin.db.lsd == 0  )
	    continue;

	  need_label = TRUE;
	  
	  break;
	}

      if (p->val != 0)
	{
	  need_label = TRUE;
	  
	  break;
	}
    }
      
  if (phase == 0)
    {
      setlabel( datainitlab );
      
      load_static_data_ptr( R_ATMP, NO, NULL );
	  
      prepare_for_data_exporting( R_ATMP );
  
      /*
       * scan the data list twice
       *
       * The first scan (or phase) generates code to block copy the data
       * from the code segment into the data segment, and to calculate
       * address constants.  The second phase generates word directives
       * to insert the data into the code segment.
       */
      
      for (phase = 2; phase--; )
	{
	  unsigned32	val;
	  
	  
	  init_phase( phase, datasymbols, need_label );
	  
	  if (big_end)
	    {
	      for (p = datainitp; p != NULL; p = p->datacdr)
		{
		  switch (p->sort)
		    {
		    case LIT_LABEL:
		      break;
		      
		    case LIT_ADCON:
		      if (p->rpt != 1)
			syserr( heliobj_repeated_symbol );
		      
		      phase_store_address_constant( phase, (Symstr *)p->len, p->val );
		      break;
		      
		    case LIT_BBBB:
		      val = p->val;
		      
		      val = ((val <<  8) & 0x00FF0000U) |
		            ((val >>  8) & 0x0000FF00U) |
			     (val >> 24)                |
			     (val << 24)                ;
		      
		      phase_store( phase, val, p->rpt );
		      
		      break;
		      
		    case LIT_BBH:
		      val = p->val;
		      phase_store( phase, (val << 16) | (val >> 24) | ((val >>  8) & 0x0000FF00U), p->rpt );
		      break;
		      
		    case LIT_HBB:
		      val = p->val;
		      phase_store( phase, (val >> 16) | (val << 24) | ((val <<  8) & 0x00FF0000U), p->rpt );
		      break;
		      
		    case LIT_HH:
		      val = p->val;		      
		      phase_store( phase, (val << 16) | (val >> 16), p->rpt );
		      break;
		      
		    case LIT_NUMBER:
		      phase_store( phase, p->val, p->rpt );
		      break;
		      
		    case LIT_FPNUM:
		      switch (p->len)
			{
			case sizeof_float:
			  phase_store( phase,
				      IEEE_to_single_float( ((FloatCon *)p->val)->floatbin.fb.val ),
				      p->rpt );
			  break;
			  
			case sizeof_double:		      
			  phase_store( phase,
				      IEEE_to_extended_float(
							     ((FloatCon *)p->val)->floatbin.db.msd,
							     ((FloatCon *)p->val)->floatbin.db.lsd,
							     (int32 *)&val ),
				      p->rpt );
			  phase_store( phase, val, p->rpt );
			  break;
			  
			default:
			  syserr( heliobj_bad_fp_number, p->len );
			  break;
			}
		      
		      break;
		      
		    default:
		      syserr( heliobj_unknown_data_type, p->sort );
		      break;
		    }
		}
	    }
	  else
	    {
	      for (p = datainitp; p != NULL; p = p->datacdr)
		{
		  switch (p->sort)
		    {
		    case LIT_LABEL:
		      break;
		      
		    case LIT_ADCON:
		      if (p->rpt != 1)
			syserr( heliobj_repeated_symbol );
		      
		      phase_store_address_constant( phase, (Symstr *)p->len, p->val );
		      break;
		      
		    case LIT_BBBB:
		    case LIT_BBH:
		    case LIT_HBB:
		    case LIT_HH:
		      if (p->len != sizeof_long)
			syserr( heliobj_bad_packed_length, p->len );
		      
		      phase_store( phase, p->val, p->rpt );
		      break;
		      
		    case LIT_NUMBER:
		      phase_store( phase, p->val, p->rpt );
		      break;
		      
		    case LIT_FPNUM:
		      switch (p->len)
			{
			case sizeof_float:
			  phase_store( phase,
				      IEEE_to_single_float( ((FloatCon *)p->val)->floatbin.fb.val ),
				      p->rpt );
			  break;
			  
			case sizeof_double:		      
			  phase_store( phase,
				      IEEE_to_extended_float(
							     ((FloatCon *)p->val)->floatbin.db.msd,
							     ((FloatCon *)p->val)->floatbin.db.lsd,
							     (int32 *)&val ),
				      p->rpt );
			  phase_store( phase, val, p->rpt );
			  break;
			  
			default:
			  syserr( heliobj_bad_fp_number, p->len );
			  break;
			}
		      break;
		      
		    default:
		      syserr( heliobj_unknown_data_type, p->sort );
		      break;
		    }
		}
	    }
	  
	  finish_phase( phase, need_label );
	}
    }
  
  finished_exporting();
  

/*}}}*/
#else  /* not TARGET_IS_C40 */
/*{{{  others data exporting */

  if (!suppress_module)
    export_routines();
  
  if (split_module_table)
    {
      vr1.r = vr2.r = GAP;
      vm.l  = RETLAB;

      show_instruction( J_B | Q_AL, vr1, vr2, vm );

      setlabel( datainitlab );

      load_static_data_ptr( R_ATMP, NO );
    }

  dsymb = datasymbols;
  
  for (p = datainitp; p != NULL; p = p->datacdr)
    {
      int32 		rpt  = p->rpt;
      int32		sort = p->sort;
      int32		len  = p->len;
      int32		val  = p->val;
      Symstr *		sv;
      FloatCon *	fc;
      LabelNumber *	l;


      if (sort == LIT_LABEL)
	continue;

      if (sort == LIT_ADCON)
	{
	  sv  = (Symstr *)len;
	  len = 4;
	}
      else
	sv = NULL;

      /* Generate the data space offset and label */

      if (dsymb != NULL)
        {
	  int32 	dataoff = dsymb->extoffset;


	  if (dataslot == dataoff)
	    {
              if (curdsymb != NULL)
		output_symbol( curdsymb->extsym, curdsize );
	      
              for (; dsymb->extcdr && dsymb->extcdr->extoffset == dataoff;
		   dsymb = dsymb->extcdr )
		output_symbol( dsymb->extsym, 0 );
	      
              curdsize = 0;
              curdsymb = dsymb;

              dsymb = dsymb->extcdr;
	    }
	  else if (dataoff < dataslot)
	    {
	      syserr( syserr_heliobj_dataseggen );
	    }
        }
      
      curdsize += len * rpt;

      /* Now generate the code to initialise the data */
      
      switch (sort)
        {
	default:
	  syserr( syserr_heliobj_gendata, (long)sort );
	  
	  /* the next 4 are the same as LIT_NUMBER except */
	  /* for (as yet unsupported) cross compilation.  */
	  
	  /* PAB 1/93 added support for cross compilation */
	  /* big endian host, little endian target        */
	  /* code not tested for BBH/HBB/HH combinations. */
	case LIT_BBBB:
	  if (big_end)
	    {
	      int32 x = val;

	      
	      val  =  x << 24;
	      val |= (x << 8 ) & 0x00ff0000;
	      val |= (x >> 8 ) & 0x0000ff00;
	      val |= (x >> 24) & 0x000000ff;
	    }
	  
	  goto	do_dump;

	case LIT_BBH:
	  if (big_end)
	    {
	      int32 x = val;

	      
	      val  =  x << 16;
	      val |= (x >> 8 ) & 0x0000ff00;
	      val |= (x >> 24) & 0x000000ff;
	    }

	  goto	do_dump;

	case LIT_HBB:
	  if (big_end)
	    {
	      int32 x = val;

	      
	      val  =  x << 24;
	      val |= (x << 8 ) & 0x00ff0000;
	      val |= (x >> 16 ) & 0x0000ffff;
	    }
	  
	  goto	do_dump;

	case LIT_HH:
	  if (big_end)
	    {
	      int32 x = val;

	      
	      val  =  x << 16;
	      val |= (x >> 16 ) & 0x0000ffff;
	    }

	  goto	do_dump;

	case LIT_NUMBER:
do_dump:
	  /* cc300+ codebuf.c ensures length == 4. */
	  
	  if (len != 4)
	    syserr( syserr_heliobj_datalen, (long)len );

	  if (val != 0)
	    {
	      if (!justvalid || justloaded != val)
		{
		  vr1.rr = R_DS;
		  vr2.r  = GAP;
		  vm.i   = val;

		  show_instruction( J_MOVK, vr1, vr2, vm );

		  justloaded = val;
		  justvalid  = YES;

		  /* Nothing else in the init code can disturb R_DS... */
		}
	      
	      if (rpt > 1)
		l = loopstart( rpt );
	      else
		l = NULL;
	      
	      vr1.rr = R_DS;
	      vr2.rr = R_ATMP;
	      vm.i   = 0;
	      
	      show_instruction( J_STRK, vr1, vr2, vm );
	      
	      vr1.rr = R_ATMP;
	      vm.i   = len;
	      
	      show_instruction( J_ADDK, vr1, vr2, vm );

	      if (rpt > 1)
		loopend( l );
	    }
	  else    /* val == 0 */
	    {
	      vr1.rr = vr2.rr = R_ATMP;
	      vm.i   = rpt * len;

	      show_instruction( J_ADDK, vr1, vr2, vm );
	    }

	  dataslot += rpt * len;
	  break;

	case LIT_FPNUM:
	  fc = (FloatCon *)val;

	  if (len != sizeof_float && len != sizeof_double)
	    syserr( syserr_heliobj_data, (long)rpt, (long)len, fc->floatstr );
	  
	  val = fc->floatbin.irep[ 0 ];

	  if (len == sizeof_double)
	    val |= fc->floatbin.irep[ 1 ];

	  if (val != 0)
	    {
	      vr1.rr = R_DS;
	      vr2.r  = GAP;
	      vm.i   = fc->floatbin.irep[ 0 ];

	      show_instruction( J_MOVK, vr1, vr2, vm );

	      if (len == 8)
		{
		  vr1.rr = R_ADDR1;
		  vr2.r  = GAP;
		  vm.i   = fc->floatbin.irep[ 1 ];

		  show_instruction( J_MOVK, vr1, vr2, vm );
		}
	    }

	  if (rpt > 1)
	    l = loopstart( rpt );
	  else
	    l = NULL;

	  if (val != 0)
	    {
	      vr1.rr = R_DS;
	      vr2.rr = R_ATMP;
	      vm.i   = 0;

	      show_instruction( J_STRK, vr1, vr2, vm );

	      if (len == 8)
		{
		  vr1.rr = R_ADDR1;
		  vr2.rr = R_ATMP;
		  vm.i   = 4;
		  
		  show_instruction( J_STRK, vr1, vr2, vm );
		}
	    }

	  vr1.rr = vr2.rr = R_ATMP;
	  vm.i   = len;

	  show_instruction( J_ADDK, vr1, vr2, vm );

	  if (rpt > 1)
	    loopend( l );

	  dataslot += rpt * len;

	  break;

	case LIT_ADCON:              /* (possibly external) name + offset */

	  vr1.rr = R_ADDR1;
	  vr2.i  = val;
	  vm.sym = sv;

	  show_instruction( J_ADCON, vr1, vr2, vm );

	  if (rpt > 1)
	    l = loopstart( rpt );
	  else
	    l = NULL;

	  vr1.rr = R_ADDR1;
	  vr2.rr = R_ATMP;
	  vm.i   = 0;
	  
	  show_instruction( J_STRK, vr1, vr2, vm );
	  
	  vr1.rr = R_ATMP;
	  vm.i   = len;
	  
	  show_instruction( J_ADDK, vr1, vr2, vm );
	  
	  if (rpt > 1)
	    loopend( l );

	  dataslot += rpt * len;
	  break;
        }
    }

  if (curdsymb)
    output_symbol( curdsymb->extsym, curdsize );

  show_init_return();

/*}}}*/
#endif /* not TARGET_IS_C40 */
  
  return;

} /* dumpdata */

/*}}}*/
/*{{{  align */

static void
align( void )
{
  int32		x = (int32)(sizeof_int - (codesize & (sizeof_int - 1)));
  

  /* Number of "bytes" to get to next multiple of word */

  if (x != sizeof_int) 
   {
     objbyte( OBJBSS );
     
     objnum( x );
     
     codesize += x;
   }

  return;
  
} /* align */

/*}}}*/
/*{{{  obj_symref */

int32
obj_symref(
	   Symstr *	s,
	   int 		flags,
	   int32 	loc )
{
  ExtRef *		x;


  if ((x = symext_( s )) == NULL)     /* if not already defined */
    {
      x = (ExtRef *)GlobAlloc( SU_Other, sizeof (ExtRef) );

      x->extcdr       = NULL;
      x->extsym       = s,
      x->extindex     = obj_symcount++,
      x->extflags     = 0,
      x->extoffset    = 0;
      
      *obj_symlistend = symext_( s ) = x;
      obj_symlistend  = &x->extcdr;
    }

  /*
   * It is critical that for Helios when I define a symbol the stub that
   * had (maybe) been set up for it gets deleted.  The syserr here can
   * be made recoverable with -zqz
   */

  if (is_defined_( flags ) &&
      is_defined( x ))
    {
      /*
       * XXX - NC - made into a serious error becuase can happen if a programmer
       * created two functions with the same name.  This is reported by the
       * compiler, and should not really generate a fatal error.
       */
	 
      cc_err( syserr_heliobj_2def, s );

      x->extflags &= ~xr_definition;
    }

  /* The next two lines cope with further ramifications of the abolition of */
  /* xr_refcode/refdata in favour of xr_code/data without xr_defloc/defext  */
  /* qualification.  This reduces the number of bits, but needs more        */
  /* checking in that a symbol defined as data, and then called via         */
  /* casting to a code pointer may acquire defloc+data and then get         */
  /* xr_code or'ed in.  Suffice it to say this causes confusion.            */
  /* AM wonders if gen.c ought to be more careful instead.                  */

  if (is_defined_( flags ))
    x->extflags &= ~(xr_code | xr_data);
  
  if (is_defined( x ))
    flags &= ~(xr_code | xr_data);
  
  /* end of fix.                                                             */
  
  x->extflags |= flags;
  
  if (is_defined_( flags ))
    {
      x->extoffset = loc;

      if (is_code( x ))          /* @@@@@@ flags ...? */
	{
	  /* the setting of xr_defloc/defext marks sym as implicitly     */
	  /* deleted from stublist.                                      */

#if defined TARGET_USES_NEW_STUBS
 	  objlabel( new_stubs ? '.' : '#', symname_( s ) );
#else
 	  objlabel( '.', symname_( s ) );
#endif
	}
    }
  else if ((loc > 0) && !is_code_( flags ) && !is_defined( x ))
    {
      /* common data, not already defined */
      
      x->extoffset = loc;
    }

  /* The next line returns the offset of a function in the codesegment */
  /* if it has been previously defined -- this saves store on the arm  */
  /* and allows short branches on other machines.  Otherwise it        */
  /* returns -1 for undefined objects or data objects.                 */

  return (is_defined( x ) && is_code( x ) ? x->extoffset : -1);

} /* obj_symref */

/*}}}*/
/*{{{  obj_init */

void
obj_init( void )
{
  obj_symcount      = 0;
  obj_symlist       = NULL;
  obj_symlistend    = &obj_symlist;
  dataxrefs         = NULL;
  codexrefs         = NULL;
  global_symbols    = NULL;
  stublist          = NULL;
  in_stubs          = NO;
#ifdef TARGET_USES_NEW_STUBS
  stub_symbols      = NULL;
  addr_stub_symbols = NULL;
#endif
  
  return;
  
} /* obj_init */

/*}}}*/
/*{{{  obj_header */

void
obj_header( void )
{
#ifdef TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_ANY ))
    db_init( sourcefile );
#endif
  
  if (!suppress_module)
    {
      char	sname[ 40 ];
      char *	ptr;      
      int 	len;


      if ((ptr = strrchr( sourcefile, '/' )) != NULL)	/* skip past path components in source name */
	++ptr;
      else
	ptr = sourcefile;
      
      len = strlen( ptr ) - 31;
      
      if (len < 0)
	len = 0;
      
      strcpy( sname, ptr + len );
      
      len = strlen( sname );

      objbyte( OBJMODULE );
      
      objnum( -1 );

      startcode( (int32)offsetof( Module, Name ) + len );
      
      objword( T_Module );

      codesizepos = ftell( objstream );
      
      objword( 0 );

      fputs( sname, objstream );

      objbyte( OBJBSS );
      
      objnum( 32L - len );

      objbyte( OBJWORD );
      
      objbyte( OBJMODNUM );

      startcode( offsetof( Module, Init ) - offsetof( Module, Version ) );

	{
	  int ver;

	  
	  /*
	   * The version number here is a bit dodgy, but I need a single number
	   * and this may be as good as any other that I can invent.
	   */

	  sscanf( MIP_VERSION, "%d", &ver );
	  
	  objword( (int32)ver );
	}
      
      datasizepos = ftell( objstream );
      
      objword( 0 );

      objbyte( OBJINIT );
      
      codesize = sizeof (Module);

      if (split_module_table)
	{
	  startcode( 4 );
	
	  maxcodeppos = ftell( objstream );
	
	  objword( 0 );	  
	}
    }

  return;
  
} /* obj_header */

/*}}}*/
/*{{{  obj_makestubs */

void
obj_makestubs( void )          /* maybe this fn is part of flowgraf.c? */
{
  argument_bindlist = NULL;
  
  if (!suppress_module)
    {
      procflags = 0;          /* certainly these are owned elsewhere  */
      regmask   = 0;          /* I think the solution is connected to */
                              /* the fact that obj_symref is NOT      */      
      show_stubs();
      
      /* AM: I now think that for each helios extern symbol we should have  */
      /* two Symstr's.  (Either with the same name by avoiding hashing or   */
      /* by prefixing the real extern with '.' or such like, which asm and  */
      /* obj then remove to make the world sweet.)                          */
      /* This forgeing at the JOPCODE level seems a bit fraught.            */
    }

  if (suppress_module != 1)
    {
      padstatic( 4 );       /* @@@@@@ flush vg_wbuff, beware call in cg.c  */
                            /* @@@@@@ rationalise soon.                    */
      dumpdata();

#ifdef TARGET_IS_C40
      asmf( ";       align 128\n" );
#endif
      asmf( "        init\n" );
      
      show_code( NULL );

      asm_lablist = NULL;
    }

  return;
  
} /* obj_makestubs */

/*}}}*/
/*{{{  obj_trailer */

void
obj_trailer( void )
{
#ifdef TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_ANY ))
    db_tidy();
#endif
  
  if (!suppress_module)
   {
     align();

     dumpglobals();

#ifdef TARGET_USES_NEW_STUBS
     if (new_stubs)
       dump_new_stubs();
#endif
     
     if (fseek( objstream, codesizepos, SEEK_SET ) == -1)
       {
	 cc_err( "Failed to seek to start of file to set code size, errno = %d", errno );

	 return;	 
       }

     objword( codesize );

     if (fseek( objstream, datasizepos, SEEK_SET ) == -1)
       {
	 cc_err( "Failed to seek to start of file to set data size, errno = %d", errno );

	 return;	 
       }     
     
     if (split_module_table)
       {
	 objword( datasize );

#ifdef TARGET_USES_NEW_STUBS
	 if (!new_stubs || usrdbg( DBG_ANY ))
#endif
	   {
	     if (fseek( objstream, maxcodeppos, SEEK_SET ) == -1)
	       {
		 cc_err( "Failed to seek to start of file to set max code size, errno = %d", errno );

		 return;
	       }

	     objword( maxcodep );
	   }	 
       }
     else
       {
	 objword( datasize + maxcodep );
       }
   }

  return;
  
} /* obj_trailer */

/*}}}*/

/*}}}*/

/* End of heliobj.c */

@


1.17
log
@updated with changes made to C40 350 version
@
text
@d5 1
a5 1
 * Copyright (C) Perihelion Software Ltd, 1988 - 1993
d1487 18
a1504 4
#if 0
	      show_entry( sym, xr_code | xr_defloc ); /* really a call to obj_symref */
#elif defined TARGET_USES_NEW_STUBS
	      objlabel( new_stubs ? '.' : '#', symname_( sym ) );
@


1.16
log
@fixed size of object images for non SMT targets
@
text
@d523 1
a523 1
      objbyte( OBJWORD );			/* patch by ... */
d536 1
a536 1
      objbyte( OBJWORD );			/* patch by ... */
a547 1
#endif
d549 4
d554 2
a555 1
	}      
d564 1
a564 1
      objbyte( OBJWORD );			/* patch by ... */
a575 1
#endif
d577 4
d582 1
d592 1
a592 1
      objbyte( OBJWORD );			/* patch by ... */
d603 1
a603 5
      /*
       * This occurs when we have a call to a function stub
       */
      
      objbyte( OBJWORD );			/* patch by ... */
a610 1
#endif
d612 4
d617 1
d621 1
a621 5
      /*
       * This occurs when we have a conditional call to a function stub
       */
      
      objbyte( OBJWORD );			/* patch by ... */
a628 1
#endif
d630 4
d635 1
d640 1
a640 1
      objbyte( OBJWORD );			/* patch by ... */
d652 2
a653 2
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE1 );		/* ... applying 'C40 specific DataModule1 patch to ... */
d662 2
a663 3
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE2 );		/* ... applying 'C40 specific DataModule2 patch to ... */
d677 2
a678 2
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE3 );		/* ... applying 'C40 specific DataModule3 patch to ... */
d684 2
a685 3
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE4 );		/* ... applying 'C40 specific DataModule4 patch to ... */
d691 2
a692 3
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE5 );		/* ... applying 'C40 specific DataModule5 patch to ... */
d698 1
a698 2
      
      objbyte( OBJWORD );			/* patch by ... */
d705 1
a705 1
	  objbyte( OBJCODESYMB );		/* ... the offset into the module of the function ... */
d710 1
a710 1
	  objbyte( OBJDATASYMB );		/* ... the offset into the module of the datum ... */
d712 1
a712 1
      objsymbol( '_', symname_( sym ) );	/* ... specified by symbol */
d717 1
a717 1
      objbyte( OBJWORD );			/* patch by ... */
d726 1
a726 1
	  objbyte( OBJCODESYMB );		/* ... the offset into the module of the function ... */
d731 1
a731 1
	  objbyte( OBJDATASYMB );		/* ... the offset into the module of the datum ... */
d733 1
a733 1
      objsymbol( '_', symname_( sym ) );	/* ... specified by symbol */
d738 1
a738 1
      objbyte( OBJWORD );			/* patch by ... */
d745 1
a745 1
	  objbyte( OBJCODESYMB );		/* ... the offset into the module of the function ... */
d749 1
a749 1
	  objbyte( OBJDATASYMB );		/* ... the offset into the module of the datum ... */
d751 1
a751 1
      objsymbol( '_', symname_( sym ) );	/* ... specified by symbol */      
d756 1
a756 1
      objbyte( OBJWORD );			/* patch by inserting ... */
d761 1
a761 1
      objbyte( OBJWORD );			/* patch by inserting ... */
d768 1
a768 1
      objbyte( OBJWORD );			/* patch by inserting ... */
d770 1
a770 1
      objsymbol( '_', symname_( sym ) );	/* ... the start of the function specified by symbol */
d1489 2
d3315 3
d3319 1
@


1.15
log
@removed declarion of external variable split_module_table
@
text
@a3436 4
      else
	{
	  codesize -= sizeof (int32);
	}      
@


1.14
log
@fixed generation of 68K patch directives
@
text
@a180 2
extern int	   	split_module_table;

@


1.13
log
@fixed call to flush_peepholer
@
text
@d209 29
d249 1
a249 1
    
d800 9
d1096 2
a1097 2
  static bool	inited  = FALSE;
  static long	big_end = FALSE;
d1112 5
a1116 1
	  big_end = TRUE;
d1118 8
d1160 1
a1160 1
      if (big_end)
d1167 4
a1170 4
	  xcode  =  (int32)buff[ i++ ] << 24;
	  xcode |= ((int32)buff[ i++ ] << 16) & 0x00ff0000;
	  xcode |= ((int32)buff[ i++ ] << 8)  & 0x0000ff00;
	  xcode |= ((int32)buff[ i++ ])       & 0x000000ff;
d1174 4
a1177 1
	  /* little endian host */
a1178 3
	  for (i = b; i < (b + n); i++)
	    objbyte( buff[ i ] );

d1236 1
a1236 1
	      fprintf( stderr, "heliobj: unknown cross refernce type %lx\n", xrtype );
d1304 1
a1304 1
  
@


1.12
log
@fixed bug introduced by previous delta
@
text
@d2623 1
a2623 1
	      flush_peepholer( "generating asm label" );
@


1.11
log
@added processing of X_PCreloc2 for C40s
@
text
@d1200 1
@


1.10
log
@removed argument_bindlist at start of operations, because its binders are out of date
@
text
@d1 2
d21 2
a22 1
/*{{{  Header Files */
d53 1
d59 1
a59 1
/*{{{  Macros       */
d88 1
a88 1
/*{{{  Constants    */
d162 1
a162 1
/*{{{  Types        */
d179 1
a179 1
/*{{{  Variables    */
d207 1
a207 1
/*{{{  Functions    */
d209 1
a209 1
/*{{{ objbyte */
d228 1
a228 1
/*{{{ objword */
d277 1
a277 1
/*{{{ objnum */
d312 1
a312 1
/*{{{ objsymbol */
d330 1
a330 1
/*{{{ globalise */
d349 1
a349 1
/*{{{ dumpglobals */
d374 1
a374 1
/*{{{ request_addr_stub */
d397 1
a397 1
/*{{{ request_new_stub  */
d416 1
a416 1
/*{{{ dump_new_stubs */
d459 1
a459 1
/*{{{ objdirective */
d474 1
a474 1
/*{{{ C40 */
d508 1
a508 1
    case X_DataAddr:		/* see load_address_constant in c40/gen.c */
d522 1
a522 1
		  OBJLABELREF );	/* ... the offset of ... */
d532 1
a532 2
    case X_DataAddr1:		/* high part of previous patch, see c40/gen.c */
      
d546 1
a546 1
		  OBJLABELREF );	/* ... the offset of ... */
d556 1
a556 1
    case X_FuncAddr:		/* see load_address_constant in c40/gen.c */
d567 1
a567 1
    case X_PCreloc:		/* see call() in c40/gen.c */
d581 19
a599 1
	      OBJLABELREF );	/* ... the offset of ... */
d607 1
a607 1
	      PATCHC40MASK16ADD );/* ... adding into the bottom 8 or 16 bits of... */	
d763 1
a763 1
/*{{{ 68K */
d839 1
a839 1
/*{{{ ARM */
d957 1
a957 1
/*{{{ startcode */
d974 1
a974 1
/*{{{ startdata */
d997 1
a997 1
/*{{{ startcodetable */
d1021 1
a1021 1
/*{{{ objlabel */
d1045 1
a1045 1
/*{{{ obj_outcode */
d1222 1
a1222 1
/*{{{ obj_codewrite */
d1300 1
a1300 1
/*{{{ request_stub */
d1330 1
a1330 1
/*{{{ request_exception_stub */
d1363 1
a1363 1
/*{{{ show_stubs */
d1475 1
a1475 1
/*{{{ export_routines */
d1538 1
a1538 1
/*{{{ output_symbol */
d1563 1
a1563 1
/*{{{ loopstart */
d1594 1
a1594 1
/*{{{ loopend */
d1626 1
a1626 1
/*{{{ show_init_entry */
d1724 1
a1724 1
/*{{{ show_init_return */
d1755 1
a1755 1
/*{{{ IEEE convert */
d1765 1
a1765 1
/*{{{ IEEE_to_single_float */
d1839 1
a1839 1
/*{{{ IEEE_to_extended_float */
d1998 1
a1998 1
/*{{{ PHASED data generation */
d2002 1
a2002 1
/*{{{ Variables */
d2015 1
a2015 1
/*{{{ init_phase */
d2072 1
a2072 1
/*{{{ phase_export_block */
d2099 1
a2099 1
/*{{{ phase_skip_block */
d2130 1
a2130 1
/*{{{ phase_export_symbols */
d2227 1
a2227 1
/*{{{ phase_store */
d2303 1
a2303 1
/*{{{ phase_store_address_constant */
d2348 1
a2348 1
/*{{{ finish_phase */
d2400 1
a2400 1
/*{{{ insert_dlist */
d2458 1
a2458 1
/*{{{ export_functions */
d2491 1
a2491 1
/*{{{ dumpdata */
d2602 1
a2602 1
/*{{{ C40 data exporting */
d2867 1
a2867 1
/*{{{ others data exporting */
d3164 1
a3164 1
/*{{{ align */
d3188 1
a3188 1
/*{{{ obj_symref */
d3280 1
a3280 1
/*{{{ obj_init */
d3303 1
a3303 1
/*{{{ obj_header */
d3399 1
a3399 1
/*{{{ obj_makestubs */
d3441 1
a3441 1
/*{{{ obj_trailer */
@


1.9
log
@replaced syserr strings with constant strings
@
text
@d55 1
a55 1
/*{{{ Macros       */
d84 1
a84 1
/*{{{ Constants    */
d158 1
a158 1
/*{{{ Types        */
d175 1
a175 1
/*{{{ Variables    */
d203 1
a203 1
/*{{{ Functions    */
d3383 2
@


1.8
log
@hmm ....
@
text
@d1464 1
d1486 1
a1486 1

d2180 1
a2180 1
		  syserr( "heliobj: symbol %s has offset %ld and follows symbol %s with offset %ld",
d2504 2
a2505 4
    {
      return;
    }  
  
d2707 1
a2707 1
			syserr( "heliobj: cannot (yet) repeatedly export the same symbol" );
d2763 1
a2763 1
			  syserr( "heliobj: bad size of floating point number %ld", p->len );
d2770 1
a2770 1
		      syserr( "heliobj: unknown data type %lx", p->sort );
d2786 1
a2786 1
			syserr( "heliobj: cannot (yet) repeatedly export the same symbol" );
d2796 1
a2796 1
			syserr( "heliobj: bad length for packed data (%ld)", p->len );
d2825 1
a2825 1
			  syserr( "heliobj: bad size of floating point number %ld", p->len );
d2831 1
a2831 1
		      syserr( "heliobj: unknown data type %lx", p->sort );
d2849 2
a2850 4
    {
      export_routines();
    }

d2864 1
a2864 1

d2878 1
a2878 1
      
d3099 1
@


1.7
log
@minor tidies
@
text
@a3139 2
  cc_msg( "dumped data\n" );
  
@


1.6
log
@fixed detecting excessivly large offsets in cross references
@
text
@a1463 1

d1485 1
a1485 1
	  
d2503 4
a2506 2
    return;

d2850 4
a2853 2
    export_routines();
  
d2867 1
a2867 1
  
d2881 1
a2881 1

a3101 1

d3139 2
@


1.5
log
@fixed bug calculating maxcodep
@
text
@d19 1
a19 1
/*{{{ Header Files */
d1157 2
a1158 2
	      if (c->codexrcode > 0xffffff)
		cc_warn( heliobj_warn_24bits, (long)c->codexrcode );
@


1.4
log
@fixed so that stubs and global references are generated
@
text
@a58 9
#define is_defined( x )			 ((x)->extflags & xr_definition)
#define is_defined_( flags )		 ((flags)       & xr_definition)
#define is_code( x )			 ((x)->extflags & xr_code)
#define is_code_( flags )		 ((flags)       & xr_code)
#define is_data( x )			 ((x)->extflags & xr_data)
#define is_external_code( x )		(((x)->extflags & xr_external_code) == xr_external_code)
#define is_local( x )			 ((x)->extflags & xr_defloc)
#define is_global( x )			 ((x)->extflags & xr_defext)
#define is_bss( x )			 ((x)->extflags & xr_bss)
d60 15
d1465 1
a1465 1
  for (x = obj_symlist; x != NULL; x = x->extcdr)
d1471 1
a1471 1
	      globalise( x->extsym );
d1473 1
a1473 1
	      startcodetable( 4, symname_( x->extsym ) );
d1477 1
a1477 1
	  export_function( x->extsym, R_ATMP );
d1485 1
a1485 1
	  vm.sym = x->extsym;
a1694 3
#ifdef TARGET_IS_ARM
  load_static_data_ptr( R_ATMP );
#else
a1696 1
#endif
d2159 1
a2159 1
		  output_symbol( curdsymb->extsym, dataslot - old_dataslot );
d2164 1
a2164 1
	      for (; dsymb->extcdr && dsymb->extcdr->extoffset == dataoff; dsymb = dsymb->extcdr )
d2166 1
a2166 1
		  output_symbol( dsymb->extsym, 0 );
d2176 1
a2176 1
	      dsymb = dsymb->extcdr;
d2178 1
a2178 1
	      if (dsymb != NULL && dsymb->extoffset < dataoff)
d2181 2
a2182 2
			 symname_( dsymb->extsym ), dsymb->extoffset,
			 symname_( curdsymb->extsym ), curdsymb->extoffset );
d2351 1
a2351 1
	  output_symbol( curdsymb->extsym, dataslot - old_dataslot );
d2449 1
a2449 1
  for (x = obj_symlist; x != NULL; x = x->extcdr )
d2453 1
a2453 1
	  globalise( x->extsym );
d2460 1
a2460 1
	    startcodetable( 4, symname_( x->extsym ) );
d2581 2
d2843 2
d2846 2
a2847 1
  
a2859 3
#ifdef TARGET_IS_ARM
      load_static_data_ptr( R_ATMP );
#else
a2860 1
#endif
d2865 1
a2865 1
  for ( p = datainitp; p != NULL; p = p->datacdr)
d3134 2
a3135 1
  
a3458 1
	 if (
d3460 1
a3460 1
	     !new_stubs ||
a3461 1
	     usrdbg( DBG_ANY ))
@


1.3
log
@fixed minor compile time warnings
@
text
@d326 2
a327 2
    
    
d342 1
a342 1
 dumpglobals( void )
d346 1
a346 1
  
d350 1
a350 1
      
d1280 1
a1280 1
  
d1318 1
a1318 1
  
d1363 1
a1363 1
  
a1367 1

d1458 1
a1458 1
  
d2436 1
d2488 1
a2488 2
  ExtRef *	datasymbols = NULL;
  ExtRef *	dsymb       = datasymbols;
d2499 1
a2500 1

d2553 1
a2553 1
	  
d2860 2
d3187 1
a3187 1
  
@


1.2
log
@fixed for 400 servies ARM front end
@
text
@d182 1
d185 1
d244 1
a244 1
  val = ((x >> 24) & 0xff);
d248 1
a248 1
  val = ((x >> 16) & 0xff);
d252 1
a252 1
  val = ((x >> 8) & 0xff);
d256 1
a256 1
  val = (x & 0xff);
d1285 1
a1285 1
      if (((Symstr *)((int32)(s->stubsym) & ~(1 << 31))) == name)
d1322 1
a1322 1
    if (((Symstr *)((int32)(s->stubsym) & ~(1 << 31))) == name)
d1327 1
a1327 1
  stublist = (Stub *)global_cons2( SU_Other, stublist, ((int32) name | (1 << 31)) );
d1377 1
a1377 1
      if (((int32)sym & (1 << 31)) != 0)
d1379 1
a1379 1
	  sym = (Symstr *)((int32)sym & ~(1 << 31)) ; /* clear the flag bit */
d1972 1
a1972 1
#endif /* TARGET_IS_C40
d2437 1
a2437 1

d2465 1
d2928 1
a2928 1
	      int x = val;
d2942 1
a2942 1
	      int x = val;
d2955 1
a2955 1
	      int x = val;
d2968 1
a2968 1
	      int x = val;
@


1.1
log
@Initial revision
@
text
@a178 3
#if defined TARGET_IS_ARM
DataXref *		dataxrefs = NULL;
#endif
a1356 3
#ifdef TARGET_IS_ARM
      entry_fudge = YES;
#else
a1357 1
#endif
d1359 1
a1359 5
      show_instruction( J_ENTER, vr1, vr2, vm );
      
#ifdef TARGET_IS_ARM
      entry_fudge = NO;
#endif
a1377 6
	 
	  in_exceptional_stub = YES ;	/* special stub case */
	}
      else
	{
	  in_exceptional_stub = NO ;	/* normal stub */
a1650 4
#ifdef TARGET_IS_ARM
  entry_fudge = YES;
#endif

a1654 4
#ifdef TARGET_IS_ARM
   entry_fudge = NO;
#endif
  
d1688 3
d1693 1
d2851 3
d2855 1
a3267 4
  
#ifdef TARGET_IS_ARM
  in_exceptional_stub = NO ; /* JGS: 910213 */
#endif /* TARGET_IS_ARM */
@
