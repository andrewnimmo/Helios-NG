head	1.49;
access;
symbols
	beta_release:1.28;
locks; strict;
comment	@ * @;


1.49
date	94.03.29.11.25.17;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	94.03.28.16.19.38;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	93.08.04.17.06.09;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	93.08.04.16.32.21;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	93.07.29.13.22.05;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	93.07.09.10.50.56;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	93.07.07.09.53.41;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	93.02.22.11.13.09;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	93.01.18.11.27.37;	author paul;	state Exp;
branches;
next	1.40;

1.40
date	92.12.07.17.58.27;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	92.11.04.17.38.30;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	92.10.21.07.49.43;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	92.10.20.16.22.57;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	92.10.20.16.18.38;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	92.10.14.13.27.37;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	92.10.07.08.51.40;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	92.08.04.16.08.52;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	92.07.29.13.04.09;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	92.07.17.09.55.40;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	92.07.16.09.51.18;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	92.07.14.17.47.29;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	92.06.25.10.56.02;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	92.06.24.17.17.43;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	92.06.24.17.04.58;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	92.06.24.14.43.56;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	92.06.24.14.39.04;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	92.06.19.10.08.56;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	92.06.18.10.13.14;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	92.06.13.15.18.24;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	92.06.11.17.08.21;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	92.06.05.08.05.34;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	92.05.22.15.30.33;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	92.05.22.14.38.19;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	92.05.22.10.32.29;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	92.05.21.14.04.40;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	92.05.18.16.42.58;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	92.05.13.14.26.20;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	92.05.07.07.33.41;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	92.05.02.12.25.08;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	92.05.02.11.48.07;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	92.05.02.11.34.04;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	92.05.01.12.35.31;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	92.05.01.09.25.25;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	92.04.28.17.04.58;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	92.04.27.16.32.22;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	92.04.24.14.55.01;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	92.04.24.10.59.53;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	92.04.23.17.12.14;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	92.04.23.16.14.07;	author nickc;	state Exp;
branches;
next	;


desc
@Peepholer for the C40 C compiler
@


1.49
log
@fixed register aliasing problem
@
text
@/*
 * peep.c : 	Peepholer for the Norcroft/Perihelion C40 C Compiler
 *
 * Copyright (c) 1992, 1993 Perihelion Software Ltd.
 *
 * All rights reserved.
 *
 * Author :	N Clifton
 * Version :	$Revision: 1.48 $
 * Date :	$Date: 1994/03/28 16:19:38 $
 *
 */

#include "peep.h"	/* for function prototype conformation */
#include "mcdpriv.h"	/* for FALSE and function prototypes   */
#include "ops.h"	/* for OP codes  */
#include "globals.h"	/* for peepholing enabling */
#include "store.h"	/* for SU_Other  */
#include "codebuf.h"	/* for codebase  */
#include "mcdep.h"	/* for in_stubs  */
#include "errors.h"	/* for cc_warn() and syserr() */
#include "regalloc.h"	/* for regmaskvec */

/*
 * constants and macros
 */

#define PEEP_BUF_SIZE	(1 << 3)	/* NB/ must be power of 2 */

#define num_in_peep_()			(peep_end - peep_start + (peep_end < peep_start ? PEEP_BUF_SIZE : 0))
#define previous_( var )		(((var) - 1) & (PEEP_BUF_SIZE - 1))
#define successor_( var )		(((var) + 1) & (PEEP_BUF_SIZE - 1))


#define is_FP_reg_( reg )			 (((reg) >= R_FV1 && ((reg) <= R_FV1 + NFLTVARREGS)) || \
						  ((reg) >= R_FT1 && ((reg) <= R_FT1 + NFLTTEMPREGS)) )

/* types */

typedef struct Node
  {
    struct Node *	next;		/* points to next     node in list, NEVER NULL */
    struct Node *	prev;		/* points to previous node in list, NEVER NULL */
  }
Node;

typedef struct
  {
    Node *		head;		/* points to first node in list */
    Node *		earth;		/* always NULL                  */
    Node *		tail;		/* points to last node in list  */
  }
list;	/* name changed from List, because List is already used by compiler */

typedef struct addr_reg
  {
    Node		link;		/* links the structure into a list		 */
    RealRegister	addr_reg;	/* the address register controlled by this node  */
    RealRegister	contents;	/* the register held by the address register     */
    int32		offset;		/* the word offset added to the address register */
    bool		biased;		/* non-0 iff R_BASE has been added into the reg  */
    bool		noted;		/* non-0 iff front end has been told about use	 */
  }
addr_reg;

typedef struct
  {
    Node		link;		/* links the structure into a queue		*/
    RealRegister	reg;		/* The register that should be pushed		*/
    push_type		type;		/* The type of push to be performed		*/
  }
pending_push;

typedef struct peep_data
  {
    peep_type		type;		/* e.g. OUT_INSTR 			 	*/
    int32 		op_code;	/* 32 bits of machine instruction		*/
    int32 		reads;		/* registers accessed				*/
    int32 		writes;		/* registers clobbered				*/
    Symstr *		symbol;		/* external symbol       (if needed)		*/
    int32 		reftype;	/* symbol reference type (if needed)		*/
    LabelNumber *	label;		/* label                 (if needed)		*/
  }
peep_data;


/* local variables */

static addr_reg		ar0, ar1, ar2, ar3, ar5;	/* potentially available address registers	*/
static list		addr_regs;			/* list of available address registers		*/
static int		node_count = 0;			/* number of nodes in addr_registers		*/

static peep_data	peep_buf[ PEEP_BUF_SIZE ];	/* circular buffer of op codes			*/
static signed int	peep_start 	= 0;		/* next instruction to be emitted		*/
static signed int	peep_end   	= 0;		/* next free slot in table			*/
static bool		xref_pending    = FALSE;	/* TRUE if cross reference is pending		*/
static int32		pending_reftype = 0;		/* the cross reference type			*/
static Symstr *		pending_symbol  = NULL;		/* the cross reference's symbol			*/
static bool		fref_pending    = FALSE;	/* TRUE if forward ref is pending		*/
static LabelNumber *	pending_label   = NULL;		/* the forward reference's label		*/
static int		peep_pending_swaps = 0;		/* number of forward intrs to swap		*/

static list		pending_pushes;			/* queue of pushes pending emission		*/
static list		free_pending_pushes;		/* nodes released from pending push queue	*/

/* exported variables */

int32			peep_protect_pc	   = 0;		/* number of instructions to protect		*/
int32			peep_eliminated    = 0;		/* number of instructions eliminated		*/
int32			peep_transformed   = 0;		/* number of instructions transformed		*/
int32			peep_swapped       = 0;		/* number of instructions swapped		*/


/*
 * print a debugging message
 */

void
#ifdef __STDC__
debug( const char * format, ... )
#else
debug( format, va_alist )
  const char *	format;		/* printf (3) style format string  */
  va_dcl			/* argumnets for the format string */
#endif
{
  va_list	args;
	

  DBG( if (format == NULL) syserr( peep_null_format );)
  
#ifdef __STDC__
  va_start( args, format );
#else
  va_start( args );
#endif

  vfprintf( stderr, (char *)format, args );

  putc( '\n', stderr );
  
  va_end( args );

  return;
  
} /* debug */


/*
 * print a message about peepholing
 */

void
#ifdef __STDC__
peepf( const char * format, ... )
#else
peepf( format, va_alist )
  const char *	format;		/* printf (3) style format string  */
  va_dcl			/* argumnets for the format string */
#endif
{
  va_list	args;
	

  DBG( if (format == NULL) syserr( peep_null_format ); )
    
  if (!annotations)
    return;
  
#ifdef __STDC__
  va_start( args, format );
#else
  va_start( args );
#endif

  asmf( "; peepholer: " );
  
  vfprintf( asmstream, (char *)format, args );

  putc( '\n', asmstream );
  
  va_end( args );

  return;
  
} /* peepf */


/*
 * local functions
 */

/*
 * initialise a list (to empty)
 */

static void
init_list( list * plist )
{
  DBG( if (plist == NULL) syserr( peep_null_list ); )
  
  plist->head  = (Node *)&plist->earth;
  plist->earth = NULL;
  plist->tail  = (Node *)&plist->head;

  return;

} /* init_list */

/*
 * add a node onto the front of a list
 */

static void
add_head(
	 list *		plist,	/* list onto which to add node	*/
	 Node *		pnode )	/* node to add to list		*/
{
  DBG( if (plist == NULL || pnode == NULL) syserr( peep_null_parameter ); )
  
  pnode->next       = (Node *)plist->head;
  pnode->prev       = (Node *)plist;
  plist->head->prev = pnode;
  plist->head       = pnode;
  
  return;

} /* add_head */


/*
 * adds a node onto the back of a list
 */

static void
add_tail(
	 list *	plist,	/* list onto which to add node	*/
	 Node *	pnode )	/* node to add onto list	*/
{
  DBG( if (plist == NULL || pnode == NULL) syserr( peep_null_parameter ); )
  
  pnode->next       = (Node *)&plist->earth;
  pnode->prev       = plist->tail;
  plist->tail->next = pnode;
  plist->tail       = pnode; 

  return;

} /* add_tail */


/*
 * removes the first node from a list,
 * and returns a pointer to the removed node
 */

static Node *
remove_head( list * plist )
{
  Node *	pnode;
  

  DBG( if (plist == NULL) syserr( peep_null_list ); )

  pnode = plist->head;
  
  if (pnode->next == NULL)
    {
      /* This is not an error - it used by the push peepholing */
      
      return NULL;
    }
  
  pnode->next->prev = (Node *)plist;
  plist->head       = pnode->next;
  pnode->next       = NULL;
  pnode->prev       = NULL;
	
  return pnode;

} /* remove_head */


/*
 * removes the last node from a list, and returns it
 */

static Node *
remove_tail( list * plist )
{
  Node *	pnode;
  

  DBG( if (plist == NULL) syserr( peep_null_list ); )
  
  pnode = plist->tail;

  if (pnode->prev == NULL)
    {
      /* this is not an error - it is used by the push peepholing */

      return NULL;      
    }
  
  pnode->prev->next = (Node *)(&plist->earth);
  plist->tail       = pnode->prev;
  pnode->next       = NULL;
  pnode->prev       = NULL;
  
  return pnode;

} /* remove_tail */

/*
 * removes a node from a list
 */

#if DEBUG
static void
remove_node( Node * pnode )
{
  if (pnode == NULL)
    {
      syserr( peep_null_parameter );
    }
  
  pnode->prev->next = pnode->next;
  pnode->next->prev = pnode->prev;
  
  return;

} /* remove_node */
#else
#define remove_node( n ) ((n)->prev->next = (n)->next, (n)->next->prev = (n)->prev)
#endif /* not DEBUG */

/*
 * returns the first node in a list or NULL
 */

#if DEBUG
static Node *
first_node( list * plist )
{
  if (plist             == NULL ||
      plist->head       == NULL ||
      plist->head->next == NULL  )
    {
      syserr( peep_null_parameter );
    }

  return plist->head;
	
} /* first_node */
#else
#define first_node( l ) ((l)->head)
#endif
 
/*
 * returns the last node in a list or NULL
 */

#if DEBUG
static Node *
last_node( list * plist )
{
  if (plist             == NULL ||
      plist->tail       == NULL ||
      plist->tail->prev == NULL  )
    {
      syserr( peep_null_parameter );
    }
  
  return plist->tail;
	
} /* last_node */
#else
#define last_node( l ) ((l)->tail)
#endif
 

/*
 * returns the node following the given one
 */

#if DEBUG
static Node *
next_node( Node * pnode )
{
  if (pnode             == NULL ||
      pnode->next       == NULL ||
      pnode->next->next == NULL  )
    {
      syserr( peep_null_parameter );

      return NULL;
    }  
    
  return pnode->next;
	
} /* next_node */
#else
#define next_node( n ) ((n)->next)
#endif /* not DEBUG */


/*
 * returns the node prior to the given one
 */

#if DEBUG
static Node *
previous_node( Node * pnode )
{
  if (pnode             == NULL ||
      pnode->prev       == NULL ||
      pnode->prev->prev == NULL  )
    {
      syserr( peep_null_parameter );

      return NULL;
    }
  
  return pnode->prev;
	
} /* previous_node */
#else
#define previous_node( n ) ((n)->prev)
#endif /* not DEBUG */


/*
 * traverses a list applying a function to each node in turn
 */

static void
walk_list(
	  list *	plist,		/* list to scan				*/
	  void (* 	pfunc)() )	/* function to apply to each node	*/
{
  Node *	pnode;
  Node *	pnext;


  DBG( if (plist == NULL || pfunc == NULL) syserr( peep_null_parameter ); )
  
  for (pnode = plist->head; pnode->next != NULL; pnode = pnext)
    {
      pnext = pnode->next;
      
      (*pfunc)( pnode );
    }
    
  return;

} /* walk_list */


/*
 * searches a list applying a given function to each node in turn
 * until one node returns a non-0 result.  Returns this node, or
 * NULL if no node was found.
 */

static Node *
search_list(
	    list *	plist,			/* list to search			*/
	    bool (*	pfunc)( Node *, int ),	/* function to apply to each node 	*/
	    int 	arg )			/* (optional) argument to function	*/
{
  Node *	pnode;
   

  DBG( if (plist == NULL || pfunc == NULL) syserr( peep_null_parameter ); )
  
  for (pnode = plist->head; pnode->next != NULL; pnode = pnode->next)
    {
      if ((*pfunc)( pnode, arg ))
	return pnode;
    }
  
  return NULL;

} /* search_list */


/* ---------------------- ADDRESS REGISTER PEEPHOLING ---------------------------------- */

/*
 * returns true if the given node matches the given register
 */

static bool
register_p(
	   Node *	pnode,
	   int		reg )
{
  DBG( if (pnode == NULL) syserr( peep_null_parameter ); )
  
  return ((addr_reg *)pnode)->addr_reg == (RealRegister)reg;
  
} /* register_p */


/*
 * returns true if the given node holds the given register
 */

static bool
contents_p(
	   Node *	pnode,
	   int		reg )
{
  DBG( if (pnode == NULL) syserr( peep_null_parameter ); )
  
  return ((addr_reg *)pnode)->contents == (RealRegister)reg;

} /* contents_p */


/*
 * forget about the contents of the given address register
 */

static void
forget( addr_reg * preg )
{
  DBG( if (preg == NULL) syserr( peep_null_parameter ); )
  
  preg->contents = GAP;
  preg->offset   = 0;
  preg->biased   = FALSE;

  return;

} /* forget */


/*
 * prepares a node for use in a function
 */

static void
init_reg( addr_reg * preg )
{
  DBG( if (preg == NULL) syserr( peep_null_parameter ); )
    
  /* contents of register are unknown */
  
  forget( preg );

  /* add to list of available registers */
  
  add_tail( &addr_regs, (Node *)preg );

  /* keep track of number of nodes available */
  
  ++node_count;

  /* front end has not been told about our use of this register */
  
  preg->noted = FALSE;

 return;
  
} /* init_reg */


/*
 * The value in the indicated reg has changed by the
 * given amount.  Update any records based upon the
 * contents of that register
 */

void
peep_change_addr_offset(
			RealRegister	reg,		/* register (probably R_SP) which has changed */
			int32		increment )	/* change to previous offset in words */
{
   Node *	pnode;


  if ((pnode = search_list( &addr_regs, contents_p, (int)reg )) != NULL)
    {
      addr_reg *	preg = (addr_reg *)pnode;


      /*
       * subtract increment because new register value is that much
       * closer to our cached value that the old register value
       */
      
      preg->offset -= increment;
    }

  return;
  
} /* peep_change_addr_offset */


/*
 * prevent any address registers from remembering that it
 * contains the contents of the given register adjusted for 
 * machine accessing.
 */

void
peep_forget_about( RealRegister reg )
{
   Node *	pnode;


  while ((pnode = search_list( &addr_regs, contents_p, (int)reg )) != NULL)
    {
      forget( (addr_reg *)pnode );
      
      if (node_count > 1)
	{
	  /* move the node to the end of the list, so that it will be used again soon */
	  
	  remove_node( pnode );

	  add_tail( &addr_regs, pnode );
	}
    }

  return;
  
} /* peep_forget_about */


/*
 * locate the structure for the given address register, and clear it
 */

void
peep_corrupt_addr_reg( RealRegister reg )
{
  Node *	pnode;


  /* locate the register mentioned */
   
  if ((pnode = search_list( &addr_regs, register_p, (int)reg )) != NULL)
    {
      /* forget about the contents of the register */
      
      forget( (addr_reg *)pnode );

      if (node_count > 1)
	{
	  /* move the node to the end of the list, so that it will be used again soon */
	  
	  remove_node( pnode );

	  add_tail( &addr_regs, pnode );
	}
    }

  return;
  
} /* peep_corrupt_addr_reg */


/*
 * indicate that all of the address registers (may) have been corrupted
 */

void
peep_corrupt_all_addr_regs( void )
{
  walk_list( &addr_regs, forget );

  return;
  
} /* peep_corrupt_all_addr_regs */
  

/*
 * inform the peepholer that the given address register
 * has been loaded with the word offset equivalent of
 * the contents of the given register, offset by the
 * given amount (in words), and possibly biased by the
 * contents of the base addressing register
 */

void
peep_note_addr_reg_loaded(
			  RealRegister	reg,		/* address register that has been loaded 	*/
			  RealRegister	contents,	/* register whoes contents have been loaded	*/
			  int32		offset,		/* word offset applied to the 'contents'	*/
			  bool		biased )	/* non-zero if 'contents' has had R_BASE added	*/
{
  Node *	pnode;


  if ((pnode = search_list( &addr_regs, register_p, (int)reg )) != NULL)
    {
      ((addr_reg *)pnode)->contents = contents;
      ((addr_reg *)pnode)->offset   = offset;
      ((addr_reg *)pnode)->biased   = biased;

      if (node_count > 1)
	{
	  /* the node has been used, so put it at the head of the list */

	  remove_node( pnode );
	  
	  add_head( &addr_regs, pnode );
	}
    }

  /* it is not an error for no match to be found */
  
  return;
    
} /* peep_note_addr_reg_loaded */


/*
 * determines if the indicated register in loaded into an
 * address register, and returns the relevant register if
 * it has been found, as well as setting up the return
 * values for the offset and bias.  Returns GAP (and does
 * not set offset and bias) if no register could be found.
 */

RealRegister
peep_find_loaded_addr_reg(
			  RealRegister	contents,		/* register whoes contents are sought	*/
			  int32 *	offset_return,		/* return value for offset included	*/
			  bool *	biased_return )		/* return value indicating bias status	*/
{
   Node *	pnode;


  if ((pnode = search_list( &addr_regs, contents_p, (int)contents )) != NULL)
    {
      if (offset_return != NULL)
	*offset_return = ((addr_reg *)pnode)->offset;

      if (biased_return != NULL)
	*biased_return = ((addr_reg *)pnode)->biased;

      return ((addr_reg *)pnode)->addr_reg;
    }

  return GAP;
  
  
} /* peep_find_loaded_addr_reg */
  

/*
 * returns the least recently used address
 * register that is not 'excludes'.  Returns
 * GAP upon failure
 */

RealRegister
peep_get_free_addr_reg( RealRegister exclude )
{
  Node *	pnode;
  addr_reg *	reg;
  

  if (node_count > 1)
    {
      if (exclude == GAP)
	{
	  /* remove the last node from the list */
	  
	  pnode = remove_tail( &addr_regs );

	  DBG( if (pnode == NULL) syserr( peep_urg ); )
	  
	  reg = (addr_reg *)pnode;
	}
      else
	{
	  /* examine last node on list */
	  
	  pnode = last_node( &addr_regs );

	  DBG( if (pnode == NULL) syserr( peep_urg ); )

	  reg = (addr_reg *)pnode;
	  
	  if (reg->addr_reg == exclude)
	    {
	      pnode = previous_node( pnode );

	      DBG( if (pnode == NULL) syserr( peep_urg ); )

	      remove_node( pnode );

	      reg = (addr_reg *)pnode;
	    }
	  else
	    {
	      pnode = remove_tail( &addr_regs );
	      
	      DBG( if (pnode == NULL) syserr( peep_urg ); )
	    }
	}

      /* place removed node at start of list */
      
      add_head( &addr_regs, pnode );
    }
  else
    {
      pnode = first_node( &addr_regs );

      DBG( if (pnode == NULL) syserr( peep_urg ); )
      
      reg = (addr_reg *)pnode;
      
      if (reg->addr_reg == exclude)
	{
	  return GAP;
	}
    }

  /* invalidate contents of address register */
  
  reg->contents = GAP;

  if (!reg->noted)
    {
      augment_RealRegSet( &regmaskvec, reg->addr_reg );

      reg->noted = TRUE;
    }

  return reg->addr_reg;
    
} /* peep_get_free_addr_reg */

  
/*
 * initialise the queue of available address registers
 */

void
peep_init_addr_regs( int32 reg_mask )
{
  static bool	inited = FALSE;

  
  if (!inited)
    {
      /* initialise the address register structures */

      ar0.addr_reg = RR_AR0;
      ar1.addr_reg = RR_AR1;
      ar2.addr_reg = RR_AR2;
      ar3.addr_reg = RR_AR3;
      ar5.addr_reg = R_ATMP;

      inited = TRUE;
    }

  /* empty the register list */
  
  init_list( &addr_regs );

  node_count = 0;
  
  /* register AR5 is always available */

  init_reg( &ar5 );
  
  ar5.noted = TRUE;	/* never tell front end about our use of this register */
  
  if (no_peepholing)
    return;
  
  /* check the other address registers */
  
  if (!(reg_mask & regbit( RR_AR0 )))
    {
      init_reg ( &ar0 );
    }
  
  if (!(reg_mask & regbit( RR_AR1 )))
    {
      init_reg( &ar1 );
    }
  
  if (!(reg_mask & regbit( RR_AR2 )))
    {
      init_reg( &ar2 );
    }
  
  if (!(reg_mask & regbit( RR_AR3 )))
    {
      init_reg( &ar3 );
    }

  return;
  
} /* peep_init_addr_regs */


/* ------------------------------ PUSH PEEPHOLING ----------------------------- */

/*
 * returns TRUE if 'pnode' is a pending push of register 'reg'
 */
   
static bool
push_reg_p(
	   Node *	pnode,
	   int		reg )
{
  return ((pending_push *)pnode)->reg == reg;
 
} /* push_reg_p */


/*
 * emits a pending push, and removes the push from the push queue
 */

static void
flush_push( Node * pnode )
{
  pending_push *	push = (pending_push *)pnode;
  RealRegister		reg  = push->reg;
  

  /* remove from the list */
  
  remove_node( pnode );

  /* place node in free pool */

  add_tail( &free_pending_pushes, pnode );
  
  /* ignore already emitted pushes */
      
  if (reg == GAP)
    return;
  
  /* push the register */

  /* debug( "flush push of reg %d", reg ); */
  
  switch (push->type)
    {
    case PUSH_INT:	ipush( reg ); break;
    case PUSH_FLOAT:	fpush( reg ); break;
    case PUSH_DOUBLE:	dpush( reg ); break;
    default:
      syserr( peep_unknown_push );
      break;
    }

  return;
  
} /* flush_push */

  
/*
 * add an entry in the pending pushes array
 * The entry is added to the TAIL of the array
 */

void
add_pending_push(
		 RealRegister	reg,	/* the register to be pushed 		*/
		 push_type	type )	/* the kind of push being performed	*/
{
  pending_push *	push;

  
  /* check that there is room */

  peepf( "adding push of reg %ld (type %d)", reg, type );

  push = (pending_push *)remove_head( &free_pending_pushes );

  if (push == NULL)
    {
      push = (pending_push *)GlobAlloc( SU_Other, sizeof (pending_push) );
  
      if (push == NULL)
	{
	  syserr( peep_out_of_memory );
	}
    }

  /* adjust the stack offset (BEFORE adding the pending push) */
  
  if (stack_move != 0)
    {
      correct_stack( FALSE );
    }
  
  /* add the push to the pending queue */

  push->reg  = reg;
  push->type = type;
  
  add_tail( &pending_pushes, (Node *)push );

  /* adjust the stack offset - XXX why ? */
  
  switch (type)
    {
    case PUSH_INT:	stack_offset += sizeof_int;    break;
    case PUSH_FLOAT:	stack_offset += sizeof_float;  break;
    case PUSH_DOUBLE:	stack_offset += sizeof_double; break;
    default:
      syserr( peep_unknown_push );
      break;
    }

  /* if we are not peepholing then emit this push immediately */
  
  if (no_peepholing)
    {
      flush_pending_pushes();
    }

  return;
  
} /* add_pending_push */


/*
 * removes a pending push into register 'reg'
 * returns number of registers poped
 */

int
pop_pending_push(
		 RealRegister	dest,			/* register into which stack value should be placed */
		 bool		can_pop_double )	/* non-zero if two words can be popped */
{
  pending_push *	push;
  RealRegister		src;
  push_type		type;
  

  /* get the last pending push */
  
  push = (pending_push *)remove_tail( &pending_pushes );
  
  if (push == NULL)
    {
      /* if there are no pushes pending then just pop */

      ipop( dest );

      stack_offset -= sizeof_int;

      /* debug( "pop into reg %d, (none stacked)", dest ); */
      
      return 1;
    }
  else
    {
      /* note that this node is now free */
      
      add_tail( &free_pending_pushes, (Node *)push );
    }

  src  = push->reg;
  type = push->type;
  
  /* adjust the stack offset */
  
  switch (type)
    {
    case PUSH_INT:	stack_offset -= sizeof_int;    break;
    case PUSH_FLOAT:	stack_offset -= sizeof_float;  break;
    case PUSH_DOUBLE:	stack_offset -= sizeof_double; break;
    default:
      syserr( peep_unknown_push );
      break;
    }

  /*
   * XXX - NC - 4/2/92
   *
   * Believe it or not, the compiler can ask us to
   * push a double and then pop "half" of it into
   * register!  try the following code ...
   *
   *  func( 1, 2.0, 3,0 );
   *
   * So we must catch the case where we want to pop
   * a double, but only a single word is required
   */
  
  if (type == PUSH_DOUBLE && can_pop_double == 0)
    {
      stack_offset += sizeof_float;

      type = PUSH_FLOAT;

      if (src != GAP)
	{
	  /*
	   * since we are about to push something onto the stack
	   * make sure that all other pending pushes have been
	   * performed
	   */
	  
	  flush_pending_pushes();
	  
	  /* make sure that "low" part of value is pushed onto stack */
      
	  ipush( src );
	}
    }

  if (dest == src)
    {
      /* push followed by pop into same register */

      peepf( "eliminated push/pop pair" );

      if (type == PUSH_DOUBLE)
	{
	  peep_eliminated += 4;
      
	  return 2;
	}
      else
	{
	  peep_eliminated += 2;
	  
	  return 1;
	}
    }
  else if (src == GAP)
    {
      /* we have already pushed the register - now pop it */

      /*
       * NB/ we never really pop floats and doubles -
       * this is only ever done when we want to put FP
       * values into INT registers
       */
      
      /* debug( "pop type %d into reg %d", type, dest ); */
      
      switch (type)
	{
	case PUSH_INT:	  ipop( dest ); return 1;
	case PUSH_FLOAT:  ipop( dest ); return 1;
	case PUSH_DOUBLE: ipop( dest ); ipop( dest + 1 ); return 2;	  
	}
    }
  else
    {
      /* push from one register, pop into another */
      
      /* debug( "reg transfer type %d from %d into reg %d", type, src, dest ); */
      
      switch (type)
	{
	case PUSH_INT:
	  maybe_flush_pending_push( dest );
	  
	  move_register( src, dest, FALSE, FALSE );
	      
	  peepf( "transformed integer push/pop pair" );

	  ++peep_transformed;
	  ++peep_eliminated;
	  
	  return 1;
	  
	case PUSH_FLOAT:
	  maybe_flush_pending_push( dest );
	      
	  if (is_FP_reg_( dest ))
	    {
	      move_register( src, dest, TRUE, FALSE );
	      
	      peepf( "transformed float push/pop pair" );

	      ++peep_transformed;
	      ++peep_eliminated;
	    }
	  else
	    {
	      if (stack_move < 0)
		correct_stack( FALSE );

	      /* push floating point value, but pop an integer */

	      fpush( src );

	      ipop( dest );
	    }	  

	  return 1;
	  
	case PUSH_DOUBLE:
	  /* we are about to corrupt dest, so make sure that we are not pushing it */
	  
	  maybe_flush_pending_push( dest );
	  maybe_flush_pending_push( dest + 1 );
	  
	  fpush( src );
	  ipop(  dest );				/* big endian doubles */
	  
	  move_register( src, dest + 1, FALSE, FALSE );	/* NB/ must transfer integer part as well */
	  
	  peepf( "transformed double push/pop pair" );
	  
	  ++peep_transformed;
	  ++peep_eliminated;
	  
	  return 2;
	}
    }

  return 0;
  
} /* pop_pending_push */


/*
 * flushes all pending pushes, (in order)
 */

void
flush_pending_pushes( void )
{
  walk_list( &pending_pushes, flush_push );
  
  return;
  
} /* flush_pending_pushes */


/*
 * flushes any pending pushes if they
 * push register 'reg'
 */

void
maybe_flush_pending_push( RealRegister reg )
{
  Node *	pnode;


  /* see if the register should be pushed */
  
  pnode = search_list( &pending_pushes, push_reg_p, (int)reg );

  /* if so then emit all the pending pushes up to and including the located one */
  
  if (pnode)
    {
      pending_push *	push;

      
      /* flush back to pnode */

      for (push  = (pending_push *)first_node( &pending_pushes );
	   push != NULL;
	   push  = (pending_push *)next_node( (Node *)push ))
	{
	  reg = push->reg;

	  /* ignore already emited pushes */
      
	  if (reg == GAP)
	    continue;

	  /* push the register */

	  /* debug( "flush push of reg %d because of clash", reg ); */
	  
	  switch (push->type)
	    {
	    case PUSH_INT:	ipush( reg ); break;
	    case PUSH_FLOAT:	fpush( reg ); break;
	    case PUSH_DOUBLE:	dpush( reg ); break;
	    default:
	      syserr( peep_unknown_push );
	      break;
	    }

	  peepf( "flushed push of reg %ld because of clash", reg );
  
	  /* mark this push as having been emitted */
	  
	  push->reg = GAP;

	  /* if we have reached the located node then stop */
	  
	  if (push == (pending_push *)pnode)
	    break;
	}
    }

  return;
  
} /* maybe_flush_pending_push */


/* ------------------------- INSTRUCTION PEEPHOLING ------------------------- */

/*
 * returns TRUE if the two instructions
 * can be swapped FALSE otherwise
 *
 * XXX - beware - we cannot ignore the ST register.
 */

static bool
can_swap(
	 int32	a,		/* first instruction 				*/
	 int32	b )		/* second instruction 				*/
{
  unsigned32	a_reads;
  unsigned32	b_reads;
  unsigned32	a_writes;
  unsigned32	b_writes;
  int32		a_op;
  int32		b_op;
  

  a_reads  = peep_buf[ a ].reads;
  b_reads  = peep_buf[ b ].reads;
  a_writes = peep_buf[ a ].writes;
  b_writes = peep_buf[ b ].writes;

  if ((a_reads  & b_writes) ||
      (b_reads  & a_writes) ||
      (a_writes & b_writes)  )
    {
      return FALSE;
    }

  a_op = peep_buf[ a ].op_code;
  b_op = peep_buf[ b ].op_code;

  if (is_normal( a_op ) 				    && /* a is diadic or triadic          */
      is_normal( b_op ) 				    && /* b is diadic or triadic          */
      is_mode( a_op, ADDR_MODE_INDIRECT ) 		    && /* a uses indirect addressing      */
      is_mode( b_op, ADDR_MODE_INDIRECT ) 		    && /* b uses indirect addressing      */
      indirect_addr_reg( a_op) == indirect_addr_reg( b_op )  ) /* share the same address register */
    {
      return FALSE;
    }
      
  return TRUE;
  
} /* can_swap */

/*
 * returns TRUE iff type is a delayed op type
 */

static bool
is_delayed( peep_type type )
{
  switch (type)
    {
    default:
      return FALSE;

    case OUT_DELAYED:
    case OUT_DELLABREF:
    case OUT_DELSYMREF:
    case OUT_DELSYMXREF:
      return TRUE;
    }
  
} /* is_delayed */


/*
 * try to eliminate a null operation by adjusting
 * the instructions already in the peephole buffer
 * returns TRUE if the instruction was eliminated,
 * FALSE otherwise
 */

static bool
eliminate_null_op( void )
{
  peep_type	type;
  signed int	delayed;
  int		count;
  int		nulls = 0;
      

  if (no_peepholing)    
    return FALSE;
  
  /* see if we have a delayed instruction somewhere in the previous three op-codes */

  delayed = peep_end;

  for (count = 0; count < 3; count++)
    {
      /* get previous instruction */
      
      delayed = previous_( delayed );

      /* have we reached the start of the peephole buffer ? */
      
      if (delayed == previous_( peep_start ))
	{
	  /* end of search */

	  count = 4;

	  break;
	}

      /* extract the type of this instruction */
      
      type = peep_buf[ delayed ].type;

      /* is it a noop ? */
      
      if (type == OUT_NULL)
	{
	  /* found a padding instruction */
	  
	  ++nulls;
	}
      else if (is_delayed( type ))
	{
	  /* found delayed instruction */

	  break;
	}
    }

  /* see if we found anything */
  
  if (count < 3 && delayed != peep_start)
    {
      signed int	prev;
      
      
      /* we have a delayed instruction and one other instruction */
      
      prev = previous_( delayed );
      
      if (can_swap( delayed, prev ))
	{
	  peep_data		tmp;
	  

	  tmp                 = peep_buf[ delayed ];
	  peep_buf[ delayed ] = peep_buf[ prev    ];
	  peep_buf[ prev    ] = tmp;
	  peep_buf[ delayed ].reads |= regbit( RR_PC );	  /* ensure that prev does not get swapped again */
	  
 	  peepf( "eliminated a NOP" );

	  ++peep_eliminated;
	  
	  return TRUE;
	}
/*    else peepf( "could not swap %08x and %08x (prev r = %x, w = %x)(delayed r = %x, w = %x)",
		   peep_buf[ prev ].op_code,  peep_buf[ delayed ].op_code,
		   peep_buf[ prev ].reads,    peep_buf[ prev ].writes,
		   peep_buf[ delayed ].reads, peep_buf[ delayed ].writes ); */
    }

  if (count == 2 && nulls == 2)
    {
      int32	op = peep_buf[ delayed ].op_code;
      int32	off;

      
      /*
       * We failed to swap the delayed instruction
       * but we might be able to convert the delayed insrtuction
       * and the three following NOPs into a non-delayed insrtuction.
       * This does not save code execution time, but it will save
       * code space.
       */
      
      if ((op >> 26) == B_011010)
	{
	  /* we have a conditional branch */
	  
	  /* removed delayed bit */
	  
	  op &= ~(1 << 21);
	  
	  if (op & (1 << 25))
	    {
	      /* branch is PC relative - increase offset by 2 */
	      
	      off = mask_and_sign_extend_word( op, 0xFFFF );

	      if (!off)
		syserr( peep_no_offset );
	      
	      off += 2;
	      
	      op = (op & 0xFFFF0000U) | (off & 0x0000FFFFU);
	    }
	  
	  peepf( "converted a delayed conditional branch into undelayed" );
	}
      else if ((op >> 25) == (B_0110000))
	{
	  /* we have an unconditional branch */
	  
	  /* removed delayed bit */
	  
	  op &= ~(1 << 24);
	      
	  /* branch is PC relative - increase offset by 2 */
	  
	  off = mask_and_sign_extend_word( op, 0x00FFFFFFU );

	  if (!off)
	    syserr( peep_no_offset );

	  off += 2;

	  op = (op & 0xFF000000U) | (off & 0x00FFFFFFU);

	  peepf( "converted a delayed unconditional branch into undelayed" );
	}
      else
	{
	  return FALSE;
	}
#if 0
      /* change the type to reflect new status */
      
      switch (type)
	{
	case OUT_DELLABREF:
	  type = OUT_LABREF;
	  break;
	  
	case OUT_DELSYMREF:
	  type = OUT_SYMREF;

	  off = mask_and_sign_extend_word( op, 0x00ffffffU );
      
	  if (off != 0)
	    {
	      /* subtract codep from offset */
	  
	      op = (op & 0xff000000U) |
		((off - (codep / sizeof_int)) & 0x00ffffffU);
	    }

	  break;
	  
	case OUT_DELSYMXREF:
	  type = OUT_SYMXREF;
	  break;
	  
	case OUT_DELAYED:
	  type = OUT_INSTR;
	  break;
	  
	default:
	  syserr( peep_unknown_delay_type );
	  break;
	}
      peep_buf[ delayed ].type    = type;
#endif      
      peep_buf[ delayed ].op_code = op;
	  
      /* remove following three NOPs */
	  
      peep_end = successor_( delayed );

      peep_eliminated += 3;
      
      return TRUE;
    }
  
  return FALSE;
    
} /* eliminate_null_op */


/*
 * returns 1 if the op_code has the potential to be converted into
 * a parallel operation, returns 0 otherwise
 */

static int
is_potential_parallel_op(
			 int32 	op,
			 int32	potential_op,
			 int32	other_op )
{
  if (is_op(   op, potential_op )	&&	/* matches sought op			*/
      is_mode( op, ADDR_MODE_INDIRECT )	&&	/* uses indirect addressing		*/
      dest_of( op ) <= 7		&&	/* references registers R0 - R7		*/
      (op & 0xFF)   < 2			)	/* displacement is 0 or 1		*/
    {
      if (has_indirect_side_effects( op ))
	{
	  int32	reg = indirect_addr_reg( op );

	  
	  /* check to see if side effects might affect other instruction */
	  
	  if (dest_of( other_op )           == real_addr_reg( reg ) ||
	      indirect_addr_reg( other_op ) == reg                   )
	    {
	      return 0;
	    }
	}

      return 1;
    }

  return 0;
      
} /* is_potential_parallel_op */
  

#ifdef NOT_USED
/*
 * returns TRUE if the op code is a triadic
 * operation that might be turned into a parallel
 * operation.  Returns FALSE otherwise
 */

static bool 
is_suitable_triadic( int32 op )
{
  if (((op & (B_111   << 29)) == (B_001 << 29))	&&	/* currently triadic                   */
      ((op & (1       << 28)) == 0)		&&	/* uses type 1 addressing              */
      ((op & (B_11    << 21)) == (B_10  << 21))	&&	/* uses register / indirect addressing */
      dest_of( op ) <= 7			&&	/* dst  uses register R0 - R7		*/
      ((op & (B_11111 <<  8)) <= (7     <<  8))	 )	/* src1 uses register R0 - R7          */
    {
      return TRUE;
    }

  return FALSE;
  
} /* is_suitable_triadic */
#endif /* NOT_USED */
  
/*
 * try to combine the current instruction with the
 * previous instuction in the peephole buffer.
 * returns TRUE if successful, FALSE otherwise
 */

#define SWAP_OPS					\
  *pcurr_op                 = prev_op; 			\
  *preads                   = peep_buf[ prev ].reads;	\
  *pwrites                  = peep_buf[ prev ].writes;	\
   peep_buf[ prev ].op_code = prev_op = curr_op;	\
   peep_buf[ prev ].reads   = reads;			\
   peep_buf[ prev ].writes  = writes;			\
   curr_op                  = *pcurr_op;		\
   reads                    = *preads;			\
   writes                   = *pwrites;			\
   swapped                  = TRUE


static bool
combine_instrs(
	      int32 *	pcurr_op,
	      int32 *	preads,
	      int32 *	pwrites )
{
  signed int	prev;
  int32		prev_op;
  int32		curr_op = *pcurr_op;
  int32		reads   = *preads;
  int32		writes  = *pwrites;
  int		prev_store;
  int		prev_load;
  int		curr_store;
  int		curr_load;
  bool		swapped = FALSE;
  

  /* see if we can peephole */

  /*
   * note that we disable this kind of peepholing if we are
   * generating memory access checks, because several of our
   * assumptions are no longer valid.  For example the compiler
   * will cache seperate read and write pointers to data areas
   * and could try to store via one pointer and then load via
   * another pointer, in which case it is imperative that these
   * instructions are not combined.
   */
  
  if (no_peepholing || memory_access_checks)
    return FALSE;
  
  /* see if there are two instructions to compare */
  
  if (peep_end == peep_start)
    return FALSE;

  /* find the previous instruction */
  
  prev = previous_( peep_end );

  /* only peephole ordinary instructions */
  
  if (peep_buf[ prev ].type != OUT_INSTR)
    return FALSE;
  
  /* get the op code of the previous instruction */
  
  prev_op = peep_buf[ prev ].op_code;

  /* check to see if the two instructions are the same */

  if (prev_op == curr_op)
    {
      int32	type = (curr_op >> 29) & 0x7;


      /* see if they have any side effects */
      
      if (type == 0)
	{
	  if (!is_mode( curr_op, ADDR_MODE_INDIRECT ) ||  /* if it does not use indirect addressing       */
	      ((curr_op >> 13) & 1) == 0)		  /* or the indirect addressing does not auto inc */
	    {
	      switch (curr_op >> 23)
		{
		case OP_ADDI:
		  if (is_mode( curr_op, ADDR_MODE_IMMEDIATE ))
		    {
		      int32	val = mask_and_sign_extend_word( curr_op, 0xFFFF ) * 2;


		      if (fits_in_16_bits_signed( val ))
			{
			  peep_buf[ prev ].op_code = ((curr_op & 0xFFFF0000U) | (val & 0xFFFFU));

			  peepf( "combined multiple additions" );

			  ++peep_eliminated;
			  
			  return TRUE;
			}
		    }
		break;

		case OP_LDI:
		  peepf( "eliminated multiple identical LDIs" );
		  ++peep_eliminated;
		  return TRUE;
		  
		case OP_LDA:
		  peepf( "eliminated multiple identical LDAs" );
		  ++peep_eliminated;
		  return TRUE;

		case OP_LDF:
		  peepf( "eliminated multiple identical LDFs" );
		  ++peep_eliminated;
		  return TRUE;
		  
		case OP_AND:
		  /*
		   * eg:-   while ((c = *a) != '\0') *a++ = c + 1;
		   */
		  
		  peepf( "eliminated multiple identical ANDs" );
		  ++peep_eliminated;
		  return TRUE;
		  
		default:
		  peepf( "failed to combine multiple identical op codes (%lx)", curr_op );
		  break;
		}
	    }
	}
    }
  /*
   * check for an indirect post incr 
   * followed by an addition to same register
   * or a STIK indirect followed by an addition to the register
   *
   * eg turns:
   *	LDI	*AR6++(1), R0
   *	ADDI	1, AR6
   * into:
   *	LDI	*AR6++(2), R0
   */

  else if (
      (is_op( curr_op, OP_ADDI ))
      &&
      (
       (/*is_op( prev_op, OP_LDI  ) &&*/ is_mode( prev_op, ADDR_MODE_INDIRECT  ))
       ||
       (is_op( prev_op, OP_STIK ) && is_mode( prev_op, ADDR_MODE_IMMEDIATE ))
      )
      &&
      (is_mode( curr_op, ADDR_MODE_IMMEDIATE ))
     )
    {
      int32	dest;
      int32	amount;

      
      dest    = dest_of( curr_op );
      amount  = mask_and_sign_extend_word( curr_op, 0xffff );
      amount += prev_op & 0xff;
      
      if (
	  real_addr_reg( indirect_addr_reg( prev_op ) ) == dest && /* same register affected */
	  ((prev_op >> 11) & 0x1f) == INDIRECT_POST_INCR        && /* op was *ARx++() */
	  fits_in_8_bits_unsigned( amount )                     )  /* new addition total fits */
	{
	  peep_buf[ prev ].op_code = (prev_op & 0xffffff00U) | (amount & 0xffU);

	  peepf( "transformed indirect addition" );

	  ++peep_transformed;
	  
	  return TRUE;
	}
    }

  /*
   * There are several potential optimisations when the previous instruction
   * is a register based LDI, LDA or LDF and the current instruction is diadic
   */

  if (is_load(   prev_op )			&&	/* prev_op is one of LDI, LDA, LDF	*/
      is_mode(   prev_op, ADDR_MODE_REGISTER )	&&	/* it uses register addressing		*/
      is_diadic( curr_op )                  	)	/* current op is a diadic operation	*/
    {
      /* if they both have the same destination */

      if (dest_of( prev_op ) == dest_of( curr_op ))
	{
	  if (is_mode( curr_op, ADDR_MODE_REGISTER ))
	    {
	      unsigned long	op = OP_NOP;
		  
	      
	      /*
	       * check for loading a register
	       * followed by a register based monadic op with
	       * that register as both source and destination
	       *
	       * eg turns:
	       *	LDI	R0, R1
	       *	NEGI	R1, R1
	       * into:
	       *    	NEGI	R0, R1
	       */
	      
	      if (source_of( curr_op ) == dest_of( curr_op ) &&
		  is_monadic( curr_op ))
		{
		  /* avoid the case of LDF followed by LDI */
      
		  if (!is_op( prev_op, OP_LDF) || !is_op( curr_op, OP_LDI ))
		    {
		      peep_buf[ prev ].op_code = (curr_op & 0xff800000U) | (prev_op & 0x007fffffU);
	  
		      peepf( "merged load and diadic op into diadic op" );

		      ++peep_eliminated;
		      
		      return TRUE;
		    }
		}
		  
	      /*
	       * check for moving one register into another followed
	       * by a register based diadic op on that register
	       *
	       * eg turns:
	       *	LDI	R1, R0
	       *	ADDI	R2, R0
	       * into:
	       *	ADDI3	R1, R2, R0
	       *
	       * and:
	       * 	LDF	R5, R7
	       *	MPYF	R5, R7
	       * into:
	       * 	MPYF3	R5, R5, R7
	       */
	  
	      switch ((curr_op >> 23) & 0x3f)
		{
		case OP_ADDC:	  op = OP_ADDC3;	  break;
		case OP_ADDF:	  op = OP_ADDF3;	  break;
		case OP_ADDI:	  op = OP_ADDI3;	  break;
		case OP_AND:	  op = OP_AND3;		  break;
		case OP_ANDN:	  op = OP_ANDN3;	  break;
		case OP_ASH:	  op = OP_ASH3;		  break;
		case OP_LSH:	  op = OP_LSH3;		  break;
		case OP_MPYF:	  op = OP_MPYF3;	  break;
		case OP_MPYI:	  op = OP_MPYI3;	  break;
		case OP_OR:	  op = OP_OR3;		  break;
		case OP_SUBB:	  op = OP_SUBB3;	  break;
		case OP_SUBF:	  op = OP_SUBF3;	  break;
		case OP_SUBI:	  op = OP_SUBI3;	  break;
		case OP_XOR:	  op = OP_XOR3;		  break;
		default:
		  break;
		}      
	      
	      if (op != OP_NOP)
		{
		  peep_buf[ prev ].op_code = (B_0010 << 28) | op << 23 | 0x0U << 21 |
		    prev_op & 0x001f0000U | (prev_op & 0x1f) << 8 |
		      (source_of( curr_op ) == dest_of( prev_op ) ?
			source_of( prev_op ) :
			source_of( curr_op ) );
		  
		  peep_buf[ prev ].writes |= writes;
		  peep_buf[ prev ].reads  |= reads;
		  
		  peepf( "merged load and register op into triadic op" );

		  ++peep_eliminated;

		  return TRUE;
		}
	    }
	  else if (is_mode( curr_op, ADDR_MODE_IMMEDIATE ))
	    {
	      /*
	       * check for moving one register into another followed
	       * by an immediate diadic op on that register
	       *
	       * eg turns:
	       *	LDI	R1, R0
	       *	ADDI	1,  R0
	       * into:
	       *	ADDI3	1, R1, R0
	       */

	      unsigned long	op        = OP_NOP;
	      bool		is_signed = TRUE;
	      
	      
	      switch ((curr_op >> 23) & 0x3f)
		{
		case OP_ADDC:	  op = OP_ADDC3;	  		break;
		case OP_ADDI:	  op = OP_ADDI3;	  		break;
		case OP_AND:	  op = OP_AND3;	 is_signed = FALSE;	break;
		case OP_ANDN:	  op = OP_ANDN3; is_signed = FALSE;	break;
		case OP_ASH:	  op = OP_ASH3;  is_signed = FALSE;	break;
		case OP_LSH:	  op = OP_LSH3;  is_signed = FALSE;	break;
		case OP_MPYI:	  op = OP_MPYI3;	  		break;
		case OP_OR:	  op = OP_OR3;	 is_signed = FALSE;	break;
		case OP_SUBB:	  op = OP_SUBB3;	  		break;
		case OP_SUBI:	  op = OP_SUBI3;	  		break;
		case OP_XOR:	  op = OP_XOR3;	 is_signed = FALSE;	break;
		default:
		  break;
		}      
#ifndef TRIADIC_BINARY_OPS_ARE_UNSIGNED
	      is_signed = TRUE;
#endif
	      /* check that immediate value will fit in triadic operation */
	      
	      if (is_signed)
		{
		  if (!fits_in_8_bits_signed( mask_and_sign_extend_word( curr_op, 0xFFFF )))
		    op = OP_NOP;
		}
	      else
		{
		  if (curr_op & 0xFF00 != 0)
		    op = OP_NOP;
		}
	      
	      if (op != OP_NOP)
		{
		  peep_buf[ prev ].op_code = (B_0011 << 28) | op << 23 | 0x0U << 21 |
		    prev_op & 0x001f0000U | (prev_op & 0x1f) << 8 | (curr_op & 0xff);
		  
		  peep_buf[ prev ].writes |= writes;
		  peep_buf[ prev ].reads  |= reads;
		  
		  peepf( "merged load and immediate op into triadic op" );

		  ++peep_eliminated;
		  
		  return TRUE;
		}
	    }
	  else if (is_op( curr_op, OP_STI )		 &&	/* current op is a store	*/
		   is_mode( curr_op, ADDR_MODE_INDIRECT ) )	/* current op is NOT a STIK 	*/
	    {
	      /*
	       * transforms:
	       *    LDI	R3, R1
	       *    STI	R1, *--AR6(1)
	       * into:
	       *    STI R3, *--AR6(1)
	       *    LDI R3, R1
	       */

	      reads  &= ~regbit( real_register( dest_of(   curr_op ) ) );
	      reads  |=  regbit( real_register( source_of( prev_op ) ) );
	      
	      curr_op = (curr_op & 0xFFE0FFFFU) | ((prev_op << 16) & 0x001F0000U);
	      
	      SWAP_OPS;
	      
	      peepf( "transformed and swapped register store" );

	      ++peep_transformed;
	      ++peep_swapped;
	      
	      if (death & regbit( real_register( dest_of( curr_op ) ) ) )
		{
		  /*
		   * the load into the other register (R1 in the above example)
		   * was uncessary, and  so we can eliminate it!
		   */
		  
		  peepf( "eliminated load after swapped store" );

		  ++peep_eliminated;

		  return TRUE;
		}
	    }
	}
      
      if (is_load( prev_op )                          &&	/* make sure our knowledge of prev is OK     */
	  is_load( curr_op )                          &&	/* current operation is a load               */
	  ((curr_op >> 23) == (prev_op >> 23)	     ||		 /* both loads are the same kind    	     */
	   !(is_op( curr_op, OP_LDF )		     ||		 /* or neither of them is a 		     */
	     is_op( prev_op, OP_LDF ) ) )             &&	 /* load float				     */
	  is_mode( curr_op, ADDR_MODE_REGISTER )      &&	/* current operation is register based       */	
	  dest_of( prev_op ) == source_of( curr_op  )  )	/* previous op's dest is current op's source */
	{
	  if (dest_of( curr_op ) == source_of( prev_op ))	/* current  op's dest is prev    op's source */
	    {
	      /*
	       * check for two register to register loads
	       * with the source and destinations swapped
	       *
	       * eg turns:
	       * 	LDI	R0, R1
	       * 	LDI	R1, R0
	       * into:
	       * 	LDI	R0, R1
	       */
      
	      peepf( "eliminated unnecessary register load" );

	      ++peep_eliminated;

	      if (death & regbit( real_register( dest_of( prev_op ) ) ) )
		{
		  /*
		   * The destination of the previous load (R1 in the above example)
		   * is dead at the end of the load just eliminated.  Therefore
		   * we do not need to do the previous load either!  This can happend
		   * when we are eliminating multiple LDFs, eg:-
		   *
		   * double f1( void )
		   * { extern double f2( double );
		   *   return f2( 2.0 );
		   * }
		   */

		  peepf( "eliminated previous register load as well !" );

		  ++peep_eliminated;

		  peep_end = prev;
		}
	      
	      return TRUE;
	    }
	  else
	    {
	      /*
	       * check for two register to register loads
	       * with the source and destinations matches
	       *
	       * eg turns:
	       *	LDI	R0, R1
	       *	LDI	R1, R2
	       * into:
	       *   	LDI	R0, R2
	       *   	LDI	R0, R1		<-- note swap
	       *
	       * Why bother ?  Because it is very likly that
	       * I will be able to eliminate the second load
	       * later on
	       */

	      reads &= ~regbit( real_register( source_of( curr_op ) ) );
	      reads |=  regbit( real_register( source_of( prev_op ) ) );
	      
	      curr_op = (curr_op & 0xFFFF0000U) | source_of( prev_op );
	      
	      SWAP_OPS;
	      
	      peepf( "swapped and transformed register loads" );

	      ++peep_transformed;
	      ++peep_swapped;
	    }
	}

      if (!swapped					&&	/* if instructions are still OK	*/
	  is_mode( curr_op, ADDR_MODE_REGISTER )	&&	/* and both use reg addressing	*/
	  dest_of( prev_op ) == source_of( curr_op )	&&	/* destination is trasmitted    */
	  !is_op(  curr_op, OP_CMPI )			&&	/* do not swap instructions	*/
	  !is_op(  curr_op, OP_CMPF )			&&	/* that especially set the	*/
	  !is_op(  curr_op, OP_TSTB )			&&	/* status register		*/
	  !is_op(  curr_op, OP_LDF  )			&&	/* do not swap LDI/LDF		*/
	  !is_op(  curr_op, OP_RCPF )			&&	/* do not swap LDI/RCPF		*/
	  !is_op(  curr_op, OP_SUBF )			&&	/* do not swap LDI/SUBF		*/
	  !is_op(  curr_op, OP_SUBRF)			&&	/* do not swap LDI/SUBRF	*/
	  !is_op(  curr_op, OP_ADDF )			&&	/* do not swap LDI/ADDF		*/
	  !is_op(  curr_op, OP_MPYF )			&&	/* do not swap LDI/MPYF		*/
	  !is_op(  curr_op, OP_RND  )			&&	/* do not swap LDI/RND		*/
	  !is_op(  curr_op, OP_NEGF )			)	/* do not swap LDI/NEGF		*/
	{
	  /*
	   * transforms:
	   *    LDI	R3, R1
	   *    ADDI	R1, R2
	   * into:
	   *    ADDI	R3, R2
	   *    LDI	R3, R1
	   */

	  reads  &= ~regbit( real_register( source_of( curr_op ) ) );
	  reads  |=  regbit( real_register( source_of( prev_op ) ) );
	      
	  curr_op = (curr_op & 0xFFFF0000U) | (prev_op & 0x0000FFFFU);

	  if (dest_of( curr_op ) == source_of( prev_op ))
	    {
	      /*
	       * transform:
	       *   LDI  R3, R1
	       *   ADDI R1, R3
	       * into:
	       *   LDI  R3, R1
	       *   ADDI R3, R3
	       * but NO swapping
	       */
	       
	      peepf( "transformed register diadic" );
	    }
	  else
	    {
	      SWAP_OPS;
	      
	      peepf( "transformed and swapped register diadic" );

	      ++peep_swapped;
	    }

	  ++peep_transformed;
	}
    }
  
  /*
   * check for loading a register
   * followed by a triadic op which writes the same
   * register, and does not use the loaded register
   *
   * eg turns:
   *	LDI	R0, R1
   *	MPYI3	5,  R2, R1
   * into:
   *    MPYI3	5,  R2, R1
   *
   * and
   *	LDI	R0, R1
   *	MPYI3	5,  R1, R1
   * into:
   *	MPYI3	5,  R0, R1
   */
  
  if (is_load( prev_op )	 		&&	/* prev_op is one of LDI, LDA, LDF	*/
      is_mode(   prev_op, ADDR_MODE_REGISTER )	&&	/* prev_op uses register addressing	*/
      is_triadic( curr_op )                  	&&	/* current op is a triadic		*/
      dest_of(   prev_op ) == dest_of( curr_op ) )	/* they share the same destination	*/
    {
      bool	src1_is_prev 	= FALSE;
      bool	src2_is_prev 	= FALSE;
      bool	uses_prev	= FALSE;
      int32	T    		= (curr_op >> 21) & 3;
      int32	dest 		= dest_of( prev_op );
      int32	src1 		= (curr_op >> 8) & 0xFF;
      int32	src2 		= curr_op & 0xFF;
      

      /* check to see if triadic op uses dest of previous load */

      if ((curr_op >> 28) & 1)
	{
	  switch (T)
	    {
	    case B_00:
	      if (src1 == dest)
		src1_is_prev = TRUE;
	      break;
	      
	    case B_01:
	      if (src1 == dest)
		src1_is_prev = TRUE;

	      if (real_addr_reg( src2 & 0x7 ) == dest)
		uses_prev = TRUE;
	      break;
	      
	    case B_10:
	      if (real_addr_reg( src1 & 0x7 ) == dest)
		uses_prev = TRUE;
	      break;
	      
	    case B_11:
	      if ((real_addr_reg( src1 & 0x7 ) == dest) ||
		  (real_addr_reg( src2 & 0x7 ) == dest)  )
		uses_prev = TRUE;
	      break;
	    }
	}
      else
	{
	  switch (T)
	    {
	    case B_00:
	      if (src1 == dest)
		src1_is_prev = TRUE;
	      
	      if (src2 == dest)
		src2_is_prev = TRUE;
	      
	      break;
	      
	    case B_01:
	      if (src2 == dest)
		src2_is_prev = TRUE;
	      
	      if (((src1 & 0x7) + 0x08) == dest)
		uses_prev = TRUE;
	      break;
	      
	    case B_10:
	      if (src1 == dest)
		src1_is_prev = TRUE;
	      
	      if (((src2 & 0x7) + 0x08) == dest)
		uses_prev = TRUE;
	      break;
	      
	    case B_11:	      
	      if (((src1 & 0x7) + 0x08) == dest ||
		  ((src2 & 0x7) + 0x08) == dest)
		uses_prev = TRUE;
	      break;
	    }
	}

      if (!uses_prev)
	{
	  peepf( "eliminated unnecessary register load before triadic" );

	  ++peep_eliminated;
	  
	  peep_buf[ prev ].reads   = reads;
	  peep_buf[ prev ].writes  = writes;
	  
	  if (src1_is_prev || src2_is_prev)
	    {
	      /* move source of previous load into triadic */
	      
	      if (src1_is_prev)
		{
		  curr_op = curr_op & 0xFFFF00FFU;
		  curr_op = curr_op | (source_of( prev_op ) << 8);
		}

	      if (src2_is_prev)
		{
		  curr_op = curr_op & 0xFFFFFF00U;
		  curr_op = curr_op | source_of( prev_op );
		}
	    }
	  
	  peep_buf[ prev ].op_code = curr_op;

	  return TRUE;
	}
    }
  
#if 0	/* This is a bad and bogus peephole as it does not set R2 to correct value */
  /*
   * check for a register based diadic
   * followed by a load from the dest back into the source
   *
   * eg turns:
   *	NEGI	R1, R2
   *	LDI	R2, R1
   * into:
   *    NEGI	R1, R1
   *
   * turns:
   *    ADDI	R1, R2
   *	LDI	R2, R1
   * into:
   *    ADDI	R2, R1
   */

  if (is_diadic( prev_op )				&&	/* prev_op is a diadic			*/
      is_mode(   prev_op, ADDR_MODE_REGISTER )		&&	/* which uses register addressing	*/
      is_load(   curr_op )				&&	/* curr_op is one of LDI, LDA, LDF	*/
      is_mode(   curr_op, ADDR_MODE_REGISTER )		&&	/* and also uses register addressing	*/
      dest_of(   prev_op ) == source_of( curr_op )	&&	/* and source and destination of the	*/
      dest_of(   curr_op ) == source_of( prev_op )	)	/* two instructions are reversed	*/
    {
      switch (prev_op >> 23)
	{
	case OP_ABSF:
	case OP_ABSI:
	case OP_FIX:
	case OP_FLOAT:
	case OP_NEGF:
	case OP_NEGI:
	case OP_NOT:
	  peep_buf[ prev ].writes &= ~regbit( real_register( dest_of( prev_op ) ) );
	  peep_buf[ prev ].writes |=  regbit( real_register( dest_of( curr_op ) ) );
	  peep_buf[ prev ].op_code = (prev_op & 0xFFE0FFFFU) | (curr_op & 0x001F0000U);
	  
	  peepf( "removed unnecessary register load after monadic" );

	  ++peep_eliminated;
	  
	  return TRUE;

	case OP_AND:
	case OP_ADDF:
	case OP_ADDI:
	case OP_MPYF:
	case OP_MPYI:
	case OP_OR:
	case OP_TSTB:
	case OP_XOR:
	  peep_buf[ prev ].reads   = reads;
	  peep_buf[ prev ].writes  = writes;
	  peep_buf[ prev ].op_code = (prev_op & 0xFFE00000U) | (curr_op & 0x001FFFFFU);
	  
	  peepf( "removed unnecessary register load after diadic" );

	  ++peep_eliminated;
	  
	  return TRUE;
	}
    }
#endif /* NEVER */
  
  /*
   * check for a store followed by a load to the same register
   *
   * eg turns:
   *	STI	R0, *AR6
   *	LDI	*AR6, R0
   * into:
   *    STI	R0, *AR6
   */

  if (is_op(   prev_op, OP_STI )             	   &&	/* previous operation is an integer store        */
      is_op(   curr_op, OP_LDI )                   &&	/* current  operation is an integer load         */
      is_mode( prev_op, ADDR_MODE_INDIRECT ) 	   &&	/* previous operation uses indirect addressing   */
      is_mode( curr_op, ADDR_MODE_INDIRECT ) 	   &&	/* current  operation uses indirect addressing   */
      source_of( prev_op ) == source_of( curr_op ) &&	/* the have the same form of indirect addressing */
      dest_of( prev_op )   == dest_of( curr_op  )  && 	/* previous op's dest is current op's dest       */
      ! has_indirect_side_effects( curr_op )        )	/* the indirect addressing has no side effects   */
    {
      peepf( "eliminated unnecessary indirect load" );

      ++peep_eliminated;

      return TRUE;
    }

  /*
   * check for a load constant
   */

  if (
      ((prev_op >> 28)         == OP_LDIc      ||	/* previous of is a load int (un)conditional	*/
       (prev_op >> 28)         == OP_LDFc      ) &&	/* previous of is a load flt (un)conditional	*/
      ((prev_op >> 23) & 0x1F) == C_U		&&	/* load is unconditional			*/
      is_mode( prev_op, ADDR_MODE_IMMEDIATE ) 	 )	/* previous operation uses immediate addressing	*/
    {
      if (is_op(   curr_op, OP_LDI )		      && /* current op is a load			 */
	  is_mode( curr_op, ADDR_MODE_REGISTER  )     && /* current  operation uses register  addressing */
          dest_of( prev_op ) == source_of( curr_op  ) )	 /* previous op's dest is current op's source	*/
	{
	  /*
	   * check for a load constant followed by a move register
	   *
	   * eg turns:
	   *    LDIu	0,  R5
	   *	LDI	R5, R0
	   * into:
	   *    LDIu	0, R5
	   *    LDIu	0, R0
	   *
	   * Why bother, I hear you ask.  The answer is that I hope
	   * at a later date, to be able to eliminate the first load
	   */

	  *pcurr_op = curr_op = (prev_op & 0xFFE0FFFFU) | (curr_op & 0x001F0000U);

	  *preads = reads = 0;
      
	  peepf( "transformed load register into load immeadiate" );

	  ++peep_transformed;
	}
#ifdef STIK_NOW_WORKS_ON_HARDWARE
      else if (is_op(   curr_op, OP_STI )	        &&	/* we have a store instruction    */
	       is_mode( curr_op, ADDR_MODE_INDIRECT )   &&	/* which uses indirect addressing */
	       dest_of( curr_op ) == dest_of( prev_op )  )	/* and they share the same destination */
	{
	  int32		val;

	  
	  /*
	   * check for a load followed by a store.
	   *
	   * turns:
	   *	LDIu	0,	R1
	   *	STI	R1,	*AR6
	   * into:
	   *	STIK	0,	*AR6
	   *	LDIu	0,	R1
	   */

	  val = mask_and_sign_extend_word( prev_op, 0xFFFF );
	  
	  if (fits_in_5_bits_signed( val ))
	    {
	      reads  &= ~regbit( real_register( dest_of( curr_op ) ) );	/* no longer reads destination */
	      
	      curr_op = (curr_op & 0xFF80FFFFU) | (ADDR_MODE_IMMEDIATE << 21) | ((val & 0x1F) << 16);
	      
	      SWAP_OPS;

	      if (regbit( real_register( dest_of( curr_op ) ) ) & death)
		{
		  peepf( "eliminated register load and transformed register store" );

		  ++peep_eliminated;
		  
		  return TRUE;
		}
	      else
		{
		  peepf( "transformed store register into store immeadiate" );

		  ++peep_transformed;
		}
	    }
	}
#endif /* STIK_NOW_WORKS_ON_HARDWARE */
    }
      
  if (
      ((prev_op >> 28)         == OP_LDIc      ||	/* previous of is a load int (un)conditional	*/
       (prev_op >> 28)         == OP_LDFc      ) &&	/* previous of is a load flt (un)conditional	*/
      ((prev_op >> 23) & 0x1F) == C_U		 &&	/* load is unconditional			*/
      is_mode( prev_op, ADDR_MODE_REGISTER ) 	 &&	/* previous operation uses register addressing	*/
      is_mode( curr_op, ADDR_MODE_REGISTER ) 	 )	/* current  operation uses register addressing	*/
    {
      if (dest_of( prev_op ) == source_of( curr_op ) &&
	  dest_of( curr_op ) == source_of( prev_op ) )
	{
	  /*
	   * check for mutual register loading
	   *
	   * eg turns:
	   *    LDFu	R4, R0
	   *	LDFu	R0, R4
	   * into:
	   *    LDFu	R4, R0
	   */
	  
	  peepf( "eliminated unnecessary uncoditional register move" );
	  
	  ++peep_eliminated;
	  
	  return TRUE;
	}
    }
  
  /*
   * check for two successive ANDs
   *
   * eg turns:
   *	AND	0xff, R0
   *	AND	0x7f, R0
   * into:
   *    AND	0x7f, R0
   */

  if (is_op(   prev_op, OP_AND )             	  &&	/* previous operation is AND        */
      is_op(   curr_op, OP_AND )                  &&	/* current  operation is AND         */
      is_mode( prev_op, ADDR_MODE_IMMEDIATE ) 	  &&	/* previous operation uses immediate addressing   */
      is_mode( curr_op, ADDR_MODE_IMMEDIATE ) 	  &&	/* current  operation uses immediate addressing   */
      dest_of( prev_op )   == dest_of( curr_op  ) ) 	/* previous op's dest is current op's dest       */
    {
      peep_buf[ prev ].op_code = (prev_op & 0xFFFF0000U) | (prev_op & 0xFFFF & curr_op);

      ++peep_eliminated;

      peepf( "eliminated unnecessary immediate AND" );

      return TRUE;
    }
  
  /* See if both instructions alter the same register (except the status register) */

  if (writes & (peep_buf[ prev ].writes) & (~(1 << RR_ST)))
    return FALSE;

  /*
   * check for two load or store operations in succession
   */

  prev_load  = is_potential_parallel_op( prev_op, OP_LDI, curr_op );
  prev_store = is_potential_parallel_op( prev_op, OP_STI, curr_op );
  curr_load  = is_potential_parallel_op( curr_op, OP_LDI, prev_op );
  curr_store = is_potential_parallel_op( curr_op, OP_STI, prev_op );

  if (prev_load + prev_store + curr_load + curr_store >= 2)
    {
      if (   (curr_op & 0xFF)   == 0	  /* displacement is zero   */
	  && (curr_op & 0xc000) == 0)	  /* displacement is "used" */
	{
	  /* change mode to straight relative */
	  
	  curr_op = (curr_op & 0xFFFF07FFUL) | (INDIRECT_REL << 11);
	}
	      
      if (   (prev_op & 0xFF)   == 0	  /* displacement is zero   */
	  && (prev_op & 0xc000) == 0)	  /* displacement is "used" */
	{
	  /* change mode to straight relative */
	  
	  prev_op = (prev_op & 0xFFFF07FFUL) | (INDIRECT_REL << 11);
	}
	      
      if (prev_load)
	{
	  if (peep_buf[ prev ].writes & regbit( RR_PST ))
	    {
	      /*
	       * oh oh, the compiler has already used the fact that the
	       * load instruction writes to the ST register, so we cannot
	       * combine it with another instruction, preventing it from
	       * writing to ST.
	       *   See comment in peep_sets_status_reg()
	       */

	      return FALSE;	      
	    }
	  
	  if (curr_load)
	    {
	      /* previous and current LDI */
	      
	      /* check that the destination of the loads */
	      
	      if (dest_of( prev_op ) == dest_of( curr_op ))
		{
		  peepf( "WARNING: two successive loads with the same destination" );
		  
		  /* ignore first load */
		  
		  peep_buf[ prev ].op_code = curr_op;
		  peep_buf[ prev ].reads   = reads;
		  peep_buf[ prev ].writes  = writes;
		  
		  return TRUE;
		}
	      
	      peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                     	         (OP_LDI_LDI << 25)                     |
		                         (prev_op & (B_111 << 16)) << (22 - 16) |
		                         (curr_op & (B_111 << 16)) << (19 - 16) |
		                         (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			                 (prev_op & (0xFF  <<  8)) >> ( 8 -  0);

	      peep_buf[ prev ].reads  |= reads;
	      peep_buf[ prev ].writes |= writes;
	      peep_buf[ prev ].writes &= ~regbit( RR_ST );
	      
	      peepf( "transformed LDI, LDI into LDI || LDI" );

	      ++peep_eliminated;
	      ++peep_transformed;
	      
	      return TRUE;
	    }
	  else
	    {
	      /* previous LDI, current STI */
	      
	      /* check that the destination of the load is not the source of the store */
	      
	      if (dest_of( prev_op ) != dest_of( curr_op ))
		{
		  peep_buf[ prev ].op_code = (B_11 << 30)                           |
		                             (OP_LDI_STI << 25)                     |
		                             (prev_op & (B_111 << 16)) << (22 - 16) |
			                     (curr_op & (B_111 << 16)) << (16 - 16) |
			                     (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			                     (prev_op & (0xFF  <<  8)) >> ( 8 -  0);
		  
		  peep_buf[ prev ].reads  |= reads;
		  peep_buf[ prev ].writes |= writes;
		  peep_buf[ prev ].writes &= ~regbit( RR_ST );
		  
		  peepf( "transformed LDI, STI into LDI || STI" );

		  ++peep_eliminated;
		  ++peep_transformed;
		  
		  return TRUE;
		}
	    }
	}
      else /* prev op is STI */
	{
	  if (curr_load)
	    {
	      if (writes & regbit( RR_PST ))
		{
		  /*
		   * See comment in peep_sets_status_reg()
		   */

		  return FALSE;	      
		}
	  
	      /* previous STI, current LDI */
	      
	      if (source_of( prev_op ) == source_of( curr_op ))
		{
		  /* weird - a store followed by a load from the same place ! */
		  
		  if (dest_of( prev_op ) == dest_of( curr_op ))
		    {
		      peepf( "eliminated register load" );

		      ++peep_eliminated;
		      
		      return TRUE;
		    }
		  else
		    {
		      /* transform load into register move */
		      
		      *preads   = regbit( dest_of( prev_op ) );
		      *pwrites  = regbit( dest_of( curr_op ) ) | regbit( RR_ST );
		      *pcurr_op = build_op( OP_LDI, ADDR_MODE_REGISTER,
					   dest_of( curr_op ), dest_of( prev_op ) );
		      
		      peepf( "transformed memory access into register transfer" );

		      ++peep_transformed;
		      
		      return FALSE;
		    }
		}

#if 0
	      /*
	       * XXX - NC
	       *
	       * We cannot safely generate this instruction because
	       * the load will take place before the store, and the
	       * destination of the store might be an alias for the
	       * source of the load.  *sigh*
	       *
	       * For example see the code for removing spaces from
	       * a command line argument in ExecuteList() in c.c
	       * This generats just such an example
	       */
	      
	      peep_buf[ prev ].op_code = (B_11 << 30)                           |
		                         (OP_LDI_STI << 25)                     |
		                         (curr_op & (B_111 << 16)) << (22 - 16) |
		                         (prev_op & (B_111 << 16)) << (16 - 16) |
		                         (prev_op & (0xFF  <<  8)) << ( 8 -  8) |
			                 (curr_op & (0xFF  <<  8)) >> ( 8 -  0);
	      
	      peep_buf[ prev ].reads  |= reads;
	      peep_buf[ prev ].writes |= writes;
	      peep_buf[ prev ].writes &= ~regbit( RR_ST );
	      
	      peepf( "transformed STI, LDI into LDI || STI" );

	      ++peep_transformed;
	      ++peep_eliminated;
	      
	      return TRUE;
#endif
	    }
#ifdef STI_STI_NOW_WORKS_ON_HARDWARE
	  else
	    {
	      /* previous and current STI */
	      
	      if (source_of( prev_op ) == source_of( curr_op ))
		{
		  /* weird two stores to the same place ! */
		  
		  peepf( "eliminating duplicate store!" );

		  ++peep_eliminated;
		  
		  /* eliminate the first store */
		  
		  SWAP_OPS;

		  return TRUE;
		}
	      
	      peep_buf[ prev ].op_code = (B_11 << 30)                           |
		                         (OP_STI_STI << 25)                     |
		                         (prev_op & (B_111 << 16)) << (22 - 16) |
		                         (curr_op & (B_111 << 16)) << (16 - 16) |
		                         (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			                 (prev_op & (0xFF  <<  8)) >> ( 8 -  0);
	      
	      peep_buf[ prev ].reads  |= reads;
	      peep_buf[ prev ].writes |= writes;
	      peep_buf[ prev ].writes &= ~regbit( RR_ST );
	      
	      peepf( "transformed STI, STI into STI || STI" );

	      ++peep_eliminated;
	      ++peep_transformed;
	      
	      return TRUE;
	    }
#endif /* STI_STI_NOW_WORKS_ON_HARDWARE */
	}
    }

  return FALSE;
  
} /* combine_instrs */
  
  
static void
peep_swap(
	  signed int	a,
	  signed int	b,
	  char *	reason )
{
  peep_data	tmp;

  
  tmp           = peep_buf[ a ];
  peep_buf[ a ] = peep_buf[ b ];
  peep_buf[ b ] = tmp;

  if (asmstream != NULL && annotations)
    {
      asmf( "; peepholer: swapped " );

      decode_instruction( peep_buf[ a ].op_code, FALSE );

      asmf( " with " );

      decode_instruction( peep_buf[ b ].op_code, FALSE );
  
      asmf( " because: %s\n", reason );
    }

  ++peep_swapped;
  
  return;
  
} /* peep_swap */


/*
 * remove an instruction from the peephole buffer
 * performing any peep hole optimisations that you can
 */

static void
emit_from_peep( void )
{
  peep_data *	instruction;
  int32		offset;
  int32		op;


  DBG( if (peep_start == peep_end) syserr( peep_peepholer_empty ); )
  
  /*
   * possible futher optimisations :-
   *
   *   parallel load / store & diadic / triadic op
   *
   *   elimination of compare then link-and-jump with a conditional link-and-jump
   *
   */

  /* now send out an instruction */

  instruction = &(peep_buf[ peep_start ]);

  op = instruction->op_code;

  switch (instruction->type)
    {
    default:
      syserr( peep_unknown_type, instruction->type );
      break;
      
    case OUT_XREF:
      codexrefs = (CodeXref *) global_list3( SU_Other, codexrefs,
					    instruction->reftype + codebase + codep,
					    instruction->symbol );
      
      outcodewordaux( op, LIT_RELADDR, instruction->symbol );
      
      break;

    case OUT_DELLABREF:
    case OUT_LABREF:
      if (lab_isset_( instruction->label ))
	{
	  /*
	   * This can happen when we generate an unconditional backwards reference,
	   * but we do not know the offset, because the instruction might be moved
	   * by the peepholer.
	   */

	  switch (instruction->reftype)
	    {
	    case LABREF_OFF24:
	      offset = instruction->label->u.defn & 0x7fffffffU;
	      offset = (offset - codep) / sizeof_int;
	      if ((op >> 24) & 1)
		offset -= 3; /* delayed version */
	      else
		offset -= 1;	      
	      op = (op & 0xFF000000U) | (offset & 0x00FFFFFFU);
	      break;
	      
	    default:
	      syserr( peep_unexpected_back_ref );
	      break;
	    }
	}
      else
	{
	  addfref_( instruction->label, codep | instruction->reftype );
	}
      
      /* drop through */

    case OUT_DELAYED:
      /* drop through */
      
    case OUT_NULL:
      /* drop through */

    case OUT_INSTR:
      outcodeword( op, LIT_OPCODE );
      break;

    case OUT_DELSYMXREF:
      /* drop through */
      
    case OUT_SYMXREF:
      codexrefs = (CodeXref *) global_list3( SU_Other, codexrefs,
					    instruction->reftype + codebase + codep,
					    instruction->symbol );
      /* drop through */

    case OUT_SYMREF:
      outcodewordaux( op, LIT_RELADDR, instruction->symbol );
      break;

    case OUT_DELSYMREF:
      offset = mask_and_sign_extend_word( op, 0x00ffffffU );
      
      if (offset != 0)
	{
	  /* subtract codep from offset */
	  
	  op = (op & 0xff000000U) |
	    ((offset - (codep / sizeof_int)) & 0x00ffffffU);
	}
				   
      outcodewordaux( op, LIT_RELADDR, instruction->symbol );
      
      break;
    }

  peep_start = successor_( peep_start );
  
  return;
   
} /* emit_from_peep */


/*
 * this function indicates that the next instruction to be appended
 * to the peepholer's buffer is a cross reference type instruction, rather than
 * an ordinary instruction
 */
  
void
peep_xref(
	  int32		reftype,
	  Symstr *	symbol )
{
  xref_pending    = TRUE;
  pending_reftype = reftype;
  pending_symbol  = symbol;


  return;
  
} /* peep_xref */

  
/*
 * this function indicates that the next instruction to be
 * appended to the peepholer's buffer references a symbol
 */
  
void
peep_symref( Symstr * symbol )
{
  xref_pending    = TRUE;
  pending_reftype = LABREF_NONE;
  pending_symbol  = symbol;

  return;
  
} /* peep_symref */


/*
 * this function indicates that the next instruction to be
 * appended to the peepholer's buffer has a forward
 * reference to a label
 */
  
void
peep_fref(
	  LabelNumber *	label,
	  int32		reftype )
{
  fref_pending    = TRUE;
  pending_label   = label;
  pending_reftype = reftype;

  return;
  
} /* peep_fref */


/*
 * Try to push the latest instruction in the peepholer back
 * by the number of instructions indicated.  Returns the
 * actual number of instructions skipped.
 */

int
peep_shift_back( int n )
{
  signed int	prev;
  signed int	last;
  int		done;
  
  
  /* check that we can move the instructions */
  
  if (xref_pending || fref_pending || peep_end == peep_start || n < 1)
    {
      return 0;
    }

  /* get last instruction */
  
  last = prev = previous_( peep_end );

  /* initialise count of successful swaps */
  
  done = 0;
  
  /* examine previous instructions */
  
  while (prev != peep_start && n--)
    {
      prev = previous_( prev );

      if (can_swap( last, prev ))
	{
	  /* swap the two instructions */

	  peep_swap( last, prev, "backwards pipeline conflict avoidance" );
	  
	  /* update pointer to the "last" instruction */
	  
	  last = prev;

	  /* increment count */
	  
	  done++;
	}
      else
	{
#if 0
	  asmf( "; peepholer: could not swap " );

	  decode_instruction(  peep_buf[ last ].op_code, FALSE );

	  asmf( " with " );
	  
	  decode_instruction( peep_buf[ prev ].op_code, FALSE );

	  asmf( "\n" );
#endif	  
	  return done;
	}
    }

  return done;
  
} /* peep_shift_back */


void
append_peep(
	    peep_type		type,
	    int32		op_code,
	    int32		reads,
	    int32		writes,
	    Symstr *		symbol,
	    LabelNumber *	label,
	    int32		reftype )
{
  signed int	next;


  if (!xref_pending && !fref_pending)
    {
      /* see if we have a redundant op-code */

      if (type == OUT_NULL && eliminate_null_op())
	{
	  return;
	}

      /* see if we can combine two ops into one */
  
      if (type == OUT_INSTR && combine_instrs( &op_code, &reads, &writes ))
	{
	  return;
	}
    }

  if (peep_protect_pc > 0)
    {
      reads |= regbit( RR_PC );

      --peep_protect_pc;
    }
  
  /* insert the instruction into the table */
  
  peep_buf[ peep_end ].type    = type;
  peep_buf[ peep_end ].op_code = op_code;
  peep_buf[ peep_end ].reads   = reads;
  peep_buf[ peep_end ].writes  = writes;
  peep_buf[ peep_end ].symbol  = symbol;
  peep_buf[ peep_end ].reftype = reftype;
  peep_buf[ peep_end ].label   = label;

  /* check to see if this instruction was a cross reference or a forward reference */

  if (xref_pending)
    {
      if (fref_pending)
	{
	  syserr( peep_fwd_and_cross_ref );
	}
      
      if (type == OUT_INSTR)
	{
	  if (pending_reftype == LABREF_NONE)
	    {
	      peep_buf[ peep_end ].type    = OUT_SYMREF;
	      peep_buf[ peep_end ].symbol  = pending_symbol;
	    }
	  else
	    {
	      peep_buf[ peep_end ].type    = OUT_XREF;
	      peep_buf[ peep_end ].symbol  = pending_symbol;
	      peep_buf[ peep_end ].reftype = pending_reftype;
	    }
	}
      else if (type == OUT_SYMREF)
	{
	  peep_buf[ peep_end ].type    = OUT_SYMXREF;
	  peep_buf[ peep_end ].reftype = pending_reftype;
	}
      else if (type == OUT_DELSYMREF)
	{
	  peep_buf[ peep_end ].type    = OUT_DELSYMXREF;
	  peep_buf[ peep_end ].reftype = pending_reftype;
	}
      else
	{
	  syserr( peep_special_pending_cross );
	}

      xref_pending = FALSE;
    }
  else if (fref_pending)
    {
      if (type == OUT_INSTR)
	{
	  peep_buf[ peep_end ].type    = OUT_LABREF;
	  peep_buf[ peep_end ].label   = pending_label;
	  peep_buf[ peep_end ].reftype = pending_reftype;
	}
      else
	{
	  syserr( peep_special_pending_fwd );
	}

      fref_pending = FALSE;
    }

  /* adjust pointer to indicate next free slot */

  next = successor_( peep_end );

  if (next == peep_start)
    {
      /* table is full */

      emit_from_peep();
    }

  peep_end = next;

  /*
   * try to avoid pipeline conflicts when using (real) address registers
   */

  if ((new_stubs || !in_stubs) &&	/* do not alter stub generation */
      !no_peepholing)			/* only operate if allowed to	*/
    {
      signed int	back1 = previous_( peep_end );
      signed int	back2 = previous_( back1 );
      int32		prev  = 0;


      if (num_in_peep_() > 1)
	prev = peep_buf[ back2 ].op_code;
      
      if (peep_pending_swaps > 0)
	{
#if 0 /* cannot use this optimisation because of pointer aliasing */
	  if (num_in_peep_() > 1 	&& /* if there are instructions to swap */
	      is_normal( op_code )	&& /* and first is diadic or triadic	*/
	      is_normal( prev )		&& /* and second is diadic or triadic   */ 
	      can_swap( back1, back2 )   ) /* and we are allowed to swap them   */
	    {
	      peep_swap( back1, back2, "forwards pipeline conflict avoidance" );
	      
	      --peep_pending_swaps;
	    }
	  else
#endif
	    {
	      if (asmstream != NULL && num_in_peep_() > 1 && annotations)
		{
		  asmf( "; could not swap op " );
		  
		  decode_instruction( op_code, FALSE );
		  
		  asmf( " with op " );
		  
		  decode_instruction( prev, FALSE );
		  
		  asmf( "\n" );
		}
	      
	      peepf( "%d forward swaps left undone", peep_pending_swaps );
	      
	      /* stop trying to swap instrs */

	      peep_pending_swaps = 0;
	    }
	}
      else if (
	       is_normal( op_code )                    	         && /* is diadic or triadic		*/
	       dest_of( op_code ) == hardware_register( R_ATMP ) && /* and its destination is R_ATMP	*/
	       !is_op( op_code, OP_STI  )              	         && /* and it is not a store		*/
	       !is_op( op_code, OP_STIK )              	     	 && /* of any kind			*/
	       !is_op( op_code, OP_STF  )                         )
	{
	  (void) peep_shift_back( 2 );
	}
      else if (
	       num_in_peep_() > 1			&&	/* there is a previous op to check	*/
	       is_normal( prev ) 			&&	/* diadic or triadic 			*/
	       is_normal( op_code ) 			&&	/* diadic or triadic 			*/
	       is_mode( op_code, ADDR_MODE_INDIRECT ) 	&&	/* current op uses indirect addressing	*/
	       dest_of( prev ) == real_addr_reg( indirect_addr_reg( op_code ) ) )
	{
	  /*
	   * indicate that we would like the current instruction swapped forwards
	   */
      
	  if (is_op( prev, OP_LDPK ))
	    peep_pending_swaps = 0;
	  else if (is_op( prev, OP_LDA))
	    peep_pending_swaps = 1;
	  else
	    peep_pending_swaps = 2;
	}
    }
    
  return;
  
} /* append_peep */

/*
 * returns TRUE if the last instruction in the peepholer
 * is a register based LDI whoes destination is the register
 * given
 */

bool
peep_reg_transfer_to( RealRegister r )
{
  int32		op;
  

  op = peep_buf[ previous_( peep_end ) ].op_code;
  
  if (peep_end != peep_start            &&	/* if there are any instructions in the peepholer */
      is_op( op, OP_LDI )               &&	/* and the last instruction is a load instruction */
      is_mode( op, ADDR_MODE_REGISTER ) &&	/* and it is a transfer between two registers     */
      dest_of( op ) == hardware_register( r ) )	/* and the destination register is the given reg  */
    {
      return TRUE;
    }
  
  return FALSE;
  
} /* peep_reg_transfer_to */

  
/*
 * returns TRUE if the last instruction in the peepholer
 * which sets the status register will set the condition
 * codes based on the contents of register 'r'
 */

bool
peep_sets_status_reg( RealRegister r )
{
  signed int	prev;


  if (peep_start == peep_end)
    return FALSE;					/* nothing in the peepholer */

  prev = peep_end;
  
  do
    {
      int32	writes;

      
      prev = previous_( prev );

      writes = peep_buf[ prev ].writes;
      
      if (writes & regbit( RR_ST ))			/* the instruction sets the status register	*/
	{
	  int32		op;

	  
	  if (writes & regbit( r ))			/* the instruction writes to register 'r'	*/
	    {
	      /*
	       * XXX - NC - 11/6/92
	       *
	       * The following is to catch a bug whereby a load instruction
	       * is detected as setting the status register, and so a
	       * compare instruction is not issued.  Then the load instruction
	       * is turned into a combined load/store instruction which does
	       * not set the ST register.
	       *   Strictly speaking, I should not turn a load followed by a
	       * store in a combined instruction, but this would prevent a
	       * useful optimisation.  Instead, I claim that instruction writes
	       * to a pseudo ST register, which the peepholer can detect when
	       * it wants to combine the two instructions.
	       */
	      
	      peep_buf[ prev ].writes |= regbit( RR_PST );
	      
	      return TRUE;
	    }	  

	  op = peep_buf[ prev ].op_code;
      
	  if (is_op(   op, OP_LDI ) 		    &&	/* or the instruction is a load			*/
	      is_mode( op, ADDR_MODE_REGISTER )     &&	/* and it is a register to register transfer	*/
	      (peep_buf[ prev ].reads & regbit( r )) )	/* and the instruction reads from register 'r'	*/
	    {
	      peep_buf[ prev ].writes |= regbit( RR_PST );
	      
	      return TRUE;
	    }	  

	  return FALSE;
	}
      else if (writes & regbit( r ))
	{
	  return FALSE;					/* the instruction alters 'r' but not ST	*/
	}
            
      /* continue until we run out of instructions */
    }
  while (prev != peep_start);

  return FALSE;
  
} /* peep_sets_status_reg */

  
/*
 * returns TRUE if any of the instructions in the peeholer
 * reference the given label.  Returns FALSE otherwise.
 */

bool
peep_refs_label( LabelNumber * l )
{
  signed int	i;


  for (i = peep_start; i != peep_end; i = successor_( i ))
    {
      if ((peep_buf[ i ].type == OUT_LABREF || peep_buf[ i ].type == OUT_DELLABREF) &&
	  peep_buf[ i ].label == l)
	{
	  return TRUE;
	}
    }

  return FALSE;
  
} /* peep_refs_label */

  
/*
 * returns the source register of the register transfer
 * instruction that is the last instruction in the peepholer
 */

RealRegister
peep_eliminate_reg_transfer( RealRegister r )
{
  int32		op;
  

  if (xref_pending || fref_pending)
    {
      syserr( peep_elim_clash );
    }

  op = peep_buf[ previous_( peep_end ) ].op_code;
  
  if (peep_end != peep_start            &&
      is_op( op, OP_LDI )               &&
      is_mode( op, ADDR_MODE_REGISTER ) &&
      dest_of( op ) == hardware_register( r ) )
    {
      peep_end = previous_( peep_end );

      return real_register( source_of( op ) );
    }
  
  syserr( peep_non_existant_xfer );

  return GAP;
  
} /* peep_eliminate_reg_transfer */

  
/*
 * empty the peephole buffer
 */

void
flush_peepholer( DBG( const char * reason ) )
{
  flush_pending_pushes();
  
  if (xref_pending)
    {
      syserr( peep_cross_ref_pending );
    }

  if (fref_pending)
    {
      syserr( peep_fwd_ref_pending );
    }

  while (peep_start != peep_end)
    {
      emit_from_peep();      
    }

  DBG( peepf( "flushed: %s ", reason ); )

  if (num_in_peep_() > 0)
    syserr( peep_failed_reset_count );
  
  return;
  
} /* flush_peepholer */

  

/* --------------------------------- INITIALISATION -------------------------------- */

void
peep_init( void )
{
  /*
   * NB/ This is necessary because J_LABEL is called before J_ENTER
   * and J_LABEL calls peep_corrupt_all_addr_regs() which does a
   * walklist() on the addr regs list.
   */

  init_list( &addr_regs );

  node_count = 0;
  
  init_list( &pending_pushes );
  
  init_list( &free_pending_pushes );
  
  return;

} /* peep_init */


void
peep_tidy( void )
{
  return;

} /* peep_tidy */
  

/* end of peep.c */

@


1.48
log
@fixed bug causing core dump
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.47 $
 * Date :	$Date: 1993/08/04 17:06:09 $
d130 1
a130 4
  if (DEBUG && format == NULL)
    {
      syserr( peep_null_format );
    }
d165 2
a166 5
  if (DEBUG && format == NULL)
    {
      syserr( peep_null_format );
    }
  
d200 1
a200 4
  if (DEBUG && plist == NULL)
    {
      syserr( peep_null_list );
    }
d219 1
a219 4
  if (DEBUG && (plist == NULL || pnode == NULL))
    {
      syserr( peep_null_parameter );
    }
d240 1
a240 4
  if (DEBUG && (plist == NULL || pnode == NULL))
    {
      syserr( peep_null_parameter );
    }
d263 1
a263 4
  if (DEBUG && plist == NULL)
    {
      syserr( peep_null_list );
    }
d294 1
a294 4
  if (DEBUG && plist == NULL)
    {
      syserr( peep_null_list );
    }
d445 1
a445 4
  if (DEBUG && (plist == NULL || pfunc == NULL))
    {
      syserr( peep_null_parameter );
    }  
d474 1
a474 4
  if (DEBUG && (plist == NULL || pfunc == NULL))
    {
      syserr( peep_null_parameter );
    }  
d498 1
a498 4
  if (DEBUG && pnode == NULL)
    {
      syserr( peep_null_parameter );
    }  
d514 1
a514 4
  if (DEBUG && pnode == NULL)
    {
      syserr( peep_null_parameter );
    }  
d528 1
a528 4
  if (DEBUG && preg == NULL)
    {
      syserr( peep_null_parameter );
    }  
d546 1
a546 4
  if (DEBUG && preg == NULL)
    {
      syserr( peep_null_parameter );
    }  
d775 1
a775 2
	  if (DEBUG && pnode == NULL)
	    syserr( peep_urg );
d785 1
a785 2
	  if (DEBUG && pnode == NULL)
	    syserr( peep_urg );
d793 1
a793 2
	      if (DEBUG && pnode == NULL)
		syserr( peep_urg );
d803 1
a803 2
	      if (DEBUG && pnode == NULL)
		syserr( peep_urg );
d815 1
a815 2
      if (DEBUG && pnode == NULL)
	syserr( peep_urg );
d2820 1
a2820 6
  if (DEBUG && peep_start == peep_end)
    {
      syserr( peep_peepholer_empty );

      return;
    }
d3194 1
d3205 1
@


1.47
log
@fixed use of move_register
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.46 $
 * Date :	$Date: 1993/08/04 16:32:21 $
a13 2
#define DEBUG 		0

a3542 7
/* @@@@ emacs customization */

/* Local Variables: */
/* mode: c */
/* outline-regexp: "^[a-zA-Z_]*(" */
/* eval: (outline-minor-mode 1) */
/* End: */
@


1.46
log
@replaced syserrs with compress strings and inlined some list functions
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.4 $
 * Date :	$Date: 1993/08/04 16:21:09 $
d1215 1
a1215 1
	  move_register( src, dest, FALSE );
d1229 1
a1229 1
	      move_register( src, dest, TRUE );
d1259 1
a1259 1
	  move_register( src, dest + 1, FALSE );	/* NB/ must transfer integer part as well */
@


1.45
log
@added new peephole test and extended LDIu test to include LDFu
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.44 $
 * Date :	$Date: 1993/07/09 10:50:56 $
d14 1
a14 5
#ifdef __CC_NORCROFT
#pragma few_modules
#endif

/* #define DEBUG */
d132 1
a132 2
#ifdef DEBUG
  if (format == NULL)
d134 1
a134 1
      syserr( "NULL format passed to debug()" );
a135 1
#endif
d170 1
a170 2
#ifdef DEBUG
  if (format == NULL)
d172 1
a172 1
      syserr( "peepholer: NULL format passed to peepf" );
a173 1
#endif
d175 1
a175 1
  if (asmstream == NULL || !annotations)
d184 1
a184 1
  fprintf( asmstream, "; peepholer: " );
d208 1
a208 2
#ifdef DEBUG
  if (plist == NULL)
d210 1
a210 1
      syserr( "peepholer: passed NULL list to init_list" );
a211 1
#endif
a220 1

d230 1
a230 2
#ifdef DEBUG
  if (plist == NULL || pnode == NULL)
d232 1
a232 1
      syserr( "peepholer: passed NULL parameter to add_head" );
a233 1
#endif
d254 1
a254 2
#ifdef DEBUG
  if (plist == NULL || pnode == NULL)
d256 1
a256 1
      syserr( "peepholer: passed NULL parameter to add_tail" );
a257 1
#endif
d280 1
a280 2
#ifdef DEBUG
  if (plist == NULL)
d282 1
a282 1
      syserr( "peepholer: NULL list passed to remove_head" );
a283 1
#endif
d314 1
a314 2
#ifdef DEBUG
  if (plist == NULL)
d316 1
a316 1
      syserr( "peepholer: NULL list passed to remove_tail" );
a317 1
#endif
d341 1
a344 1
#ifdef DEBUG
d347 1
a347 1
      syserr( "peepholer: remove_node passed a NULL node" );
a348 1
#endif  
d356 3
a359 1

d364 1
a367 1
#ifdef DEBUG
d372 1
a372 1
      syserr( "peepholer: first_node: passed a NULL list" );
a373 1
#endif
d378 3
d386 1
a389 1
#ifdef DEBUG
d394 1
a394 1
      syserr( "peepholer: last_node: passed a NULL list" );
a395 1
#endif
d400 3
d409 1
a412 1
#ifdef DEBUG
d417 1
a417 1
      syserr( "peepholer: previous_node: passed a NULL node" );
a420 1
#endif
d425 3
d434 1
a437 1
#ifdef DEBUG
d442 1
a442 1
      syserr( "peepholer: previous_node: passed a NULL node" );
a445 1
#endif
d450 3
d468 1
a468 2
#ifdef DEBUG
  if (plist == NULL || pfunc == NULL)
d470 1
a470 1
      syserr( "peepholer: walk_list: passed a NULL parameter" );
a471 1
#endif
d500 1
a500 2
#ifdef DEBUG
  if (plist == NULL || pfunc == NULL)
d502 1
a502 1
      syserr( "peepholer: search_list: passed a NULL parameter" );
a503 1
#endif
d527 1
a527 2
#ifdef DEBUG
  if (pnode == NULL)
d529 1
a529 1
      syserr( "peepholer: register_p: passed a NULL node" );
a530 1
#endif
d546 1
a546 2
#ifdef DEBUG
  if (pnode == NULL)
d548 1
a548 1
      syserr( "peepholer: contents_p: passed a NULL node" );
a549 1
#endif
d563 1
a563 2
#ifdef DEBUG
  if (preg == NULL)
d565 1
a565 1
      syserr( "peepholer: forget: passed a NULL register" );
a566 1
#endif
d584 1
a584 2
#ifdef DEBUG
  if (preg == NULL)
d586 1
a586 1
      syserr( "peepholer: init_reg: passed a NULL register" );
a587 1
#endif
d815 4
a818 4
#ifdef DEBUG
	  if (pnode == NULL)
	    syserr( "peepholer: urg urg" );
#endif
d826 4
a829 4
#ifdef DEBUG
	  if (pnode == NULL)
	    syserr( "peepholer: urg urg 2" );
#endif
d835 4
a838 4
#ifdef DEBUG
	      if (pnode == NULL)
		syserr( "peepholer: urg" );
#endif  
d846 3
a848 4
#ifdef DEBUG
	      if (pnode == NULL)
		syserr( "peepholer: urg urg 3" );
#endif
d860 2
a861 4
#ifdef DEBUG
      if (pnode == NULL)
	syserr( "peepholer: urg urg 4" );
#endif
d1002 1
a1002 1
      syserr( "peepholer: flush_push: unknown push type" );
d1036 1
a1036 1
	  syserr( "peepholer: add_pending_push: out of memory" );
d1062 1
a1062 1
      syserr( "peepholer: add_pending_push: unknown push type" );
d1127 1
a1127 1
      syserr( "peepholer: pop_pending_push: unknown push type" );
d1215 1
a1215 1
	  move_register( src, dest, FALSE, TRUE );
d1229 1
a1229 1
	      move_register( src, dest, TRUE, TRUE );
d1259 1
a1259 1
	  move_register( src, dest + 1, FALSE, TRUE );	/* NB/ must transfer integer part as well */
d1334 1
a1334 2
	      syserr( "peepholer: maybe_flush_pending_push: unknown push type %x for reg %ld",
		     push->type, reg );
d1550 1
a1550 1
		syserr( "peepholer: no offset in branch!" );
d1572 1
a1572 1
	    syserr( "peepholer: no offset in branch!" );
d1617 1
a1617 1
	  syserr( "peepholer: unknown delay type" );
d1830 1
a1830 1
		  peepf( "failed to combine multiple indentical op codes (%lx)", curr_op );
d2457 3
a2459 3
      if (is_op(   curr_op, OP_LDI )		     && /* current op is a load			        */
	  is_mode( curr_op, ADDR_MODE_REGISTER  )    && /* current  operation uses register  addressing */
          dest_of( prev_op ) == source_of( curr_op  ) ) /* previous op's dest is current op's source	*/
d2835 1
a2835 1
      fprintf( asmstream, "; peepholer: swapped " );
d2839 1
a2839 1
      fprintf( asmstream, " with " );
d2843 1
a2843 1
      fprintf( asmstream, " because: %s\n", reason );
d2866 1
a2866 2
#ifdef DEBUG
  if (peep_start == peep_end)
d2868 1
a2868 1
      syserr( "peepholer: attempting to emit from EMPTY peepholer!" );
a2871 1
#endif
d2891 1
a2891 1
      syserr( "peepholer: asked to emit an unknown type %d", instruction->type );
d2926 1
a2926 1
	      syserr( "peepholer: unexpected backwards reference" );
d3093 1
a3093 1
	  fprintf( asmstream, "; peepholer: could not swap " );
d3097 1
a3097 1
	  fprintf( asmstream, " with " );
d3101 1
a3101 1
	  fprintf( asmstream, "\n" );
d3165 1
a3165 1
	  syserr( "peepholer: pending forward and cross references for same instruction!" );
d3194 1
a3194 1
	  syserr( "peepholer: special instruction type had a pending cross reference!" );
d3209 1
a3209 1
	  syserr( "peepholer: special instruction type had a pending forward reference!" );
d3258 1
a3258 1
		  fprintf( asmstream, "; could not swap op " );
d3262 1
a3262 1
		  fprintf( asmstream, " with op " );
d3266 1
a3266 1
		  fprintf( asmstream, "\n" );
d3454 1
a3454 1
      syserr( "peepholer: attempting to eliminate instruction whilst a reference is still pending" );
d3469 1
a3469 1
  syserr( "peepholer: trying to eliminate non-existant register transfer" );
d3481 1
a3481 1
flush_peepholer( const char * reason )
d3487 1
a3487 1
      syserr( "peepholer: attempting to flush peepholer whilst a cross ref is still pending" );
d3492 1
a3492 1
      syserr( "peepholer: attempting to flush peepholer whilst a forward ref is still pending" );
d3500 1
a3500 1
  peepf( "flushed: %s ", reason );
d3503 1
a3503 1
    syserr( "peepholer: flush has failed to reset peep count" );
@


1.44
log
@added extra parameters to move_register()
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.43 $
 * Date :	$Date: 1993/07/07 09:53:41 $
d2477 3
a2479 1
  if ( (prev_op >> 28)         == OP_LDIc       &&	/* previous of is a load (un)conditional	*/
d2483 3
a2485 3
      if (is_op(   curr_op, OP_LDI )		      && /* current op is a load			 */
	  is_mode( curr_op, ADDR_MODE_REGISTER  )     && /* current  operation uses register  addressing */
          dest_of( prev_op ) == source_of( curr_op  ) )	 /* previous op's dest is current op's source	*/
d2557 28
@


1.43
log
@fixed compile time warnings
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.42 $
 * Date :	$Date: 1993/02/22 11:13:09 $
d1240 1
a1240 1
	  move_register( src, dest, FALSE );
d1254 1
a1254 1
	      move_register( src, dest, TRUE );
d1284 1
a1284 1
	  move_register( src, dest + 1, FALSE );	/* NB/ must transfer integer part as well */
@


1.42
log
@Fixed debugging output so that it does not flush after every print
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.41 $
 * Date :	$Date: 1993/01/18 11:27:37 $
d1359 1
a1359 1
	      syserr( "peepholer: maybe_flush_pending_push: unknown push type %x for reg %d",
@


1.41
log
@change as directed by NickC over the phone. Stops multiple adds being combined
erroneously
@
text
@d4 1
a4 1
 * Copyright (c) 1992 Perihelion Software Ltd.
d9 2
a10 2
 * Version :	$Revision: 1.40 $
 * Date :	$Date: 1992/12/07 17:58:27 $
a148 4
  fflush( stderr );
	
  fseek( stderr, 0L, SEEK_END );

a152 2
  fflush( stderr );
	
a191 4
  fflush( asmstream );
	
  fseek( asmstream, 0L, SEEK_END );

a197 2
  fflush( asmstream );
	
d665 3
a667 1
 * prevent any address registers remembering the contents of the given register
@


1.40
log
@fixed peepholer bug
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.41 $
 * Date :	$Date: 1992/12/07 17:57:39 $
d1839 1
@


1.39
log
@fixed bug combining load and store instructions
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.40 $
 * Date :	$Date: 1992/10/30 18:13:54 $
d2228 2
a2229 2
	  reads  &= ~regbit( real_register( dest_of( curr_op ) ) );
	  reads  |=  regbit( real_register( dest_of( prev_op ) ) );
d2232 18
d2251 4
a2254 3
	  SWAP_OPS;
	      
	  peepf( "transformed and swapped register diadic" );
a2256 1
	  ++peep_swapped;
@


1.38
log
@fixed incorrect shifting of RND instruction
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.39 $
 * Date :	$Date: 1992/10/21 07:49:29 $
d2587 16
d2643 1
a2643 1
	      
@


1.37
log
@removed spurious debugging
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.38 $
 * Date :	$Date: 1992/10/20 16:20:59 $
d2216 1
@


1.36
log
@fixed two nefarious bugs
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.37 $
 * Date :	$Date: 1992/10/20 16:15:04 $
a2095 2
	      debug( "old reads = %x, source = %x, prev_op = %x",
		    reads, source_of( prev_op ), prev_op );
a2097 1
	      debug( "new reads = %x", reads );
@


1.35
log
@fixed bug combining floating point loads
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.36 $
 * Date :	$Date: 1992/10/12 15:49:33 $
d2096 5
a2100 2
	      reads  &= ~regbit( dest_of( curr_op ) );
	      reads  |=  regbit( dest_of( prev_op ) );
d2193 2
a2194 2
	      reads &= ~regbit( source_of( curr_op ) );
	      reads |=  regbit( source_of( prev_op ) );
d2230 2
a2231 2
	  reads  &= ~regbit( dest_of( curr_op ) );
	  reads  |=  regbit( dest_of( prev_op ) );
d2410 2
a2411 2
	  peep_buf[ prev ].writes &= ~regbit( dest_of( prev_op ) );
	  peep_buf[ prev ].writes |=  regbit( dest_of( curr_op ) );	  
d2523 1
a2523 1
	      reads  &= ~regbit( dest_of( curr_op ) );	/* no longer reads destination */
@


1.34
log
@fixed bug combining store and load instructions
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.34 $
 * Date :	$Date: 1992/08/04 16:07:19 $
d2127 2
a2128 2
	   !(is_op( curr_op, OP_LDF )		     &&		 /* or they are both not		     */
	     is_op( prev_op, OP_LDF ) ) )             &&	 /* load floats				     */
@


1.33
log
@fixed bug in combine_instructions()
@
text
@d2709 14
d2741 1
@


1.32
log
@fixed compile time warning
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.33 $
 * Date :	$Date: 1992/07/27 16:31:37 $
d2206 1
d2212 5
a2216 4
	  !is_op(  curr_op, OP_SUBF )			&&	/* do not swap LDI/RCPF		*/
	  !is_op(  curr_op, OP_ADDF )			&&	/* do not swap LDI/RCPF		*/
	  !is_op(  curr_op, OP_MPYF )			&&	/* do not swap LDI/RCPF		*/
	  dest_of( prev_op ) == source_of( curr_op )	)
@


1.31
log
@moved memory access peephole prevention
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.31 $
 * Date :	$Date: 1992/07/16 09:21:48 $
d3192 1
a3192 1
      int32		prev;
@


1.30
log
@fixed bug when memory access checks were conflicting with peephole optimisations
@
text
@d1774 10
d1785 1
a1785 1
  if (no_peepholing)
a1870 1
  
d2434 1
a2434 1
#endif
d2443 1
a2443 1
   *    LDI	R0, *AR6
a2572 10
  /*
   * We cannot combine load and store operations if we are generating memory access
   * checks because the compiler caches seperate read and write pointers to the same object,
   * and it might try to store via the write pointer and then read back the same value via
   * the read pointer.  If these two operations were combined into one ...
   */
  
  if (memory_access_checks)
    return FALSE;
  
@


1.29
log
@why do want to know anyway ??
supports new stub generation
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.30 $
 * Date :	$Date: 1992/07/13 08:57:32 $
d2562 10
@


1.28
log
@fixed compile time warnings
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.27 $
 * Date :	$Date: 1992/06/24 17:17:43 $
d1187 8
d3178 2
a3179 2
  if (!in_stubs 	&&	/* do not alter stub generation */
      !no_peepholing 	)	/* only operate if allowed to	*/
@


1.27
log
@fixed bug introduced by previous delta
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.26 $
 * Date :	$Date: 1992/06/24 17:04:58 $
d1061 1
a1061 1
  peepf( "adding push of reg %d (type %d)", reg, type );
d1366 1
a1366 1
	  peepf( "flushed push of reg %d because of clash", reg );
@


1.26
log
@fixed list scanning bug
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.25 $
 * Date :	$Date: 1992/06/24 14:43:56 $
d717 1
a717 1
  while ((pnode = search_list( &addr_regs, register_p, (int)reg )) != NULL)
@


1.25
log
@fixed typo in previous delta
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.24 $
 * Date :	$Date: 1992/06/24 14:39:04 $
d686 1
a686 1
  if ((pnode = search_list( &addr_regs, contents_p, (int)reg )) != NULL)
d717 1
a717 1
  if ((pnode = search_list( &addr_regs, register_p, (int)reg )) != NULL)
@


1.24
log
@removed ST suppression from can_swap()
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.23 $
 * Date :	$Date: 1992/06/19 10:08:56 $
d1396 1
a1396 1
	 int32	b,		/* second instruction 				*/
@


1.23
log
@improved peephole optimisation
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.22 $
 * Date :	$Date: 1992/06/18 10:13:14 $
d1389 2
a1396 1
	 bool	ignore_ST )	/* TRUE if we can safely ignore the ST register */
a1410 20
  if (ignore_ST)
    {
      if ((a_reads  & regbit( RR_ST )) &&
	  (b_writes & regbit( RR_ST )) )
	{
	  return FALSE;
	}      

      if ((b_reads  & regbit( RR_ST )) &&
	  (a_writes & regbit( RR_ST )) )
	{
	  return FALSE;
	}      

      /* we can safely ignore writing to ST */
      
      a_writes &= ~(regbit( RR_ST ));
      b_writes &= ~(regbit( RR_ST ));
    }
  
d1527 1
a1527 1
      if (can_swap( delayed, prev, FALSE ))
d3014 1
a3014 1
      if (can_swap( last, prev, TRUE ))
d3183 4
a3186 4
	  if (num_in_peep_() > 1 		&& /* if there are instructions to swap */
	      is_normal( op_code )		&& /* and first is diadic or triadic	*/
	      is_normal( prev )			&& /* and second is diadic or triadic   */ 
	      can_swap( back1, back2, FALSE )    ) /* and we are allowed to swap them   */
@


1.22
log
@fixed bug in can_swap
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.21 $
 * Date :	$Date: 1992/06/13 15:18:24 $
d2128 3
a2130 1
	  (curr_op >> 23) == (prev_op >> 23)	      &&	/* both loads are the same kind	    	     */
d2134 1
a2134 1
	  if (dest_of( curr_op ) == source_of( prev_op ) )	/* current  op's dest is prev    op's source */
@


1.21
log
@improved debug comments
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.20 $
 * Date :	$Date: 1992/06/11 17:08:21 $
d1412 14
@


1.20
log
@fixed bug with comparison elimination
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.19 $
 * Date :	$Date: 1992/06/05 08:05:34 $
d1048 1
a1048 1
 * The entry is added to the HEAD of the array
d1061 1
a1061 1
  /* debug( "adding push of reg %d (type %d)", reg, type ); */
d1088 1
a1088 1
  
d1102 1
d1346 1
a1346 1
	  /* ignore already emiited pushes */
@


1.19
log
@fixed bug in recoding backward unconditional references
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.18 $
 * Date :	$Date: 1992/05/22 15:30:33 $
d2571 13
d2653 9
d3308 20
a3327 1
	    return TRUE;
d3334 5
a3338 1
	    return TRUE;
@


1.18
log
@improved backward label references
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.17 $
 * Date :	$Date: 1992/05/22 14:38:19 $
a39 20
#define is_op(      instruction, op_code )	 (((instruction) >> 23)        == (op_code))
#define is_mode(    instruction, mode )		((((instruction) >> 21) & 0x3) == (mode))
#define is_diadic(  instruction )		 (((instruction) >> 29)        == 0)
#define is_triadic( instruction )		 (((instruction) >> 29)        == 1)
#define is_normal(  instruction )		 (((instruction) >> 30)        == 0)
#define dest_of(    instruction )		 (((instruction) >> 16) & 0x1f)
#define source_of(  instruction )		  ((instruction) & 0xffff)
#define has_indirect_side_effects( instruction )((((instruction) >> 11) & 0x6) != 0)

#define is_load(    instruction )		(is_op( instruction, OP_LDI ) || \
						 is_op( instruction, OP_LDA ) || \
						 is_op( instruction, OP_LDF ) )

#define is_monadic( instruction )		(is_op( instruction, OP_ABSF  ) || \
						 is_op( instruction, OP_ABSI  ) || \
  						 is_op( instruction, OP_FIX   ) || \
  						 is_op( instruction, OP_FLOAT ) || \
  						 is_op( instruction, OP_NEGF  ) || \
  						 is_op( instruction, OP_NEGI  ) || \
  						 is_op( instruction, OP_NOT   ) )
d1605 1
a1605 1
	  
d2195 4
d2838 2
@


1.17
log
@added new magic peephole
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.16 $
 * Date :	$Date: 1992/05/22 10:32:29 $
d2841 20
a2860 1
	  syserr( "peepholer: instruction referencing already set label" );
a3416 24


/*
 * changes the type of the current (latest) instruction in the peepholer
 */

void
peep_change_type( peep_type type )
{
  int32		op;
  

  if (num_in_peep_() == 0)
    {
      /* oh dear - nothing to change */

      syserr( "peepholer: changing instruction type when peepholer is empty" );
    }
  
  peep_buf[ previous_( peep_end ) ].type = type;
  
  return;
  
} /* peep_change_type */
@


1.16
log
@fixed pushing doubles
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.15 $
 * Date :	$Date: 1992/05/21 14:04:40 $
d3390 1
a3390 1
  /* peepf( "flushed: %s ", reason ); */
d3399 25
@


1.15
log
@fixed bug in peepholer
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.14 $
 * Date :	$Date: 1992/05/18 16:42:58 $
d60 4
d665 32
d1019 1
a1019 1
  
a1121 1
#if 0  
a1122 1
#endif
d1271 3
a1273 1
	  if (is_float( dest ))
a1274 2
	      maybe_flush_pending_push( dest );
	      
d1297 14
a1310 27
	  if (is_float( dest ))
	    {
	      /* we are about to corrupt dest, so make sure that we are not pushing it */
	      
	      maybe_flush_pending_push( dest );
	      maybe_flush_pending_push( dest + 1 );

	      fpush( src );
	      ipop(  dest );				/* big endian doubles */

	      move_register( src, dest + 1, FALSE );	/* NB/ must transfer integer part as well */
	      
	      peepf( "transformed double push/pop pair" );
	      
	      ++peep_transformed;
	      ++peep_eliminated;
	    }
	  else
	    {
	      if (stack_move < 0)
		correct_stack( FALSE );

	      dpush( src );

	      ipop( dest );		/* big endian doubles */
	      ipop( dest + 1 );
	    }
@


1.14
log
@fixed bug in half pushing registers
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.13 $
 * Date :	$Date: 1992/05/13 14:26:20 $
d52 8
d1086 1
a1086 1
  
d1088 1
d1164 1
a1164 1
  if (type == PUSH_DOUBLE && can_pop_double == 0 && src != GAP)
d1170 6
a1175 1
      ipush( src );
d1177 1
a1177 1
  
a1383 3



d1885 1
a1885 1
      dest    = (curr_op >> 16) & 0x1f;
d1924 1
a1924 1
	       * followed by a register based diadic op with
d1934 2
a1935 1
	      if (source_of( curr_op ) == dest_of( curr_op ))
d1960 6
d1991 4
a1994 1
		    prev_op & 0x001f0000U | (prev_op & 0x1f) << 8 | (curr_op & 0x1f);
d2002 1
a2002 1
		  
d2572 1
a2572 1
	      if (((prev_op >> 16) & 0x1F) == ((curr_op >> 16) & 0x1F))
d2609 1
a2609 1
	      if (((prev_op >> 16) & 0x1F) != ((curr_op >> 16) & 0x1F))
@


1.13
log
@ammended to work with new version of mcdpriv.h
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.12 $
 * Date :	$Date: 1992/05/07 07:33:41 $
d550 2
d592 2
a593 1
  
d653 313
d1023 351
a2851 661


/* ---------------------- ADDRESS REGISTER PEEPHOLING ---------------------------------- */

/*
 * prevent any address registers remembering the contents of the given register
 */

void
peep_forget_about( RealRegister reg )
{
   Node *	pnode;


  if ((pnode = search_list( &addr_regs, contents_p, (int)reg )) != NULL)
    {
      forget( (addr_reg *)pnode );
      
      if (node_count > 1)
	{
	  /* move the node to the end of the list, so that it will be used again soon */
	  
	  remove_node( pnode );

	  add_tail( &addr_regs, pnode );
	}
    }

  return;
  
} /* peep_forget_about */


/*
 * locate the structure for the given address register, and clear it
 */

void
peep_corrupt_addr_reg( RealRegister reg )
{
  Node *	pnode;


  /* locate the register mentioned */
   
  if ((pnode = search_list( &addr_regs, register_p, (int)reg )) != NULL)
    {
      /* forget about the contents of the register */
      
      forget( (addr_reg *)pnode );

      if (node_count > 1)
	{
	  /* move the node to the end of the list, so that it will be used again soon */
	  
	  remove_node( pnode );

	  add_tail( &addr_regs, pnode );
	}
    }

  return;
  
} /* peep_corrupt_addr_reg */


/*
 * indicate that all of the address registers (may) have been corrupted
 */

void
peep_corrupt_all_addr_regs( void )
{
  walk_list( &addr_regs, forget );

  return;
  
} /* peep_corrupt_all_addr_regs */
  

/*
 * inform the peepholer that the given address register
 * has been loaded with the word offset equivalent of
 * the contents of the given register, offset by the
 * given amount (in words), and possibly biased by the
 * contents of the base addressing register
 */

void
peep_note_addr_reg_loaded(
			  RealRegister	reg,		/* address register that has been loaded 	*/
			  RealRegister	contents,	/* register whoes contents have been loaded	*/
			  int32		offset,		/* word offset applied to the 'contents'	*/
			  bool		biased )	/* non-zero if 'contents' has had R_BASE added	*/
{
  Node *	pnode;


  if ((pnode = search_list( &addr_regs, register_p, (int)reg )) != NULL)
    {
      ((addr_reg *)pnode)->contents = contents;
      ((addr_reg *)pnode)->offset   = offset;
      ((addr_reg *)pnode)->biased   = biased;

      if (node_count > 1)
	{
	  /* the node has been used, so put it at the head of the list */

	  remove_node( pnode );
	  
	  add_head( &addr_regs, pnode );
	}
    }

  /* it is not an error for no match to be found */
  
  return;
    
} /* peep_note_addr_reg_loaded */


/*
 * determines if the indicated register in loaded into an
 * address register, and returns the relevant register if
 * it has been found, as well as setting up the return
 * values for the offset and bias.  Returns GAP (and does
 * not set offset and bias) if no register could be found.
 */

RealRegister
peep_find_loaded_addr_reg(
			  RealRegister	contents,		/* register whoes contents are sought	*/
			  int32 *	offset_return,		/* return value for offset included	*/
			  bool *	biased_return )		/* return value indicating bias status	*/
{
   Node *	pnode;


  if ((pnode = search_list( &addr_regs, contents_p, (int)contents )) != NULL)
    {
      if (offset_return != NULL)
	*offset_return = ((addr_reg *)pnode)->offset;

      if (biased_return != NULL)
	*biased_return = ((addr_reg *)pnode)->biased;

      return ((addr_reg *)pnode)->addr_reg;
    }

  return GAP;
  
  
} /* peep_find_loaded_addr_reg */
  

/*
 * returns the least recently used address
 * register that is not 'excludes'.  Returns
 * GAP upon failure
 */

RealRegister
peep_get_free_addr_reg( RealRegister exclude )
{
  Node *	pnode;
  addr_reg *	reg;
  

  if (node_count > 1)
    {
      if (exclude == GAP)
	{
	  /* remove the last node from the list */
	  
	  pnode = remove_tail( &addr_regs );
#ifdef DEBUG
	  if (pnode == NULL)
	    syserr( "peepholer: urg urg" );
#endif
	  reg = (addr_reg *)pnode;
	}
      else
	{
	  /* examine last node on list */
	  
	  pnode = last_node( &addr_regs );
#ifdef DEBUG
	  if (pnode == NULL)
	    syserr( "peepholer: urg urg 2" );
#endif
	  reg = (addr_reg *)pnode;
	  
	  if (reg->addr_reg == exclude)
	    {
	      pnode = previous_node( pnode );
#ifdef DEBUG
	      if (pnode == NULL)
		syserr( "peepholer: urg" );
#endif  
	      remove_node( pnode );

	      reg = (addr_reg *)pnode;
	    }
	  else
	    {
	      pnode = remove_tail( &addr_regs );
#ifdef DEBUG
	      if (pnode == NULL)
		syserr( "peepholer: urg urg 3" );
#endif
	    }
	}

      /* place removed node at start of list */
      
      add_head( &addr_regs, pnode );
    }
  else
    {
      pnode = first_node( &addr_regs );

#ifdef DEBUG
      if (pnode == NULL)
	syserr( "peepholer: urg urg 4" );
#endif
      
      reg = (addr_reg *)pnode;
      
      if (reg->addr_reg == exclude)
	{
	  return GAP;
	}
    }

  /* invalidate contents of address register */
  
  reg->contents = GAP;

  if (!reg->noted)
    {
      augment_RealRegSet( &regmaskvec, reg->addr_reg );

      reg->noted = TRUE;
    }

  return reg->addr_reg;
    
} /* peep_get_free_addr_reg */

  
/*
 * initialise the queue of available address registers
 */

void
peep_init_addr_regs( int32 reg_mask )
{
  static bool	inited = FALSE;

  
  if (!inited)
    {
      /* initialise the address register structures */

      ar0.addr_reg = RR_AR0;
      ar1.addr_reg = RR_AR1;
      ar2.addr_reg = RR_AR2;
      ar3.addr_reg = RR_AR3;
      ar5.addr_reg = R_ATMP;

      inited = TRUE;
    }

  /* empty the register list */
  
  init_list( &addr_regs );

  node_count = 0;
  
  /* register AR5 is always available */

  init_reg( &ar5 );
  
  ar5.noted = TRUE;	/* never tell front end about our use of this register */
  
  if (no_peepholing)
    return;
  
  /* check the other address registers */
  
  if (!(reg_mask & regbit( RR_AR0 )))
    {
      init_reg ( &ar0 );
    }
  
  if (!(reg_mask & regbit( RR_AR1 )))
    {
      init_reg( &ar1 );
    }
  
  if (!(reg_mask & regbit( RR_AR2 )))
    {
      init_reg( &ar2 );
    }
  
  if (!(reg_mask & regbit( RR_AR3 )))
    {
      init_reg( &ar3 );
    }

  return;
  
} /* peep_init_addr_regs */


/* ------------------------------ PUSH PEEPHOLING ----------------------------- */

/*
 * add an entry in the pending pushes array
 * The entry is added to the HEAD of the array
 */

void
add_pending_push(
		 RealRegister	reg,	/* the register to be pushed 		*/
		 push_type	type )	/* the kind of push being performed	*/
{
  pending_push *	push;

  
  /* check that there is room */

  /* debug( "adding push of reg %d (type %d)", reg, type ); */

  push = (pending_push *)remove_head( &free_pending_pushes );

  if (push == NULL)
    {
      push = (pending_push *)GlobAlloc( SU_Other, sizeof (pending_push) );
  
      if (push == NULL)
	{
	  syserr( "peepholer: add_pending_push: out of memory" );
	}
    }

  /* adjust the stack offset (BEFORE adding the pending push) */
  
  if (stack_move != 0)
    {
      correct_stack( FALSE );
    }
  
  /* add the push to the pending queue */

  push->reg  = reg;
  push->type = type;
  
  add_tail( &pending_pushes, (Node *)push );
  
  /* adjust the stack offset - XXX why ? */
  
  switch (type)
    {
    case PUSH_INT:	stack_offset += sizeof_int;    break;
    case PUSH_FLOAT:	stack_offset += sizeof_float;  break;
    case PUSH_DOUBLE:	stack_offset += sizeof_double; break;
    default:
      syserr( "peepholer: add_pending_push: unknown push type" );
      break;
    }

  /* if we are not peepholing then emit this push immediately */
  
  if (no_peepholing)
    {
      flush_pending_pushes();
    }

  return;
  
} /* add_pending_push */


/*
 * removes a pending push into register 'reg'
 * returns number of registers poped
 */

int
pop_pending_push(
		 RealRegister	dest,			/* register into which stack value should be placed */
		 bool		can_pop_double )	/* non-zero if two words can be popped */
{
  pending_push *	push;
  RealRegister		src;
  push_type		type;
  

  /* get the last pending push */
  
  push = (pending_push *)remove_tail( &pending_pushes );
  
  if (push == NULL)
    {
      /* if there are no pushes pending then just pop */

      ipop( dest );

      stack_offset -= sizeof_int;

      /* debug( "pop into reg %d, (none stacked)", dest ); */
      
      return 1;
    }
  else
    {
      /* note that this node is now free */
      
      add_tail( &free_pending_pushes, (Node *)push );
    }

  src  = push->reg;
  type = push->type;
  
  /* adjust the stack offset */
  
  switch (type)
    {
    case PUSH_INT:	stack_offset -= sizeof_int;    break;
    case PUSH_FLOAT:	stack_offset -= sizeof_float;  break;
    case PUSH_DOUBLE:	stack_offset -= sizeof_double; break;
    default:
      syserr( "peepholer: pop_pending_push: unknown push type" );
      break;
    }

  /*
   * XXX - NC - 4/2/92
   *
   * Believe it or not, the compiler can ask us to
   * push a double and then pop "half" of it into
   * register!  try the following code ...
   *
   *  func( 1, 2.0, 3,0 );
   *
   * So we must catch the case where we want to pop
   * a double, but only a single word is required
   */
  
  if (type == PUSH_DOUBLE && can_pop_double == 0)
    {
      stack_offset += sizeof_float;

      type = PUSH_FLOAT;
    }
  
  if (dest == src)
    {
      /* push followed by pop into same register */

      peepf( "eliminated push/pop pair" );

      if (type == PUSH_DOUBLE)
	{
	  peep_eliminated += 4;
      
	  return 2;
	}
      else
	{
	  peep_eliminated += 2;
	  
	  return 1;
	}
    }
  else if (src == GAP)
    {
      /* we have already pushed the register - now pop it */

      /*
       * NB/ we never really pop floats and doubles -
       * this is only ever done when we want to put FP
       * values into INT registers
       */
      
      /* debug( "pop type %d into reg %d", type, dest ); */
      
      switch (type)
	{
	case PUSH_INT:	  ipop( dest ); return 1;
	case PUSH_FLOAT:  ipop( dest ); return 1;
	case PUSH_DOUBLE: ipop( dest ); ipop( dest + 1 ); return 2;	  
	}
    }
  else
    {
      /* push from one register, pop into another */
      
      /* debug( "reg transfer type %d from %d into reg %d", type, src, dest ); */
      
      switch (type)
	{
	case PUSH_INT:
	  maybe_flush_pending_push( dest );
	  
	  move_register( src, dest, FALSE );
	      
	  peepf( "transformed integer push/pop pair" );

	  ++peep_transformed;
	  ++peep_eliminated;
	  
	  return 1;
	  
	case PUSH_FLOAT:
	  if (is_float( dest ))
	    {
	      maybe_flush_pending_push( dest );
	      
	      move_register( src, dest, TRUE );
	      
	      peepf( "transformed float push/pop pair" );

	      ++peep_transformed;
	      ++peep_eliminated;
	    }
	  else
	    {
	      if (stack_move < 0)
		correct_stack( FALSE );

	      /* push floating point value, but pop an integer */

	      fpush( src );

	      ipop( dest );
	    }	  

	  return 1;
	  
	case PUSH_DOUBLE:
	  if (is_float( dest ))
	    {
	      /* we are about to corrupt dest, so make sure that we are not pushing it */
	      
	      maybe_flush_pending_push( dest );
	      maybe_flush_pending_push( dest + 1 );

	      fpush( src );
	      ipop(  dest );				/* big endian doubles */
	      move_register( src, dest + 1, FALSE );	/* NB/ must transfer integer part as well */
	      
	      peepf( "transformed double push/pop pair" );
	      
	      ++peep_transformed;
	      ++peep_eliminated;
	    }
	  else
	    {
	      if (stack_move < 0)
		correct_stack( FALSE );

	      dpush( src );

	      ipop( dest );		/* big endian doubles */
	      ipop( dest + 1 );
	    }
	  
	  return 2;
	}
    }

  return 0;
  
} /* pop_pending_push */


/*
 * flushes all pending pushes, (in order)
 */

void
flush_pending_pushes( void )
{
  walk_list( &pending_pushes, flush_push );
  
  return;
  
} /* flush_pending_pushes */


/*
 * flushes any pending pushes if they
 * push register 'reg'
 */

void
maybe_flush_pending_push( RealRegister reg )
{
  Node *	pnode;


  /* see if the register should be pushed */
  
  pnode = search_list( &pending_pushes, push_reg_p, (int)reg );

  /* if so then emit all the pending pushes up to and including the located one */
  
  if (pnode)
    {
      pending_push *	push;

      
      /* flush back to pnode */

      for (push  = (pending_push *)first_node( &pending_pushes );
	   push != NULL;
	   push  = (pending_push *)next_node( (Node *)push ))
	{
	  reg = push->reg;

	  /* ignore already emiited pushes */
      
	  if (reg == GAP)
	    continue;

	  /* push the register */

	  /* debug( "flush push of reg %d because of clash", reg ); */
	  
	  switch (push->type)
	    {
	    case PUSH_INT:	ipush( reg ); break;
	    case PUSH_FLOAT:	fpush( reg ); break;
	    case PUSH_DOUBLE:	dpush( reg ); break;
	    default:
	      syserr( "peepholer: maybe_flush_pending_push: unknown push type %x for reg %d",
		     push->type, reg );
	      break;
	    }

	  peepf( "flushed push of reg %d because of clash", reg );
  
	  /* mark this push as having been emitted */
	  
	  push->reg = GAP;

	  /* if we have reached the located node then stop */
	  
	  if (push == (pending_push *)pnode)
	    break;
	}
    }

  return;
  
} /* maybe_flush_pending_push */


/* ------------------------- INSTRUCTION PEEPHOLING ------------------------- */
@


1.12
log
@minor cosmetic change
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.11 $
 * Date :	$Date: 1992/05/02 12:25:08 $
d21 1
a21 2
#include "mcdpriv.h"	/* for FALSE     */
#include "xrefs.h"	/* for codexrefs */
a99 1
/* external functions */
a100 14
extern signed long	mask_and_sign_extend_word( unsigned long, unsigned long );
extern void		decode_instruction( int32, bool );
extern int32		hardware_register( RealRegister );
extern int32		build_op( int32, int32, RealRegister, int32 );
extern void		correct_stack( bool );
void			move_register( RealRegister, RealRegister, bool );
void			ipop(  RealRegister );
void			ipush( RealRegister );
void			fpush( RealRegister );
void			dpush( RealRegister );
bool			is_C40_float_register( RealRegister );
RealRegister		real_register( int32  );


a126 3
extern int32		stack_move;
extern int32		stack_offset;

d197 1
a197 2
  if (asmstream == NULL ||
      (feature & FEATURE_ANNOTATE) == 0)
d1449 1
a1449 1
		   * is dead at the end of the load just eliminated. therefore
d2056 1
a2056 1
  if (asmstream != NULL && (feature & FEATURE_ANNOTATE))
d3121 1
a3121 1
	      if (asmstream != NULL && num_in_peep_() > 1 && (feature & FEATURE_ANNOTATE))
@


1.11
log
@added another peephole optimisation
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.10 $
 * Date :	$Date: 1992/05/02 11:48:07 $
d1777 1
a1777 1
  if ((prev_op >> 28) == OP_LDIc                &&	/* previous of is a load (un)conditional	*/
@


1.10
log
@added another peephole optimisation
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.9 $
 * Date :	$Date: 1992/05/02 11:34:04 $
d1855 25
@


1.9
log
@added new peephole
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.8 $
 * Date :	$Date: 1992/05/01 12:35:31 $
d1425 14
@


1.8
log
@minor cosmetic changes
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.7 $
 * Date :	$Date: 1992/05/01 09:25:25 $
d1251 1
a1251 1
  if (is_load( prev_op )			&&	/* prev_op is one of LDI, LDA, LDF	*/
d1428 4
a1431 3
      if (is_op(   prev_op, OP_LDI )                  &&	/* make sure our knowledge of prev is OK     */
	  is_op(   curr_op, OP_LDI )                  &&	/* current  operation is an integer load     */
	  is_mode( curr_op, ADDR_MODE_REGISTER )      &&	/* current  operation is register based      */	
d1450 21
@


1.7
log
@minor cosmetic changes
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.6 $
 * Date :	$Date: 1992/04/28 17:04:58 $
a876 2
	  /* IOdebug( "Peep: eliminate: eliminating" ); */
	  
a885 2
	  /* IOdebug( "Peep: eliminate: eliminated" ); */

@


1.6
log
@minor cosmetic changes
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.5 $
 * Date :	$Date: 1992/04/27 16:32:22 $
d18 2
a35 1
#define PUSH_ARRAY_SIZE	20
d68 1
a68 1
list;
d83 3
a85 2
    RealRegister	reg;
    push_type		type;
d91 7
a97 7
    peep_type		type;		/* e.g. OUT_INSTR 			 */
    int32 		op_code;	/* 32 bits of machine instruction	 */
    int32 		reads;		/* registers accessed 			 */
    int32 		writes;		/* registers clobbered			 */
    Symstr *		symbol;		/* external symbol       (if needed) 	 */
    int32 		reftype;	/* symbol reference type (if needed) 	 */
    LabelNumber *	label;		/* label                 (if needed) 	 */
d117 1
a117 1
/* variables */
d122 1
d131 6
a136 3
static int		peep_pending_swaps = 0;		/* number of forward intrs to swap		*/	
static pending_push	pending_pushes[ PUSH_ARRAY_SIZE ];	/* array of pending pushes		*/
static int		pend_push_free = 0;		/* next free slot in pending_pushes array 	*/
d148 46
d318 1
a318 1
  
d325 37
d374 1
a374 1
      syserr( "peepholer: passed NULL parameter to remove_tail" );
a379 1
#ifdef DEBUG
d382 3
a384 1
      syserr( "peepholer: no nodes on list for remove_tail" );
a385 1
#endif  
d433 1
a433 1
  
d460 23
d495 2
d511 1
a511 1
	  list *	plist,			/* list to scan				*/
d668 15
d684 43
d877 2
d888 2
d927 1
a927 1
		syserr( "back end: peepholer: no offset in branch!" );
d949 1
a949 1
	    syserr( "back end: peepholer: no offset in branch!" );
d2079 1
a2079 1
      syserr( "back end: peepholer: asked to emit an unknown type %d", instruction->type );
d2095 1
a2095 1
	  syserr( "back end: peepholed instruction referencing already set label" );
d2323 1
a2323 1

d2325 2
a2326 2
	    syserr( "urg urg" );

d2334 1
a2334 1

d2336 2
a2337 2
	    syserr( "urg urg 2" );

d2343 1
a2343 1

d2346 1
a2346 1
	      
d2354 1
a2354 1
	      
d2356 2
a2357 1
		syserr( "urg urg 3" );
d2369 1
d2371 2
a2372 1
	syserr( "urg urg 4" );
d2467 1
d2475 3
d2480 7
a2486 1
  /* peepf( "adding push of reg %d (type %d)", reg, type ); */
d2488 4
a2491 5
  if (pend_push_free == PUSH_ARRAY_SIZE)
    {
      syserr( "back end: add_pending_push: array overflow" );

      return;
d2501 6
a2506 1
  /* add the push to the pending array */
a2507 4
  pending_pushes[ pend_push_free ].reg  = reg;
  pending_pushes[ pend_push_free ].type = type;
  pend_push_free++;

d2516 1
a2516 1
      syserr( "back end: add_pending_push: unknown push type" );
d2542 3
a2544 2
  RealRegister	src;
  push_type	type;
d2547 5
a2551 1
  if (pend_push_free == 0)
d2558 2
d2563 6
d2570 3
a2572 3
  src  = pending_pushes[ --pend_push_free ].reg;
  type = pending_pushes[   pend_push_free ].type;

d2581 1
a2581 1
      syserr( "back end: pop_pending_push: unknown push type" );
d2634 2
d2647 2
d2726 3
a2728 1
/* empties the pending pushes array */
d2733 1
a2733 29
  int	i;


  for (i = pend_push_free; i--;)
    {
      RealRegister	reg = pending_pushes[ i ].reg;
      

      /* ignore already removed pushes */
      
      if (reg == GAP)
	continue;

      /* push the registers in order */
      
      switch (pending_pushes[ i ].type)
	{
	case PUSH_INT:		ipush( reg ); break;
	case PUSH_FLOAT:	fpush( reg ); break;
	case PUSH_DOUBLE:	dpush( reg ); break;
	default:
	  syserr( "back end: flush_pending_pushes: unknown push type" );
	  break;
	}

      /* peepf( "forced flush of push of reg %d", reg ); */
    }

  /* reset pending array */
a2734 2
  pend_push_free = 0;

d2748 1
a2748 1
  signed int	i;
d2751 3
a2753 5
  for (i = pend_push_free; i--;)
    {
      if (pending_pushes[ i ].reg == reg)
	break;
    }
d2755 3
a2757 1
  if (i >= 0)
d2759 1
a2759 1
      int	j;
d2762 1
a2762 1
      /* flush back to i */
d2764 3
a2766 1
      for (j = pend_push_free; j-- > i;)
d2768 1
a2768 2
	  RealRegister	reg = pending_pushes[ j ].reg;
      
d2770 1
a2770 1
	  /* ignore already removed pushes */
d2775 1
a2775 1
	  /* push the registers in order */
d2777 3
a2779 1
	  switch (pending_pushes[ j ].type)
d2785 2
a2786 1
	      syserr( "back end: maybe_flush_pending_push: unknown push type" );
d2790 1
a2790 1
	  /* peepf( "flushed push of reg %d because of clash", reg ); */	
d2792 1
a2792 1
	  /* mark this push as having been removed */
d2794 6
a2799 1
	  pending_pushes[ j ].reg = GAP;
d2993 1
a2993 1
	  syserr( "back end: peepholer: pending forward and cross references for same instruction!" );
d3022 1
a3022 1
	  syserr( "back end: peepholer: special instruction type had a pending cross reference!" );
d3037 1
a3037 1
	  syserr( "back end: peepholer: special instruction type had a pending forward reference!" );
d3259 1
a3259 1
      syserr( "back end: peepholer: attempting to eliminate instruction whilst a reference is still pending" );
d3274 1
a3274 1
  syserr( "back end: peepholer: trying to eliminate non-existant register transfer" );
d3292 1
a3292 1
      syserr( "back end: peepholer: attempting to flush peepholer whilst a cross ref is still pending" );
d3297 1
a3297 1
      syserr( "back end: peepholer: attempting to flush peepholer whilst a forward ref is still pending" );
d3315 1
a3315 3
/*
 * INITIALISATION
 */
d3329 4
@


1.5
log
@fixed bug in peep_get_free_addr_reg()
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.4 $
 * Date :	$Date: 1992/04/24 14:55:01 $
d14 4
d157 7
d204 7
d229 7
d255 8
a263 1
  pnode->next       = (Node *)&plist->earth;
d282 7
d290 2
a291 1
  
d293 4
a296 1
    return NULL;
d298 1
a298 1
  pnode->prev->next = (Node *)plist->earth;
a306 1

d314 7
d336 1
d341 1
a341 1
      return NULL;
d343 2
a344 1

a348 1

d356 1
d361 1
a361 1
      return NULL;
d363 2
a364 1

d377 1
d382 1
a382 1
      return NULL;
d384 2
a385 1

d404 7
d438 7
d465 8
a472 4
  if (((addr_reg *)pnode)->addr_reg == (RealRegister)reg)
    return TRUE;

  return FALSE;
d486 8
a493 2
  if (((addr_reg *)pnode)->contents == (RealRegister)reg)
    return TRUE;
a494 2
  return FALSE;
  
d504 7
d527 7
a553 1

a606 1

d645 1
a645 1
  if (no_peepholing)
d1836 1
a1836 1
  peep_data	tmp = peep_buf[ a ];
d1838 2
d1875 2
a1876 1
  
d1879 1
a1879 1
      cc_warn( "peepholer: attempting to emit from EMPTY peepholer!" );
d1883 2
a1884 1

d1974 1
a1974 3
/*
 * ADDRESS REGISTER PEEPHOLING
 */
d2012 1
a2012 1
   Node *	pnode;
d2015 1
a2015 1
   /* locate the register mentioned */
d2198 3
a2200 1
	return GAP;
d2284 1
a2284 3
/*
 * PUSH PEEPHOLING
 */
d2620 2
a2621 3
/*
 * INSTRUCTION PEEPHOLING
 */
d2639 1
d2771 3
a2773 1
	return;
a2948 1
  
d3127 30
@


1.4
log
@increased push stack size
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.3 $
 * Date :	$Date: 1992/04/24 10:59:53 $
d23 1
d72 1
d438 28
d2047 2
a2048 1

d2060 2
d2072 3
a2074 1
	  if (((addr_reg *)pnode)->addr_reg == exclude)
d2082 2
d2105 3
a2107 1
      if (((addr_reg *)pnode)->addr_reg == exclude)
d2113 5
a2117 1
  ((addr_reg *)pnode)->contents = GAP;
d2119 4
a2122 1
  return ((addr_reg *)pnode)->addr_reg;
d2126 1
a2126 1

d2154 2
d2157 2
d2160 2
a2161 6
  forget( &ar5 );

  add_tail( &addr_regs, (Node *)(&ar5) );

  node_count = 1;

d2169 1
a2169 5
      forget( &ar0 );

      add_tail( &addr_regs, (Node *)(&ar0) );

      ++node_count;
d2174 1
a2174 5
      forget( &ar1 );

      add_tail( &addr_regs, (Node *)(&ar1) );

      ++node_count;
d2179 1
a2179 5
      forget( &ar2 );

      add_tail( &addr_regs, (Node *)(&ar2) );

      ++node_count;
d2184 1
a2184 5
      forget( &ar3 );

      add_tail( &addr_regs, (Node *)(&ar3) );

      ++node_count;
@


1.3
log
@tidied up
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.2 $
 * Date :	$Date: 1992/04/23 17:12:14 $
d29 1
a29 1
#define PUSH_ARRAY_SIZE	10
@


1.2
log
@added peepholing code from gen.c
@
text
@d9 2
a10 2
 * Version :	$Revision: 1.1 $
 * Date :	$Date: 1992/04/23 16:14:07 $
d22 1
d93 1
d95 14
d1857 1
a1857 1
 * forget the contents on the given register
d1861 1
a1861 1
peep_forget( RealRegister reg )
d1869 9
d1882 1
a1882 1
} /* peep_forget */
d1890 1
a1890 1
peep_corrupt( RealRegister reg )
d1895 2
d1899 2
d1902 9
d1915 1
a1915 1
} /* peep_corrupt */
d1923 1
a1923 1
peep_corrupt_all( void )
d1929 1
a1929 1
} /* peep_corrupt_all */
d1941 5
a1945 5
peep_addr_reg_loaded(
		     RealRegister	reg,		/* address register that has been loaded 	*/
		     RealRegister	contents,	/* register whoes contents have been loaded	*/
		     int32		offset,		/* word offset applied to the 'contents'	*/
		     bool		biased )	/* non-zero if 'contents' has had R_BASE added	*/
d1947 1
a1947 1
   Node *	pnode;
d1966 2
d1970 1
a1970 1
} /* peep_addr_reg_loaded */
d1982 4
a1985 4
peep_reg_is_loaded(
		   RealRegister	contents,		/* register whoes contents are sought	*/
		   int32 *	offset_return,		/* return value for offset included	*/
		   bool *	biased_return )		/* return value indicating bias status	*/
d2004 1
a2004 1
} /* peep_reg_is_loaded */
d2014 1
a2014 1
peep_get_address_reg( RealRegister exclude )
d2078 1
a2078 1
} /* peep_get_address_reg */
d2562 71
a2970 71


/*
 * Try to push the latest instruction in the peepholer back
 * by the number of instructions indicated.  Returns the
 * actual number of instructions skipped.
 */

int
peep_shift_back( int n )
{
  signed int	prev;
  signed int	last;
  int		done;
  
  
  /* check that we can move the instructions */
  
  if (xref_pending || fref_pending || peep_end == peep_start || n < 1)
    {
      return 0;
    }

  /* get last instruction */
  
  last = prev = previous_( peep_end );

  /* initialise count of successful swaps */
  
  done = 0;
  
  /* examine previous instructions */
  
  while (prev != peep_start && n--)
    {
      prev = previous_( prev );

      if (can_swap( last, prev, TRUE ))
	{
	  /* swap the two instructions */

	  peep_swap( last, prev, "backwards pipeline conflict avoidance" );
	  
	  /* update pointer to the "last" instruction */
	  
	  last = prev;

	  /* increment count */
	  
	  done++;
	}
      else
	{
#if 0
	  fprintf( asmstream, "; peepholer: could not swap " );

	  decode_instruction(  peep_buf[ last ].op_code, FALSE );

	  fprintf( asmstream, " with " );
	  
	  decode_instruction( peep_buf[ prev ].op_code, FALSE );

	  fprintf( asmstream, "\n" );
#endif	  
	  return done;
	}
    }

  return done;
  
} /* peep_shift_back */
@


1.1
log
@Initial revision
@
text
@d9 2
a10 2
 * Version :	$Revision$
 * Date :	$Date$
a13 6
#include "host.h"	/* for int32 */
#include "target.h"	/* for register aliases */
#include "defs.h"	/* for cgdefs.h */
#include "cgdefs.h"	/* for int32, RealRegister */
#include "globals.h"
#include "mcdpriv.h"	/* for FALSE */
d15 7
d23 23
d73 18
d92 1
d98 60
d159 3
d163 4
a166 1
/* local functions */
d168 3
a170 1
/* initialise a list (to empty) */
d184 3
a186 1
/* adds a node onto the front of a list */
d203 3
a205 1
/* adds a node onto the back of a list */
d222 3
a224 1
/* removes the last node from a list, and returns it */
d247 3
a249 1
/* removes a node from a list */
d262 3
a264 1
/* returns the first node in a list or NULL */
d281 3
a283 1
/* returns the last node in a list or NULL */
d300 3
a302 1
/* returns the node prior to the given one */
d318 1
d370 36
a405 1
/* forget about the contents of the given address register */
d419 82
a500 1
/* returns true if the given node matches the given register */
d503 249
a751 3
register_p(
	   Node *	pnode,
	   int		reg )
d753 8
a760 2
  if (((addr_reg *)pnode)->addr_reg == (RealRegister)reg)
    return TRUE;
d764 8
a771 1
} /* register_p */
d773 11
a784 1
/* returns true if the given node holds the given register */
d787 4
a790 3
contents_p(
	   Node *	pnode,
	   int		reg )
d792 898
a1689 2
  if (((addr_reg *)pnode)->contents == (RealRegister)reg)
    return TRUE;
d1693 137
a1829 1
} /* contents_p */
d1831 3
d1836 3
a1838 1
/* exported functions */
d1840 3
a1842 1
/* forget the contents on the given register */
d1860 3
a1862 1
/* locate the structure for the given address register, and clear it */
d1880 4
d1894 8
d1904 4
a1907 4
		     RealRegister	reg,
		     RealRegister	contents,
		     int32		offset,
		     bool		biased )
d1943 3
a1945 3
		   RealRegister	contents,
		   int32 *	offset_return,
		   bool *	biased_return )
d2041 3
a2043 1
/* initialise the queue of available address registers */
d2120 846
a2965 1
   
@
