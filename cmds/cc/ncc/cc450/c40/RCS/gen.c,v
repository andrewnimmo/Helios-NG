head	1.267;
access;
symbols
	beta_release:1.198;
locks; strict;
comment	@ * @;


1.267
date	94.01.04.14.21.15;	author nickc;	state Exp;
branches;
next	1.266;

1.266
date	93.09.20.10.23.54;	author nickc;	state Exp;
branches;
next	1.265;

1.265
date	93.08.05.08.30.15;	author nickc;	state Exp;
branches;
next	1.264;

1.264
date	93.08.04.16.59.12;	author nickc;	state Exp;
branches;
next	1.263;

1.263
date	93.08.04.10.53.30;	author nickc;	state Exp;
branches;
next	1.262;

1.262
date	93.08.03.15.24.05;	author nickc;	state Exp;
branches;
next	1.261;

1.261
date	93.07.29.13.35.35;	author nickc;	state Exp;
branches;
next	1.260;

1.260
date	93.07.27.11.12.49;	author nickc;	state Exp;
branches;
next	1.259;

1.259
date	93.07.27.09.19.19;	author nickc;	state Exp;
branches;
next	1.258;

1.258
date	93.07.22.10.05.15;	author nickc;	state Exp;
branches;
next	1.257;

1.257
date	93.07.19.11.23.21;	author nickc;	state Exp;
branches;
next	1.256;

1.256
date	93.07.15.16.47.51;	author nickc;	state Exp;
branches;
next	1.255;

1.255
date	93.07.09.10.49.52;	author nickc;	state Exp;
branches;
next	1.254;

1.254
date	93.07.08.12.35.05;	author nickc;	state Exp;
branches;
next	1.253;

1.253
date	93.07.08.08.26.52;	author nickc;	state Exp;
branches;
next	1.252;

1.252
date	93.07.07.08.42.52;	author nickc;	state Exp;
branches;
next	1.251;

1.251
date	93.07.06.14.16.01;	author nickc;	state Exp;
branches;
next	1.250;

1.250
date	93.06.23.16.05.19;	author nickc;	state Exp;
branches;
next	1.249;

1.249
date	93.06.08.16.07.37;	author nickc;	state Exp;
branches;
next	1.248;

1.248
date	93.04.28.10.06.30;	author nickc;	state Exp;
branches;
next	1.247;

1.247
date	93.03.31.16.36.21;	author nickc;	state Exp;
branches;
next	1.246;

1.246
date	93.03.16.10.40.16;	author nickc;	state Exp;
branches;
next	1.245;

1.245
date	93.03.16.10.25.45;	author nickc;	state Exp;
branches;
next	1.244;

1.244
date	93.03.15.17.23.11;	author nickc;	state Exp;
branches;
next	1.243;

1.243
date	93.02.22.11.09.38;	author nickc;	state Exp;
branches;
next	1.242;

1.242
date	93.01.12.10.39.25;	author nickc;	state Exp;
branches;
next	1.241;

1.241
date	92.12.16.20.09.37;	author nickc;	state Exp;
branches;
next	1.240;

1.240
date	92.12.09.10.32.51;	author nickc;	state Exp;
branches;
next	1.239;

1.239
date	92.12.04.09.07.38;	author nickc;	state Exp;
branches;
next	1.238;

1.238
date	92.12.03.19.05.36;	author nickc;	state Exp;
branches;
next	1.237;

1.237
date	92.11.30.15.37.01;	author nickc;	state Exp;
branches;
next	1.236;

1.236
date	92.11.11.09.19.17;	author nickc;	state Exp;
branches;
next	1.235;

1.235
date	92.11.04.18.05.51;	author nickc;	state Exp;
branches;
next	1.234;

1.234
date	92.11.04.17.36.35;	author nickc;	state Exp;
branches;
next	1.233;

1.233
date	92.10.21.17.14.46;	author nickc;	state Exp;
branches;
next	1.232;

1.232
date	92.10.20.08.53.50;	author nickc;	state Exp;
branches;
next	1.231;

1.231
date	92.10.19.11.50.55;	author nickc;	state Exp;
branches;
next	1.230;

1.230
date	92.10.16.17.23.42;	author nickc;	state Exp;
branches;
next	1.229;

1.229
date	92.10.15.14.47.16;	author nickc;	state Exp;
branches;
next	1.228;

1.228
date	92.10.15.13.48.37;	author nickc;	state Exp;
branches;
next	1.227;

1.227
date	92.10.14.15.23.56;	author nickc;	state Exp;
branches;
next	1.226;

1.226
date	92.10.07.14.04.06;	author nickc;	state Exp;
branches;
next	1.225;

1.225
date	92.10.06.10.46.22;	author nickc;	state Exp;
branches;
next	1.224;

1.224
date	92.10.05.08.42.32;	author nickc;	state Exp;
branches;
next	1.223;

1.223
date	92.10.02.16.44.19;	author nickc;	state Exp;
branches;
next	1.222;

1.222
date	92.10.02.11.58.38;	author nickc;	state Exp;
branches;
next	1.221;

1.221
date	92.10.02.11.26.03;	author nickc;	state Exp;
branches;
next	1.220;

1.220
date	92.09.10.17.24.31;	author nickc;	state Exp;
branches;
next	1.219;

1.219
date	92.09.10.16.58.38;	author nickc;	state Exp;
branches;
next	1.218;

1.218
date	92.09.04.08.43.35;	author nickc;	state Exp;
branches;
next	1.217;

1.217
date	92.09.03.17.00.34;	author nickc;	state Exp;
branches;
next	1.216;

1.216
date	92.09.03.15.40.24;	author nickc;	state Exp;
branches;
next	1.215;

1.215
date	92.08.25.15.37.51;	author nickc;	state Exp;
branches;
next	1.214;

1.214
date	92.08.24.17.29.17;	author nickc;	state Exp;
branches;
next	1.213;

1.213
date	92.08.24.16.27.00;	author nickc;	state Exp;
branches;
next	1.212;

1.212
date	92.08.18.08.20.39;	author nickc;	state Exp;
branches;
next	1.211;

1.211
date	92.08.17.16.20.35;	author nickc;	state Exp;
branches;
next	1.210;

1.210
date	92.08.05.17.25.47;	author nickc;	state Exp;
branches;
next	1.209;

1.209
date	92.08.05.17.23.58;	author nickc;	state Exp;
branches;
next	1.208;

1.208
date	92.08.04.16.10.02;	author nickc;	state Exp;
branches;
next	1.207;

1.207
date	92.08.03.12.07.16;	author nickc;	state Exp;
branches;
next	1.206;

1.206
date	92.07.29.12.51.32;	author nickc;	state Exp;
branches;
next	1.205;

1.205
date	92.07.28.15.47.17;	author nickc;	state Exp;
branches;
next	1.204;

1.204
date	92.07.17.09.12.41;	author nickc;	state Exp;
branches;
next	1.203;

1.203
date	92.07.16.09.50.23;	author nickc;	state Exp;
branches;
next	1.202;

1.202
date	92.07.15.13.21.32;	author nickc;	state Exp;
branches;
next	1.201;

1.201
date	92.07.15.10.45.55;	author nickc;	state Exp;
branches;
next	1.200;

1.200
date	92.07.14.17.45.50;	author nickc;	state Exp;
branches;
next	1.199;

1.199
date	92.07.13.10.20.45;	author nickc;	state Exp;
branches;
next	1.198;

1.198
date	92.06.25.10.54.59;	author nickc;	state Exp;
branches;
next	1.197;

1.197
date	92.06.24.17.04.43;	author nickc;	state Exp;
branches;
next	1.196;

1.196
date	92.06.19.17.07.43;	author nickc;	state Exp;
branches;
next	1.195;

1.195
date	92.06.19.13.10.44;	author nickc;	state Exp;
branches;
next	1.194;

1.194
date	92.06.18.08.41.43;	author nickc;	state Exp;
branches;
next	1.193;

1.193
date	92.06.17.18.28.03;	author nickc;	state Exp;
branches;
next	1.192;

1.192
date	92.06.16.13.33.22;	author nickc;	state Exp;
branches;
next	1.191;

1.191
date	92.06.10.09.38.51;	author nickc;	state Exp;
branches;
next	1.190;

1.190
date	92.06.10.08.58.57;	author nickc;	state Exp;
branches;
next	1.189;

1.189
date	92.06.08.14.50.23;	author nickc;	state Exp;
branches;
next	1.188;

1.188
date	92.06.05.17.17.33;	author nickc;	state Exp;
branches;
next	1.187;

1.187
date	92.06.05.08.32.26;	author nickc;	state Exp;
branches;
next	1.186;

1.186
date	92.06.02.10.15.51;	author nickc;	state Exp;
branches;
next	1.185;

1.185
date	92.05.22.16.48.46;	author nickc;	state Exp;
branches;
next	1.184;

1.184
date	92.05.22.10.32.06;	author nickc;	state Exp;
branches;
next	1.183;

1.183
date	92.05.20.17.12.56;	author nickc;	state Exp;
branches;
next	1.182;

1.182
date	92.05.20.15.36.39;	author nickc;	state Exp;
branches;
next	1.181;

1.181
date	92.05.20.08.38.12;	author nickc;	state Exp;
branches;
next	1.180;

1.180
date	92.05.19.14.00.21;	author nickc;	state Exp;
branches;
next	1.179;

1.179
date	92.05.18.16.02.08;	author nickc;	state Exp;
branches;
next	1.178;

1.178
date	92.05.15.13.12.53;	author nickc;	state Exp;
branches;
next	1.177;

1.177
date	92.05.15.08.53.32;	author nickc;	state Exp;
branches;
next	1.176;

1.176
date	92.05.14.16.38.26;	author nickc;	state Exp;
branches;
next	1.175;

1.175
date	92.05.14.16.11.33;	author nickc;	state Exp;
branches;
next	1.174;

1.174
date	92.05.14.10.29.04;	author nickc;	state Exp;
branches;
next	1.173;

1.173
date	92.05.14.09.30.52;	author nickc;	state Exp;
branches;
next	1.172;

1.172
date	92.05.14.08.59.46;	author nickc;	state Exp;
branches;
next	1.171;

1.171
date	92.05.13.15.26.45;	author nickc;	state Exp;
branches;
next	1.170;

1.170
date	92.05.11.16.27.46;	author nickc;	state Exp;
branches;
next	1.169;

1.169
date	92.05.06.15.47.53;	author nickc;	state Exp;
branches;
next	1.168;

1.168
date	92.05.06.13.49.33;	author nickc;	state Exp;
branches;
next	1.167;

1.167
date	92.05.02.12.06.17;	author nickc;	state Exp;
branches;
next	1.166;

1.166
date	92.05.02.11.25.13;	author nickc;	state Exp;
branches;
next	1.165;

1.165
date	92.05.01.09.25.45;	author nickc;	state Exp;
branches;
next	1.164;

1.164
date	92.05.01.08.49.07;	author nickc;	state Exp;
branches;
next	1.163;

1.163
date	92.04.28.17.56.17;	author nickc;	state Exp;
branches;
next	1.162;

1.162
date	92.04.28.17.05.16;	author nickc;	state Exp;
branches;
next	1.161;

1.161
date	92.04.27.12.31.15;	author nickc;	state Exp;
branches;
next	1.160;

1.160
date	92.04.24.15.41.33;	author nickc;	state Exp;
branches;
next	1.159;

1.159
date	92.04.24.10.35.09;	author nickc;	state Exp;
branches;
next	1.158;

1.158
date	92.04.23.17.11.53;	author nickc;	state Exp;
branches;
next	1.157;

1.157
date	92.04.23.16.13.50;	author nickc;	state Exp;
branches;
next	1.156;

1.156
date	92.04.23.08.48.00;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	92.04.22.16.43.08;	author nickc;	state Exp;
branches;
next	1.154;

1.154
date	92.04.22.13.59.14;	author nickc;	state Exp;
branches;
next	1.153;

1.153
date	92.04.22.09.41.48;	author nickc;	state Exp;
branches;
next	1.152;

1.152
date	92.04.21.15.04.59;	author nickc;	state Exp;
branches;
next	1.151;

1.151
date	92.04.16.14.05.43;	author nickc;	state Exp;
branches;
next	1.150;

1.150
date	92.04.16.07.40.38;	author nickc;	state Exp;
branches;
next	1.149;

1.149
date	92.04.15.16.43.38;	author nickc;	state Exp;
branches;
next	1.148;

1.148
date	92.04.15.14.26.28;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	92.04.14.16.16.32;	author nickc;	state Exp;
branches;
next	1.146;

1.146
date	92.04.14.14.45.39;	author nickc;	state Exp;
branches;
next	1.145;

1.145
date	92.04.14.08.09.10;	author nickc;	state Exp;
branches;
next	1.144;

1.144
date	92.04.13.15.47.54;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	92.04.13.13.46.22;	author nickc;	state Exp;
branches;
next	1.142;

1.142
date	92.04.13.10.44.57;	author nickc;	state Exp;
branches;
next	1.141;

1.141
date	92.04.10.14.47.50;	author nickc;	state Exp;
branches;
next	1.140;

1.140
date	92.04.09.16.28.48;	author nickc;	state Exp;
branches;
next	1.139;

1.139
date	92.04.09.13.46.16;	author nickc;	state Exp;
branches;
next	1.138;

1.138
date	92.04.08.17.19.10;	author nickc;	state Exp;
branches;
next	1.137;

1.137
date	92.04.08.15.48.55;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	92.04.07.15.42.18;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	92.04.07.14.33.49;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	92.04.03.15.36.07;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	92.04.03.14.32.58;	author nickc;	state Exp;
branches;
next	1.132;

1.132
date	92.04.02.16.03.26;	author nickc;	state Exp;
branches;
next	1.131;

1.131
date	92.04.02.12.14.28;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	92.04.02.11.45.51;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	92.04.01.17.11.43;	author nickc;	state Exp;
branches;
next	1.128;

1.128
date	92.03.31.17.45.10;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	92.03.31.17.43.35;	author nickc;	state Exp;
branches;
next	1.126;

1.126
date	92.03.31.10.27.41;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	92.03.31.09.21.35;	author nickc;	state Exp;
branches;
next	1.124;

1.124
date	92.03.27.17.27.19;	author nickc;	state Exp;
branches;
next	1.123;

1.123
date	92.03.27.15.33.49;	author nickc;	state Exp;
branches;
next	1.122;

1.122
date	92.03.27.13.13.37;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	92.03.26.10.31.02;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	92.03.26.09.39.54;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	92.03.25.19.07.33;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	92.03.25.18.52.33;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	92.03.25.16.06.48;	author nickc;	state Exp;
branches;
next	1.116;

1.116
date	92.03.23.18.12.40;	author nickc;	state Exp;
branches;
next	1.115;

1.115
date	92.03.20.19.10.44;	author nickc;	state Exp;
branches;
next	1.114;

1.114
date	92.03.19.18.05.11;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	92.03.19.17.59.15;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	92.03.19.13.56.53;	author nickc;	state Exp;
branches;
next	1.111;

1.111
date	92.03.19.09.21.54;	author nickc;	state Exp;
branches;
next	1.110;

1.110
date	92.03.19.08.34.56;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	92.03.18.11.02.37;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	92.03.17.17.59.54;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	92.03.17.14.18.30;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	92.03.17.13.57.05;	author nickc;	state Exp;
branches;
next	1.105;

1.105
date	92.03.16.17.47.09;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	92.03.11.16.37.40;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	92.03.11.15.27.06;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	92.03.11.14.58.08;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	92.03.11.14.26.43;	author nickc;	state Exp;
branches;
next	1.100;

1.100
date	92.03.11.09.23.41;	author nickc;	state Exp;
branches;
next	1.99;

1.99
date	92.03.10.19.05.25;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	92.03.10.10.22.05;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	92.03.09.16.07.45;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	92.03.09.15.19.43;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	92.03.09.14.34.59;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	92.03.04.17.53.48;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	92.03.03.19.11.38;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	92.03.03.16.05.00;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	92.03.02.11.59.53;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	92.02.28.18.04.25;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	92.02.28.12.45.22;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	92.02.28.12.17.05;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	92.02.28.12.09.42;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	92.02.28.11.25.09;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	92.02.27.17.52.43;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	92.02.27.14.09.11;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	92.02.27.13.42.20;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	92.02.24.11.19.34;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	92.02.21.14.52.52;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	92.02.20.18.51.14;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	92.02.20.17.48.03;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	92.02.20.16.36.23;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	92.02.20.10.20.15;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	92.02.19.17.06.11;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	92.02.19.15.57.19;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	92.02.19.14.49.00;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	92.02.18.15.44.17;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	92.02.13.12.51.49;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	92.02.12.18.51.25;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	92.02.12.18.06.07;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	92.02.12.15.36.52;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	92.02.12.11.29.21;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	92.02.11.17.50.13;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	92.02.11.12.01.22;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	92.02.10.12.07.04;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	92.02.06.14.29.47;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	92.02.05.16.56.42;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	92.02.05.15.44.05;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	92.02.05.11.32.38;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	92.02.04.15.17.30;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	92.02.04.13.46.47;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	92.01.31.18.02.21;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	92.01.16.13.28.56;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	91.12.16.11.55.03;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	91.12.13.15.06.59;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	91.12.13.14.18.36;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	91.12.13.12.16.58;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	91.12.12.10.21.18;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	91.12.10.18.30.01;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	91.12.10.17.36.46;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	91.12.10.17.33.30;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	91.12.05.10.35.26;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	91.12.04.11.31.12;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	91.12.03.19.14.13;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	91.11.13.18.54.04;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	91.11.11.14.24.03;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	91.11.08.17.10.06;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	91.11.07.17.49.40;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	91.11.06.12.00.07;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	91.11.05.17.28.43;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	91.11.05.16.50.35;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	91.11.04.11.00.04;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	91.11.03.14.27.31;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	91.11.03.11.54.37;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	91.10.31.11.29.08;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	91.10.29.10.40.24;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	91.10.28.15.28.05;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	91.10.18.10.49.45;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	91.10.17.10.07.37;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	91.10.15.12.22.35;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	91.10.14.10.39.26;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	91.10.11.15.26.31;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	91.10.10.16.14.47;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	91.10.10.16.09.00;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	91.10.10.15.41.28;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	91.10.10.14.42.18;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	91.10.10.13.53.17;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	91.10.10.10.38.41;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	91.10.09.12.58.04;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	91.10.07.16.16.34;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	91.10.04.10.09.57;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	91.10.03.15.04.30;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	91.10.03.07.20.20;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	91.10.02.11.05.53;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	91.10.02.09.20.14;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	91.10.01.13.18.33;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	91.09.25.12.48.29;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	91.09.20.17.18.04;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	91.09.20.12.17.12;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	91.09.20.09.54.35;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	91.09.19.15.14.45;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	91.09.18.16.00.44;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	91.08.29.14.38.58;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	91.08.23.17.12.28;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	91.08.23.12.20.03;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	91.08.23.09.26.06;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	91.08.22.16.54.47;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	91.08.22.16.46.45;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	91.08.22.14.58.57;	author nickc;	state Exp;
branches;
next	;


desc
@C40 op code gernator
@


1.267
log
@fixed bug in unsigned int -> float conversion
@
text
@/* C compiler file c40/gen.c :  Copyright (c) Perihelion Software Ltd, 1991, 1992. 1993.  */
/* version 1 */
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/gen.c,v 1.266 1993/09/20 10:23:54 nickc Exp nickc $ */

/*
 * XXX - NC - 30/07/91
 *
 * This is my first attempt at converting a code generator to work
 * for the Texas Instruments TMS320C4x chips.  I am basing this
 * port on the SPARC code generator, with bits stolen from the MIPS
 * and 68K code generators.
 *
 *	Caveat Emptor
 */
/*
 * XXX - NC
 *
 * For Your Information
 *
 * If you are looking at this file, and you are not familiar with the 'C40
 * instruction set then a few points might prove helpful:
 *
 *  + all op codes are 32 bits wide
 *
 *  + all op codes except CALL (jump to subroutine) and B (branch) take 1 instruction cycle
 *
 *  + the chip only supports word addressing and has a 16 gigabyte range (where 1 byte = 8 bits)
 *
 *  + the machine shares floating point and integer registers, and has seperate address registers
 *
 *  + the instruction set has delayed branches (delayed for 3 instructions) and link-and-jump instructions
 *
 *  + we are using byte addressing where addresses are a byte offset from register IR0
 *    (in this case a byte is an 8 bit quantity)
 *
 * + the instruction set is a fairly standard RISC set except that:
 *	- it has diadic and triadic versions of most operations
 *	- triadic ops can sometimes be done in parallel with a load or store
 *	- floating point is not IEEE standard, but instructions exist to convert between formats
 *	- there is a "repeat single instruction" and "repeat block of instructions" mode
 */

/*
 * due to an incredible bug in the C40 silicon design, logical triadic
 * operations take a signed immediate value.  If TI ever fix this
 * stupidity then enable this define
 *
 *  #define TRIADIC_BINARY_OPS_ARE_UNSIGNED		1
 */

/* similarly define these if the hardware bugs are ever fixed */

/* #define STI_STI_NOW_WORKS_ON_HARDWARE 1 	*/
/* #define STIK_NOW_WORKS_ON_HARDWARE 1 	*/

/* AM July 88: add TAILCALLK/TAILCALLR -- ACN to check anomalies. */
/* bug: try the following and see uneven noop insertion:
   f(int *x,int *y) { x[5] = y[5];  x[4] = y[4];  x[3] = y[3];
   x[2] = y[2];  x[1] = y[1];  x[0] = y[0]; }
   g(int *x) { h(x[1],x[2],x[3]); }
   */

#ifdef __STDC__
#  include <string.h>
#else
#  include <strings.h>
#endif

#include "globals.h"
#include "builtin.h"
#include "mcdep.h"
#include "ops.h"
#include "mcdpriv.h"
#include "xrefs.h"
#include "jopcode.h"
#include "store.h"
#include "codebuf.h"
#include "regalloc.h"
#include "cg.h"        /* for procflags, greatest_stackdepth */
#include "errors.h"
#include "util.h"
#include "aeops.h"
#include "peep.h"
#include "bind.h"	/* for sym_insert() */

#if defined __HELIOS
#define UNUSED( var )	var = var;
#else
#define UNUSED( var )
#endif

#ifndef streq
#define streq( a, b )	(strcmp( (a), (b) ) == 0)
#endif

#define CONTIGUOUS_ARGS			(PROC_ARGPUSH | PROC_ARGADDR)
#define NONLEAF 			(CONTIGUOUS_ARGS | PROC_BIGSTACK | BLKCALL)

/* vvvvvvvvvvvvvvvvvvvvvv    PEEPHOLER    vvvvvvvvvvvvvvvvvvvv */

int32			death              = 0;		/* mask of dead registers at end of current J_opcode */

/* ^^^^^^^^^^^^^^^^^^^^^^    PEEPHOLER    ^^^^^^^^^^^^^^^^^^^^ */

static void		routine_exit( bool tailcall );

static bool		saved_frame        = FALSE;	/* true iff frame pointer saved on stack	   */
static int32		saved_ivars        = 0;		/* mask of INT variable registers saved on stack   */
static int32		saved_fvars        = 0;		/* mask of FP  variable registers saved on stack   */
static int32		saved_args         = 0;		/* number of argument registers saved on stack     */
static int32 		casebranch_pending = 0;
static int32		casebranch_r1r     = GAP;
static RealRegister	saved_link_reg	   = GAP;	/* register containing return address, if not R_LR */
static Symstr *		saved_regs         = NULL;	/* register saving structure used by debugger      */

static LabelNumber *	returnlab;

static int32		codep_of_call = 0;	/* used during data initialisation */

int32			stack_move    = 0;	/* number of bytes potentially subtracted from stack */
int32			stack_offset  = 0;	/* number of bytes from stack pointer to first local arg */

/*
 * macros for manipulating the stack pointer
 */

#define adjust_stack( by ) 	(stack_move += (by))

#ifndef __HELIOS
void
IOdebug( const char * format, ... )
{
  return;
}  
#endif

/*
 * output an instruction
 */

static void
outinstr(
	 int32	op_code,	/* the 32 bit op code */
	 int32	reads,		/* mask of registers read by the op code */
	 int32	writes )	/* mask of registers altered by the op code */
{
  append_peep( OUT_INSTR, op_code, reads, writes, NULL, NULL, LABREF_NONE );
    
  return;
    
} /* outinstr */


/*
 * send a NO-OP instruction
 */

static void
nop( bool is_delay )
{
  append_peep( OUT_NULL, OP_NOP << 23,
	      is_delay ? examines1( RR_PC ) : examines0(),
	      alters0(), NULL, NULL, LABREF_NONE );
    
  return;
    
} /* nop */


/*
 * output a delayed instruction
 */

static void
outdelayed(
	   int32	op_code,	/* the 32 bit op code */
	   int32	reads,		/* mask of registers read by the op code */
	   int32	writes )	/* mask of registers altered by the op code */
{
  append_peep( OUT_DELAYED, op_code, reads, writes, NULL, NULL, LABREF_NONE );
    
  nop( TRUE );
  nop( TRUE );
  nop( TRUE );

  /* do not allow peepholing to occur across a delayed instruction */
  
  flush_peepholer( DBG( "delayed instruction" ) );
  
  return;
    
} /* outdelayed */


/*
 * output a delayed instruction that references a label
 */

static void
outdellabref(
	     int32		op_code,	/* the 32 bit op code */
	     LabelNumber *	label,		/* the label referenced */
	     int32		reftype,	/* the size of the offset field */
	     int32		reads,		/* mask of registers read by the op code */
	     int32		writes )	/* mask of registers altered by the op code */
{
  append_peep( OUT_DELLABREF, op_code, reads, writes, NULL, label, reftype );
    
  nop( TRUE );
  nop( TRUE );
  nop( TRUE );

  /* do not allow peepholing across delayed instructions */
  
  flush_peepholer( DBG( "delayed instruction" ) );
  
  return;
    
} /* outdellabref */

#ifdef NOT_USED

/*
 * output an instruction which references symbol 'name'
 */

static void
outinstrref(
	    int32	op_code,	/* 32 bit op code */
	    Symstr *	name,		/* symbol used by op code */
	    int32	reads,		/* mask of registers examined by op code */
	    int32	writes )	/* mask of registers altered by op_code */
{
  append_peep( OUT_SYMREF, op_code, reads, writes, name, NULL, LABREF_NONE );
    
  return;
    
} /* outinstrref */

#endif /* NOT_USED */

/*
 * output a delayed instruction which references symbol 'name'
 */

static void
outdelsymref(
	    int32	op_code,	/* 32 bit op code */
	    Symstr *	name,		/* symbol used by op code */
	    int32	reads,		/* mask of registers examined by op code */
	    int32	writes )	/* mask of registers altered by op_code */
{
  append_peep( OUT_DELSYMREF, op_code, reads, writes, name, NULL, LABREF_NONE );

  nop( TRUE );
  nop( TRUE );
  nop( TRUE );
  
  /* do not allow peepholing across delayed instructions */
  
  flush_peepholer( DBG( "delayed instruction" ) );
  
  return;
    
} /* outdelsymref */


#ifdef NOT_USED

/*
 * op code construction functions
 */

static char *	regstr =
  "R0\0\0R1\0\0R2\0\0R3\0\0R4\0\0R5\0\0R6\0\0R7\0\0"
  "AR0\0AR1\0AR2\0AR3\0AR4\0AR5\0AR6\0AR7\0"
  "DP\0\0IR0\0IR1\0BK\0\0SP\0\0ST\0\0DIE\0IIE\0"
  "IIF\0RS\0\0RE\0\0RC\0\0R8\0\0R9\0\0R10\0R11\0";

/* NB/ regname_ has already been taken */

#define reg_( r ) ((((r) & 0x1f) * 4) + regstr)

#endif /* NOT_USED */

/*
 * maps between a RealRegister and a hardware register
 * NB/ this must agree with the register naming scheme
 * documented in c40/target.h
 *
 * This also affects is_C40_float_register() below
 */

int32
hardware_register( RealRegister r )
{
  static int32 tab[ MAXREGNUMBER + 1 ] =
    {
      0x00,	/*  0 => R0  */
      0x01,	/*  1 => R1  */
      0x02,	/*  2 => R2  */
      0x03,	/*  3 => R3  */
      0x04,	/*  4 => R4  */
      0x05,	/*  5 => R5  */
      0x06,	/*  6 => R6  */
      0x07,	/*  7 => R7  */
      0x10,	/*  8 => DP  */
      0x13,	/*  9 => BK  */
      0x1c,	/* 10 => R8  */
      0x1d,	/* 11 => R9  */
      0x1e,	/* 12 => R10 */
      0x08, 	/* 13 => AR0 */
      0x09,	/* 14 => AR1 */
      0x0a,	/* 15 => AR2 */
      0x0b,	/* 16 => AR3 */
      0x1f,	/* 17 => R11 */
      0x0c,	/* 18 => AR4 */
      0x0d,	/* 19 => AR5 */
      0x0e,	/* 20 => AR6 */
      0x0f,  	/* 21 => AR7 */
      0x11,	/* 22 => IR0 */
      0x12,	/* 23 => IR1 */
      0x14,	/* 24 =>  SP */
      0x15,	/* 25 =>  ST */
      0x19,	/* 26 =>  RS */
      0x1a,	/* 27 =>  RE */
      0x1b	/* 28 =>  RC */
    };

  if (r > MAXREGNUMBER)
    syserr( syserr_illegal_register, r );
  
  return tab[ r ];
  
} /* hardware_register */


bool
is_C40_float_register( RealRegister r )
{
  int32	reg = hardware_register( r );


  if (reg <= 0x07 || (reg >= 0x1c && reg <= 0x1f))
    return TRUE;

  return FALSE;

} /* is_C40_float_register */
  

/*
 * maps between a harwdare register and a RealRegister 
 */

RealRegister
real_register( int32 r )
{
  static int32 tab[ 0x1f + 1 ] =
    {
      RR_R0,	/*  0 */
      RR_R1,	/*  1 */
      RR_R2,	/*  2 */
      RR_R3,	/*  3 */
      RR_R4,	/*  4 */
      RR_R5,	/*  5 */
      RR_R6,	/*  6 */
      RR_R7,	/*  7 */
      RR_AR0,	/*  8 */
      RR_AR1,	/*  9 */
      RR_AR2,	/*  a */
      RR_AR3,	/*  b */
      RR_AR4,	/*  c */
      RR_AR5, 	/*  d */
      RR_AR6,	/*  e */
      RR_AR7,	/*  f */
      RR_DP,	/* 10 */
      RR_IR0,	/* 11 */
      RR_IR1,	/* 12 */
      RR_BK,	/* 13 */
      RR_SP,	/* 14 */
      RR_ST,  	/* 15 */
      -1,	/* 16 */ /* DIE */
      -1,	/* 17 */ /* IIE */
      -1,	/* 18 */ /* IIF */
      RR_RS,	/* 19 */
      RR_RE,	/* 1a */
      RR_RC,	/* 1b */
      RR_R8,	/* 1c */
      RR_R9,	/* 1d */
      RR_R10,	/* 1e */
      RR_R11	/* 1f */
    };

  if (r > 0x1f)
    syserr( syserr_illegal_register2, r );
  
  return tab[ r ];
  
} /* real_register */


/*
 * builds a diadic op-code
 */

int32
build_op(
	 int32		op_code,		/* 32 bit operand */
	 int32		addressing_mode,	/* form of addressing */
	 RealRegister	destination,		/* registers written to */
	 int32		source			/* NB/ doubles up as a RealRegister */
	 )
{
  int32	op;
  int32	dst;


  if (op_code == OP_STIK && addressing_mode == ADDR_MODE_IMMEDIATE)
    {
      dst = destination;	/* ie do NOT translate, the 'destintaion' is NOT a register */
    }
  else
    {
      dst = hardware_register( destination );
    }

  /* ensure bit fields are the right length */
  
  op_code &= 0x3fU;
  source  &= 0xffffU;
  dst     &= 0x1fU;

  /* construct op code */

  op = (op_code << 23) | (dst << 16);

  /* set addressing bits, and munge source if necessary */
  
  switch (addressing_mode)
    {
    case ADDR_MODE_REGISTER:
      source = hardware_register( (RealRegister)source );
      break;

    case ADDR_MODE_DIRECT:
      op |= 0x1U << 21;
      break;
      
    case ADDR_MODE_INDIRECT:
      op |= 0x2U << 21;
      break;

    case ADDR_MODE_IMMEDIATE:
      op |= 0x3U << 21;
      break;

    default:
      syserr( syserr_bad_addressing_mode );
      break;
    }

  return op | source;

} /* build_op */


#ifdef NOT_USED
/*
 * output an instruction which cross references symbol 'name'
 */

static void
outxref(
	int32		op_code,		/* 32 bit operand 				*/
	int32		addressing_mode,	/* form of addressing 				*/
	RealRegister	destination,		/* register written to 				*/
	int32		source,			/* register read from 				*/
	Symstr *	name,			/* symbol used by op code 			*/
	int32		ref_type,		/* type of cross reference 			*/
	int32		reads,			/* mask of registers examined by op code	*/
	int32		writes )		/* mask of registers altered by op_code 	*/
{
  append_peep( OUT_XREF, build_op( op_code, addressing_mode, destination, source ),
	      reads, writes, name, NULL, ref_type );
    
  return;
    
} /* outxref */
#endif /* NOT_USED */

/*
 * builds and sends a diadic op-code
 */

static void
out_diadic_op(
	      int32		op_code,		/* 32 bit operand 				*/
	      int32		addressing_mode,	/* form of addressing 				*/
	      RealRegister	destination,		/* registers written to 			*/
	      int32		source,			/* NB/ doubles up as a RealRegister 		*/
	      unsigned long	reads,			/* mask of registers examined by op_code	*/
	      unsigned long	writes )		/* mask of registers altered by op_code		*/
{
  /* send completed op-code */
  
  outinstr( build_op( op_code, addressing_mode, destination, source ), reads, writes );
  
  return;
  
} /* out_diadic_op */


/*
 * build and send a simple triadic operation
 *
 * NB/ when using an ADDR_MODE_INDIRECT form of addressing
 * construct the source field with the build_indirect
 * macro NOT the build_parallel_indirect macro
 */
  
static void
out_triadic_op(
	       int32		op_code,
	       RealRegister	destination,
	       int32		source1,		/* can double up as RealRegister */
	       int32		source2,		/* can double up as RealRegister */
	       int		source1_type,
	       int		source2_type,
	       int32		reads,			/* mask of registers examined by operation */
	       int32		writes )		/* mask of registers altered by examination */
{
  int32		op;
  int32		dst;


  dst = hardware_register( destination );
  
  /*
   * when the source type is ADDR_MODE_INDIRECT then
   * the corresponding source field is encoded as:
   *
   * bits  0 - 7  encode 8-bit displacement
   * bits  8 - 10 encode addressing register
   * bits 11 - 15 encode indirect addressing mode
   *
   * and the instruction can be encoded as:
   *
   * bits  0 - 2  encode addressing register      \__ implies INDIRECT_PRE_ADD addressing mode
   * bits  3 - 7  encode 5-bit displacement       /
   *
   * OR
   *
   * bits  0 - 2  encode addressing register      \__ implies a displacement of 1
   * bits  3 - 7  encode indirect addressing mode /
   *
   */
	  
  /* ensure bit fields are the right length */
  
  op_code &= 0x1f;
  dst     &= 0x1f;

  /* partially construct op code */

  op = (0x1U << 29) | (op_code << 23) | (dst << 16);

  /* set addressing bits */
  
  switch (source1_type)
    {
    case ADDR_MODE_REGISTER:

      source1 = hardware_register( (RealRegister)source1 );
      
      switch (source2_type)
	{
	case ADDR_MODE_REGISTER:

	  source2 = hardware_register( (RealRegister)source2 );
	  
	  op |= (0x0U << 21);	/* set the T    field */
	  op |= (0x0U << 28);	/* set the type field */
	  
	  break;
	  
	case ADDR_MODE_INDIRECT:
	  switch ((source2 >> 11) & 0x1f)	/* get indirect addressing type */
	    {
	    case INDIRECT_PRE_ADD:
	      if (source2 & 0xe0 != 0)
		{
		  syserr( syserr_illegal_displacement );
		}

	      /* extract register and 5 bit displacement - addressing mode ignored */
	      
	      source2 = ((source2 & 0x1f) << 3) | indirect_addr_reg( source2 );

	      /* set up type fields */
	      
	      op |= (0x1U << 21);	/* set the T field */
	      op |= (0x1U << 28);	/* set the type field */
	      
	      break;

	    default:	/* in all other cases we loose the displacment field */

	      if (source2 & (B_11000 << 1))
		{
		  /* index register relative */
		  
		  if ((source2 & 0xff) != 0)
		    {
		      syserr( syserr_illegal_displacement2 );
		    }
		}
	      else if ((source2 & 0xff) != 1)
		{
		  syserr( syserr_illegal_displacement3 );
		}

	      /* extract addressing mode and register - displacement ignored */
	      
	      source2 = (((source2 >> 11) & 0x1f) << 3) | indirect_addr_reg( source2 );
	      
	      /* set up type fields */
	      
	      op |= (0x2 << 21);	/* set the T field */
	      op |= (0x0 << 28);	/* set the type field */
	      
	      break;
	    }
	  break;
	  
	case ADDR_MODE_IMMEDIATE:
	  switch (op_code)
	    {
#ifdef TRIADIC_BINARY_OPS_ARE_UNSIGNED
	    case OP_AND3:
	    case OP_OR3:
	    case OP_XOR3:
	      if (!fits_in_8_bits_unsigned( source2 ))
		{
		  syserr( syserr_signed_val_too_large );
		}
	      break;
#endif	      
	    default:
	      if (!fits_in_8_bits_signed( source2 ))
		{
		  syserr( syserr_unsigned_val_too_large );
		}
	      break;
	    }
	  
	  /* set up type fields */
	  
	  op |= (0x0U << 21);	/* set the T field */
	  op |= (0x1U << 28);	/* set the type field */
	  
	  break;
	  
	default:
	  syserr( syserr_unknown_triadic, source2_type );
	  break;
	}
      break;

    case ADDR_MODE_INDIRECT:
      switch (source2_type)
	{
	case ADDR_MODE_REGISTER:
	  if (source1 & (B_11000 << 11))
	    {
	      /* index register relative */
	      
	      if ((source1 & 0xff) != 0)
		{
		  syserr( syserr_illegal_displacement2 );
		}
	    }
	  else if ((source1 & 0xff) != 1)
	    {
	      syserr( syserr_illegal_displacement3 );
	    }

	  /* extract addressing mode and register fields - displacement is ignored */
	      
	  source1 = ((source1 >> 11) & 0x1f) << 3 | indirect_addr_reg( source1 );

	  source2 = hardware_register( (RealRegister)source2 );
	      
	  /* set up type fields */
	      
	  op |= (0x1U << 21);	/* set the T field */
	  op |= (0x0U << 28);	/* set the type field */
	      
	  break;
	  
	case ADDR_MODE_INDIRECT:
	  if (((source1 >> 11) & 0x1f) == INDIRECT_PRE_ADD &&
	      ((source2 >> 11) & 0x1f) == INDIRECT_PRE_ADD )
	    {
	      /* ensure that displacments are 5 bits */
	      
	      if ((source1 & 0xe0) != 0 ||
		  (source2 & 0xe0) != 0  )
		{
		  syserr( syserr_displacement_out_of_range );
		}

	      /* extract register and 5 bit displacement - addressing mode ignored */
	      
	      source1 = ((source1 & 0x1f) << 3) | indirect_addr_reg( source1 );
	      source2 = ((source2 & 0x1f) << 3) | indirect_addr_reg( source2 );
	      
	      /* set up type fields */
	      
	      op |= (0x3U << 21);	/* set the T field */
	      op |= (0x1U << 28);	/* set the type field */
	    }
	  else
	    {
	      /* ensure that displacement is 1 */

	      if (source1 & (B_11000 << 11))
		{
		  /* index register relative */
	      
		  if ((source1 & 0xff) != 0)
		    {
		      syserr( syserr_illegal_displacement2 );
		    }
		}
	      else if ((source1 & 0xff) != 1)
		{
		  syserr( syserr_illegal_displacement3 );
		}

	      if (source2 & (B_11000 << 11))
		{
		  /* index register relative */
	      
		  if ((source2 & 0xff) != 0)
		    {
		      syserr( syserr_illegal_displacement2 );
		    }
		}
	      else if ((source2 & 0xff) != 1)
		{
		  syserr( syserr_illegal_displacement3 );
		}

	      /* extract addressing mode and register fields - displacement is ignored */
	      
	      source1 = (((source1 >> 11) & 0x1f) << 3) | indirect_addr_reg( source1 );
	      source2 = (((source2 >> 11) & 0x1f) << 3) | indirect_addr_reg( source2 );
	      
	      /* set up type fields */
	      
	      op |= (0x3U << 21);	/* set the T field */
	      op |= (0x0U << 28);	/* set the type field */
	    }
	  
	  break;
	    
	case ADDR_MODE_IMMEDIATE:
	  /* ensure that indirect address mode is PRE_ADD */
	  
	  if (((source1 >> 11) & 0x1f) != INDIRECT_PRE_ADD)
	    {
	      syserr( syserr_illegal_indirect );
	    }

	  /* ensure displacement is 5 bits */
	  
	  if ((source1 & 0xe0) != 0)
	    {
	      syserr( syserr_triadic_disp_oor );
	    }

	  /* extract register and 5 bit displacement - addressing mode ignored */
	      
	  source1 = ((source1 & 0x1f) << 3) | indirect_addr_reg( source1 );

	  /* ensure that immediate value fits in 8 bits */
	  
	  if (!fits_in_8_bits_signed( source2 ))
	    {
	      syserr( syserr_bad_addressing_mode );
	    }

	  /* set up type fields */
	      
	  op |= (0x2U << 21);	/* set the T field */
	  op |= (0x1U << 28);	/* set the type field */

	  break;
	  
	default:
	  syserr( syserr_unknown_triadic, source2_type );
	  break;
	}
      break;

    default:
      syserr( syserr_unknown_op, source1_type );
      break;
    }

  source1 &= 0xff;
  source2 &= 0xff;

  op |=  (source1 << 8) | source2;
  
  /* send completed op-code */

  outinstr( op, reads, writes );
  
  return; 
  
} /* out_triadic_op */


static unsigned long
C_FROMQ( int32 q )
{
  switch (q & Q_MASK)
    {
    case Q_EQ:	return C_EQ;	/* equal to */
    case Q_NE:	return C_NE;	/* not equal to */
    case Q_HS:	return C_HS;	/* higher than or the same (unsigned) */
    case Q_LO:	return C_LO;	/* lower than (unsigned) */
    case Q_HI:	return C_HI;	/* higher than (unsigned) */
    case Q_LS:	return C_LS;	/* less than or the same (unsigned) */
    case Q_GE:	return C_GE;	/* greater than or equal to (signed) */
    case Q_LT:	return C_LT;	/* less than (signed) */
    case Q_GT:	return C_GT;	/* greater than (signed) */
    case Q_LE:	return C_LE;	/* less than or equal to (signed) */
    case Q_AL:	return C_U;	/* always */
    case (Q_AL | Q_UBIT):	return C_U;	/* conditional execution always */
    case Q_UEQ:	return C_EQ;	/* equal to (unsigned) */
    case Q_UNE:	return C_NE;	/* not equal to (unsigned) */
    case Q_NOT:	syserr( syserr_unsupported_branch_type, q );	/* never */      
    default:	syserr( syserr_unsupported_branch_type, q );
    }

  return C_U;
  
} /* C_FROMQ */


/*
 * build and send a conditional load op code
 */
  
static void
conditional_load(
		 int32		condition,		/* condition in Norcroft format     */
		 int32		addressing_mode,	/* addressing mode for the load     */
		 RealRegister	destination,		/* destination register             */
		 int32		source,			/* NB/ doubles up as a RealRegister */
		 int32		reads,			/* bit mask of registers examined   */
		 int32		writes )		/* bit mask of registers altered    */
{
  int32		op;

  
  addressing_mode &= 0x3;
  destination     &= 0x1f;
  source          &= 0xffff;

  op = (OP_LDIc << 28) | (C_FROMQ( condition ) << 23) | (hardware_register( destination ) << 16);

  if (addressing_mode == ADDR_MODE_REGISTER)
    {
      outinstr( op | hardware_register( source ), reads, writes );
    }
  else
    {
      outinstr( op | (addressing_mode << 21) | source, reads, writes );
    }

  peep_forget_about( destination );
  
  return;
  
} /* conditional_load */


/*
 * build and send a conditional FP load op code
 */
  
static void
conditional_load_float(
		       int32		condition,
		       int32		addressing_mode,
		       RealRegister	destination,
		       int32		source,		/* NB/ doubles up as a RealRegister */
		       int32		reads,
		       int32		writes )
{
  int32		op;

  
  addressing_mode &= 0x3;
  destination     &= 0x1f;
  source          &= 0xffff;

  op = (OP_LDFc << 28) | (C_FROMQ( condition ) << 23) | (hardware_register( destination ) << 16);

  if (addressing_mode == ADDR_MODE_REGISTER)
    {
      outinstr( op | hardware_register( source ), reads, writes );
    }
  else
    {
      outinstr( op | (addressing_mode << 21) | source, reads, writes );
    }

  peep_forget_about( destination );
  
  return;
  
} /* conditional_load_float */
 
/*
 * returns the index of the first bit set in a word.
 * The least significant bit is index 0 (not 1).
 * cf ffs().
 */
  
static int
firstbit( int32 w )
{
  int 		i;
  int32		mask = 1;
  

  for (i = 0; i < 32; i++)
    if (w & mask)
      return i;
    else
      mask <<= 1;
  
  syserr( syserr_firstbit );
  
  return 0;

} /* firstbit */


#ifdef NOT_USED
/*
 * returns the index of the last bit set in a word.
 * The least significant bit is index 0 (not 1).
 * cf ffs().
 */
  
static int
lastbit( int32 w )
{
  int 		i;
  int32		mask = 0x80000000U;
  

  for (i = 32; i--;)
    if (w & mask)
      return i;
    else
      mask >>= 1;
  
  syserr( syserr_firstbit );
  
  return 0;

} /* lastbit */
#endif /* NOT_USED */


/*
 * move register 'source' into register 'dest'
 * MUST only use one instruction
 */

void
move_register(
	      RealRegister	source,
	      RealRegister	dest,
	      bool		floating,
	      bool		set_cc )
{
  /* make sure that the destination is not cached in a register push */

  maybe_flush_pending_push( dest );
  
  if (source != dest)
    {
      if (floating && is_float( source ) && is_float( dest ))
	{
	  if (set_cc)
	    out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, dest, source,
			  examines1( source ),
			  alters2( dest, RR_ST ) );
	  else
	    conditional_load_float( Q_AL, ADDR_MODE_REGISTER, dest, source,
				   examines1( source ),
				   alters1( dest ) );
	}
      else if (is_special_register( hardware_register( dest ) ))
	{
	  out_diadic_op( OP_LDA, ADDR_MODE_REGISTER, dest, source,
			examines1( source ),
			alters1( dest ) );
	}
      else if (!set_cc)
	{
	  if (is_float( source ) && is_float( dest ))
	    {
	      conditional_load_float( Q_AL, ADDR_MODE_REGISTER, dest, source,
				     examines1( source ),
				     alters1( dest ) );
	    }
	  else
	    {
	      conditional_load( Q_AL, ADDR_MODE_REGISTER, dest, source,
			       examines1( source ),
			       alters1( dest ) );
	    }
	}
      else
	{
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, source,
			examines1( source ),
			alters2( dest, RR_ST ) );
	}
    }

  /* if dest is also in an address register, forget about it */
  
  peep_forget_about( dest );
  
  return;
  
} /* move_register */


/* push a integer register onto the stack */

void
ipush( RealRegister reg )
{
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_PRE_DECR, R_SP, 1 ),
		examines2( reg, R_SP ),
		alters1( R_SP ) );

  peep_change_addr_offset( R_SP, -1 );
  
  return;
  
} /* ipush */

  
/* pop an integer register from the stack */

void
ipop( RealRegister reg )
{
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_POST_INCR, R_SP, 1 ),
		examines1( R_SP ),
		alters3( R_SP, reg, RR_ST ) );

  peep_change_addr_offset( R_SP, +1 );
  
  return;
  
} /* ipop */


/* push a floating point register onto the stack */

void
fpush( RealRegister reg )
{
#ifdef DEBUG
  if (!is_float( reg ))
    syserr( syserr_push_non_float, reg );
#endif
  
  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_PRE_DECR, R_SP, 1 ),
		examines2( reg, R_SP ),
		alters1( R_SP ) );

  peep_change_addr_offset( R_SP, -1 );
  
  return;
  
} /* fpush */

  
/* pop a floating point register from the stack */

static void
fpop( RealRegister reg )
{
#ifdef DEBUG
  if (!is_float( reg ))
    syserr( syserr_pop_non_float, reg );
#endif
  
  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_POST_INCR, R_SP, 1 ),
		examines1( R_SP ),
		alters3( R_SP, reg, RR_ST ) );

  peep_change_addr_offset( R_SP, +1 );
  
  return;
  
} /* fpop */

  
/* push a double precision register onto the stack */

void
dpush( RealRegister reg )
{
#ifdef DEBUG
  if (!is_float( reg ))
    syserr( syserr_push_non_double, reg );
#endif

  /* NB/ opposite order to dpop() */
  
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_PRE_DECR, R_SP, 1 ),
		examines2( reg, R_SP ),
		alters1( R_SP ) );

  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_PRE_DECR, R_SP, 1 ),
		examines2( reg, R_SP ),
		alters1( R_SP ) );

  peep_change_addr_offset( R_SP, -2 );
  
  return;
  
} /* dpush */

  
/* pop a double precision register from the stack */

static void
dpop( RealRegister reg )
{
#ifdef DEBUG
  if (!is_float( reg ))
    syserr( syserr_pop_non_double, reg );
#endif
  
  /* NB/ LDF before LDI */
  
  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_POST_INCR, R_SP, 1 ),
		examines1( R_SP ),
		alters2( reg, RR_ST ) );
  
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_POST_INCR, R_SP, 1 ),
		examines1( R_SP ),
		alters3( R_SP, reg, RR_ST ) );

  peep_change_addr_offset( R_SP, +2 );
  
  return;
  
} /* dpop */

  
/*
 * Set register 'r' to the integer 'n'
 * if 'must_save_st' is true then the status register must be preserved
 */

static void
load_integer(
	     RealRegister	r,
	     int32 		n,
	     bool		must_save_st )
{
#if 0	/* This can corrupt the value in DP in the instruction before this one !!!! */
  if (fits_in_16_bits_unsigned( n )  &&
      hardware_register( r ) == 0x10  ) /* DP */
    {
      out_diadic_op( OP_LDPK, ADDR_MODE_IMMEDIATE, r, n,
		    examines0(),
		    alters1( r ) );

      return;
    }
#endif
  
  if (fits_in_16_bits_signed( n ))
    {
      /* 16 bit signed immediate, does not set ST  */

      if (is_special_register( hardware_register( r ) ))
	{
	  out_diadic_op( OP_LDA, ADDR_MODE_IMMEDIATE, r, n,
			examines0(),
			alters1( r ) );
	}
      else
	{
	  conditional_load( Q_AL, ADDR_MODE_IMMEDIATE, r, n,
			   examines0(),
			   alters1( r ) );
	}

      return;
    }
  else if ((n & 0xffff) == 0)
    {
      /* only 16 msb's set, use special half word load instruction */
      
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, r, n >> 16,
		    examines0(),
		    alters1( r ) );

      return;
    }

  if (must_save_st)
    {
      /*
       * save status register
       *
       * (NB/ since this function can be called from anywhere in
       * compiler we cannot use one of the temporary registers).
       */

      ipush( RR_ST );
    }
  
  if ((n & 0xffff0000U) == 0xffff0000U)
    {
      /* all 16 msb's set, use inversion */
      
        out_diadic_op( OP_NOT, ADDR_MODE_IMMEDIATE, r, ~n,
		    examines0(),
		    alters2( r, RR_ST ) );
    }
  else
    {
      /*
       * Other op codes we could try ....
       *
       * LDF, NORM, RND, FLOAT, FIX
       */
      
      /* load high part -- bottom 16 bits are set to 0 */

      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, r, n >> 16,
		    examines0(),
		    alters1( r ) );

      /* load low part */
      
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, r, n,
		    examines1( r ),
		    alters2( r, RR_ST ) );
    }
      
  if (must_save_st)
    {
      /* restore ST */

      ipop( RR_ST );
    }
  
  return;

} /* load_integer */


/*
 * output an instruction using immediate addressing with integer values
 * handles the case when triadic addressing may be necessary
 */

static void
integer_immediate_op(
		     int32		diadic_op,	/* diadic version of the operation */
		     int32		triadic_op,	/* triadic version of the operation */
		     RealRegister	dest,		/* detination register for operation */
		     RealRegister	source,		/* source register for operation */
		     int32		value,		/* the immediate value */
		     bool		signed_op )	/* TRUE if value op takes signed immediate values */
{
  if (is_word_addressed_( source ) || is_word_addressed_( dest ))
    {
      flush_pending_pushes();

      if (value & (sizeof_int - 1))
	syserr( syserr_non_word_offset );
      
      /* calculations use word addressing */
      
      value /= sizeof_int;
    }

  if (value == 0 && !no_peepholing)
    {
      if (diadic_op == OP_OR   ||
	  diadic_op == OP_XOR  ||
	  diadic_op == OP_ADDI ||
	  diadic_op == OP_SUBI )
	{
	  if (source != dest)
	    {
	      move_register( source, dest, FALSE, TRUE );
	      
	      peepf( "transformed addition into move" );

	      ++peep_transformed;
	    }
	  else
	    {
	      peepf( "eliminating op %lx with value 0", diadic_op );

	      ++peep_eliminated;
	    }

	  return;
	}
      else
	{
	  cc_warn( "possibly generating unneccessary op code %lx!", diadic_op );
	}
    }
  
  if (dest == source && (signed_op ? fits_in_16_bits_signed( value ) : fits_in_16_bits_unsigned( value )))
    {
      out_diadic_op( diadic_op, ADDR_MODE_IMMEDIATE, dest, value,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
    }
#ifdef TRIADIC_BINARY_OPS_ARE_UNSIGNED
  else if (signed_op ? fits_in_8_bits_signed( value ) : fits_in_8_bits_unsigned( value ))
#else
  else if (fits_in_8_bits_signed( value ))
#endif
    {
      out_triadic_op( triadic_op, dest, source, value, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( source ),
		     alters2( dest, RR_ST ) );
    }
  else if (diadic_op == OP_AND)
    {
      if (source == dest && fits_in_16_bits_unsigned( ~value ))
	{
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, dest, ~value,
			examines1( dest ),
			alters2( dest, RR_ST ) );
	}
#ifdef TRIADIC_BINARY_OPS_ARE_UNSIGNED
      else if (fits_in_8_bits_unsigned( ~value ))
#else
      else if (fits_in_8_bits_signed( ~value ))
#endif
	{
	  out_triadic_op( OP_ANDN3, dest, source, ~value, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( source ),
			 alters2( dest, RR_ST ) );
	}
      else
	{
	  RealRegister	tmp;

	  
	  tmp = R_TMP1;

	  if (dest == R_TMP1)
	    {
	      if (source == R_TMP2)
		{
		  tmp = R_TMP3;
		}
	      else
		{
		  tmp = R_TMP2;
		}
	    }
	  else if (source == R_TMP1)
	    {
	      if (dest == R_TMP2)
		{
		  tmp = R_TMP3;
		}
	      else
		{
		  tmp = R_TMP2;
		}
	    }
	  else
	    {
	      tmp = R_TMP1;
	    }
	  
	  load_integer( tmp, value, FALSE );
      
	  out_triadic_op( OP_AND3, dest, source, tmp, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( tmp, source ),
		     alters2( dest, RR_ST ) );
	}
    }
  else
    {
      RealRegister	tmp;

	  
      tmp = R_TMP1;
      
      if (dest == R_TMP1)
	{
	  if (source == R_TMP2)
	    {
	      tmp = R_TMP3;
	    }
	  else
	    {
	      tmp = R_TMP2;
	    }
	}
      else if (source == R_TMP1)
	{
	  if (dest == R_TMP2)
	    {
	      tmp = R_TMP3;
	    }
	  else
	    {
	      tmp = R_TMP2;
	    }
	}
      else
	{
	  tmp = R_TMP1;
	}
      
      load_integer( tmp, value, FALSE );
      
      out_triadic_op( triadic_op, dest, source, tmp, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( tmp, source ),
		     alters2( dest, RR_ST ) );
    }

  /* we have altered dest so do not remember it - maybe optimise one day ? */
  
  peep_forget_about( dest );
  
  return;
  
} /* integer_immediate_op */
  

#ifdef TARGET_HAS_FP_LITERALS

/*
 * Converts an IEEE number produced by the compiler into
 * a C40 short format floating point format number.  Returns
 * 0xFFFFFFFFU if the conversion fails
 */


static int32
convert_to_C40_format(
		      FloatCon *	fc,		/* the immediate value                  */
		      bool		is_double )	/* TRUE iff 'fc' is a 64 bit IEEE value */
{
  if (is_double)
    {
      unsigned32	high;
      int32		low;

      
      high = (unsigned32) IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &low );

      /* catch 0.0 */
      
      if (low == 0 && high == 0x80000000U)
	return 0x8000;
      
      if ((low & 0xfffff) == 0 &&		   /* no bits will be lost by the truncation */
	  (((high & 0xf8000000U) == 0) ||	   /* exponent is 0 to 7 */
	   ((high & 0xff000000U) >  0xf8000000U))) /* exponent in range -1 to -7 */
	{
	  return (high >> 12);
	}
    }
  else
    {
      unsigned32	val;
  

      val = (unsigned32) IEEE_to_single_float( fc->floatbin.fb.val );

      /* catch 0.0 */
      
      if (val == 0x80000000U)
	return 0x8000;

      if ( ((val & 0xfff) == 0) &&			/* no bits will be lost by truncation */
	  (((val & 0xf8000000U) == 0) ||		/* exponent is in range 0 to 7 */
	   ((val & 0xff000000U) >  0xf8000000U)))	/* exponent is in range -1 to -7 */
	return (val >> 12);
    }

  /* indicate that the conversion failed */
  
  return 0xFFFFFFFFU;
  
} /* convert_to_C40_format */


/*
 * returns TRUE if the floating point value is suitable for use by the op code indicated
 */

bool
fpliteral(
	  FloatCon *	fc,
	  J_OPCODE	op )
{
  if (convert_to_C40_format( fc, (bool) J_fltisdouble( op ) ) != 0xFFFFFFFFU)
    return TRUE;

  return FALSE;
  
} /* fpliteral */


/*
 * output an instruction using immediate addressing with floating point values
 * handles the case when triadic addressing may be necessary
 */

static void
float_immediate_op(
		   int32	op,		/* the instruction to be performed      */
		   RealRegister	dest,		/* detination register for operation    */
		   RealRegister	source,		/* source register for operation        */
		   FloatCon *	fc,		/* the immediate value                  */
		   bool		is_double )	/* TRUE iff 'fc' is a 64 bit IEEE value */
{
  int32		val;
  
  
#ifdef DEBUG
  if (!is_float( source ))
    syserr( syserr_non_float_source );
  
  if (source != dest && !is_float( dest ))
    syserr( syserr_non_float_dest );
#endif

  val = convert_to_C40_format( fc, is_double );

  if (val == 0xFFFFFFFFU)
    {
      syserr( syserr_FP_value_not_fit );
  
      return;
    }
  
  /* check for operations using immediate value 0.0 */
  
  if (val == 0x8000)
    {
      if (!no_peepholing)
	{
	  if (op == OP_ADDF || op == OP_SUBF)
	    {
	      if (source != dest)
		{
		  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, dest, source,
				examines1( source ),
				alters2( dest, RR_ST ) );
		  
		  peepf( "transformed FP addition of 0.0 into move" );

		  ++peep_transformed;
		}
	      else
		{
		  peepf( "eliminating op %lx with value 0", op );

		  ++peep_eliminated;
		}
	      
	      return;
	    }
	  else if (op == OP_MPYF)
	    {
	      out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, dest,
			    0x8000,
			    examines0(),
			    alters2( dest, RR_ST ) );
	      
	      peepf( "transformed FP multiplication of 0.0 into load" );

	      ++peep_transformed;
	      
	      return;
	    }
	  
	  cc_warn( "possibly generating unneccessary op code %lx!", op );
	}
      
      if (dest == source)
	{
	  out_diadic_op( op, ADDR_MODE_IMMEDIATE, source,
			0x8000,
			examines1( source ),
			alters2( source, RR_ST ) );
	}
      else
	{
	  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, dest, source,
			examines1( source ),
			alters2( dest, RR_ST ) );
	  
	  out_diadic_op( op, ADDR_MODE_IMMEDIATE, dest,
			0x8000,
			examines1( dest ),
			alters2( dest, RR_ST ) );
	}
    }

  if (dest != source)
    {
      out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, dest, source,
		    examines1( source ),
		    alters2( dest, RR_ST ) );
    }

  out_diadic_op( op, ADDR_MODE_IMMEDIATE, dest, val,
		examines1( dest ),
		alters2( dest, RR_ST ) );
  
  return;
  
} /* float_immediate_op */


/*
 * Compare register 'r' with the floating point constant 'fc' using comparison 'test'
 */

static void
compare_float(
	      RealRegister	r,
	      FloatCon *	fc,
	      int32 		test,
	      bool		is_double )
{
  int32		val;
  

#ifdef DEBUG
  if (test == Q_AL)
    {
      syserr( syserr_void_compare );
    }
#endif
  
  correct_stack( TRUE );

  val = convert_to_C40_format( fc, is_double );

  if (val == 0xFFFFFFFFU)
    {
      syserr( syserr_FP_value_not_fit );

      return;
    }

  if (!is_double && fast_FP)
    {
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r, r,
		    examines1( r ),
		    alters2( r, RR_ST ) );
    }
  
  out_diadic_op( OP_CMPF, ADDR_MODE_IMMEDIATE, r,
		val,
		examines1( r ),
		alters1( RR_ST ) );

  return;
  
} /* compare_float */

#endif /* TARGET_HAS_FP_LITERALS */
  
/*
 * Set register 'r' to the floating point value 'n'
 */

static void
load_float(
	   RealRegister	r,		/* register into which constant is to be loaded	*/
	   FloatCon * 	fc,		/* constant to be loaded 			*/
	   bool		is_double )	/* true if the constant is double precision	*/
{
  int32	val;
      
#ifdef DEBUG
  if (!is_float( r ))
    {
      syserr( syserr_non_float_dest );
    }
#endif

  val = convert_to_C40_format( fc, is_double );
      
  if (val != 0xFFFFFFFFU)
    {
      out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r, val,
		    examines0(),
		    alters2( r, RR_ST ) );
    }
  else if (is_double)
    {
      unsigned32	high;
      int32		low;

      
      high = (unsigned32) IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &low );
      
      /*
       * Other op codes we could try ....
       *
       * FLOAT, LDE, LDM, RND, FLOAT
       */
      
      /* load high part of FP number */
      
      load_integer( R_TMP1, high, FALSE );
      
      /* save as integer */
      
      ipush( R_TMP1 );
      
      /* pop as FP */
      
      fpop( r );
      
      if (low & 0xFF)
	{
	  /* OR in low part of FP number */
	  
	  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, r, low & 0xFF,
			examines1( r ),
			alters2( r, RR_ST ) );
	}
    }
  else
    {
      int32	val;


      /* convert */
      
      val = IEEE_to_single_float( fc->floatbin.fb.val );
      
      /* load high part of FP number */
	  
      load_integer( R_TMP1, val, FALSE );

      /* save as integer */
      
      ipush( R_TMP1 );
      
      /* pop as FP */
      
      fpop( r );
    }

  return;
  
} /* load_float */


/*
 * converts the byte offset in 'src' into a word offset in 'dest'
 * returns TRUE if the result is already biased by R_BASE
 */

static bool
convert_to_word_alignment(
			  RealRegister	src,		/* register contain byte offset 	*/
			  RealRegister	dest,		/* register to contain word offset 	*/
			  int32		offset,		/* offset in bytes to be added in 	*/
			  int32 *	bias_offset )	/* return value for bias offset or NULL	*/
{
  RealRegister	ar;
  int32		off;
  bool		biased;
  
  
  offset /= sizeof_int;

  ar = peep_find_loaded_addr_reg( src, &off, &biased );
  
  if (!no_peepholing      &&
      bias_offset != NULL &&
      ar          != GAP   )
    {
      if (offset == off)
	{
	  peepf( "eliminated load and add to temporary address register" );

	  if (ar == dest)
	    {
	      peep_eliminated += 2;
	    }
	  else
	    {
	      move_register( ar, dest, FALSE, TRUE );

	      peep_note_addr_reg_loaded( dest, src, off, biased );
	      
	      peep_eliminated += 1;
	    }

	  if (biased)
	    {
	      *bias_offset = 0;

	      return TRUE;
	    }
	  
	  return FALSE;
	}
      else if (biased)
	{
	  if (fits_in_8_bits_unsigned( abs( offset - off )))
	    {
	      if (ar != dest)
		{
		  move_register( ar, dest, FALSE, TRUE );

		  peep_corrupt_addr_reg( ar );

		  peep_note_addr_reg_loaded( dest, src, offset, TRUE );
		}

	      *bias_offset = offset - off;

	      return TRUE;
	    }
	}
      else
	{
	  if (ar == dest && fits_in_16_bits_signed( offset - off ))
	    {
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, offset - off,
			    examines1( dest ),
			    alters2( dest, RR_ST ) );
		  
	      peepf( "eliminated load to temporary address register" );

	      ++peep_eliminated;
	      
	      peep_note_addr_reg_loaded( dest, src, offset, FALSE );
		  
	      return FALSE;
	    }
	}
    }
  
  /* divide address by sizeof_int (here assumed to be 4) and place in dest */

  if (dest == src)
    {
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dest, -2,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
    }
  else
    {
      out_triadic_op( OP_LSH3, dest, src, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( src ),
		     alters2( dest, RR_ST ) );
    }

  if (offset == 0)
    {
      ;	/* do nothing */
    }
  else if (fits_in_16_bits_signed( offset ))
    {
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, offset,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
    }
  else
    {
      if (dest == R_TMP2)
	syserr( syserr_offset_reg_conflict );

      load_integer( R_TMP2, offset, FALSE );
      
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP2,
		    examines2( dest, R_TMP2 ),
		    alters2( dest, RR_ST ) );
    }
      
  peep_note_addr_reg_loaded( dest, src, offset, FALSE );
  
  return FALSE;

} /* convert_to_word_alignment */
  

/*
 * perform 'dst' = 'op' 'src','offset'
 *
 * ie using indirect addressing off 'src'
 */

static void
out_immediate_offset(
		     int32		op,			/* op code of operation to be performed	*/
		     RealRegister	dst,			/* register to be loaded with result	*/
		     RealRegister	src,			/* register pointing to source value	*/
		     int32		offset,			/* offset from location pointed to	*/
		     int32		can_corrupt_src )	/* non-zero if 'src' may be courrupted	*/
{
  bool		is_store = (op == OP_STI || op == OP_STF);
  RealRegister	ar       = R_ATMP;


  if (is_word_addressed_( src ))
    {
      /*
       * the stack pointer and frame pointers are always
       * word pointers so no special adjustments should
       * be necessary
       */
      
      /* check to see if we about to access the stack and there are pushes pending */
      
      if (src == R_SP)
	{
	  flush_pending_pushes();
	}
	  
      offset /= sizeof_int;

      if (offset)
	{
	  if (!fits_in_8_bits_unsigned( abs( offset ) ))
	    {
	      int32		off;
	      bool		biased;


	      ar = peep_find_loaded_addr_reg( src, &off, &biased );
	      
	      if (!no_peepholing  &&
		  ar     != GAP   &&
		  biased == FALSE &&
		  fits_in_16_bits_signed( offset - off ) )
		{
		  peepf( "eliminated load to temporary address register" );

		  if ((offset - off) == 0)
		    {
		      peep_eliminated += 2;
		    }
		  else
		    {
		      ++peep_eliminated;
		      
		      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, ar, offset - off,
				    examines1( ar ),
				    alters2( ar, RR_ST ) );
		    }
		}
	      else
		{
		  if (ar == GAP)
		    {
		      ar = peep_get_free_addr_reg( GAP );
		    }
		  
		  load_integer( ar, offset, FALSE );

		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, src,
				examines2( src, ar ),
				alters2( ar, RR_ST ) );
		}
			    
	      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
			    is_store ? examines2( dst, ar ) : examines1( ar ),
			    is_store ? alters0()            : alters2( dst, RR_ST ) );

	      peep_note_addr_reg_loaded( ar, src, offset, FALSE );
	    }
	  else if (offset > 0)
	    {
	      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD, src, offset ),
			    is_store ? examines2( dst, src ) : examines1( src ),
			    is_store ? alters0()             : alters2( dst, RR_ST ) );
	    }
	  else
	    {
	      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_SUB, src, -offset ),
			    is_store ? examines2( dst, src ) : examines1( src ),
			    is_store ? alters0()             : alters2( dst, RR_ST ) );
	    }
	}
      else
	{
	  out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, src, 0 ),
			    is_store ? examines2( dst, src ) : examines1( src ),
			    is_store ? alters0()             : alters2( dst, RR_ST ) );
	}
    }
  else if (can_corrupt_src && is_address_register( hardware_register( src )))
    {
      /* divide by sizeof_int (here assumed to be 4) */
      
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, src, -2,
		     examines1( src ),
		     alters2( src, RR_ST ) );

      offset /= sizeof_int;

      if (offset == 0)
	{
	  ;	/* do nothing */
	}
      else if (fits_in_16_bits_signed( offset ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, src, offset,
			examines1( src ),
			alters2( src, RR_ST ) );
	}
      else
	{
	  if (src == R_TMP2)
	    syserr( syserr_offset_reg_conflict );

	  load_integer( R_TMP2, offset, FALSE );
	  
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, src, R_TMP2,
			examines2( src, R_TMP2 ),
			alters2( src, RR_ST ) );
	}

      /* send the operation */
      
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR_IR0, src, 0 ),
		    is_store ? examines3( dst, R_BASE, src ) : examines2( R_BASE, src ),
		    is_store ? alters1( src )                : alters3( src, dst, RR_ST ) );
      
      peep_corrupt_addr_reg( src );
    }
  else
    {
      int32	off;


      
      if (src == R_ATMP)
	{
	  /* XXX - this can happen with the code generated during the static data initialisation phase */
	  
	  ar = RR_AR2;
	}
      else
	{
	  ar = peep_find_loaded_addr_reg( src, NULL, NULL );
	  
	  if (ar == GAP)
	    ar = peep_get_free_addr_reg( src );

	  if (ar == GAP)
	    {
	      peep_corrupt_addr_reg( R_ATMP );
	      
	      ar = R_ATMP;
	    }
	}

      if (convert_to_word_alignment( src, ar, offset, &off ))
	{
	  if (off > 0)
	    out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR, ar, off ),
			  is_store ? examines2( dst, ar ) : examines1( ar ),
			  is_store ? alters1( ar )        : alters3( ar, dst, RR_ST ) );
	  else if (off == 0)
	    out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
			  is_store ? examines2( dst, ar ) : examines1( ar ),
			  is_store ? alters0()            : alters2( dst, RR_ST ) );
	  else
	    out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_DECR, ar, -off ),
			  is_store ? examines2( dst, ar ) : examines1( ar ),
			  is_store ? alters1( ar )        : alters3( ar, dst, RR_ST ) );
	}
      else
	{
	  /* send the operation */
      
	  out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR_IR0, ar, 0 ),
			is_store ? examines3( dst, R_BASE, ar ) : examines2( R_BASE, ar ),
			is_store ? alters1( ar )                : alters3( ar, dst, RR_ST ) );
	}
      
      peep_note_addr_reg_loaded( ar, src, offset / sizeof_int, TRUE );
    }
  
  if (op == OP_LDI || op == OP_LDF || op == OP_LDA)
    {
      /* if dest is also in an address register, forget about it */
      
      peep_forget_about( dst );      
    }  

  return;

} /* out_immediate_offset */


/*
 * load a double precision value from the address in 'dst'
 * offset by 'offset'
 */

static void
load_double_relative(
		     RealRegister	dst,			/* register to be loaded 		*/
		     RealRegister	src,			/* register containing address 		*/
		     int32		offset,			/* byte offset from the address 	*/
		     int32		can_corrupt_src )	/* non-zero if 'src' may be courrupted	*/
{
  RealRegister	ar;

  
#ifdef DEBUG
  if (!is_float( dst ))
    syserr( syserr_non_float_dest );
#endif
  
  /* NB/ LDF before LDI */

  if (is_word_addressed_( src ))
    {
      if (src == R_SP)
	{
	  flush_pending_pushes();
	}
	  
      offset /= sizeof_int;

      if (fits_in_8_bits_unsigned( abs( offset + 1 ) ))
	{
	  if (offset == 0)
	    {
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_REL, src, 0 ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_ADD, src, 1 ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
	    }
	  else if (offset > 0)
	    {
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_ADD, src, offset ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_ADD, src, offset + 1 ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
	    }
	  else
	    {
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_SUB, src, -offset ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_SUB, src, -offset - 1 ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
	    }
	}
      else
	{
	  int32	off;
	  bool	biased;
	  
	    
	  ar = peep_find_loaded_addr_reg( src, &off, &biased );

	  if (!no_peepholing &&
	      ar     != GAP  &&
	      biased == FALSE )
	    {
	      off = offset - off;

	      
	      if (off == 0)
		{
		  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
				examines1( ar ),
				alters2( dst, RR_ST ) );
		}
	      else if (fits_in_8_bits_unsigned( off ))
		{
		  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR, ar, off ),
				examines1( ar ),
				alters3( ar, dst, RR_ST ) );	      
		}
	      else if (fits_in_8_bits_unsigned( -off ))
		{
		  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_DECR, ar, -off ),
				examines1( ar ),
				alters3( ar, dst, RR_ST ) );	      
		}
	      else if (fits_in_16_bits_signed( off ))
		{
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, ar, off,
				examines1( ar ),
				alters2( ar, RR_ST ) );

		  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
				examines1( ar ),
				alters2( dst, RR_ST ) );
		}
	      else
		{
		  /* sigh, we have to do this by hand */
		  
		  load_integer( ar, offset, FALSE );

		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, src,
				examines2( src, ar ),
				alters2( ar, RR_ST ) );
		  
		  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
				examines1( ar ),
				alters2( dst, RR_ST ) );
		}
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR, ar, 1 ),
			    examines1( ar ),
			    alters3( ar, dst, RR_ST ) );		  

	      peep_note_addr_reg_loaded( ar, src, offset + 1, FALSE );
	    }
	  else
	    {
	      if (ar == GAP)
		{
		  ar = peep_get_free_addr_reg( GAP );
		}

	      load_integer( ar, offset, FALSE );

	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, src,
			    examines2( src, ar ),
			    alters2( ar, RR_ST ) );
		  
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
			    examines1( ar ),
			    alters2( dst, RR_ST ) );
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR, ar, 1 ),
			    examines1( ar ),
			    alters3( dst, ar, RR_ST ) );		  

	      peep_note_addr_reg_loaded( ar, src, offset + 1, FALSE );
	      
	    }
	}
    }
  else if (can_corrupt_src &&
	   is_address_register( hardware_register( src )) &&
	   fits_in_16_bits_signed( offset / sizeof_int ))
    {
      /* divide by sizeof_int (here assumed to be 4) */
      
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, src, -2,
		     examines1( src ),
		     alters2( src, RR_ST ) );

      offset /= sizeof_int;

      if (offset != 0)
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, src, offset,
			examines1( src ),
			alters2( src, RR_ST ) );
	}

      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
		    build_indirect( INDIRECT_PRE_INCR_IR0, src, 0 ),
		    examines2( src, R_BASE ),
		    alters3( dst, src, RR_ST ) );
	      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
		    build_indirect( INDIRECT_PRE_INCR, src, 1 ),
		    examines1( src ),
		    alters3( dst, src, RR_ST ) );		  

      peep_corrupt_addr_reg( src );
    }
  else
    {
      int32	off;

      
      ar = peep_find_loaded_addr_reg( src, NULL, NULL );
	  
      if (ar == GAP)
	{
	  ar = peep_get_free_addr_reg( src );

	  if (ar == GAP)
	    {
	      peep_corrupt_addr_reg( R_ATMP );
	  
	      ar = R_ATMP;
	    }
	}

      if (convert_to_word_alignment( src, ar, offset, &off ))
	{
	  if (off > 0)
	    {
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR, ar, off ),
			    examines1( ar ),
			    alters3( ar, dst, RR_ST ) );
	    }
	  else if (off == 0)
	    {
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
			    examines1( ar ),
			    alters2( dst, RR_ST ) );
	    }
	  else
	    {
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_DECR, ar, -off ),
			    examines1( ar ),
			    alters3( ar, dst, RR_ST ) );
	    }
	}
      else
	{
	  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR_IR0, ar, 0 ),
			examines2( R_BASE, ar ),
			alters3( ar, dst, RR_ST ) );
	}
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR, ar, 1 ),
		    examines1( ar ),
		    alters3( ar, dst, RR_ST ) );
      
      peep_note_addr_reg_loaded( ar, src, offset / sizeof_int + 1, TRUE );
    }
  
  /* if dest is also in an address register, forget about it */
      
  peep_forget_about( dst );
  
  return;
  
} /* load_double_relative */


/*
 * store a double precision value into the address in 'dst'
 * offset by 'offset'
 */

static void
store_double_relative(
		      RealRegister	val,			/* register containing the value	*/
		      RealRegister	addr,			/* register containing the address 	*/
		      int32		offset,			/* offset from the address in bytes	*/
		      int32		can_corrupt_addr )	/* non-zero if 'addr' may be courrupted	*/

{
  RealRegister	ar;


#ifdef DEBUG
  if (!is_float( addr ))
    syserr( syserr_non_float_source );
#endif
  
  /* NB/ STI must be AFTER the STF in memory */

  if (is_word_addressed_( addr ))
    {
      /*
       * the stack pointer and frame pointers are always
       * word pointers so no special adjustments should
       * be necessary
       */
      
      /* check to see if we about to access the stack and there are pushes pending */
      
      if (addr == R_SP)
	{
	  flush_pending_pushes();
	}
	  
      offset /= sizeof_int;

      if (fits_in_8_bits_unsigned( abs( offset + 1 ) ))
	{
	  if (offset == 0)
	    {
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_REL, addr, 0 ),
			    examines2( val, addr ),
			    alters0() );
	      
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_ADD, addr, 1 ),
			    examines2( val, addr ),
			    alters0() );
	    }
	  else if (offset > 0)
	    {
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_ADD, addr, offset ),
			    examines2( val, addr ),
			    alters0() );
	      
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_ADD, addr, ++offset ),
			    examines2( val, addr ),
			    alters0() );
	    }
	  else
	    {
	      offset = -offset;
	      
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_SUB, addr, offset ),
			    examines2( val, addr ),
			    alters0() );
	      
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_SUB, addr, --offset ),
			    examines2( val, addr ),
			    alters0() );
	    }
	}
      else
	{
	  int32	off;
	  bool	biased;
	  
	    
	  ar = peep_find_loaded_addr_reg( addr, &off, &biased );

	  if (!no_peepholing &&
	      ar     != GAP  &&
	      biased == FALSE )
	    {
	      off = offset - off;

	      
	      if (off == 0)
		{
		  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_REL, ar, 0 ),
				examines2( val, ar ),
				alters0() );
		}
	      else if (fits_in_8_bits_unsigned( off ))
		{
		  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR, ar, off ),
				examines2( val, ar ),
				alters1( ar ) );	      
		}
	      else if (fits_in_8_bits_unsigned( -off ))
		{
		  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_DECR, ar, -off ),
				examines2( val, ar ),
				alters1( ar ) );	      
		}
	      else if (fits_in_16_bits_signed( off ))
		{
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, ar, off,
				examines1( ar ),
				alters2( ar, RR_ST ) );

		  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_REL, ar, 0 ),
				examines2( val, ar ),
				alters0() );
		}
	      else
		{
		  /* sigh, we have to do this by hand */
		  
		  load_integer( ar, offset, FALSE );

		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, addr,
				examines2( addr, ar ),
				alters2( ar, RR_ST ) );
		  
		  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_REL, ar, 0 ),
				examines2( val, ar ),
				alters0() );
		}
	      
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR, ar, 1 ),
			    examines2( val, ar ),
			    alters1( ar ) );		  

	      peep_note_addr_reg_loaded( ar, addr, offset + 1, FALSE );
	    }
	  else
	    {
	      if (ar == GAP)
		{
		  ar = peep_get_free_addr_reg( GAP );
		}

	      load_integer( ar, offset, FALSE );

	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, addr,
			    examines2( addr, ar ),
			    alters2( ar, RR_ST ) );
		  
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_REL, ar, 0 ),
			    examines2( val, ar ),
			    alters0() );
	      
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR, ar, 1 ),
			    examines2( val, ar ),
			    alters1( ar ) );		  

	      peep_note_addr_reg_loaded( ar, addr, offset + 1, FALSE );
	      
	    }
	}
    }
  else if (can_corrupt_addr &&
	   is_address_register( hardware_register( addr )) &&
	   fits_in_16_bits_signed( offset / sizeof_int ))
    {
      /* divide by sizeof_int (here assumed to be 4) */
      
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
		     examines1( addr ),
		     alters2( addr, RR_ST ) );

      offset /= sizeof_int;

      if (offset != 0)
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, addr, offset,
			examines1( addr ),
			alters2( addr, RR_ST ) );
	}

      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR_IR0, addr, 0 ),
		    examines3( val, addr, R_BASE ),
		    alters1( addr ) );
	      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR, addr, 1 ),
		    examines2( val, addr ),
		    alters1( addr ) );		  

      peep_corrupt_addr_reg( addr );
    }
  else
    {
      int32	off;

      
      ar = peep_find_loaded_addr_reg( addr, NULL, NULL );
	  
      if (ar == GAP)
	{
	  ar = peep_get_free_addr_reg( addr );

	  if (ar == GAP)
	    {
	      peep_corrupt_addr_reg( R_ATMP );
	  
	      ar = R_ATMP;
	    }
	}

      if (convert_to_word_alignment( addr, ar, offset, &off ))
	{
	  if (off > 0)
	    {
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR, ar, off ),
			    examines2( val, ar ),
			    alters1( ar ) );
	    }
	  else if (off == 0)
	    {
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_REL, ar, 0 ),
			    examines2( val, ar ),
			    alters0() );
	    }
	  else
	    {
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_DECR, ar, -off ),
			    examines2( val, ar ),
			    alters1( ar ) );
	    }
	}
      else
	{
	  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR_IR0, ar, 0 ),
			examines3( val, R_BASE, ar ),
			alters1( ar ) );
	}
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR, ar, 1 ),
		    examines2( val, ar ),
		    alters1( ar ) );
      
      peep_note_addr_reg_loaded( ar, addr, offset / sizeof_int + 1, TRUE );
    }
  
  return;

} /* store_double_relative */



/*
 * perform 'dst' = 'op' 'src','offset'
 *
 * ie using indirect addressing off 'src'
 */

static void
out_register_offset(
		    int32		op,		/* operation to perform 		*/
		    RealRegister	dst,		/* destintaion of operation 		*/
		    RealRegister	src,		/* address of value for operation 	*/
		    RealRegister	offset )	/* offset from source address 		*/
{
  bool		is_store = (op == OP_STI || op == OP_STF);
  RealRegister	ar;

  
  if (is_word_addressed_( src ))
    {
      int32	off;
      bool	biased;

      
      /* check to see if we about to access the stack and there are pushes pending */
      
      if (src == R_SP)
	{
	  flush_pending_pushes();
	}
	  
      /*
       * XXX
       *
       * we could save an instruction here if we could use IR1,
       * ie:
       *
       *	LSH3  offset, -2, IR1
       *	op    *+src(IR1), dst
       *
       * instead of:
       *	LSH3  offset, -2, R_ATMP
       *	ADDI  src,     R_ATMP
       *        op    *R_ATMP, dst
       */


      ar = peep_find_loaded_addr_reg( offset, &off, &biased );

      if (ar     != GAP  &&
	  off    == 0    &&
	  biased == FALSE )
	{
	  peepf( "eliminated register conversion" );

	  ++peep_eliminated;
	}
      else
	{
	  /* get an address register */
	  
	  ar = peep_get_free_addr_reg( GAP );
	  
	  /* copy offset to address register adjusting for word offsets */

	  (void) convert_to_word_alignment( offset, ar, 0, NULL );
	}
      
      /* add in the source register */
      
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, src,
		    examines2( src, ar ),
		    alters2( ar, RR_ST ) );

      /* do not remember contents of 'ar' as we have just corrupted it */

      peep_corrupt_addr_reg( ar );
      
      /* and perform op */

      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
		    is_store ? examines2( dst, ar ) : examines1( ar ),
		    is_store ? alters0()            : alters2( dst, RR_ST ) );
    }
  else
    {
      ar = peep_get_free_addr_reg( GAP );
      
      /* add offset to address and place in temporary register */

      out_triadic_op( OP_ADDI3, ar, offset, src, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( offset, src ),
		     alters2( ar, RR_ST ) );

      /* forget about contents of address reg */

      peep_corrupt_addr_reg( ar );
      
      /* loose bottom two bits (byte selector) */

      (void) convert_to_word_alignment( ar, ar, 0, NULL );

      /* complete operation */
      
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, ar, 0 ),
		    is_store ? examines3( dst, ar, R_BASE ) : examines2( R_BASE, ar ),
		    is_store ? alters0()                    : alters2( dst, RR_ST ) );
    }
  
  if (op == OP_LDI || op == OP_LDF || op == OP_LDA)
    {
      peep_forget_about( dst );      
    }
  
  return;

} /* out_register_offset */


static void
load_double_indirect(
		     RealRegister	dst,		/* destintaion of operation */
		     RealRegister	src,		/* address of value for operation */
		     RealRegister	offset )	/* offset from source address */
{
  RealRegister	ar;

  
#ifdef DEBUG
  if (!is_float( dst ))
    syserr( syserr_non_float_dest );
#endif
  
  /* NB/ LDF before LDI */
  
  if (is_word_addressed_( src ))
    {
      int32	off;
      bool	biased;

      
      /* check to see if we about to access the stack and there are pushes pending */
      
      if (src == R_SP)
	{
	  flush_pending_pushes();
	}

      ar = peep_find_loaded_addr_reg( offset, &off, &biased );

      if (ar     != GAP  &&
	  off    == 0    &&
	  biased == FALSE )
	{
	  peepf( "eliminated register transfer" );

	  ++peep_eliminated;
	}
      else
	{
	  ar = peep_get_free_addr_reg( GAP );
	  
	  /* copy offset to temporary register adjusting for word offsets */

	  (void) convert_to_word_alignment( ar, offset, 0, NULL );
	}
      
      /* add in the source register */
      
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, src,
		    examines2( src, ar ),
		    alters2( ar, RR_ST ) );

      /* forget about contents of 'ar' */

      peep_corrupt_addr_reg( ar );
      
      /* and perform load */

      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, ar, 0 ),
		    examines1( ar ),
		    alters2( dst, RR_ST ) );
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD, ar, 1 ),
		    examines1( ar ),
		    alters2( dst, RR_ST ) );
    }
  else
    {
      ar = peep_get_free_addr_reg( GAP );
      
      /* add offset to address and place in temporary register */

      out_triadic_op( OP_ADDI3, ar, src, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( offset, src ),
		     alters2( ar, RR_ST ) );

      /* forget about contents of 'ar' */

      peep_corrupt_addr_reg( ar );
      
      /* loose bottom two bits (byte selector) */

      (void) convert_to_word_alignment( ar, ar, 0, NULL );
      
      /* complete operation (NB/ LDF before LDI) */
  
      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR_IR0, ar, 0 ),
		    examines2( R_BASE, ar ),
		    alters3( dst, ar, RR_ST ) );
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD, ar, 1 ),
		    examines1( ar ),
		    alters2( dst, RR_ST ) );
    }

  peep_forget_about( dst );
  
  return;

} /* load_double_indirect */


static void
store_double_indirect(
		     RealRegister	val,		/* source of value to store	*/
		     RealRegister	addr,		/* address into which to store	*/
		     RealRegister	offset )	/* offset from address		*/
{
  RealRegister	ar;

  
#ifdef DEBUG
  if (!is_float( val ))
    syserr( syserr_non_float_source );
#endif
  
  /* NB/ STI must be AFTER the STF in memory */
  
  if (is_word_addressed_( addr ))
    {
      int32	off;
      bool	biased;
      
      
      /* check to see if we about to access the stack and there are pushes pending */
      
      if (addr == R_SP)
	{
	  flush_pending_pushes();
	}

      ar = peep_find_loaded_addr_reg( offset, &off, &biased );

      if (ar     != GAP  &&
	  off    == 0    &&
	  biased == FALSE )
	{
	  peepf( "eliminated register load" );

	  ++peep_eliminated;
	}
      else
	{
	  ar = peep_get_free_addr_reg( GAP );
	  
	  /* copy offset to temporary register adjusting for word offsets */

	  (void) convert_to_word_alignment( ar, offset, 0, NULL );
	}
      
      /* add in the source register */
      
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, addr,
		    examines2( addr, ar ),
		    alters2( ar, RR_ST ) );

      /* forget about contents of ar */

      peep_corrupt_addr_reg( ar );
      
      /* and perform store */
      
      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_REL, ar, 0 ),
		    examines2( val, ar ),
		    alters0() );

      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_ADD, ar, 1 ),
		    examines2( val, ar ),
		    alters0() );
    }
  else
    {
      ar = peep_get_free_addr_reg( GAP );
      
      /* add offset to address and place in temporary register */

      out_triadic_op( OP_ADDI3, ar, addr, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( addr, offset ),
		     alters2( ar, RR_ST ) );

      /* forget about contents of 'ar' */

      peep_corrupt_addr_reg( ar );
      
      /* loose bottom two bits (byte selector) */

      (void) convert_to_word_alignment( ar, ar, 0, NULL );

      /* complete store */
  
      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR_IR0, ar, 0 ),
		    examines3( val, R_BASE, ar ),
		    alters1( ar ) );
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_ADD, ar, 1 ),
		    examines2( val, ar ),
		    alters0() );
    }
  
  return;

} /* store_double_indirect */


#ifdef TARGET_HAS_PROFILE

typedef union count_position
  {
    int32 i;

    struct s
      {
	unsigned int posn : 12,
                     line : 16,
                     file : 4;
      }
    s;
  }
count_position;

#endif /* TARGET_HAS_PROFILE */

/*
 * ensures that the stack is increased or decreased as necessary
 */

void
correct_stack( bool flush_pushes )
{
  int32	move;

  
  if (stack_move == 0)
    {
      return;
    }

  if (flush_pushes)
    {
      flush_pending_pushes();
    }

  if (stack_move & (sizeof_long - 1))
    syserr( syserr_bad_stack_move, sizeof_long );

  move = stack_move / sizeof_long;

  /* NB/ do not use integer_immediate_op() as this might flush pushes */
  
  if (!fits_in_16_bits_signed( move ))
    {
      load_integer( R_TMP3, move, FALSE );
      
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_SP, R_TMP3,
		    examines2( R_SP, R_TMP3 ),
		    alters2( R_SP, RR_ST ) );
      
      peep_change_addr_offset( R_SP, move );
    }  
  else if (move > 0)
    {
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, move,
		    examines1( R_SP ),
		    alters2( R_SP, RR_ST ) );
      
      peep_change_addr_offset( R_SP, move );
    }
  else
    {
      out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_SP, -move,
		    examines1( R_SP ),
		    alters2( R_SP, RR_ST ) );
      
      peep_change_addr_offset( R_SP, move );
    }

  adjust_stack( -stack_move );
  
  return;
  
} /* correct_stack */


/*
 * Compare register 'r' with the integer 'n' using comparison 'test'
 */

static void
compare_integer(
		RealRegister	r,
		int32		n,
		int32 		test )
{
#ifdef DEBUG
  if (test == Q_AL)
    {
      syserr( syserr_void_compare );
    }
#endif
  
  correct_stack( TRUE );

  if (fits_in_16_bits_signed( n ))
    {
      if (n == 0 && !no_peepholing)
	{
	  /* check to see if the test is unnecessary */

	  if (peep_sets_status_reg( r ))
	    {
	      peepf( "eliminated compare!" );

	      ++peep_eliminated;
	      
	      return;
	    }
	}
  
      /* 16 bit signed immediate - can do */

      out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, r, n,
		    examines1( r ),
		    alters1( RR_ST ) );
    }
  else
    {
      /* use the temporary register */
      
      load_integer( R_TMP1, n, FALSE );
      
      out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, r, R_TMP1,
		    examines2( r, R_TMP1 ),
		    alters1( RR_ST ) );
    }

  return;
  
} /* compare_integer */


/*
 * perform a shift by 'abs( amount )' on 'source'
 * placing the result in 'dest'.  If 'amount' < 0
 * the shift is to the right otherwise it is to the
 * left.  If 'arithmetic' is true the a right shift
 * should preserve the sign bit
 */
 
static void
shift_register(
	       bool		arithmetic,	/* true for arithmetic shift, false otherwise */
	       RealRegister	dest,
	       RealRegister	source,
	       int32		amount )
{
  /*
   * if amount < 0 then shift right otherwise shift left
   */

  if (amount == 0)
    {
      move_register( source, dest, FALSE, TRUE );

      return;
    }
  else if (amount >= 32)
    {
      /* nothing left in dest but 0's */

      cc_rerr( syserr_large_shift, (int)amount );

      /* still do the shift as we may want the last bit left in the carry flag */
      
      amount = 32;
    }
  else if (amount <= -32)
    {
      cc_rerr( syserr_large_shift, (int)amount );

      amount = -32;
    }

  /*
   * at this point we know that |amount| <= 32 and so fits in 8 bits
   */
  
  if (source == dest)
    {
      out_diadic_op( arithmetic ? OP_ASH : OP_LSH,
		     ADDR_MODE_IMMEDIATE, dest, amount,
		     examines1( dest ),
		     alters2( dest, RR_ST ) );
    }
  else
    {
      out_triadic_op( arithmetic ? OP_ASH3 : OP_LSH3,
		     dest, source, amount, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( source ),
		     alters2( dest, RR_ST ) );
    }
  
  peep_forget_about( dest );
  
  return;
  
} /* shift_register */


/*
 * register 'dest' = register 'source' * integer 'val'
 */

static void
multiply_integer(
		 RealRegister	dest,
		 RealRegister	source,
		 int32		val )
{
  /*
   * the following special cases are detected in cg.c (with the exception of
   * bitcount(-m) = 1, m != -1), but are included for completeness and because
   * there is a possibility they may be introduced by attempting to factorise
   * and invoke mulk recursively.
   */

  if (val == 0)
    {
      load_integer( dest, 0, FALSE );
    }
  else if (val == 1)
    {
      move_register( source, dest, FALSE, TRUE );
    }      
  else if (val == -1)
    {
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, dest, source,
		    examines1( source ),
		    alters2( dest, RR_ST ) );
    }
  else if (bitcount( val ) == 1)
    {
      shift_register( FALSE, dest, source, firstbit( val ) );
    }
  else if (fits_in_16_bits_signed( val ))
    {
      if (fits_in_8_bits_signed( val ))
	{
	  out_triadic_op( OP_MPYI3,
			 dest,
			 source,
			 val,
			 ADDR_MODE_REGISTER,
			 ADDR_MODE_IMMEDIATE,
			 examines1( source ),
			 alters2( dest, RR_ST ) );
	}
      else if (dest == source)
	{
	  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, dest, val,
			examines1( dest ),
			alters2( dest, RR_ST ) );
	}
      else
	{
	  load_integer( dest, val, FALSE );
	  
	  out_triadic_op( OP_MPYI3, dest, source, dest, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			examines2( source, dest ),
			alters2( dest, RR_ST ) );
	}
    }
  else if (bitcount( -val ) == 1)
    {
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, dest, source,
		    examines1( source ),
		    alters2( dest, RR_ST ) );
      
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dest, firstbit( -val ),
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
    }
  else
    {
      load_integer( R_TMP1, val, FALSE );

      out_triadic_op( OP_MPYI3, 
		     dest,
		     source,
		     R_TMP1,
		     ADDR_MODE_REGISTER,
		     ADDR_MODE_REGISTER,
		     examines1( source ),
		     alters2( dest, RR_ST ) );
    }
  
  peep_forget_about( dest );
  
  return;

} /* mutiply_integer */


/*
 * generates a branch by a given number
 * of instructions if a given condition is true
 */

static void
conditional_skip_instructions(
			      int32	condition,	/* condition - TI version */
			      int32	num_to_skip )	/* number of instructions to miss out */
{
  if (!fits_in_16_bits_signed( num_to_skip ))
    {
      syserr( syserr_too_many_to_skip, num_to_skip );

      return;
    }
  
  /* output a conditional branch (delayed), PC relative */
  
  outdelayed( (OP_BRcD << 24) | (0x1U << 21) | (condition << 16) | (num_to_skip & 0xffff),
	     condition == C_U ? examines0() : examines1( RR_ST ),
	     alters1( RR_PC ) );
  
  return;
  
} /* conditional_skip_instructions */


/*
 * This function handles the case of branching
 * to a label, possibly conditionally
 */

static void
conditional_branch_to(
		      int32		condition,
		      LabelNumber *	destination )
{
  /* don't keep pushes pending */
  
  flush_pending_pushes();

  if (destination == RETLAB)
    {
      /* AM: treat the special value RETLAB of destination as return address */

      destination = returnlab;

      if (condition == Q_AL)
	{
	  /* if get an unconditional return expand it inline      */
	  /* and save its address if it was the first             */
	  /* - but ACN suggests we may get better code by not     */
	  /* doing so, waiting instead until we are at ENDPROC    */
	  
	  /* if (!lab_isset_(destination)) setlabel(destination); */
	    
	  routine_exit( FALSE );
	  
	  return;
	}
      else if (!no_peepholing    &&	/* if we are allowed to peephole */
	       stack_move   == 0 &&	/* and the stack is OK */
	       stack_offset == 0 &&	/* totally OK */
	       saved_fvars  == 0 &&	/* and we have no register to pop */
	       saved_ivars  == 0 &&	/* ditto */
	       saved_frame  == 0 &&	/* ditto */
	       saved_args   == 0 &&	/* ditto */
	       !usrdbg( DBG_PROC ) )	/* and we do not want an exit routine called */
	{
	  peepf( "eliminated branch to return jump" );
	  
	  /* this is a conditional, delayed branch, register relative */
      
	  outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( condition ) << 16 | hardware_register( R_LR ),
		     examines2( R_LR, RR_ST ),
		     alters1( RR_PC ) );

	  return;
	}
    }

  /*
   * If the label we are branching to has
   * already been defined then we can
   * calculate the offset straight away
   */

  if (lab_isset_( destination ))
    {
      int32	w;
      int32	off;


      flush_peepholer( DBG( "backward conditional branch" ) );
  
      w   = (destination->u.defn) & 0x7fffffffU;	/* get position of label in our code */
      off = (w - codep) / sizeof_int - 3;		/* calculate offset (in words) */
      							/* (the -3 is because of the delay in the branch)  */
      
      if (condition == Q_AL && fits_in_24_bits_signed( off ))
	{
	  /* branch (delayed), PC relative */

	  outdellabref( OP_BRD << 24 | (off & 0xffffff),
		       destination,
		       LABREF_OFF24,
		       examines0(),
		       alters1( RR_PC ) );
	}
      else if (fits_in_16_bits_signed( off ))		/* short branch */
        {
	  conditional_skip_instructions( C_FROMQ( condition ), off );
        }
      else					/* word branch */
        {
	  syserr( syserr_cannot_cond_branch, off );
        }
    }
  else    /* Forward reference */
    {
      /*
       * put in a branch instruction with a fake offset as a placeholder
       * this will be patched with the correct offset when setlabel() is called
       * to actually position our destination label
       */

      if (condition == Q_AL)
	{
	  outdellabref( OP_BRD << 24 | (-3 & 0xffffff), destination, LABREF_OFF24,
		     examines0(), alters1( RR_PC ) );
	}
      else
        {
	  /* output a conditional branch (delayed), PC relative */
  
	  outdellabref( OP_BRcD << 24 | 0x1U << 21 | C_FROMQ( condition ) << 16 | (-3 & 0xffff),
		    destination,
		    LABREF_OFF16,
		    condition == Q_AL ? examines0() : examines1( RR_ST ),
		    alters1( RR_PC ) );
        }
    }

  return;
  
} /* conditional_branch_to */


/*
 * convert the absolute word address in 'reg'
 * into a byte offset from IR0
 */

static void
convert_to_byte_offset( RealRegister reg )
{
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, reg, R_BASE,
		examines2( reg, R_BASE ),
		alters2( reg, RR_ST ) );

  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, reg, 2,
		 examines1( reg ),
		 alters2( reg, RR_ST ) );

 return;
  
} /* convert_to_byte_offset */

  
/*
 * convert the byte offset in 'src'
 * into an absolute word address in 'dst'
 */

static void
convert_to_word_address(
			RealRegister src,	/* register to convert to word alignment	*/
			RealRegister dst )	/* register to hold result of convertion	*/
{
  int32	off;

  
  if (convert_to_word_alignment( src, dst, 0, &off ))
    {
      if (off != 0)
	integer_immediate_op( OP_ADDI, OP_ADDI3, dst, dst, off, TRUE );
    }
  else
    {
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dst, R_BASE,
		    examines2( dst, R_BASE ),
		    alters2( dst, RR_ST ) );

      peep_note_addr_reg_loaded( dst, src, 0, TRUE );
    }

 return;
  
} /* convert_to_word_address */


/*
 * find a symbol that is as close as possible
 * to the given symbol, including the offset
 * provided.
 */

static Symstr *
find_nearest_symbol(
		    Symstr * 	symbol,
		    unsigned32	offset )
{
  ExtRef *	r;
  ExtRef *	least;
  unsigned long	least_diff;
  
  
  offset += extoffset_( symext_( symbol ) );
  
  r = obj_symlist; 

  least      = NULL;
  least_diff = -1;

  /* debug( "searching for nearest match to %s, offset %d", symname_( symbol ), offset ); */
  
  for (; r != NULL; r = extcdr_( r ))
    {
      if (is_data( r ) && is_defined( r ))
	{
	  unsigned long	diff = abs( extoffset_( r ) - offset );


	  /* debug( "checking symbol %s, offset %d, diff %d",
	     symname_( extsym_( r ) ), extoffset_( r ), diff ); */

	  if (diff == 0 && extsym_( r ) != symbol)
	    return extsym_( r );
	  
	  if (diff <= least_diff)
	    {
	      least_diff = diff;
	      least      = r;
	    }	  
	}
    }

  /* debug( "result is %s", least == NULL ? "nothing" : symname_( extsym_( least ) ) ); */
  
  return least == NULL ? NULL : extsym_( least ) ;

} /* find_nearest_symbol */


/*
 * returns non-0 if the symbol is static
 * returns 0 otherwise
 */

static int32
static_definition( Symstr * name )
{
  if (bind_global_( name ) != 0)
#if 1
    {
      struct Binder * b = bind_global_( name );
      SET_BITMAP      s = bindstg_( b );
      return (s & bitofstg_( s_static ));      
    }  
#else
    return (bindstg_( bind_gloabl_( name ) ) & bitofstg_( s_static ) );
#endif
  else
    return 0;

} /* static_definition */


/*
 * XXX
 *
 * Module Layout
 *
 * version: 	7	(keep in step with stack scheme and register scheme)
 * date:	29/2/92
 *
 *
 *                                MT
 *                                |
 *                        (word pointer to)
 *                                |
 *                                v
 *                             ------------------------------ - - -
 *         The (split)      ->|       .      |      .      |
 *         Module Table    |  |   |   .    | |  |   .   |  |
 *                         |   ---|--------|----|-------|---- - - -
 *                         |______|     ^  |    |       |
 *                                      |  |    |       |
 *                                       --     |       |
 *                                              |       |
 *                                 _____________|       |____________________
 *                                |                                          |
 *                                |                                          |
 *                        (byte offset from IR0 of ...) (*)          (word pointer to)
 *                                |                                          |
 *                                v                                          |
 *      Per Module             ------------------------------ - - -          |
 *      Data Slots            |       |      |      |      |                 |
 * (one copy per process)     |       |      |      |      |                 |
 *                             ------------------------------ - - -          |
 *                                                                           |
 *                                                                           |
 *                                 __________________________________________|
 *                                |
 *                                |
 *                                v                                 
 *        Per Module           ------------------------------ - - - 
 *     Function Pointers      |       |      |      |      |        
 * (shared between processes) |   |   |      |      |      |        
 *                             ---|-------------------------- - - - 
 *                                |
 *                        (word address of first
 *                         function in module)
 *                                |
 *                                v
 *
 * (*) The data slot pointer is held as a byte offset, rather than a word pointer, because
 * all data pointers must be held as byte offsets, and data is fetched by taking the data
 * slot pointer from the module table and just adding a known byte offset to obtain a pointer
 * to the required piece of data.
 * 
 */


/*
 * Places a pointer to the static data area or the
 * function pointer table into the indicated register.
 *
 * If 'iscode' is true then the pointer returned is
 *   an absolute, word address,
 * whereas if 'iscode' is false then the pointer returned is
 *   a byte offset from IR0.
 */

void
load_static_data_ptr(
		     RealRegister	r,
		     bool		iscode,
		     Symstr *		symbol )
{
  RealRegister	tmp;
  int32		op;

  
  if (is_address_register( hardware_register( r ) ))
    {
      tmp = r;
    }
  else
    {
      tmp = peep_get_free_addr_reg( GAP );
    }

  if (is_special_register( hardware_register( r ) ))
    {
      op = OP_LDA;
    }
  else
    {
      op = OP_LDI;
    }
      
  if (!few_modules)
    {
      /*
       * XXX - we are assuming that the module number fits into 16 bits (signed)
       * (ie that there will never be more that 32766 modules) ...
       */

      /*
       * load the module table address into temporary address register
       */

      move_register( R_MT, tmp, FALSE, TRUE );
      
      /*
       * add in the offset of our module's entry in the module table
       */
  
      /*
       * indicate that the following instruction loads the module
       * number of the current module as the least 16 significant bits
       * of the instruction.  This number will actually have to be
       * inserted at link time (rather than now), so we use the cross
       * reference facility to ensure that the linker will patch
       * this instruction.  This instruction loads the WORD offset
       * from the module table pointer.
       */
  
      peep_xref( X_Modnum, symbol );
  
      if (iscode && split_module_table)
	{
	  /*
	   * if we are accessing the function table of a split
	   * module table then we actually want the next word on
	   */
      
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 1,
			examines0(),
			alters2( tmp, RR_ST ) );
	}
      else
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
			examines0(),
			alters2( tmp, RR_ST ) );
	}

      /*
       * get the appropriate pointer out of the module table
       */
  
      out_diadic_op( op, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, tmp, 0 ),
		    examines1( tmp ),
		    alters2( r, RR_ST ) );
    }
  else
    {
      /*
       * XXX - we are assuming that the module number fits into 8 bits (unsigned)
       * (ie that there will never be more that 255 modules) ...
       */

      peep_xref( X_Modnum, symbol );
  
      if (iscode && split_module_table)
	{
	  /*
	   * if we are accessing the function table of a split
	   * module table then we actually want the next word on
	   */
      
	  out_diadic_op( op, ADDR_MODE_INDIRECT, r,
			build_indirect( INDIRECT_PRE_ADD, R_MT, 1 ),
			examines1( R_MT ),
			alters2( r, RR_ST ) );
	}
      else
	{
	  out_diadic_op( op, ADDR_MODE_INDIRECT, r,
			build_indirect( INDIRECT_PRE_ADD, R_MT, 0 ),
			examines1( R_MT ),
			alters2( r, RR_ST ) );
	}
    }
  
  /* 'r' now contains the address or offset of the appropriate table */
  
  return;

} /* load_static_data_ptr */


bool
is_function( Symstr * symbol )
{
  struct Binder *	data;


#ifdef DEBUG
  /* be paranoid */
  
  if (symbol == NULL)
    syserr( syserr_null_pointer );
#endif
  
  /* catch a rare special case */
  
  if (symtype_( symbol ) != s_identifier)
    syserr( syserr_not_identifier );
  
  /* __dataseg has no data associated with it */
  
  if (symbol == bindsym_( datasegment ))
    return FALSE;
  
  /*
   * We default to FALSE because even though functions like
   * '__stackoverflow' & '_printf' have no data this function should
   * never be called for them, and local external data will have
   * no data.  ie
   *
   * int func ( void )
   * {
   *    extern int fred;
   *    return fred;
   * }
   *
   * Will call this function with a symbol 'fred' with no data.
   *
   */

  if ((data = bind_global_( symbol )) == NULL)
    {
      struct ExtRef *	ref;

      
      if ((ref = symext_( symbol )) != NULL)
	{
	  /* cope with external symbols */
	  
	  if (is_data( ref ))
	    {
	      return FALSE;
	    }
	  else
	    {
	      return TRUE;
	    }
	}
      else
	{
	  return FALSE;
	}
    }

  return ((bindstg_( data ) & b_fnconst) != 0 );

} /* is_function */


/*
 * place the address of 'symbol',
 * offset by 'offset'
 * into register 'dest'
 */

static void
load_address_constant(
		      RealRegister	dest,
		      Symstr *		symbol,
		      int32		offset )
{
  ExtRef *		x = symext_( symbol );
  int32 		d = obj_symref( symbol, xr_code, 0 );


  if (dest == R_SP)
    {
      syserr( syserr_fixed_SP );
    }
  /*
   * find out what kind of symbol we are dealing with
   */
  
  if (is_data( x ) && is_defined( x ))
    {
      /*
       * A previously defined data symbol
       *
       * address = module table[ our module number ].data_slots + offset_of_symbol_in_data_slots
       */

      if (suppress_module || !fits_in_16_bits_signed( offset + extoffset_( x ) ))
	{
	  Symstr *	newsymbol;

	  
	  /*
	   * try to eliminate references to __dataseg or offsets that do not fit in 16 bits
	   */
	      
	  if ((newsymbol = find_nearest_symbol( symbol, offset )) != NULL)
	    {
	      offset += extoffset_( symext_( symbol ) ) - extoffset_( symext_( newsymbol ) );
	      symbol = newsymbol;
	      x      = symext_( symbol );
	    }
        }

      if (suppress_module || !fits_in_16_bits_signed( offset + extoffset_( x ) ))
	{
	  /*
	   * get the address of the data slots of the current module into 'tmp'
	   */
      
	  load_static_data_ptr( dest, FALSE, symbol );

	  if (much_data)
	    {
	      /*
	       * load R_TMP1 with the high part offset of 'symbol' into the data table
	       */
	      
	      peep_xref( X_DataSymbHi, symbol );
	      
	      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
			    examines0(),
			    alters1( R_TMP1 ) );
	      
	      /*
	       * load R_TMP1 with the low part offset of 'symbol' into the data table
	       *
	       * Note that we cannot include 'offset' in this part of the addition because
	       * the sum of 'offset' and the low part of 'symbol's offset might exceeed 16
	       * bits
	       */
	      
	      peep_xref( X_DataSymbLo, symbol );
	      
	      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
			    examines1( R_TMP1 ),
			    alters1( R_TMP1 ) );	/* XXX - do not mention setting ST flag as ADDI does that */
	      
	      /*
	       * and add R_TMP1 into dest
	       */
	      
	      if (offset)
		{
		  integer_immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );
		  
		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
				examines2( dest, R_TMP1 ),
				alters2( dest, RR_ST ) );
		}
	      else
		{
		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
				examines2( dest, R_TMP1 ),
				alters2( dest, RR_ST ) );
		}
	    }
	  else
	    {
	      peep_xref( X_DataSymbLo, symbol );

	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, 0,
			    examines1( dest ),
			    alters2( dest, RR_ST ) );
	  
	      if (offset)
		{
		  integer_immediate_op( OP_ADDI, OP_ADDI3, dest, dest, offset, TRUE );
		}
	    }
	}
      else
	{
	  load_static_data_ptr( dest, FALSE, symbol );

	  /*
	   * do not bother to ask the linker for the offset of symbol,
	   * as we already know it
	   */
		  
	  offset += extoffset_( x );
	  
	  if (offset)
	    {
	      integer_immediate_op( OP_ADDI, OP_ADDI3, dest, dest, offset, TRUE );
	    }
	}      
    }
  else if (d != -1 && !in_stubs)
    {
      /*
       * An already defined internal code symbol
       *
       * This is called when we want to take the address of an already
       * defined function, eg:
       *
       *   int munge( int (*f)() ) { return (*f)(); }
       *
       *   int func1( void ) { return 3; }
       *
       *   int main( void ) { return munge( func1 ); }
       *
       */

#ifdef DEBUG
      /* be paraniod */
      
      if (!is_function( symbol ))
	syserr( syserr_non_function );
#endif
      
      if ((dest != R_LR)                        &&	 /* register being corrupted is not linker register */
	  (((saved_ivars & regbit( R_LR )) == 0) ||	 /* link register has not been saved on the stack */
	   usedmaskvec.map[ 0 ] & regbit( R_LR )) )	 /* link register being used as temporary */
	   
	{
	  /* save link register */

	  if (dest == R_TMP1)
	    {
	      move_register( R_LR, R_TMP2, FALSE, TRUE );
	    }
	  else
	    {
	      move_register( R_LR, R_TMP1, FALSE, TRUE );
	    }
	}

      flush_peepholer( DBG( "about to emit a LAJ" ) );
      
      /* put PC of next instruction into R_LR */

      outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

      flush_peepholer( DBG( "getting address of LAJ (2)" ) );

      d = codep + codebase - d + (3 * sizeof_int);

      /* protect the next three instructions from future BRs and LAJs */
      
      peep_protect_pc = 3;
      
      /*
       * XXX - the following NOP is because of a bug in the C40
       * silicon, whereby R_LR is occaisionally not set by the
       * LAJ until the second instruction after the LAJ
       */

      nop( FALSE );

      /*
       * XXX - beware special knowledge of the position of this NOP is
       * is used in asm.c: decode_diadic_address()
       */

      /* prevent NOP from being peepholed */
      
      flush_peepholer( DBG( "LAJ bug" ) );
      
      /* retreive PC from R_LR */

      move_register( R_LR, dest, FALSE, TRUE );
      
      /* compute compound offset */

#ifdef DEBUG
      if (d & 3)
	syserr( syserr_non_aligned_fn );
#endif
      /* adjust symbol offset to be relative to next instruction */

      d += offset;

#ifdef DEBUG
      if (d & 3)
	syserr( syserr_non_aligned_fn );
#endif
      
      /* subtract offset (in words) */

      d /= sizeof_int;
      
      if (d)
	{
	  /* indicate that the next instruction will reference 'symbol' */
  
	  peep_symref( symbol );
	  
	  /*
	   * XXX - beware special knowledge of the position of this instruction is
	   * is used in asm.c: decode_diadic_address()
	   */

	  integer_immediate_op( OP_SUBI, OP_SUBI3, dest, dest, d, TRUE );
	}
      else
	{
	  nop( FALSE );
	}

      if ((dest != R_LR) &&
	  (((saved_ivars & regbit( R_LR )) == 0) ||
	   usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */	   
	{
	  /* restore saved link register */
      
	  if (dest == R_TMP1)
	    {
	      move_register( R_TMP2, R_LR, FALSE, TRUE );
	    }
	  else
	    {
	      move_register( R_TMP1, R_LR, FALSE, TRUE );
	    }
	}

      /* finished */
    }
  else if (static_definition( symbol ))
    {
      /*
       * A not yet defined internal code symbol
       *
       * word address = PC of current position in code +
       *               offset of symbol from current position in code
       *
       * This is caused by code such as...
       * 
       *  static int func( void );
       *
       *  int
       *  main( void )
       *  {
       *    int (* fn )();
       *
       *
       *    fn = func;
       *
       *    return (*fn)();
       *  }
       *
       *  static int func( void ) { return 1; }
       *
       */

      if (offset != 0)
	syserr( syserr_offset_from_fn );

      if ((dest != R_LR) &&
	  (((saved_ivars & regbit( R_LR )) == 0) ||
	   usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */
	{
	  /* save link register */

	  move_register( R_LR, R_TMP1, FALSE, TRUE );
	}
      
      /* put PC of next instruction into R_LR */

      outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

      peep_protect_pc = 3;
      
      /*
       * The value loaded here should be
       * 'top 16 bits of offset of symbol from (this instruction + 3)'
       * The +3 is taken of by the patch generated in heliobj.c
       */
      
      peep_xref( X_DataAddr1, symbol ); 

      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP2, 0,
		    examines0(),
		    alters2( R_TMP2, RR_ST ) );

      peep_xref( X_DataAddr, symbol ); 
      
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP2, -4 + 2,
		    examines1( R_TMP2 ),
		    alters1( R_TMP2 ) );	/* XXX - note lie about not affecting RR_ST */

      flush_peepholer( DBG( "symbol address" ) );
      
      /*
       * now add the two offsets place in destination register
       *
       * (This instruction does not need to be patched)
       */
      
      out_triadic_op( OP_ADDI3, dest, R_LR, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( R_LR, R_TMP2 ),
		     alters2( dest, RR_ST ) );
      
      if ((dest != R_LR) &&
	  (((saved_ivars & regbit( R_LR )) == 0) ||
	   usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */
	{
	  /* restore saved link register */
      
	  move_register( R_TMP1, R_LR, FALSE, TRUE );
	}
    }
  else if (/* is_function( symbol ) && */ !new_stubs && in_stubs)
    {
      RealRegister	real_dest = dest;
      bool		must_copy = FALSE;
      
      
      /*
       * Calling stub
       *
       *    address = contents of
       *              module table[ symbol's module number ].function table +
       *              offset of symbol in function table
       *
       * Note that we have special case code here, (instead of using the more
       * general function address loading code below), because we want to reduce
       * the function call overhead as much as possible, and that means having
       * efficient calling stubs.
       */

      if (offset != 0)
	{
	  syserr( syserr_offset_from_fn );
	}
      
      if (dest != RR_AR5)
	{
	  real_dest = dest;
	  dest      = RR_AR5;
	  must_copy = TRUE;
	}
      else
	{
	  must_copy = FALSE;
	}

      /*
       * XXX
       *
       * In an ideal world we could be sure of having less than 256
       * modules in a program, and less than 256 exported functions
       * per module.  If this were true then out calling stubs
       * could be :-
       *
       *   LDI   *+R_MT( modnum ), R_ATMP	- get the function table pointer into temp address register
       *   LDI   *+R_MT( offset ), R_ATMP	- get the function pointer into temp reg
       *   Bu    R_ATMP				- jump to function
       *
       * Unhappily, we cannot guarantee these things, and so our
       * calling stubs may have to be :-
       *
       *   LDI   R_MT,    R_ATMP		- get module table pointer into temporary address register
       *   ADDI  modnum,  R_ATMP		- add in the module number
       *   LDI   *R_ATMP, R_ATMP		- get the function table pointer into temp reg
       *   ADDI  offset,  R_ATMP		- add in the word offset of the function into the table
       *   LDI   *R_ATMP, R_ATMP		- get the function pointer
       *   Bu    R_ATMP				- and jump
       *
       * NB/ If we know that the module table is at a fixed offset from IR0 then we could do :-
       *
       *   LDI   modnum + offset_of_MT, R_ATMP	- get offset of module table + offset of module table pointer
       *   LDI   *+R_ATMP(IR0),         R_ATMP	- get the function table pointer into temp reg
       *   ADDI  offset,                R_ATMP	- add in the word offset of the function into the table
       *   LDI   *R_ATMP,               R_ATMP	- get the function pointer
       *   Bu    R_ATMP				- and jump
       *
       * The bad news is that we can only make the decision about
       * the size of the offsets we are going to have to add in
       * at link time, not a compile time.  Hence we are going to
       * assume the pessimistic case, but we will allow the linker
       * to change the instructions around, (replacing redundant
       * instructions with NOPs ?)
       */
      
      /*
       * get the module table pointer into 'dest'
       *
       * this instruction could be patched if the module
       * number of 'symbol' is less than 256
       */
      
      peep_xref( X_DataModule1, symbol );
      
      move_register( R_MT, dest, FALSE, TRUE );
      
      /*
       * add in the offset of the module containing 'symbol'
       *
       * XXX - we asssume that there will never be more than 32767 modules
       */
      
      peep_xref( X_DataModule2, symbol );
      
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, split_module_table ? 1 : 0,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
      
      /*
       * get the address of the module's function table
       */
      
      peep_xref( X_DataModule3, symbol );
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ),
		    examines1( dest ),
		    alters2( dest, RR_ST ) );

      /*
       * add in the offset of 'symbol' into the function table
       *
       * XXX - we are assuming that there will never be more than 65535 exported functions per module
       */
      
      peep_xref( X_DataModule4, symbol );
      
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, 0,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );

      /*
       * get the address of the function
       */
      
      peep_xref( X_DataModule5, symbol );
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ),
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
      
      if (must_copy)
	{
	  move_register( dest, real_dest, FALSE, TRUE );
	}
    }
  else
    {
      bool		is_func = is_function( symbol );      
      RealRegister	tmp;


      /*
       * All we have left are external data and function symbols
       *
       *    address = module table[ symbol's module number ].data slots +
       *              offset of symbol in data slots
       * or
       *    address = module table[ symbol's module number ].function table +
       *              offset of symbol in function table       
       */

      /*
       * In an ideal world we could do :-
       *
       *   LDI  *+R_MT( modnum ), dest
       *   ADDI byte_offset,      dest
       *
       * but in the worst case we have :-
       *
       *   LDI  R_MT,   dest
       *   ADDI modnum, dest
       *   LDI  *dest,  dest
       *   LDHI byte_offset >> 16, R_TMP1
       *   OR   byte_offset,       R_TMP1
       *   ADDI R_TMP1, dest
       *
       * NB/ If we know that the module table is at a fixed offset from IR0 then we could do :-
       *
       *   LDI  modnum + offset_of_MT, dest
       *   LDI  *+dest(IR0),           dest
       *   LDHI byte_offset >> 16,     R_TMP1
       *   OR   byte_offset,           R_TMP1
       *   ADDI R_TMP1,                dest
       *
       * Unfortunately since this code can occur in the middle of a function body,
       * we gain nothing by optimising down to the best case.
       */

      if (suppress_module && is_func)
	{
	  /*
	   * XXX - urg!
	   *
	   * If we are compiling a resident library and we have a reference
	   * the address of a function, then we must treat this as a reference
	   * to a static function, EVEN IF the function's prototype has
	   * suggested that it is automatic or extern.  This is because all
	   * functions in a resident library are by default static, (rather than
	   * auto as for normal C programs), but the front end does not know
	   * this.
	   *
	   * As a consequence of this, if a function really is external to the
	   * library then this code will actually load the address of the function
	   * stub, rather than the address in the functions module table entry,
	   * and hence comparisions between function pointers will not work.
	   *
	   * Anyway, hence the following code.
	   */

	  if (feature & FEATURE_FUSSY)
	    cc_warn( "Comparing the addresses of an external functions may not work with -Zl or -Zr" );

	  if ((dest != R_LR) &&
	      (((saved_ivars & regbit( R_LR )) == 0) ||
	       usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */	      
	    {
	      /* save link register */

	      move_register( R_LR, R_TMP1, FALSE, TRUE );
	    }
      
	  /* put PC of next instruction into R_LR */

	  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

	  peep_protect_pc = 3;
	  
	  /*
	   * The value loaded here should be
	   * 'top 16 bits of offset of symbol from (this instruction + 3)'
	   * The +3 is taken of by the patch generated in heliobj.c
	   */
      
	  peep_xref( X_DataAddr1, symbol );
	  
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP2, 0,
			examines0(),
			alters2( RR_ST, R_TMP2 ) );

	  peep_xref( X_DataAddr, symbol );
	  
	  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP2, -4 + 2,
			examines1( R_TMP2 ),
			alters1( R_TMP2 ) );	/* XXX - note lie about not affecting RR_ST */

	  flush_peepholer( DBG( "symbol address 2" ) );
	  
	  /*
	   * now add the two offsets place in destination register
	   *
	   * (This instruction does not need to be patched)
	   */
      
	  out_triadic_op( OP_ADDI3, dest, R_LR, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( R_LR, R_TMP2 ),
			 alters2( dest, RR_ST ) );
      
	  if ((dest != R_LR) &&
	      (((saved_ivars & regbit( R_LR )) == 0) ||
	       usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */
	    {
	      /* restore saved link register */
	  
	      move_register( R_TMP1, R_LR, FALSE, TRUE );
	    }
	}
      else
	{
	  /* we need an address register to load the pointer */
      
	  if (is_address_register( hardware_register( dest ) ))
	    {
	      tmp = dest;
	    }
	  else
	    {
	      tmp = peep_get_free_addr_reg( GAP );
	    }

	  if (is_func && new_stubs)
	    {
	      request_new_stub( symbol );

	      /* do nothing here, do something in next if statement ... */
	      ;	      
	    }	  
	  else if (!few_modules)
	    {
	      /*
	       * get address of module table into 'tmp'
	       */

	      move_register( R_MT, tmp, FALSE, TRUE );
	  
	      /*
	       * add in the offset of the module containing 'name'
	       *
	       * XXX - we asssume that there will never be more than 32767 modules
	       */
	  
	      peep_xref( X_DataModule, symbol );
	      
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
			    examines1( tmp ),
			    alters2( tmp, RR_ST ) );
	  
	      /*
	       * get the address of the module's function table or data slots
	       */
	  
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, is_func ? tmp : dest,
			    build_indirect( INDIRECT_REL, tmp, 0 ),
			    examines1( tmp ),
			    alters2( is_func ? tmp : dest, RR_ST ) );
	    }
	  else
	    {
	      peep_xref( X_DataModule, symbol );
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, is_func ? tmp : dest,
			    build_indirect( INDIRECT_PRE_ADD, R_MT, 0 ),
			    examines1( R_MT ),
			    alters2( is_func ? tmp : dest, RR_ST ) );
	    }
	  
	  if (is_func)
	    {
	      if (offset != 0)
		syserr( syserr_offset_from_fn );
	      
	      /*
	       * add in the offset of the function
	       *
	       * XXX - we are assuming that there will never be more than 32767
	       * functions in one module
	       *
	       * This code is used by :-
	       *
	       * int use( int (* f )() ) { return (*f)(); }
	       * int func( void );
	       * int main( void ) { return use( func ); }
	       * int func( void ) { return 1; }
	       */

	      if (new_stubs)
		{
		  if ((dest != R_LR) &&
		      (((saved_ivars & regbit( R_LR )) == 0) ||
		       usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */
		    {
		      /* save link register */

		      /* NB/ do NOT use R_TMP1 as this is used by the address generating stub */
		      
		      move_register( R_LR, R_TMP2, FALSE, TRUE );
		    }

		  /* call function address stub ! */

		  request_addr_stub( symbol );
		  
		  peep_xref( X_FuncAddr, symbol );
		  
		  peep_corrupt_addr_reg( R_ATMP );
		  
		  outdelsymref( OP_LAJ << 24 | (-3 & 0xffffff), symbol, examines0(), alters2( R_LR, RR_PC ) );

		  peep_protect_pc = 3;

		  /* result is placed in AR5 (alias R_ATMP) */
		  
		  move_register( R_ATMP, dest, FALSE, TRUE );
		  
		  if ((dest != R_LR) &&
		      (((saved_ivars & regbit( R_LR )) == 0) ||	
		       usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */
		    {
		      /* restore saved link register */
		  
		      move_register( R_TMP2, R_LR, FALSE, TRUE );
		    }
		}
	      else /* old stubs */
		{
		  peep_xref( X_DataSymb, symbol );
	      
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
				examines1( tmp ),
				alters2( tmp, RR_ST ) );
	      
		  /* and fetch the address out of the function table */
	      
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, tmp, 0 ),
				examines1( tmp ),
				alters2( dest, RR_ST ) );
		}
	    }
	  else /* is data */
	    {
	      if (!fits_in_16_bits_signed( offset ))
		{
		  syserr( syserr_offset_too_big, offset );
		}
	      
	      /*
	       * load R_TMP1 with the high part offset of 'name' into the data table
	       */

	      if (much_data)
		{
		  /*
		   * Note that we assume here, (and elsewhere) that there will never be more than
		   * 32767 functions in one module.
		   */

		  peep_xref( X_DataSymbHi, symbol );
	      
		  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
				examines0(),
				alters1( R_TMP1 ) );
	      
		  /*
		   * load R_TMP1 with the low part offset of 'name' into the data slots or function table
		   */
	      
		  peep_xref( X_DataSymbLo, symbol );
	      
		  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
				examines1( R_TMP1 ),
				alters1( R_TMP1 ) );	/* XXX - hide alteration of ST */

		  /*
		   * and add R_TMP1 into dest
		   */
	      
		  if (offset)
		    {
		      integer_immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );
		      
		      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
				    examines2( dest, R_TMP1 ),
				    alters2( dest, RR_ST ) );
		    }
		  else
		    {		  
		      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
				    examines2( dest, R_TMP1 ),
				    alters2( dest, RR_ST ) );
		    }		  
		}
	      else /* not much_data */
		{
		  peep_xref( X_DataSymbLo, symbol );

		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, 0,
				examines1( dest ),
				alters2( dest, RR_ST ) );
				
		  if (offset != 0)
		    {
		      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, offset,
				    examines1( dest ),
				    alters2( dest, RR_ST ) );
		    }
		}
	    }
	}
    }

  peep_forget_about( dest );
  
  return;
  
} /* load_address_constant */


static void
load_string_constant( RealRegister dest )
{
  /*
   * address = start of literal pool + current offset into literal pool
   *         =     `litlab'          +         `litpoolp'
   */


  if ((dest != R_LR) &&
      (((saved_ivars & regbit( R_LR )) == 0) ||
       usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */
    {
      /* save link register */

      move_register( R_LR, R_TMP1, FALSE, TRUE );
    }
      
  /* put PC of next instruction into R_LR */

  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

  peep_protect_pc = 3;
  
  /*
   * add in offset of start of literal pool
   *
   * NB/ beware of assumption that literal pool is within 16
   * (signed) bits of this instruction - this may not be true
   */
  
  peep_fref( litlab, LABREF_LIT16 ); 

  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, dest, 0,
		examines0(),
		alters2( dest, RR_ST ) );

  /* add in offset into literal pool */
  
  /*
   * XXX - this is done as a seperate instruction because we cannot
   * reliably use R_LR immediately after a LAJ (due to a silicon bug)
   * and so I have reordered the ops
   */

  integer_immediate_op( OP_ADDI, OP_ADDI3, dest, dest, litpoolp -4 + 1, TRUE );

  /* add in value in link register */
  
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_LR,
		examines1( R_LR ),
		alters2( dest, RR_ST ) );

  if ((dest != R_LR) &&
      (((saved_ivars & regbit( R_LR )) == 0) ||
       usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */
    {
      /* restore saved link register */
      
      move_register( R_TMP1, R_LR, FALSE, TRUE );
    }

  /* convert offset to byte offset */

  convert_to_byte_offset( dest );

  peep_forget_about( dest );
  
  return;
      
} /* load_string_constant */
  

/*
 * output an instruction using register addressing
 */

static void
register_op(
	    int32		diadic_op,
	    int32		triadic_op,
	    RealRegister	dest,
	    RealRegister	source1,
	    RealRegister	source2,
	    bool		can_commute )
{
  if (source1 == dest)
    {
      out_diadic_op( diadic_op, ADDR_MODE_REGISTER, dest, source2,
		     examines2( dest, source2 ),
		     alters2( dest, RR_ST ) );
    }
  else if (can_commute && source2 == dest)
    {
      out_diadic_op( diadic_op, ADDR_MODE_REGISTER, dest, source1,
		     examines2( dest, source1 ),
		     alters2( dest, RR_ST ) );
    }
  else
    {
      out_triadic_op( triadic_op, dest, source1, source2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( source1, source2 ),
		     alters2( dest, RR_ST ) );
    }

  peep_forget_about( dest );
  
  return;
  
} /* register_op */
  

/*
 * this code is called just before we start to initialise
 * the data and function tables of the current module
 */

void
prepare_for_initialisation(
			   int			data_init,
			   LabelNumber *	data_label )
{
  death = 0;
  
  if (var_cc_private_flags > 2)
    {
      LabelNumber *	l;

      
      /* insert a JTAGHalt() to allow for debugging init code */
      
      flush_peepholer( DBG( "why" ) );
      
      l = nextlabel();
      
      load_integer( R_TMP1, 0x2f, FALSE );
      
      flush_peepholer( DBG( "hmm" ) );
      
      setlabel( l );
      
      integer_immediate_op( OP_SUBI, OP_SUBI3, R_TMP1, R_TMP1, 1, TRUE );
      
      conditional_branch_to( Q_NE, l );
      
      outinstr( 0x66FFFFFF, 0, 0 );
      
      flush_peepholer( DBG( "why not" ) );
    }
  
  if (suppress_module)
    {
      if (!data_init)
	{
	  outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_LR ),
		     examines1( R_LR ),
		     alters1( RR_PC ) );
	}
      else
	{
	  /* if we are only initialising data then skip all stages except stage 0 */
      
	  out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, R_A1, 0,
			examines1( R_A1 ),
			alters1( RR_ST ) );

	  outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_NE ) << 16 | hardware_register( R_LR ),
		     examines2( R_LR, RR_ST ),
		     alters1( RR_PC ) );
	}
    }
  else if (!data_init)
    {
      if (new_stubs && !usrdbg( DBG_ANY ))
	{
	  /* no data or functions to init */
	  
	  outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_LR ),
		     examines1( R_LR ),
		     alters1( RR_PC ) );
	}
      else
	{
	  /* if we are only initialising functions then skip all stages except stage 2 */
      
	  out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, R_A1, 2,
			examines1( R_A1 ),
			alters1( RR_ST ) );

	  outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_NE ) << 16 | hardware_register( R_LR ),
		     examines2( R_LR, RR_ST ),
		     alters1( RR_PC ) );
	}      
    }
  else
    {
      if (new_stubs && !usrdbg( DBG_ANY ))
	{
	  /* if we are only initialising data then skip all stages except stage 0 */
      
	  out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, R_A1, 0,
			examines1( R_A1 ),
			alters1( RR_ST ) );

	  outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_NE ) << 16 | hardware_register( R_LR ),
		     examines2( R_LR, RR_ST ),
		     alters1( RR_PC ) );
	}
      else
	{
	  /* we are initialisaing data and functions */
      
	  out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, R_A1, 1,
			examines1( R_A1 ),
			alters1( RR_ST ) );

	  /* stage 0 initialises data */
      
	  conditional_branch_to( Q_LT, data_label );

	  /* and stage 1 is ignored */
      
	  outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_EQ ) << 16 | hardware_register( R_LR ),
		     examines2( R_LR, RR_ST ),
		     alters1( RR_PC ) );
	}      
    }

  return;
  
} /* prepare_for_initialisation */


/*
 * this code is called just before we start to initialise the
 * function table of the module containing the
 * code we have just compiled.  This function is used to get
 * hold to the PC once, rather than every time a symbol is
 * referenced
 */

void
prepare_for_function_exporting( void )
{
  /*
   * this should not be necessary, but lets be paranoid ...
   */
  
  flush_peepholer( DBG( "start of function exports" ) );

  /* save the return address */

  move_register( R_LR, R_DS, FALSE, TRUE );
  
  /*
   * make sure that the previous instruction is emitted
   */
  
  flush_peepholer( DBG( "call used in preparing for exports" ) );
   
  /*
   * remember the address of the next instruction
   */
  
  codep_of_call = codep;
  
  /* put PC of next instruction into R_LR */

  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

  peep_protect_pc = 3;
  
  /*
   * XXX - the following NOP is because of a bug in the C40
   * silicon, whereby R_LR is occaisionally not set by the
   * LAJ until the second instruction after the LAJ
   */

  nop( FALSE );

  /* prevent this NOP from being peepholed */
  
  flush_peepholer( DBG( "LAJ bug 1" ) );
  
  /*
   * Use R_ADDR1 as a temporary address register.
   * We can do this safely as we know that we are
   * being called from outside of any of the normal
   * code generation sequence.
   */
  
  /* retreive PC from R_LR */

  move_register( R_LR, R_ADDR1, FALSE, TRUE );

  /*
   * our temporary register now contains the word
   * address of the LAJ instruction plus 4.
   */

  /* restore the return address */

  move_register( R_DS, R_LR, FALSE, TRUE );
  
  /*
   * There is no need to pad the LAJ instruction
   * as the load_static_data_pointer() function
   * is about to be called.  (see dumpdata() in heliobj.c)
   */
  
  return;
  
} /* prepare_for_function_exporting */



/*
 * load word address of symbol 'name' and
 * store it in the word pointed to by 'dest', and
 * increment 'dest' to point to the next word.
 *
 * This function is called from export_routines() in
 * c40/heliobj.c, where it used to be implemented by
 * emitting J op codes, but this proved to be too
 * inefficient.
 *
 * Note dest is a word pointer
 *
 * Also note that 'dest' is very probably 'R_ATMP'.
 */
 
void
export_function(
		Symstr *	name,
		RealRegister	dest )
{
  int32		offset;

  
  /*
   * calculate the word offset of the symbol
   * we have been given from the 'CALL'
   * in prepare_for_exporting()
   */

  /*
   * The offsets look like this:
   *
   *                                                     <-codep_of_call-->
   *              <---obj_symref()-->
   *              <---------------codebase--------------->
   *  <---------------------------R_ADDR1 -------------------------------->
   *
   *   ----------------------------------------------------------------------- - -
   *  |
   *  |
   *   ----------------------------------------------------------------------- - - 
   *  ^           ^                 ^                    ^               ^
   *  |           |                 |                    |               |
   *  |           |                 |                    |               |
   *  0    start of code    start of 'name'     start of init code   LAJ +0
   *
   *
   */

  /*
   * the + 4 is because the LAJ instruction puts PC + 4 into R_ADRR1
   */
  
  offset = ((codep_of_call + codebase) - obj_symref( name, xr_code, 0 )) / sizeof_int - 1 + 4;

  /*
   * the linker is going to insert an extra word between
   * the end of the code and the start of the initialisation code
   * as a chain of init sequences, so ...
   */

  offset += 1;
  
  /*
   * indicate that the next instruction will reference 'name'
   */
  
  peep_symref( name );
      
  /*
   * subtract the offset we have just calculated to the offset
   * we have in R_ADDR1 (see prepare_for_exporting())
   * and place the result in R_TMP1
   *
   * Note that if we are producing assembly output, we do not
   * really know what the offset is, and so we cannot use the
   * optimised version.
   */

  if (fits_in_8_bits_signed( offset ) && asmstream == NULL)
    {      
      out_triadic_op( OP_SUBI3, R_TMP1, R_ADDR1, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( R_ADDR1 ),
		     alters2( R_TMP1, RR_ST ) );
    }
  else
    {
      if (asmstream != NULL && !fits_in_16_bits_signed( offset ))
	{
	  /* catch the case where two instructions are needed */
	  
	  syserr( syserr_need_patch );
	}
      
      load_integer( R_TMP1, offset, FALSE );

      out_triadic_op( OP_SUBI3, R_TMP1, R_ADDR1, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( R_TMP1, R_ADDR1 ),
		     alters2( R_TMP1, RR_ST ) );
    }

  /*
   * and store the result into 'dest'
   * (incrementing 'dest' afterwards)
   */
  
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
		examines2( dest, R_TMP1 ),
		alters1( dest ) );
  return;
  
} /* export_function */


/*
 * this code is called just before we start to initialise the
 * data slots of the module containing the
 * code we have just compiled. 
 */

void
prepare_for_data_exporting( RealRegister reg )
{
  if (suppress_module == 2)
    {
      RealRegister	tmp;

      
      /*
       * Resident libraries only have one static data area, shared amoungst
       * many source files.  To cope with this each file is allocated part
       * of the data area for its own use, (determined by the amount of
       * data that file requires).  Hence when we are loading the static
       * data pointer we must add in the file's offset into the data area.
       */

      if (reg == R_TMP1)
	tmp = R_TMP2;
      else
	tmp = R_TMP1;

      if (much_data)
	{
	  peep_xref( X_DataSymbHi, bindsym_( datasegment ) );
	  
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, tmp, 0,
			examines1( tmp ),
			alters2( tmp, RR_ST ) );
      
	  peep_xref( X_DataSymbLo, bindsym_( datasegment ) );
	  
	  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, tmp, 0,
			examines1( tmp ),
			alters1( RR_ST ) );	/* XXX - note lie about not affecting RR_ST */
	}
      else
	{
	  peep_xref( X_DataSymbLo, bindsym_( datasegment ) );
	  
	  conditional_load( Q_AL, ADDR_MODE_IMMEDIATE, tmp, 0,
			   examines0(),
			   alters1( tmp ) );
	}      

      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, reg, tmp,
		    examines2( reg, tmp ),
		    alters2( reg, RR_ST ) );
    }
  
  /*
   * XXX
   *
   * 'reg' currently contains the byte offset from IR0
   * of the start of the data table.  Convert this to
   * a word pointer to speed up stores of data values
   */

  convert_to_word_address( reg, reg );

  /* save the return address so that we can use LAJ's with impunity */
  
  move_register( R_LR, RR_R6, FALSE, TRUE );

  saved_link_reg = RR_R6;

  /* note that we have not done a LAJ yet */
  
  codep_of_call = 0;
  
  return;
  
} /* prepare_for_data_exporting */


/*
 * initialise the pointer to the data that is to be copied into the program's data area
 */

#define	SRC_REG		R_ADDR1
#define DST_REG		R_ATMP
#define VAL_REG		RR_R1

void
prepare_for_block_copying( LabelNumber * start_of_data )
{
  flush_peepholer( DBG( "do not swap this LAJ backwards" ) );
  
  /* put PC into R_LR */

  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

  /* ensure that codep is up to date */
	  
  flush_peepholer( DBG( "getting hold of PC" ) );

  codep_of_call = codep;

  peep_protect_pc = 3;

  peep_fref( start_of_data, LABREF_LIT16 );

  /* load the offset from the return address of the LAJ to the start of the data */
  
  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, SRC_REG, -3,
		examines0(),
		alters2( SRC_REG, RR_ST ) );

  /* add in the program counter */
  
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, SRC_REG, R_LR,
		examines2( SRC_REG, R_LR ),
		alters2( SRC_REG, RR_ST ) );

  /* ensure that three instructions follow the LAJ */
  
  nop( TRUE );
  
  return;  
  
} /* prepare_for_block_copying */


void
block_copy_data( int32 num_words_to_copy )
{
  if (num_words_to_copy < 1)
    {
      syserr( syserr_no_data_to_init, num_words_to_copy );
    }
  else if (num_words_to_copy < 5)
    {
      /* copy by hand - it is quicker than a loop */
      
      /* load first word */
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, VAL_REG, build_indirect( INDIRECT_POST_INCR, SRC_REG, 1 ),
		    examines1( SRC_REG ),
		    alters3( VAL_REG, RR_ST, SRC_REG ) );

      while (--num_words_to_copy)
	{
	  /*
	   * instruction repeated is:
	   *
	   *  LDI    *R_ADDR1++(1), R1
	   *  || STI  R1,          *R_ATMP++(1)
	   *
	   */
      
	  outinstr( B_1101 << 28 | B_1010 << 24 |
		   hardware_register( VAL_REG ) << 22 | hardware_register( VAL_REG ) << 16 |
		   build_parallel_indirect( INDIRECT_POST_INCR, DST_REG ) << 8 |
		   build_parallel_indirect( INDIRECT_POST_INCR, SRC_REG ),
		   examines3( SRC_REG, VAL_REG, DST_REG ),
		   alters3(   SRC_REG, VAL_REG, DST_REG ) );
	}
      
      /* save last word */
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, VAL_REG, build_indirect( INDIRECT_POST_INCR, DST_REG, 1 ),
		    examines2( VAL_REG, DST_REG ),
		    alters1( DST_REG ) );
    }
  else
    {
      LabelNumber *	l;  
  
     
      /* load repeat count */
      
      load_integer( RR_RC, num_words_to_copy - 2, FALSE );
      
      /* try to move the instruction to a more advantagous location */
      
      peep_shift_back( 2 );
      
      /* load first word */
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, VAL_REG, build_indirect( INDIRECT_POST_INCR, SRC_REG, 1 ),
		    examines1( SRC_REG ),
		    alters3( VAL_REG, RR_ST, SRC_REG ) );
      
      /* start repeat block */
      
      l = nextlabel();
      
      outdellabref( (OP_RPTBD << 24) | (-3 & 0x00FFFFFFU),
		   l,
		   LABREF_OFF24,
		   examines1( RR_PC ),
		   alters4( RR_RC, RR_RS, RR_RE, RR_PC ) );
      
      setlabel( l );
      
      /*
       * instruction repeated is:
       *
       *  LDI    *R_ADDR1++(1), R1
       *  || STI  R1,          *R_ATMP++(1)
       *
       */
      
      outinstr( B_1101 << 28 | B_1010 << 24 |
	       hardware_register( VAL_REG ) << 22 | hardware_register( VAL_REG ) << 16 |
	       build_parallel_indirect( INDIRECT_POST_INCR, DST_REG ) << 8 |
	       build_parallel_indirect( INDIRECT_POST_INCR, SRC_REG ),
	       examines3( SRC_REG, VAL_REG, DST_REG ),
	       alters3(   SRC_REG, VAL_REG, DST_REG ) );
      
      /* prevent the repeated instruction from being peepholed */
      
      flush_peepholer( DBG( "block data init" ) );
      
      /* save last word */
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, VAL_REG, build_indirect( INDIRECT_POST_INCR, DST_REG, 1 ),
		    examines2( VAL_REG, DST_REG ),
		    alters1( DST_REG ) );
    }
  
  return;
  
} /* block_copy_data */


void
store_data_value( unsigned32 value )
{
  if (value == 0)
    syserr( syserr_store_zero );

#ifdef STIK_NOW_WORKS_ON_HARDWARE
  if (fits_in_5_bits_signed( value ))
    {
      /* addressing mode is actually ADDR_MODE_INDIRECT */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, value, build_indirect( INDIRECT_POST_INCR, DST_REG, 1 ),
		    examines1( DST_REG ),
		    alters1( DST_REG ) );

      return;
    }
#endif

  load_integer( VAL_REG, value, FALSE );

  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, VAL_REG, build_indirect( INDIRECT_POST_INCR, DST_REG, 1 ),
		examines2( VAL_REG, DST_REG ),
		alters1( DST_REG ) );

  return;
  
} /* store_data_value */
  

/*
 * load byte offset from IR0 of symbol 'name' and
 * store it in the word pointed to by 'R_ATMP', and
 * increment 'R_ATMP' by one word.
 *
 * This function is called from dump_data() in
 * c40/heliobj.c, where it used to be implemented by
 * emitting J op codes, but this proved to be too
 * inefficient.
 *
 * Note R_ATMP is a word pointer.
 */
 
void
export_data_symbol(
		   Symstr *	name,		/* symbol whoes address is to be stored */
		   int32	offset,		/* offset (in bytes) from symbol to store */
		   unsigned32	current_offset )/* the offset (in words) of R_ATMP from start of data table */
{
  if (streq( symname_( name ), "__dataseg" ))
    {
      /*
       * Ah ha, we are trying to place __dataseg + offset
       * into static_data_ptr + current_offset,
       * BUT
       * we know that DST_REG holds IR0 + [static_data_ptr / sizeof_int] + current_offset (in words)
       * and that static_data_ptr == __dataseg !
       */

      if (offset & (sizeof_int - 1))
	{
	  /* offset is not an integer multiple, *sigh* */

	  offset -= current_offset * sizeof_int;
	  
	  /* get DST_REG - IR0 into temporary register */

	  out_triadic_op( OP_SUBI3, VAL_REG, DST_REG, R_BASE, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( DST_REG, R_BASE ),
			 alters2( VAL_REG, RR_ST ) );

	  /* convert to a byte offset */

	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, VAL_REG, 2,
			examines1( VAL_REG ),
			alters2( VAL_REG, RR_ST ) );

	  /* add in offset */

	  integer_immediate_op( OP_ADDI, OP_ADDI3, VAL_REG, VAL_REG, offset, TRUE );

	  /* result is now in VAL_REG, ready to store */
	}
      else
	{
	  offset /= sizeof_int;

	  /*
	   * adjust offset
	   */
      
	  offset -= current_offset;

	  /* get DST_REG - IR0 into temporary register */

	  out_triadic_op( OP_SUBI3, VAL_REG, DST_REG, R_BASE, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( DST_REG, R_BASE ),
			 alters2( VAL_REG, RR_ST ) );

	  /* add in offset */

	  integer_immediate_op( OP_ADDI, OP_ADDI3, VAL_REG, VAL_REG, offset, TRUE );

	  /* convert to a byte offset */

	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, VAL_REG, 2,
			examines1( VAL_REG ),
			alters2( VAL_REG, RR_ST ) );

	  /* result is now in VAL_REG, ready to store */
	}
    }
  else if (is_function( name ))
    {
      if (offset != 0)
	syserr( syserr_offset_from_fn );

      offset = obj_symref( name, xr_code, 0 );

      if (offset != -1)
	{
	  /*
	   * This is can happen with the following code:
	   *
	   *   int func( void ) { return 3; }
	   *
	   *   int (* func_ptr)() = func;
	   *
	   */

	  if (codep_of_call == 0)
	    {
	      flush_peepholer( DBG( "save out LAJs" ) );
	      
	      /* put PC into R_LR */

	      outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

	      /* adjust symbol offset to be relative to next instruction */

	      flush_peepholer( DBG( "getting address of LAJ" ) );

	      peep_protect_pc = 3;

	      codep_of_call = codep;
	    }
	  
	  /* calculate required offset */
      
	  offset = codep_of_call + codebase - offset + (3 * sizeof_int);

	  /* compute compound offset */
#ifdef DEBUG	  
	  if (offset & 3)
	    syserr( syserr_non_aligned_fn );
#endif
	  offset /= sizeof_int;
	  
	  /* indicate that the next instruction will reference 'symbol' */
	      
	  peep_symref( name );
	  
	  load_integer( VAL_REG, offset, FALSE );
	  
	  /* subtract offset from PC (in R_LR) */

	  out_diadic_op( OP_SUBRI, ADDR_MODE_REGISTER, VAL_REG, R_LR,
			examines2( VAL_REG, R_LR ),
			alters2( VAL_REG, RR_ST ) );	  
	}
      else
	{
	  /*
	   * function is defined in another module, eg:
	   *
	   *
	   *   extern int func( void );
	   *
	   *   int (* func_ptr)() = func;
	   *
	   */

	  if (new_stubs)
	    {
	      request_new_stub( name );
	      
	      /* dealt with later on */
	    }
	  else if (!few_modules)
	    {
	      /* copy module table pointer */

	      move_register( R_MT, R_DS, FALSE, TRUE );
	  
	      /*
	       * add in the offset of the module containing 'name'
	       *
	       * XXX - we are assuming that there will never be more than 32767 modules
	       */

	      peep_xref( X_DataModule, name );
	  
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_DS, 0,
			    examines1( R_DS ),
			    alters2( R_DS, RR_ST ) );
      
	      /* get the address of that module's function table */
 
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_DS, build_indirect( INDIRECT_REL, R_DS, 0 ),
			    examines1( R_DS ),
			    alters2( R_DS, RR_ST ) );
	    }
	  else
	    {
	      peep_xref( X_DataModule, name );
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_DS,
			    build_indirect( INDIRECT_PRE_ADD, R_DS, 0 ),
			    examines1( R_DS ),
			    alters2( R_DS, RR_ST ) );
	    }

	  if (new_stubs)
	    {
	      /* call function address stub ! */
	      
	      request_addr_stub( name );
	      
	      /*
	       * unfortunately the address returning stub places its result
	       * in R_ATMP, the register we are using to index the current
	       * slot into the module table!
	       */
	      
	      move_register( R_ATMP, R_DS, FALSE, TRUE );
	      
	      peep_corrupt_addr_reg( R_ATMP );

	      peep_xref( X_FuncAddr, name );

	      outdelsymref( OP_LAJ << 24 | (-3 & 0xffffff), name, examines0(), alters2( R_LR, RR_PC ) );

	      move_register( R_ATMP, VAL_REG, FALSE, TRUE );

	      move_register( R_DS, R_ATMP, FALSE, TRUE );
	      
	      codep_of_call = 0;	      
	    }
	  else
	    {
	      /* add in the offset of 'name' into the function table */

	      peep_xref( X_DataSymbLo, name );

	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_DS, 0,
			    examines1( R_DS ),
			    alters2( R_DS, RR_ST ) );
	  
	      /* get the address of the function */

	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, VAL_REG, build_indirect( INDIRECT_REL, R_DS, 0 ),
			    examines1( R_DS ),
			    alters2( VAL_REG, RR_ST ) );
	    }	  
	}
      
      /* result is now in VAL_REG, ready to store */
    }
  else
    {
      ExtRef *		x = symext_( name );


      if (!is_data( x ))
	syserr( syserr_export_non_data, symname_( name ) );

      if (is_defined( x ))
	{
	  /*
	   * This is generated by code such as :
	   *
	   *     int	fred;
	   *     int *	jim = &fred + 5;
	   *
	   * XXX - maybe this could be optimised one day
	   * since we might know the offset of fred from
	   * the start of the data table without using
	   * the DataModule directives as below.
	   */

	  /* get pointer to this module's data slots */

	  load_static_data_ptr( R_DS, FALSE, name );
	}
      else
	{
	  /*
	   * This is generated by code such as :
	   *
	   *     extern int	fred;
	   *     int *		jim = &fred;
	   *
	   */

	  if (!few_modules)
	    {
	      move_register( R_MT, R_DS, FALSE, TRUE );
	  
	      peep_xref( X_DataModule, name );
	  
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_DS, 0,
			    examines1( R_DS ),
			    alters2( R_DS, RR_ST) );

	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_DS, build_indirect( INDIRECT_REL, R_DS, 0 ),
			    examines1( R_DS ),
			    alters2( R_DS, RR_ST ) );
	    }
	  else
	    {
	      peep_xref( X_DataModule, name );
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_DS,
			    build_indirect( INDIRECT_PRE_ADD, R_MT, 0 ),
			    examines2( R_DS, R_MT ),
			    alters2( R_DS, RR_ST ) );
	    }
	}
      
      /*
       * load VAL_REG with the high part offset of 'symbol' into the data table
       */

      if (much_data)
	{
	  peep_xref( X_DataSymbHi, name );
	  
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, VAL_REG, 0,
			examines0(),
			alters1( VAL_REG ) );
	  
	  /*
	   * load VAL_REG with the low part offset of 'symbol' into the data table
	   */
	  
	  peep_xref( X_DataSymbLo, name );
	  
	  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, VAL_REG, 0,
			examines1( VAL_REG ),
			alters1( VAL_REG ) );	/* XXX - note lie about not affecting RR_ST */
	}
      else
	{
	  peep_xref( X_DataSymbLo, name );
	  
	  conditional_load( Q_AL, ADDR_MODE_IMMEDIATE, VAL_REG, 0,
			   examines0(),
			   alters1( VAL_REG ) );
	}
      
      /*
       * and add R_DS to VAL_REG
       */

      if (offset)
	{
	  if (!fits_in_16_bits_signed( offset ))
	    {
	      syserr( syserr_offset_too_large );
	    }
	  else
	    {	  	  
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, VAL_REG, offset,
			    examines1( VAL_REG ),
			    alters2( VAL_REG, RR_ST ) );
	      
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, VAL_REG, R_DS,
			    examines2( R_DS, VAL_REG ),
			    alters2( VAL_REG, RR_ST ) );
	    }
	}
      else
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, VAL_REG, R_DS,
			examines2( R_DS, VAL_REG ),
			alters2( VAL_REG, RR_ST ) );
	}
    }

  /* store result into data area, incrementing pointer as we go */
  
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, VAL_REG, build_indirect( INDIRECT_POST_INCR, DST_REG, 1 ),
		examines2( DST_REG, VAL_REG ),
		alters1( DST_REG ) );
  return;
  
} /* export_data_symbol */


/*
 * we have finished exporting symbols
 */

void
finished_exporting( void )
{
  VRegInt vr1, vr2, vm;


  vr1.r = vr2.r = GAP;
  vm.i  = 0;

  show_instruction( J_ENDPROC, vr1, vr2, vm );

  return;  
}


static void
call(
     Symstr *	name,		/* the function to call */
     bool	tailcall )	/* true if this call is the last action of the current function */
{
  int32		dest;


  /* The initial part of this code is independent of operating   */  
  /* system since if we know how far the routine is there is no  */
  /* problem. Things get a bit trickier from there on in.        */

  if (suppress_module == 1 && streq( symname_( name ), "GetExecRoot" ))
    {
      /*
       * This is a HORRIBLE HACK.
       *
       * The idea is to allow the kernel to get hold of the
       * exec root structure, (whoes address is in TVTP),
       * without using a function call.  I tried using _word(),
       * but the compiler does not really understand about
       * this function returning a result in R0.
       */
      
      outinstr( 0x76190001, examines0(), alters2( R_TMP1, RR_ST ) );	/* LDEP TVTP, R_TMP1 */

      out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, R_TMP1, R_BASE,
		    examines2( R_BASE, R_TMP1 ),
		    alters2( R_TMP1, RR_ST ) );
      
      out_triadic_op( OP_LSH3, R_A1, R_TMP1, 2,
		     ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( R_TMP1 ),
		     alters2( R_A1, RR_ST ) );

      peep_forget_about( RR_R0 );
      
      return;
    }
  
  /* forget about contents of address registers after a function call */

  peep_corrupt_all_addr_regs();

  /* make sure stack is up to date before calling */
  
  flush_pending_pushes();

  if (!new_stubs && in_stubs)
    {
      /* load temporary address register with address of symbol */
      
      load_address_constant( R_ATMP, name, 0 );

      /* and jump to it */
      
      if (tailcall)
	{
	  /*
	   * (the following instruction is a conditional CALL, register relative)
	   */

	  outinstr( OP_BRcr << 24 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_ATMP ),
		   examines1( R_ATMP ),
		   alters1( RR_PC ) );
	}
#ifdef DEBUG
      else
	{
	  syserr( syserr_fn_call_in_stub, symname_( name ) );      
	}
#endif
      return;
    }
  
  /* XXX - by removing this flush I can slide the LAJ back several instructions... */

  /*  flush_peepholer( DBG( "calling another function" ) ); */
  
  dest = obj_symref( name, xr_code, 0 );

  /*
   * determine if we already know the location
   * of the function to be called
   */
  
  if (dest != -1)
    {
      int32 	off;

      
      /* previously defined routine - save the symbol name for disassembly purposes */

      /* calculate offset of dest from current position (in words) */
  
      off  = (dest - codebase) / sizeof_int;

      /* codep ins subtracted in the peepholer */
      
      off -= 3;	/* allow for offset built into LAJ instruction */

      if (fits_in_24_bits_signed( off ))
        {
	  /* the following is an unconditional link and jump, PC relative */

	  if (tailcall)
	    {
	      outdelsymref( OP_BRD << 24 | (off & 0xffffff), name,
			  examines0(), alters1( RR_PC ) );
	    }
	  else
	    {
	      outdelsymref( OP_LAJ << 24 | (off & 0xffffff), name,
			  examines0(),
			  alters2( R_LR, RR_PC ) );
	    }

	  return;
        }
      else
        {
	  syserr( syserr_cannot_call_offset, off );
        }
    }

  /* Static forward or external calls are generated in the same   */
  /*  way. The addition to the stublist will be removed if the    */
  /*  function is subsequently defined.                           */

  peep_xref( X_PCreloc /* X_FUNCstub */, name );

  if (tailcall)
    {
      outdelsymref( (OP_BRD << 24) | (-3 & 0x00ffffffU), name, examines0(), alters1( RR_PC ) );
    }
  else
    {
      outdelsymref( (OP_LAJ << 24) | (-3 & 0x00ffffffU), name, examines0(), alters2( R_LR, RR_PC ) );
    }

  request_stub( name );
  
  return;
  
} /* call */


/*
 * pushes every register whoes bit is set in 'mask'
 */

static void
save_regs(
	  int32		mask,		/* bit mask of registers to save 			*/
	  bool		is_float )	/* TRUE if floating point registers are being saved 	*/
{
  int32	i;	/* XXX beware if number of registers > 32 */


  /*
   * NB/ save in reverse order so that argument registers are
   * placed on the stack in descending order
   */

  if (is_float)
    {
      for (i = 31; i >= 0; i--)
	{
	  if (mask & regbit( i ))
	    {
	      dpush( i );
	    }
	}
    }
  else
    {
      for (i = 31; i >= 0; i--)
	{
	  if (mask & regbit( i ))
	    {
	      ipush( i );
	    }
	}
    }

  return;
    
} /* save_regs */


/*
 * pops every integer register whoes bit is set in 'mask'
 */

static void
restore_regs(
	     int32	mask,		/* bit mask of registers to remove from stack	*/
	     bool	is_float )	/* TRUE if registers are floating point		*/
{
  /* NB/ restore must be done in opposite order to save */


  if (is_float)
    {
      while (mask)
	{
	  RealRegister r1  = firstbit( mask );

      
	  dpop( r1 );

	  mask ^= regbit( r1 );
	}
    }
  else
    {
      while (mask)
	{
	  RealRegister r1  = firstbit( mask );

      
	  ipop( r1 );

	  mask ^= regbit( r1 );
	}
    }

  return;
  
} /* restore_regs */


#ifdef TARGET_HAS_DEBUGGER

/*
 * set up and perform a call to _notify_entry()
 */

static void
do_notify_entry( void )
{
  extern Symstr *	current_proc;
  extern LabelNumber *	proc_label;
  int32			save_mask;
  

  if (debugging( DEBUG_Q ))
    cc_msg( "debugger: generating _notify_entry for: %s\n", symname_( current_proc ) );
  
  flush_peepholer( DBG( "notify_entry" ) );
  
  /*
   * we know that no temporaries have yet been assigned
   * so just save the argument registers,
   * but remember that we want to pass the stack
   * pointer as it was before pushing these registers
   * as our third argument to _notify_entry()
   */

  save_mask  = M_ALL_ARG_REGS;
  
  save_regs( save_mask, FALSE );
  
  /* third argument: the stack pointer */

  out_triadic_op( OP_ADDI3, R_A1 + 2, R_SP, bitcount( save_mask ),
		 ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		 examines1( R_SP ),
		 alters1( R_A1 + 2 ) );
		
  /* second argument: the frame pointer */
  
  move_register( R_FP, R_A1 + 1, FALSE, TRUE );

  /* first argument: the address of the ProcInfo structure as a word pointer */
  
  proc_label = nextlabel();

  /*
   * put PC of next instruction into R_LR
   *
   * (There is no need to save R_LR, as it will
   *  have been pushed onto the stack)
   */

  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

  /*
   * add in offset of the proc structure
   *
   * NB/ beware of assumption that proc structure is within 16
   * (signed) bits of this instruction - this may not be true
   */
  
  peep_fref( proc_label, LABREF_LIT16 ); 

  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_A1, -3,
		examines0(),
		alters2( R_A1, RR_ST ) );

  /* add in value in link register */
  
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_A1, R_LR,
		examines1( R_LR ),
		alters2( R_A1, RR_ST ) );

  nop( FALSE );

  flush_peepholer( DBG( "protect LAJ" ) );
  
  /* finally call the _notify_entry function */
  
  call( _notify_entry, FALSE );

  /* now restore saved argument registers */
  
  restore_regs( save_mask, FALSE );
  
  return;
  
} /* do_notify_entry */

#endif /* TARGET_HAS_DEBUGGER */


#define STACK_GUARD	64		/* number of words left clear at end of stack */

/*
 * XXX - CALLING SCHEME
 *
 * version:	7			(keep in step with module table and register schemes)
 * date:	23rd October 1991
 * designed:	NC
 *
 * changes from version 3 to version 7:
 *      Register allocation scheme has changed.  There are
 *	now 6 variable registers and 7 temporaries.
 *	(There were no versions 4, 5 or 6)
 *
 * changes from version 2 to version 3:
 *	frame pointer now pushed before link register
 *	frame pointer always retrieved relative to frame pointer, not stack pointer
 *	stack chunks now have a 6 word header
 *	fake arguments and (optionally) frame pointer pushed onto new stack chunk
 *	 by stack extension code
 *	stack extension code now implemented
 *	stack end pointer no longer points to end of stack
 *
 * changes from version 1 to version 2:
 *	stack is now falling
 *
 * This scheme uses a frame pointer, a stack pointer, a stack end pointer
 * and a module table pointer.  Arguments are accesssed relative to the
 * frame pointer.  Local variables are accessed relative to the stack
 * pointer.  External functions and data are accessed relative to the
 * module table.  If the stack fills up, a new chunk is allocated for it
 * by the compiler, so that the program can carry on execution normally.
 *
 * This scheme does not use a display, but if we need one then it would
 * be placed on the stack and accessed via the stack pointer.  The display
 * is a dynamic structure that cannot be a fixed because languages like
 * PASCAL require function tables in the display on a per function basis.
 *
 * We use an falling, full, stack pointer
 *
 *
 * before entry to a (non-leaf) function has completed :-
 * (NB/ arguments 1 to 4 held in registers, return address held in link register)
 *
 *
 *     This is the execution stack, memory DECREASES this way -->
 *     -----------------------------  -  -  -  -  - ----
 *               |     |   |     |                      |
 *      previous | arg |...| arg |                      |
 *      function |  n  |   |  5  |                      |
 *               |     |   |     |                      |
 *     -----------------------------  -  -  -  -  - ----
 *         ^                  ^              ^         ^
 *         |                  |              |         |
 *         FP                 SP             SE   (end of stack)
 *
 *    FP  - current frame pointer
 *    SP  - current stack pointer
 *    SE  - stack end pointer (plus STACK_GUARD words)
 *
 *
 * after entry to a (non-leaf) function has completed
 * (NB/ arguments 1 to 4 now on stack, all arguments accessed via FP)
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ------------------------------------------------------------- - - - ---
 *               |     |   |     |     |     |       |   |       |            |
 *      previous | arg |...| arg | FP' | LNK | saved |...| saved |            |
 *      function |  n  |   |  1  |     |     |  reg  |   |  reg  |            |
 *               |     |   |     | |   |     |       |   |       |            |
 *     ----------------------------|-------------------------------- - - - ---
 *        ^                        | ^                       ^           ^
 *        |________________________| |                       |           |
 *                                   |                       |           |
 *                                   FP                      SP          SE
 *
 *	FP' - frame pointer  of previous function
 *	LNK - return address to previous function
 *
 * during execution of a (non-leaf) function :-
 * (note locals on the stack)
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     -------------------------------------------------------------------------------- -
 *              |     |   |     |     |     |       |   |       |       |   |       |
 *     previous | arg |...| arg | FP' | LNK | saved |...| saved | local |...| local |
 *     function |  n  |   |  1  |     |     |  reg  |   |  reg  |   n   |   |   1   |
 *              |     |   |     | |   |     |       |   |       |       |   |       |
 *     ---------------------------|---------------------------------------------------- -
 *       ^                        | ^                                           ^
 *       |________________________| |                                           |
 *                                  |                                           |
 *                                  FP                                          SP
 *
 *
 * before entry to a (non-leaf) function has completed :-
 * (with no more than 4 arguments passed to the function)
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     -------------  -  -  -  -  - ---
 *               |                     |
 *      previous |                     |
 *      function |                     |
 *               |                     |
 *     -------------  -  -  -  -  - ---
 *       ^     ^                 ^
 *       |     |                 |
 *       FP    SP                SE
 *
 * after entry to such a function has completed :-
 * (NB/ no new stack frame allocated)
 * (NB/ this example only applies if none of the arguments have their address taken)
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     --------------------------------------- - - - - ---
 *               |     |       |   |       |              |
 *      previous | LNK | saved |...| saved |              |
 *      function |     |  reg  |   |  reg  |              |
 *               |     |       |   |       |              |
 *     --------------------------------------- - - - - ---
 *        ^                             ^            ^
 *        |                             |            |
 *        |                             |            |
 *        FP                            SP           SE
 *
 *
 * after entry to a such function has completed :-
 * (when the function is a LEAF FUNCTION)
 * (leaf functions call no other functions,
 *                 have all their arguments passed in registers,
 *                 do not take the address of any argument,
 *                 do not use varargs
 *                 and do not need a large amount of stack space)
 *
 * (NB/ link register not saved)
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ---------------------------------- - - - - ---
 *               |       |   |       |               |
 *      previous | saved |...| saved |               |
 *      function |  reg  |   |  reg  |               |
 *               |       |   |       |               |
 *     ---------------------------------- - - - - ---
 *        ^                       ^            ^
 *        |                       |            |
 *        |                       |            |
 *        FP                      SP           SE
 *
 *
 * after entry to a (non-leaf) function has completed (when there is insufficient stack space) :-
 * (NB/ insufficient space is defined to be less than STACK_GUARD words, (usually 64 words),
 *      the code will fail if there is insufficient room to store 5 words on stack).
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ------------------------------------------------------
 *               |     |   |     |     |   |     |      |    |
 *      previous | arg |...| arg | arg |...| arg |  FP' |    |
 *      function |  n  |   |  5  |  4  |   |  1  |      |    |
 *               |     |   |     |     |   |     |  |   |    |
 *     ---------------------------------------------|--------
 *        ^                   ^               ^     | ^  
 *        |___________________|_______________|_____| |  
 *                            |               |       |  
 *                            |               |       FP
 *                            |___       _____|
 *                                |     |
 *                                |     |
 *                <this is a new chunk of memory> memory DECREASES this way -->
 *      --------------------------|-----|------------------------------------------------------------ - - ---
 *     |       |       |       |  |  |  |  |     |dummy|   |dummy|dummy|      |       |   |       |          |
 *     | Chunk | Next  | Prev  | SP' | SE' | LNK | arg |...| arg | FP' | LNK' | saved |...| saved |          |
 *     | Size  | Chunk | Chunk |     |     |     |  4  |   |  1  |     |      |  reg  |   |  reg  |          |
 *     |       |       |       |     |     |     |     |   |     |     |      |       |   |       |          |
 *      --------------------------------------------------------------------------------------------- - - ---
 *                                                                                            ^         ^
 *                                                                                            |         |
 *                                                                                            SP        SE
 *
 *      LNK' - link address of a special assembler routine that frees up the newly allocated stack chunk
 *             (or more probably frees up the chunk after this one)
 *
 *	SP' - stack pointer before this function
 *
 *	SE' - stack end pointer for previous chunk
 *     
 *
 *
 * after entry to a (leaf) function has completed (when there was insufficient stack space) :-
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ----------------------
 *                 |         |
 *      previous   |         |
 *      function   |         |
 *                 |         |
 *     ----------------------
 *        ^       ^      ^
 *        |       |      |
 *        |       |      |______________
 *        FP      |                     |
 *                |_______________      |
 *                                |     |
 *                                |     |
 *      <this is a new chunk of memory> memory DECREASES this way -->
 *      --------------------------|-----|------------------------------- - - - ---
 *     |       |       |       |  |  |  |  |     |       |   |       |            |
 *     | Chunk | Next  | Prev  | SP' | SE' | LNK | saved |...| saved |            |
 *     | Size  | Chunk | Chunk |     |     |     |  reg  |   |  reg  |            |
 *     |       |       |       |     |     |     |       |   |       |            |
 *      ---------------------------------------------------------------- - - - ---
 *                                                               ^           ^
 *                                                               |           |
 *                                                               SP          SE
 *
 *	NB/ Link register now points to the special free_extension_stack routine
 *          and the original value of the link register has been saved on the new stack
 *          
 *
 * STILL TO DO
 *  alloca		(emulate J_SETSP + add stack checking - is alloca allowed to fail ? )
 */

/*
 * pseudo-code for stack extension routines
 *
 * 
 * typedef struct stack_chunk_header
 *   {
 *     unsigned int			size_of_chunk_in_words;	// excludes the size of the header      
 *     struct stack_chunk_header *	ptr_to_next_chunk;	// NULL if no following chunk           
 *     struct stack_chunk_header *	ptr_to_prev_chunk;	// NULL if no previous  chunk           
 *     unsigned int *			old_stack_pointer;	// last stack pointer in previous chunk 
 *     unsigned int *			old_stack_end_pointer;	// stack end pointer of previous chunk  
 *     void (*				old_return_address)();	// old value of link register           
 *   }
 * stack_chunk_header;
 * 
 * #define CHUNK_HEADER_SIZE	(sizeof (stack_chunk_header) / sizeof (int))	// in words 
 * 
 * static stack_chunk_header *	next_free_chunk = NULL;
 * static stack_chunk_header *	current_chunk   = NULL;
 * static int			min_chunk_size  = 2000;
 * 
 * static void
 * free_stack_chunk( void )
 * {
 *   // indicate that this chunk is now free 
 *   
 *   next_free_chunk = current_chunk;
 * 
 *   // get the previous chunk 
 *   
 *   current_chunk = next_free_chunk->ptr_to_prev_chunk;
 * 
 *   // check to see if we have unwound the stack all the way! 
 *   
 *   if (current_chunk == NULL)
 *     {
 *       abort();
 *     }
 * 
 *   // recover registers from the newly freed chunk 
 * 
 *   return_address    = next_free_chunk->old_return_address;
 *   stack_end_pointer = next_free_chunk->old_stack_end_pointer;
 *   stack_pointer     = next_free_chunk->old_stack_pointer;
 * 
 *   // XXX we are currently NOT freeing any chunks 
 *   
 *   return;
 *   
 * } // free_stack_chunk 
 * 
 * 
 * static void
 * get_new_stack_chunk(
 * 		    unsigned int	num_words_required,
 * 		    unsigned int	num_words_on_stack )
 * {
 *   stack_chunk_header *	new_chunk;
 *   int			size_of_chunk;
 * 
 * 
 *   // see if there are any free stack chunks 
 *   
 *   if (next_free_chunk == NULL)
 *     {
 *       // none available - try allocating a new one 
 *       
 *       size_of_chunk = min_chunk_size;
 * 
 *       // ensure that the new stack chunk will of suffiecient size 
 *       
 *       if (size_of_chunk < num_words_required)
 *       {
 * 	   size_of_chunk = num_words_required;
 *       }
 * 
 *       // allocate a new chunk 
 *       
 *       new_chunk = (stack_chunk_header *) malloc( (size_of_chunk + CHUNK_HEADER_SIZE) * sizeof (int) );
 * 
 *       // make sure that we got a chunk 
 *       
 *       if (new_chunk == NULL)
 *       {
 * 	   // oh dear - no more memory available 
 * 	  
 * 	   abort();
 * 	 }
 * 
 *       // fill in the first two fields of the chunk header 
 *       
 *       new_chunk->size_of_chunk_in_words = size_of_chunk;
 *       new_chunk->ptr_to_next_chunk      = NULL;
 *       new_chunk->ptr_to_prev_chunk      = current_chunk;
 *     }
 *   else 
 *     {
 *       // get the size of the next free chunk 
 *       
 *       size_of_chunk = next_free_chunk->size_of_chunk_in_words;
 * 
 *       // ensure that the chunk will be of sufficient size 
 *       
 *       if (size_of_chunk < num_words_required)
 * 	   {
 * 	     // if not then create a new chunk
 * 	     //
 * 	     // XXX
 * 	     // we really ought to search the
 * 	     // free chunk list for another chunk
 * 	     // of sufficient size before allocating
 * 	     // a new one.
 * 	  
 * 	     size_of_chunk = num_words_required;
 * 	  
 * 	     new_chunk = (stack_chunk_header *) malloc( (size_of_chunk + CHUNK_HEADER_SIZE) * sizeof (int) );
 * 
 * 	     // make sure that the malloc succeded 
 * 	  
 * 	     if (new_chunk == NULL)
 * 	       {
 * 	         // oh dear - out of memory 
 * 	      
 * 	         abort();
 * 	       }
 * 
 * 	     // store the size of this chunk 
 * 	  
 * 	     new_chunk->size_of_chunk_in_words  = size_of_chunk;
 * 
 * 	     // insert the new chunk into the chunk list 
 * 	  
 * 	           new_chunk->ptr_to_next_chunk = next_free_chunk;
 * 	     next_free_chunk->ptr_to_prev_chunk = new_chunk;
 * 	       current_chunk->ptr_to_next_chunk = new_chunk;
 * 	           new_chunk->ptr_to_prev_chunk = current_chunk;
 * 	   }
 *       else
 * 	   {
 * 	     // we can use the next available chunk 
 * 	  
 * 	     new_chunk = next_free_chunk;
 * 
 * 	     // advance free pointer to next chunk on list 
 * 	  
 * 	     next_free_chunk = next_free_chunk->ptr_to_next_chunk;
 * 	   }
 *      }
 * 
 *   // advance current chunk pointer 
 *   
 *   current_chunk = new_chunk;
 *   
 *   // fill in the rest of the chunk header 
 *   
 *   new_chunk->old_stack_pointer     = stack_pointer - num_words_on_stack;
 *   new_chunk->old_stack_end_pointer = stack_end_pointer;
 *   new_chunk->old_return_address    = return_address;
 * 
 *   // set up stack pointer 
 * 
 *   stack_pointer = ((unsigned int *)new_chunk) - CHUNK_HEADER_SIZE;
 * 
 *   // set up the stack end pointer 
 *   
 *   stack_end_pointer = stack_pointer - size_of_chunk + STACK_GUARD;
 * 
 *   // advance stack pointer by the number of words already
 *   // pushed onto the stack by the entry code for the current
 *   // function
 *      
 *   stack_pointer += num_words_on_stack;
 * 
 *   // and replace return address by the address of our chunk free routine 
 *   
 *   return_address = free_stack_chunk;
 * 
 *   return;
 *   
 * } // get_new_stack_chunk 
 */
  

/*
 * emit code to handle entry to a routine
 * this routine is being passed 'num_args' arguments
 */

static void
routine_entry( int32 arg_mask )
{
  int32	imask             = 0;
  int32	fmask             = 0;
  int32	imaskarg          = 0;
  int32	fmaskarg          = 0;


  /* initialise available address registers */
  
  peep_init_addr_regs( usedmaskvec.map[ 0 ] );

  if (!new_stubs && in_stubs)
    {      
      /* stub routines have no entry code */
  
      saved_ivars  = 0;
      saved_fvars  = 0;
      saved_args   = 0;
      saved_frame  = 0;
      stack_move   = 0;
      stack_offset = 0;
      
      return;
    }
  
  /* check the argument mask passed to this function */
  
  if (arg_mask < 0)
    {
      syserr( syserr_enter, arg_mask );
    }

  /*
   * imask	       - is a bit mask of registers used by this function which MUST be saved before use
   * fmask	       - FP register equivalent of imask
   * imaskarg	       - is a bit mask of the arg regs that must be saved (since their address will be used)
   * fmaskarg	       - FP register equivalent of fmask
   */

  fmask = usedmaskvec.map[ 0 ] & M_FVARREGS;
  imask = usedmaskvec.map[ 0 ] & M_VARREGS;

  if (procflags & BLKCALL
#ifdef TARGET_HAS_DEBUGGER
      || usrdbg( DBG_ANY )
#endif
      || usedmaskvec.map[ 0 ] & regbit( R_LR )
    )
    {
      /*
       * if we are going to call another procedure then we must
       * save the link register
       *
       * XXX - should I check against BLK2CALL aswell ?
       */
      
      imask |= regbit( R_LR );
    }

  /*
   * note that the compiler is paranoid - even if only
   * one argument has its address taken then it will ask
   * us to save all of the arguments on the stack - such is life
   */
  
  if (procflags & PROC_ARGPUSH)
    {
      imaskarg = mask_of_regs_( R_A1,  k_intregs_( arg_mask ) );
      fmaskarg = mask_of_regs_( R_FA1, k_fltregs_( arg_mask ) );
      
      /*
       * XXX - ignore registers in the regmaskvec as these are the
       * registers USED or CORRUPTED by the function, and they may not include
       * all of the registers used to PASS arguments to the function
       */ 
    }

#if defined TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_ANY ))
    {
      /*
       * save all registers since debugger wants to
       * be able to grab initial values for arguments
       * even after the function has started executing
       */
      
      imaskarg |= M_INT_ARG_REGS;
      fmaskarg |= M_FLT_ARG_REGS;
      imask    |= M_VARREGS;
      fmask    |= M_FVARREGS;
    }
#endif /* TARGET_HAS_DEBUGGER */
  
  /* peepf( "num_args = %d + %d, register masks: used = %x, INT var = %x, FP var = %x, args = %x , %x",
       k_intregs_( arg_mask ), k_fltregs( arg_mask ),
       usedmaskvec.map[ 0 ], imask, fmask, imaskarg, fmaskarg ); */
  
  /*
   * The return label is created here, but it is not set until its first use.
   * When it is used then routine_exit code is generated and from then on all
   * return statements will branch to that label.  If the function does not
   * return then the return code will never be generated!
   */
		    
  returnlab = nextlabel();
  
  /*
   * at the start of a function that stack is set correctly
   * and there are no local variables
   */
  
  stack_move   = 0;
  stack_offset = 0;

  /*
   * this should not be necessary, but let's be paranoid ....
   */
  
  flush_peepholer( DBG( "start of function" ) );
  
  /*
   * If necessary, push arguments onto stack.
   * We do not need to keep the stack double word
   * aligned, so do not bother.
   */

  if (imaskarg)
    {
      save_regs( imaskarg, FALSE );
    }

  if (fmaskarg)
    {
      save_regs( fmaskarg, TRUE );
    }

  /*
   * next save the frame pointer (if necessary)
   */

  if (k_argwords_( arg_mask ) > k_regargwords_( arg_mask ) ||	/* if we have arguments passed on the stack */
      imaskarg						   ||	/* or we have had to save args on the stack */
      fmaskarg						   ||	/* or we have had to save args on the stack */
      backtrace_enabled					    )	/* or we are supporting back traces	    */
    {
      /**/                             				/* then we must save old frame pointer */

      ipush( R_FP );

      /* set new frame pointer to be current stack position */

      move_register( R_SP, R_FP, FALSE, TRUE );

      /* make a note that we have saved FP */

      saved_frame = TRUE;
    }
  else
    {
      saved_frame = FALSE;
    }

  /*
   * now check to see if we have sufficient stack remaining
   * or if we need to allocate a new stack hunk
   */
  
  if (!no_stack_checks)
    {
      LabelNumber *	stack_ok = NULL;
      int32		require;
      int32		already_placed;
      

      /* calculate number of words already placed upon stack */
      
      already_placed = bitcount( imaskarg ) + 2 * bitcount( fmaskarg ) + (saved_frame ? 1 : 0);

      /* calculate the maximum number of words of stack we will need in the function we are entering */
      
      /*
       * XXX for some reason the front end does not always get the greatest depth correct
       * it seems to forget about saving registers (especially the link register) onto the stack
       */
      
      require = greatest_stackdepth / sizeof_int + bitcount( imask ) + bitcount( fmask ) * 2;

      /* fprintf( asmstream, "; words required = %ld, already placed = %ld, greatest depth = %ld\n",
	      require, already_placed, greatest_stackdepth ); */
      
      /*
       * note that we have optimised leaf procedures by assuming that we
       * will always have 25 words of stack available to us
       */
      
      if (require > 25 || ((procflags & BLKCALL) && require > 0))
	{
	  RealRegister	cmp_reg = R_TMP1;

	  
	  /*
	   * place stack pointer less number of words of stack we will require,
	   * into temporary register
	   */

	  if (!fits_in_8_bits_signed( require ))
	    {
	      load_integer( R_TMP2, require, FALSE );

	      out_triadic_op( OP_SUBI3, cmp_reg, R_SP, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			     examines2( cmp_reg, R_SP ),
			     alters2( R_TMP1, RR_ST ) );
	    }
	  else if (require > 25)
	    {
	      out_triadic_op( OP_SUBI3, cmp_reg, R_SP, require,
			     ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( R_SP ),
			     alters2( cmp_reg, RR_ST ) );
	    }
	  else
	    {
	      /*
	       * XXX - special optimisation - with less than 26 words of stack
	       * being used just check the stack pointer against the stack end
	       * pointer.  This saves an entire instruction.  We have a excess
	       * of 64 words on the stack end pointer 25 of which are used here,
	       * and 25 are used in leaf functions.
	       */
	      
	      cmp_reg = R_SP;	      
	    }
	  
	  /* if this is still above the stack end pointer ... */
	  
	  out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, R_SE, cmp_reg,
			examines2( cmp_reg, R_SE ),
			alters1( RR_ST ) );
	  
	  if (!few_modules)
	    {
	      /* ... then skip the next few instructions */

	      /*
	       * with the few_modules model we assume that we can use a
	       * conditional LAJ which only hsa a 16 bit displacement
	       */
	      
	      stack_ok = nextlabel();

	      /*
	       * NB/ Comparison must be unsigned as the stack pointer
	       * could be on global bus (>= 0x80000000) and the stack
	       * end pointer could be on local bus (<= 0x7fffffff)
	       * and a signed compare would show the stack pointer
	       * being less than the stack end pointer, hence requiring
	       * a new stack chunk.
	       */
	      
	      conditional_branch_to( Q_LO, stack_ok );
	    }	  

	  conditional_load( Q_HS, ADDR_MODE_REGISTER, R_TMP3, R_LR,
			   examines1( R_LR ),
			   alters1( R_TMP3 ) );
	  
	  /* place number of words we require in R_TMP2 (if not already placed there) */
	  
	  if (fits_in_8_bits_signed( require ))
	    {
	      conditional_load( Q_HS, ADDR_MODE_IMMEDIATE, R_TMP2, require,
			       examines0(), alters1( R_TMP2 ) );
	    }

	  /* and place number of words we have added to the stack into R_TMP1 */

	  conditional_load( Q_HS, ADDR_MODE_IMMEDIATE, R_TMP1, already_placed,
			   examines0(), alters1( R_TMP1 ) );

	  /* and call get_new_stack_chunk function */

	  if (few_modules)
	    {
	      peep_xref( X_PCreloc2, stackoverflow );
	      
	      outdelsymref( (OP_LAJc << 24) | 0x1U << 21 | C_FROMQ( Q_HS ) << 16 | (-3 & 0x0000ffffU),
			   stackoverflow,
			   examines0(),
			   alters2( R_LR, RR_PC ) );
      
	      flush_peepholer( DBG( "stack size checking code" ) );
	    }
	  else
	    {
	      call( stackoverflow, FALSE );

	      flush_peepholer( DBG( "stack size checking code" ) );
	  
	      /* on return from this function R_SP, R_LR and R_SE will have been set up */

	      setlabel( stack_ok );
	    }	  
	}
      else if (already_placed > 0 && (procflags & BLKCALL))
	{
	  /*
	   * if we have just put some words on the stack and we are going
	   * to call another function, and we do not require any more stack space
	   * ourselves, we still have to check to see if we have used up the
	   * current stack chunk ....
	   */

	  /* check stack pointer in case we have run out of space */
	  
	  out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, R_SE, R_SP,
			examines2( R_SE, R_SP ),
			alters1( RR_ST ) );

	  if (!few_modules)
	    {
	      stack_ok = nextlabel();

	      /* if we are OK skip the next bit */
	  
	      conditional_branch_to( Q_LO, stack_ok );
	    }

	  /* save the return address */
	  
	  conditional_load( Q_HS, ADDR_MODE_REGISTER, R_TMP3, R_LR,
			   examines1( R_LR ),
			   alters1( R_TMP3 ) );
	  
	  /* we do not require any more words */
	  
	  conditional_load( Q_HS, ADDR_MODE_IMMEDIATE, R_TMP2, 0,
			   examines0(),
			   alters1( R_TMP2 ) );
	  
	  /* but we have already used some ... */
	  
	  conditional_load( Q_HS, ADDR_MODE_REGISTER, R_TMP1, already_placed,
			   examines0(),
			   alters1( R_TMP1 ) );

	  /* call get_new_stack_chunk function */

	  if (few_modules)
	    {
	      peep_xref( X_PCreloc2, stackoverflow );
	      
	      outdelsymref( (OP_LAJc << 24) | 0x1U << 21 | C_FROMQ( Q_HS ) << 16 | (-3 & 0x0000ffffU),
			   stackoverflow,
			   examines0(),
			   alters2( R_LR, RR_PC ) );
      
	      flush_peepholer( DBG( "stack size checking code" ) );
	    }
	  else
	    {
	      call( stackoverflow, FALSE );

	      flush_peepholer( DBG( "stack size checking code" ) );
	  
	      /* on return from this function R_SP, R_LR and R_SE will have been set up */

	      setlabel( stack_ok );
	    }
	}
    }
  
  /*
   * now save any register we are going to corrupt in this function
   * this may include the link register
   */

  if (imask)
    {
      save_regs( imask, FALSE );
    }
  
  if (fmask)
    {
      save_regs( fmask, TRUE );
    }
  
  /*
   * OK we are done - set up the remaining statics used by routine_exit()
   */

  saved_ivars = imask;
  saved_fvars = fmask;
  saved_args  = bitcount( imaskarg ) + 2 * bitcount( fmaskarg );

#if defined TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_PROC ) && !in_stubs)
    {
      do_notify_entry();
    }
#endif
  
  return;
  
} /* routine_entry */


#ifdef TARGET_HAS_DEBUGGER

static void
do_notify_leave( void )
{
  extern Symstr *	current_proc;
  extern LabelNumber *	proc_label;


  if (debugging( DEBUG_Q ))
    cc_msg( "debugger: generating _notify_return for: %s\n", symname_( current_proc ) );
  
  flush_peepholer( DBG( "notify_leave" ) );

  /*
   * At this point the rotuine is about to exit.
   * The return code, (if any) is in R_A1, (or the
   * area of memory pointed to by R_A1).  The return
   * will either be a BuD R_LR or a BRD <offset> if a
   * tailcall is taking place.
   *
   * We can call our _notif_return function
   * directly as R_LR will have been cached upon the stack,
   * and no variable registers have significant values
   * left in them.
   */

  /* second argument: the return value */
  
  move_register( R_A1, R_A1 + 1, FALSE, TRUE ); /* XXX - potential bug, if return value is a double */

  /* first argument: the address of the ProcInfo structure as a word pointer */
  
  /*
   * put PC of next instruction into R_LR
   *
   * (There is no need to save R_LR, as it will
   *  have been pushed onto the stack)
   */

  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

  /*
   * add in offset of the proc structure
   *
   * NB/ beware of assumption that proc structure is within 16
   * (signed) bits of this instruction - this may not be true
   */
  
  peep_fref( proc_label, LABREF_LIT16 ); 

  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_A1, -3,
		examines0(),
		alters2( R_A1, RR_ST ) );

  /* add in value in link register */
  
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_A1, R_LR,
		examines1( R_LR ),
		alters2( R_A1, RR_ST ) );

  nop( FALSE );
  
  flush_peepholer( DBG( "protect LAJ again" ) );
  
  /* finally call the _notify_return function */
  
  call( _notify_return, FALSE );

  /*
   * upon return from this function R_A1 will have been restored
   * to its proper value
   */
  
  return;
  
} /* do_notifty_leave */

#endif /* TARGET_HAS_DEBUGGER */


static void
routine_exit( bool tailcall )
{
  RealRegister	link_reg = R_LR;


  if (saved_link_reg != GAP)
    {
      /* this is a special optimisation for data initialisation */
      
      link_reg       = saved_link_reg;
      saved_link_reg = GAP;
    }
  
  /*
   * ensure that the stack pointer is back at start of local variables
   * this should remove local variables and effectively resets any
   * stack manipulations
   */

  /* The correct_stack() has been put here as a bugfix. cf genmodule() in linker/readfile.c */
  
  correct_stack( TRUE );
  
  if (stack_offset >= sizeof_int)
    {
      flush_pending_pushes();
      
      stack_offset /= sizeof_int;

      if (fits_in_16_bits_signed( stack_offset ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, stack_offset,
			examines1( R_SP ),
			alters2( R_SP, RR_ST ) );
	}
      else
	{
	  load_integer( R_TMP1, stack_offset, FALSE );
	  
	  out_triadic_op( OP_ADDI3, R_SP, R_SP, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			examines2( R_SP, R_TMP1 ),
			alters2( R_SP, RR_ST ) );
	}

      stack_offset = 0;
    }

  stack_move = 0;
  
  /*
   * if the return label has not yet been set
   * and we are not doing a tail call then
   * set the label
   */
  
  if (!tailcall && !lab_isset_( returnlab ))
    {
      /* note to NC from NC - this flush is necessary! */
#if 1
      /* experimental - eg for int func( int arg ){ return arg * arg; } */
      
      if (returnlab->u.frefs != NULL || peep_refs_label( returnlab ))
#endif
	{
	  flush_peepholer( DBG( "routine_exit" ) );

	  setlabel( returnlab );
	}
    }
  
#if defined TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_PROC ) && !in_stubs)
    {
      do_notify_leave();
    }
#endif
  
  /*
   * if registers were saved onto the stack then pop them back
   */

  if (saved_fvars)
    {
      restore_regs( saved_fvars, TRUE );
    }

  if (saved_ivars)
    {
      if (!no_peepholing && !tailcall && (saved_ivars & regbit( R_LR )))
	{
	  int32		pos;
	  int32		count;

	  
	  /*
	   * special optimisation
	   *
	   * We are about to do a "BuD R_LR", so try
	   * popping this off the stack first, in the hopes that
	   * the BuD can be pushed back over the remaining pops
	   */

	  pos   = 1;
	  count = 0;

	  /* count number of registers on stack "above" the link register */
	  
	  while (pos < R_LR)
	    {
	      if (saved_ivars & regbit( pos ))
		++count;
	      
	      ++pos;
	    }

	  if (count > 0)
	    {
	      int32	TMP;
	      
	      
	      /* pull the link register off the stack */

	      if (count == 1)
		{
		  /*
		   * another piece of optimisation here
		   * If we pull the link register into one of R1 - R7
		   * (and the increment is 1)
		   * then we may be able to combine it with the previous
		   * instruction, making a parallel load !
		   * (But only a temporary register that we have already dirtied)
		   */

		  if (usedmaskvec.map[ 0 ] & regbit( R_A1 + 1 ))
		    link_reg = R_A1 + 1;
		  else if (usedmaskvec.map[ 0 ] & regbit( R_A1 + 2 ))
		    link_reg = R_A1 + 2;
		  else if (usedmaskvec.map[ 0 ] & regbit( R_A1 + 3 ))
		    link_reg = R_A1 + 3;
#if R_FT1 > 0
		  else if (usedmaskvec.map[ 0 ] & regbit( R_FT1 ))
		    link_reg = R_FT1;					/* currently R6 */
		  else if (usedmaskvec.map[ 0 ] & regbit( R_FT1 + 1 ))
		    link_reg = R_FT1 + 1;
#endif
#if R_FA1 > 0
		  else if (usedmaskvec.map[ 0 ] & regbit( R_FA1 ))
		    link_reg = R_FA1;					/* currently R4 */
#endif
		}
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, link_reg,
			    build_indirect( INDIRECT_PRE_ADD, R_SP, count ),
			    examines1( R_SP ),
			    alters2( link_reg, RR_ST ) );

	      /* preserve a copy of saved_ivars before altering it */
	      
	      TMP = saved_ivars;
	      
	      /* remove the link register (and all registers above it) from the mask of registers to pop */
	  
	      saved_ivars &= (regbit( R_LR ) - 1);
	      
	      /* pop all the other variable registers off the stack */
	  
	      restore_regs( saved_ivars, FALSE );

	      /* restore saved_ivars - in case it is used again */
	  
	      saved_ivars = TMP;

	      /* add one to stack pointer to skip past link register (which is still on the stack) */

	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, 1,
			    examines1( R_SP ),
			    alters2( R_SP, RR_ST ) );
	      
	      /* get any registers above R_LR */
	      
	      TMP &= ~(regbit( R_LR + 1 ) - 1);

	      /* if there are any then restore those as well */
	      
	      if (TMP)
		{
		  restore_regs( TMP, FALSE );
		}
	    }
	  else
	    {
	      restore_regs( saved_ivars, FALSE );
	    }
	}
      else
	{
	  restore_regs( saved_ivars, FALSE );
	}
    }

  /*
   * at this point SP == FP unless we ahave split the stack
   * across two stack chunks, in which case we MUST restore
   * the frame pointer relative to FP
   */

  /*
   * if the previous frame pointer
   * was saved on the stack then pop it
   */

  if (saved_frame)
    {
      /*
       * special optimisation -
       *
       * we must reduce the stack by an extra word to account
       * for the frame pointer, BUT, if we did not push any
       * arguments onto the stack then we will not be able to
       * include this word in simulated pop below.  Instead
       * we include the reduction here, and the peepholer
       * will try to merge the addition into the restoring
       * of the saved temporary registers above
       *
       * XXX - this is now disallowed because it means that
       * the stack pointer is incremented before the FP
       * is read off the stack, and so an interrupt routine
       * could, conceivably, come in and corrupt the FP on
       * the stack.  Hence we do the load before we do the add
       */
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_FP, build_indirect( INDIRECT_REL, R_FP, 0 ),
		    examines1( R_FP ),
		    alters2( R_FP, RR_ST ) );
      
      if (saved_args == 0)
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, 1,
			examines1( R_SP ),
			alters2( R_SP, RR_ST ) );
	}
    }

  /*
   * if arguments were pushed onto the stack then adjust
   * the stack pointer, (do not bother to pop)
   */

  if (saved_args)
    {
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, saved_args + (saved_frame ? 1 : 0),
		     examines1( R_SP ),
		     alters2( R_SP, RR_ST ) );
    }
  
  /*
   * if we are doing a tailcall then the next instruction output
   * will be a branch to the next function, otherwise we have to
   * return through the link (by doing a conditional branch)
   */

  if (!tailcall)
    {
      /* this is a conditional, delayed branch, register relative */
      
      outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( link_reg ),
		 examines1( link_reg ),
		 alters1( RR_PC ) );
      /*
       * make sure that all of the op codes have been emitted
       */
  
      flush_peepholer( DBG( "end of function" ) );
    }

  /*
   * finished
   */

  return;
    
} /* routine_exit */


/*
 * this function returns the register, relative to which
 * the given symbol may be accessed
 */

RealRegister
local_base( Binder * b )
{
  int32	addr = bindaddr_( b );

  
  /*
   * arguments are accessed relative to frame pointer
   * locals    are accessed relative to stack pointer
   */
  
  switch (addr & BINDADDR_MASK)
    {
    default:
      syserr( syserr_local_base, (long)addr );
      
    case BINDADDR_ARG:
      return R_FP;
      
    case BINDADDR_LOC:
      return R_SP;
    }
  
} /* local_base */


/*
 * This function gives the offset of the
 * symbol passed in from the
 * register given by the 'local_base()'
 */
  
int32
local_address( Binder * b )
{
  int32 	addr = bindaddr_( b );
  int32 	off  = addr & ~BINDADDR_MASK;

  
  switch (addr & BINDADDR_MASK)
    {
    default:
      syserr( syserr_local_address, (long)addr );

      /* drop through */
      
    case BINDADDR_LOC:	/* relative to stack pointer */

      /*
       * The values look like this:
       *
       *           decreasing memory -->
       * ___________________________________________________ _ _
       *  |           |       |                           |
       *  | arguments | saved | locals    (local)         |
       *  |           | regs  |           (sought)        |
       *  |           |       |               |           |
       * --------------------------------------------------- - - 
       *            ^                                    ^
       *            |                                    |
       *            FP                                   SP
       *                       <------stack offset-------> <---stack move--->
       *                       <----off------>
       *
       */
       
      correct_stack( TRUE );

      return (stack_offset - off);

    case BINDADDR_ARG:	/* relative to frame pointer */

      /*
       * The stack can look like this ... ((saved_args != 0))
       *
       *           decreasing memory -->
       * __________________________________________ _ _
       *  |     |   |     |     |   |     |     |
       *  | arg |...| arg | arg |...| arg | old |
       *  |  n  |   |  5  |  4  |   |  1  | FP  |
       *  |     |   |     |     |   |     |     |
       * ------------------------------------------ - - 
       *                                     ^                            
       *                                     |                            
       *                                     FP
       *
       * or like this ... ((saved_args == 0))
       *
       *           decreasing memory -->
       * __________________________________________ _ _
       *  |     |   |     |     |
       *  | arg |...| arg | old |
       *  |  n  |   |  5  | FP  |
       *  |     |   |     |     |
       * ------------------------------------------ - - 
       *                     ^                            
       *                     |                            
       *                     FP                           
       *
       * offset is the (number of the argument minus 1) multiplied by sizeof_int
       *
       * saved_frame is always True if this function is called
       */

      if (saved_args == 0)
	{
	  /* arguments 1 - 4 held in registers */
	    	
	  return (off + (1 - NARGREGS) * sizeof_int );
	}
      else
	{
	  return (off + sizeof_int);
	}
    }
  
} /* local_address */


/*
 * Although the idea of setlabel is machine independent, it stays here
 * because it back-patches code.  In the long term setlabel should be
 * in codebuf.c and call a machine dependent backpatch routine.
 */

void
setlabel( LabelNumber * l )
{
  List *	p;
  

  if (lab_isset_( l ))
    {
      syserr( syserr_already_set_label );
    }
  
  /* do not flush the peepholer - this is done elsewhere */
  
  if (asmstream)
    {
      asm_lablist = mkLabList( asm_lablist, l );
    }
  
  /* resolve all the forward references to this label */

  p = l->u.frefs;	/* XXX should this be before the mkLabList() call ??? */

  while (p != NULL)
    {
      int32		v = car_( p );
      int32 		q = (v & 0x00ffffffU);   /* BYTE address */
      int32 		w = code_inst_( q );
      unsigned32	d;


      /*
       * v	- the type of forward reference
       * q	- the address (in code space) of the instruction to be patched
       * w	- the instruction to be patched
       * d	- work variable
       */

      switch (v & 0xff000000U)
        {
	case LABREF_OFF24:     /* e.g. forw. BR ref. */
	  
	  /* note assumption that sizeof_int == 4 */

	  d = (codep - q  >> 2) + mask_and_sign_extend_word( w, 0x00ffffffU );

	  if (!fits_in_24_bits_signed( d ))
	    syserr( syserr_displacement, (long)d );

	  if (d == 0 && !no_peepholing)
	    {
	      /* we have a branch to the next instruction ! */

	      w = OP_NOP << 23;
	      
	      peepf( "converted branch to next instruction into NOP" );

	      ++peep_transformed;
	    }
	  else
	    {
	      w = (w & 0xFF000000U) | (d & 0x00FFFFFFU);
	    }

	  break;

	case LABREF_OFF16:     /* e.g. forw. Bc ref. */

	  /* note assumption that sizeof_byte * 4 == sizeof_int */
	  
	  d = (codep - q  >> 2) + mask_and_sign_extend_word( w, 0xffff );

	  if (!fits_in_16_bits_signed( d ))
	    syserr( syserr_displacement, (long)d );
	  
	  w = (w & 0xffff0000U) | (d & 0xffff);

	  break;
	  
	case LABREF_LIT16:     /* e.g. forw. LDI ref. */

	  /* note assumption that sizeof_byte * 4 == sizeof_int */
	  
	  d = (codep - q  >> 2) + mask_and_sign_extend_word( w, 0xffff );

	  if (!fits_in_16_bits_signed( d ))
	    syserr( syserr_displacement, (long)d );
	  
	  w = (w & 0xffff0000U) | (d & 0xffff);
	  
	  break;
	  
	case LABREF_LIT8:     /* e.g. forw. ADDI3 ref. */

	  /* note assumption that sizeof_byte * 4 == sizeof_int */
	  
	  d = ((codep - q  >> 2) >> 16) + mask_and_sign_extend_word( w, 0xff );

	  if (!fits_in_8_bits_signed( d ))
	    syserr( syserr_displacement, (long)d );
	  
	  w = (w & 0xffffff00U) | (d & 0xff);
	  
	  break;
	  
	case LABREF_ABS32:     /* e.g. BXX */
	  {
	    CodeXref *	z = (CodeXref *) (((List3 *)p)->csr);

	    
	    /* note assumption that sizeof_byte * 4 == sizeof_int */
	  
	    z->codexrlitoff += (codebase + codep) >> 2;
	    
	    p = (List *)discard3( p );

	    code_inst_( q ) = z->codexrlitoff;
	    
	    continue;
	  }
	  
	default:
	  syserr( syserr_labref, (long)v );
        }

      code_inst_( q ) = w;
      
      p = (List *)discard2( p );
    }

  /* and set the label */

  lab_setloc_( l, codep | 0x80000000U ); /* cheapo union checker for ->frefs */

  return;
  
} /* setlabel */


/*
 * Locates a free register from the list of hardware
 * registers supplied.
 * The list is terminated by a register of value GAP.
 * If no free register can be found GAP is returned.
 */

static RealRegister
get_free_register(
		  RealRegister	reg,
		  ... 		)
{
  int32		map  = usedmaskvec.map[ 0 ];	/* XXX - assumes less than 32 registers */
  va_list	args;

  
  /*
   * XXX - there is a potential bug here
   *
   * If this function selects an argument register as being free
   * because the function does not use that argument register,
   * but the Norcroft front end, with its global knowledge of the
   * registers corrupted by a function, thinks that the argument
   * register is not corrupted, then it might be tempted to use
   * the argument register as a variable register !
   *
   * NB/ This will not work for variable registers!
   *
   * The augmentation below is an attempt to fix this.
   */

  va_start( args, reg );

  while (reg != GAP)
    {
      /* see if the register is used by the function */
      
      if ((map & regbit( reg )) == 0)
	{
	  /* let the front end know that we are going to corrupt this register */

	  augment_RealRegSet( &regmaskvec, reg );

	  /* paranoia alert - make sure that this register has not been push cached */

	  maybe_flush_pending_push( reg );
	  
	  break;	  
	}

      /* get the next register in the list */
      
      reg = va_arg( args, RealRegister );
    }
  
  /* tidy up */
  
  va_end( args );

  /* return located register */
  
  return reg;
  	    
} /* get_free_register */
  
  
/*
 * set to zero the 'length' "bytes" of memory pointed to by 'start'
 */

static void
clear_memory(
	     RealRegister	start,			/* pointer to memory to be set to 0 */
	     int32		length,			/* number of bytes to clear, (a word multiple) */
	     int32		can_corrupt_start )	/* TRUE if the start register can be corrupted */
{
  RealRegister	dst;
  
  
  if (length < 1 || length & (sizeof_int - 1))
    {
      syserr( syserr_bad_block_length, length );
      
      return;
    }

  /*
   * XXX
   *
   * NB/ we are assuming that the address given to us
   * will be word aligned - THIS HAD BETTER BE TRUE!
   *
   */

  if (!can_corrupt_start || !is_address_register( hardware_register( start ) ))
    {
      /* use temporary address register */

      dst = peep_get_free_addr_reg( GAP );
    }
  else
    {
      dst = start;
    }

  /*
   * round length down to nearest word
   */
  
  length /= sizeof_int;
  
  /*
   * store temporary into block
   */

  if (length == 1)		/* XXX - can this ever happen ? */
    {
      (void) convert_to_word_alignment( start, dst, 0, NULL );
      
#ifdef STIK_NOW_WORKS_ON_HARDWARE     
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ),
		    examines2( dst, R_BASE ),
		    alters0() );
#else
      load_integer( R_TMP1, 0, FALSE );
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ),
		    examines3( dst, R_BASE, R_TMP1 ),
		    alters0() );
      
#endif /* STIK_NOW_WORKS_ON_HARDWARE */
    }
  else if (length == 2)		/* XXX - can this ever happen ? */
    {
      (void) convert_to_word_alignment( start, dst, 0, NULL );
      
#ifdef STIK_NOW_WORKS_ON_HARDWARE     
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_PRE_INCR_IR0, dst, 0 ),
		    examines2( dst, R_BASE ),
		    alters1( dst ) );

      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_PRE_ADD, dst, 1 ),
		    examines1( dst ),
		    alters0() );
#else
      load_integer( R_TMP1, 0, FALSE );
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_INCR_IR0, dst, 0 ),
		    examines3( dst, R_BASE, R_TMP1 ),
		    alters1( dst ) );

      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD, dst, 1 ),
		    examines2( dst, R_TMP1 ),
		    alters0() );
      
#endif /* STIK_NOW_WORKS_ON_HARDWARE */
      
      peep_note_addr_reg_loaded( dst, start, 0, TRUE );
    }
  else
    {
      LabelNumber *	l = nextlabel();
#ifndef STIK_NOW_WORKS_ON_HARDWARE
      RealRegister	zero;
#endif
      

      /* load repeat count */

      load_integer( RR_RC, length - 1, FALSE );

      flush_peepholer( DBG( "force RC flush" ) );

#ifndef STIK_NOW_WORKS_ON_HARDWARE
#ifdef TARGET_R0_ALWAYS_ZERO
      zero = RR_R0;
#else
      zero = get_free_register( RR_R0,  RR_R1, RR_R2, RR_R3, RR_R6, RR_R7, RR_R10, GAP );

      if (zero == GAP)
	{
	  zero = R_LR;

	  if ((saved_ivars & regbit( R_LR )) == 0 ||
	      usedmaskvec.map[ 0 ] & regbit( R_LR ))	/* link register being used as temporary */
	    ipush( R_LR );
	}
#endif
#endif /* !STIK_NOW_WROKS_ON_HARDWARE */
      
      /* convert destintation pointer to word offset */

      convert_to_word_address( start, dst );

      /* NB/ do NOT use RPTS as this locks out interrupts */

      outdellabref( (OP_RPTBD << 24) | (-3 & 0x00FFFFFFU),
		   l,
		   LABREF_OFF24,
		   examines1( RR_PC ),
		   alters4( RR_RC, RR_RS, RR_RE, RR_PC ) );
      
      setlabel( l );

#ifdef STIK_NOW_WORKS_ON_HARDWARE
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
		    alters1( dst ) );
#else
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, zero, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines2( dst, zero ),
		    alters1( dst ) );
      
#endif /* STIK_NOW_WORKS_ON_HARDWARE */
      
      flush_peepholer( DBG( "end of repeat block" ) );

#ifndef STIK_NOW_WORKS_ON_HARDWARE
      if (zero == R_LR &&
	  (((saved_ivars & regbit( R_LR )) == 0) ||
	   usedmaskvec.map[ 0 ] & regbit( R_LR )) )	/* link register being used as temporary */
	{
	  ipop( R_LR );
	}      
#endif
      peep_note_addr_reg_loaded( dst, start, length, TRUE );
    }
  
  return;
      
} /* clear_memory */


/*
 * copy the 'length' "bytes" of memory pointed to by 'src' to the area pointed to by 'dst'
 * Both pointers are word aligned, and 'length' is a whole number of words
 */

static void
copy_memory(
	    RealRegister	src,			/* register containing byte piinter to source */
	    RealRegister	dst,			/* register containing byte pointer to destination */
	    int32		length,			/* number of bytes to copy */
	    int32		can_corrupt_source,	/* non-zero if 'src' can be courrupted */
	    int32		can_corrupt_dest )	/* non-zero if 'dst' can be corrupted */
{
  RealRegister	source;
  RealRegister	dest;
  int		restore_ar    = FALSE;
  

  if (length < 4)
    syserr( syserr_copy_less_than_four, length );

  if (length & (sizeof_int - 1))
    syserr( syserr_non_word_multiple, length );
      
  /*
   * get registers into address registers
   */
  
  if (!can_corrupt_source || !is_address_register( hardware_register( src ) ))
    {
      source = peep_get_free_addr_reg( GAP );
    }
  else
    {
      source = src;
    }
      
  if (!can_corrupt_dest || !is_address_register( hardware_register( dst ) ))
    {
      dest = peep_get_free_addr_reg( source );

      if (dest == GAP)
	{
	  restore_ar = TRUE;

	  dest = RR_AR3;

	  peep_corrupt_addr_reg( RR_AR3 );
	      
	  if (length > 2 * sizeof_int)
	    {
	      ipush( dest );
	    }
	  else
	    {
	      move_register( dest, R_TMP2, FALSE, TRUE );
	    }
	}
    }
  else
    {
      dest = dst;
    }
      
  /*
   * copy whole number of words
   */

  if (length == sizeof_int)
    {
      (void) convert_to_word_alignment( src, source, 0, NULL );
      (void) convert_to_word_alignment( dst, dest,   0, NULL );
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ),
		    examines2( source, R_BASE ),
		    alters2( R_TMP1, RR_ST ) );
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ),
		    examines3( dest, R_TMP1, R_BASE ),
		    alters0() );
    }
  else if (length == sizeof_int * 2)
    {
      RealRegister	TMP;
      

      (void) convert_to_word_alignment( src, source, 0, NULL );
      (void) convert_to_word_alignment( dst, dest,   0, NULL );
      
      /*
       * find a (temporary) register that can be used in a parallel op
       */
      
      TMP = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R6, RR_R7, GAP );

      if (TMP == GAP)
	{
	  /* get first word into TMP */
      
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_INCR_IR0, source, 0 ),
			examines2( source, R_BASE ),
			alters3( R_TMP1, RR_ST, source ) );

	  /* store first word */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_INCR_IR0, dest, 0 ),
			examines3( dest, R_TMP1, R_BASE ),
			alters1( dest ) );

	  /* do second word */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD, source, 1 ),
			examines1( source ),
			alters2( R_TMP1, RR_ST ) );

	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD, dest, 1 ),
			examines2( dest, R_TMP1 ),
			alters0() );
	}
      else
	{
	  /* get first word into TMP */
      
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, TMP, build_indirect( INDIRECT_PRE_INCR_IR0, source, 0 ),
			examines2( source, R_BASE ),
			alters3( TMP, RR_ST, source ) );
	  
	  /*
	   * instruction is:
	   *
	   *    LDI  *<source>++(1), TMP
	   * || STI  TMP, *<dest>++(1)
	   *
	   */
	  
	  outinstr( B_1101 << 28 | B_1010 << 24 |
		   hardware_register( TMP ) << 22 | hardware_register( TMP ) << 16 |
		   build_parallel_indirect( INDIRECT_PRE_INCR_IR0, dest ) << 8 |
		   build_parallel_indirect( INDIRECT_PRE_ADD, source ),
		   examines4( source, TMP, dest, R_BASE ),
		   alters3(   source, TMP, dest ) );
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, TMP, build_indirect( INDIRECT_PRE_ADD, dest, 1 ),
			examines2( dest, R_TMP1 ),
			alters0() );
	}

      peep_note_addr_reg_loaded( source, src, 0, TRUE );
      peep_note_addr_reg_loaded( dest,   dst, 0, TRUE );
    }
  else 
    {
      RealRegister	TMP;
      bool		must_save = FALSE;
      LabelNumber *	l;
      int32		off;
      

      /* get a label for the end of the repeat block */
      
      l = nextlabel();

      /*
       * load repeat count
       *
       * the -2 is because we will have already loaded one word, and the
       * RPTB instruction takes 'number of itterations - 1' as its count
       */
      
      load_integer( RR_RC, length / sizeof_int - 2, FALSE );
      
      /*
       * find a (temporary) register than can be used in a parallel op
       */
      
      TMP = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R6, RR_R7, GAP );
      
#ifdef TARGET_R0_ALWAYS_ZERO
      if (TMP == GAP)
	{
	  TMP = R_ZERO;
	}
#else
      if (TMP == GAP)
	{
	  must_save = TRUE;
	  TMP       = RR_R0;
	  
	  /*
	   * preserve TMP register
	   * This is not as expensive as it might seems,
	   * since the push can be combined with the load
	   * below to form a parallel instruction !
	   *
	   * Also we cannot just copy the register to a temporary register
	   * as all three are used by the RPTB instruction below
	   */

	  ipush( TMP );

	  /*
	   * NB/ we do not need to dpush() this as we are only doing integer
	   * loads and stores below, so we will not upset the exponent.
	   */
	}
#endif /* TARGET_R0_ALWAYS_ZERO */  

      /* prevent the RC loading from being moved over address calculation below */
      
      flush_peepholer( DBG( "copy_memory" ) );
      
      /* convert offsets to word pointers */

      convert_to_word_address( dst, dest );
      
      if (convert_to_word_alignment( src, source, 0, &off ))
	{
	  if (off != 0)
	    {
	      if (fits_in_8_bits_unsigned( off ))
		{
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, TMP,
				build_indirect( INDIRECT_PRE_INCR, source, off ),
				examines1( source ),
				alters3( TMP, RR_ST, source ) );
		}
	      else if (fits_in_8_bits_unsigned( -off ))
		{
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, TMP,
				build_indirect( INDIRECT_PRE_DECR, source, -off ),
				examines1( source ),
				alters3( TMP, RR_ST, source ) );
		}
	      else
		{
		  integer_immediate_op( OP_ADDI, OP_ADDI3, source, source, off, TRUE );

		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, TMP, build_indirect( INDIRECT_REL, source, 0 ),
				examines1( source ),
				alters2( TMP, RR_ST ) );
		}
	    }
	  else
	    {
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, TMP, build_indirect( INDIRECT_REL, source, 0 ),
			    examines1( source ),
			    alters2( TMP, RR_ST ) );
	    }	  
	}
      else
	{
	  /* load first word */

	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, TMP, build_indirect( INDIRECT_PRE_INCR_IR0, source, 0 ),
			examines2( source, R_BASE ),
			alters3( TMP, RR_ST, source ) );
	}

      /* repeat load and save ops */

      /* NB/ do NOT use RPTS as this locks out interrupts */

      outdellabref( (OP_RPTBD << 24) | (-3 & 0x00FFFFFFU),
		   l,
		   LABREF_OFF24,
		   examines1( RR_PC ),
		   alters4( RR_RC, RR_RS, RR_RE, RR_PC ) );
      
      setlabel( l );
      
      /*
       * instruction repeated is:
       *
       *    LDI  *++<source>(1), TMP
       * || STI  TMP, *<dest>++(1)
       *
       */
      
      outinstr( B_1101 << 28 | B_1010 << 24 |
	       hardware_register( TMP ) << 22 | hardware_register( TMP ) << 16 |
	       build_parallel_indirect( INDIRECT_POST_INCR, dest ) << 8 |
	       build_parallel_indirect( INDIRECT_PRE_INCR, source ),
	       examines3( source, TMP, dest ),
	       alters3(   source, TMP, dest ) );

      /* prevent the repeated instruction from being peepholed */
      
      flush_peepholer( DBG( "copy memory" ) );
      
      /* save last word */
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, TMP, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
		    examines2( TMP, dest ),
		    alters1( dest ) );

#ifdef TARGET_R0_ALWAYS_ZERO
      if (TMP == R_ZERO)
	out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, TMP, 0,
		      examines0(), alters1( TMP ) );
#else
      if (must_save)
	{
	  /* restore TMP register */

	  ipop( TMP );
	}
#endif

      peep_note_addr_reg_loaded( source, src, length / sizeof_int - 1, TRUE );
      peep_note_addr_reg_loaded( dest,   dst, length / sizeof_int, TRUE );
    }  

  if (restore_ar)
    {
      if (length > 2 * sizeof_int)
	{
	  ipop( dest );
	}
      else
	{
	  move_register( R_TMP2, dest, FALSE, TRUE );
	}
    }

  return;

} /* copy_memory */


/*
 * start of exported functions
 */


#ifdef ADDRESS_REG_STUFF

/*
 * Returns true iff the register is an address register
 * that can be used by the compiler
 */

bool
target_isaddrreg_( RealRegister r )
{
  /* any register will do since we have to translate all addresses anyway */
  
  return TRUE;
  
} /* target_isaddrreg_ */

#endif /* ADDRESS_REG_STUFF */

/*
 * Returns true iff the value 'n' is suitable for an immediate comparison
 */

bool
immed_cmp( int32 n )
{
  return fits_in_16_bits_signed( n );

} /* immed_cmp */


#ifdef NOT_USED
/*
 * copy the 'which_byte'th byte out of 'source' and
 * merge into 'destination'
 * NB/ This function must produce exactly one instruction
 */

static void
out_merge_byte(
	       int32		which_byte,
	       RealRegister	destination,
	       RealRegister	source )
{
  which_byte &= 0x3;
  
  outinstr( FUNC_LOAD << 28 | OP_MB << 24 | which_byte << 23 | ADDR_MODE_REGISTER << 21 |
	       hardware_register( destination ) | hardware_register( source ),
	   examines2( destination, source ),
	   alters2( destination, RR_ST ) );

  return;
  
} /* out_merge byte */

#endif /* NOT_USED */

/*
 * general function to load or store a byte or half-word
 */

static void
non_word_op(
	    RealRegister	operand,		/* register "containing" operand */
	    RealRegister	address,		/* register "pointing to" operand */
	    int32		offset,			/* offset from address (doubles as a RealRegister) */
	    int32		offset_in_register,	/* non-zero if offset is a RealRegister */
	    int32		is_signed,		/* non-zreo if loading a signed quantity */
	    int32		half_word_op,		/* non-zero if operand is a half-word quantity */
	    int32		is_load )		/* non-zero if the operation is a load op */
{
  RealRegister	addr      = GAP;
  bool		absolute  = FALSE;
  bool		addr_not_loaded = FALSE;

  
  if (is_word_addressed_( address ))
    {
      if (address == R_SP)
	flush_pending_pushes();
      
      if (offset_in_register)
	{
	  addr = peep_get_free_addr_reg( address );
	  
	  /*
	   * copy stack pointer to 'addr' adjusting for byte offsets
	   *
	   * XXX - beware this might overflow if either of the top two
	   *       bits of the stack pointer are set !!!
	   */

	  out_triadic_op( OP_LSH3, addr, address, 2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( address ),
			 alters2( addr, RR_ST ) );

	  /* add in the offset */
      
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, addr, offset,
			examines2( addr, offset ),
			alters2( addr, RR_ST ) );

	  /* indicate that we have an absolute address */

	  absolute   = TRUE;
	}
      else
	{
	  int32		selector;
	  int32		indirect_field;
	  RealRegister	ar;
	  int32		off;
	  bool		biased;
	  int32		op;
	  

	  selector = half_word_op ?
	    (offset & 0x2) >> 1 :
	     offset & 0x3;
	  
	  offset /= sizeof_int;

	  if (offset)
	    {
	      if (!fits_in_8_bits_unsigned( abs( offset ) ))
		{
		  ar = peep_find_loaded_addr_reg( address, &off, &biased );
		  
		  if (!no_peepholing  &&
		      ar     != GAP   &&
		      biased == FALSE &&
		      fits_in_16_bits_signed( offset - off ))
		    {
		      peepf( "eliminated load to temporary address register" );

		      if ((offset - off) == 0)
			{
			  peep_eliminated += 2;
			}
		      else
			{
			  ++peep_eliminated;
		      
			  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, ar, offset - off,
					examines1( ar ),
					alters2( ar, RR_ST ) );
			}
		    }
		  else
		    {
		      if (ar == GAP)
			{
			  ar = peep_get_free_addr_reg( GAP );
			}
		      
		      load_integer( ar, offset, FALSE );

		      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, address,
				examines2( address, ar ),
				alters2( ar, RR_ST ) );
		    }

		  peep_note_addr_reg_loaded( ar, address, offset, FALSE );
		  
		  indirect_field = build_indirect( INDIRECT_REL, ar, 0 );

		  address = ar;
		}
	      else if (offset > 0)
		{
		  indirect_field = build_indirect( INDIRECT_PRE_ADD, address, offset );
		}
	      else
		{
		  indirect_field = build_indirect( INDIRECT_PRE_SUB, address, -offset );
		}
	    }
	  else
	    {
	      indirect_field = build_indirect( INDIRECT_REL, address, 0 );
	    }

	  if (is_load)
	    {	      
	      if (half_word_op)
		{
		  op = is_signed ? OP_LH : OP_LHU;
		}
	      else
		{
		  op = is_signed ? OP_LB : OP_LBU;
		}
	  
	      outinstr( FUNC_LOAD << 28 | op << 24 | selector << 23 | ADDR_MODE_INDIRECT << 21 |
		       hardware_register( operand ) << 16 | indirect_field,
		       examines1( address ),
		       alters2( operand, RR_ST ) );
	    }
	  else
	    {
	      /* get word on stack */
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, indirect_field,
			    examines1( address ),
			    alters2( R_TMP1, RR_ST ) );
	      
	      /* merge in byte or half-word */

	      op = half_word_op ? OP_MH : OP_MB;
	      
	      outinstr( FUNC_LOAD                  << 28 |
		       op                          << 24 |
		       selector                    << 23 |
		       ADDR_MODE_REGISTER          << 21 |
		       hardware_register( R_TMP1 ) << 16 |
		       hardware_register( operand ),
		       examines2( operand, R_TMP1 ),
		       alters2( R_TMP1, RR_ST ) );
	      
	      /* and store back onto the stack */
	      
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, indirect_field,
			    examines2( R_TMP1, address ),
			    alters0() );
	    }
	  
	  return;
	}
    }
  else
    {
      addr = peep_get_free_addr_reg( address );
	  
      if (addr == GAP)
	syserr( syserr_urg );
  
      /* get byte offset into 'addr' */
      
      if (offset_in_register)
	{
	  /* add offset to address and place in temporary register */
	  
	  out_triadic_op( OP_ADDI3, addr, address, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( address, offset ),
			 alters2( addr, RR_ST ) );
	}
      else
	{
	  if (offset == 0)
	    {
	      addr_not_loaded = TRUE;
	    }
	  else if (fits_in_8_bits_signed( offset ))
	    {
	      out_triadic_op( OP_ADDI3, addr, address, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( address ),
			     alters2( addr, RR_ST ) );
	    }
	  else
	    {
	      load_integer( R_TMP1, offset, FALSE );
	      
	      out_triadic_op( OP_ADDI3, addr, address, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			     examines2( address, R_TMP1 ),
			     alters2( addr, RR_ST ) );
	    }
	}
    }

  /*
   *  addr    - byte offset if 'addr_not_loaded' is FALSE
   *  address - byte offset if 'addr_not_loaded' is TRUE
   *  operand - free or value to store
   *  R_TMP1  - free
   *  R_TMP2  - free
   *  R_TMP3  - free
   */
  
  if (is_load)
    {
      if (half_word_op)
	{
	  /*
	   *    addr    - byte offset
	   *    address - byte offset if 'addr_not_loaded' is TRUE
	   *    operand - free 
	   *    R_TMP1  - free
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * loose bottom two bits (byte selector) of byte offset
	   */

	  if (addr_not_loaded)
	    {
	      out_triadic_op( OP_LSH3, addr, address, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			    examines1( address ),
			    alters2( addr, RR_ST ) );
	    }
	  else
	    {
	      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			    examines1( addr ),
			    alters2( addr, RR_ST ) );
	    }

	  /*
	   *    addr    - word offset
	   *    operand - free 
	   *    R_TMP1  - free
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * load half word selector into R_TMP2
	   *
	   * (the carry flag contains the half-word selector, so ...)
	   */
	  
	  conditional_load( Q_LO, ADDR_MODE_IMMEDIATE, R_TMP2,
			   is_signed ? 0 : -16,
			   examines1( RR_ST ),
			   alters1( R_TMP2 ) );
	  
	  conditional_load( Q_HS, ADDR_MODE_IMMEDIATE, R_TMP2,
			   is_signed ? 16 : 0,
			   examines1( RR_ST ),
			   alters1( R_TMP2 ) );
	  /*
	   *    addr    - word offset
	   *    operand - free 
	   *    R_TMP1  - free
	   *    R_TMP2  - half word selector (0, 16 or -16)
	   *    R_TMP3  - free
	   *
	   * shift source half-word up or down and place in destination
	   */

	  out_triadic_op( OP_LSH3,
			 operand,
			 absolute ?
			 build_indirect( INDIRECT_REL, addr, 0 ) :
			 build_indirect( INDIRECT_PRE_INCR_IR0, addr, 0 ),
			 R_TMP2,
			 ADDR_MODE_INDIRECT,
			 ADDR_MODE_REGISTER,
			 absolute ?
			 examines2( R_TMP2, addr ) :
			 examines3( R_TMP2, addr, R_BASE ),
			 alters2( operand, RR_ST ) );

	  /*
	   *    addr    - free
	   *    operand - shifted word at destination
	   *    R_TMP1  - free
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   */
	  
	  if (is_signed)
	    {
	      /*
	       * shift source half-word down and place in destination
	       */
	      
	      out_diadic_op( OP_ASH, ADDR_MODE_IMMEDIATE, operand, -16,
			     examines1( operand ),
			     alters2( operand, RR_ST ) );
	    }
	  else
	    {
	      /*
	       * ensure rest of word is zero
	       *
	       * NB/ this is needed because code like
	       *
	       * int func( char * p ) { if (*p < 10) return 1; return 0 }
	       *
	       * does not mask result of load
	       */
	      
	      out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, operand, 0xFFFF,
			    examines1( operand ),
			    alters2( operand, RR_ST ) );
	    }
	}
      else
	{
	  /*
	   *    addr    - byte offset if 'addr_not_loaded' is FALSE
	   *    address - byte offset if 'addr_not_loaded' is TRUE
	   *    operand - free 
	   *    R_TMP1  - free
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * loose bottom two bits (byte selector) of offset AND
	   * save non-word selector of address into R_TMP2
	   */

	  if (addr_not_loaded)
	    {
	      out_triadic_op( OP_LSH3, addr, address, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			    examines1( address ),
			    alters2( addr, RR_ST ) );
	      
	      out_triadic_op( OP_AND3, R_TMP2, address,
			     0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( address ),
			     alters2( R_TMP2, RR_ST ) );	  
	    }
	  else
	    {
	      out_triadic_op( OP_AND3, R_TMP2, addr,
			     0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( addr ),
			     alters2( R_TMP2, RR_ST ) );
	  
	      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			    examines1( addr ),
			    alters2( addr, RR_ST ) );
	    }

	  /*
	   *    addr    - word offset
	   *    operand - free
	   *    R_TMP1  - free
	   *    R_TMP2  - byte selector (0, 1, 2 or 3)
	   *    R_TMP3  - free
	   *
	   * convert byte selector to negated bit_position
	   * NB/ done before load to help avoid pipeline conflicts
	   */
	      
	  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP2, -8,
			examines1( R_TMP2 ),
			alters2( R_TMP2, RR_ST ) );
	      
	  /*
	   *    addr    - word offset
	   *    operand - free
	   *    R_TMP1  - free
	   *    R_TMP2  - byte selector (0, -8, -16 or -24)
	   *    R_TMP3  - free
	   *
	   * shift source word to correct source alignment and place in destination or R_TMP3
	   */
	      
	  out_triadic_op( OP_LSH3,
			 is_signed ? R_TMP3 : operand,
			 absolute ?
			 build_indirect( INDIRECT_REL, addr, 0 ) :
			 build_indirect( INDIRECT_PRE_INCR_IR0, addr, 0 ),
			 R_TMP2,
			 ADDR_MODE_INDIRECT,
			 ADDR_MODE_REGISTER,
			 absolute ?
			 examines2( addr, R_TMP2 ) :
			 examines3( addr, R_TMP2, R_BASE ),
			 absolute ?
			 alters2( is_signed ? R_TMP3 : operand, RR_ST ) :
			 alters3( is_signed ? R_TMP3 : operand, RR_ST, addr ) );

	  if (is_signed)
	    {
	      /*
	       *    addr    - free
	       *    operand - free
	       *    R_TMP1  - free
	       *    R_TMP2  - free
	       *    R_TMP3  - part of word at destination
	       *
	       * load bottom byte from R_TMP3 into destination, sign extending
	       */
	      
	      outinstr( (FUNC_LOAD << 28) | (OP_LB << 24) | (0 << 23) | (ADDR_MODE_REGISTER << 21) |
		       hardware_register( operand ) << 16 | hardware_register( R_TMP3 ),
		       examines1( R_TMP3 ),
		       alters2( operand, RR_ST ) );
	    }
	  else
	    {
	      /*
	       *    addr    - free
	       *    operand - part of word at destination
	       *    R_TMP1  - free
	       *    R_TMP2  - free
	       *    R_TMP3  - free
	       *
	       * ensure rest of word is zero
	       *
	       * NB/ this is needed because code like
	       *
	       * int func( char * p ) { if (*p < 10) return 1; return 0 }
	       *
	       * does not mask result of load
	       */
	      
	      out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, operand, 0xFF,
			    examines1( operand ),
			    alters2( operand, RR_ST ) );
	    }
	}
    }
  else /* non-word store */
    {
      if (half_word_op)
	{
	  /*
	   *    addr    - byte offset if 'addr_not_loaded' is FALSE
	   *    address - byte offset if 'addr_not_loaded' is TRUE
	   *    operand - value to store
	   *    R_TMP1  - free
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * loose bottom two bits of byte offset (ie convert to word offset)
	   * NB/ This is done 6 instructions before the load to avoid pipeline conflicts
	   */

	  if (addr_not_loaded)
	    {
	      out_triadic_op( OP_LSH3, addr, address, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			    examines1( address ),
			    alters2( addr, RR_ST ) );
	    }
	  else
	    {
	      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			    examines1( addr ),
			    alters2( addr, RR_ST ) );
	    }

	  /*
	   *    addr    - word offset
	   *    operand - value to store
	   *    R_TMP1  - free
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * load word at destination into R_TMP1, without corrupting carry flag
	   */

	  if (absolute)
	    {
	      conditional_load( Q_AL, ADDR_MODE_INDIRECT, R_TMP1,
			       build_indirect( INDIRECT_REL, addr, 0 ),
			       examines1( addr ),
			       alters1( R_TMP1 ) );
	    }
	  else
	    {
	      conditional_load( Q_AL, ADDR_MODE_INDIRECT, R_TMP1,
			       build_indirect( INDIRECT_PRE_INCR_IR0, addr, 0 ),
			       examines2( addr, R_BASE ),
			       alters2( R_TMP1, addr ) );
	    }
	  
	  /*
	   *    addr    - word address
	   *    operand - value to store
	   *    R_TMP1  - word at destination
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * copy destination word into R_TMP2, without corrupting carry flag
	   */

	  conditional_load( Q_AL, ADDR_MODE_REGISTER, R_TMP2, R_TMP1,
			   examines1( R_TMP1 ),
			   alters1( R_TMP2 ) );
	  
	  /*
	   *    addr    - word address
	   *    operand - value to store
	   *    R_TMP1  - word at destination
	   *    R_TMP2  - word at destination
	   *    R_TMP3  - free
	   *
	   * merge source value into bottom half of destination word (does not affect carry flag)
	   */

	  outinstr( (FUNC_LOAD << 28) | (OP_MH << 24) | (0 << 23) | (ADDR_MODE_REGISTER << 21) |
		   hardware_register( R_TMP1 ) << 16 | hardware_register( operand ),
		   examines2( R_TMP1, operand ),
		   alters2( R_TMP1, RR_ST ) );
	  
	  /*
	   *    addr    - word address
	   *    operand - value to store
	   *    R_TMP1  - merged source value & top half of word at destination
	   *    R_TMP2  - word at destination
	   *    R_TMP3  - free
	   *
	   * merge source value into top half of destination word (does not affect carry flag)
	   */

	  outinstr( (FUNC_LOAD << 28) | (OP_MH << 24) | (1 << 23) | (ADDR_MODE_REGISTER << 21) |
		   hardware_register( R_TMP2 ) << 16 | hardware_register( operand ),
		   examines2( R_TMP1, operand ),
		   alters2( R_TMP2, RR_ST ) );
	  
	  /*
	   *    addr    - word address
	   *    operand - free (not corruptible)
	   *    R_TMP1  - merged source value & top    half of word at destination
	   *    R_TMP2  - merged source value & bottom half of word at destination
	   *    R_TMP3  - free
	   *
	   * select the correct value to store
	   *
	   * (The LSH above left the half-word selector in the carry flag, and none
	   *  of the other instructions have affected this flag).
	   */

	  conditional_load( Q_LO, ADDR_MODE_REGISTER, R_TMP1, R_TMP2,
			   examines2( RR_ST, R_TMP2 ),
			   alters1( R_TMP1 ) );
	  
	  /*
	   *    addr    - word address
	   *    operand - free (not corruptible)
	   *    R_TMP1  - merged value to store
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * store the value back into memory
	   */

	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, addr, 0 ),
			examines2( R_TMP1, addr ),
			alters0() );
	}
      else
	{
	  RealRegister	dest;


	  if (addr_not_loaded)
	    {
	      /*
	       *    address - byte offset
	       *    addr    - free
	       *    operand - value to store
	       *    R_TMP1  - free
	       *    R_TMP2  - free
	       *    R_TMP3  - free
	       *
	       * convert byte offset to word offset
	       */

	      out_triadic_op( OP_LSH3, addr, address, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( address ),
			     alters2( addr, RR_ST ) );
	      
	      /*
	       *    address - byte offset
	       *    addr    - word offset
	       *    operand - value to store
	       *    R_TMP1  - byte selector (0, 1, 2, or 3)
	       *    R_TMP2  - free
	       *    R_TMP3  - free
	       *
	       * save byte selector of address into R_TMP1
	       */
	  
	      out_triadic_op( OP_AND3, R_TMP1, address, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( address ),
			     alters2( R_TMP1, RR_ST ) );	  
	    }
	  else
	    {
	      /*
	       *    addr    - byte offset
	       *    operand - value to store
	       *    R_TMP1  - free
	       *    R_TMP2  - free
	       *    R_TMP3  - free
	       *
	       * save byte selector of address into R_TMP1
	       */
	  
	      out_triadic_op( OP_AND3, R_TMP1, addr, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( addr ),
			     alters2( R_TMP1, RR_ST ) );
	  
	      /*
	       *    addr    - byte offset
	       *    operand - value to store
	       *    R_TMP1  - byte selector (0, 1, 2, or 3)
	       *    R_TMP2  - free
	       *    R_TMP3  - free
	       *
	       * convert byte offset to word offset
	       */
	  
	      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			    examines1( addr ),
			    alters2( addr, RR_ST ) );
	    }

	  /*
	   *    addr    - word offset
	   *    operand - value to store
	   *    R_TMP1  - byte selector (0, 1, 2, or 3)
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * convert byte selector to bit-position selector in R_TMP2
	   */
	  
	  out_triadic_op( OP_MPYI3, R_TMP2, R_TMP1, 8, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( R_TMP1 ),
			 alters2( R_TMP2, RR_ST ) );
	  
	  /*
	   *    addr    - word offset
	   *    operand - value to store
	   *    R_TMP1  - free
	   *    R_TMP2  - bit-position selector (0, 8, 16 or 24)
	   *    R_TMP1  - free
	   *
	   * shift source value to correct alignment and place in R_TMP3
	   */
	  
	  out_triadic_op( OP_LSH3, R_TMP3, operand, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( operand, R_TMP2 ),
			 alters2( R_TMP3, RR_ST ) );
	  
	  /*
	   *    addr    - word offset
	   *    operand - free (might not be corruptible)
	   *    R_TMP1  - free
	   *    R_TMP2  - bit-position selector (0, 8, 16 or 24)
	   *    R_TMP3  - shifted source value
	   *
	   * load mask into R_TMP1
	   */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFF,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );
	  
	  /*
	   *    addr    - word offset
	   *    operand - free (might not be corruptible)
	   *    R_TMP1  - 0x000000FF
	   *    R_TMP2  - bit-position selector (0, 8, 16 or 24)
	   *    R_TMP3  - shifted source value
	   *
	   * shift mask up if necessary
	   */
	  
	  out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, R_TMP1, R_TMP2,
			examines2( R_TMP2, R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );
	  
	  /*
	   *    addr    - word offset
	   *    operand - free (might not be corruptible)
	   *    R_TMP1  - byte mask (0x000000FF, 0x0000FF00, 0x00FF0000 or 0xFF000000)       
	   *    R_TMP2  - free
	   *    R_TMP3  - shifted source value
	   *
	   * get word at destination into R_TMP2 with unwanted byte masked out
	   */

	  if (death & regbit( operand ))
	    {
	      dest = operand;
	    }
	  else
	    {
	      dest = R_TMP2;
	    }

	  if (absolute)
	    {
	      out_triadic_op( OP_ANDN3, dest, build_indirect( INDIRECT_REL, addr, 0 ),
			     R_TMP1, ADDR_MODE_INDIRECT, ADDR_MODE_REGISTER,
			     examines3( dest, R_TMP1, addr ),
			     alters2( dest, RR_ST ) );
	    }
	  else
	    {
	      out_triadic_op( OP_ANDN3, dest, build_indirect( INDIRECT_PRE_INCR_IR0, addr, 0 ),
			     R_TMP1, ADDR_MODE_INDIRECT, ADDR_MODE_REGISTER,
			     examines4( dest, R_TMP1, addr, R_BASE ),
			     alters3( dest, RR_ST, addr ) );
	    }
	  
	  /*
	   *    addr    - word address
	   *    R_TMP1  - byte mask (0x000000FF, 0x0000FF00, 0x00FF0000 or 0xFF000000)       
	   *    dest    - other part of word at destination
	   *    R_TMP3  - shifted source value
	   *
	   * mask out all but the byte to be stored
	   */
	  
	  out_diadic_op( OP_AND, ADDR_MODE_REGISTER, R_TMP3, R_TMP1,
			examines2( R_TMP1, R_TMP3 ),
			alters2( R_TMP3, RR_ST ) );
	  
	  /*
	   *    addr    - word address
	   *    R_TMP1  - free
	   *    dest    - other part of word at destination
	   *    R_TMP3  - shifted and masked source value
	   *
	   * OR in the byte
	   */
	  
	  out_diadic_op( OP_OR, ADDR_MODE_REGISTER, dest, R_TMP3,
			examines2( dest, R_TMP3 ),
			alters2( dest, RR_ST ) );
	  
	  /*
	   *    addr    - word address
	   *    R_TMP1  - free
	   *    dest    - source part word plus destination part word
	   *    R_TMP3  - free
	   *
	   * and store word back in destination
	   */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, addr, 0 ),
			examines2( dest, addr ),
			alters0() );
	}
    }

  if (!offset_in_register)
    {
      peep_note_addr_reg_loaded( addr, address, offset / sizeof_int, TRUE );
    }
  
  if (is_load)
    {
      peep_forget_about( operand );
    }
      
  return;
  
} /* non_word_op */


/*
 * convert an FP value into an integer value
 */

static void
fix(
    RealRegister	src,		/* register containing FP value  */
    RealRegister	dst,		/* register to contain INT value */
    bool		is_signed )	/* non-0 if 'dst' is signed      */
{
#ifdef DEBUG
  if (!is_float( src ))
    {
      syserr( syserr_non_float_source );
    }      
#endif

  if (is_signed)
    {
      bool		must_save = FALSE;
      RealRegister	tmp;


      /* convert the number to integer format */
      
      out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, dst, src,
		    examines1( src ),
		    alters2( dst, RR_ST ) );
	      
      /*
       * ANSI spec says that J_FIX must truncate floating point
       * numbers, but the OP_FIX rounds towards negative infinity
       * so ....
       */

      /* get hold of a free floating point temporary register */
      
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
      tmp = get_free_register( RR_R1, RR_R2, RR_R3, RR_R8, RR_R9, RR_R10, GAP );
      
      /* if we must then save a register on the stack */
      
      if (tmp == GAP)
	{
	  tmp = R_LR;
	  
	  if ((saved_ivars & regbit( R_LR )) == 0 ||
	      usedmaskvec.map[ 0 ] & regbit( R_LR ))	/* link register being used as temporary */
	    {
	      must_save = TRUE;

	      dpush( tmp );
	    }
	}
#else
      tmp = get_free_register( RR_R1, RR_R2, RR_R3, RR_R10, GAP );
      
      /*
       * if we must then save a register in temporary.
       * Note/ we have chosen an FP reg that is only used to hold INTs
       */
      
      if (tmp == GAP)
	{
	  tmp = R_LR;
	  
	  if ((saved_ivars & regbit( R_LR )) == 0 ||
	      usedmaskvec.map[ 0 ] & regbit( R_LR ))	/* link register being used as temporary */
	    {	
	      must_save = TRUE;
	  
	      move_register( tmp, R_TMP1, FALSE, TRUE );
	    }
	}
#endif
      /* negate original number */
      
      out_diadic_op( OP_NEGF, ADDR_MODE_REGISTER, tmp, src,
		    examines1( src ),
		    alters2( tmp, RR_ST ) );
      
      /* fix this number */
      
      out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, tmp, tmp,
		    examines1( tmp ),
		    alters2( tmp, RR_ST ) );
      
      /* negate the result */
      
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, tmp, tmp,
		    examines1( tmp ),
		    alters2( tmp, RR_ST ) );
      
      /* if the result is negative, then so was the original */
      
      conditional_load( Q_LE, ADDR_MODE_REGISTER, dst, tmp,
		       examines2( tmp, RR_ST ),
		       alters1( dst ) );
      
      /* restore register if necessary */
      
      if (must_save)
	{
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
	  dpop( tmp );
#else
	  move_register( R_TMP1, tmp, FALSE, TRUE );
#endif
	}
    }
  else
    {
#ifdef TARGET_LACKS_UNSIGNED_FIX
      syserr( syserr_no_unsigned_fix );
#else
      bool		must_save = FALSE;
      RealRegister	tmp;
      LabelNumber *	l;
      
      
      /*
       * ANSI spec does not say what to do if the FP value is < 0.0
       * All the compilers I have tested so far just return the bit
       * pattern for the negative number, ie
       *    ((unsigned int) -2.0) = 0xfffffffe
       * which I consider to be wrong.  I would expect rounding to 0.0, ie
       *    ((unsigned int) -2.0) = 0x00000000
       *
       * The real problem, however is when the FP number does not fit
       * in a signed int, but it would fit in an unsigned int.  The
       * compiler has code to cope with this, but I am hoping that I
       * will be able to produce better code here.
       */
      
      /* convert the number */
      
      out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, dst, src,
		    examines1( src ),
		    alters2( dst, RR_ST ) );
      
#ifdef UNSIGNED_FIX_GIVES_0_FOR_NEGATIVE
      conditional_load( Q_LT, ADDR_MODE_IMMEDIATE, dst, 0,
		       examines1( RR_ST ),
		       alters1( dst ) );
#endif
      if (src == dst)
	{
	  /* get hold of a free floating point register */
	  
	  tmp = get_free_register( RR_R1, RR_R2, RR_R3, RR_R6, RR_R7, RR_R10, GAP );
	}
      else
	{
	  tmp = dst;
	}
      
      l = nextlabel();
      
      /* if integer overflow did not occur, then skip the next bit */
      
      conditional_branch_to( C_NV, l );
      
      /* if we must then save a register on the stack */
      
      if (tmp == GAP)
	{
	  tmp = R_LR;
	  
	  if ((saved_ivars & regbit( R_LR )) == 0 ||
	      usedmaskvec.map[ 0 ] & regbit( R_LR ))	/* link register being used as temporary */	      
	    {	
	      must_save = TRUE;

#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS	      
	      dpush( tmp );
#else
	      move_register( tmp, R_TMP2, FALSE, TRUE );
#endif
	    }
	}
      
      /* load 2e31 */
      
      load_integer( R_TMP1, 0x1f000000U, FALSE );
      
      /* save on stack as an integer */
      
      ipush( R_TMP1 );
      
      /* pop the value off the stack as a float */
      
      fpop( tmp );
      
      /* subtract 2^31 from the original number */
      
      out_triadic_op( OP_SUBF3, dst, src, tmp, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( src, tmp ),
		     alters2( dst, RR_ST ) );
      
      /* convert the number again */
      
      out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, dst, dst,
		    examines1( dst ),
		    alters2( dst, RR_ST ) );
      
      /* then add back in 2^31 */
      
      load_integer( R_TMP1, 0x80000000U, FALSE );
      
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dst, R_TMP1,
		    examines2( dst, R_TMP1 ),
		    alters2( dst, RR_ST ) );
      
      if (must_save)
	{
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
	  dpop( tmp );
#else
	  move_register( R_TMP2, tmp, FALSE, TRUE );
#endif
	}
      
      /* prevent these instructions from being peepholed */
      
      flush_peepholer( DBG( "unsigned fix" ) );
      
      /* target the end of the branch */
      
      setlabel( l );
#endif /* ! TARGET_LACKS_UNSIGNED_FIX */
    }

  peep_forget_about( dst );
  
  return;
  
} /* fix */
  


#ifdef TARGET_HAS_DEBUGGER

/*
 * macros for storing and retrieving a register from a known location in memory
 */

int32 saved_regs_offsets[ MAXREGNUMBER + 1 ] =
  {
    0,	/* R0  -  0 - integer */
    1,  /* R1  -  1 - integer */
    2,  /* R2  -  2 - integer */
    3,  /* R3  -  3 - integer */
    4,  /* R4  -  4 - FP      */
    6,  /* R5  -  5 - FP      */
    8,  /* R6  -  6 - FP      */
   10,  /* R7  -  7 - FP      */
   12,  /* DP  -  8 - integer */
   13,  /* BK  -  9 - integer */
   14,  /* R8  - 10 - integer */
   15,  /* R9  - 11 - integer */
   16,  /* R10 - 12 - integer */
   17,  /* AR0 - 13 - address */
   18,  /* AR1 - 14 - address */
   19,  /* AR2 - 15 - address */
   20,  /* AR3 - 16 - address */
   21,  /* R11 - 17 - integer */
   22,  /* AR4 - 18 - address */
   23,  /* AR5 - 19 - address */
   24,  /* AR6 - 20 - address */
   25,  /* AR7 - 21 - address */
   26,  /* IR0 - 22 - index   */
   27,  /* IR1 - 23 - index   */
   28,  /* SP  - 24 - stack   */
   29,  /* ST  - 25 - status  */
   30,  /* RS  - 26 - integer */
   31,  /* RE  - 27 - integer */
   32   /* RC  - 28 - integer */
  };


#define save_reg( r )	\
  if (usedmaskvec.map[ 0 ] & (int32) regbit( r )) \
    out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, r, \
		  build_indirect( INDIRECT_PRE_ADD, R_ATMP, saved_regs_offsets[ r ] ), \
		  examines2( r, R_ATMP ), \
		  alters0() )

#define restore_reg( r )	\
  if (usedmaskvec.map[ 0 ] & (int32) regbit( r )) \
    out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r, \
		  build_indirect( INDIRECT_PRE_ADD, R_ATMP, saved_regs_offsets[ r ] ), \
		  examines1( R_ATMP ), \
		  alters1( r ) )

#define save_freg( r )	\
  if (usedmaskvec.map[ 0 ] & (int32) regbit( r )) \
  { \
    out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, r, \
		  build_indirect( INDIRECT_PRE_ADD, R_ATMP, saved_regs_offsets[ r ] ), \
		  examines2( r, R_ATMP ), \
		  alters0() ); \
    \
    out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, r, \
		  build_indirect( INDIRECT_PRE_ADD, R_ATMP, saved_regs_offsets[ r ] + 1 ), \
		  examines2( r, R_ATMP ), \
		  alters0() ); \
  }


#define restore_freg( r ) \
  if (usedmaskvec.map[ 0 ] & (int32) regbit( r )) \
  { \
    out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, r, \
		  build_indirect( INDIRECT_PRE_ADD, R_ATMP, saved_regs_offsets[ r ] ), \
		  examines1( R_ATMP ), \
		  alters1( r ) ); \
    \
    out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r, \
		  build_indirect( INDIRECT_PRE_ADD, R_ATMP, saved_regs_offsets[ r ] + 1 ), \
		  examines1( R_ATMP ), \
		  alters1( r ) ); \
    }

static void
do_notify_command(
		  int32		linenumber,
		  char *	filename )
{
  LabelNumber *		label;
  
  
  if (debugging( DEBUG_Q ))
    cc_msg( "debugger: generating _notify_command of: %s at line %ld\n", filename, linenumber );

  if (saved_regs == NULL)
    {
      syserr( syserr_init_failed );
    }  
  
  flush_peepholer( DBG( "notify_command" ) );

  /*
   * save registers into saved_regs structure of debugger library
   */

  peep_corrupt_addr_reg( R_ATMP );
  
  /* get address of module table into temporary */

  move_register( R_MT, R_ATMP, FALSE, TRUE );

  /* add in the offset of the module containing 'saved_regs' */
	  
  peep_xref( X_DataModule, saved_regs );
  
  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, 0,
		examines1( R_ATMP ),
		alters2( R_ATMP, RR_ST ) );
  
  /* get the address of the module's function table or data slots */
  
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ATMP,
		build_indirect( INDIRECT_REL, R_ATMP, 0 ),
		examines1( R_ATMP ),
		alters2( R_ATMP, RR_ST ) );

  /* get high part of data offset */
  
  peep_xref( X_DataSymbHi, saved_regs );
  
  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
		examines0(),
		alters1( R_TMP1 ) );
  
  /* load R_TMP1 with the low part offset of 'name' into the data slots or function table */
	      
  peep_xref( X_DataSymbLo, saved_regs );
  
  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
		examines1( R_TMP1 ),
		alters1( R_TMP1 ) );	/* XXX - hide alteration of ST */

  /* and add R_TMP1 into temporary */
	      
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_TMP1,
		examines2( R_ATMP, R_TMP1 ),
		alters2( R_ATMP, RR_ST ) );

  /* convert */
  
  convert_to_word_address( R_ATMP, R_ATMP );
  
  /* save registers into register array in KNOWN order */

  save_reg( RR_R0  );
  save_reg( RR_R1  );
  save_reg( RR_R2  );
  save_reg( RR_R3  );
  save_freg( RR_R4  );
  save_freg( RR_R5  );
  save_freg( RR_R6  );
  save_freg( RR_R7  );
  save_reg( RR_R8  );
  save_reg( RR_R9  );
  save_reg( RR_R10 );
  save_reg( RR_R11 );
  save_reg( RR_BK  );
  save_reg( RR_DP  );
  save_reg( RR_AR0 );
  save_reg( RR_AR1 );
  save_reg( RR_AR2 );
  save_reg( RR_AR3 );

  /* save address register */

  ipush( R_V1 );
  move_register( R_ATMP, R_V1, FALSE, TRUE );
  
  /* second argument: the address of the SourceInfo structure (as word pointer) */
  
  label = debugger_filenamelabel( filename );

  /*
   * put PC of next instruction into R_LR
   *
   * (There is no need to save R_LR, as it will
   *  have been pushed onto the stack at the start
   *  of the function.)
   */
  
  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

  /* protect the following three instructions against LAJs abd BRs */
  
  peep_protect_pc = 3;
  
  /*
   * add in offset of the SourceInfo structure
   */
      
  if (lab_isset_( label ))
    {
      int32	off = (label->u.defn) & 0x7fffffffU;


      flush_peepholer( DBG( "calculating position" ) );
      
      off = (off - codep - codebase) / sizeof_int - 3;

      load_integer( R_A1 + 1, off, FALSE );
    }
  else
    {
      /*
       * NB/ beware of assumption that the structure is within 16
       * (signed) bits of this instruction - this may not be true
       */
      
      peep_fref( label, LABREF_LIT16 ); 
      
      out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_A1 + 1, -3,
		    examines0(),
		    alters2( R_A1 + 1, RR_ST ) );
    }      

  /* add in value in link register */
      
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_A1 + 1, R_LR,
		examines1( R_LR ),
		alters2( R_A1 + 1, RR_ST ) );
      
  /* first argument: the line number */
  
  load_integer( R_A1, linenumber, FALSE );

  /* finally call the _notify_command function */
  
  call( _notify_command, FALSE );

  /* restore saved registers */

  move_register( R_V1, R_ATMP, FALSE, TRUE );
  ipop( R_V1 );
  
  restore_reg( RR_R0  );
  restore_reg( RR_R1  );
  restore_reg( RR_R2  );
  restore_reg( RR_R3  );
  restore_freg( RR_R4  );
  restore_freg( RR_R5  );
  restore_freg( RR_R6  );
  restore_freg( RR_R7  );
  restore_reg( RR_R8  );
  restore_reg( RR_R9  );
  restore_reg( RR_R10 );
  restore_reg( RR_R11 );
  restore_reg( RR_AR0 );
  restore_reg( RR_AR0 );
  restore_reg( RR_AR1 );
  restore_reg( RR_AR2 );
  restore_reg( RR_AR3 );
  restore_reg( RR_BK  );
  restore_reg( RR_DP  );
  
  /* finished */
  
  return;
  
} /* do_notifty_command */

#endif /* TARGET_HAS_DEBUGGER */


#ifndef TARGET_LACKS_FP_DIVIDE

static void
fp_reg_divide(
	      RealRegister	dest,
	      RealRegister	top,
	      RealRegister	bottom,
	      bool		is_double )
{
  RealRegister	tmp1;
  RealRegister	tmp2;
  bool		must_restore_tmp1 = FALSE;
  bool		must_restore_tmp2 = FALSE;
  
  
  /* dest = top / bottom */
  
  if ((saved_ivars & regbit( R_LR )) &&
      (usedmaskvec.map[ 0 ] & regbit( R_LR )) == 0)	/* link register being used as temporary */
    {
      /* use R_LR as an FP temporary ! */
      
      tmp1 = R_LR;
    }
  else
    {
      /* find a free (integer) register */
      
      tmp1 = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R10, GAP );
      
      if (tmp1 == GAP)
	{
	  tmp1 = RR_R10;
	  
	  must_restore_tmp1 = TRUE;
	  
	  move_register( tmp1, R_TMP1, FALSE, TRUE );
	}
    }
  
  if (dest == top || dest == bottom)
    {
      int32	oldmask = usedmaskvec.map[ 0 ];
      
      
      /* prevent 'tmp1' register from being selected */
      
      usedmaskvec.map[ 0 ] |= regbit( tmp1 );
      
      tmp2 = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R10, GAP );
      
      usedmaskvec.map[ 0 ] = oldmask;
      
      if (tmp2 == GAP)
	{
	  tmp2 = RR_R9;
	  
	  must_restore_tmp2 = TRUE;
	  
	  move_register( tmp2, R_TMP2, FALSE, TRUE );
	}
    }
  else
    {
      /* use destination as a temporary register */
      
      tmp2 = dest;
    }
  
  out_diadic_op( OP_RCPF, ADDR_MODE_REGISTER, tmp1, bottom,
		examines1( bottom ),
		alters2( tmp1, RR_ST ) );
  
  out_triadic_op( OP_MPYF3, tmp2, tmp1, bottom, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		 examines2( tmp1, bottom ),
		 alters2( tmp2, RR_ST ) );
  
  out_diadic_op( OP_SUBRF, ADDR_MODE_IMMEDIATE, tmp2, 0x1000,	/* 0x1000 = 2.0 */
		examines1( tmp2 ),
		alters2( tmp2, RR_ST ) );
  
  out_diadic_op( OP_MPYF, ADDR_MODE_REGISTER, tmp1, tmp2,
		examines2( tmp1, tmp2 ),
		alters2( tmp1, RR_ST ) );
  
  /* repeat last three instruction */
  
  out_triadic_op( OP_MPYF3, tmp2, tmp1, bottom, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		 examines2( tmp1, bottom ),
		 alters2( tmp2, RR_ST ) );
  
  out_diadic_op( OP_SUBRF, ADDR_MODE_IMMEDIATE, tmp2, 0x1000,	/* 0x1000 = 2.0 */
		examines1( tmp2 ),
		alters2( tmp2, RR_ST ) );
  
  out_diadic_op( OP_MPYF, ADDR_MODE_REGISTER, tmp1, tmp2,
		examines2( tmp1, tmp2 ),
		alters2( tmp1, RR_ST ) );

  if (!fast_FP)
    {
      if (is_double)
	{
	  /* for double precision we require a final loop to get the last bit right */
	  
	  out_triadic_op( OP_MPYF3, tmp2, tmp1, bottom, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( tmp1, bottom ),
			 alters2( tmp2, RR_ST ) );
  
	  out_diadic_op( OP_SUBRF, ADDR_MODE_IMMEDIATE, tmp2, 0x0000,	/* 0x0000 = 1.0 */
			examines1( tmp2 ),
			alters2( tmp2, RR_ST ) );
  
	  out_diadic_op( OP_MPYF, ADDR_MODE_REGISTER, tmp2, tmp1,
			examines2( tmp1, tmp2 ),
			alters2( tmp2, RR_ST ) );
      
	  out_diadic_op( OP_ADDF, ADDR_MODE_REGISTER, tmp1, tmp2,
			examines2( tmp1, tmp2 ),
			alters2( tmp2, RR_ST ) );
	}
      else
	{
	  out_diadic_op( OP_RND, ADDR_MODE_REGISTER, tmp1, tmp1,
			examines1( tmp1 ),
			alters2( tmp1, RR_ST ) );	  
	}
    }  
  
  /* finally multiply and place in destination */
  
  out_triadic_op( OP_MPYF3, dest, tmp1, top, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		 examines2( tmp1, top ),
		 alters2( dest, RR_ST ) );

  if (!is_double && !fast_FP)
    {
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, dest, dest,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );	  
    }
  
  if (must_restore_tmp2)
    {
      move_register( R_TMP2, tmp2, FALSE, TRUE );
    }
  
  if (must_restore_tmp1)
    {
      move_register( R_TMP1, tmp1, FALSE, TRUE );
    }
  
  return;
	
} /* fp_reg_divide */


static void
fp_imm_divide(
	      RealRegister	dest,
	      RealRegister	top,
	      FloatCon *	fc,
	      bool		is_double )
{
  bool		must_restore_bottom = FALSE;
  RealRegister	bottom;
  int32		map;
  int32		i;
  
  
  /* dest = top / fc */
  
  /* we must load the constant into an FP register */

  map = usedmaskvec.map[ 0 ];

#if NFLTTEMPREGS > 0
  for (i = NFLTTEMPREGS; i--;)
    {
      if ((map & regbit( R_FT1 + i )) == 0)
	break;
    }
  
  if (i < 0)
#endif  
    {
      for (i = NFLTVARREGS; i--;)
	{
	  if ((map & regbit( R_FV1 + i )) == 0)
	    break;
	}      

      if (i < 0)
	{
#if NFLTTEMPREGS > 0
	  if (dest != R_FT1)
	    {
	      if (top != R_FT1)
		{
		  bottom = R_FT1;
		}
	      else if (dest != R_FV1)
		{
		  bottom = R_FV1;
		}
	      else
		{
#if NFLTVARREGS < 2
#error Not Enought FP Var Regs
#endif		  
		  bottom = R_FV1 + 1;
		}
	    }
	  else
#endif /* NFLTTEMPREGS > 0 */
	    if (top != R_FV1)
	    {
	      bottom = R_FV1;
	    }
	  else
	    {
#if NFLTVARREGS < 2
#error Not Enought FP Var Regs
#endif
	      bottom = R_FV1 + 1;
	    }
	  
	  dpush( bottom );
	  
	  must_restore_bottom = TRUE;
	}
      else
	{
	  bottom = R_FV1 + i;

	  if ((saved_fvars & regbit( bottom )) == 0)
	    {
	      dpush( bottom );
	      
	      must_restore_bottom = TRUE;
	    }
	}
    }
#if NFLTTEMPREGS > 0
  else
    {
      bottom = R_FT1 + i;

      augment_RealRegSet( &regmaskvec, bottom );
    }
#endif
  
  load_float( bottom, fc, is_double );
  
  fp_reg_divide( dest, top, bottom, is_double );

  if (must_restore_bottom)
    {
      dpop( bottom );
    }
  
  return;
  
} /* fp_imm_divide */

#endif /* ! TARGET_LACKS_FP_DIVIDE */


/*
 * XXX - comment by NC
 *
 * This is the biggy.
 * This function is called by the code generator when it wants
 * to emit an instruction.  It is passed in the generic op code
 * 'op', two virtual source registers 'vr2' and 'vm', and a
 * virtual destination register 'vr1'
 *
 * performs 'vr1' = 'vr2' 'op' 'm'
 */

void
show_instruction(
		 J_OPCODE	op,
		 VRegInt	vr1,
		 VRegInt	vr2,
		 VRegInt	vm )
{
#ifdef TARGET_HAS_COND_EXEC
  static int32		pending_condition = Q_AL;
#endif
  int32			m   = vm.i;
  RealRegister		r1r = vr1.r;
  RealRegister		r2r = vr2.r;
  RealRegister		mr  = m;
  int32			opm;
  int32			dead;
  

  /* The types of the arguments here are rather unsatisfactory - in        */
  /* particular the last one (m) is really a big union.                    */
  
  /*
   * Is this the way to do it?  Concern over code quality - the compiler
   * clearly needs to know how to put union values of size 4 in registers.
   *  union { Symstr *sym; int32 umint; } um;
   *  um.umint = m;
   */

  if (uses_r1( op ))
    {
      if (r1r >= MAXREGNUMBER)
	{
	  syserr( syserr_r1r, (long)r1r );
	}
    }

  if (uses_r2( op ))
    {
      if (r2r >= MAXREGNUMBER)
	{
	  syserr( syserr_r2r, (long)r2r );
	}
    }

  if (uses_r3( op ))
    {
        if (mr >= MAXREGNUMBER)
	  {
	    syserr( syserr_mr, (long)mr );
	  }
      }
  
  if (debugging( DEBUG_CG ))
    {
      int r1dead = (op & J_DEAD_R1 ? '#' : ' ');
      int r2dead = (op & J_DEAD_R2 ? '#' : ' ');
      int r3dead = (op & J_DEAD_R3 ? '#' : ' ');

      
      cc_msg( "GEN: " );

      jopprint_opname( op );

      if (r1r == GAP)
	cc_msg( "GAP  " );
      else
	cc_msg( "%3ld%c ", (long)r1r, r1dead );
      
      if (r2r == GAP)
	cc_msg( "GAP  " );
      else
	cc_msg( "%3ld%c ", (long)r2r, r2dead );
      
      if (mr == GAP)
	cc_msg( "GAP\n" );
      else
	cc_msg( "%3ld%c\n", (long)mr, r3dead );
    }
  
  death = 0;
      
  if (op & J_DEAD_R1)
    death |= regbit( r1r );
      
  if (op & J_DEAD_R2)
    death |= regbit( r2r );
      
  if (op & J_DEAD_R3)
    death |= regbit( mr );
      
  /*
   * to enable future JOPCODE peephole optimisation expand_jop_macros()
   *  tries quite hard not to call show_inst() with instructions with
   *  no effect.
   */

  dead = op & J_DEADBITS;		/* Keep just in case */
  op  &= ~J_DEADBITS;                   /* ignore as yet */
  opm  = op & ~Q_MASK;

  /* Stack optimisation code */
  
  if ((r1r == R_SP) || (r2r == R_SP))
    {
      if ((opm == J_ADDK) && (r1r == r2r))
	{
	  adjust_stack( m );
	  
	  if (stack_move < 0)
	    correct_stack( TRUE );
	  
	  return;
	}
      else if ((opm == J_SUBK) && (r1r == r2r))
	{
	  adjust_stack( -m );

	  if (stack_move < 0)
	    correct_stack( TRUE );
	  
	  return;
	}
      else if ((uses_r1( op ) && r1r == R_SP) ||
	       (uses_r2( op ) && r2r == R_SP) ||
	       (uses_r3( op ) && mr  == R_SP))
	{
	  correct_stack( TRUE );
	}
    }
  else if ((stack_move < 0) &&
	   ((uses_r1( op )  && r1r == R_SP) ||	/* XXX - used to R_FP */
	    (uses_r2( op )  && r2r == R_SP) ||	/* XXX - used to R_FP */
	    (uses_r3( op )  && mr  == R_SP) ))	/* XXX - used to R_FP */
    {
      correct_stack( TRUE );
    }

  if (loads_r1( op ))
    {
      maybe_flush_pending_push( r1r );
    }

  /*
   * XXX - NC
   *
   * In the switch below, case entries should terminate with a
   * 'return' if they do not care about pending conditional execution
   * (or if they have dealt with it), and they should 'break' if it
   * is an error for the J_opcode to be produced conditionally
   */
  
  switch (opm)
    {
    case J_CLRC:
      /*
       * clear memory the 'm' "bytes" of memory pointed
       * to by register 'r1r'
       * (register 'r2r' not used)
       */
      
      clear_memory( r1r, m, dead & J_DEAD_R1 );
      break;

    case J_MOVC:
      /*
       * copy the 'm' "bytes" of memory pointed
       * to by register 'r2r' to the area
       * pointed to by register 'r1r'
       */

      copy_memory( r2r, r1r, m, dead & J_DEAD_R2, dead & J_DEAD_R1 );
      break;
      
    case J_CALLK:
      /*
       * call subroutine at symbol 'm'
       * (registers 'r1r' and 'r2r' not used)
       */

      correct_stack( TRUE );

      if (stack_move)
	syserr( syserr_stack_mis_aligned );
      
      call( (Symstr *)m, FALSE );

      break;

    case J_TAILCALLK:
      /*
       * call subroutine at symbol 'm'
       * this call is the last instruction in the current subroutine
       * (registers 'r1r' and 'r2r' not used)
       */
      if (!new_stubs || !in_stubs)
	{
	  routine_exit( TRUE );   /* effectively includes correct_stack() */

	  if (stack_move)
	    syserr( syserr_stack_mis_aligned );
	}
      
      call( (Symstr *)m, TRUE );

      flush_peepholer( DBG( "tailcall" ) );
      
      break;

    case J_CALLR:	/* call subroutine at register 'mr' ????? */
      
      correct_stack( TRUE );

      flush_pending_pushes();
      
      if (stack_move)
	syserr( syserr_stack_mis_aligned );

      outdelayed( (OP_LAJcr << 24) | 0x1U << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( mr ),
		 examines1( mr ),
		 alters2( R_LR, RR_PC ) );
      
      /* forget about contents of address registers after a call */

      peep_corrupt_all_addr_regs();
      
      break;

    case J_TAILCALLR:	/* tail call subroutine at register 'mr' ????? */

      if ((regbit( mr ) & saved_fvars) ||
	  (regbit( mr ) & saved_ivars) )
	{
	  /* we are about to pop 'mr' off the stack! */

	  move_register( mr, R_TMP1, FALSE, TRUE );

	  mr = R_TMP1;	  
	}
      
      routine_exit( TRUE );   /* effectively includes correct_stack() */

      if (stack_move)
	syserr( syserr_stack_mis_aligned );

      outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( mr ),
		 examines1( mr ),
		 alters1( RR_PC ) );

      flush_peepholer( DBG( "tailcall R" ) );
      
      break;

#ifdef TARGET_HAS_PROFILE
    case J_COUNT:	/* something to do with profiler ???? */
      
      correct_stack( TRUE );
      
      /* (int)r1 is ? (I would like the character on the line) ????              */
      /* (char *)r2 is the name of the file, and (int)m is the line number       */
      /* within that file. I will assume here a sensible limit on the length     */
      /* of files and hence pack these two pieces of information into a single   */
      /* 32-bit word. The structure used is count_position, and up to 16 files   */
      /* can be referenced. If there is any danger of running out of same I will */
      /* flush out the table used to decode files names and start again.         */
      
        {
	  count_position	k;


	  /* beware that the next line may flush literals etc. */

	  k.s.file = lit_of_count_name( (char *)r2 );
	  k.s.line = (unsigned int)m;
	  k.s.posn = 0;       /* Not available here */

	  flush_peepholer( DBG( "emitting count" ) );
	  
	  /* 	  outcall( countroutine ); */
	  
	  codexrefs = global_list4( SU_Xref, codexrefs, X_absreloc | (codebase + codep),
				   bindsym_( datasegment ), dataloc );

	  outcodewordaux( dataloc, LIT_RELADDR, 0 );

	  gendcI( 4, 0 );        /* Generate the slot */

	  outcodeword( k.i, LIT_NUMBER );
        }

      return;
#endif /* TARGET_HAS_PROFILE */
      
    case J_ADCON:
      /*
       * load register 'r1r' with the address of
       * symbol 'm' offset by the integer 'r2'
       */

      load_address_constant( r1r, (Symstr *)m, (int32)r2r );
      break;
      
    case J_STRING:
      /*
       * place string 'm' in literal pool
       * and place pointer to the string in register 'r1r'
       * (register 'r2r' not used)
       */

      load_string_constant( r1r );

      /*
       * strings for -Zr are placed in code segment
       */
      
      if (suppress_module == 1)
	codeseg_stringsegs( (StringSegList *)m, 1 );
      
      return;

    case J_LABEL:	/* place label in code */
	{
	  LabelNumber *	l = (LabelNumber *)m;

	  
	  if (l->block == DUFF_ADDR && l != returnlab)
	    {
	      cc_msg( "Unused label L%ld\n", lab_name_( l ) & 0x7fffffffU );
	    }
	  else
	    {
	      correct_stack( TRUE );
	      
	      flush_peepholer( DBG( "j_label" ) );
	      
	      setlabel( l );
	    }

	  /* cannot remember register contents across loops and branches */

	  peep_corrupt_all_addr_regs();
	}
      
      return;

/* XXX - flow control */
      
    case J_B:		/* conditional branch */
      correct_stack( TRUE );

#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  if ((op & Q_MASK) == Q_AL)
	    conditional_branch_to( pending_condition, (LabelNumber *)m );
	  else
	    syserr( syserr_not_match_pending, pending_condition, op & Q_MASK );
	}
      else
#endif
	{
	  conditional_branch_to( op & Q_MASK, (LabelNumber *)m );
	}

      return;
      
    case J_CASEBRANCH:	/* start of case branch */
      
      /* defer any action until the first BXX, when the default label becomes known */
      
      casebranch_pending = m;
      casebranch_r1r     = r1r;
      
      break;
      
    case J_BXX:             /* Used with case tables */
      if (casebranch_pending)
	{
	  LabelNumber *		tablelab = nextlabel();
	  int32			offset;
	  RealRegister		ar;
	  bool			saved_lr = FALSE;
	  int			num_instructions;
	  
	  
	  /* this is the first BXX following a J_CASEBRANCH */
	  
	  r1r = casebranch_r1r;

	  /* compare the value with the index of the first entry in the branch table */
	  
	  compare_integer( r1r, casebranch_pending - 1, Q_HS );   /* 1 for default */

	  /* and if we are out of range then branch to label 'm' */
	  
	  (void) conditional_branch_to( Q_HS, (LabelNumber *)m );

	  /*
	   * Note - we do not have to check for underflow, as the compiler
	   * will ensure that the table index starts from 0
	   */

	  if ((r1r == R_LR) ||				/* switch register is link register      */
	      ((saved_ivars & regbit( R_LR )) == 0) ||	/* return address was not saved on stack */
	      usedmaskvec.map[ 0 ] & regbit( R_LR )	/* link register being used as temporary */
	      )
	    {
	      /* save the return address */

	      move_register( R_LR, R_TMP2, FALSE, TRUE );

	      if (r1r == R_LR)
		r1r = R_TMP2;	/* choose a different temporary */

	      saved_lr = TRUE;
	    }

	  flush_peepholer( DBG( "paranoid, moi?" ) );
	  
	  /* put PC into R_LR */

	  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

	  /* ensure that codep is up to date */
	  
	  flush_peepholer( DBG( "getting hold of PC" ) );

	  codep_of_call = codep;

	  peep_protect_pc = 3;
	  
	  /*
	   * get address of jump table (set later)
	   *
	   * XXX - we assume this offset will fit in 8 bits
	   */

	  peep_fref( tablelab, LABREF_LIT8 );

	  /* add the offset of start of table and switch index into temp register */

	  ar = peep_get_free_addr_reg( GAP );
	  
	  /*
	   * Note that the 'num_instructions' constant in the following op code
	   * comes from that fact that there are 'n' instructions between the
	   * instruction now pointed at by the link register and the start of
	   * the jump table
	   */

	  offset = ((codep_of_call + codebase) >> 2) + 3;

	  num_instructions = saved_lr ? 3 : 2;

	  if (!fits_in_16_bits_signed( offset ))
	    num_instructions += 2;
	  
	  out_triadic_op( OP_ADDI3, ar, r1r,
			 num_instructions,
			 ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( r1r ),
			 alters2( ar, RR_ST ) );  /* relative to the LAJ instruction above */

	  /* add PC into address */

	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, ar, R_LR,
			examines2( ar, R_TMP1 ),
			alters2( ar, RR_ST ) );
	  
	  /* add PC to address in jump table and place result back in temporary */

	  out_triadic_op( OP_ADDI3, ar, R_LR, build_indirect( INDIRECT_REL, ar, 1 ),
			 ADDR_MODE_REGISTER, ADDR_MODE_INDIRECT,
			 examines2( R_LR, ar ),
			 alters2( ar, RR_ST ) );

	  /* R_LR points to following instruction */
	     
	  /* adjust offset to be relative to the LAJ instruction */
	  
	  if (fits_in_16_bits_signed( offset ))
	    {
	      out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, ar, offset,
			    examines1( ar ),
			    alters2( ar, RR_ST ) );
	    }
	  else
	    {
	      RealRegister	tmp = R_TMP3;


	      /* load high part of offset */
	      
	      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, tmp, offset >> 16,
			    examines0(),
			    alters1( tmp ) );

	      /* load low part of offset */
      
	      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, tmp, offset,
			    examines1( tmp ),
			    alters2( tmp, RR_ST ) );

	      /* subtract offset from value in jump table */
	      
	      out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, ar, tmp,
			    examines2( ar, tmp ),
			    alters2( ar, RR_ST ) );
	    }
	  
	  flush_peepholer( DBG( "switch table 2" ) );
	  
	  if (saved_lr)
	    {
	      /* restore return address */
	      
	      move_register( R_TMP2, R_LR, FALSE, TRUE );
	    }
	  
	  /* and jump */
	  
	  outinstr( OP_BRcr << 24 | C_FROMQ( Q_AL ) << 16 | hardware_register( ar ),
		   examines1( ar ),
		   alters1( RR_PC ) );
	  
	  /* start the branch table */
	  
	  flush_peepholer( DBG( "switch table 3" ) );
	  
	  setlabel( tablelab );
	  
	  /* remember to reset the casebranch_pending flag */
	  
	  casebranch_pending = 0;
	  
	  /* and codep flag */
	  
	  codep_of_call = 0;
	}
      else
	{
	  LabelNumber *	l = (LabelNumber *)m;
	  
	  
	  /* not first BXX */
	  
	  if (l == RETLAB)
	    l = returnlab;	/* yuk!! ?? */
	  
	  flush_peepholer( DBG( "generating switch table" ) );
	  
	  if lab_isset_( l )
	    {
	      /*
	       * This can occur because of code like ...
	       *
	       * label:
	       *  <code>
	       *
	       * switch (arg)
	       * {
	       * case 1: goto label;
	       * }
	       *
	       */
	      
	      codexrefs = (CodeXref *) global_list4( SU_Xref, codexrefs, X_absreloc | (codebase + codep),
				       bindsym_( codesegment ),
				       (codebase + l->u.defn & 0x00ffffffUL) / sizeof_int );
	      
	      outcodewordaux( (codebase + l->u.defn & 0x00ffffffUL) / sizeof_int,
			     LIT_ADCON, bindsym_( codesegment ) );
	    }
	  else
	    {
	      codexrefs = (CodeXref *) global_list4( SU_Xref, codexrefs, X_absreloc | (codebase + codep),
				       bindsym_( codesegment ), 0 );
	      
	      addlongfref_( l, codep | LABREF_ABS32, codexrefs );
	      
	      outcodewordaux( 0, LIT_ADCON, bindsym_( codesegment ) );
	    }
	  
	  flush_peepholer( DBG( "generating switch table 2" ) );
	}
      
      break;
      
      /* XXX - stack manipulation */
      
    case J_STACK:
      /*
       * the compiler now believes that we have 'm' bytes of
       * stack used by this function (presumably for local
       * variables). This is an informative op code and
       * should not really generate any output.
       */
      
      stack_offset = m;
      stack_move   = 0;
      
      return;
      
    case J_SETSP:
      /*
       * set the stack pointer
       * the compiler currently thinks that we have 'r2r' bytes
       * of stack allocated to local variables, and it wants us
       * to have 'm' bytes
       */
        {
	  int32	diff;
	  int32	oldstack = (int32)r2r;
	  int32	newstack = m;
	  
	  
	  if (stack_offset != oldstack)
	    syserr( syserr_setsp_confused, (long)stack_offset, (long)oldstack, (long)newstack );
	  
	  diff         = newstack - oldstack;
	  stack_offset = newstack;
	  
	  adjust_stack( - diff );
	  
	  flush_pending_pushes();
        }
      
      break;
      
#ifdef TARGET_HAS_COND_EXEC
    case J_CONDEXEC:
      pending_condition = op & Q_MASK;
      return;
#endif
      
    case J_CMPFR:
      if (fast_FP)
	{
#ifdef TARGET_HAS_COND_EXEC
	  if (pending_condition)
	    syserr( syserr_no_fast_compare );
#endif	  
	  out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r2r, r2r,
			examines1( r2r ),
			alters2( r2r, RR_ST ) );
      
	  out_diadic_op( OP_RND, ADDR_MODE_REGISTER, mr, mr,
			examines1( mr ),
			alters2( mr, RR_ST ) );
	}
      
    case J_CMPDR:
      /*
       * compare the contents of register 'r2r'
       * with the contents of register 'mr'
       * (register 'r1r' not used)
       */
      
      correct_stack( TRUE );
      
#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  /*
	   * XXX - the C40 does not really have conditional comparisons
	   * but we fake it here, to allow the code generator to do
	   * conditional executions
	   */

	  move_register( RR_ST, R_TMP1, FALSE, TRUE );
	  out_diadic_op( OP_CMPF, ADDR_MODE_REGISTER, r2r, mr,
			examines2( r2r, mr ),
			alters1( RR_ST ) );
	  conditional_load( pending_condition, ADDR_MODE_REGISTER, RR_ST, R_TMP1,
			   examines2( RR_ST, R_TMP1 ),
			   alters1( RR_ST ) );
	}
      else
#endif
	out_diadic_op( OP_CMPF, ADDR_MODE_REGISTER, r2r, mr,
		      examines2( r2r, mr ),
		      alters1( RR_ST ) );
      return;
      
    case J_CMPR:
      correct_stack( TRUE );
      
#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  /*
	   * XXX - the C40 does not really have conditional comparisons
	   * but we fake it here, to allow the code generator to do
	   * conditional executions
	   */

	  move_register( RR_ST, R_TMP1, FALSE, TRUE );
	  out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, r2r, mr,
			examines2( r2r, mr ),
			alters1( RR_ST ) );
	  conditional_load( pending_condition, ADDR_MODE_REGISTER, RR_ST, R_TMP1,
			   examines2( RR_ST, R_TMP1 ),
			   alters1( RR_ST ) );
	}
      else
#endif
	out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, r2r, mr,
		      examines2( r2r, mr ),
		      alters1( RR_ST ) );
      return;
      
    case J_CMPK:
      /*
       * compare the contents of register 'r2r'
       * against the integer 'm'
       * (register 'r1r' not used)
       */

#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  /*
	   * XXX - the C40 does not really have conditional comparisons
	   * but we fake it here, to allow the code generator to do
	   * conditional executions
	   */

	  move_register( RR_ST, R_TMP2, FALSE, TRUE );
	  compare_integer( r2r, m, pending_condition );
	  conditional_load( pending_condition, ADDR_MODE_REGISTER, RR_ST, R_TMP2,
			   examines2( RR_ST, R_TMP2 ),
			   alters1( RR_ST ) );
	}
      else
#endif
	compare_integer( r2r, m, op & Q_MASK );
      
      return;
      
#ifdef TARGET_HAS_FP_LITERALS      
    case J_CMPFK:
      /*
       * compare the contents of register 'r2r'
       * against the floating point constant 'm'
       * (register 'r1r' not used)
       */

#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  /*
	   * XXX - the C40 does not really have conditional comparisons
	   * but we fake it here, to allow the code generator to do
	   * conditional executions
	   */

	  move_register( RR_ST, R_TMP1, FALSE, TRUE );
	  compare_float( r2r, (FloatCon *)m, pending_condition, FALSE );
	  conditional_load( pending_condition, ADDR_MODE_REGISTER, RR_ST, R_TMP1,
			   examines2( RR_ST, R_TMP1 ),
			   alters1( RR_ST ) );
	}
      else
#endif
	compare_float( r2r, (FloatCon *)m, op & Q_MASK, FALSE );
      return;
      
    case J_CMPDK:
      /*
       * compare the contents of register 'r2r'
       * against the floating point constant 'm'
       * (register 'r1r' not used)
       */
      
#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  /*
	   * XXX - the C40 does not really have conditional comparisons
	   * but we fake it here, to allow the code generator to do
	   * conditional executions
	   */

	  move_register( RR_ST, R_TMP1, FALSE, TRUE );
	  compare_float( r2r, (FloatCon *)m, pending_condition, TRUE );
	  conditional_load( pending_condition, ADDR_MODE_REGISTER, RR_ST, R_TMP1,
			   examines2( RR_ST, R_TMP1 ),
			   alters1( RR_ST ) );
	}
      else
#endif
	compare_float( r2r, (FloatCon *)m, op & Q_MASK, TRUE );
      return;
#endif /* TARGET_HAS_FP_LITERALS */
      
    case J_MOVDFR:
      /*
       * move the contents of double precision register 'mr'
       * into the floating point register 'r1r'
       * (register 'r2r' not used)
       */
      
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, mr, mr,
		    examines1( mr ),
		    alters2( mr, RR_ST ) );
      
      /* drop through */
      
    case J_MOVFDR:
      /*
       * move the contents of floating point register 'mr'
       * into the double precision register 'r1r'
       * (register 'r2r' not used)
       */
      
      /* drop through */
      
    case J_MOVDR:
      /*
       * move the contents of double precision register 'mr'
       * into the double precision register register 'r1r'
       * (register 'r2r' not used)
       */
      
      /* drop through */
      
    case J_MOVFR:
      /*
       * move the contents of floating point register 'mr'
       * into the floating point register register 'r1r'
       * (register 'r2r' not used)
       */
      
#ifdef DEBUG
      if (!is_float( mr ))
	syserr( syserr_non_float_source );
      
      if (!is_float( r1r ))
	syserr( syserr_non_float_dest );
#endif
      
      /* drop through */
      
#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition)
	{
	  conditional_load_float( pending_condition, ADDR_MODE_REGISTER, r1r, mr,
				 examines2( mr, RR_ST ),
				 alters1( r1r ) );
	}
      else
#endif /* TARGET_HAS_COND_EXEC */
	{
	  move_register( mr, r1r, TRUE, FALSE );
	}
      
      return;
      
    case J_MOVR:
      if (r1r == mr)
	syserr( syserr_movr );
      
#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition)
	{
	  conditional_load( pending_condition, ADDR_MODE_REGISTER, r1r, mr,
			   examines2( mr, RR_ST ),
			   alters1( r1r ) );
	}
      else
#endif
	{
	  move_register( mr, r1r, FALSE, FALSE );
	}
      
      return;
      
    case J_MOVIDR:
      
      /*
       * move the contents of integer registers 'mr' (lsd) and 'r2r' (msd)
       * into the double precision register register 'r1r'
       */
      
#ifdef DEBUG
      if (!is_float( r1r ))
	{
	  syserr( syserr_non_float_dest );
	}      
#endif
      ipush( r2r );	/* big endian doubles */
      fpop(  r1r );
      
      move_register( mr, r1r, FALSE, TRUE );
      
      break;
      
    case J_MOVIFR:
      /*
       * move the contents of integer register 'mr' 
       * into the floating point register register 'r1r'
       * (register 'r2r' not used)
       */
      
#ifdef DEBUG
      if (!is_float( r1r ))
	{
	  syserr( syserr_non_float_dest );
	}      
#endif
      ipush( mr );
      fpop( r1r );
      
      peep_forget_about( r1r );
      
      break;
      
    case J_FLTDR + J_SIGNED:
#ifndef TARGET_LACKS_UNSIGNED_FIX
    case J_FLTDR /* + J_UNSIGNED */:
#endif
      /*
       * place the nearest double precision representation of
       * the contents of integer register 'mr'
       * into the double precision register 'r1r'
       * (register 'r2r' not used)
       */
      
      /* drop through */
      
    case J_FLTFR + J_SIGNED:
#ifndef TARGET_LACKS_UNSIGNED_FIX
    case J_FLTFR /* + J_UNSIGNED */:
#endif
      /*
       * place the nearest floating point representation of
       * the contents of integer register 'mr'
       * into the floating point register 'r1r'
       * (register 'r2r' not used)
       */
      
#ifdef DEBUG
      if (!is_float( r1r ))
	{
	  syserr( syserr_non_float_dest );
	}      
#endif
      out_diadic_op( OP_FLOAT, ADDR_MODE_REGISTER, r1r, mr,
		    examines1( mr ),
		    alters2( r1r, RR_ST ) );
      
#ifndef TARGET_LACKS_UNSIGNED_FIX
      if (!(opm & J_SIGNED))
	{
	  bool		bMustRestoreLR = FALSE;
	  RealRegister	dst;
	  
	  
	  /* get hold of a free floating point register */
	  
	  dst = get_free_register( RR_R1, RR_R2, RR_R3, RR_R6, RR_R7, RR_R10, GAP );
	  
	  /* if we must then save a register on the stack */
	  
	  if (dst == GAP)
	    {
	      dst = R_LR;
		  
	      /* can we use R_LR ? */
	      
	      if ((saved_ivars & regbit( R_LR )) == 0 ||
		  usedmaskvec.map[ 0 ] & regbit( R_LR ))	/* link register being used as temporary */
		{
		  bMustRestoreLR = TRUE;
		  
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS	      
		  dpush( R_LR );
#else
		  /* NB/ do not use move_register() as this corrupts status register */
		  maybe_flush_pending_push( R_TMP2 );
		  conditional_load( Q_AL, ADDR_MODE_REGISTER, R_TMP2, R_LR,
				   examines1( R_LR ), alters1( R_TMP2 ) );
		  peep_forget_about( R_TMP2 );
#endif
		}
	    }
	  
	  /* load 2e32 */
	  
	  load_integer( R_TMP1, 0x20000000U, TRUE );
	  
	  /* save on stack as an integer */
	  
	  ipush( R_TMP1 );
	  
	  /* pop back as a float */
	  
	  conditional_load_float( Q_AL, ADDR_MODE_INDIRECT, dst,
				 build_indirect( INDIRECT_POST_INCR, R_SP, 1 ),	/* NB/ must be same as fpop() */
				 examines1( R_SP ),
				 alters2( R_SP, dst ) );
	  
	  peep_change_addr_offset( R_SP, +1 );
	  
	  /* overwrite with 0 if the conversion went OK */
	  
	  conditional_load_float( Q_GE, ADDR_MODE_IMMEDIATE, dst, 0x8000,
				 examines1( RR_ST ),
				 alters1( dst ) );
	  
	  /* add the value as required */
	  
	  out_diadic_op( OP_ADDF, ADDR_MODE_REGISTER, r1r, dst,
			examines2( r1r, dst ),
			alters2( r1r, RR_ST ) );
	  
	  /* restore destination if necessary */
	  
	  if (bMustRestoreLR)
	    {
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS	      
	      dpop( R_LR );
#else
	      move_register( R_TMP2, R_LR, FALSE );
#endif
	    }
	  
	  peep_forget_about( r1r );
	}
#endif /* ! TARGET_LACKS_UNSIGNED_FIX */
      
      if ((opm == J_FLTFR + J_SIGNED) ||
	  (opm == J_FLTFR + J_UNSIGNED) )
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ),
		      alters2( r1r, RR_ST ) );
      
      break;
      
    case J_FIXDR + J_SIGNED:
#ifndef TARGET_LACKS_UNSIGNED_FIX
    case J_FIXDR /* + J_UNSIGNED */:
#endif      
      /*
       * place the nearest integer representation of
       * the contents of double precision register 'mr'
       * into the integer register 'r1r'
       * (register 'r2r' not used)
       */

      /* drop through */
      
    case J_FIXFR + J_SIGNED:
#ifndef TARGET_LACKS_UNSIGNED_FIX
    case J_FIXFR /* + J_UNSIGNED */:
#endif      
      /*
       * place the nearest integer representation of
       * the contents of floating point register 'mr'
       * into the integer register 'r1r'
       * (register 'r2r' not used)
       */

      fix( mr, r1r, (bool) (opm & J_SIGNED) );
      break;
      
    case J_NEGDR:
    case J_NEGFR:
      /*
       * place the negated contents of floating point register 'mr'
       * into floating point register 'r1r'
       * (register 'r2r' not used)
       */

#ifdef DEBUG
      if (!is_float( mr ) || !is_float( r1r ))
	{
	  syserr( syserr_non_float_dest );
	}      
#endif
      
      out_diadic_op( OP_NEGF, ADDR_MODE_REGISTER, r1r, mr,
		    examines1( mr ),
		    alters2( r1r, RR_ST ) );

      peep_forget_about( r1r );

      if (!fast_FP && opm == J_NEGFR)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ),
		      alters2( r1r, RR_ST ) );
      
      break;

    case J_NEGR:
      /*
       * place the negated contents of register 'mr'
       * into register 'r1r'
       * (register 'r2r' not used)
       */

      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, r1r, mr,
		    examines1( mr ),
		    alters2( r1r, RR_ST ) );
      
      peep_forget_about( r1r );
      break;
      
    case J_NOTR:
      /*
       * place the inverted contents of register 'mr'
       * into register 'r1r'
       * (register 'r2r' not used)
       */

      out_diadic_op( OP_NOT, ADDR_MODE_REGISTER, r1r, mr,
		    examines1( mr ),
		    alters2( r1r, RR_ST ) );
      
      peep_forget_about( r1r );
      break;
      
    case J_MOVDK:
      /*
       * load the double precision value 'm' into
       * register double precision register 'r1r'
       * (register 'r2r not used)
       */

#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  int32	val = convert_to_C40_format( (FloatCon *)m, TRUE );


	  if (val == 0xFFFFFFFFU)
	    syserr( syserr_FP_value_not_fit );

	  conditional_load_float( pending_condition, ADDR_MODE_IMMEDIATE, r1r, val,
				 examines1( RR_ST ),
				 alters1( r1r ) );
	}
      else
#endif /* TARGET_HAS_COND_EXEC */
	{	  
	  load_float( r1r, (FloatCon *)m, TRUE );
	}

      return;
      
    case J_MOVFK:
      /*
       * load the floating point value 'm' into
       * register floating point register 'r1r'
       * (register 'r2r not used)
       */

#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  int32	val = convert_to_C40_format( (FloatCon *)m, FALSE );


	  if (val == 0xFFFFFFFFU)
	    syserr( syserr_FP_value_not_fit );

	  conditional_load_float( pending_condition, ADDR_MODE_IMMEDIATE, r1r, val,
				 examines1( RR_ST ),
				 alters1( r1r ) );
	}
      else
#endif /* TARGET_HAS_COND_EXEC */
	{	  
	  load_float( r1r, (FloatCon *)m, FALSE );
	}
      
      return;
      
    case J_MOVK:
      /*
       * load the integer 'm' into
       * register 'r1r'
       * (register 'r2r not used)
       */

#ifdef TARGET_HAS_COND_EXEC
      if (pending_condition != Q_AL)
	{
	  if (fits_in_16_bits_signed( m ))
	    {
	      conditional_load( pending_condition, ADDR_MODE_IMMEDIATE, r1r, m,
			       examines1( RR_ST ),
			       alters1( r1r ) );
	    }
	  else
	    {
	      load_integer( R_TMP1, m, TRUE );
	      
	      conditional_load( pending_condition, ADDR_MODE_REGISTER, r1r, R_TMP1,
			       examines2( R_TMP1, RR_ST ),
			       alters1( r1r ) );
	    }
	}
      else
#endif /* TARGET_HAS_COND_EXEC */
	{
	  load_integer( r1r, m, FALSE );
	}
      
      return;

/* XXX - binary ops */
      
    case J_SHRK + J_SIGNED:	
    case J_SHRK: /* + J_UNSIGNED: */
      /*
       * shift the contents of register 'r2r'
       * right by 'm' and place the result
       * in register 'r1r'
       */
      
      m = -m;

      /* drop through */

    case J_SHLK + J_SIGNED:
    case J_SHLK: /* + J_UNSIGNED: */
      
      /*
       * shift the contents of register 'r2r'
       * left by 'm' and place the result
       * in register 'r1r'
       */
      
      shift_register( (op & J_SIGNED) ? TRUE : FALSE, r1r, r2r, m ); 
      break;
		     
#ifdef TARGET_HAS_FP_LITERALS
    case J_SUBFK:
      /*
       * subtract floating point value 'm' from
       * the contents of register 'r2r' and place
       * result in register 'r1r'
       */

      float_immediate_op( OP_SUBF, r1r, r2r, (FloatCon *)m, FALSE );

      if (!fast_FP)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ),
		      alters2( r1r, RR_ST ) );      
      break;
      
    case J_SUBDK:
      /*
       * subtract double precision value 'm' from
       * the contents of register 'r2r' and place
       * result in register 'r1r'
       */

      float_immediate_op( OP_SUBF, r1r, r2r, (FloatCon *)m, TRUE );
      break;
#endif /* TARGET_HAS_FP_LITERALS */
      
    case J_SUBK:
      /*
       * subtract 'm' from the contents of
       * register 'r2r' and place result
       * in register 'r1r'
       */

      if (r2r == R_SP)
	flush_pending_pushes();

      if (is_word_addressed_( r2r ))
	{
	  RealRegister	ar;
	  int32		off;
	  bool		biased;

	  
	  if (m & (sizeof_int - 1))
	    syserr( syserr_adjust_non_word );

	  ar = peep_find_loaded_addr_reg( r2r, &off, &biased );
	      
	  m /= sizeof_int;
	  
	  if (ar     != GAP   &&
	      biased == FALSE &&
	      !no_peepholing   )
	    {
	      m -= off;
	  
	      if (m == 0)
		{
		  peepf( "eliminated unnecessary integer load" );

		  ++peep_eliminated;
		  
		  move_register( ar, r1r, FALSE, TRUE );
		}
	      else if (fits_in_8_bits_signed( m ))
		{
		  peepf( "eliminated unnecessary integer load" );

		  ++peep_eliminated;
	      
		  out_triadic_op( OP_SUBI3, r1r, ar, m, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
				 examines1( ar ),
				 alters2( r1r, RR_ST ) );
		}
	      else
		{
		  integer_immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, (m + off) * sizeof_int, TRUE );
		}
	    }
	  else
	    {
	      integer_immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, m * sizeof_int, TRUE );
	    }

	  convert_to_byte_offset( r1r );
	}
      else if (m == 0)
	{
	  move_register( r2r, r1r, FALSE, TRUE );
	}
      else if (m < 0)
	{
	  integer_immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, -m, TRUE );
	}
      else
	{
	  integer_immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, m, TRUE );
	}
      
      break;

#ifdef TARGET_HAS_FP_LITERALS
    case J_ADDFK:
      /*
       * add floating point value 'm' to the
       * contents of register 'r2r' and place
       * the result in register 'r1r'
       */

      float_immediate_op( OP_ADDF, r1r, r2r, (FloatCon *)m, FALSE );

      if (!fast_FP)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ),
		      alters2( r1r, RR_ST ) );
      
      break;
      
    case J_ADDDK:
      /*
       * add double precision value 'm' to the
       * contents of register 'r2r' and place
       * the result in register 'r1r'
       */

      float_immediate_op( OP_ADDF, r1r, r2r, (FloatCon *)m, TRUE );
      break;
      
#endif /* TARGET_HAS_FP_LITERALS */
      
    case J_ADDK:
      /*
       * add 'm' to the contents of
       * register 'r2r' and place the
       * result in register 'r1r'
       */

      if (r2r == R_SP)
	flush_pending_pushes();
      
      if (is_word_addressed_( r2r ))
	{
	  RealRegister	ar;
	  int32		off;
	  bool		biased;

	  
	  if (m & (sizeof_int - 1))
	    syserr( syserr_adjust_non_word );
	  
	  m /= sizeof_int;

	  ar = peep_find_loaded_addr_reg( r2r, &off, &biased );

	  if (ar     != GAP   &&
	      biased == FALSE &&
	      !no_peepholing   )
	    {
	      m -= off;
	  
	      if (m == 0)
		{
		  peepf( "eliminated unnecessary integer load" );

		  ++peep_eliminated;
	      
		  move_register( ar, r1r, FALSE, TRUE );
		}
	      else if (fits_in_8_bits_signed( m ))
		{
		  peepf( "eliminated unnecessary integer load" );

		  ++peep_eliminated;
	      
		  out_triadic_op( OP_ADDI3, r1r, ar, m, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
				 examines1( ar ),
				 alters2( r1r, RR_ST ) );
		}
	      else
		{
		  integer_immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, (m + off) * sizeof_int, TRUE );
		}
	    }
	  else
	    {
	      integer_immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, m * sizeof_int, TRUE );
	    }

	  convert_to_byte_offset( r1r );
	}
      else if (m == 0)
	{
	  move_register( r2r, r1r, FALSE, TRUE );
	}
      else if (m < 0)
	{
	  integer_immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, -m, TRUE );
	}
      else
	{
	  integer_immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, m, TRUE );
	}

      break;

#ifdef TARGET_HAS_FP_LITERALS
    case J_MULFK:
      /*
       * multiply the floating point value 'm' with the
       * contents of register 'r2r' and place
       * the result in register 'r1r'
       */

      float_immediate_op( OP_MPYF, r1r, r2r, (FloatCon *)m, FALSE );

      if (!fast_FP)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ),
		      alters2( r1r, RR_ST ) );      
      break;
      
    case J_MULDK:
      /*
       * multiply the double precision value 'm' with the
       * contents of register 'r2r' and place
       * the result in register 'r1r'
       */

      float_immediate_op( OP_MPYF, r1r, r2r, (FloatCon *)m, TRUE );
      break;

#ifndef TARGET_LACKS_FP_DIVIDE
    case J_DIVDK:
      /* r1r = r2r / m */      
      fp_imm_divide( r1r, r2r, (FloatCon *)m, TRUE );
      break;
      
    case J_DIVFK:
      fp_imm_divide( r1r, r2r, (FloatCon *)m, FALSE );
      break;
#endif /* !TARGET_LACKS_FP_DIVIDE */
#endif /* TARGET_HAS_FP_LITERALS */
      
      /*
       * the front-end maps MULK to MULR if TARGET_LACKS_MULTIPLY_LITERALS,
       * and DIVK/REMK to DIVR/REMR if TARGET_LACKS_DIVIDE_LITERALS.
       * TARGET_LACKS_MULDIV_LITERALS is equivalent to setting both of these.
       * MULR/DIVR/REMR get mapped to function calls unless TARGET_HAS_MULTIPLY,
       * TARGET_HAS_DIVIDE etc. Beware also CONFIG_HAS_MULTIPLY in mcdep.c
       */

    case J_MULK:
      /*
       * multiply contents of register 'r2r'
       * by 'm' and place the results
       * in register 'r1r'
       */

      multiply_integer( r1r, r2r, m );
      break;
      
    case J_ANDK:
      /*
       * perform a bitwise AND between 'm' and
       * the contents of register 'r2r' and
       * place the result in register 'r1r'
       */

      /*
       * XXX - NB we cannot translate J_AND into a OP_TSTB
       * because we do not know when the destination register
       * is really dead.
       *
       * cf below where in both cases R2 is marked as dead and R1 is alive
       *
       * int func( int arg ) {
       * arg &= 0xff;	     
       * return (arg & 0x80) ? 1 : 2; }
       */
        
      integer_immediate_op( OP_AND, OP_AND3, r1r, r2r, m, FALSE );

      break;
  
    case J_ORRK:
      /*
       * preform a bitwise OR between 'm' and
       * the contents of register 'r2r' and
       * place the result in register 'r1r'
       */
      
      integer_immediate_op( OP_OR, OP_OR3, r1r, r2r, m, FALSE );
      break;
      
    case J_EORK:
      /*
       * perform a bitwise XOR between 'm' and
       * the contents of register 'r2r' and
       * place the result in register 'r1r'
       */
      
      integer_immediate_op( OP_XOR, OP_XOR3, r1r, r2r, m, FALSE );
      break;

    case J_ADDDR:
    case J_ADDFR:
      /*
       * add contents of register 'r2r' to
       * the contents of register 'mr' and
       * place the result in register 'r1r'
       */
#ifdef DEBUG
      if (!is_float( mr ) || !is_float( r2r ))
	{
	  syserr( syserr_non_source );
	}
  
      if (!is_float( r1r ))
	{
	  syserr( syserr_non_dest );
	}
#endif
      register_op( OP_ADDF, OP_ADDF3, r1r, r2r, mr, TRUE );

      if (!fast_FP && opm == J_ADDFR)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ),
		      alters2( r1r, RR_ST ) );
      
      /* no need to check for word addressing */
      
      break;
      
    case J_ADDR:
      if (r2r == R_SP)
	flush_pending_pushes();
      
      register_op( OP_ADDI, OP_ADDI3, r1r, r2r, mr, TRUE );
      
      if (is_word_addressed_( r2r ))
	{
	  convert_to_byte_offset( r1r );
	}
      
      break;
      
    case J_SUBFR:
    case J_SUBDR:
      /*
       * subtract the contents of register 'mr' from
       * the contents of register 'r2r' and place
       * the result in register 'r1r'
       */
      
#ifdef DEBUG
      if (!is_float( mr ) || !is_float( r2r ))
	{
	  syserr( syserr_non_source );
	}
  
      if (!is_float( r1r ))
	{
	  syserr( syserr_non_dest );
	}
#endif
      register_op( OP_SUBF, OP_SUBF3, r1r, r2r, mr, FALSE );

      /* no need to check for word addressing */

      if (!fast_FP && opm == J_SUBFR)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ),
		      alters2( r1r, RR_ST ) );
      break;
      
    case J_SUBR:
      if (r2r == R_SP)
	flush_pending_pushes();

      register_op( OP_SUBI, OP_SUBI3, r1r, r2r, mr, FALSE );
      
      if (is_word_addressed_( r2r ))
	{
	  convert_to_byte_offset( r1r );
	}
      
      break;
      
    case J_MULDR:
    case J_MULFR:
      /*
       * multiply contents of register 'r2r'
       * by contents of register 'mr' and
       * place the results in register 'r1r'
       */      
#ifdef DEBUG
      if (!is_float( mr ) || !is_float( r2r ))
	{
	  syserr( syserr_non_source );
	}
  
      if (!is_float( r1r ))
	{
	  syserr( syserr_non_dest );
	}
#endif
      register_op( OP_MPYF, OP_MPYF3, r1r, r2r, mr, TRUE );

      if (!fast_FP && opm == J_MULFR)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ),
		      alters2( r1r, RR_ST ) );
      break;

    case J_MULR:
      register_op( OP_MPYI, OP_MPYI3, r1r, r2r, mr, TRUE );
      break;

#ifndef TARGET_LACKS_FP_DIVIDE
    case J_DIVDR:
    case J_DIVFR:
      /* r1r = r2r / mr */
      
      fp_reg_divide( r1r, r2r, mr, opm == J_DIVDR );
      break;
#endif /* ! TARGET_LACKS_FP_DIVIDE */
      
    case J_ANDR:
      /*
       * perform a bitwise AND between the contents of register 'mr'
       * and the contents of register 'r2r' and place the result in
       * register 'r1r'
       */

      register_op( OP_AND, OP_AND3, r1r, r2r, mr, TRUE );
      break;
      
    case J_ORRR:
      /*
       * perform a bitwise OR between the contents of register 'mr'
       * and the contents of register 'r2r' and place the result in
       * register 'r1r'
       */

      register_op( OP_OR, OP_OR3, r1r, r2r, mr, TRUE );
      break;
      
    case J_EORR:
      /*
       * perform a bitwise XOR between the contents of register 'mr'
       * and the contents of register 'r2r' and place the result in
       * register 'r1r'
       */

      register_op( OP_XOR, OP_XOR3, r1r, r2r, mr, TRUE );
      break;
      
    case J_SHLR + J_SIGNED:
      /*
       * arithmetically shift contents of register 'r2r'
       * left by the amount in register 'mr' and
       * place the result in register 'r1r'
       */
      
      register_op( OP_ASH, OP_ASH3, r1r, r2r, mr, FALSE );
      break;
      
    case J_SHLR: /* + J_UNSIGNED: */
      /*
       * logically shift contents of register 'r2r'
       * left by the amount in register 'mr' and
       * place the result in register 'r1r'
       */

      register_op( OP_LSH, OP_LSH3, r1r, r2r, mr, FALSE );
      break;
      
    case J_SHRR + J_SIGNED:
      /*
       * arithmetically shift contents of register 'r2r'
       * right by the amount in register 'mr' and
       * place the result in register 'r1r'
       */

      if (r2r == r1r)
	{
	  /* negate 'mr' and move into R_TMP1 */
      
	  out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, R_TMP1, mr,
			examines1( mr ),
			alters2( R_TMP1, RR_ST ) );

	  mr = R_TMP1;	  
	}
      else
	{
	  /* negate 'mr' and move into 'r1r' */
      
	  out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, r1r, mr,
			examines1( mr ),
			alters2( r1r, RR_ST ) );

	  mr = r1r;
	}
      
      /* 'r1r' = 'r2r' >> 'mr' */
      
      out_triadic_op( OP_ASH3, r1r, r2r, mr, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( mr, r2r ),
		     alters2( r1r, RR_ST ) );
      
      peep_forget_about( r1r );
      
      break;
      
    case J_SHRR: /* + J_UNSIGNED: */
      /*
       * logically shift contents of register 'r2r'
       * right by the amount in register 'mr' and
       * place the result in register 'r1r'
       */

      if (r2r == r1r)
	{	  
	  /* negate 'mr' and move into R_TMP1 */
      
	  out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, R_TMP1, mr,
			examines1( mr ),
			alters2( R_TMP1, RR_ST ) );

	  mr = R_TMP1;	  
	}
      else
	{
	  /* negate 'mr' and move into 'r1r' */
      
	  out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, r1r, mr,
			examines1( mr ),
			alters2( r1r, RR_ST ) );

	  mr = r1r;
	}
      
      /* 'r1r' = 'r2r' >> 'mr' */
      
      out_triadic_op( OP_LSH3, r1r, r2r, mr, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( mr, r2r ),
		     alters2( r1r, RR_ST ) );
      
      peep_forget_about( r1r );
      break;


#ifdef TARGET_HAS_ROTATE
    case J_RORR:
      /*
       * rotate right the contents of register 'r2r'
       * by the amount in register 'mr' and
       * place the result in register 'r1r'
       */

      debug( "rotate right reg %d by contents of reg %d and place into reg %d", r2r, mr, r1r );
      syserr( "not yet implemented" );
      
      break;
      
    case J_RORK:
      /*
       * rotate right the contents of register 'r2r'
       * by 'm' and
       * place the result in register 'r1r'
       */

      debug( "rotate right reg %d by %d and place into reg %d", r2r, m, r1r );
      syserr( "not yet implemented" );
      break;
            
#endif /* TARGET_HAS_ROTATE */
      
/* XXX loads and stores to memory */

    case J_LDRDK:
      /*
       * load register 'r1r' with the "double precision value"
       * pointed to by register 'r2r'
       * offset by 'm'
       */

      load_double_relative( r1r, r2r, m, dead & J_DEAD_R2 );
      break;

    case J_LDRFK:
      /*
       * load register 'r1r' with the "floating point value"
       * pointed to by register 'r2r'
       * offset by 'm'
       */

      out_immediate_offset( OP_LDF, r1r, r2r, m, dead & J_DEAD_R2 );
      break;

    case J_LDRK:
      /*
       * load register 'r1r' with the "integer"
       * pointed to by register 'r2r'
       * offset by 'm'
       */

      /* catch a special case that occurs because of our word addressing */
      
      if (r1r == r2r && !no_peepholing && peep_reg_transfer_to( r2r ))
	{
	  r2r = peep_eliminate_reg_transfer( r2r );

	  peepf( "eliminated register transfer" );

	  ++peep_eliminated;
	}
      
      out_immediate_offset( OP_LDI, r1r, r2r, m, dead & J_DEAD_R2 );
      break;

    case J_LDRWK: /* + J_UNSIGNED:*/
    case J_LDRWK + J_SIGNED:
      /*
       * load register 'r1r' with the "half-word"
       * pointed to by register 'r2r'
       * offset by 'm'
       */
      
      non_word_op( r1r, r2r, m, FALSE, opm == J_LDRWK + J_SIGNED, TRUE, TRUE );
      break;

    case J_LDRBK: /* + J_UNSIGNED:*/
    case J_LDRBK + J_SIGNED:
      /*
       * load register 'r1r' with the "byte"
       * pointed to by register 'r2r'
       * offset by 'm'
       */

      non_word_op( r1r, r2r, m, FALSE, opm == (J_LDRBK + J_SIGNED), FALSE, TRUE );
      break;
     
    case J_STRDK:
      /*
       * store the contents of register 'r1r'
       * into the "double precision value" pointed at by register 'r2r'
       * offset by 'm'
       */

      store_double_relative( r1r, r2r, m, dead & J_DEAD_R2 );
      break;
      
    case J_STRFK:
      /*
       * store the contents of register 'r1r'
       * into the "floating point value" pointed at by register 'r2r'
       * offset by 'm'
       */

      if (fast_FP)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ), alters2( r1r, RR_ST ) );
      
      out_immediate_offset( OP_STF, r1r, r2r, m, dead & J_DEAD_R2 );
      break;
      
    case J_STRK:
      /*
       * store the contents of register 'r1r'
       * into the "word" pointed at by register 'r2r'
       * offset by 'm'
       */

      if (!no_peepholing && peep_reg_transfer_to( r2r ))
	{
	  RealRegister	src = peep_eliminate_reg_transfer( r2r );

	  
	  out_immediate_offset( OP_STI, r1r, src, m, dead & J_DEAD_R2 );

	  move_register( src, r2r, FALSE, TRUE );

	  peepf( "swapped order of register transfer and store" );

	  ++peep_swapped;
	}
      else

	{
	  out_immediate_offset( OP_STI, r1r, r2r, m, dead & J_DEAD_R2 );
	}
      break;
      
    case J_STRWK:
      /*
       * store the contents of register 'r1r'
       * into the "half-word" pointed at by register 'r2r'
       * offset by 'm'
       */

      non_word_op( r1r, r2r, m, FALSE, FALSE, TRUE, FALSE );
      break;
      
    case J_STRBK:
      /*
       * store the contents of register 'r1r'
       * into the "byte" pointed at by register 'r2r'
       * offset by 'm'
       */

      non_word_op( r1r, r2r, m, FALSE, FALSE, FALSE, FALSE );
      break;

    case J_LDRDR:
      /*
       * load register 'r1r' with the "double precision value"
       * pointed to by register 'r2r'
       * offset by the contents of register 'mr'
       */

      load_double_indirect( r1r, r2r, m );
      break;
      
    case J_LDRFR:
      /*
       * load register 'r1r' with the "floating point value"
       * pointed to by register 'r2r'
       * offset by the contents of register 'mr'
       */

      out_register_offset( OP_LDF, r1r, r2r, m );
      break;
      
    case J_LDRR:
      /*
       * load register 'r1r' with the "word"
       * pointed to by register 'r2r'
       * offset by the contents of register 'mr'
       */

      out_register_offset( OP_LDI, r1r, r2r, m );
      break;
      
    case J_LDRWR: /* + J_UNSIGNED:*/
    case J_LDRWR + J_SIGNED:
      /*
       * load register 'r1r' with the "half-word"
       * pointed to by register 'r2r'
       * offset by the contents of register 'mr'
       */

      non_word_op( r1r, r2r, mr, TRUE, opm == J_LDRWR + J_SIGNED, TRUE, TRUE );
      break;

    case J_LDRBR: /* + J_UNSIGNED:*/
    case J_LDRBR + J_SIGNED:
      /*
       * load register 'r1r' with the "byte"
       * pointed to by register 'r2r'
       * offset by the contents of register 'mr'
       */

      non_word_op( r1r, r2r, mr, TRUE, opm == J_LDRBR + J_SIGNED, FALSE, TRUE );
      break;
      
    case J_STRDR:
      /*
       * store the contents register 'r1r'
       * into the "double precision value" pointed at by register 'r2r'
       * offset by the contents of register 'mr'
       */

      store_double_indirect( r1r, r2r, m );
      break;
      
    case J_STRFR:
      /*
       * store the contents register 'r1r'
       * into the "floating point value" pointed at by register 'r2r'
       * offset by the contents of register 'mr'
       */

      if (fast_FP)
	out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		      examines1( r1r ), alters2( r1r, RR_ST ) );
      
      out_register_offset( OP_STF, r1r, r2r, m );
      break;
      
    case J_STRR:
      /*
       * store the contents register 'r1r'
       * into the "word" pointed at by register 'r2r'
       * offset by the contents of register 'mr'
       */

      out_register_offset( OP_STI, r1r, r2r, m );
      break;
      
    case J_STRWR:
      /*
       * store the contents register 'r1r'
       * into the "half-word" pointed at by register 'r2r'
       * offset by the contents of register 'mr'
       */

      non_word_op( r1r, r2r, mr, TRUE, FALSE, TRUE, FALSE );
      break;
      
    case J_STRBR:
      /*
       * store the contents register 'r1r'
       * into the "byte" pointed at by register 'r2r'
       * offset by the contents of register 'mr'
       */

      non_word_op( r1r, r2r, mr, TRUE, FALSE, FALSE, FALSE );
      break;
      
    case J_ENDPROC:
      /*
       * reached end of function
       */

      if (!lab_isset_( returnlab ) && returnlab->u.frefs != NULL)
	{
	  flush_peepholer( DBG( "J_ENDPROC" ) );
	  
	  conditional_branch_to( Q_AL, RETLAB );
	}

      /* NB/ flush peepholer before dumping literals */
      
      flush_peepholer( DBG( "end of procedure" ) );

#ifdef TARGET_HAS_DEBUGGER
      if (usrdbg( DBG_ANY ) /* && !new_stubs */ && !in_stubs)
	debugger_end_of_function();
#endif
      dumplits2( 0 );
      
      asm_lablist = (LabList *)dreverse( (List *)asm_lablist );
      
      dump_count_names();

      peepf( "instructions: eliminated %ld, transformed %ld, swapped %ld",
	    peep_eliminated, peep_transformed, peep_swapped );

      peep_eliminated = peep_transformed = peep_swapped = 0;

      break;
      
    case J_ENTER:
      /*
       * reached start of function
       */
      
      asm_lablist = NULL;
      
      routine_entry( m );
      
      break;
      
    case J_PUSHM:
      /*
       * save the registers indicate by the bits set in 'm' onto the stack
       */
      
      if (m != 0)
	{
	  int32	i;

	  /*
	   * NB/ push in REVERSE order to the pops.
	   * If we have peepholing disabled, each push will be emitted
	   * straight away, and so they will be in the correct order.
	   * If peepholing is enabled then each push will be prepended
	   * to the list, and the list will be emptied from the tail
	   * backwards, so emitting the pushes in reverse order.
	   * If pushes are later added to the list (by futher J_PUSH[M|F|D]
	   * op codes), then they will be prepended as well, and hence they
	   * will be in the right order as well.
	   *
	   * NB/ beware if number of registers > 32
	   */

	  for (i = 32; i--;)
	    {
	      if (m & regbit( i ))
		add_pending_push( i, PUSH_INT );
	    }	  
	}
      
      break;
            
    case J_PUSHF:
#ifdef DEBUG
      if (!is_float( r1r ))
	{
	  syserr( syserr_push_non_float, r1r );
	}
#endif
      add_pending_push( r1r, PUSH_FLOAT );
      break;

    case J_PUSHD:
#ifdef DEBUG
      if (!is_float( r1r ))
	{
	  syserr( syserr_push_non_double, r1r );
	}
#endif      
      add_pending_push( r1r, PUSH_DOUBLE );
      break;

    case J_POPM:
      /*
       * restore the registers indicated by the bits set in 'm' from the stack
       */

      while (m)
	{
	  RealRegister	r = firstbit( m );

	  
	  m ^= regbit( r );

	  if (pop_pending_push( r, (bool) (m & regbit( r + 1 )) ) == 2)
	    {
	      m ^= regbit( r + 1 );
	    }
	}
      
      break;
      
#ifdef TARGET_HAS_SIGN_EXTEND
    case J_EXTEND:
      /*
       * sign extend the contents of r2r into r1r
       * the value in m is
       * 0 for byte  to short extensions
       * 1 for byte  to int   extensions
       * 2 for short to int   extensions
       */

      switch (m)
	{
	case 0:
	  syserr( syserr_no_byte_short_sign_extend );
	  break;

	case 1:
	  /* this instruction is an LB0 r2r, r1r */
	  
	  outinstr( FUNC_LOAD << 28 | OP_LB << 24 | 0x0U << 23 | ADDR_MODE_REGISTER << 21 |
		   hardware_register( r1r ) << 16 | hardware_register( r2r ),
		   examines1( r2r ),
		   alters2( r1r, RR_ST ) );
	  break;

	case 2:
	  /* this instruction is an LH0 r2r, r1r */
	  
	  outinstr( FUNC_LOAD << 28 | OP_LH << 24 | 0x0U << 23 | ADDR_MODE_REGISTER << 21 |
		   hardware_register( r1r ) << 16 | hardware_register( r2r ),
		   examines1( r2r ),
		   alters2( r1r, RR_ST ) );
	  break;
	  
	default:
	  syserr( syserr_unknown_sign_extend_mode, m );
	  break;
	}
      
      break;
#endif /* TARGET_HAS_SIGN_EXTEND */

#ifdef TARGET_HAS_DEBUGGER
    case J_INFOLINE:
      flush_peepholer( DBG( "J_INFOLINE" ) );

      debugger_add_line( m );

      do_notify_command( m, vr2.str );

      break;

    case J_INFOBODY:
      break;

    case J_INFOSCOPE:
      break;
      
#endif /* TARGET_HAS_DEBUGGER */

    case J_WORD:
      flush_peepholer( DBG( "inline op code" ) );
      
      outinstr( m, examines0(), alters2( RR_R0, RR_ST ) );

      flush_peepholer( DBG( "inline op code" ) );

      break;
      
    default:
      syserr( syserr_show_inst, (long)op );
      
      nop( FALSE );		/* placeholder */

      break;
    }

#ifdef TARGET_HAS_COND_EXEC
  if (pending_condition != Q_AL)
    {
      syserr( syserr_cond_exec, opm );
    }
#endif /* TARGET_HAS_COND_EXEC */
  
  return;
  
} /* show_instruction */


/* the next routine is required for the machine independent codebuf.c */

void
branch_round_literals( LabelNumber * m )
{
  conditional_branch_to( Q_AL, m );
    
  return;
    
} /* branch_round_literals */


void
mcdep_init( void )
{
  peep_init();

  if (usrdbg( DBG_ANY ))
    saved_regs = sym_insert( "saved_regs", s_identifier );
  
  return;
    
} /* mcdep_init */


void
localcg_tidy( void )
{
  peep_tidy();

  if (usrdbg( DBG_ANY ))
    saved_regs = NULL;
  
  return;
    
} /* localcg_tidy */

void
localcg_reinit( void )
{
  return;
    
} /* localcg_reinit */


/* returns YES if the Jopcode would alter the condition code register */

bool
alterscc( Icode * ic )
{
  switch (ic->op & ~(Q_MASK|J_DEADBITS))
    {
    case J_STACK:
    case J_STRDK:
    case J_STRFK:
    case J_STRK:
    case J_STRWK:
    case J_STRBK:
    case J_STRDR:
    case J_STRFR:
    case J_STRR:
    case J_STRWR:
    case J_STRBR:
    case J_PUSHM:
    case J_PUSHF:
    case J_PUSHD:
    case J_MOVR:
    case J_MOVFR:
    case J_MOVDR:
    case J_MOVFDR:
      return NO;

    default:
      return YES;      
    }
  
} /* alterscc */


/* returns YES if the Jopcode is suitable for conditional execution */

bool
can_cond_exec( Icode * ic )
{
  switch (ic->op & ~(Q_MASK|J_DEADBITS))
    {
    case J_MOVDFR:
    case J_MOVFDR:
    case J_MOVDR:
    case J_MOVFR:
    case J_MOVR:
    case J_MOVK:
      return YES;

    case J_MOVDK:
    case J_MOVFK:
      return fpliteral( ic->m.f, ic->op );
      
    default:
      return NO;      
    }
  
} /* can_cond_exec */

/* End of  mbe/gen.c */
@


1.266
log
@fixed stack extension to use unsigned compares
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/gen.c,v 1.265 1993/08/05 08:30:15 nickc Exp nickc $ */
d10635 1
a10635 1
	  bool		must_save = TRUE;
d10648 1
a10648 1
	      
d10654 1
a10654 1
		  must_save = TRUE;
d10657 1
a10657 1
		  dpush( dst );
d10659 5
a10663 1
		  move_register( dst, R_TMP2, FALSE, TRUE );
d10699 1
a10699 1
	  if (must_save)
d10702 1
a10702 1
	      dpop( dst );
d10704 1
a10704 1
	      move_register( R_TMP2, dst, FALSE, TRUE );
@


1.265
log
@reduced code size
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/gen.c,v 1.264 1993/08/04 16:59:12 nickc Exp nickc $ */
d23 1
a23 1
 *	+ all op codes are 32 bits wide
d25 1
a25 1
 *	+ all op codes except CALL (jump to subroutine) and B (branch) take 1 instruction cycle
d27 1
a27 1
 *	+ the chip only supports word addressing and has a 16 gigabyte range (where 1 byte = 8 bits)
d29 1
a29 1
 *	+ the machine shares floating point and integer registers, and has seperate address registers
d31 1
a31 1
 *	+ the instruction set has delayed branches (delayed for 3 instructions) and link-and-jump instructions
d33 2
a34 2
 *	+ we are using byte addressing where addresses are a byte offset from register IR0
 *        (in this case a byte is an 8 bit quantity)
d36 5
a40 5
 *	+ the instruction set is a fairly standard RISC set except that:
 *		- it has diadic and triadic versions of most operations
 *		- triadic ops can sometimes be done in parallel with a load or store
 *		- floating point is not IEEE standard, but instructions exist to convert between formats
 *		- there is a "repeat single instruction" and "repeat block of instructions" mode
d6678 9
d6688 1
a6688 1
	      conditional_branch_to( Q_LT, stack_ok );
d6691 1
a6691 1
	  conditional_load( Q_GE, ADDR_MODE_REGISTER, R_TMP3, R_LR,
d6699 1
a6699 1
	      conditional_load( Q_GE, ADDR_MODE_IMMEDIATE, R_TMP2, require,
d6705 1
a6705 1
	  conditional_load( Q_GE, ADDR_MODE_IMMEDIATE, R_TMP1, already_placed,
d6714 1
a6714 1
	      outdelsymref( (OP_LAJc << 24) | 0x1U << 21 | C_FROMQ( Q_GE ) << 16 | (-3 & 0x0000ffffU),
d6753 1
a6753 1
	      conditional_branch_to( Q_LT, stack_ok );
d6758 1
a6758 1
	  conditional_load( Q_GE, ADDR_MODE_REGISTER, R_TMP3, R_LR,
d6764 1
a6764 1
	  conditional_load( Q_GE, ADDR_MODE_IMMEDIATE, R_TMP2, 0,
d6770 1
a6770 1
	  conditional_load( Q_GE, ADDR_MODE_REGISTER, R_TMP1, already_placed,
d6780 1
a6780 1
	      outdelsymref( (OP_LAJc << 24) | 0x1U << 21 | C_FROMQ( Q_GE ) << 16 | (-3 & 0x0000ffffU),
d6796 1
a6796 1
	    }	  
@


1.264
log
@made strings passed in flush_peepholer only appear on debugging
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/gen.c,v 1.263 1993/08/04 10:53:30 nickc Exp nickc $ */
d6598 1
a6598 1
      LabelNumber *	stack_ok;
@


1.263
log
@oops - fixed bugs in new stack extend code
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/gen.c,v 1.262 1993/08/03 15:24:05 nickc Exp nickc $ */
d188 1
a188 1
  flush_peepholer( "delayed instruction" );
d215 1
a215 1
  flush_peepholer( "delayed instruction" );
d261 1
a261 1
  flush_peepholer( "delayed instruction" );
d3360 1
a3360 1
      flush_peepholer( "backward conditional branch" );
d3972 1
a3972 1
      flush_peepholer( "about to emit a LAJ" );
d3978 1
a3978 1
      flush_peepholer( "getting address of LAJ (2)" );
d4001 1
a4001 1
      flush_peepholer( "LAJ bug" );
d4125 1
a4125 1
      flush_peepholer( "symbol address" );
d4379 1
a4379 1
	  flush_peepholer( "symbol address 2" );
d4741 1
a4741 1
      flush_peepholer( "why" );
d4747 1
a4747 1
      flush_peepholer( "hmm" );
d4757 1
a4757 1
      flush_peepholer( "why not" );      
d4858 1
a4858 1
  flush_peepholer( "start of function exports" );
d4868 1
a4868 1
  flush_peepholer( "call used in preparing for exports" );
d4892 1
a4892 1
  flush_peepholer( "LAJ bug 1" );
d5131 1
a5131 1
  flush_peepholer( "do not swap this LAJ backwards" );
d5139 1
a5139 1
  flush_peepholer( "getting hold of PC" );
d5257 1
a5257 1
      flush_peepholer( "block data init" );
d5403 1
a5403 1
	      flush_peepholer( "save out LAJs" );
d5411 1
a5411 1
	      flush_peepholer( "getting address of LAJ" );
d5766 1
a5766 1
  /*  flush_peepholer( "calling another function" ); */
d5938 1
a5938 1
  flush_peepholer( "notify_entry" );
d5997 1
a5997 1
  flush_peepholer( "protect LAJ" );
d6547 1
a6547 1
  flush_peepholer( "start of function" );
d6710 1
a6710 1
	      flush_peepholer( "stack size checking code" );
d6716 1
a6716 1
	      flush_peepholer( "stack size checking code" );
d6761 1
a6761 1
	  conditional_load( Q_GE, ADDR_MODE_REGISTER, R_TMP1, already_used,
d6776 1
a6776 1
	      flush_peepholer( "stack size checking code" );
d6782 1
a6782 1
	      flush_peepholer( "stack size checking code" );
d6838 1
a6838 1
  flush_peepholer( "notify_leave" );
d6889 1
a6889 1
  flush_peepholer( "protect LAJ again" );
d6972 1
a6972 1
	  flush_peepholer( "routine_exit" );
d7180 1
a7180 1
      flush_peepholer( "end of function" );
d7637 1
a7637 1
      flush_peepholer( "force RC flush" );
d7683 1
a7683 1
      flush_peepholer( "end of repeat block" );
d7910 1
a7910 1
      flush_peepholer( "copy_memory" );
d7988 1
a7988 1
      flush_peepholer( "copy memory" );
d9104 1
a9104 1
      flush_peepholer( "unsigned fix" );
d9219 1
a9219 1
  flush_peepholer( "notify_command" );
d9325 1
a9325 1
      flush_peepholer( "calculating position" );
d9877 1
a9877 1
      flush_peepholer( "tailcall" );
d9921 1
a9921 1
      flush_peepholer( "tailcall R" );
d9948 1
a9948 1
	  flush_peepholer( "emitting count" );
d10005 1
a10005 1
	      flush_peepholer( "j_label" );
d10089 1
a10089 1
	  flush_peepholer( "paranoid, moi?" );
d10097 1
a10097 1
	  flush_peepholer( "getting hold of PC" );
d10182 1
a10182 1
	  flush_peepholer( "switch table 2" );
d10199 1
a10199 1
	  flush_peepholer( "switch table 3" );
d10221 1
a10221 1
	  flush_peepholer( "generating switch table" );
d10255 1
a10255 1
	  flush_peepholer( "generating switch table 2" );
d11734 1
a11734 1
	  flush_peepholer( "J_ENDPROC" );
d11741 1
a11741 1
      flush_peepholer( "end of procedure" );
d11887 1
a11887 1
      flush_peepholer( "J_INFOLINE" );
d11904 1
a11904 1
      flush_peepholer( "inline op code" );
d11908 1
a11908 1
      flush_peepholer( "inline op code" );
@


1.262
log
@improved stack checking entry code (saves 2 words in most cases)
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/gen.c,v 1.261 1993/07/29 13:35:35 nickc Exp nickc $ */
d6681 4
a6684 2
	  
	  move_register( R_LR, R_TMP3, FALSE );
d6690 1
a6690 1
	      conditional_load( Q_LT, ADDR_MODE_IMMEDIATE, R_TMP2, require,
d6696 1
a6696 1
	  conditional_load( Q_LT, ADDR_MODE_IMMEDIATE, R_TMP1, already_placed,
d6705 1
a6705 1
	      outdelsymref( (OP_LAJc << 24) | 0x1U << 21 | C_FROMQ( Q_LT ) << 16 | (-3 & 0x0000ffffU),
d6749 4
a6752 2
	  move_register( R_LR, R_TMP3, FALSE );

d6755 4
a6758 2
	  load_integer( R_TMP3, 0, FALSE );

d6761 3
a6763 1
	  load_integer( R_TMP2, already_placed, FALSE );
d6771 1
a6771 1
	      outdelsymref( (OP_LAJc << 24) | 0x1U << 21 | C_FROMQ( Q_LT ) << 16 | (-3 & 0x0000ffffU),
@


1.261
log
@fixed routine entry code
@
text
@d1 1
a1 1
/* C compiler file c40/gen.c :  Copyright (c) Perihelion Software Ltd, 1991, 1992.     */
d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/gen.c,v 1.260 1993/07/27 11:12:49 nickc Exp nickc $ */
d6621 1
a6621 1
       * will always have 50 words of stack available to us
d6624 1
a6624 1
      if (require > 50 || ((procflags & BLKCALL) && require > 0))
d6626 3
d6637 3
a6639 3
	      
	      out_triadic_op( OP_SUBI3, R_TMP1, R_SP, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			     examines2( R_TMP2, R_SP ),
d6642 1
a6642 1
	  else
d6644 1
a6644 1
	      out_triadic_op( OP_SUBI3, R_TMP1, R_SP, require,
d6647 13
a6659 1
			     alters2( R_TMP1, RR_ST ) );
d6664 2
a6665 2
	  out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, R_SE, R_TMP1,
			examines2( R_TMP1, R_SE ),
d6668 13
a6680 3
	  /* ... then skip the next few instructions */
	  
	  stack_ok = nextlabel();
d6682 1
a6682 1
	  conditional_branch_to( Q_LT, stack_ok );
a6683 2
	  move_register( R_LR, R_TMP3, FALSE, TRUE );
	  
d6688 2
a6689 1
	      load_integer( R_TMP2, require, FALSE );
d6691 1
a6691 1
	  
d6693 4
a6696 3
	  
	  load_integer( R_TMP1, already_placed, FALSE );
	  
d6698 17
d6716 4
a6719 7
	  call( stackoverflow, FALSE );
	  
	  flush_peepholer( "stack size checking code" );
	  
	  /* on return from this function R_SP, R_LR and R_SE will have been set up */
	  
	  setlabel( stack_ok );
d6735 6
d6742 3
a6744 6
	  stack_ok = nextlabel();
	  
	  /* if we are OK skip the next bit */
	  
	  conditional_branch_to( Q_LT, stack_ok );
	  
d6747 2
a6748 2
	  move_register( R_LR, R_TMP3, FALSE, TRUE );
	  
d6752 1
a6752 1
	  
d6756 1
a6756 1
	  
d6758 17
d6776 4
a6779 7
	  call( stackoverflow, FALSE );
	  
	  flush_peepholer( "stack size checking code" );
	  
	  /* on return from this function R_SP, R_LR and R_SE will have been set up */
	  
	  setlabel( stack_ok );
@


1.260
log
@fixed FP temp reg usage
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/gen.c,v 1.259 1993/07/27 09:19:19 nickc Exp nickc $ */
d107 4
a110 4
static bool		saved_frame        = FALSE;	/* true if frame pointer saved on stack		*/
static int32		saved_ivars        = 0;		/* mask of variable registers saved on stack	*/
static int32		saved_fvars        = 0;		/* mask of variable registers saved on stack	*/
static int32		saved_args         = 0;		/* mask of argument registers saved on stack 	*/
d114 1
a114 1
static Symstr *		saved_regs         = NULL;	/* register saving structure used by debugger */
d5948 2
a5949 2
  save_mask  = regbit( R_A1 + NARGREGS ) - regbit( R_A1 );

d6430 4
a6433 5
  int32	n        = 0;
  int32	mask     = 0;
  int32	fmask    = 0;
  int32	maskarg  = 0;
  int32 num_args = 0;
d6444 5
a6448 5
      saved_ivars = 0;
      saved_fvars = 0;
      saved_args  = 0;
      saved_frame = 0;
      stack_move  = 0;
d6462 4
a6465 3
   * n 		- is the number of arguments we have in registers
   * mask 	- is a bit mask of registers used by this function which MUST be saved before use
   * maskarg	- is a bit mask of the argument registers that must be saved (since their address will be used)
d6468 2
a6469 11
  num_args = k_argwords_( arg_mask );
  
  n = (num_args <= NARGREGS) ? num_args : NARGREGS;

  /*
   * note that the compiler is paranoid - even if only
   * one argument has its address taken then it will ask
   * us to save all of the arguments on the stack - such is life
   */
  
  mask = usedmaskvec.map[ 0 ] & M_VARREGS;
d6485 1
a6485 1
      mask |= regbit( R_LR );
d6488 5
a6492 7
  /* remember FP variable registers */
  
  fmask = usedmaskvec.map[ 0 ] & M_FVARREGS;

#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
  mask &= ~fmask;		/* do not save integer vars if they are going to be saved as FP vars */  
#endif
d6496 2
a6497 24
#if NFLTARGREGS > 0
      int32	fn;
#endif
      
      /*
       * XXX
       *
       * since we do not know if an argument is a
       * floating point or integer argument, we have
       * to assume the worst case for both types.
       *
       * Note, however that since we share integer and
       * floating point argument registers, we only need
       * to save the intersection of masks for the two
       * types.
       */

      maskarg  = regbit( R_A1 + n ) - regbit( R_A1 );

#if NFLTARGREGS > 0
      fn = (((n <= NFLTARGREGS) ? n : NFLTARGREGS) + sizeof_float / sizeof_int ) / (sizeof_double / sizeof_int);
      
      maskarg |= regbit( R_FA1 + fn ) - regbit( R_FA1 );
#endif
d6515 4
a6518 3
      maskarg |= regbit( R_A1 + NARGREGS ) - regbit( R_A1 );
      mask    |= M_VARREGS;
      fmask   |= M_FVARREGS;
d6522 3
a6524 2
  /* peepf( "num_args = %d, register masks: used = %x, var = %x, FP var = %x, args = %x",
       num_args, usedmaskvec.map[ 0 ], mask, fmask, maskarg ); */
d6555 1
a6555 1
  if (maskarg)
d6557 1
a6557 1
      save_regs( maskarg, FALSE );
d6560 5
d6569 4
a6572 3
  if (num_args > NARGREGS ||		/* if we have arguments passed on the stack 	 */
      maskarg             ||		/* or we have had to save arguments on the stack */
      backtrace_enabled    )		/* or we are supporting back traces		 */
d6574 1
a6574 1
      /**/                              /* then we must save old frame pointer */
d6605 1
a6605 1
      already_placed = bitcount( maskarg ) + (saved_frame ? 1 : 0);
d6610 1
a6610 1
       * XXX for some reason the front end does always get the greatest depth correct
d6614 1
a6614 1
      require = greatest_stackdepth / sizeof_int + bitcount( mask ) + bitcount( fmask ) * 2;
d6634 1
a6634 1

d6646 1
a6646 1

d6648 1
a6648 1

d6652 1
a6652 1
      
d6654 1
a6654 1

d6656 1
a6656 1
      
d6658 1
a6658 1

d6662 1
a6662 1

d6667 1
a6667 1

d6669 1
a6669 1

d6671 1
a6671 1

d6673 1
a6673 1

d6675 1
a6675 1

d6679 1
a6679 1

d6696 1
a6696 1

d6698 1
a6698 1

d6702 1
a6702 1

d6706 1
a6706 1

d6710 1
a6710 1

d6714 1
a6714 1

d6716 1
a6716 1

d6718 1
a6718 1

d6722 1
a6722 1

d6732 1
a6732 1
  if (mask)
d6734 1
a6734 1
      save_regs( mask, FALSE );
d6746 1
a6746 1
  saved_ivars = mask;
d6748 1
a6748 1
  saved_args  = maskarg;
d7094 1
a7094 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, bitcount( saved_args ) + (saved_frame ? 1 : 0),
@


1.259
log
@replaced syserr strings with string constants
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/gen.c,v 1.258 1993/07/22 10:05:15 nickc Exp nickc $ */
d5107 1
a5107 1
  move_register( R_LR, R_FT1, FALSE, TRUE );
d5109 1
a5109 1
  saved_link_reg = R_FT1;
d6995 1
a6995 1
		   * If we pull the link register into one of R0 - R7
d7001 1
a7001 1
		  
d7008 1
d7012 6
a7017 1
		    link_reg = R_FT1 + 1;	
d9530 1
d9536 1
a9536 1

d9538 1
d9548 1
d9561 4
a9564 1
		  bottom = R_FV1 + 1;	/* XXX beware of assumption that NFLTVARREGS > 1 */
d9567 3
a9569 1
	  else if (top != R_FV1)
d9575 4
a9578 1
	      bottom = R_FV1 + 1;	/* XXX beware of assumption that NFLTVARREGS > 1 */
d9597 1
d9604 2
a9605 1

@


1.258
log
@fixed calculating number of arguments passed to a function
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/gen.c,v 1.257 1993/07/19 11:23:21 nickc Exp nickc $ */
d331 1
a331 1
    syserr( "back end: hardware_register: trying to evaluate illegal register 0x%lx", r );
d396 1
a396 1
    syserr( "back end: real_register: trying to evaluate illegal register 0x%lx", r );
d459 1
a459 1
      syserr( "back end: build_op: bad addressing mode %ld\n", addressing_mode );
d593 1
a593 1
		  syserr( "back end: illegal displacement in indirect/indirect triadic addressing\n" );
d615 1
a615 1
		      syserr( "back end: illegal displacement (non-0) in indirect triadic addressing\n" );
d620 1
a620 1
		  syserr( "back end: illegal displacement (not 1) in indirect triadic addressing\n" );
d645 1
a645 1
		  syserr( "back end: immediate value too large for signed triadic immediate addressing\n" );
d652 1
a652 1
		  syserr( "back end: immediate value too large for unsigned triadic immediate addressing\n" );
d665 1
a665 1
	  syserr( "back end: unknown kind of triadic addressing %d\n", source2_type );
d680 1
a680 1
		  syserr( "back end: illegal displacement (non-0) in indirect triadic addressing\n" );
d685 1
a685 1
	      syserr( "back end: illegal displacement (not 1) in indirect triadic addressing\n" );
d710 1
a710 1
		  syserr( "back end: displacement out of range for indirect/indirect triadic\n" );
d733 1
a733 1
		      syserr( "back end: illegal displacement (non-0) in indirect triadic addressing\n" );
d738 1
a738 1
		  syserr( "back end: illegal displacement (not 1) in indirect triadic addressing\n" );
d747 1
a747 1
		      syserr( "back end: illegal displacement (non-0) in indirect triadic addressing\n" );
d752 1
a752 1
		  syserr( "back end: illegal displacement (not 1) in indirect triadic addressing\n" );
d773 1
a773 1
	      syserr( "back end: illegal indirect triadic addressing mode\n" );
d780 1
a780 1
	      syserr( "back end: triadic displacement out of range\n" );
d802 1
a802 1
	  syserr( "back end: unknown kind of triadic addressing %d\n", source2_type );
d808 1
a808 1
      syserr( "back end: out_triadic_op: what is this mess? %d\n", source1_type );
d1089 1
a1089 1
    syserr( "back end: trying to float push a non-floating point register %x", reg );
d1110 1
a1110 1
    syserr( "back end: trying to float pop a non-floating point register %x", reg );
d1131 1
a1131 1
    syserr( "back end: trying to double push a non-floating point register %x", reg );
d1158 1
a1158 1
    syserr( "back end: trying to double pop a non-floating point register %x", reg );
d1303 1
a1303 1
	syserr( "back end: trying to add a non-word offset to a word pointer" );
d1559 1
a1559 1
    syserr( "back end: trying to perform a floating point operation with a non floating point source" );
d1562 1
a1562 1
    syserr( "back end: trying to perform a floating point operation with a non floating point destination" );
d1569 1
a1569 1
      syserr( "back end: float_immediate_op: asked to perform an op with an FP value that does not fit" );
d1667 2
a1668 1
  
d1671 1
a1671 1
      syserr( "back end: compare_float: asked to perform void comparision" );
d1673 1
d1681 1
a1681 1
      syserr( "back end: compare_float: asked to compare with a floating point value that does not fit" );
d1719 1
a1719 1
      syserr( "back end: trying to load floating point constant into a non-floating point register %d", r );
d1909 1
a1909 1
	syserr( "back end: offset register conflict" );
d2053 1
a2053 1
	    syserr( "back end: offset register conflict" );
d2153 1
a2153 1
    syserr( "back end: load_double_relative: trying to load a double into a non-floating point register" );
d2408 1
a2408 1
    syserr( "back end: store_double_relative: trying to store a double from a non-floating point register" );
d2773 1
a2773 1
    syserr( "back end: load_double_indirect: trying to load a double into a non-floating point register" );
d2877 1
a2877 1
    syserr( "back end: store_double_indirect: trying to store a double from a non-floating point register" );
d3007 1
a3007 1
    syserr( "back end: stack move by a non-multiple of %d", sizeof_long );
d3057 1
d3060 1
a3060 1
      syserr( "back end: compare_integer: asked to perform void comparision" );
d3062 1
d3278 1
a3278 2
      syserr( "back end: conditional_skip_instructions: too many instructions to skip! (%ld)",
	     num_to_skip );
d3382 1
a3382 1
	  syserr( "back end: cannot conditionally branch to offset %lx", off );
d3529 10
a3538 2
  if (symdata_( name ) != 0)
    return (bindstg_( symdata_( name ) ) & bitofstg_( s_static ) );
d3737 1
d3741 3
a3743 2
    syserr( "gen.c: is_function: passed a NULL pointer" );

d3747 1
a3747 1
    syserr( "gen.c: is_function: not passed an identifier" );
d3749 1
a3749 1
   /* __dataseg has no data associated with it */
d3770 1
a3770 1
  if ((data = symdata_( symbol )) == NULL)
d3817 1
a3817 1
      syserr( "back end: loading stack pointer with a constant address is not yet supported" );
d3948 1
d3952 3
a3954 2
	syserr( "back end: load_address_constant: trying to take address of non-function!" );

d4009 1
d4011 2
a4012 2
	syserr( "back end: load_address_constant: function pointer not word aligned!" );

d4017 1
d4019 3
a4021 2
	syserr( "back end: load_address_constant: offset from function pointer not word aligned!" );

d4090 1
a4090 1
	syserr( "back end: load_address_constant: it is illegal to take an offset from a function pointer" );
d4167 1
a4167 1
	  syserr( "back end: load_address_constant: cannot take offset from function pointer\n" );
d4462 1
a4462 2
		syserr( "back end: load_address_constant: cannot take an offset from function pointer %s",
		       symname_( symbol ) );
d4535 1
a4535 1
		  syserr( "back end: external data: offset too big (offset = %ld)", offset );
d5017 1
a5017 1
	  syserr( "back end: assembly code output is missing a patch directive\n" );
d5173 1
a5173 1
      syserr( "back end: block_data_init: no data to init (%ld)", num_words_to_copy );
d5275 1
a5275 1
    syserr( "gen: asked to store 0 into already zero'ed memory" );
d5386 1
a5386 1
	syserr( "back end: export_data_symbol: cannot take an offset from a function pointer!" );
d5423 1
a5423 1
	  
d5425 2
a5426 2
	    syserr( "back end: export_data_symbol: function pointer '%s' not word aligned!", symname_( name ) );
	  
d5545 1
a5545 1
	syserr( "back end: export_data_symbol: asked to export non-data: %s", symname_( name ) );
d5639 1
a5639 1
	      syserr( "back end: cannot initialise large data offset" );
d5755 1
d5758 1
a5758 1
	  syserr( "back end: call: function call to %s whilst generating a stub", symname_( name ) );      
d5760 1
a5760 1

d5810 1
a5810 1
	  syserr( "back end: cannot call to offset %lx", off );
a6600 3
      debug( "saving FP, num_args = %d, maskarg = %x, backtrace = %d",
	    num_args, maskarg, backtrace_enabled );
      
d7285 1
a7285 1
      syserr( "back end: trying to set an already set label!" );
d7675 1
a7675 1
    syserr( "back end: copying less than 4 bytes of memory (%ld)", length );
d7678 1
a7678 1
    syserr( "back end: copy memory asked to copy a non word multiple %ld", length );
d8223 1
a8223 1
	syserr( "back end: urg - this should not happen" );
d8848 1
a8848 1
      syserr( "back end: trying a fix a non floating point register" );
d8948 1
a8948 1
      syserr( "back end: unsigned FIX not supported" );
d9171 1
a9171 1
      syserr( "gen.c: failed to initialise saved_regs" );
d9797 1
a9797 1
	syserr( "back end: CALLK stack mis-aligned\n" );
d9814 1
a9814 1
	    syserr( "back end: TAILCALLK stack mis-aligned\n" );
d9830 1
a9830 1
	syserr( "back end: CALLR stack mis-aligned\n" );
d9857 1
a9857 1
	syserr( "back end: TAILCALLR stack mis-aligned\n" );
d9970 1
a9970 2
	    syserr( "back end: branch %lx does not match pending condition %lx\n",
		   pending_condition, op & Q_MASK );
d10252 1
d10254 2
a10255 2
	    syserr( "cannot do fast conditional compares" );
	  
d10449 1
a10449 1
	syserr( "back end: trying to move a float from a non float register" );
d10452 1
a10452 1
	syserr( "back end: trying to move a float to a non float register" );
d10501 1
a10501 1
	  syserr( "back end: trying to move an integer into a non-floating point register" );
d10521 1
a10521 1
	  syserr( "back end: trying to move an integer into a non-floating point register" );
d10558 1
a10558 1
	  syserr( "back end: trying a float to a non floating point register" );
d10687 1
a10687 1
	  syserr( "back end: trying a floating point negate on a non floating point register" );
d10746 1
a10746 1
	    syserr( "back end: trying to conditionally load a non-suitable float" );
d10774 1
a10774 1
	    syserr( "back end: trying to conditionally load a non-suitable float" );
d10892 1
a10892 1
	    syserr( "back end: trying to subtract a non-word offset from a word pointer" );
d10996 1
a10996 1
	    syserr( "back end: trying to add a non-word offset to a word pointer" );
d11160 6
a11165 1
      if (!is_float( r1r ) || !is_float( mr ) || !is_float( r2r ))
d11167 1
a11167 1
	  syserr( "back end: floating point add given illegal register" );
d11203 6
a11208 1
      if (!is_float( r1r ) || !is_float( mr ) || !is_float( r2r ))
d11210 1
a11210 1
	  syserr( "back end: floating point subtract given illegal register" );
d11244 6
a11249 1
      if (!is_float( r1r ) || !is_float( mr ) || !is_float( r2r ))
d11251 1
a11251 1
	  syserr( "back end: floating point multiply given illegal register" );
d11749 1
a11749 1
	  syserr( "back end: trying to (float) push a non-floating point register %d\n", r1r );
d11759 1
a11759 1
	  syserr( "back end: trying to (double) push a non-floating point register %d\n", r1r );
d11798 1
a11798 1
	  syserr( "back end: sign extend byte to short not yet supported" );
d11820 1
a11820 1
	  syserr( "back end: unknown sign extend mode %ld", m );
d11865 1
a11865 1
      syserr( "back end: attempted to conditionally execute J_opcode %ld\n", opm );
@


1.257
log
@fixed encoding of special case negative numbers in FP constants, and FP register moving
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/gen.c,v 1.256 1993/07/15 16:47:51 nickc Exp nickc $ */
d3481 1
a3481 1
  offset += symext_( symbol )->extoffset;
d3490 1
a3490 1
  for (; r != NULL; r = r->extcdr)
d3492 1
a3492 1
      if (is_data( r ) && is_local( r ))
d3494 1
a3494 1
	  unsigned long	diff = abs( r->extoffset - offset );
d3497 5
a3501 1
	  /* debug( "checking symbol %s, offset %d, diff %d", symname_( r->extsym ), r->extoffset, diff ); */
d3511 1
a3511 1
  /* debug( "result is %s", least == NULL ? "nothing" : symname_( least->extsym ) ); */
d3513 1
a3513 1
  return least == NULL ? NULL : least->extsym ;
d3818 1
a3818 1
      if (suppress_module || !fits_in_16_bits_signed( offset + x->extoffset ))
d3829 1
a3829 1
	      offset += symext_( symbol )->extoffset - symext_( newsymbol )->extoffset;		  
d3835 1
a3835 1
      if (suppress_module || !fits_in_16_bits_signed( offset + x->extoffset ))
d3911 1
a3911 1
	  offset += x->extoffset;
d6410 1
a6410 1
routine_entry( int32 num_args )
d6416 1
d6437 1
a6437 1
  /* check the number of arguments passed to this function */
d6439 1
a6439 1
  if (num_args < 0)
d6441 1
a6441 3
      syserr( syserr_enter, num_args );

      num_args = 0;
d6450 2
d6582 3
@


1.256
log
@minor comment improvements
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/gen.c,v 1.255 1993/07/09 10:49:52 nickc Exp nickc $ */
d1020 12
a1031 3
	  conditional_load( Q_AL, ADDR_MODE_REGISTER, dest, source,
			   examines1( source ),
			   alters1( dest ) );
d1481 2
a1482 2
      int32	high;
      int32	low;
d1485 1
a1485 1
      high = IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &low );
d1492 3
a1494 2
      if ((low & 0xfffff) == 0 &&
	  (((high & 0xf8000000U) == 0) || ((high & 0xf8000000U) == 0xf8000000U)))
d1501 1
a1501 1
      int32		val;
d1504 1
a1504 2
      val = IEEE_to_single_float( fc->floatbin.fb.val );

d1511 3
a1513 1
      if (((val & 0xfff) == 0) && (((val & 0xf8000000U) == 0) || ((val & 0xf8000000U) == 0xf8000000U)))
d1712 2
d1721 9
a1729 1
  if (is_double)
d1731 2
a1732 2
      int32	high;
      int32	low;
d1734 16
a1749 2

      /* convert IEEE number to C40 format */
d1751 1
a1751 1
      high = IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &low );
d1753 1
a1753 1
      /* catch 0.0 */
d1755 1
a1755 8
      if (low == 0 && high == 0x80000000U)
	{	  
	  out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r, 0x8000,
			examines0(),
			alters2( r, RR_ST ) );
	}      
      else if ((low & 0xfffff) == 0 &&
	       (((high & 0xf8000000U) == 0) || ((high & 0xf8000000U) == 0xf8000000U)))
d1757 4
a1760 2
	  out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r, (high >> 12),
			examines0(),
a1762 29
      else
	{
	  /*
	   * Other op codes we could try ....
	   *
	   * FLOAT, LDE, LDM, RND, FLOAT
	   */
  
	  /* load high part of FP number */
	  
	  load_integer( R_TMP1, high, FALSE );

	  /* save as integer */
	  
	  ipush( R_TMP1 );

	  /* pop as FP */
	  
	  fpop( r );

	  if (low & 0xFF)
	    {
	      /* OR in low part of FP number */
	  
	      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, r, low & 0xFF,
			    examines1( r ),
			    alters2( r, RR_ST ) );
	    }
	}
d1766 2
a1767 2
      int32		val;
  
d1769 1
a1769 1
      /* convert IEEE number to C40 format */
a1771 2

      /* catch 0.0 */
d1773 1
a1773 16
      if (val == 0x80000000U)
	{
	  out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r, 0x8000,
			examines0(),
			alters2( r, RR_ST ) );
	}
      else if (((val & 0xfff) == 0) &&
	       (((val & 0xf8000000U) == 0) || ((val & 0xf8000000U) == 0xf8000000U)))
	{
	  out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r, (val >> 12),
			examines0(),
			alters2( r, RR_ST ) );
	}
      else
	{
	  /* load high part of FP number */
d1775 1
a1775 1
	  load_integer( R_TMP1, val, FALSE );
d1777 7
a1783 8
	  /* save as integer */
	  
	  ipush( R_TMP1 );

	  /* pop as FP */
	  
	  fpop( r );
	}
@


1.255
log
@fixed (I hope) conditional execution of load statements
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/gen.c,v 1.254 1993/07/08 12:35:05 nickc Exp nickc $ */
d4162 1
a4162 1
	  syserr( "back end: load_address_constant: taking offset from function pointer - this does not work\n" );
d4184 1
a4184 1
       *   LDI   *+R_MT( modnum ), R_ATMP	- get the function table pointer into temporary address register
d4198 1
a4198 1
       * NB/ IF we know that the module table is at a fixed offset from IR0 then we could do :-
d4200 1
a4200 1
       *   LDI   modnum + offset_of_MT, R_ATMP	- get offset of module table plus offset of module table pointer
d4213 1
a4213 1

d4220 1
a4220 1

d4222 1
a4222 1

d4224 1
a4224 1

d4230 1
a4230 1

d4232 1
a4232 1

d4240 1
a4240 1
 
d4242 1
a4242 1

d4252 1
a4252 1

d4254 1
a4254 1

d4262 1
a4262 1

d4268 1
a4268 1

@


1.254
log
@oops, forgot a return statement at end of conditional execution switch
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/gen.c,v 1.253 1993/07/08 08:26:52 nickc Exp nickc $ */
d992 2
a993 1
	      bool		floating )
d1003 8
a1010 3
	  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, dest, source,
			examines1( source ),
			alters2( dest, RR_ST ) );
d1018 6
d1310 1
a1310 1
	      move_register( source, dest, FALSE );
d1843 1
a1843 1
	      move_register( ar, dest, FALSE );
d1865 1
a1865 1
		  move_register( ar, dest, FALSE );
d3138 1
a3138 1
      move_register( source, dest, FALSE );
d3208 1
a3208 1
      move_register( source, dest, FALSE );
d3652 1
a3652 1
      move_register( R_MT, tmp, FALSE );
d3962 1
a3962 1
	      move_register( R_LR, R_TMP2, FALSE );
d3966 1
a3966 1
	      move_register( R_LR, R_TMP1, FALSE );
d4003 1
a4003 1
      move_register( R_LR, dest, FALSE );
d4047 1
a4047 1
	      move_register( R_TMP2, R_LR, FALSE );
d4051 1
a4051 1
	      move_register( R_TMP1, R_LR, FALSE );
d4093 1
a4093 1
	  move_register( R_LR, R_TMP1, FALSE );
d4138 1
a4138 1
	  move_register( R_TMP1, R_LR, FALSE );
d4223 1
a4223 1
      move_register( R_MT, dest, FALSE );
d4271 1
a4271 1
	  move_register( dest, real_dest, FALSE );
d4347 1
a4347 1
	      move_register( R_LR, R_TMP1, FALSE );
d4392 1
a4392 1
	      move_register( R_TMP1, R_LR, FALSE );
d4421 1
a4421 1
	      move_register( R_MT, tmp, FALSE );
d4484 1
a4484 1
		      move_register( R_LR, R_TMP2, FALSE );
d4501 1
a4501 1
		  move_register( R_ATMP, dest, FALSE );
d4509 1
a4509 1
		      move_register( R_TMP2, R_LR, FALSE );
d4621 1
a4621 1
      move_register( R_LR, R_TMP1, FALSE );
d4665 1
a4665 1
      move_register( R_TMP1, R_LR, FALSE );
d4858 1
a4858 1
  move_register( R_LR, R_DS, FALSE );
d4899 1
a4899 1
  move_register( R_LR, R_ADDR1, FALSE );
d4908 1
a4908 1
  move_register( R_DS, R_LR, FALSE );
d5103 1
a5103 1
  move_register( R_LR, R_FT1, FALSE );
d5459 1
a5459 1
	      move_register( R_MT, R_DS, FALSE );
d5501 1
a5501 1
	      move_register( R_ATMP, R_DS, FALSE );
d5509 1
a5509 1
	      move_register( R_ATMP, VAL_REG, FALSE );
d5511 1
a5511 1
	      move_register( R_DS, R_ATMP, FALSE );
d5573 1
a5573 1
	      move_register( R_MT, R_DS, FALSE );
d5956 1
a5956 1
  move_register( R_FP, R_A1 + 1, FALSE );
d6599 1
a6599 1
      move_register( R_SP, R_FP, FALSE );
d6678 1
a6678 1
	  move_register( R_LR, R_TMP3, FALSE );
d6724 1
a6724 1
	  move_register( R_LR, R_TMP3, FALSE );
d6810 1
a6810 1
  move_register( R_A1, R_A1 + 1, FALSE ); /* XXX - potential bug, if return value is a double */
d7705 1
a7705 1
	      move_register( dest, R_TMP2, FALSE );
d7970 1
a7970 1
	  move_register( R_TMP2, dest, FALSE );
d8900 1
a8900 1
	      move_register( tmp, R_TMP1, FALSE );
d8935 1
a8935 1
	  move_register( R_TMP1, tmp, FALSE );
d9005 1
a9005 1
	      move_register( tmp, R_TMP2, FALSE );
d9047 1
a9047 1
	  move_register( R_TMP2, tmp, FALSE );
d9178 1
a9178 1
  move_register( R_MT, R_ATMP, FALSE );
d9245 1
a9245 1
  move_register( R_ATMP, R_V1, FALSE );
d9310 1
a9310 1
  move_register( R_V1, R_ATMP, FALSE );
d9378 1
a9378 1
	  move_register( tmp1, R_TMP1, FALSE );
d9401 1
a9401 1
	  move_register( tmp2, R_TMP2, FALSE );
d9486 1
a9486 1
      move_register( R_TMP2, tmp2, FALSE );
d9491 1
a9491 1
      move_register( R_TMP1, tmp1, FALSE );
d9843 1
a9843 1
	  move_register( mr, R_TMP1, FALSE );
d10018 1
a10018 1
	      move_register( R_LR, R_TMP2, FALSE );
d10125 1
a10125 1
	      move_register( R_TMP2, R_LR, FALSE );
d10277 1
a10277 1
	  move_register( RR_ST, R_TMP1, FALSE );
d10304 1
a10304 1
	  move_register( RR_ST, R_TMP1, FALSE );
d10335 1
a10335 1
	  move_register( RR_ST, R_TMP2, FALSE );
d10364 1
a10364 1
	  move_register( RR_ST, R_TMP1, FALSE );
d10391 1
a10391 1
	  move_register( RR_ST, R_TMP1, FALSE );
d10461 1
a10461 1
	  move_register( mr, r1r, TRUE );
d10480 1
a10480 1
	  move_register( mr, r1r, FALSE );
d10501 1
a10501 1
      move_register( mr, r1r, FALSE );
d10586 1
a10586 1
		  move_register( dst, R_TMP2, FALSE );
d10627 1
a10627 1
	      move_register( R_TMP2, dst, FALSE );
d10904 1
a10904 1
		  move_register( ar, r1r, FALSE );
d10930 1
a10930 1
	  move_register( r2r, r1r, FALSE );
d11008 1
a11008 1
		  move_register( ar, r1r, FALSE );
d11034 1
a11034 1
	  move_register( r2r, r1r, FALSE );
d11509 1
a11509 1
	  move_register( src, r2r, FALSE );
d11897 2
a11898 1
/* returns YES if the jopcode would alter the condition code register */
a11904 8
#if 0
      /*
       * XXX - Strictly speaking these instructions do not
       * affect the ST register, but since this function is actually
       * called, saying "can we do CONDEXEC on this Jopcode ?" then
       * we have to lie.
       */
      
d11919 20
a11938 3
#endif
      /* XXX - the following jop codes are here to support conditional execution */
      
d11945 1
a11945 1
      return NO;
d11949 1
a11949 1
      return !fpliteral( ic->m.f, ic->op );
d11952 1
a11952 1
      return YES;      
d11954 2
a11955 1
}
@


1.253
log
@fixed bug in conditional compares
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350B/mbe/RCS/gen.c,v 1.252 1993/07/07 08:42:52 nickc Exp nickc $ */
d10388 1
a10388 1
      break;
@


1.252
log
@fixed compile time warnings
@
text
@d3 1
a3 1
/* $Header: /scratch/nickc/ncc/cc350B/mbe/RCS/gen.c,v 1.251 1993/07/06 14:16:01 nickc Exp nickc $ */
d9744 1
a9744 1
   * (or if they have delt with it), and they should 'break' if it
d10323 1
a10323 1
	  move_register( RR_ST, R_TMP1, FALSE );
d10325 2
a10326 2
	  conditional_load( pending_condition, ADDR_MODE_REGISTER, RR_ST, R_TMP1,
			   examines2( RR_ST, R_TMP1 ),
d11367 27
@


1.251
log
@MUCH better conditional execution support, including conditional compares !
@
text
@d3 1
a3 1
/* $Header: /scratch/nickc/ncc/cc350B/mbe/RCS/gen.c,v 1.250 1993/06/23 16:05:19 nickc Exp nickc $ */
d331 1
a331 1
    syserr( "back end: hardware_register: trying to evaluate illegal register 0x%x", r );
d396 1
a396 1
    syserr( "back end: real_register: trying to evaluate illegal register 0x%x", r );
d459 1
a459 1
      syserr( "back end: build_op: bad addressing mode %d\n", addressing_mode );
d842 1
d3279 1
a3279 1
      syserr( "back end: conditional_skip_instructions: too many instructions to skip! (%d)",
d3384 1
a3384 1
	  syserr( "back end: cannot conditionally branch to offset %x", off );
d4519 1
a4519 1
		  syserr( "back end: external data: offset too big (offset = %d)", offset );
d5157 1
a5157 1
      syserr( "back end: block_data_init: no data to init (%d)", num_words_to_copy );
d5793 1
a5793 1
	  syserr( "back end: cannot call to offset %x", off );
d7372 1
a7372 1
	    p = discard3( p );
d7385 1
a7385 1
      p = discard2( p );
d7657 1
a7657 1
    syserr( "back end: copying less than 4 bytes of memory (%d)", length );
d7660 1
a7660 1
    syserr( "back end: copy memory asked to copy a non word multiple %d", length );
d9063 1
a9063 1
int saved_regs_offsets[ MAXREGNUMBER + 1 ] =
d9952 1
a9952 1
	    syserr( "back end: branch %x does not match pending condition %x\n",
d10163 1
a10163 1
	      codexrefs = global_list4( SU_Xref, codexrefs, X_absreloc | (codebase + codep),
d10172 1
a10172 1
	      codexrefs = global_list4( SU_Xref, codexrefs, X_absreloc | (codebase + codep),
d11760 1
a11760 1
	  syserr( "back end: unknown sign extend mode %d", m );
d11805 1
a11805 1
      syserr( "back end: attempted to conditionally execute J_opcode %d\n", opm );
@


1.250
log
@Now only stack checks leaf functions if more than 50 words of stack are used, (used to be 6, but we are guaranteed 64 words left on stack anyway).
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.249 1993/06/08 16:07:37 nickc Exp nickc $ */
d10227 1
a10227 1
      pending_condition = m;
d10234 3
d10255 23
a10277 3
      out_diadic_op( OP_CMPF, ADDR_MODE_REGISTER, r2r, mr,
		    examines2( r2r, mr ),
		    alters1( RR_ST ) );
a10278 2
      break;
      
d10282 23
a10304 5
      out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, r2r, mr,
		    examines2( r2r, mr ),
		    alters1( RR_ST ) );
      
      break;
d10312 19
d10332 1
a10332 2
      compare_integer( r2r, m, op & Q_MASK );
      break;
d10342 19
a10360 2
      compare_float( r2r, (FloatCon *)m, op & Q_MASK, FALSE );
      break;
d10369 18
a10386 1
      compare_float( r2r, (FloatCon *)m, op & Q_MASK, TRUE );
d11857 48
d11906 1
a11906 1
/* End of  c40/gen.c */
@


1.249
log
@fixed compile time warning
@
text
@d3 1
a3 1
/* $Header: /dsl/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.248 1993/04/28 10:06:30 nickc Exp nickc $ */
d6627 1
a6627 1
       * will always have 6 words of stack available to us
d6630 1
a6630 1
      if (require > 6 || ((procflags & BLKCALL) && require > 0))
@


1.248
log
@supports fp variables in debugger
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.255 1993/04/28 10:03:25 nickc Exp $ */
d9097 1
a9097 1
  if (usedmaskvec.map[ 0 ] & regbit( r )) \
d9104 1
a9104 1
  if (usedmaskvec.map[ 0 ] & regbit( r )) \
d9111 1
a9111 1
  if (usedmaskvec.map[ 0 ] & regbit( r )) \
d9126 1
a9126 1
  if (usedmaskvec.map[ 0 ] & regbit( r )) \
@


1.247
log
@fixed omission in module table initialisation code whereby it code not initialise not word aligned offsets
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.254 1993/03/31 16:35:15 nickc Exp $ */
d5485 1
a5485 1
	       * slot into the moduke table!
d6797 1
a6797 1
  move_register( R_A1, R_A1 + 1, FALSE );
d6823 2
a6824 1
  /* add in value in link register */  
d9058 38
d9098 2
a9099 1
    out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_PRE_ADD, R_ATMP, r ), \
d9105 2
a9106 1
    out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_PRE_ADD, R_ATMP, r ), \
d9110 29
d9214 4
a9217 4
  save_reg( RR_R4  );
  save_reg( RR_R5  );
  save_reg( RR_R6  );
  save_reg( RR_R7  );
d9304 4
a9307 4
  restore_reg( RR_R4  );
  restore_reg( RR_R5  );
  restore_reg( RR_R6  );
  restore_reg( RR_R7  );
@


1.246
log
@hmm - fixed another big from (delta -2)
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.252 1993/03/08 17:43:47 nickc Exp nickc $ */
d5309 1
a5309 1
       * we know that DST_REG holds IR0 + [static_data_ptr / sizeof_int] + current_offset
d5313 27
a5339 4
      if (offset & 3)		/* XXX note assumption that sizeof_int == 4 */
	syserr( "back end: export_data_symbol: non word aligned offset!" );
      
      offset /= sizeof_int;
d5341 3
a5343 3
      /*
       * adjust offset
       */
d5345 1
a5345 1
      offset -= current_offset;
d5347 1
a5347 1
      /* get R_ATMP - IR0 into temporary register */
d5349 3
a5351 3
      out_triadic_op( OP_SUBI3, VAL_REG, DST_REG, R_BASE, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( DST_REG, R_BASE ),
		     alters2( VAL_REG, RR_ST ) );
d5353 1
a5353 1
      /* add in offset */
d5355 1
a5355 1
      integer_immediate_op( OP_ADDI, OP_ADDI3, VAL_REG, VAL_REG, offset, TRUE );
d5357 1
a5357 1
      /* convert to a byte offset */
d5359 3
a5361 3
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, VAL_REG, 2,
		     examines1( VAL_REG ),
		     alters2( VAL_REG, RR_ST ) );
d5363 2
a5364 1
      /* result is now in VAL_REG, ready to store */
@


1.245
log
@oops, fixed buglet in previous delta
@
text
@d8340 2
a8341 1
	   * loose bottom two bits (byte selector) of offset
d8349 5
d8357 5
a8366 15
	  /*
	   *    addr    - word offset
	   *    operand - free 
	   *    R_TMP1  - free
	   *    R_TMP2  - free
	   *    R_TMP3  - free
	   *
	   * save non-word selector of address into R_TMP2
	   */
	  
	  out_triadic_op( OP_AND3, R_TMP2, addr,
			 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( addr ),
			 alters2( R_TMP2, RR_ST ) );
	  
@


1.244
log
@reorder byte load instructions to remove pipeline conflict
@
text
@d8366 1
a8366 2
	  out_triadic_op( OP_AND3, R_TMP2,
			 addr_not_loaded ? address : addr,
d8368 1
a8368 1
			 examines1( addr_not_loaded ? address : addr ),
@


1.243
log
@Fixed bug 1147 (registers saved for debugger support were wrong)
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.242 1993/01/12 10:39:25 nickc Exp nickc $ */
d993 4
a8339 17
	   * save non-word selector of address into R_TMP2
	   */
	  
	  out_triadic_op( OP_AND3, R_TMP2,
			 addr_not_loaded ? address : addr,
			 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( addr_not_loaded ? address : addr ),
			 alters2( R_TMP2, RR_ST ) );
	  
	  /*
	   *    addr    - byte offset if 'addr_not_loaded' is FALSE
	   *    address - byte offset if 'addr_not_loaded' is TRUE
	   *    operand - free 
	   *    R_TMP1  - free
	   *    R_TMP2  - byte selector (0, 1, 2 or 3)
	   *    R_TMP3  - free
	   *
d8356 16
@


1.242
log
@fixed reinitialisation of debugging world, and fixed debugger support to generate code tables
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.249 1993/01/12 10:15:25 nickc Exp nickc $ */
d922 2
d3969 1
a3969 1
       * silicon, whereby R_LR is occiaisionally not set by the
d3975 5
d4010 5
d7410 4
d9036 4
a9039 5
  reg = real_register( r ); \
  if (usedmaskvec.map[ 0 ] & regbit( reg )) \
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_PRE_ADD, R_ATMP, r ), \
		  examines2( reg, R_ATMP ), \
		  alters0() ) \
d9042 2
a9043 3
  reg = real_register( r ); \
  if (usedmaskvec.map[ 0 ] & regbit( reg )) \
    out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_PRE_ADD, R_ATMP, r ), \
d9045 1
a9045 1
		  alters1( reg ) ) \
a9052 1
  RealRegister		reg;
@


1.241
log
@fixed bug in reporting of register usage
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.248 1992/12/16 20:07:00 nickc Exp $ */
d114 1
d1171 2
a1172 1
#endif  
d3717 16
a3732 1
  if (symbol == bindsym_( datasegment )) /* __dataseg has no data associated with it */
a3735 2
   * XXX - NC
   *
d3751 1
a3751 1
  if (symdata_( symbol ) == NULL)
d3753 4
a3756 1
      if (symext_( symbol ))
d3760 1
a3760 1
	  if (is_data( symext_( symbol ) ))
a3773 1
  
d3775 1
a3775 1
  return ((bindstg_( symdata_( symbol ) ) & b_fnconst) != 0 );
d4750 1
a4750 1
      if (new_stubs)
d4773 1
a4773 1
      if (new_stubs)
a9037 1
  static Symstr *	sym = NULL;  
d9045 1
a9045 1
  if (sym == NULL)
d9047 1
a9047 1
      sym = sym_insert( "saved_regs", s_identifier );
d9064 1
a9064 1
  peep_xref( X_DataModule, sym );
d9079 1
a9079 1
  peep_xref( X_DataSymbHi, sym );
d9087 1
a9087 1
  peep_xref( X_DataSymbLo, sym );
d11429 1
a11429 1
      if (usrdbg( DBG_ANY ) && !new_stubs && !in_stubs)
d11633 3
d11646 3
@


1.240
log
@fixed switch statements in very large functions
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.247 1992/12/09 10:30:01 nickc Exp $ */
d8163 1
a8163 1
			     examines2( address, offset ),
@


1.239
log
@fixed constant used in previous delta
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.246 1992/12/04 09:05:57 nickc Exp $ */
d9857 1
d9868 1
a9868 1
	  /* and if we are out of range then branch to */
a9906 6
	   * Note that the 3 in the following op code comes from that fact that there
	   * are 3 instructions between the instruction now pointed at by the link
	   * register and the start of the jump table
	   */
	  
	  /*
d9918 14
d9933 1
a9933 1
			 saved_lr ? 3 : 2,
d9951 2
a9954 2
	  offset = ((codep_of_call + codebase) >> 2) + 3;

d9963 20
a9982 1
	      syserr( "back end: function containing switch is too big" );
d10006 1
a10006 1
	  /* and remember to reset the casebranch_pending flag */
@


1.238
log
@fixed calculation of offset of already created SourceInfo structure
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.245 1992/11/30 15:35:02 nickc Exp nickc $ */
d9142 1
a9142 1
      off = (off - codep - codebase) / sizeof_int - 4;
@


1.237
log
@fixed bug in horrible hack
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.245 1992/11/30 15:35:02 nickc Exp $ */
d9142 1
a9142 1
      off = (off - codep - codebase) / sizeof_int;
@


1.236
log
@added HORRIBLE HACK to catch GetExecRoot and insert inline code
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.243 1992/11/06 16:57:16 nickc Exp nickc $ */
d5649 3
@


1.235
log
@fixed bug with tailcalls
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.241 1992/10/30 18:12:27 nickc Exp nickc $ */
d998 1
a998 2
      else if (is_special_register( hardware_register( dest ) ) &&
	       var_cc_private_flags == 0)	/* simulator cannot cope with LDA */
d1162 1
a1162 2
      hardware_register( r ) == 0x10 && /* DP */
      var_cc_private_flags   == 0    )	/* simulator cannot cope with LDPK */
d1175 1
a1175 2
      if (is_special_register( hardware_register( r ) ) &&
	  var_cc_private_flags == 0)	/* simulator cannot cope with LDA */	  
d1652 1
a1652 1
  if (!is_double)
d3060 1
a3060 1
      if (n == 0 && !no_peepholing && var_cc_private_flags == 0)
a3061 12
	  /*
	   * XXX - NC - 16/12/91
	   *
	   * The cc_var_private_flags above is because ...
	   *
	   * The test for the pragma is because the stupid
	   * C40 simulator is broken, and it will not
	   * set the status bits for a result of 0.  Hence
	   * if we are compiling code to run on the simulator
	   * we must compare against 0 all the time.  *sigh*
	   */
	  
d3611 1
a3611 2
  if (is_special_register( hardware_register( r ) ) &&
      var_cc_private_flags == 0)	/* simulator cannot cope with LDA */
d4684 1
a4684 1
  if (var_cc_private_flags > 1)
d5626 25
d9328 3
a9330 3
	  out_diadic_op( OP_RND, ADDR_MODE_REGISTER, tmp2, tmp2,
			examines1( tmp2 ),
			alters2( tmp2, RR_ST ) );	  
d9953 1
a9953 1

d9955 1
a9955 1

d9959 1
a9959 1

d9964 1
a9964 1

d9968 1
a9968 1

d9974 1
a9974 1

d9978 1
a9978 1

d9986 1
a9986 1

d9992 1
a9992 1

d10013 1
a10013 1

d10020 1
a10020 1
				      bindsym_( codesegment ), 0 );
d10026 1
a10026 1

d10029 1
a10029 1

d10031 2
a10032 2

/* XXX - stack manipulation */
d10044 1
a10044 1

d10058 2
a10059 2


d10062 1
a10062 1

d10067 1
a10067 1

d10070 1
a10070 1

d10072 1
a10072 1

d10080 10
a10089 3
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r2r, r2r,
		    examines1( r2r ),
		    alters2( r2r, RR_ST ) );
a10090 4
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, mr, mr,
		    examines1( mr ),
		    alters2( mr, RR_ST ) );

d10099 1
a10099 1

d10103 1
a10103 1

d10108 1
a10108 1

d10112 1
a10112 1

d10124 1
a10124 1

d10132 1
a10132 5
      
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r2r, r2r,
		    examines1( r2r ),
		    alters2( r2r, RR_ST ) );
      
d10142 1
a10142 1

d10153 1
a10153 1

d10166 1
a10166 1

d10175 1
a10175 1

d10184 1
a10184 1

d10188 1
a10188 1

d10192 1
a10192 1

d10213 1
a10213 1

d10226 1
a10226 1

d10235 1
a10235 1

d10244 1
a10244 1

d10246 1
a10246 1

d10255 1
a10255 1

d10264 1
a10264 1

d10268 1
a10268 1

d10279 1
a10279 1

d10292 1
a10292 1

d10302 1
a10302 1

d10308 1
a10308 1

d10311 1
a10311 1
	      
d10321 1
a10321 1

d10338 1
a10338 1

d10342 1
a10342 1

d10349 1
a10349 1

d10357 1
a10357 1

d10363 1
a10363 1

d10374 1
a10374 1

d10378 1
a10378 1

d10386 1
a10386 1
            
d11205 3
a11207 2
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		    examines1( r1r ), alters2( r1r, RR_ST ) );
d11328 3
a11330 2
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		    examines1( r1r ), alters2( r1r, RR_ST ) );
d11544 1
a11544 1
      outinstr( m, 0, 0 );
@


1.234
log
@fixed to work with C40 source debugger
@
text
@d9691 10
@


1.233
log
@changed large_model to few_modules and fixed static data initialisation with few_modules
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.240 1992/10/21 17:13:12 nickc Exp $ */
d84 1
d3008 2
d3011 6
a3016 1
    syserr( "back end: stack move does not fit in 16 bits" );
d3018 3
a3020 3
  /* NB/ do not use integer_immediate_op() as this might flush pushes */
  
  if (move > 0)
d3445 2
a3446 2
 * convert the byte offset in 'reg'
 * into an absolute word address
d5845 2
a5847 1

d5849 1
a5849 1
    cc_msg( "debugger: generating _notify_entry  for: %s\n", symname_( current_proc ) );
d5854 5
a5858 2
   * we know that the arguments have been saved onto the stack,
   * and that no temporaries have yet been assigned
d5861 11
d5916 4
d6451 1
a6451 1
#ifdef TARGET_HAS_DEBUGGER
d6455 3
a6457 1
       * save all registers since debugging routines could corrupt anything
d8843 1
a8843 1
      conditional_load( Q_LT, ADDR_MODE_REGISTER, dst, tmp,
d8990 14
d9009 1
d9011 1
a9011 2
  int32			Ireg_mask;		/* XXX beware of assumption of num registers < 33 */
  int32			Freg_mask;		/* XXX beware of assumption of num registers < 33 */
d9016 5
d9024 7
a9030 1
  /* build mask of registers to save */
d9032 1
a9032 4
  Ireg_mask = regbit( R_A1  + NARGREGS     ) - regbit( R_A1  ) |
              regbit( R_T1  + NTEMPREGS    ) - regbit( R_T1  );
  Freg_mask = regbit( R_FA1 + NFLTARGREGS  ) - regbit( R_FA1 ) |
              regbit( R_FT1 + NFLTTEMPREGS ) - regbit( R_FT1 );
d9034 14
a9047 1
  /* only bother to save those registers used by this function */
d9049 7
a9055 2
  Ireg_mask &= usedmaskvec.map[ 0 ];
  Freg_mask &= usedmaskvec.map[ 0 ];
d9057 40
a9096 4
  if (Ireg_mask)
    {
      save_regs( Ireg_mask, FALSE );
    }
d9098 2
a9099 4
  if (Freg_mask)
    {
      save_regs( Freg_mask, TRUE );
    }
a9120 3
   *
   * NB/ beware of assumption that the structure is within 16
   * (signed) bits of this instruction - this may not be true
d9128 3
a9130 1
      off = (off - codep - codebase) / sizeof_int - 4;
d9136 5
d9163 3
d9167 19
a9185 4
  if (Freg_mask)
    {
      restore_regs( Freg_mask, TRUE );
    }
a9186 5
  if (Ireg_mask)
    {
      restore_regs( Ireg_mask, FALSE );
    }

@


1.232
log
@added fast_FP support
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.238 1992/10/20 08:39:48 nickc Exp $ */
d3628 1
a3628 1
  if (large_model)
d4377 1
a4377 1
	  else if (large_model)
d5393 1
a5393 1
	  else if (large_model)
d5509 1
a5509 1
	  if (large_model)
d5528 2
a5529 2
			    build_indirect( INDIRECT_PRE_ADD, R_DS, 0 ),
			    examines1( R_DS ),
@


1.231
log
@added automatic rounding after every FP operation!
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.237 1992/10/19 11:49:40 nickc Exp $ */
d9175 1
a9175 1
  if (is_double)
d9177 7
a9183 5
      /* for double precision we require a final loop to get the last bit right */
	
      out_triadic_op( OP_MPYF3, tmp2, tmp1, bottom, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( tmp1, bottom ),
		     alters2( tmp2, RR_ST ) );
d9185 3
a9187 3
      out_diadic_op( OP_SUBRF, ADDR_MODE_IMMEDIATE, tmp2, 0x0000,	/* 0x0000 = 1.0 */
		    examines1( tmp2 ),
		    alters2( tmp2, RR_ST ) );
d9189 3
a9191 3
      out_diadic_op( OP_MPYF, ADDR_MODE_REGISTER, tmp2, tmp1,
		    examines2( tmp1, tmp2 ),
		    alters2( tmp2, RR_ST ) );
d9193 11
a9203 8
      out_diadic_op( OP_ADDF, ADDR_MODE_REGISTER, tmp1, tmp2,
		    examines2( tmp1, tmp2 ),
		    alters2( tmp2, RR_ST ) );
    }
  
  /*
   * NB/ do not round before multiplying as this reduces accuracy to 32 bits
   */
d9210 7
d10297 1
a10297 1
      if (opm == J_NEGFR)
d10456 5
a10460 4
      
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		    examines1( r1r ),
		    alters2( r1r, RR_ST ) );      
d10558 5
a10562 4
      
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		    examines1( r1r ),
		    alters2( r1r, RR_ST ) );
d10662 5
a10666 4
      
      out_diadic_op( OP_RND, ADDR_MODE_REGISTER, r1r, r1r,
		    examines1( r1r ),
		    alters2( r1r, RR_ST ) );      
d10767 1
a10767 1
      if (opm == J_ADDFR)
d10807 1
a10807 1
      if (opm == J_SUBFR)
d10841 1
a10841 1
      if (J_MULFR)
@


1.230
log
@fixed bug in slecting a spare register for use with FP divides
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.236 1992/10/16 17:22:24 nickc Exp $ */
d9979 4
d10004 4
d10229 6
d10284 6
d10444 4
d10545 5
d10648 4
d10752 5
d10791 5
a10795 1
      
d10826 4
@


1.229
log
@now rounds before performing short double compare
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.233 1992/10/15 13:47:33 nickc Exp nickc $ */
a5865 2
  peep_protect_pc = 3;
  
d5885 4
d6424 13
a6711 2
  peep_protect_pc = 3;
  
d6730 4
d6820 1
a6820 1
   
d7323 2
d8868 1
a8868 1
	  tmp = get_free_register( RR_R1, RR_R2, RR_R3, RR_R4, RR_R5, RR_R6, RR_R7, RR_R8, RR_R9, RR_R10, GAP );
d8987 1
a8987 1

d9104 1
a9104 1
      tmp1 = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R8, RR_R9, RR_R10, GAP );
d9125 1
a9125 1
      tmp2 = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R8, RR_R9, RR_R10, GAP );
d10154 1
a10154 1
	  dst = get_free_register( RR_R1, RR_R2, RR_R3, RR_R4, RR_R5, RR_R6, RR_R7, RR_R8, RR_R9, RR_R10, GAP );
@


1.228
log
@improved accuracy of double precision divide
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.233 1992/10/15 13:47:33 nickc Exp $ */
d1653 7
d9910 8
@


1.227
log
@fixed bug in FP divide
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.231 1992/10/09 10:03:37 nickc Exp nickc $ */
d9056 2
a9057 1
	      RealRegister	bottom )
d9149 21
d9279 1
a9279 1
  fp_reg_divide( dest, top, bottom );
d10761 1
a10761 1
      fp_reg_divide( r1r, r2r, mr );
@


1.226
log
@fixed rounding of floating point numbers stored into memory
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.230 1992/10/07 13:22:30 nickc Exp $ */
d6637 1
a6637 1
  if (usrdbg( DBG_PROC ))
d6798 1
a6798 1
  if (usrdbg( DBG_PROC ))
a9207 2
	  must_restore_bottom = TRUE;

d9233 2
d9240 6
a9245 1
	  augment_RealRegSet( &regmaskvec, bottom );
d11112 1
a11112 1
      
d11125 1
a11125 1
      if (usrdbg( DBG_ANY ) && (!new_stubs || !in_stubs))
a11127 1
      
d11138 1
a11138 1
      
@


1.225
log
@fixfixed bug in calculation of external function addresses
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.228 1992/10/05 14:13:02 nickc Exp nickc $ */
d10945 3
d11067 3
@


1.224
log
@fixed bug in static initialisation of function addresses
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.226 1992/10/02 11:57:33 nickc Exp nickc $ */
d4437 3
a4439 1
		      move_register( R_LR, R_TMP1, FALSE );
d4464 1
a4464 1
		      move_register( R_TMP1, R_LR, FALSE );
d9147 4
a9150 6
  
  /* round before multiplying */
  
  out_diadic_op( OP_RND, ADDR_MODE_REGISTER, tmp1, tmp1,
		examines1( tmp1 ),
		alters2( tmp1, RR_ST ) );
@


1.223
log
@improved LAJ generation for address stubs
@
text
@d5424 10
a5435 2
	      peep_corrupt_addr_reg( R_ATMP );
	      
d5439 2
@


1.222
log
@fixed bug obtaining result of address generation stubs
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.226 1992/10/02 11:57:33 nickc Exp $ */
d4442 2
d4448 1
a4448 1
		  outinstr( OP_LAJ << 24 | (-3 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );
a4451 11
		  /*
		   * there is a bug in C40 silicon which means that R11 cannot be set
		   * in the two instructions following a LAJ
		   */

		  /* wait for LAJ to take affect */
		  
		  nop( FALSE );
		  nop( FALSE );
		  nop( FALSE );
		  
d5422 2
a5424 2
		  
	      outinstr( OP_LAJ << 24 | (-3 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );
d5426 3
a5428 1
	      peep_protect_pc = 3;
a5429 11
	      /*
	       * there is a bug in C40 silicon which means that R11 cannot be set
	       * in the two instructions following a LAJ
	       */
	      
	      /* wait for LAHJ to take affect */
	      
	      nop( FALSE );
	      nop( FALSE );
	      nop( FALSE );
		  
@


1.221
log
@fixed calculation of function addresses to use address generator stubs
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.225 1992/10/02 08:21:49 nickc Exp $ */
a4449 4
		  /* result is placed in AR5 (alias R_ATMP) */
		  
		  move_register( R_ATMP, dest, FALSE );
		  
d4454 2
d4458 6
a5436 2
	      move_register( R_ATMP, VAL_REG, FALSE );
	      
d5442 3
d5446 4
a5449 1

@


1.220
log
@hmm, fixed buglet in previous delta
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.223 1992/09/10 17:06:17 nickc Exp nickc $ */
d4246 1
a4246 3
       * This code is very similar to the code for loading the address of
       * functions, except that we must assume that there can be more than 32767
       * words of data per module.  Again in an ideal world we could do :-
a4290 2
	   *
	   * (This code is exactly the same as that found in load_address_constant).
d4439 2
a4440 2
      
		  /* put PC of next instruction into R_LR */
d4442 5
a4446 1
		  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );
a4448 8
      
		  /*
		   * The value loaded here should be
		   * 'top 16 bits of offset of symbol from (this instruction + 3)'
		   * The +3 is taken of by the patch generated in heliobj.c
		   */
      
		  peep_xref( X_DataAddr1, symbol ); 
d4450 3
a4452 11
		  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP2, 0,
				examines0(),
				alters2( R_TMP2, RR_ST ) );

		  peep_xref( X_DataAddr, symbol ); 
      
		  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP2, -4 + 2,
				examines1( R_TMP2 ),
				alters1( R_TMP2 ) );	/* XXX - note lie about not affecting RR_ST */

		  flush_peepholer( "function address" );
d4455 2
a4456 3
		   * now add the two offsets place in destination register
		   *
		   * (This instruction does not need to be patched)
d4458 3
a4460 5
      
		  out_triadic_op( OP_ADDI3, dest, R_LR, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
				 examines2( R_LR, R_TMP2 ),
				 alters2( dest, RR_ST ) );
      
d4470 1
a4470 1
	      else
d4485 1
a4485 1
	  else
d5425 3
a5427 3
	      if (codep_of_call == 0)
		{
		  flush_peepholer( "no more LAJ swaps" );
d5429 1
a5429 1
		  /* put PC into R_LR */
d5431 1
a5431 5
		  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

		  /* adjust symbol offset to be relative to next instruction */

		  flush_peepholer( "getting address of LAJ" );
d5433 1
a5433 4
		  peep_protect_pc = 3;

		  codep_of_call = codep;
		}
d5436 2
a5437 3
	       * The value loaded here should be
	       * 'top 16 bits of offset of symbol from (this instruction + 3)'
	       * The +3 is taken off by the patch generated in heliobj.c
d5439 2
a5440 14
      
	      peep_xref( X_DataAddr1, name );

	      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, VAL_REG, 0,
			    examines0(),
			    alters2( VAL_REG, RR_ST ) );

	      peep_xref( X_DataAddr, name ); 

	      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, VAL_REG, 0,
			    examines1( VAL_REG ),
			    alters1( VAL_REG ) );	/* XXX - note lie about not affecting RR_ST */

	      flush_peepholer( "get codep" );
d5442 1
a5442 16
	      offset = (codep - codep_of_call) / sizeof_int - 4;

	      if (offset)     /* add offset seperately as it could easily cause the OR to overflow 16 bits */
		integer_immediate_op( OP_ADDI, OP_ADDI3, VAL_REG, VAL_REG, offset, TRUE );
	      
	      flush_peepholer( "prevent loosing knowledge of position of OR" );
	      
	      /*
	       * now add the two offsets place in destination register
	       *
	       * (This instruction does not need to be patched)
	       */
      
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, VAL_REG, R_LR,
			     examines2( R_LR, VAL_REG ),
			     alters2( VAL_REG, RR_ST ) );
d5844 1
a5844 1
  /* first argument: the address of the Proc & ProcInfo structures */
a5877 4
  /* convert offset to byte offset */

  convert_to_byte_offset( R_A1 );
  
d6677 1
a6677 1
  /* first argument: the address of the Proc & ProcInfo structures */
d6703 1
a6703 2
  /* add in value in link register */
  
a6707 4
  /* convert offset to byte offset */

  convert_to_byte_offset( R_A1 );
  
d8970 1
a8970 1
  /* second argument: the address of the SourceInfo structure */
a9018 4
  /* convert offset to byte offset */
      
  convert_to_byte_offset( R_A1 + 1 );
  
@


1.219
log
@Fixed the LAST GREAT COMPILER bug
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.222 1992/09/04 09:22:05 nickc Exp nickc $ */
d9132 1
a9132 1
      usedmaskvec.map[ 0 ] & regbit( R_LR ) == 0)	/* link register being used as temporary */
@


1.218
log
@changed calls to globalise() to be calls to request_new_stub()
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.221 1992/09/03 16:58:52 nickc Exp nickc $ */
d3918 4
a3921 2
      if ((dest != R_LR) &&
	  ((saved_ivars & regbit( R_LR )) == 0))
d3995 2
a3996 1
	  ((saved_ivars & regbit( R_LR )) == 0))
d4043 2
a4044 1
	  ((saved_ivars & regbit( R_LR )) == 0))
d4088 2
a4089 1
	  ((saved_ivars & regbit( R_LR )) == 0))
d4301 2
a4302 1
	      ((saved_ivars & regbit( R_LR )) == 0))
d4346 2
a4347 1
	      ((saved_ivars & regbit( R_LR )) == 0))
d4436 2
a4437 1
		      ((saved_ivars & regbit( R_LR )) == 0))
d4481 2
a4482 1
		      ((saved_ivars & regbit( R_LR )) == 0))
d4593 2
a4594 1
      ((saved_ivars & regbit( R_LR )) == 0))
d4637 2
a4638 1
      ((saved_ivars & regbit( R_LR )) == 0))
d7517 2
a7518 1
	  if ((saved_ivars & regbit( R_LR )) == 0)
d7554 3
a7556 1
      if (zero == R_LR && ((saved_ivars & regbit( R_LR )) == 0))
d8800 2
a8801 1
	  if ((saved_ivars & regbit( R_LR )) == 0)
d8820 2
a8821 1
	  if ((saved_ivars & regbit( R_LR )) == 0)
d8922 2
a8923 1
	  if ((saved_ivars & regbit( R_LR )) == 0)
d9131 2
a9132 1
  if (saved_ivars & regbit( R_LR ))
d9716 1
d9736 4
a9739 2
	  if ((r1r == R_LR) ||
	      ((saved_ivars & regbit( R_LR )) == 0))
d9746 3
a9748 1
		r1r = R_TMP2;
d9784 1
a9784 1
			 ((saved_ivars & regbit( R_LR )) == 0 || (r1r == R_TMP2)) ? 3 : 2,
d9819 1
a9819 2
	  if ((r1r == R_TMP2) ||
	      ((saved_ivars & regbit( R_LR )) == 0))
d10170 2
a10171 1
	      if ((saved_ivars & regbit( R_LR )) == 0)
@


1.217
log
@fixed globalising of function symbols
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.221 1992/09/03 16:58:52 nickc Exp $ */
d4362 1
a4362 1
	      globalise( symbol );
d5393 1
a5393 1
	      globalise( name );
@


1.216
log
@new style stubs now request stubs as well
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.220 1992/09/03 15:38:15 nickc Exp $ */
d4229 1
a4229 1
      
d4362 2
d4564 1
a4564 1
	}      
d5393 2
a5395 1
	      ;	      
@


1.215
log
@fixed peepholer bug
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.219 1992/08/25 15:35:44 nickc Exp $ */
d5765 1
a5765 6
  if (!new_stubs)
    {
      /* XXX - should this stub be inserted before the NOPs are generated ?? */
  
      request_stub( name );
    }
@


1.214
log
@fixed generation of object code for backward switches
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.213 1992/08/24 16:27:00 nickc Exp nickc $ */
d4071 2
d4326 2
d4458 2
d6368 5
a6372 5
      saved_ivars  = 0;
      saved_fvars  = 0;
      saved_args   = 0;
      saved_frame  = 0;
      stack_move   = 0;
a6496 14

      /* There is a problem here:                                             */
      /* Given a fn f(int x, ...) then the 2nd arg will be expected in        */
      /* an int reg and so f(1,3.4) will cause va_arg to look in the          */
      /* wrong place for ...va_start(x); va_arg(double)...  The solution      */
      /* is probably to save the 2nd arg reg in this case in a slightly       */
      /* unusual position and have va_arg take more care with access.         */

      /* XXX - NC - not sure if this applies to the C40 */
      
#define gen_warn_va_double "calls to va_arg(double) may be mis-compiled in this function"
  
      if ((procflags & PROC_ARGADDR) && (suppress & D_VARARGWARN))
	cc_warn( gen_warn_va_double );
d9852 1
a9852 1

d9856 1
a9856 1
	      
@


1.213
log
@fixed backward references in switch statements
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.212 1992/08/18 08:20:39 nickc Exp nickc $ */
d9864 3
d9874 2
a9876 2

	  outcodewordaux( 0, LIT_ADCON, bindsym_( codesegment ) );
@


1.212
log
@fixed another bug with old style stubs
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.211 1992/08/17 16:20:35 nickc Exp nickc $ */
d9848 12
a9859 1
	      /* only if returnlab? never? */
d9862 2
a9863 1
				      bindsym_( codesegment ), codebase + (l->u.defn & 0x00ffffffU));
@


1.211
log
@fixed bug generating old style calling stubs
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.210 1992/08/05 17:25:47 nickc Exp nickc $ */
d6362 7
a6368 5
      saved_ivars = 0;
      saved_fvars = 0;
      saved_args  = 0;
      saved_frame = 0;
	
@


1.210
log
@oops, fixed typo in previous delta
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.212 1992/08/04 16:07:50 nickc Exp nickc $ */
d6365 2
a6366 1
      
@


1.209
log
@fixed several (potential) bugs with using LAJ to obtain PC
@
text
@d1 1
a1 1
* C compiler file c40/gen.c :  Copyright (c) Perihelion Software Ltd, 1991, 1992.     */
@


1.208
log
@fixed bug in conditional_load() whereby it forgot to tell the peepholer about its actions
@
text
@d1 1
a1 1
/* C compiler file c40/gen.c :  Copyright (c) Perihelion Software Ltd, 1991, 1992.     */
d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.212 1992/08/04 16:07:50 nickc Exp $ */
d3932 2
d5085 2
d5333 2
d5426 2
d9734 3
a9736 1
  
@


1.207
log
@fixed bug in fp_imm_divide
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.206 1992/07/29 12:51:32 nickc Exp nickc $ */
d882 2
d9308 1
a9308 1
	
@


1.206
log
@fixed compile time warnings
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.210 1992/07/28 16:54:18 nickc Exp $ */
d9260 1
a9260 1
		  bottom = R_F1;
@


1.205
log
@changed severity of error messages
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.204 1992/07/17 09:12:41 nickc Exp nickc $ */
a55 10
#if defined helios
#define UNUSED( var )	var = var;
#else
#define UNUSED( var )
#endif

#ifndef streq
#define streq( a, b )	(strcmp( (a), (b) ) == 0)
#endif

d85 10
d1169 1
a1169 2
#endif
  
d3123 1
a3123 1
      cc_rerr( syserr_large_shift, amount );
d3131 1
a3131 1
      cc_rerr( syserr_large_shift, amount );
d4087 1
a4087 1
      RealRegister	real_dest;
d4563 1
a4563 3
load_string_constant(
		     StringSegList *	string_constant,
		     RealRegister	dest )
a7951 1
	    int32		can_corrupt_address,	/* non-zero if address register can be corrupted */
a8980 1
  extern LabelNumber *	debugger_filenamelabel( char * );
d9622 1
a9622 1
      load_string_constant( (StringSegList *)m, r1r );
d9952 1
a9952 1
      
d10938 1
a10938 1
      non_word_op( r1r, r2r, m, FALSE, dead & J_DEAD_R2, opm == J_LDRWK + J_SIGNED, TRUE, TRUE );
d10949 1
a10949 1
      non_word_op( r1r, r2r, m, FALSE, dead & J_DEAD_R2, opm == (J_LDRBK + J_SIGNED), FALSE, TRUE );
d11006 1
a11006 1
      non_word_op( r1r, r2r, m, FALSE, dead & J_DEAD_R2, FALSE, TRUE, FALSE );
d11016 1
a11016 1
      non_word_op( r1r, r2r, m, FALSE, dead & J_DEAD_R2, FALSE, FALSE, FALSE );
d11057 1
a11057 1
      non_word_op( r1r, r2r, mr, TRUE, dead & J_DEAD_R2, opm == J_LDRWR + J_SIGNED, TRUE, TRUE );
d11068 1
a11068 1
      non_word_op( r1r, r2r, mr, TRUE, dead & J_DEAD_R2, opm == J_LDRBR + J_SIGNED, FALSE, TRUE );
d11108 1
a11108 1
      non_word_op( r1r, r2r, mr, TRUE, dead & J_DEAD_R2, FALSE, TRUE, FALSE );
d11118 1
a11118 1
      non_word_op( r1r, r2r, mr, TRUE, dead & J_DEAD_R2, FALSE, FALSE, FALSE );
d11363 1
a11363 1
} /* localcd_reinit */
@


1.204
log
@fixed bug in load_integer
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.203 1992/07/16 09:50:23 nickc Exp nickc $ */
d3124 1
a3124 1
      syserr( syserr_large_shift, amount );
d3132 1
a3132 1
      syserr( syserr_large_shift, amount );
@


1.203
log
@fixed stupid bug initialising function pointers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.205 1992/07/16 09:48:43 nickc Exp $ */
d1158 1
d1169 1
@


1.202
log
@fixed function pointer initialisation to cope with large offsets
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.204 1992/07/15 13:19:18 nickc Exp $ */
d5465 1
a5465 1
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_LR, VAL_REG,
@


1.201
log
@fixed static initialisation of function pointers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.202 1992/07/13 17:29:26 nickc Exp nickc $ */
a5443 2
	      flush_peepholer( "get codep" );
	      
d5446 1
a5446 1
	      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, VAL_REG, (codep - codep_of_call) / sizeof_int - 3,
d5450 7
@


1.200
log
@err, I've forgotten what the changes were - sorry
oh, wait, I've remembered now
its, err. err
new linker scheme
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.202 1992/07/13 17:29:26 nickc Exp $ */
d5376 1
a5376 1
	  if (large_model)
d5378 5
d5414 53
a5466 2
	  
	  /* add in the offset of 'name' into the function table */
d5468 1
a5468 1
	  peep_xref( X_DataSymbLo, name );
d5470 3
a5472 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_DS, 0,
			examines1( R_DS ),
			alters2( R_DS, RR_ST ) );
d5474 1
a5474 1
	  /* get the address of the function */
d5476 4
a5479 3
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, VAL_REG, build_indirect( INDIRECT_REL, R_DS, 0 ),
			examines1( R_DS ),
			alters2( VAL_REG, RR_ST ) );
@


1.199
log
@fixed bug in large switch statements
@
text
@d3 1
a3 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/gen.c,v 1.198 1992/06/25 10:54:59 nickc Exp nickc $ */
d4084 1
a4084 1
  else if (/* is_function( symbol ) && */ in_stubs)
d4351 6
a4356 1
	  if (large_model)
d4414 56
d4471 3
a4473 1
	      peep_xref( X_DataSymb, symbol );
d4475 1
a4475 3
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
			    examines1( tmp ),
			    alters2( tmp, RR_ST ) );
d4477 4
a4480 5
	      /* and fetch the address out of the function table */
	      
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, tmp, 0 ),
			    examines1( tmp ),
			    alters2( dest, RR_ST ) );
d4734 11
a4744 1
      /* if we are only initialising functions then skip all stages except stage 2 */
d4746 3
a4748 3
      out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, R_A1, 2,
		    examines1( R_A1 ),
		    alters1( RR_ST ) );
d4750 4
a4753 3
      outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_NE ) << 16 | hardware_register( R_LR ),
		 examines2( R_LR, RR_ST ),
		 alters1( RR_PC ) );
d4757 15
a4771 1
      /* we are initialisaing data and functions */
d4773 3
a4775 3
      out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, R_A1, 1,
		    examines1( R_A1 ),
		    alters1( RR_ST ) );
d4777 1
a4777 1
      /* stage 0 initialises data */
d4779 1
a4779 1
      conditional_branch_to( Q_LT, data_label );
d4781 1
a4781 1
      /* and stage 1 is ignored */
d4783 4
a4786 3
      outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_EQ ) << 16 | hardware_register( R_LR ),
		 examines2( R_LR, RR_ST ),
		 alters1( RR_PC ) );
d4788 2
d5596 2
a5597 2
  
  if (in_stubs)
d5622 1
a5622 1

d5688 6
a5693 1
  /* XXX - should this stub be inserted before the NOPs are generated ?? */
a5694 2
  request_stub( name );

d6286 4
a6290 4
  /* stub routines have no entry code */
  
  if (in_stubs)
    {      
d6297 1
a6297 1

d9459 1
a9459 2

      if (!in_stubs)
d9697 1
a9697 2
			 ((saved_ivars & regbit( R_LR )) == 0 ||
			  (r1r == R_TMP2)) ? 3 : 2,
d11079 1
a11079 1
      if (usrdbg( DBG_ANY ) && !in_stubs)
@


1.198
log
@fixed compile time warning
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.197 1992/06/24 17:04:43 nickc Exp nickc $ */
d9607 2
a9608 1
			 ((saved_ivars & regbit( R_LR )) == 0) ? 3 : 2,
@


1.197
log
@might have fixed potential bug
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.196 1992/06/19 17:07:43 nickc Exp nickc $ */
d10999 1
a10999 1
      peepf( "instructions: eliminated %d, transformed %d, swapped %d",
@


1.196
log
@fixed bug introduced by previous delta
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.195 1992/06/19 13:10:44 nickc Exp nickc $ */
a14 1

d2110 1
a2110 1
  if (op == OP_LDI || op == OP_LDF)
d2114 1
a2114 1
      peep_forget_about( dst );
d2116 1
a2116 1
  
d2738 1
a2738 1
  if (op == OP_LDI)
d4627 3
d4632 2
a4633 2
      LabelNumber *	l;
      flush_peepholer( "why" );      
d4635 1
d4637 3
a4639 1
      flush_peepholer("hmm");
d4641 1
d4643 1
d4645 1
d4647 1
d6302 1
a6302 1

d10573 1
a10573 1
      
@


1.195
log
@greatly improved data initialisation code, escpecially for function pointers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.194 1992/06/18 08:41:43 nickc Exp nickc $ */
d5246 1
a5246 1
	  offset = codep_of_call + codebase - offset + (4 * sizeof_int);
@


1.194
log
@improved data address calculation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.193 1992/06/17 18:28:03 nickc Exp nickc $ */
d112 2
a113 1
static int32		casebranch_r1r;
d4576 39
d4626 16
d4958 10
a4984 4
  /* save return address */

  move_register( R_LR, R_DS, FALSE );

d5010 2
d5013 1
a5013 18
  /* restore return address */
  
  move_register( R_DS, R_LR, FALSE );

#if 0
    {
      LabelNumber *	l;
      flush_peepholer( "why" );      
      l = nextlabel();
      load_integer( R_TMP1, 0x2f, FALSE );
      flush_peepholer("hmm");
      setlabel( l );
      integer_immediate_op( OP_SUBI, OP_SUBI3, R_TMP1, R_TMP1, 1, TRUE );
      conditional_branch_to( Q_NE, l );
      outinstr( 0x66FFFFFF, 0, 0 );
      flush_peepholer( "why not" );      
    }
#endif
d5229 3
a5231 1
	  /* save the return address */
d5233 1
a5233 3
	  move_register( R_LR, R_DS, FALSE );
  
	  /* put PC into R_LR */
d5235 1
a5235 1
	  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );
d5237 1
a5237 1
	  /* adjust symbol offset to be relative to next instruction */
d5239 1
a5239 1
	  flush_peepholer( "getting address of LAJ" );
d5241 2
a5242 1
	  peep_protect_pc = 3;
d5246 1
a5246 15
	  offset = codep + codebase - offset + (3 * sizeof_int);

	  /*
	   * XXX - the following NOP is because of a bug in the C40
	   * silicon, whereby R_LR is occiaisionally not set by the
	   * LAJ until the second instruction after the LAJ
	   */

	  nop( FALSE );
      
	  /* prevent this NOP from being peepholed */
  
	  flush_peepholer( "LAJ bug 2" );

	  /* retreive PC from R_LR */
a5247 2
	  move_register( R_LR, VAL_REG, FALSE );
	  
d5255 1
a5255 3
	  if (offset)
	    {
	      /* indicate that the next instruction will reference 'symbol' */
d5257 5
a5261 8
	      peep_symref( name );
	      
	      integer_immediate_op( OP_SUBI, OP_SUBI3, VAL_REG, VAL_REG, offset, TRUE );
	    }
	  else
	    {
	      nop( FALSE );
	    }
d5263 3
a5265 3
	  /* restore link register */
	  
	  move_register( R_DS, R_LR, FALSE );
d6617 8
a7718 39

/*
 * output an instruction using register addressing
 */

static void
register_op(
	    int32		diadic_op,
	    int32		triadic_op,
	    RealRegister	dest,
	    RealRegister	source1,
	    RealRegister	source2,
	    bool		can_commute )
{
  if (source1 == dest)
    {
      out_diadic_op( diadic_op, ADDR_MODE_REGISTER, dest, source2,
		     examines2( dest, source2 ),
		     alters2( dest, RR_ST ) );
    }
  else if (can_commute && source2 == dest)
    {
      out_diadic_op( diadic_op, ADDR_MODE_REGISTER, dest, source1,
		     examines2( dest, source1 ),
		     alters2( dest, RR_ST ) );
    }
  else
    {
      out_triadic_op( triadic_op, dest, source1, source2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( source1, source2 ),
		     alters2( dest, RR_ST ) );
    }

  peep_forget_about( dest );
  
  return;
  
} /* register_op */
  
@


1.193
log
@fixed bug in calculating addresses of strings and added new mega-optimisation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.192 1992/06/16 13:33:22 nickc Exp nickc $ */
d3793 5
a3797 2
      if (is_local( x ))
        {
d3799 1
a3799 1
	   * A previously defined local (= static) data symbol
a3800 12

	  
	  if (symbol == bindsym_( datasegment ))
            {
	      Symstr *	newsymbol;


	      if (suppress_module || !fits_in_16_bits_signed( offset ))
		{
		  /*
		   * try to eliminate reference to __dataseg
		   */
d3802 6
a3807 28
		  if ((newsymbol = find_nearest_symbol( symbol, offset )) != NULL)
		    {
		      offset += symext_( symbol )->extoffset - symext_( newsymbol )->extoffset;		  
		      symbol = newsymbol;
		      x      = symext_( symbol );
		    }
		}
	      else
		{
		  /*
		   * XXX - NC - 17/6/92
		   *
		   * do not bother to load the offset of __dataseg
		   * we know that it is 0 !!!!
		   */
		  
		  load_static_data_ptr( dest, FALSE, symbol );

		  if (offset)
		    {
		      integer_immediate_op( OP_ADDI, OP_ADDI3, dest, dest, offset, TRUE );
		    }

		  peep_forget_about( dest );

		  return;
		}
            }
d3810 1
a3810 7
      /*
       * get the address of the data slots of the current module into 'tmp'
       */
      
      load_static_data_ptr( dest, FALSE, symbol );

      if (much_data)
d3813 1
a3813 1
	   * load R_TMP1 with the high part offset of 'symbol' into the data table
d3815 2
a3816 24

	  peep_xref( X_DataSymbHi, symbol );
     
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
			examines0(),
			alters1( R_TMP1 ) );

	  /*
	   * load R_TMP1 with the low part offset of 'symbol' into the data table
	   *
	   * Note that we cannot include 'offset' in this part of the addition because
	   * the sum of 'offset' and the low part of 'symbol's offset might exceeed 16
	   * bits
	   */

	  peep_xref( X_DataSymbLo, symbol );
     
	  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
			examines1( R_TMP1 ),
			alters1( R_TMP1 ) );	/* XXX - do not mention setting ST flag as ADDI does that */
	  
	  /*
	   * and add R_TMP1 into dest
	   */
d3818 1
a3818 1
	  if (offset)
d3820 42
a3861 5
	      integer_immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );

	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			    examines2( dest, R_TMP1 ),
			    alters2( dest, RR_ST ) );
d3865 4
a3868 2
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			    examines2( dest, R_TMP1 ),
d3870 5
d3879 1
a3879 1
	  peep_xref( X_DataSymbLo, symbol );
d3881 6
a3886 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, 0,
			examines1( dest ),
			alters2( dest, RR_ST ) );
@


1.192
log
@fixed bug in register based right shifts
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.191 1992/06/10 09:38:51 nickc Exp nickc $ */
d3457 6
a3462 5
  
/* This routine will find another data symbol with the same offset */
/* as the one provided as its argument. This is used in the helios */
/* compiler when compiling with the -r flag so that we don't       */
/* have lots of ___dataseg symbols.                                */
d3465 3
a3467 1
find_data_start( Symstr * name, int32 offset )
d3470 3
a3472 2
  ExtRef *	dext;

d3474 1
a3474 1
  /* fprintf( stderr, "find_data_start: called for symbol %s\n", symname_( name ) ); */
d3476 1
a3476 1
  dext = r = ((ExtRef *)symext_( name ))->extcdr;
d3478 5
d3485 13
a3497 4
      /* fprintf( stderr, "find_data_start: checking symbol %s\n", symname_( r->extsym ) ); */
      
      if (is_data( r )  && (r->extoffset == (dext->extoffset + offset)))
	return r->extsym;
d3500 1
a3500 1
  /* fprintf( stderr, "find_data_start: failed\n" ); */
d3502 1
a3502 1
  return 0;
d3504 1
a3504 1
} /* find_data_start */
d3802 1
a3802 1
	      Symstr *	newsymbol = find_data_start( symbol, offset );
d3805 1
a3805 1
	      if (newsymbol)
d3807 10
a3816 3
		  symbol = newsymbol;
		  x      = symext_( symbol );
		  offset = 0;
d3818 1
a3818 1
	      else if ((newsymbol = find_data_start( symbol, 0 )) != NULL)
d3820 17
a3836 2
		  symbol = newsymbol;
		  x      = symext_( symbol );
d4554 1
a4554 1
   * XXX - this is done as a seperate instruction becuase we cannot
@


1.191
log
@fixed bug remembering contents of a register after it has been converted
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.190 1992/06/10 08:58:57 nickc Exp nickc $ */
a9150 2
  RealRegister		r1  = vr1.r;
  RealRegister		r2  = vr2.r;
d9152 2
a9153 2
  RealRegister		r1r = r1;
  RealRegister		r2r = r2;
d9430 1
a9430 1
      load_address_constant( r1r, (Symstr *)m, (int32)r2 );
d9689 1
a9689 1
       * the compiler currently thinks that we have 'r2' bytes
d9695 1
a9695 1
	  int32	oldstack = (int32)r2;
d10637 13
a10649 1
      /* negate 'mr' and move into 'r1r' */
d10651 3
a10653 3
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, r1r, mr,
		    examines1( mr ),
		    alters2( r1r, RR_ST ) );
d10655 4
a10658 1
      /* 'r1r' = 'r2r' >> 'r1r' */
d10660 2
a10661 2
      out_triadic_op( OP_ASH3, r1r, r2r, r1r, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( r1r, r2r ),
d10665 1
d10675 13
a10687 1
      /* negate 'mr' and move into 'r1r' */
d10689 3
a10691 3
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, r1r, mr,
		    examines1( mr ),
		    alters2( r1r, RR_ST ) );
d10693 4
a10696 1
      /* 'r1r' = 'r2r' >> 'r1r' */
d10698 2
a10699 2
      out_triadic_op( OP_LSH3, r1r, r2r, r1r, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( r1r, r2r ),
@


1.190
log
@fixed compiler detected warnings
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.189 1992/06/08 14:50:23 nickc Exp nickc $ */
d1425 4
@


1.189
log
@fixed bug in store_double_indirect
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.188 1992/06/05 17:17:33 nickc Exp nickc $ */
d9042 1
a9042 1
  int		i;
@


1.188
log
@fixed bug in store double_double_indirect
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.187 1992/06/05 08:32:26 nickc Exp nickc $ */
d2922 2
a2923 2
      out_triadic_op( OP_ADDI3, ar, val, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( val, offset ),
@


1.187
log
@fixed bug in inline FP divide
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.186 1992/06/02 10:15:51 nickc Exp nickc $ */
d2923 1
a2923 1
		     examines2( val, ar ),
@


1.186
log
@added inline FP divide
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.185 1992/05/22 16:48:46 nickc Exp nickc $ */
d3290 1
a3290 7
#if 0
  /* forget about the contents of address registers after a branch */

  peep_corrupt_all_addr_regs();
#endif
  
  /* dont keep pushes pending */
d3293 1
a3293 1
  
d3346 1
a3346 2
      if (condition != Q_AL)
	flush_peepholer( "backward conditional branch" );
d3355 1
a3355 1
	  
d8946 1
a8946 1
  if (dest == top)
@


1.185
log
@added support for inline FP divide
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.184 1992/05/22 10:32:06 nickc Exp nickc $ */
d8915 217
d10416 11
d10579 1
a10579 111
	{
	  RealRegister	bottom;
	  RealRegister	tmp;
	  bool		must_restore_bottom = FALSE;
	  bool		must_restore_tmp    = FALSE;
	  

	  /* r1r = r2r / mr */

	  if (saved_ivars & regbit( R_LR ))
	    {
	      /* use R_LR as an FP temporary ! */

	      bottom = R_LR;
	    }
	  else
	    {
	      /* find a free (integer) register */
	      
	      bottom = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R8, RR_R9, RR_R10, GAP );

	      if (bottom == GAP)
		{
		  bottom = RR_R10;

		  must_restore_bottom = TRUE;

		  move_register( bottom, R_TMP1, FALSE );
		}
	    }

	  if (r1r == r2r)
	    {
	      int32	oldmask = usedmaskvec.map[ 0 ];

	      
	      /* prevent 'bottom' register from being selected */
	      
	      usedmaskvec.map[ 0 ] |= regbit( bottom );

	      tmp = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R8, RR_R9, RR_R10, GAP );

	      usedmaskvec.map[ 0 ] = oldmask;
	      
	      if (tmp == GAP)
		{
		  tmp = RR_R9;

		  must_restore_tmp = TRUE;

		  move_register( tmp, R_TMP2, FALSE );
		}
	    }
	  else
	    {
	      /* use destination as a temporary register */
	      
	      tmp = r1r;
	    }
      
	  out_diadic_op( OP_RCPF, ADDR_MODE_REGISTER, bottom, mr,
			examines1( mr ),
			alters2( bottom, RR_ST ) );
	  out_triadic_op( OP_MPYF3, tmp, bottom, mr, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( bottom, mr ),
			 alters2( tmp, RR_ST ) );

	  out_diadic_op( OP_SUBRF, ADDR_MODE_IMMEDIATE, tmp, 0x1000,	/* 0x1000 = 2.0 */
			examines1( tmp ),
			alters2( tmp, RR_ST ) );

	  out_diadic_op( OP_MPYF, ADDR_MODE_REGISTER, bottom, tmp,
			examines2( bottom, tmp ),
			alters2( bottom, RR_ST ) );

	  /* repeat last three instruction */
      
	  out_triadic_op( OP_MPYF3, tmp, bottom, mr, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( bottom, mr ),
			 alters2( tmp, RR_ST ) );

	  out_diadic_op( OP_SUBRF, ADDR_MODE_IMMEDIATE, tmp, 0x1000,	/* 0x1000 = 2.0 */
			examines1( tmp ),
			alters2( tmp, RR_ST ) );

	  out_diadic_op( OP_MPYF, ADDR_MODE_REGISTER, bottom, tmp,
			examines2( bottom, tmp ),
			alters2( bottom, RR_ST ) );

	  /* round before multiplying */

	  out_diadic_op( OP_RND, ADDR_MODE_REGISTER, bottom, bottom,
			examines1( bottom ),
			alters2( bottom, RR_ST ) );

	  /* finally multiply and place in destination */

	  out_triadic_op( OP_MPYF3, r1r, bottom, r2r, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( bottom, r2r ),
			 alters2( r1r, RR_ST ) );

	  if (must_restore_tmp)
	    {
	      move_register( R_TMP2, tmp, FALSE );
	    }

	  if (must_restore_bottom)
	    {
	      move_register( R_TMP1, bottom, FALSE );
	    }
	}
d10581 1
d10583 1
a10583 1
#endif
@


1.184
log
@improved store_double_relative
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.183 1992/05/20 17:12:56 nickc Exp nickc $ */
d3290 1
d3294 1
d3352 2
a3353 1
      flush_peepholer( "backward conditional branch" );
d3356 2
a3357 1
      off = (w - codep) / sizeof_int - 3;		/* calculate offset (in words) (the -3 is because of the delay in the branch)  */
d3362 6
a3367 4
	     
	  outdelayed( OP_BRD << 24 | (off & 0xffffff),
		     examines0(),
		     alters1( RR_PC ) );
d10348 118
@


1.183
log
@added some (commented out) debugging
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.182 1992/05/20 15:36:39 nickc Exp nickc $ */
d1028 2
d1044 2
d1065 2
d1086 2
d1113 2
d1140 2
d1922 1
a1922 1
  RealRegister	ar = R_ATMP;
d2139 1
a2139 3
	      
  out_immediate_offset( OP_LDF, dst, src, offset, can_corrupt_src );
      
d2142 5
d2148 2
a2149 2
      
      if (offset)
d2151 1
a2151 1
	  if (!fits_in_8_bits_unsigned( abs( offset ) ))
d2153 4
a2156 4
	      ar = peep_find_loaded_addr_reg( src, NULL, NULL );

	      if (ar == GAP)
		syserr( "back end: lost address register" );
d2159 2
a2160 2
			    build_indirect( INDIRECT_PRE_ADD, ar, 1 ),
			    examines1( ar ),
d2165 37
a2201 1
	      /* catch a potential nasty */
d2203 19
a2221 1
	      if (!fits_in_8_bits_unsigned( offset + 1 ))
d2223 1
a2223 5
		  ar = peep_get_free_addr_reg( GAP );

		  move_register( src, ar, FALSE );
		  
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, ar, offset + 1,
d2226 2
a2227 3
		  
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
				build_indirect( INDIRECT_REL, ar, 0 ),
a2229 2

		  peep_note_addr_reg_loaded( ar, src, offset + 1, FALSE );
d2233 10
a2242 3
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
				build_indirect( INDIRECT_PRE_ADD, src, offset + 1 ),
				examines1( src ),
d2245 6
d2254 13
a2266 3
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_SUB, src, -offset - 1 ),
			    examines1( src ),
d2268 7
d2277 14
a2290 1
      else
d2292 1
a2292 2
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
			build_indirect( INDIRECT_PRE_ADD, src, 1 ),
d2294 1
a2294 1
			alters2( dst, RR_ST ) );
d2296 6
a2301 3
    }
  else if (can_corrupt_src && is_address_register( hardware_register( src )))
    {
d2303 1
a2303 1
		    build_indirect( INDIRECT_PRE_ADD, src, 1 ),
d2305 3
a2307 1
		    alters2( dst, RR_ST ) );
d2311 4
a2314 3
      if (src == R_ATMP)
	{
	  /* XXX - this can happen with the code generated during the static data initialisation phase */
d2316 1
a2316 3
	  ar = RR_AR2;
	}
      else
d2318 1
a2318 4
	  ar = peep_find_loaded_addr_reg( src, NULL, NULL );
	  
	  if (ar == GAP)
	    ar = peep_get_free_addr_reg( src );
d2323 1
a2323 1
	      
d2328 29
a2356 2
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
		    build_indirect( INDIRECT_PRE_INCR, ar, 1 ),
d2362 5
a2366 1

d2368 1
a2368 1

d2389 1
a2389 1
  if (!is_float( val ))
a2394 2
  out_immediate_offset( OP_STF, val, addr, offset, can_corrupt_addr );
  
d2397 13
d2411 2
a2412 2
      
      if (offset)
d2414 1
a2414 1
	  if (!fits_in_8_bits_unsigned( abs( offset ) ))
d2416 3
a2418 4
	      ar = peep_find_loaded_addr_reg( addr, NULL, NULL );

	      if (ar == GAP)
		syserr( "back end: lost address register again" );
d2420 2
a2421 3
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val,
			    build_indirect( INDIRECT_PRE_ADD, ar, 1 ),
			    examines2( val, ar ),
d2426 35
a2460 1
	      /* catch a potential nasty */
d2462 19
a2480 1
	      if (!fits_in_8_bits_unsigned( offset + 1 ))
d2482 1
a2482 5
		  ar = peep_get_free_addr_reg( GAP );

		  move_register( addr, ar, FALSE );
		  
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, ar, offset + 1,
d2485 3
a2487 4
		  
		  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val,
				build_indirect( INDIRECT_REL, ar, 0 ),
				examines1( ar ),
a2488 2

		  peep_note_addr_reg_loaded( ar, addr, offset + 1, FALSE );
d2492 10
a2501 3
		  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val,
				build_indirect( INDIRECT_PRE_ADD, addr, offset + 1 ),
				examines2( val, addr ),
d2504 6
d2513 13
a2525 3
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val,
			    build_indirect( INDIRECT_PRE_SUB, addr, -offset - 1 ),
			    examines2( val, addr ),
d2527 7
d2536 14
a2549 1
      else
d2551 3
a2553 4
	  out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val,
			build_indirect( INDIRECT_REL, addr, 0 ),
			examines2( val, addr ),
			alters0() );
d2555 6
a2560 5
    }
  else if (can_corrupt_addr && is_address_register( hardware_register( addr )))
    {
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val,
		    build_indirect( INDIRECT_PRE_INCR, addr, 1 ),
d2562 3
a2564 1
		    alters1( addr ) );
d2568 4
a2571 3
      if (addr == R_ATMP)
	{
	  /* XXX - this can happen with the code generated during the static data initialisation phase */
d2573 1
a2573 3
	  ar = RR_AR2;
	}
      else
d2575 1
a2575 4
	  ar = peep_find_loaded_addr_reg( addr, NULL, NULL );
	  
	  if (ar == GAP)
	    ar = peep_get_free_addr_reg( addr );
d2580 1
a2580 1
	      
d2585 29
a2613 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val,
		    build_indirect( INDIRECT_PRE_INCR, ar, 1 ),
d2616 1
a2616 1

d2625 1
d2947 1
a2947 1
} /* load_double_indirect */
d3003 2
d3011 2
d9755 2
@


1.182
log
@fixed bug in OP_RPTBD
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.181 1992/05/20 08:38:12 nickc Exp nickc $ */
d4659 15
@


1.181
log
@removed compiler warning message
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.180 1992/05/19 14:00:21 nickc Exp nickc $ */
d4731 2
a4732 2
		   examines0(),
		   alters3( RR_RC, RR_RS, RR_RE ) );
d6486 6
d6494 4
a6503 4

      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_FP, build_indirect( INDIRECT_REL, R_FP, 0 ),
		    examines1( R_FP ),
		    alters2( R_FP, RR_ST ) );
d7013 2
a7014 2
		   examines0(),
		   alters3( RR_RC, RR_RS, RR_RE ) );
d7312 2
a7313 2
		   examines0(),
		   alters3( RR_RC, RR_RS, RR_RE ) );
@


1.180
log
@added support for back tracing
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.179 1992/05/18 16:02:08 nickc Exp nickc $ */
d7527 1
d7529 4
a7532 9
	  
	  if (half_word_op)
	    {
	      selector = (offset & 0x2) >> 1;
	    }
	  else
	    {
	      selector = offset & 0x3;
	    }
a7597 3
	      int32		op;

	      
d7600 1
a7600 8
		  if (is_signed)
		    {
		      op = OP_LH;
		    }
		  else
		    {
		      op = OP_LHU;
		    }
d7604 1
a7604 8
		  if (is_signed)
		    {
		      op = OP_LB;
		    }
		  else
		    {
		      op = OP_LBU;
		    }	  
d7622 7
a7628 5
	      outinstr( FUNC_LOAD                             << 28   |
		       (half_word_op ? (OP_MH << 24) : (OP_MB << 24)) |
		       selector                               << 23   |
		       ADDR_MODE_REGISTER                     << 21   |
		       hardware_register( R_TMP1 )            << 16   |
d7962 14
a7975 4
	  conditional_load( Q_AL, ADDR_MODE_INDIRECT, R_TMP1,
			   build_indirect( absolute ? INDIRECT_REL : INDIRECT_PRE_INCR_IR0, addr, 0 ),
			   absolute ? examines1( addr ) : examines2( addr, R_BASE ),
			   absolute ? alters1( R_TMP1 ) : alters2( R_TMP1, addr ) );
@


1.179
log
@fixed bugs storing doubles
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.178 1992/05/15 13:12:53 nickc Exp nickc $ */
d2224 1
a2224 1
		    build_indirect( INDIRECT_PRE_ADD, ar, 1 ),
d2226 1
a2226 1
		    alters2( dst, RR_ST ) );
d2228 1
a2228 1
      peep_note_addr_reg_loaded( ar, src, offset + 1, TRUE );
d5159 2
d5162 1
a5162 6
  /* argument registers will be corrupted by a call, so flush any pushes using them */

  for (dest = R_A1; dest < R_A1 + NARGREGS; dest++)
    {
      maybe_flush_pending_push( dest );
    }
a5646 1
 *  setjmp, longjmp
d6001 3
a6003 2
  if (num_args > NARGREGS ||		/* if we have arguments passed on the stack */
      maskarg              )		/* or we have had to save arguments on the stack */
d8861 2
d10501 1
a10501 1
	  
@


1.178
log
@fixed bug introduced by attempt to convert OP_AND into OP_TSTB
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.177 1992/05/15 08:53:32 nickc Exp nickc $ */
d2251 1
a2251 1
  
d2327 1
a2327 1
		    build_indirect( INDIRECT_PRE_ADD, addr, 1 ),
d2355 1
a2355 1
		    build_indirect( INDIRECT_PRE_ADD, ar, 1 ),
d2359 1
a2359 1
      peep_note_addr_reg_loaded( ar, addr, offset + 1, TRUE );
@


1.177
log
@fixed bug in non_word_ops
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.176 1992/05/14 16:38:26 nickc Exp nickc $ */
d9944 13
a9956 29
      if (death & regbit( r1r ))
	{
	  /* the result register is not used, hence ... */

	  if (fits_in_16_bits_unsigned( m ))
	    {
	      /*
	       * XXX - note that we lie about setting r1r, so that
	       * the comparison to follow will known that the
	       * status register has been set to the contents
	       * of r1r.
	       */
	      
	      out_diadic_op( OP_TSTB, ADDR_MODE_IMMEDIATE, r2r, m,
			    examines1( r2r ),
			    alters2( r1r, RR_ST ) );
	    }
	  else 
	    {
	      RealRegister	tmp;


	      if (r1r == r2r)
		{
		  tmp = R_TMP1;
		}
	      else
		{
		  /* we know that r1r is dead, so ... */
a9957 14
		  tmp = r1r;
		}
	      
	      load_integer( tmp, m, FALSE );

	      out_diadic_op( OP_TSTB, ADDR_MODE_REGISTER, r2r, tmp,
			    examines2( r2r, tmp ),
			    alters2( r1r, RR_ST ) );	/* XXX - note lie */
	    }
	}
      else
	{
	  integer_immediate_op( OP_AND, OP_AND3, r1r, r2r, m, FALSE );
	}
d10073 1
a10073 13
      if (death & regbit( r1r ))
	{
	  /* the result register is not used, hence ... */

	  out_diadic_op( OP_TSTB, ADDR_MODE_REGISTER, r2r, mr,
			examines2( r2r, mr ),
			alters1( RR_ST ) );
	}
      else
	{
	  register_op( OP_AND, OP_AND3, r1r, r2r, mr, TRUE );
	}
      
@


1.176
log
@fixed bug in loading shorts
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.175 1992/05/14 16:11:33 nickc Exp nickc $ */
d7706 2
a7707 1
   *  addr    - byte offset (might be an alias for R_TMP1)
d7719 2
a7720 1
	   *    addr    - byte offset (might be an alias for R_TMP1)
d7728 13
a7740 4
	  
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			 examines1( addr ),
			 alters2( addr, RR_ST ) );
d7824 2
a7825 1
	   *    addr    - byte offset (might be an alias for R_TMP1)
d7834 4
a7837 2
	  out_triadic_op( OP_AND3, R_TMP2, addr, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( addr ),
d7841 2
a7842 1
	   *    addr    - byte offset (might be an alias for R_TMP1)
d7850 13
a7862 4
	  
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			 examines1( addr ),
			 alters2( addr, RR_ST ) );
d7950 2
a7951 1
	   *    addr    - byte offset
d7960 13
a7972 4
      
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			 examines1( addr ),
			 alters2( addr, RR_ST ) );
@


1.175
log
@added code to convert AND into TSTB when appropriate
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.174 1992/05/14 10:29:04 nickc Exp nickc $ */
d7767 1
a7767 1
			 R_TMP1,
d7771 2
a7772 2
			 examines2( R_TMP1, addr ) :
			 examines3( R_TMP1, addr, R_BASE ),
d7875 1
a7875 1
			 examines3( addr, R_TMP3, R_BASE ),
@


1.174
log
@tided uo ExtRef macros
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.173 1992/05/14 09:30:52 nickc Exp nickc $ */
d1260 1
a1260 1
	syserr( "back end: trying to add a non-wordd offset to a word pointer" );
d9910 44
a9953 1
      integer_immediate_op( OP_AND, OP_AND3, r1r, r2r, m, FALSE );
d10069 13
a10081 1
      register_op( OP_AND, OP_AND3, r1r, r2r, mr, TRUE );
@


1.173
log
@removed generationg of LDA for simulator code
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.172 1992/05/14 08:59:46 nickc Exp nickc $ */
d3212 1
a3212 1
      if ((r->extflags & xr_data)  && (r->extoffset == (dext->extoffset + offset)))
d3456 1
a3456 1
	  if (symext_( symbol )->extflags & xr_data)
d3501 1
a3501 1
  if (is_data( x->extflags ) && is_defined( x->extflags ))
d3509 1
a3509 1
      if (is_local( x->extflags ))
d4999 1
a4999 1
      if (!is_data( x->extflags ))
d5002 1
a5002 1
      if (is_defined( x->extflags ))
@


1.172
log
@removed debugging
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.171 1992/05/13 15:26:45 nickc Exp nickc $ */
d3312 1
d3324 10
d3385 1
a3385 1
      out_diadic_op( OP_LDA, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, tmp, 0 ),
a3390 3
      int32	op;

      
a3397 6
      if (is_special_register( hardware_register( r ) ) &&
	  var_cc_private_flags == 0)	/* simulator cannot cope with LDA */
	op = OP_LDA;
      else
	op = OP_LDI;
      
@


1.171
log
@changed to work with new mcdpriv.h and new data initialisation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.170 1992/05/11 16:27:46 nickc Exp nickc $ */
d3374 1
a3374 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, tmp, 0 ),
d5008 4
a5013 3
	  debug( "local symbol, offset = %d, off = %d",
		offset, ((ExtRef *)(symext_( name )->extcdr))->extoffset );
	  
@


1.170
log
@added code for new style block copy initialisation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.169 1992/05/06 15:47:53 nickc Exp nickc $ */
a73 24
/* exports:
   void         show_instruction( J_OPCODE op, VRegInt r1, VRegInt r2, VRegInt m );
   RealRegister local_base( Binder * b );
   int32        local_address( Binder * b );
   bool         immed_cmp( int32 );
   bool         target_isaddrreg( RealRegister r );
   also (beware peephole):
   void         setlabel( LabelNumber * );
   void         branch_round_literals( LabelNumber * );
   void		load_static_data_ptr( RealRegister r, bool iscode, Symstr * symbol );
   bool		fpliteral( FloatCon * val, J_OPCODE op );
   added for 'C40
   void		prepare_for_initialisation( int data_init, LabelNumber * data_label );
   void		prepare_for_function_exporting( void );
   void		prepare_for_data_exporting( RealRegister ptr );
   void		block_data_init( int32 num_words, LabelNumber * start, RealRegister dest );
   void		export_function( Symstr * name, RealRegister dest );
   void		export_data_symbol( Symstr * name, RealRegister dest, int rpt, int offset, int len, int current_offset  );
   void		export_data_value( RealRegister source, RealRegister dest, int32 val, int32 increment ); 
v   void		export_data_float( RealRegister source, RealRegister dest ); 
   void		finished_exporting( void );
   int32	hardware_register( RealRegister r )
*/

a105 1
void			correct_stack( bool flush_pushes );
a120 16
extern int		split_module_table;
extern FILE *		asmstream;		/* accessed for debugging purposes */

extern unsigned long	abs( signed long );
extern signed long	mask_and_sign_extend_word( unsigned long word, unsigned long mask );
extern int32		IEEE_to_extended_float( int32 high, int32 low, int32 * low_return );
extern int32		IEEE_to_single_float( int32 val );
extern void		decode_instruction( int32 op_code, bool flag_errs );

#ifdef TARGET_HAS_DEBUGGER
extern void 		debugger_add_line( int32 linenumber );
extern void		debugger_end_of_function( void );      
#endif
      
LabelNumber *		base_label;

d128 2
a129 1
void IOdebug( const char * format, ... )
a3474 7
#define xr_definition			(xr_defloc | xr_defext)
#define xr_external_code		(xr_code   | xr_defext)
#define is_defined( flags )		((flags)  & xr_definition)
#define is_code( flags )		((flags)  & xr_code)
#define is_data( flags )		((flags)  & xr_data)
#define is_external_code( flags )	(((flags) & xr_external_code) == xr_external_code)

d3507 1
a3507 1
      if ((x->extflags & xr_defloc))
d4445 2
a4446 2
		 Symstr *	name,
		 RealRegister	dest )
d4613 1
a4613 1
 * initialise the module's static data area by a block copy operation
d4616 4
d4621 1
a4621 4
block_data_init(
		int32		words_of_data,	/* number of whole words of data to copy */
		LabelNumber *	start_of_data,	/* label at start of data to copy	 */
		RealRegister	dest_of_data )	/* word pointer to destination of copy	 */
a4622 14
  LabelNumber *	l;  
  RealRegister	tmp  = RR_R1;
  RealRegister	atmp = R_ADDR1;
  
  
  if (words_of_data < 2)
    syserr( "back end: block_data_init: too little data to init" );
  
  /*
   * copy the data from the label specified to
   * the area pointed to by dest_of_data (a word
   * pointer)
   */

d4643 1
a4643 1
  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, atmp, -3,
d4645 1
a4645 1
		alters2( atmp, RR_ST ) );
d4649 3
a4651 3
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, atmp, R_LR,
		examines2( atmp, R_LR ),
		alters2( atmp, RR_ST ) );
a4652 4
  /* load repeat count */

  load_integer( RR_RC, words_of_data - 2, FALSE );

d4657 4
a4660 1
  /* load first word */
d4662 16
a4677 5
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, atmp, 1 ),
		examines1( atmp ),
		alters3( tmp, RR_ST, atmp ) );
  
  /* start repeat block */
d4679 27
a4705 1
  l = nextlabel();
d4707 18
a4724 5
  outdellabref( (OP_RPTBD << 24) | (-3 & 0x00FFFFFFU),
	       l,
	       LABREF_OFF24,
	       examines0(),
	       alters3( RR_RC, RR_RS, RR_RE ) );
d4726 38
a4763 1
  setlabel( l );
d4765 10
a4774 7
  /*
   * instruction repeated is:
   *
   *  LDI    *R_ADDR1++(1), R1
   *  || STI  R1,          *R_ATMP++(1)
   *
   */
d4776 9
a4784 16
  outinstr( B_1101 << 28 | B_1010 << 24 |
	   hardware_register( tmp ) << 22 | hardware_register( tmp ) << 16 |
	   build_parallel_indirect( INDIRECT_POST_INCR, dest_of_data ) << 8 |
	   build_parallel_indirect( INDIRECT_POST_INCR, atmp ),
	   examines3( atmp, tmp, dest_of_data ),
	   alters3(   atmp, tmp, dest_of_data ) );

  /* prevent the repeated instruction from being peepholed */
      
  flush_peepholer( "copy memory" );
      
  /* save last word */
      
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest_of_data, 1 ),
		examines2( tmp, dest_of_data ),
		alters1( dest_of_data ) );
d4786 5
a4790 1
  return;  
d4792 1
a4792 1
} /* block_data_init */
d4794 1
d4797 2
a4798 2
 * store it in the word pointed to by 'reg', and
 * increment 'reg' by 'len' bytes.
d4805 1
a4805 3
 * Note 'reg' is a now a word pointer.
 *
 * Also note that 'reg' is very probably 'R_ATMP'.
d4811 2
a4812 5
		   RealRegister	reg,		/* register containing destination of store */
		   int		rpt,		/* number of times this operation is to be performed */
		   int32	offset,		/* offset from symbol to store */
		   int32	len,		/* amount to increment 'reg' (in bytes) after storing */
		   int32	current_offset )/* the current offset (in bytes) of 'reg' from start of data table */
a4813 3
  if (rpt > 1)
    syserr( "back end: export_data_symbol: not ready for repeated exports!" );
  
d4820 1
a4820 1
       * we know that reg holds IR0 + [static_data_ptr + current_offset] / sizeof_int
d4824 5
a4830 2
       *
       * XXX - note assumption that offset is a whole multiple of sizeof_int
d4835 1
a4835 4
      if (offset & 3)
	syserr( "back end: export_data_symbol: non word aligned offset!" );
      
      offset /= sizeof_int;		/* XXX note assumption that sizeof_int == 4 */
d4837 3
a4839 5
      /* get 'reg' - IR0 into temporary register */

      out_triadic_op( OP_SUBI3, R_TMP1, reg, R_BASE, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( reg, R_BASE ),
		     alters2( R_TMP1, RR_ST ) );
d4843 1
a4843 1
      integer_immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );
d4847 3
a4849 3
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP1, 2,
		     examines1( R_TMP1 ),
		     alters2( R_TMP1, RR_ST ) );
d4851 1
a4851 1
      /* result is now in R_TMP1, ready to store */
d4873 1
a4873 1
	  move_register( R_LR, R_ADDR1, FALSE );
d4903 1
a4903 1
	  move_register( R_LR, R_TMP1, FALSE );
d4918 1
a4918 1
	      integer_immediate_op( OP_SUBI, OP_SUBI3, R_TMP1, R_TMP1, offset, TRUE );
d4927 1
a4927 1
	  move_register( R_ADDR1, R_LR, FALSE );
d4945 1
a4945 1
	      move_register( R_MT, R_ADDR1, FALSE );
d4955 3
a4957 3
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ADDR1, 0,
			    examines1( R_ADDR1 ),
			    alters2( R_ADDR1, RR_ST ) );
d4961 3
a4963 3
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ADDR1, build_indirect( INDIRECT_REL, R_ADDR1, 0 ),
			    examines1( R_ADDR1 ),
			    alters2( R_ADDR1, RR_ST ) );
d4969 4
a4972 4
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ADDR1,
			    build_indirect( INDIRECT_PRE_ADD, R_ADDR1, 0 ),
			    examines1( R_ADDR1 ),
			    alters2( R_ADDR1, RR_ST ) );
d4979 3
a4981 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ADDR1, 0,
			examines1( R_ADDR1 ),
			alters2( R_ADDR1, RR_ST ) );
d4985 3
a4987 3
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, R_ADDR1, 0 ),
			examines1( R_ADDR1 ),
			alters2( R_TMP1, RR_ST ) );
d4990 1
a4990 1
      /* result is now in R_TMP1, ready to store */
d5010 3
d5014 2
a5015 2
      
	  load_static_data_ptr( R_ADDR1, FALSE, name );
d5029 1
a5029 1
	      move_register( R_MT, R_ADDR1, FALSE );
d5033 7
a5039 7
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ADDR1, 0,
			    examines1( R_ADDR1 ),
			    alters2( R_ADDR1, RR_ST) );

	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ADDR1, build_indirect( INDIRECT_REL, R_ADDR1, 0 ),
			    examines1( R_ADDR1 ),
			    alters2( R_ADDR1, RR_ST ) );
d5045 4
a5048 4
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ADDR1,
			    build_indirect( INDIRECT_PRE_ADD, R_ADDR1, 0 ),
			    examines1( R_ADDR1 ),
			    alters2( R_ADDR1, RR_ST ) );
d5053 1
a5053 1
       * load R_TMP1 with the high part offset of 'symbol' into the data table
d5060 1
a5060 1
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
d5062 1
a5062 1
			alters1( R_TMP1 ) );
d5065 1
a5065 1
	   * load R_TMP1 with the low part offset of 'symbol' into the data table
d5070 3
a5072 3
	  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
			examines1( R_TMP1 ),
			alters1( R_TMP1 ) );	/* XXX - note lie about not affecting RR_ST */
d5078 1
a5078 1
	  conditional_load( Q_AL, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
d5080 1
a5080 1
			   alters1( R_TMP1 ) );
d5084 1
a5084 1
       * and add R_ADDR1 to R_TMP1
d5095 3
a5097 3
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
			    examines1( R_TMP1 ),
			    alters2( R_TMP1, RR_ST ) );
d5099 3
a5101 3
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_TMP1, R_ADDR1,
			    examines2( R_ADDR1, R_TMP1 ),
			    alters2( R_TMP1, RR_ST ) );
d5106 3
a5108 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_TMP1, R_ADDR1,
			examines2( R_ADDR1, R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );
a5110 9
  
  /* ensure word pointer's increment is in words */
      
  if (len & 3)
    syserr( "back end: export_data: non word aligned address increment" );
      
  len /= sizeof_int;

  /* and store resultant address, incrementing word pointer */
d5112 1
a5112 24
  if (len == 0)
    {
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, reg, 0 ),
		    examines2( reg, R_TMP1 ),
		    alters0() );
    }
  else if (fits_in_8_bits_signed( len ))
    {
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, reg, len ),
		    examines2( reg, R_TMP1 ),
		    alters1( reg ) );
    }
  else
    {
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, reg, 0 ),
		    examines2( reg, R_TMP1 ),
		    alters0() );
      
      load_integer( R_TMP1, len, FALSE );
      
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, reg, R_TMP1,
		    examines2( reg, R_TMP1 ),
		    alters2( reg, RR_ST ) );
    }
d5114 3
a5122 113
 * this function is used to store a value into
 * the module's data slots.  It is called from
 * dumpdata() in c40/heliobj.c
 *
 * Note that 'dest' is a word pointer
 */

void
export_data_value(
		  RealRegister	source,		/* register containing the value to save */
		  RealRegister	dest,		/* word offset from IR0 of destination */
		  int32		value,		/* value to store */
		  int32		increment )	/* byte increment for 'dest' */
{
  /* XXX note dependency upon size of int */
  
  if (increment & 3)
    syserr( "back end: export_data_value: non word increment for word pointer" );

  increment /= sizeof_int;

#ifdef STIK_NOW_WORKS_ON_HARDWARE
  if (fits_in_5_bits_signed( value ))
    {
      /*
       * XXX
       *
       * in this case 'source' will not contain any valid value,
       * but we can use the STIK op code!
       */

      if (increment == 0)
	{
	  /* addressing mode is actually ADDR_MODE_INDIRECT */
	  
	  out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, value, build_indirect( INDIRECT_REL, dest, 0 ),
			examines1( dest ),
			alters0() );
	}
      else if (fits_in_8_bits_signed( increment ))
	{
	  out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, value,
			build_indirect( INDIRECT_POST_INCR, dest, increment ),
			examines1( dest ),
			alters1( dest ) );
	}
      else
	{
	  out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, value, build_indirect( INDIRECT_REL, dest, 0 ),
			examines1( dest ),
			alters0() );

	  load_integer( R_TMP1, increment, FALSE );

	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			 examines2( dest, R_TMP1 ),
			 alters2( dest, RR_ST ) );
	}
    }
  else
#endif /* STIK_NOW_WORKS_ON_HARDWARE */
    {
      if (increment == 0)
	{
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( source, dest ),
			alters0() );
	}
      else if (fits_in_8_bits_signed( increment ))
	{
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, source,
			build_indirect( INDIRECT_POST_INCR, dest, increment ),
			examines2( source, dest ),
			alters1( dest ) );
	}
      else
	{
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( source, dest ),
			alters0() );

	  load_integer( R_TMP1, increment, FALSE );

	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			 examines2( dest, R_TMP1 ),
			 alters2( dest, RR_ST ) );
	}
    }

  return;
  
} /* export_data_value */
  

/*
 * store (part of) a floating point value in a data slot
 * increment pointer to point to next word
 */

void
export_data_float(
		  RealRegister	val,
		  RealRegister	dest )
{
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
		examines2( dest, val ),
		alters1( dest ) );

  return;
  
} /* export_data_float */

/*
d6386 1
a6386 1
	      int32	tmp;
d6421 1
a6421 1
	      tmp = saved_ivars;
d6433 1
a6433 1
	      saved_ivars = tmp;
d6443 1
a6443 1
	      tmp &= ~(regbit( R_LR + 1 ) - 1);
d6447 1
a6447 1
	      if (tmp)
d6449 1
a6449 1
		  restore_regs( tmp, FALSE );
d7124 1
a7124 1
      RealRegister	tmp;
d7134 1
a7134 1
      tmp = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R6, RR_R7, GAP );
d7136 1
a7136 1
      if (tmp == GAP)
d7138 1
a7138 1
	  /* get first word into tmp */
d7162 1
a7162 1
	  /* get first word into tmp */
d7164 1
a7164 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_PRE_INCR_IR0, source, 0 ),
d7166 1
a7166 1
			alters3( tmp, RR_ST, source ) );
d7171 2
a7172 2
	   *    LDI  *<source>++(1), tmp
	   * || STI  tmp, *<dest>++(1)
d7177 1
a7177 1
		   hardware_register( tmp ) << 22 | hardware_register( tmp ) << 16 |
d7180 2
a7181 2
		   examines4( source, tmp, dest, R_BASE ),
		   alters3(   source, tmp, dest ) );
d7183 1
a7183 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_PRE_ADD, dest, 1 ),
d7193 1
a7193 1
      RealRegister	tmp;
d7216 1
a7216 1
      tmp = get_free_register( RR_R0, RR_R1, RR_R2, RR_R3, RR_R6, RR_R7, GAP );
d7219 1
a7219 1
      if (tmp == GAP)
d7221 1
a7221 1
	  tmp = R_ZERO;
d7224 1
a7224 1
      if (tmp == GAP)
d7227 1
a7227 1
	  tmp       = RR_R0;
d7230 1
a7230 1
	   * preserve tmp register
d7239 1
a7239 1
	  ipush( tmp );
d7262 1
a7262 1
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp,
d7265 1
a7265 1
				alters3( tmp, RR_ST, source ) );
d7269 1
a7269 1
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp,
d7272 1
a7272 1
				alters3( tmp, RR_ST, source ) );
d7278 1
a7278 1
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_REL, source, 0 ),
d7280 1
a7280 1
				alters2( tmp, RR_ST ) );
d7285 1
a7285 1
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_REL, source, 0 ),
d7287 1
a7287 1
			    alters2( tmp, RR_ST ) );
d7294 1
a7294 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_PRE_INCR_IR0, source, 0 ),
d7296 1
a7296 1
			alters3( tmp, RR_ST, source ) );
d7314 2
a7315 2
       *    LDI  *++<source>(1), tmp
       * || STI  tmp, *<dest>++(1)
d7320 1
a7320 1
	       hardware_register( tmp ) << 22 | hardware_register( tmp ) << 16 |
d7323 2
a7324 2
	       examines3( source, tmp, dest ),
	       alters3(   source, tmp, dest ) );
d7332 2
a7333 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
		    examines2( tmp, dest ),
d7337 3
a7339 3
      if (tmp == R_ZERO)
	out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, tmp, 0,
		      examines0(), alters1( tmp ) );
d7343 1
a7343 1
	  /* restore tmp register */
d7345 1
a7345 1
	  ipop( tmp );
@


1.169
log
@added support for inline op codes
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.168 1992/05/06 13:49:33 nickc Exp nickc $ */
d89 1
d4660 109
a5243 1
  
d5251 2
a5252 1
  flush_peepholer( "end of function exports" );
d5254 5
d7382 22
a7403 1
	      integer_immediate_op( OP_ADDI, OP_ADDI3, source, source, off, TRUE );
d7405 6
@


1.168
log
@improved non_word_op and allowed X_DataModule to work with large_model pragma
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.167 1992/05/02 12:06:17 nickc Exp nickc $ */
d10500 9
@


1.167
log
@added a new peephole optimisation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.166 1992/05/02 11:25:13 nickc Exp nickc $ */
d3419 3
d3429 6
d3442 1
a3442 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r,
d3449 1
a3449 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r,
d3610 19
d3634 2
a3635 15
	  conditional_load( Q_AL, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
			   examines0(),
			   alters1( R_TMP1 ) );
	}
      
      /*
       * and add R_TMP1 into dest
       */

      if (offset)
	{
	  integer_immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );

	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			examines2( dest, R_TMP1 ),
d3637 6
a3642 7
	}
      else
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			examines2( dest, R_TMP1 ),
			alters2( dest, RR_ST ) );
	}
d4100 6
a4105 4
	  
	  /*
	   * get address of module table into 'tmp'
	   */
d4107 1
a4107 1
	  move_register( R_MT, tmp, FALSE );
d4109 5
a4113 5
	  /*
	   * add in the offset of the module containing 'name'
	   *
	   * XXX - we asssume that there will never be more than 32767 modules
	   */
d4115 5
a4119 1
	  peep_xref( X_DataModule, symbol );
d4121 3
a4123 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
			examines1( tmp ),
			alters2( tmp, RR_ST ) );
d4125 14
a4138 8
	  /*
	   * get the address of the module's function table or data slots
	   */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, is_func ? tmp : dest,
			build_indirect( INDIRECT_REL, tmp, 0 ),
			examines1( tmp ),
			alters2( is_func ? tmp : dest, RR_ST ) );
d4225 1
a4225 1
	      else
d4228 3
a4230 12
	      
		  /*
		   * XXX - there is a potential bug here if the given offset plus the
		   * symbol's offset exceed 16 bits.
		   */
		  
		  conditional_load( Q_AL, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
				   examines0( ),
				   alters1( R_TMP1 ) );
		  
		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
				examines2( dest, R_TMP1 ),
d4232 7
d4814 3
a4816 1
	  /* copy module table pointer */
d4818 1
a4818 1
	  move_register( R_MT, R_ADDR1, FALSE );
d4820 5
a4824 5
	  /*
	   * add in the offset of the module containing 'name'
	   *
	   * XXX - we are assuming that there will never be more than 32767 modules
	   */
d4826 1
a4826 1
	  peep_xref( X_DataModule, name );
d4828 3
a4830 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ADDR1, 0,
			examines1( R_ADDR1 ),
			alters2( R_ADDR1, RR_ST ) );
d4832 1
a4832 1
	  /* get the address of that module's function table */
d4834 14
a4847 4
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ADDR1, build_indirect( INDIRECT_REL, R_ADDR1, 0 ),
			examines1( R_ADDR1 ),
			alters2( R_ADDR1, RR_ST ) );

d4897 3
a4899 1
	  move_register( R_MT, R_ADDR1, FALSE );
d4901 1
a4901 1
	  peep_xref( X_DataModule, name );
d4903 3
a4905 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ADDR1, 0,
			examines1( R_ADDR1 ),
			alters2( R_ADDR1, RR_ST) );
d4907 13
a4919 3
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ADDR1, build_indirect( INDIRECT_REL, R_ADDR1, 0 ),
			examines1( R_ADDR1 ),
			alters2( R_ADDR1, RR_ST ) );
d6380 2
a6397 7
	      /*
	       * another piece of optimisation here
	       * If we pull the link register into one of R0 - R7
	       * then we may be able to combine it with the previous
	       * instruction, making a parallel load !
	       */

d6399 21
a6419 1
		link_reg = R_FT1;	/* currently R6 */
d7465 1
a7465 1
  RealRegister	addr      = R_TMP1;
d7467 2
a7468 1
  
d7477 2
d7498 1
a7498 1
	  absolute = TRUE;
d7505 2
a7523 4
		  int32		off;
		  bool		biased;


d7644 5
d7663 1
a7663 1
	      addr = address;
a7681 5
  address = peep_get_free_addr_reg( addr );
  
  if (address == GAP)
    syserr( "back end: urg - this should not happen" );
  
d7692 1
a7692 49
      /*
       *    addr    - byte offset (might be an alias for R_TMP1)
       *    operand - free 
       *    R_TMP1  - free
       *    R_TMP2  - free
       *    R_TMP3  - free
       *
       * loose bottom two bits (byte selector) of offset
       * NB/ done before AND3 below to help avoid pipeline conflicts
       */
	  
      out_triadic_op( OP_LSH3, address, addr, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( addr ),
		     alters2( address, RR_ST ) );
	  
      /*
       *    addr    - byte offset (might be an alias for R_TMP1)
       *    address - word offset
       *    operand - free 
       *    R_TMP1  - free
       *    R_TMP2  - free
       *    R_TMP3  - free
       *
       * save non-word selector of address into R_TMP1
       */

      if (addr == R_TMP1)
	{
	  out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, R_TMP1, half_word_op ? 0x2 : 0x3, 
			 examines1( R_TMP1 ),
			 alters2( R_TMP1, RR_ST ) );
	}
      else
	{
	  out_triadic_op( OP_AND3, R_TMP1, addr,
			 half_word_op ? 0x2 : 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( addr ),
			 alters2( R_TMP1, RR_ST ) );
	}
      
      /*
       *    address - word offset
       *    operand - free
       *    R_TMP1  - half-word selector (0 or 2) or byte selector (0, 1, 2 or 3)
       *    R_TMP2  - free
       *    R_TMP3  - free
       */
      
      if (is_signed)
d7695 3
a7697 3
	   *    address - word offset
	   *    operand - free
	   *    R_TMP1  - half-word selector (0 or 2) or byte selector (0, 1, 2 or 3)
d7701 1
a7701 2
	   * invert selector
	   * NB/ done before load to help avoid pipeline conflicts
d7704 4
a7707 4
	  out_diadic_op( OP_XOR, ADDR_MODE_IMMEDIATE, R_TMP1, half_word_op ? 0x2 : 0x3,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );
	  
d7709 3
a7711 3
	   *    address - word offset
	   *    operand - free
	   *    R_TMP1  - NOT half-word selector (2 or 0) or NOT byte selector (3, 2, 1 or 0)
d7715 3
a7717 2
	   * convert to inverted bit position
	   * NB/ done before load to help avoid pipeline conflicts
d7720 9
a7728 4
	  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP1, 8,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );
	  
d7730 4
a7733 4
	   *    address - free
	   *    operand - free
	   *    R_TMP1  - inverted bit position (16 or 0) or (24, 16, 8 or 0)
	   *    R_TMP2  - word at destination
d7736 1
a7736 1
	   * shift source byte/half-word up into R_TMP2
d7738 1
a7738 1
	  
d7740 1
a7740 1
			 R_TMP2,
d7742 2
a7743 2
			  build_indirect( INDIRECT_REL, address, 0 ) :
			  build_indirect( INDIRECT_PRE_ADD_IR0, address, 0 ),
d7748 53
a7800 2
			  examines2( R_TMP1, address ) :
			  examines3( R_TMP1, address, R_BASE ),
d7804 2
a7805 2
	   *    address - free
	   *    operand - free
d7807 1
a7807 1
	   *    R_TMP2  - shifted word at destination
d7810 1
a7810 1
	   * shift source half-word down and place in destination
d7813 4
a7816 7
	  out_triadic_op( OP_ASH3, operand, R_TMP2, half_word_op ? -16 : -24,
			 ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( R_TMP2 ),
			 alters2( operand, RR_ST ) );
	}
      else /* is unsigned */
	{
d7818 1
a7818 1
	   *    address - word offset
d7820 2
a7821 2
	   *    R_TMP1  - half-word selector (0 or 2) or byte selector (0, 1, 2 or 3)
	   *    R_TMP2  - free
d7824 1
a7824 1
	   * convert selector to negated bit_position
d7827 5
a7831 5
	  
	  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP1, -8,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );
	  
d7833 1
a7833 1
	   *    address - word offset
d7835 2
a7836 2
	   *    R_TMP1  - half-word selector (0 or -16) or byte selector (0, -8, -16 or -24)
	   *    R_TMP2  - free
d7839 1
a7839 1
	   * shift source word to correct source alignment and place in operand
d7841 1
a7841 1
	  
d7843 1
a7843 1
			 operand,
d7845 3
a7847 3
			  build_indirect( INDIRECT_REL, address, 0 ) :
			  build_indirect( INDIRECT_PRE_ADD_IR0, address, 0 ),
			 R_TMP1,
d7851 66
a7916 3
			  examines2( address, R_TMP1 ) :
			  examines3( address, R_TMP1, R_BASE ),
			 alters2( operand, RR_ST ) );
d7918 2
a7919 2
	   *    address - free
	   *    operand - part of word at destination
d7924 43
a7966 1
	   * ensure rest of word is zero
d7968 14
a7981 1
	   * NB/ this is needed because code like
d7983 1
a7983 1
	   * int func( char * p ) { if (*p < 10) return 1; return 0 }
d7985 2
a7986 1
	   * does not mask result of load
d7988 4
d7993 9
a8001 32
	  out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, operand, half_word_op ? 0xFFFF : 0xFF,
			examines1( operand ),
			alters2( operand, RR_ST ) );
	}
    }
  else /* non-word store */
    {
      /*
       *    addr    - byte offset (might be an alias for R_TMP1)
       *    operand - value to store
       *    R_TMP1  - free
       *    R_TMP2  - free
       *    R_TMP3  - free
       *
       * loose bottom two bits of byte offset (ie convert to word offset)
       * NB/ This is done 6 instructions before the load to avoid pipeline conflicts
       */
      
      out_triadic_op( OP_LSH3, address, addr, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( addr ),
		     alters2( address, RR_ST ) );
      
      /*
       *    addr    - byte offset (might be an alias for R_TMP1)
       *    address - word offset
       *    operand - value to store
       *    R_TMP1  - free
       *    R_TMP2  - free
       *    R_TMP3  - free
       *
       * save non-word selector of address into R_TMP1
       */
d8003 3
a8005 5
      if (addr == R_TMP1)
	{
	  out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, R_TMP1, half_word_op ? 0x2 : 0x3, 
			 examines1( R_TMP1 ),
			 alters2( R_TMP1, RR_ST ) );
d8009 194
a8202 4
	  out_triadic_op( OP_AND3, R_TMP1, addr,
			 half_word_op ? 0x2 : 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( addr ),
			 alters2( R_TMP1, RR_ST ) );
d8204 1
a8204 38
      
      /*
       *    address - word offset
       *    operand - value to store
       *    R_TMP1  - half-word selector (0 or 2) or byte selector (0, 1, 2, or 3)
       *    R_TMP2  - free
       *    R_TMP3  - free
       *
       * convert selector to bit-position selector in R_TMP2
       */
      
      out_triadic_op( OP_MPYI3, R_TMP2, R_TMP1, 8, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( R_TMP1 ),
		     alters2( R_TMP2, RR_ST ) );
      
      /*
       *    address - byte offset
       *    operand - value to store
       *    R_TMP1  - free (0, 1, 2, 3)
       *    R_TMP2  - bit-position selector (0 or 16) or (0, 8, 16 or 24)
       *    R_TMP1  - free
       *
       * shift source value to correct alignment and place in R_TMP3
       */
      
      out_triadic_op( OP_LSH3, R_TMP3, operand, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( operand, R_TMP2 ),
		     alters2( R_TMP3, RR_ST ) );
      
      /*
       *    address - word offset
       *    operand - free (not corruptible)
       *    R_TMP1  - free (0, 1, 2, 3)
       *    R_TMP2  - bit-position selector (0 or 16) or (0, 8, 16 or 24)
       *    R_TMP3  - shifted source value
       *
       * load mask into R_TMP1
       */
d8206 3
a8208 84
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, half_word_op ? 0xFFFF : 0xFF,
		    examines1( R_TMP1 ),
		    alters2( R_TMP1, RR_ST ) );
      
      /*
       *    address - word offset
       *    operand - free (not corruptible)
       *    R_TMP1  - 0x0000FFFF or 0x000000FF
       *    R_TMP2  - bit-position selector (0 or 16) or (0, 8, 16 or 24)
       *    R_TMP3  - shifted source value
       *
       * shift mask up if necessary
       */
      
      out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, R_TMP1, R_TMP2,
		    examines2( R_TMP2, R_TMP1 ),
		    alters2( R_TMP1, RR_ST ) );
      
      /*
       *    address - word offset
       *    operand - free (not corruptible)
       *    R_TMP1  - half-word mask (0x0000FFFF or 0xFFFF0000) or
       *              byte mask (0x000000FF, 0x0000FF00, 0x00FF0000 or 0xFF000000)       
       *    R_TMP2  - free
       *    R_TMP3  - shifted source value
       *
       * get word at destination into R_TMP2 with unwanted byte/half-word masked out
       */
      
      out_triadic_op( OP_ANDN3,
		     R_TMP2,
		     absolute ?
		      build_indirect( INDIRECT_REL, address, 0 ) :
		      build_indirect( INDIRECT_PRE_ADD_IR0, address, 0 ),
		     R_TMP1,
		     ADDR_MODE_INDIRECT,
		     ADDR_MODE_REGISTER,
		     absolute ?
		      examines3( R_TMP2, R_TMP1, address ) :
		      examines4( R_TMP2, R_TMP1, address, R_BASE ),
		     alters2( R_TMP2, RR_ST ) );
      
      /*
       *    address - word offset
       *    operand - free (not corruptible)
       *    R_TMP1  - half-word mask (0x0000FFFF or 0xFFFF0000) or
       *              byte mask (0x000000FF, 0x0000FF00, 0x00FF0000 or 0xFF000000)       
       *    R_TMP2  - other part of word at destination
       *    R_TMP3  - shifted source value
       *
       * mask out all but the half-word/byte to be stored
       */
      
      out_diadic_op( OP_AND, ADDR_MODE_REGISTER, R_TMP3, R_TMP1,
		    examines2( R_TMP1, R_TMP3 ),
		    alters2( R_TMP3, RR_ST ) );
      
      /*
       *    address - word offset
       *    operand - free (not corruptible)
       *    R_TMP1  - free
       *    R_TMP2  - other part of word at destination
       *    R_TMP3  - shifted source value
       *
       * OR in byte/half-word
       */
      
      out_diadic_op( OP_OR, ADDR_MODE_REGISTER, R_TMP2, R_TMP3,
		    examines2( R_TMP2, R_TMP3 ),
		    alters2( R_TMP2, RR_ST ) );
      
      /*
       *    address - word offset
       *    operand - free (not corruptible)
       *    R_TMP1  - free
       *    R_TMP2  - source part word plus destination part word
       *    R_TMP3  - free
       *
       * and store word back in destination
       */
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, address, 0 ),
		    examines3( R_TMP2, address, R_BASE ),
		    alters0() );
@


1.166
log
@made death global
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.165 1992/05/01 09:25:45 nickc Exp nickc $ */
d3091 19
@


1.165
log
@fixed bug in copy_memory & inadventant register memories
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.164 1992/05/01 08:49:07 nickc Exp nickc $ */
d124 1
a124 1
static int32		death              = 0;		/* mask of dead registers at end of current J_opcode */
@


1.164
log
@fixed bug loading shorts off stack
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.163 1992/04/28 17:56:17 nickc Exp nickc $ */
d2926 2
d3020 2
d7185 1
a7185 1
	      integer_immediate_op( OP_ADDI, OP_ADDI3, src, src, off, TRUE );
d7300 2
d8192 2
d9082 2
d9188 2
d9241 1
d9254 2
d9268 2
d9806 2
d9828 2
@


1.163
log
@improved find_data_start
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.162 1992/04/28 17:05:16 nickc Exp nickc $ */
d295 1
a295 1

d1091 1
a1091 1
#ifdef CHECK_FLOAT_OPS
d1110 1
a1110 1
#ifdef CHECK_FLOAT_OPS
d1129 1
a1129 1
#ifdef CHECK_FLOAT_OPS
d1154 1
a1154 1
#ifdef CHECK_FLOAT_OPS
d1547 1
a1547 1
#ifdef CHECK_FLOAT_OPS
d1695 1
a1695 1
#ifdef CHECK_FLOAT_OPS
d2160 1
a2160 1
#ifdef CHECK_FLOAT_OPS
d2291 1
a2291 1
#ifdef CHECK_FLOAT_OPS
d2533 1
a2533 1
#ifdef CHECK_FLOAT_OPS
d2637 1
a2637 1
#ifdef CHECK_FLOAT_OPS
d5085 1
a5085 1
  /* The initial part of this code is independent of operating   */
d7021 4
d7500 1
a7500 1
		      op = OP_LHU;
d7504 1
a7504 1
		      op = OP_LH;
d7967 1
a7967 1
#ifdef CHECK_FLOAT_OPS
d8994 1
a8994 1
#ifdef CHECK_FLOAT_OPS
d9045 1
a9045 1
#ifdef CHECK_FLOAT_OPS
d9065 1
a9065 1
#ifdef CHECK_FLOAT_OPS
d9100 1
a9100 1
#ifdef CHECK_FLOAT_OPS
d9218 1
a9218 1
#ifdef CHECK_FLOAT_OPS
d9642 1
a9642 1
#ifdef CHECK_FLOAT_OPS
d9675 1
a9675 1
#ifdef CHECK_FLOAT_OPS
d9707 1
a9707 1
#ifdef CHECK_FLOAT_OPS
d10100 9
a10108 4
	   * NB/ push in SAME order to pop because add_pending_push stacks up
	   * the pushes and then undoes them in reverse order!
	   * (Unless, of course we have disabled peepholing - in which case
	   * we must push in reverse order!)
d10113 1
a10113 1
	  if (no_peepholing)
d10115 3
a10117 14
	      for (i = 32; i--;)
		{
		  if (m & regbit( i ))
		    add_pending_push( i, PUSH_INT );
		}
	    }
	  else
	    {
	      for (i = 0; i < 32; i++)
		{
		  if (m & regbit( i ))
		    add_pending_push( i, PUSH_INT );
		}
	    }
d10123 1
a10123 1
#ifdef CHECK_FLOAT_OPS
d10133 1
a10133 1
#ifdef CHECK_FLOAT_OPS
@


1.162
log
@fixed bugs in copy_memory() and convert_to_word_address()
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.161 1992/04/27 12:31:15 nickc Exp nickc $ */
d3214 1
a3214 1
find_data_start( Symstr * name )
d3220 1
a3220 1
/* fprintf( stderr, "find_data_start: called for symbol %s\n", symname_( name ) ); */
d3226 1
a3226 1
/* fprintf( stderr, "find_data_start: checking symbol %s\n", symname_( r->extsym ) ); */
d3228 1
a3228 1
      if ((r->extflags & xr_data)  && (r->extoffset == dext->extoffset))
d3232 1
a3232 1
/* fprintf( stderr, "find_data_start: failed\n" ); */
a3233 2
/*  syserr( syserr_data_sym, dext->extoffset ); */

d3521 1
a3521 1
      if (x->extflags & xr_defloc)
d3530 2
a3531 1
	      Symstr *	newsymbol = find_data_start( symbol );
a3532 1
	      
d3534 6
@


1.161
log
@fixed bug in export_data_symbol
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.160 1992/04/24 15:41:33 nickc Exp nickc $ */
d168 1
a168 1
void IOdebug( char * format, ... )
d291 1
a291 1
    
d3192 1
a3192 1
	integer_immediate_op( OP_SUBI, OP_SUBI3, dst, dst, off, TRUE );
d6086 1
a6086 1
	  setlabel( stack_ok );	  
d7159 1
a7159 1
#endif  
d7173 1
a7173 1
	      integer_immediate_op( OP_SUBI, OP_SUBI3, src, src, off, TRUE );
d7235 1
a7235 1
      peep_note_addr_reg_loaded( source, src, length / sizeof_int, TRUE );
d10255 2
d10265 2
@


1.160
log
@fixed bug in J_ADDK and J)SUBK
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.159 1992/04/24 10:35:09 nickc Exp nickc $ */
d4810 9
a4818 7
      /*
       * This is generated by code such as :
       *
       *     int	fred;
       *     int *	jim = &fred + 5;
       *
       */
d4820 1
a4820 1
      /* get pointer to data slots */
d4822 19
a4840 1
      load_static_data_ptr( R_ADDR1, FALSE, name );
d4842 5
@


1.159
log
@better use of address registers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.158 1992/04/23 17:11:53 nickc Exp nickc $ */
d3192 1
a3192 1
	integer_immediate_op( OP_ADDI, OP_ADDI3, dst, dst, off, TRUE );
d7084 1
a7099 5
      /* convert offsets to word pointers */

      convert_to_word_address( src, source );
      convert_to_word_address( dst, dest );
  
d7136 18
a7153 1
      /* load first word */
d7155 4
a7158 3
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, source, 1 ),
		    examines1( source ),
		    alters3( tmp, RR_ST, source ) );
d7175 1
a7175 1
       *    LDI  *<source>++(1), tmp
d7183 1
a7183 1
	       build_parallel_indirect( INDIRECT_POST_INCR, source ),
d9369 1
a9369 1
      if (m == 0)
a9370 4
	  move_register( r2r, r1r, FALSE );
	}
      else if (is_word_addressed_( r2r ))
	{
d9419 4
d9467 1
a9467 5
      if (m == 0)
	{
	  move_register( r2r, r1r, FALSE );
	}
      else if (is_word_addressed_( r2r ))
d9516 4
@


1.158
log
@move peepholing into seperate file
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.157 1992/04/23 16:13:50 nickc Exp nickc $ */
d1051 1
a1051 1
  peep_forget( dest );
d1821 1
a1821 1
  ar = peep_reg_is_loaded( src, &off, &biased );
d1839 1
a1839 1
	      peep_addr_reg_loaded( dest, src, off, biased );
d1861 1
a1861 1
		  peep_corrupt( ar );
d1863 1
a1863 1
		  peep_addr_reg_loaded( dest, src, offset, TRUE );
d1883 1
a1883 1
	      peep_addr_reg_loaded( dest, src, offset, FALSE );
d1927 1
a1927 1
  peep_addr_reg_loaded( dest, src, offset, FALSE );
d1977 1
a1977 1
	      ar = peep_reg_is_loaded( src, &off, &biased );
d2003 1
a2003 1
		      ar = peep_get_address_reg( GAP );
d2017 1
a2017 1
	      peep_addr_reg_loaded( ar, src, offset, FALSE );
d2077 1
a2077 1
      peep_corrupt( src );
d2093 1
a2093 1
	  ar = peep_reg_is_loaded( src, NULL, NULL );
d2096 1
a2096 1
	    ar = peep_get_address_reg( src );
d2100 1
a2100 1
	      peep_corrupt( R_ATMP );
d2130 1
a2130 1
      peep_addr_reg_loaded( ar, src, offset / sizeof_int, TRUE );
d2137 1
a2137 1
      peep_forget( dst );
d2177 1
a2177 1
	      ar = peep_reg_is_loaded( src, NULL, NULL );
d2193 1
a2193 1
		  ar = peep_get_address_reg( GAP );
d2206 1
a2206 1
		  peep_addr_reg_loaded( ar, src, offset + 1, FALSE );
d2249 11
a2259 1
	  ar = R_ATMP;
d2267 1
a2267 1
      peep_addr_reg_loaded( ar, src, offset + 1, TRUE );
d2308 1
a2308 1
	      ar = peep_reg_is_loaded( addr, NULL, NULL );
d2324 1
a2324 1
		  ar = peep_get_address_reg( GAP );
d2337 1
a2337 1
		  peep_addr_reg_loaded( ar, addr, offset + 1, FALSE );
d2380 11
a2390 1
	  ar = R_ATMP;
d2398 1
a2398 1
      peep_addr_reg_loaded( ar, addr, offset + 1, TRUE );
d2419 2
a2420 1
  bool	is_store = (op == OP_STI || op == OP_STF);
d2425 4
d2450 19
a2468 2
       
      /* copy offset to temporary register adjusting for word offsets */
d2470 2
a2471 1
      (void) convert_to_word_alignment( offset, R_ATMP, 0, NULL );
d2475 3
a2477 3
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, src,
		    examines2( src, R_ATMP ),
		    alters2( R_ATMP, RR_ST ) );
d2479 1
a2479 1
      /* do not remember contents of R_ATMP as we have just corrupted it */
d2481 1
a2481 1
      peep_corrupt( R_ATMP );
d2485 3
a2487 3
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, R_ATMP, 0 ),
		    is_store ? examines2( dst, R_ATMP ) : examines1( R_ATMP ),
		    is_store ? alters0()                : alters2( dst, RR_ST ) );
d2491 2
d2495 1
a2495 1
      out_triadic_op( OP_ADDI3, R_ATMP, offset, src, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d2497 1
a2497 1
		     alters2( R_ATMP, RR_ST ) );
d2499 1
a2499 1
      /* forget about contents of R_ATMP */
d2501 1
a2501 1
      peep_corrupt( R_ATMP );
d2505 1
a2505 1
      (void) convert_to_word_alignment( R_ATMP, R_ATMP, 0, NULL );
d2509 3
a2511 3
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ),
		    is_store ? examines3( dst, R_ATMP, RR_IR0 ) : examines2( RR_IR0, R_ATMP ),
		    is_store ? alters0()                        : alters2( dst, RR_ST ) );
d2516 1
a2516 1
      peep_forget( dst );      
d2530 3
d2542 4
d2552 14
d2567 1
a2567 1
      /* copy offset to temporary register adjusting for word offsets */
d2569 2
a2570 1
      (void) convert_to_word_alignment( R_ATMP, offset, 0, NULL );
d2574 3
a2576 3
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, src,
		    examines2( src, R_ATMP ),
		    alters2( R_ATMP, RR_ST ) );
d2578 1
a2578 1
      /* forget about contents of R_ATMP */
d2580 1
a2580 1
      peep_corrupt( R_ATMP );
d2584 2
a2585 2
      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, R_ATMP, 0 ),
		    examines1( R_ATMP ),
d2588 2
a2589 2
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD, R_ATMP, 1 ),
		    examines1( R_ATMP ),
d2594 2
d2598 1
a2598 1
      out_triadic_op( OP_ADDI3, R_ATMP, src, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d2600 1
a2600 1
		     alters2( R_ATMP, RR_ST ) );
d2602 1
a2602 1
      /* forget about contents of R_ATMP */
d2604 1
a2604 1
      peep_corrupt( R_ATMP );
d2608 1
a2608 1
      (void) convert_to_word_alignment( R_ATMP, R_ATMP, 0, NULL );
d2612 3
a2614 3
      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_INCR_IR0, R_ATMP, 0 ),
		    examines2( RR_IR0, R_ATMP ),
		    alters3( dst, R_ATMP, RR_ST ) );
d2616 2
a2617 2
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD, R_ATMP, 1 ),
		    examines1( R_ATMP ),
d2621 1
a2621 1
  peep_forget( dst );
d2634 3
d2646 4
d2656 14
d2671 1
a2671 1
      /* copy offset to temporary register adjusting for word offsets */
d2673 2
a2674 1
      (void) convert_to_word_alignment( R_ATMP, offset, 0, NULL );
d2678 3
a2680 3
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, addr,
		    examines2( addr, R_ATMP ),
		    alters2( R_ATMP, RR_ST ) );
d2682 1
a2682 1
      /* forget about contents of R_ATMP */
d2684 1
a2684 1
      peep_corrupt( R_ATMP );
d2688 2
a2689 2
      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_REL, R_ATMP, 0 ),
		    examines2( val, R_ATMP ),
d2692 2
a2693 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_ADD, R_ATMP, 1 ),
		    examines2( val, R_ATMP ),
d2698 2
d2702 3
a2704 3
      out_triadic_op( OP_ADDI3, R_ATMP, val, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( val, R_ATMP ),
		     alters2( R_ATMP, RR_ST ) );
d2706 1
a2706 1
      /* forget about contents of R_ATMP */
d2708 1
a2708 1
      peep_corrupt( R_ATMP );
d2712 1
a2712 1
      (void) convert_to_word_alignment( R_ATMP, R_ATMP, 0, NULL );
d2716 3
a2718 3
      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_INCR_IR0, R_ATMP, 0 ),
		    examines3( val, RR_IR0, R_ATMP ),
		    alters1( R_ATMP ) );
d2720 2
a2721 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val, build_indirect( INDIRECT_PRE_ADD, R_ATMP, 1 ),
		    examines2( val, R_ATMP ),
d2730 2
d2746 1
d3062 1
a3062 1
  /* forget about the contents of R_ATMP after a branch */
d3064 1
a3064 1
  peep_corrupt_all();
d3200 1
a3200 1
      peep_addr_reg_loaded( dst, src, 0, TRUE );
d3338 1
a3338 5
      tmp = R_ATMP;

      /* forget about contents of R_ATMP */
      
      peep_corrupt( R_ATMP );
d3843 2
a3844 2
       *   LDI   R_MT, R_ATMP	 		- get module table pointer into temporary address register
       *   ADDI  modnum, R_ATMP			- add in the module number
d3846 1
a3846 1
       *   ADDI  offset, R_ATMP			- add in the word offset of the function into the table
d3853 3
a3855 3
       *   LDI   *+R_ATMP(IR0), R_ATMP		- get the function table pointer into temp reg
       *   ADDI  offset, R_ATMP			- add in the word offset of the function into the table
       *   LDI   *R_ATMP, R_ATMP		- get the function pointer
d3948 1
a3948 1
       *   ADDI byte_offset, dest
d3952 1
a3952 1
       *   LDI  R_MT, dest
d3954 1
a3954 1
       *   LDI  *dest, dest
d3956 1
a3956 1
       *   OR   byte_offset, R_TMP1
d3962 4
a3965 4
       *   LDI  *+dest(IR0), dest
       *   LDHI byte_offset >> 16, R_TMP1
       *   OR   byte_offset, R_TMP1
       *   ADDI R_TMP1, dest
d4057 1
a4057 3
	      tmp = R_ATMP;

	      peep_corrupt( R_ATMP );
a4106 1
	      
d4193 1
a4193 1
  peep_forget( dest );
d4266 1
a4266 1
  peep_forget( dest );
d5060 1
a5060 1
  /* forget about contents of R_ATMP after a function call */
d5062 1
a5062 1
  peep_corrupt_all();
d6793 1
a6793 1
      dst = R_ATMP;
a6827 5

      if (dst == R_ATMP)
	{
	  peep_addr_reg_loaded( R_ATMP, start, 0, FALSE );
	}
d6858 1
a6858 4
      if (dst == R_ATMP)
	{
	  peep_addr_reg_loaded( R_ATMP, start, 0, FALSE );
	}
d6878 1
a6878 2
      zero = get_free_register( RR_R0,  RR_R1,  RR_R2,  RR_R3,  RR_R6,  RR_R7,
			        RR_R10, RR_AR0, RR_AR1, RR_AR2, RR_AR3, GAP );
d6925 1
a6925 4
      if (dst == R_ATMP)
	{
	  peep_addr_reg_loaded( R_ATMP, start, length, FALSE );
	}
a6947 1
  RealRegister	reg_in_R_ATMP = GAP;
d6956 1
a6956 2
  
    
d6963 1
a6963 3
      source = R_ATMP;

      reg_in_R_ATMP = source;
d6972 1
a6972 3
      if (source != R_ATMP)
	{
	  dest = R_ATMP;
d6974 1
a6974 3
	  reg_in_R_ATMP = dest;	  
	}
      else
d6976 1
a6976 3
	  /* find a free address register */
	  
	  dest = get_free_register( RR_AR0, RR_AR1, RR_AR2, RR_AR3, GAP );
d6978 1
a6978 3
	  if (dest == GAP)
	    {
	      restore_ar = TRUE;
d6980 1
a6980 1
	      dest = RR_AR3;
d6982 7
a6988 8
	      if (length > 2 * sizeof_int)
		{
		  ipush( dest );
		}
	      else
		{
		  move_register( dest, R_TMP2, FALSE );
		}
a7008 3

      if (reg_in_R_ATMP != GAP)
	peep_addr_reg_loaded( R_ATMP, reg_in_R_ATMP, 0, FALSE );
d7076 2
a7077 2
      if (reg_in_R_ATMP != GAP)
	peep_addr_reg_loaded( R_ATMP, reg_in_R_ATMP, 0, FALSE );
d7196 2
a7197 2
      if (reg_in_R_ATMP != GAP)
	peep_addr_reg_loaded( R_ATMP, reg_in_R_ATMP, length / sizeof_int, FALSE );
d7388 1
a7388 1
		  ar = peep_reg_is_loaded( address, &off, &biased );
d7414 1
a7414 1
			  ar = peep_get_address_reg( GAP );
d7424 1
a7424 1
		  peep_addr_reg_loaded( ar, address, offset, FALSE );
d7541 1
a7541 1
  peep_corrupt( R_ATMP );
d7543 3
d7567 1
a7567 1
      out_triadic_op( OP_LSH3, R_ATMP, addr, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d7569 1
a7569 1
		     alters2( R_ATMP, RR_ST ) );
d7573 1
a7573 1
       *    R_ATMP  - word offset
d7584 1
a7584 2
	  out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, R_TMP1, 
			 half_word_op ? 0x2 : 0x3, 
a7595 2
      addr = R_ATMP;
      
d7597 1
a7597 1
       *    addr    - word offset
d7607 1
a7607 1
	   *    addr    - word offset
d7622 1
a7622 1
	   *    addr    - word offset
d7637 1
a7637 1
	   *    addr    - free
d7649 2
a7650 2
			  build_indirect( INDIRECT_REL, addr, 0 ) :
			  build_indirect( INDIRECT_PRE_ADD_IR0, addr, 0 ),
d7655 2
a7656 2
			  examines2( R_TMP1, addr ) :
			  examines3( R_TMP1, addr, R_BASE ),
d7660 1
a7660 1
	   *    addr    - free
d7669 1
a7669 2
	  out_triadic_op( OP_ASH3, operand, R_TMP2,
			 half_word_op ? -16 : -24,
d7677 1
a7677 1
	   *    addr    - word offset
d7692 1
a7692 1
	   *    addr    - word offset
d7704 2
a7705 2
			  build_indirect( INDIRECT_REL, addr, 0 ) :
			  build_indirect( INDIRECT_PRE_ADD_IR0, addr, 0 ),
d7710 2
a7711 2
			  examines2( addr, R_TMP1 ) :
			  examines3( addr, R_TMP1, R_BASE ),
d7714 1
a7714 1
	   *    addr    - free
d7747 1
a7747 1
      out_triadic_op( OP_LSH3, R_ATMP, addr, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d7749 1
a7749 1
		     alters2( R_ATMP, RR_ST ) );
d7753 1
a7753 1
       *    R_ATMP  - word offset
d7764 1
a7764 2
	  out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, R_TMP1, 
			 half_word_op ? 0x2 : 0x3, 
a7775 2
      addr = R_ATMP;
  
d7777 1
a7777 1
       *    addr    - word offset
d7791 1
a7791 1
       *    addr    - byte offset
d7805 1
a7805 1
       *    addr    - word offset
d7814 1
a7814 2
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1,
		    half_word_op ? 0xFFFF : 0xFF,
d7819 1
a7819 1
       *    addr    - word offset
d7833 1
a7833 1
       *    addr    - word offset
d7846 2
a7847 2
		      build_indirect( INDIRECT_REL, addr, 0 ) :
		      build_indirect( INDIRECT_PRE_ADD_IR0, addr, 0 ),
d7852 2
a7853 2
		      examines3( R_TMP2, R_TMP1, addr ) :
		      examines4( R_TMP2, R_TMP1, addr, R_BASE ),
d7857 1
a7857 1
       *    addr    - word offset
d7872 1
a7872 1
       *    addr    - word offset
d7886 1
a7886 1
       *    addr    - word offset
d7895 2
a7896 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, addr, 0 ),
		    examines3( R_TMP2, addr, RR_IR0 ),
d7902 1
a7902 1
      peep_forget( operand );
d8501 1
a8501 1
      /* forget about contents of R_ATMP */
d8503 1
a8503 1
      peep_corrupt_all();
d8522 1
d8560 1
d8609 1
a8609 1
	  peep_corrupt_all();
d8650 1
d8709 1
a8709 1
	  peep_corrupt( R_ATMP );
d8711 1
a8711 1
	  out_triadic_op( OP_ADDI3, R_ATMP, r1r,
d8715 1
a8715 1
			 alters2( R_ATMP, RR_ST ) );  /* relative to the LAJ instruction above */
d8719 3
a8721 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_LR,
			examines2( R_ATMP, R_TMP1 ),
			alters2( R_ATMP, RR_ST ) );
d8725 1
a8725 1
	  out_triadic_op( OP_ADDI3, R_ATMP, R_LR, build_indirect( INDIRECT_REL, R_ATMP, 1 ),
d8727 2
a8728 2
			 examines2( R_LR, R_ATMP ),
			 alters2( R_ATMP, RR_ST ) );
d8736 3
a8738 3
	      out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_ATMP, offset,
			    examines1( R_ATMP ),
			    alters2( R_ATMP, RR_ST ) );
d8757 2
a8758 2
	  outinstr( OP_BRcr << 24 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_ATMP ),
		   examines1( R_ATMP ),
d9369 1
a9369 1
	  ar = peep_reg_is_loaded( r2r, &off, &biased );
d9469 1
a9469 1
	  ar = peep_reg_is_loaded( r2r, &off, &biased );
@


1.157
log
@fixed bug with new peepholer
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.156 1992/04/23 08:48:00 nickc Exp nickc $ */
a62 9
#define fits_in_5_bits_signed( val )	(((val) & 0xfffffff0U) == 0 || ((val) & 0xfffffff0U) == 0xfffffff0U)
#define fits_in_8_bits_signed( val )	(((val) & 0xffffff80U) == 0 || ((val) & 0xffffff80U) == 0xffffff80U)
#define fits_in_8_bits_unsigned( val )	(((val) & 0xffffff00U) == 0 )
#define fits_in_16_bits_signed( val )	(((val) & 0xffff8000U) == 0 || ((val) & 0xffff8000U) == 0xffff8000U)
#define fits_in_16_bits_unsigned( val )	(((val) & 0xffff0000U) == 0 )
#define fits_in_24_bits_signed( val )	(((val) & 0xff800000U) == 0 || ((val) & 0xff800000U) == 0xff800000U)

#define is_float( reg ) 	is_C40_float_register( reg )

a121 3
#define	indirect_addr_reg( op )		(((op) >> 8) & 0x07)
#define real_addr_reg( reg )		((reg) + hardware_register( RR_AR0 ))

a123 53
typedef enum
  {
    OUT_NULL,		/* a padding op-code that can potentially be eliminated 		*/
    OUT_INSTR,		/* normal op-code 							*/
    OUT_DELAYED,	/* a delayed instruction 						*/
    OUT_SYMREF,		/* op-code that references a symbol 					*/
    OUT_DELSYMREF,	/* (delayed) op-code that references a symbol 				*/
    OUT_XREF,		/* op-code that cross references a symbol 				*/
    OUT_SYMXREF,	/* op-code that references and cross references a symbol 		*/
    OUT_DELSYMXREF,	/* (delayed) op-code that references and cross references a symbol 	*/
    OUT_LABREF,		/* op-code that references a label 					*/
    OUT_DELLABREF	/* (delayed) op-code that references a label				*/
  }
peep_type;

typedef struct peep_data
  {
    peep_type		type;		/* e.g. OUT_INSTR 			 */
    int32 		op_code;	/* 32 bits of machine instruction	 */
    int32 		reads;		/* registers accessed 			 */
    int32 		writes;		/* registers clobbered			 */
    Symstr *		symbol;		/* external symbol       (if needed) 	 */
    int32 		reftype;	/* symbol reference type (if needed) 	 */
    LabelNumber *	label;		/* label                 (if needed) 	 */
  }
peep_data;

typedef enum
  {
    PUSH_INT,
    PUSH_FLOAT,
    PUSH_DOUBLE
  }
push_type;

static void		append_peep( peep_type, int32 op_code, int32 reads, int32 writes,
				    Symstr *, LabelNumber *, int32 reftype );
static void		flush_peepholer( const char * reason );
static void		emit_from_peep( void );
static void		peep_xref( int32 reftype, Symstr * symbol );
static void		peep_fref( LabelNumber * label, int32 reftype );
static bool		peep_sets_status_reg( RealRegister r );
static bool		peep_reg_transfer_to( RealRegister r );
static bool		peep_refs_label( LabelNumber * l );
static void		peep_symref( Symstr * symbol );
static RealRegister	peep_eliminate_reg_transfer( RealRegister r );
static int		peep_shift_back( int n );
static void		add_pending_push( RealRegister reg, push_type type );
static int		pop_pending_push( RealRegister reg, bool can_pop_double );
static void		maybe_flush_pending_push( RealRegister reg );
static void		flush_pending_pushes( void );


a124 5
static int32		peep_protect_pc	   = 0;		/* number of instructions to protect  */
static int32		peep_eliminated    = 0;		/* number of instructions eliminated  */
static int32		peep_transformed   = 0;		/* number of instructions transformed */
static int32		peep_swapped       = 0;		/* number of instructions swapped     */

a125 10
#define examines0()			0
#define examines1( r1 )			 regbit( r1 )
#define examines2( r1, r2 )		(regbit( r1 ) | regbit( r2 ))
#define examines3( r1, r2, r3 )		(regbit( r1 ) | regbit( r2 ) | regbit( r3 ))
#define examines4( r1, r2, r3, r4 )	(regbit( r1 ) | regbit( r2 ) | regbit( r3 ) | regbit( r4 ))
#define alters0()			examines0()
#define alters1( r1 )			examines1( r1 )
#define alters2( r1, r2 )		examines2( r1, r2 )
#define alters3( r1, r2, r3 )		examines3( r1, r2, r3 )

d129 1
a129 1
static void 		correct_stack( bool flush_pushes );
a130 2
static int32 		stack_move         = 0;		/* number of bytes potentially subtracted from stack */
static int32 		stack_offset       = 0;		/* number of bytes from stack pointer to first local arg */
d142 3
a174 45
 * print a message about peepholing
 */

static void
#ifdef __STDC__
peepf( const char * format, ... )
#else
peepf( format, va_alist )
  const char *	format;		/* printf (3) style format string  */
  va_dcl			/* argumnets for the format string */
#endif
{
  va_list	args;
	

  if (asmstream == NULL ||
      (feature & FEATURE_ANNOTATE) == 0)
    return;
  
#ifdef __STDC__
  va_start( args, format );
#else
  va_start( args );
#endif

  fflush( asmstream );
	
  fseek( asmstream, 0L, SEEK_END );

  fprintf( asmstream, "; peepholer: " );
  
  vfprintf( asmstream, (char *)format, args );

  putc( '\n', asmstream );
  
  fflush( asmstream );
	
  va_end( args );

  return;
  
} /* peepf */


/*
d393 1
a393 1
static RealRegister
d444 1
a444 1
static int32
d1020 1
a1020 1
static void
d1060 1
a1060 1
static void
d1074 1
a1074 1
static void
d1088 1
a1088 1
static void
d1126 1
a1126 1
static void
d2656 1
a2656 1
static void
d10155 3
a10157 3
  mcdep_init( void )
  {
    return;
d10159 1
a10159 1
  } /* mcdep_init */
d10163 1
a10163 472
  localcg_tidy( void )
  {
    return;
    
  } /* localcg_tidy */

void
  localcg_reinit( void )
  {
    return;
    
  } /* localcd_reinit */



/* vvvvvvvvvvvvvvvvvvvvvvvvvvv PEEPHOLER vvvvvvvvvvvvvvvvvvvvvvvvvvvv */


#define PEEP_BUF_SIZE	(1 << 3)	/* NB/ must be power of 2 */

static peep_data			peep_buf[ PEEP_BUF_SIZE ];	/* circular buffer of op codes    */
static signed int			peep_start 	= 0;		/* next instruction to be emitted */
static signed int			peep_end   	= 0;		/* next free slot in table        */
static bool				xref_pending    = FALSE;	/* TRUE if cross reference is pending */
static int32				pending_reftype = 0;		/* the cross reference type       */
static Symstr *				pending_symbol  = NULL;		/* the cross reference's symbol   */
static bool				fref_pending    = FALSE;	/* TRUE if forward ref is pending */
static LabelNumber *			pending_label   = NULL;		/* the forward reference's label  */
static int				peep_pending_swaps = 0;		/* number of forward intrs to swap */	

#define num_in_peep_()			(peep_end - peep_start + (peep_end < peep_start ? PEEP_BUF_SIZE : 0))
#define previous_( var )		(((var) - 1) & (PEEP_BUF_SIZE - 1))
#define successor_( var )		(((var) + 1) & (PEEP_BUF_SIZE - 1))

#define is_op(      instruction, op_code )	 (((instruction) >> 23)        == (op_code))
#define is_mode(    instruction, mode )		((((instruction) >> 21) & 0x3) == (mode))
#define is_diadic(  instruction )		 (((instruction) >> 29)        == 0)
#define is_triadic( instruction )		 (((instruction) >> 29)        == 1)
#define is_normal(  instruction )		 (((instruction) >> 30)        == 0)
#define dest_of(    instruction )		 (((instruction) >> 16) & 0x1f)
#define source_of(  instruction )		  ((instruction) & 0xffff)
#define has_indirect_side_effects( instruction )((((instruction) >> 11) & 0x6) != 0)

#define is_load(    instruction )		(is_op( instruction, OP_LDI ) || \
						 is_op( instruction, OP_LDA ) || \
						 is_op( instruction, OP_LDF ) )

/*
 * returns TRUE if the two instructions
 * can be swapped FALSE otherwise
 */

static bool
can_swap(
	 int32	a,		/* first instruction 				*/
	 int32	b,		/* second instruction 				*/
	 bool	ignore_ST )	/* TRUE if we can safely ignore the ST register */
{
  unsigned32	a_reads;
  unsigned32	b_reads;
  unsigned32	a_writes;
  unsigned32	b_writes;
  int32		a_op;
  int32		b_op;
  

  a_reads  = peep_buf[ a ].reads;
  b_reads  = peep_buf[ b ].reads;
  a_writes = peep_buf[ a ].writes;
  b_writes = peep_buf[ b ].writes;

  if (ignore_ST)
    {
      a_writes &= ~(regbit( RR_ST ));
      b_writes &= ~(regbit( RR_ST ));
    }
  
  if ((a_reads  & b_writes) ||
      (b_reads  & a_writes) ||
      (a_writes & b_writes)  )
    {
      return FALSE;
    }

  a_op = peep_buf[ a ].op_code;
  b_op = peep_buf[ b ].op_code;

  if (is_normal( a_op ) 				    && /* a is diadic or triadic          */
      is_normal( b_op ) 				    && /* b is diadic or triadic          */
      is_mode( a_op, ADDR_MODE_INDIRECT ) 		    && /* a uses indirect addressing      */
      is_mode( b_op, ADDR_MODE_INDIRECT ) 		    && /* b uses indirect addressing      */
      indirect_addr_reg( a_op) == indirect_addr_reg( b_op )  ) /* share the same address register */
    {
      return FALSE;
    }
      
  return TRUE;
  
} /* can_swap */


/*
 * returns TRUE iff type is a delayed op type
 */

static bool
is_delayed( peep_type type )
{
  switch (type)
    {
    default:
      return FALSE;

    case OUT_DELAYED:
    case OUT_DELLABREF:
    case OUT_DELSYMREF:
    case OUT_DELSYMXREF:
      return TRUE;
    }
  
} /* is_delayed */
  
/*
 * this function indicates that the next instruction to be appended
 * to the peepholer's buffer is a cross reference type instruction, rather than
 * an ordinary instruction
 */
  
static void
peep_xref(
	  int32		reftype,
	  Symstr *	symbol )
{
  xref_pending    = TRUE;
  pending_reftype = reftype;
  pending_symbol  = symbol;

  return;
  
} /* peep_xref */

  
/*
 * this function indicates that the next instruction to be
 * appended to the peepholer's buffer references a symbol
 */
  
static void
peep_symref( Symstr * symbol )
{
  xref_pending    = TRUE;
  pending_reftype = LABREF_NONE;
  pending_symbol  = symbol;

  return;
  
} /* peep_symref */


/*
 * this function indicates that the next instruction to be
 * appended to the peepholer's buffer has a forward
 * reference to a label
 */
  
static void
peep_fref(
	  LabelNumber *	label,
	  int32		reftype )
{
  fref_pending    = TRUE;
  pending_label   = label;
  pending_reftype = reftype;

  return;
  
} /* peep_fref */


typedef struct
  {
    RealRegister	reg;
    push_type		type;
  }
pending_push;

#define PUSH_ARRAY_SIZE	10

static pending_push	pending_pushes[ PUSH_ARRAY_SIZE ];	/* array of pending pushes */
static int		pend_push_free = 0;			/* next free slot in pending_pushes array */

/* add an entry in the pending pushes array */

static void
add_pending_push(
		 RealRegister	reg,	/* the register to be pushed 		*/
		 push_type	type )	/* the kind of push being performed	*/
{
  /* check that there is room */

  /* peepf( "adding push of reg %d (type %d)", reg, type ); */
  
  if (pend_push_free == PUSH_ARRAY_SIZE)
    {
      syserr( "back end: add_pending_push: array overflow" );

      return;
    }

  /* adjust the stack offset (BEFORE adding the pending push) */
  
  if (stack_move != 0)
    {
      correct_stack( FALSE );
    }
  
  /* add the push to the pending array */
  
  pending_pushes[ pend_push_free ].reg  = reg;
  pending_pushes[ pend_push_free ].type = type;
  pend_push_free++;

  /* adjust the stack offset - XXX why ? */
  
  switch (type)
    {
    case PUSH_INT:	stack_offset += sizeof_int;    break;
    case PUSH_FLOAT:	stack_offset += sizeof_float;  break;
    case PUSH_DOUBLE:	stack_offset += sizeof_double; break;
    default:
      syserr( "back end: add_pending_push: unknown push type" );
      break;
    }

  /* if we are not peepholing then emit this push immediately */
  
  if (no_peepholing)
    {
      flush_pending_pushes();
    }

  return;
  
} /* add_pending_push */


/*
 * removes a pending push into register 'reg'
 * returns number of registers poped
 */

static int
pop_pending_push(
		 RealRegister	dest,			/* register into which stack value should be placed */
		 bool		can_pop_double )	/* non-zero if two words can be popped */
{
  RealRegister	src;
  push_type	type;
  

  if (pend_push_free == 0)
    {
      /* if there are no pushes pending then just pop */

      ipop( dest );

      stack_offset -= sizeof_int;
      
      return 1;
    }

  src  = pending_pushes[ --pend_push_free ].reg;
  type = pending_pushes[   pend_push_free ].type;

  /* adjust the stack offset */
  
  switch (type)
    {
    case PUSH_INT:	stack_offset -= sizeof_int;    break;
    case PUSH_FLOAT:	stack_offset -= sizeof_float;  break;
    case PUSH_DOUBLE:	stack_offset -= sizeof_double; break;
    default:
      syserr( "back end: pop_pending_push: unknown push type" );
      break;
    }

  /*
   * XXX - NC - 4/2/92
   *
   * Believe it or not, the compiler can ask us to
   * push a double and then pop "half" of it into
   * register!  try the following code ...
   *
   *  func( 1, 2.0, 3,0 );
   *
   * So we must catch the case where we want to pop
   * a double, but only a single word is required
   */
  
  if (type == PUSH_DOUBLE && can_pop_double == 0)
    {
      stack_offset += sizeof_float;

      type = PUSH_FLOAT;
    }
  
  if (dest == src)
    {
      /* push followed by pop into same register */

      peepf( "eliminated push/pop pair" );

      if (type == PUSH_DOUBLE)
	{
	  peep_eliminated += 4;
      
	  return 2;
	}
      else
	{
	  peep_eliminated += 2;
	  
	  return 1;
	}
    }
  else if (src == GAP)
    {
      /* we have already pushed the register - now pop it */

      /*
       * NB/ we never really pop floats and doubles -
       * this is only ever done when we want to put FP
       * values into INT registers
       */
      
      switch (type)
	{
	case PUSH_INT:	  ipop( dest ); return 1;
	case PUSH_FLOAT:  ipop( dest ); return 1;
	case PUSH_DOUBLE: ipop( dest ); ipop( dest + 1 ); return 2;	  
	}
    }
  else
    {
      /* push from one register, pop into another */
      
      switch (type)
	{
	case PUSH_INT:
	  maybe_flush_pending_push( dest );
	  
	  move_register( src, dest, FALSE );
	      
	  peepf( "transformed integer push/pop pair" );

	  ++peep_transformed;
	  ++peep_eliminated;
	  
	  return 1;
	  
	case PUSH_FLOAT:
	  if (is_float( dest ))
	    {
	      maybe_flush_pending_push( dest );
	      
	      move_register( src, dest, TRUE );
	      
	      peepf( "transformed float push/pop pair" );

	      ++peep_transformed;
	      ++peep_eliminated;
	    }
	  else
	    {
	      if (stack_move < 0)
		correct_stack( FALSE );

	      /* push floating point value, but pop an integer */

	      fpush( src );

	      ipop( dest );
	    }	  

	  return 1;
	  
	case PUSH_DOUBLE:
	  if (is_float( dest ))
	    {
	      /* we are about to corrupt dest, so make sure that we are not pushing it */
	      
	      maybe_flush_pending_push( dest );
	      maybe_flush_pending_push( dest + 1 );

	      fpush( src );
	      ipop(  dest );				/* big endian doubles */
	      move_register( src, dest + 1, FALSE );	/* NB/ must transfer integer part as well */
	      
	      peepf( "transformed double push/pop pair" );
	      
	      ++peep_transformed;
	      ++peep_eliminated;
	    }
	  else
	    {
	      if (stack_move < 0)
		correct_stack( FALSE );

	      dpush( src );

	      ipop( dest );		/* big endian doubles */
	      ipop( dest + 1 );
	    }
	  
	  return 2;
	}
    }

  return 0;
  
} /* pop_pending_push */


/* empties the pending pushes array */

static void
flush_pending_pushes( void )
{
  int	i;


  for (i = pend_push_free; i--;)
    {
      RealRegister	reg = pending_pushes[ i ].reg;
      

      /* ignore already removed pushes */
      
      if (reg == GAP)
	continue;

      /* push the registers in order */
      
      switch (pending_pushes[ i ].type)
	{
	case PUSH_INT:		ipush( reg ); break;
	case PUSH_FLOAT:	fpush( reg ); break;
	case PUSH_DOUBLE:	dpush( reg ); break;
	default:
	  syserr( "back end: flush_pending_pushes: unknown push type" );
	  break;
	}

      /* peepf( "forced flush of push of reg %d", reg ); */
    }

  /* reset pending array */
  
  pend_push_free = 0;

  return;
  
} /* flush_pending_pushes */


/*
 * flushes any pending pushes if they
 * push register 'reg'
 */

static void
maybe_flush_pending_push( RealRegister reg )
a10164 46
  signed int	i;


  for (i = pend_push_free; i--;)
    {
      if (pending_pushes[ i ].reg == reg)
	break;
    }

  if (i >= 0)
    {
      int	j;

      
      /* flush back to i */

      for (j = pend_push_free; j-- > i;)
	{
	  RealRegister	reg = pending_pushes[ j ].reg;
      

	  /* ignore already removed pushes */
      
	  if (reg == GAP)
	    continue;

	  /* push the registers in order */

	  switch (pending_pushes[ j ].type)
	    {
	    case PUSH_INT:	ipush( reg ); break;
	    case PUSH_FLOAT:	fpush( reg ); break;
	    case PUSH_DOUBLE:	dpush( reg ); break;
	    default:
	      syserr( "back end: maybe_flush_pending_push: unknown push type" );
	      break;
	    }

	  /* peepf( "flushed push of reg %d because of clash", reg ); */	
  
	  /* mark this push as having been removed */
	  
	  pending_pushes[ j ].reg = GAP;
	}
    }

a10165 210
  
} /* maybe_flush_pending_push */


/*
 * try to eliminate a null operation by adjusting
 * the instructions already in the peephole buffer
 * returns TRUE if the instruction was eliminated,
 * FALSE otherwise
 */

static bool
eliminate_null_op( void )
{
  peep_type	type;
  signed int	delayed;
  int		count;
  int		nulls = 0;
      

  if (no_peepholing)
    return FALSE;
  
  /* see if we have a delayed instruction somewhere in the previous three op-codes */

  delayed = peep_end;

  for (count = 0; count < 3; count++)
    {
      /* get previous instruction */
      
      delayed = previous_( delayed );

      /* have we reached the start of the peephole buffer ? */
      
      if (delayed == previous_( peep_start ))
	{
	  /* end of search */

	  count = 4;

	  break;
	}

      /* extract the type of this instruction */
      
      type = peep_buf[ delayed ].type;

      /* is it a noop ? */
      
      if (type == OUT_NULL)
	{
	  /* found a padding instruction */
	  
	  ++nulls;
	}
      else if (is_delayed( type ))
	{
	  /* found delayed instruction */

	  break;
	}
    }

  /* see if we found anything */
  
  if (count < 3 && delayed != peep_start)
    {
      signed int	prev;
      
      
      /* we have a delayed instruction and one other instruction */
      
      prev = previous_( delayed );
      
      if (can_swap( delayed, prev, FALSE ))
	{
	  peep_data		tmp;
	  

	  tmp                 = peep_buf[ delayed ];
	  peep_buf[ delayed ] = peep_buf[ prev    ];
	  peep_buf[ prev    ] = tmp;
	  peep_buf[ delayed ].reads |= regbit( RR_PC );	  /* ensure that prev does not get swapped again */
	  
 	  peepf( "eliminated a NOP" );

	  ++peep_eliminated;
	  
	  return TRUE;
	}
/*    else peepf( "could not swap %08x and %08x (prev r = %x, w = %x)(delayed r = %x, w = %x)",
		   peep_buf[ prev ].op_code,  peep_buf[ delayed ].op_code,
		   peep_buf[ prev ].reads,    peep_buf[ prev ].writes,
		   peep_buf[ delayed ].reads, peep_buf[ delayed ].writes ); */
    }

  if (count == 2 && nulls == 2)
    {
      int32	op = peep_buf[ delayed ].op_code;
      int32	off;

      
      /*
       * We failed to swap the delayed instruction
       * but we might be able to convert the delayed insrtuction
       * and the three following NOPs into a non-delayed insrtuction.
       * This does not save code execution time, but it will save
       * code space.
       */
      
      if ((op >> 26) == B_011010)
	{
	  /* we have a conditional branch */
	  
	  /* removed delayed bit */
	  
	  op &= ~(1 << 21);
	  
	  if (op & (1 << 25))
	    {
	      /* branch is PC relative - increase offset by 2 */
	      
	      off = mask_and_sign_extend_word( op, 0xFFFF );

	      if (!off)
		syserr( "back end: peepholer: no offset in branch!" );
	      
	      off += 2;
	      
	      op = (op & 0xFFFF0000U) | (off & 0x0000FFFFU);
	    }
	  
	  peepf( "converted a delayed conditional branch into undelayed" );
	}
      else if ((op >> 25) == (B_0110000))
	{
	  /* we have an unconditional branch */
	  
	  /* removed delayed bit */
	  
	  op &= ~(1 << 24);
	      
	  /* branch is PC relative - increase offset by 2 */
	  
	  off = mask_and_sign_extend_word( op, 0x00FFFFFFU );

	  if (!off)
	    syserr( "back end: peepholer: no offset in branch!" );
	  
	  off += 2;

	  op = (op & 0xFF000000U) | (off & 0x00FFFFFFU);

	  peepf( "converted a delayed unconditional branch into undelayed" );
	}
      else
	{
	  return FALSE;
	}
#if 0
      /* change the type to reflect new status */
      
      switch (type)
	{
	case OUT_DELLABREF:
	  type = OUT_LABREF;
	  break;
	  
	case OUT_DELSYMREF:
	  type = OUT_SYMREF;

	  off = mask_and_sign_extend_word( op, 0x00ffffffU );
      
	  if (off != 0)
	    {
	      /* subtract codep from offset */
	  
	      op = (op & 0xff000000U) |
		((off - (codep / sizeof_int)) & 0x00ffffffU);
	    }

	  break;
	  
	case OUT_DELSYMXREF:
	  type = OUT_SYMXREF;
	  break;
	  
	case OUT_DELAYED:
	  type = OUT_INSTR;
	  break;
	  
	default:
	  syserr( "peepholer: unknown delay type" );
	  break;
	}
      peep_buf[ delayed ].type    = type;
#endif      
      peep_buf[ delayed ].op_code = op;
	  
      /* remove following three NOPs */
	  
      peep_end = successor_( delayed );

      peep_eliminated += 3;
      
      return TRUE;
    }
  
  return FALSE;
d10167 1
a10167 1
} /* eliminate_null_op */
d10169 2
a10170 997

/*
 * returns 1 if the op_code has the potential to be converted into
 * a parallel operation, returns 0 otherwise
 */

static int
is_potential_parallel_op(
			 int32 	op,
			 int32	potential_op,
			 int32	other_op )
{
  if (is_op(   op, potential_op )	&&	/* matches sought op			*/
      is_mode( op, ADDR_MODE_INDIRECT )	&&	/* uses indirect addressing		*/
      dest_of( op ) <= 7		&&	/* references registers R0 - R7		*/
      (op & 0xFF)   < 2			)	/* displacement is 0 or 1		*/
    {
      if (has_indirect_side_effects( op ))
	{
	  int32	reg = indirect_addr_reg( op );

	  
	  /* check to see if side effects might affect other instruction */
	  
	  if (dest_of( other_op )           == real_addr_reg( reg ) ||
	      indirect_addr_reg( other_op ) == reg                   )
	    {
	      return 0;
	    }
	}

      return 1;
    }

  return 0;
      
} /* is_potential_parallel_op */
  

#ifdef NOT_USED
/*
 * returns TRUE if the op code is a triadic
 * operation that might be turned into a parallel
 * operation.  Returns FALSE otherwise
 */

static bool 
is_suitable_triadic( int32 op )
{
  if (((op & (B_111   << 29)) == (B_001 << 29))	&&	/* currently triadic                   */
      ((op & (1       << 28)) == 0)		&&	/* uses type 1 addressing              */
      ((op & (B_11    << 21)) == (B_10  << 21))	&&	/* uses register / indirect addressing */
      dest_of( op ) <= 7			&&	/* dst  uses register R0 - R7		*/
      ((op & (B_11111 <<  8)) <= (7     <<  8))	 )	/* src1 uses register R0 - R7          */
    {
      return TRUE;
    }

  return FALSE;
  
} /* is_suitable_triadic */
#endif /* NOT_USED */
  
/*
 * try to combine the current instruction with the
 * previous instuction in the peephole buffer.
 * returns TRUE if successful, FALSE otherwise
 */

#define SWAP_OPS					\
  *pcurr_op                 = prev_op; 			\
  *preads                   = peep_buf[ prev ].reads;	\
  *pwrites                  = peep_buf[ prev ].writes;	\
   peep_buf[ prev ].op_code = prev_op = curr_op;	\
   peep_buf[ prev ].reads   = reads;			\
   peep_buf[ prev ].writes  = writes;			\
   curr_op                  = *pcurr_op;		\
   reads                    = *preads;			\
   writes                   = *pwrites;			\
   swapped                  = TRUE


static bool
combine_instrs(
	      int32 *	pcurr_op,
	      int32 *	preads,
	      int32 *	pwrites )
{
  signed int	prev;
  int32		prev_op;
  int32		curr_op = *pcurr_op;
  int32		reads   = *preads;
  int32		writes  = *pwrites;
  int		prev_store;
  int		prev_load;
  int		curr_store;
  int		curr_load;
  bool		swapped = FALSE;
  

  /* see if we can peephole */
  
  if (no_peepholing)
    return FALSE;
  
  /* see if there are two instructions to compare */
  
  if (peep_end == peep_start)
    return FALSE;

  /* find the previous instruction */
  
  prev = previous_( peep_end );

  /* only peephole ordinary instructions */
  
  if (peep_buf[ prev ].type != OUT_INSTR)
    return FALSE;
  
  /* get the op code of the previous instruction */
  
  prev_op = peep_buf[ prev ].op_code;

  /* check to see if the two instructions are the same */

  if (prev_op == curr_op)
    {
      int32	type = (curr_op >> 29) & 0x7;


      /* see if they have any side effects */
      
      if (type == 0)
	{
	  if (!is_mode( curr_op, ADDR_MODE_INDIRECT ) ||  /* if it does not use indirect addressing       */
	      ((curr_op >> 13) & 1) == 0)		  /* or the indirect addressing does not auto inc */
	    {
	      switch (curr_op >> 23)
		{
		case OP_ADDI:
		  if (is_mode( curr_op, ADDR_MODE_IMMEDIATE ))
		    {
		      int32	val = mask_and_sign_extend_word( curr_op, 0xFFFF ) * 2;


		      if (fits_in_16_bits_signed( val ))
			{
			  peep_buf[ prev ].op_code = ((curr_op & 0xFFFF0000U) | (val & 0xFFFFU));

			  peepf( "combined multiple additions" );

			  ++peep_eliminated;
			  
			  return TRUE;
			}
		    }

		case OP_LDI:
		  peepf( "eliminated multiple identical LDIs" );
		  ++peep_eliminated;
		  return TRUE;
		  
		case OP_LDA:
		  peepf( "eliminated multiple identical LDAs" );
		  ++peep_eliminated;
		  return TRUE;

		case OP_LDF:
		  peepf( "eliminated multiple identical LDFs" );
		  ++peep_eliminated;
		  return TRUE;
		  
		case OP_AND:
		  /*
		   * eg:-   while ((c = *a) != '\0') *a++ = c + 1;
		   */
		  
		  peepf( "eliminated multiple identical ANDs" );
		  ++peep_eliminated;
		  return TRUE;
		  
		default:
		  peepf( "failed to combine multiple indentical op codes (%lx)", curr_op );
		  break;
		}
	    }
	}
    }
  
  /*
   * check for an indirect post incr 
   * followed by an addition to same register
   * or a STIK indirect followed by an addition to the register
   *
   * eg turns:
   *	LDI	*AR6++(1), R0
   *	ADDI	1, AR6
   * into:
   *	LDI	*AR6++(2), R0
   */

  else if (
      (is_op( curr_op, OP_ADDI ))
      &&
      (
       (/*is_op( prev_op, OP_LDI  ) &&*/ is_mode( prev_op, ADDR_MODE_INDIRECT  ))
       ||
       (is_op( prev_op, OP_STIK ) && is_mode( prev_op, ADDR_MODE_IMMEDIATE ))
      )
      &&
      (is_mode( curr_op, ADDR_MODE_IMMEDIATE ))
     )
    {
      int32	dest;
      int32	amount;

      
      dest    = (curr_op >> 16) & 0x1f;
      amount  = mask_and_sign_extend_word( curr_op, 0xffff );
      amount += prev_op & 0xff;
      
      if (
	  real_addr_reg( indirect_addr_reg( prev_op ) ) == dest && /* same register affected */
	  ((prev_op >> 11) & 0x1f) == INDIRECT_POST_INCR        && /* op was *ARx++() */
	  fits_in_8_bits_unsigned( amount )                     )  /* new addition total fits */
	{
	  peep_buf[ prev ].op_code = (prev_op & 0xffffff00U) | (amount & 0xffU);

	  peepf( "transformed indirect addition" );

	  ++peep_transformed;
	  
	  return TRUE;
	}
    }

  /*
   * There are several potential optimisations when the previous instruction
   * is a register based LDI, LDA or LDF and the current instruction is diadic
   */

  if (is_load( prev_op )			&&	/* prev_op is one of LDI, LDA, LDF	*/
      is_mode(   prev_op, ADDR_MODE_REGISTER )	&&	/* it uses register addressing		*/
      is_diadic( curr_op )                  	)	/* current op is a diadic operation	*/
    {
      /* if they both have the same destination */

      if (dest_of( prev_op ) == dest_of( curr_op ))
	{
	  if (is_mode( curr_op, ADDR_MODE_REGISTER ))
	    {
	      unsigned long	op = OP_NOP;
		  
	      
	      /*
	       * check for loading a register
	       * followed by a register based diadic op with
	       * that register as both source and destination
	       *
	       * eg turns:
	       *	LDI	R0, R1
	       *	NEGI	R1, R1
	       * into:
	       *    	NEGI	R0, R1
	       */
	      
	      if (source_of( curr_op ) == dest_of( curr_op ))
		{
		  /* avoid the case of LDF followed by LDI */
      
		  if (!is_op( prev_op, OP_LDF) || !is_op( curr_op, OP_LDI ))
		    {
		      peep_buf[ prev ].op_code = (curr_op & 0xff800000U) | (prev_op & 0x007fffffU);
	  
		      peepf( "merged load and diadic op into diadic op" );

		      ++peep_eliminated;
		      
		      return TRUE;
		    }
		}
		  
	      /*
	       * check for moving one register into another followed
	       * by a register based diadic op on that register
	       *
	       * eg turns:
	       *	LDI	R1, R0
	       *	ADDI	R2, R0
	       * into:
	       *	ADDI3	R1, R2, R0
	       */
	  
	      switch ((curr_op >> 23) & 0x3f)
		{
		case OP_ADDC:	  op = OP_ADDC3;	  break;
		case OP_ADDF:	  op = OP_ADDF3;	  break;
		case OP_ADDI:	  op = OP_ADDI3;	  break;
		case OP_AND:	  op = OP_AND3;		  break;
		case OP_ANDN:	  op = OP_ANDN3;	  break;
		case OP_ASH:	  op = OP_ASH3;		  break;
		case OP_LSH:	  op = OP_LSH3;		  break;
		case OP_MPYF:	  op = OP_MPYF3;	  break;
		case OP_MPYI:	  op = OP_MPYI3;	  break;
		case OP_OR:	  op = OP_OR3;		  break;
		case OP_SUBB:	  op = OP_SUBB3;	  break;
		case OP_SUBF:	  op = OP_SUBF3;	  break;
		case OP_SUBI:	  op = OP_SUBI3;	  break;
		case OP_XOR:	  op = OP_XOR3;		  break;
		default:
		  break;
		}      
	      
	      if (op != OP_NOP)
		{
		  peep_buf[ prev ].op_code = (B_0010 << 28) | op << 23 | 0x0U << 21 |
		    prev_op & 0x001f0000U | (prev_op & 0x1f) << 8 | (curr_op & 0x1f);
		  
		  peep_buf[ prev ].writes |= writes;
		  peep_buf[ prev ].reads  |= reads;
		  
		  peepf( "merged load and register op into triadic op" );

		  ++peep_eliminated;
		  
		  return TRUE;
		}
	    }
	  else if (is_mode( curr_op, ADDR_MODE_IMMEDIATE ))
	    {
	      /*
	       * check for moving one register into another followed
	       * by an immediate diadic op on that register
	       *
	       * eg turns:
	       *	LDI	R1, R0
	       *	ADDI	1,  R0
	       * into:
	       *	ADDI3	1, R1, R0
	       */

	      unsigned long	op        = OP_NOP;
	      bool		is_signed = TRUE;
	      
	      
	      switch ((curr_op >> 23) & 0x3f)
		{
		case OP_ADDC:	  op = OP_ADDC3;	  		break;
		case OP_ADDI:	  op = OP_ADDI3;	  		break;
		case OP_AND:	  op = OP_AND3;	 is_signed = FALSE;	break;
		case OP_ANDN:	  op = OP_ANDN3; is_signed = FALSE;	break;
		case OP_ASH:	  op = OP_ASH3;  is_signed = FALSE;	break;
		case OP_LSH:	  op = OP_LSH3;  is_signed = FALSE;	break;
		case OP_MPYI:	  op = OP_MPYI3;	  		break;
		case OP_OR:	  op = OP_OR3;	 is_signed = FALSE;	break;
		case OP_SUBB:	  op = OP_SUBB3;	  		break;
		case OP_SUBI:	  op = OP_SUBI3;	  		break;
		case OP_XOR:	  op = OP_XOR3;	 is_signed = FALSE;	break;
		default:
		  break;
		}      
#ifndef TRIADIC_BINARY_OPS_ARE_UNSIGNED
	      is_signed = TRUE;
#endif
	      /* check that immediate value will fit in triadic operation */
	      
	      if (is_signed)
		{
		  if (!fits_in_8_bits_signed( mask_and_sign_extend_word( curr_op, 0xFFFF )))
		    op = OP_NOP;
		}
	      else
		{
		  if (curr_op & 0xFF00 != 0)
		    op = OP_NOP;
		}
	      
	      if (op != OP_NOP)
		{
		  peep_buf[ prev ].op_code = (B_0011 << 28) | op << 23 | 0x0U << 21 |
		    prev_op & 0x001f0000U | (prev_op & 0x1f) << 8 | (curr_op & 0xff);
		  
		  peep_buf[ prev ].writes |= writes;
		  peep_buf[ prev ].reads  |= reads;
		  
		  peepf( "merged load and immediate op into triadic op" );

		  ++peep_eliminated;
		  
		  return TRUE;
		}
	    }
	  else if (is_op( curr_op, OP_STI )		 &&	/* current op is a store	*/
		   is_mode( curr_op, ADDR_MODE_INDIRECT ) )	/* current op is NOT a STIK 	*/
	    {
	      /*
	       * transforms:
	       *    LDI	R3, R1
	       *    STI	R1, *--AR6(1)
	       * into:
	       *    STI R3, *--AR6(1)
	       *    LDI R3, R1
	       */

	      reads  &= ~regbit( dest_of( curr_op ) );
	      reads  |=  regbit( dest_of( prev_op ) );
	      
	      curr_op = (curr_op & 0xFFE0FFFFU) | ((prev_op << 16) & 0x001F0000U);
	      
	      SWAP_OPS;
	      
	      peepf( "transformed and swapped register store" );

	      ++peep_transformed;
	      ++peep_swapped;
	    }
	}
      
      if (is_op(   prev_op, OP_LDI )                  &&	/* make sure our knowledge of prev is OK     */
	  is_op(   curr_op, OP_LDI )                  &&	/* current  operation is an integer load     */
	  is_mode( curr_op, ADDR_MODE_REGISTER )      &&	/* current  operation is register based      */	
	  dest_of( prev_op ) == source_of( curr_op  )  )	/* previous op's dest is current op's source */
	{
	  if (dest_of( curr_op ) == source_of( prev_op ) )	/* current  op's dest is prev    op's source */
	    {
	      /*
	       * check for two register to register loads
	       * with the source and destinations swapped
	       *
	       * eg turns:
	       * 	LDI	R0, R1
	       * 	LDI	R1, R0
	       * into:
	       * 	LDI	R0, R1
	       */
      
	      peepf( "eliminated unnecessary register load" );

	      ++peep_eliminated;
	      
	      return TRUE;
	    }
	  else
	    {
	      /*
	       * check for two register to register loads
	       * with the source and destinations matches
	       *
	       * eg turns:
	       *	LDI	R0, R1
	       *	LDI	R1, R2
	       * into:
	       *   	LDI	R0, R2
	       *   	LDI	R0, R1		<-- note swap
	       *
	       * Why bother ?  Because it is very likly that
	       * I will be able to eliminate the second load
	       * later on
	       */

	      reads &= ~regbit( source_of( curr_op ) );
	      reads |=  regbit( source_of( prev_op ) );
	      
	      curr_op = (curr_op & 0xFFFF0000U) | source_of( prev_op );
	      
	      SWAP_OPS;
	      
	      peepf( "swapped and transformed register loads" );

	      ++peep_transformed;
	      ++peep_swapped;
	    }
	}

      if (!swapped					&&	/* if instructions are still OK	*/
	  is_mode( curr_op, ADDR_MODE_REGISTER )	&&	/* and both use reg addressing	*/
	  !is_op(  curr_op, OP_CMPI )			&&	/* do not swap instructions	*/
	  !is_op(  curr_op, OP_CMPF )			&&	/* that especially set the	*/
	  !is_op(  curr_op, OP_TSTB )			&&	/* status register		*/
	  !is_op(  curr_op, OP_LDF  )			&&	/* do not swap LDI/LDF		*/
	  dest_of( prev_op ) == source_of( curr_op )	)
	{
	  /*
	   * transforms:
	   *    LDI	R3, R1
	   *    ADDI	R1, R2
	   * into:
	   *    ADDI	R3, R2
	   *    LDI	R3, R1
	   */

	  reads  &= ~regbit( dest_of( curr_op ) );
	  reads  |=  regbit( dest_of( prev_op ) );
	      
	  curr_op = (curr_op & 0xFFFF0000U) | (prev_op & 0x0000FFFFU);
	      
	  SWAP_OPS;
	      
	  peepf( "transformed and swapped register diadic" );

	  ++peep_transformed;
	  ++peep_swapped;
	}
    }
  
  /*
   * check for loading a register
   * followed by a triadic op which writes the same
   * register, and does not use the loaded register
   *
   * eg turns:
   *	LDI	R0, R1
   *	MPYI3	5,  R2, R1
   * into:
   *    MPYI3	5,  R2, R1
   *
   * and
   *	LDI	R0, R1
   *	MPYI3	5,  R1, R1
   * into:
   *	MPYI3	5,  R0, R1
   */
  
  if (is_load( prev_op )	 		&&	/* prev_op is one of LDI, LDA, LDF	*/
      is_mode(   prev_op, ADDR_MODE_REGISTER )	&&	/* prev_op uses register addressing	*/
      is_triadic( curr_op )                  	&&	/* current op is a triadic		*/
      dest_of(   prev_op ) == dest_of( curr_op ) )	/* they share the same destination	*/
    {
      bool	src1_is_prev 	= FALSE;
      bool	src2_is_prev 	= FALSE;
      bool	uses_prev	= FALSE;
      int32	T    		= (curr_op >> 21) & 3;
      int32	dest 		= dest_of( prev_op );
      int32	src1 		= (curr_op >> 8) & 0xFF;
      int32	src2 		= curr_op & 0xFF;
      

      /* check to see if triadic op uses dest of previous load */

      if ((curr_op >> 28) & 1)
	{
	  switch (T)
	    {
	    case B_00:
	      if (src1 == dest)
		src1_is_prev = TRUE;
	      break;
	      
	    case B_01:
	      if (src1 == dest)
		src1_is_prev = TRUE;

	      if (real_addr_reg( src2 & 0x7 ) == dest)
		uses_prev = TRUE;
	      break;
	      
	    case B_10:
	      if (real_addr_reg( src1 & 0x7 ) == dest)
		uses_prev = TRUE;
	      break;
	      
	    case B_11:
	      if ((real_addr_reg( src1 & 0x7 ) == dest) ||
		  (real_addr_reg( src2 & 0x7 ) == dest)  )
		uses_prev = TRUE;
	      break;
	    }
	}
      else
	{
	  switch (T)
	    {
	    case B_00:
	      if (src1 == dest)
		src1_is_prev = TRUE;
	      
	      if (src2 == dest)
		src2_is_prev = TRUE;
	      
	      break;
	      
	    case B_01:
	      if (src2 == dest)
		src2_is_prev = TRUE;
	      
	      if (((src1 & 0x7) + 0x08) == dest)
		uses_prev = TRUE;
	      break;
	      
	    case B_10:
	      if (src1 == dest)
		src1_is_prev = TRUE;
	      
	      if (((src2 & 0x7) + 0x08) == dest)
		uses_prev = TRUE;
	      break;
	      
	    case B_11:	      
	      if (((src1 & 0x7) + 0x08) == dest ||
		  ((src2 & 0x7) + 0x08) == dest)
		uses_prev = TRUE;
	      break;
	    }
	}

      if (!uses_prev)
	{
	  peepf( "eliminated unnecessary register load before triadic" );

	  ++peep_eliminated;
	  
	  peep_buf[ prev ].reads   = reads;
	  peep_buf[ prev ].writes  = writes;
	  
	  if (src1_is_prev || src2_is_prev)
	    {
	      /* move source of previous load into triadic */
	      
	      if (src1_is_prev)
		{
		  curr_op = curr_op & 0xFFFF00FFU;
		  curr_op = curr_op | (source_of( prev_op ) << 8);
		}

	      if (src2_is_prev)
		{
		  curr_op = curr_op & 0xFFFFFF00U;
		  curr_op = curr_op | source_of( prev_op );
		}
	    }
	  
	  peep_buf[ prev ].op_code = curr_op;

	  return TRUE;
	}
    }
  
#if 0	/* This is a bad and bogus peephole as it does not set R2 to correct value */
  /*
   * check for a register based diadic
   * followed by a load from the dest back into the source
   *
   * eg turns:
   *	NEGI	R1, R2
   *	LDI	R2, R1
   * into:
   *    NEGI	R1, R1
   *
   * turns:
   *    ADDI	R1, R2
   *	LDI	R2, R1
   * into:
   *    ADDI	R2, R1
   */

  if (is_diadic( prev_op )				&&	/* prev_op is a diadic			*/
      is_mode(   prev_op, ADDR_MODE_REGISTER )		&&	/* which uses register addressing	*/
      is_load(   curr_op )				&&	/* curr_op is one of LDI, LDA, LDF	*/
      is_mode(   curr_op, ADDR_MODE_REGISTER )		&&	/* and also uses register addressing	*/
      dest_of(   prev_op ) == source_of( curr_op )	&&	/* and source and destination of the	*/
      dest_of(   curr_op ) == source_of( prev_op )	)	/* two instructions are reversed	*/
    {
      switch (prev_op >> 23)
	{
	case OP_ABSF:
	case OP_ABSI:
	case OP_FIX:
	case OP_FLOAT:
	case OP_NEGF:
	case OP_NEGI:
	case OP_NOT:
	  peep_buf[ prev ].writes &= ~regbit( dest_of( prev_op ) );
	  peep_buf[ prev ].writes |=  regbit( dest_of( curr_op ) );	  
	  peep_buf[ prev ].op_code = (prev_op & 0xFFE0FFFFU) | (curr_op & 0x001F0000U);
	  
	  peepf( "removed unnecessary register load after monadic" );

	  ++peep_eliminated;
	  
	  return TRUE;

	case OP_AND:
	case OP_ADDF:
	case OP_ADDI:
	case OP_MPYF:
	case OP_MPYI:
	case OP_OR:
	case OP_TSTB:
	case OP_XOR:
	  peep_buf[ prev ].reads   = reads;
	  peep_buf[ prev ].writes  = writes;
	  peep_buf[ prev ].op_code = (prev_op & 0xFFE00000U) | (curr_op & 0x001FFFFFU);
	  
	  peepf( "removed unnecessary register load after diadic" );

	  ++peep_eliminated;
	  
	  return TRUE;
	}
    }
#endif
  
  /*
   * check for a store followed by a load to the same register
   *
   * eg turns:
   *	STI	R0, *AR6
   *	LDI	*AR6, R0
   * into:
   *    LDI	R0, *AR6
   */

  if (is_op(   prev_op, OP_STI )             	   &&	/* previous operation is an integer store        */
      is_op(   curr_op, OP_LDI )                   &&	/* current  operation is an integer load         */
      is_mode( prev_op, ADDR_MODE_INDIRECT ) 	   &&	/* previous operation uses indirect addressing   */
      is_mode( curr_op, ADDR_MODE_INDIRECT ) 	   &&	/* current  operation uses indirect addressing   */
      source_of( prev_op ) == source_of( curr_op ) &&	/* the have the same form of indirect addressing */
      dest_of( prev_op )   == dest_of( curr_op  )  && 	/* previous op's dest is current op's dest       */
      ! has_indirect_side_effects( curr_op )        )	/* the indirect addressing has no side effects   */
    {
      peepf( "eliminated unnecessary indirect load" );

      ++peep_eliminated;

      return TRUE;
    }

  /*
   * check for a load constant
   */

  if ((prev_op >> 28) == OP_LDIc                &&	/* previous of is a load (un)conditional	*/
      ((prev_op >> 23) & 0x1F) == C_U		&&	/* load is unconditional			*/
      is_mode( prev_op, ADDR_MODE_IMMEDIATE ) 	 )	/* previous operation uses immediate addressing	*/
    {
      if (is_op(   curr_op, OP_LDI )		      && /* current op is a load			 */
	  is_mode( curr_op, ADDR_MODE_REGISTER  )     && /* current  operation uses register  addressing */
          dest_of( prev_op ) == source_of( curr_op  ) )	 /* previous op's dest is current op's source	*/
	{
	  /*
	   * check for a load constant followed by a move register
	   *
	   * eg turns:
	   *    LDIu	0,  R5
	   *	LDI	R5, R0
	   * into:
	   *    LDIu	0, R5
	   *    LDIu	0, R0
	   *
	   * Why bother, I hear you ask.  The answer is that I hope
	   * at a later date, to be able to eliminate the first load
	   */

	  *pcurr_op = curr_op = (prev_op & 0xFFE0FFFFU) | (curr_op & 0x001F0000U);

	  *preads = reads = 0;
      
	  peepf( "transformed load register into load immeadiate" );

	  ++peep_transformed;
	}
#ifdef STIK_NOW_WORKS_ON_HARDWARE
      else if (is_op(   curr_op, OP_STI )	        &&	/* we have a store instruction    */
	       is_mode( curr_op, ADDR_MODE_INDIRECT )   &&	/* which uses indirect addressing */
	       dest_of( curr_op ) == dest_of( prev_op )  )	/* and they share the same destination */
	{
	  int32		val;

	  
	  /*
	   * check for a load followed by a store.
	   *
	   * turns:
	   *	LDIu	0,	R1
	   *	STI	R1,	*AR6
	   * into:
	   *	STIK	0,	*AR6
	   *	LDIu	0,	R1
	   */

	  val = mask_and_sign_extend_word( prev_op, 0xFFFF );
	  
	  if (fits_in_5_bits_signed( val ))
	    {
	      reads  &= ~regbit( dest_of( curr_op ) );	/* no longer reads destination */
	      
	      curr_op = (curr_op & 0xFF80FFFFU) | (ADDR_MODE_IMMEDIATE << 21) | ((val & 0x1F) << 16);
	      
	      SWAP_OPS;

	      if (regbit( real_register( dest_of( curr_op ) ) ) & death)
		{
		  peepf( "eliminated register load and transformed register store" );

		  ++peep_eliminated;
		  
		  return TRUE;
		}
	      else
		{
		  peepf( "transformed store register into store immeadiate" );

		  ++peep_transformed;
		}
	    }
	}
#endif /* STIK_NOW_WORKS_ON_HARDWARE */
    }
      
  /* See if both instructions alter the same register (except the status register) */

  if (writes & (peep_buf[ prev ].writes) & (~(1 << RR_ST)))
    return FALSE;
  
  /*
   * check for two load or store operations in succession
   */

  prev_load  = is_potential_parallel_op( prev_op, OP_LDI, curr_op );
  prev_store = is_potential_parallel_op( prev_op, OP_STI, curr_op );
  curr_load  = is_potential_parallel_op( curr_op, OP_LDI, prev_op );
  curr_store = is_potential_parallel_op( curr_op, OP_STI, prev_op );

  if (prev_load + prev_store + curr_load + curr_store >= 2)
    {
      if (prev_load)
	{
	  if (curr_load)
	    {
	      /* previous and current LDI */
	      
	      /* check that the destination of the loads */
	      
	      if (((prev_op >> 16) & 0x1F) == ((curr_op >> 16) & 0x1F))
		{
		  peepf( "WARNING: two successive loads with the same destination" );
		  
		  /* ignore first load */
		  
		  peep_buf[ prev ].op_code = curr_op;
		  peep_buf[ prev ].reads   = reads;
		  peep_buf[ prev ].writes  = writes;
		  
		  return TRUE;
		}
	      
	      peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                     	         (OP_LDI_LDI << 25)                     |
		                         (prev_op & (B_111 << 16)) << (22 - 16) |
		                         (curr_op & (B_111 << 16)) << (19 - 16) |
		                         (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			                 (prev_op & (0xFF  <<  8)) >> ( 8 -  0);
	      
	      peep_buf[ prev ].reads  |= reads;
	      peep_buf[ prev ].writes |= writes;
	      peep_buf[ prev ].writes &= ~regbit( RR_ST );
	      
	      peepf( "transformed LDI, LDI into LDI || LDI" );

	      ++peep_eliminated;
	      ++peep_transformed;
	      
	      return TRUE;
	    }
	  else
	    {
	      /* previous LDI, current STI */
	      
	      /* check that the destination of the load is not the source of the store */
	      
	      if (((prev_op >> 16) & 0x1F) != ((curr_op >> 16) & 0x1F))
		{
		  peep_buf[ prev ].op_code = (B_11 << 30)                           |
		                             (OP_LDI_STI << 25)                     |
		                             (prev_op & (B_111 << 16)) << (22 - 16) |
			                     (curr_op & (B_111 << 16)) << (16 - 16) |
			                     (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			                     (prev_op & (0xFF  <<  8)) >> ( 8 -  0);
		  
		  peep_buf[ prev ].reads  |= reads;
		  peep_buf[ prev ].writes |= writes;
		  peep_buf[ prev ].writes &= ~regbit( RR_ST );
		  
		  peepf( "transformed LDI, STI into LDI || STI" );

		  ++peep_eliminated;
		  ++peep_transformed;
		  
		  return TRUE;
		}
	    }
	}
      else /* prev op is STI */
	{
	  if (curr_load)
	    {
	      /* previous STI, current LDI */
	      
	      if (source_of( prev_op ) == source_of( curr_op ))
		{
		  /* weird - a store followed by a load from the same place ! */
		  
		  if (dest_of( prev_op ) == dest_of( curr_op ))
		    {
		      peepf( "eliminated register load" );

		      ++peep_eliminated;
		      
		      return TRUE;
		    }
		  else
		    {
		      /* transform load into register move */
		      
		      *preads   = regbit( dest_of( prev_op ) );
		      *pwrites  = regbit( dest_of( curr_op ) ) | regbit( RR_ST );
		      *pcurr_op = build_op( OP_LDI, ADDR_MODE_REGISTER,
					   dest_of( curr_op ), dest_of( prev_op ) );
		      
		      peepf( "transformed memory access into register transfer" );

		      ++peep_transformed;
		      
		      return FALSE;
		    }
		}
	      
	      peep_buf[ prev ].op_code = (B_11 << 30)                           |
		                         (OP_LDI_STI << 25)                     |
		                         (curr_op & (B_111 << 16)) << (22 - 16) |
		                         (prev_op & (B_111 << 16)) << (16 - 16) |
		                         (prev_op & (0xFF  <<  8)) << ( 8 -  8) |
			                 (curr_op & (0xFF  <<  8)) >> ( 8 -  0);
	      
	      peep_buf[ prev ].reads  |= reads;
	      peep_buf[ prev ].writes |= writes;
	      peep_buf[ prev ].writes &= ~regbit( RR_ST );
	      
	      peepf( "transformed STI, LDI into LDI || STI" );

	      ++peep_transformed;
	      ++peep_eliminated;
	      
	      return TRUE;
	    }
#ifdef STI_STI_NOW_WORKS_ON_HARDWARE
	  else
	    {
	      /* previous and current STI */
	      
	      if (source_of( prev_op ) == source_of( curr_op ))
		{
		  /* weird two stores to the same place ! */
		  
		  peepf( "eliminating duplicate store!" );

		  ++peep_eliminated;
		  
		  /* eliminate the first store */
		  
		  SWAP_OPS;

		  return TRUE;
		}
	      
	      peep_buf[ prev ].op_code = (B_11 << 30)                           |
		                         (OP_STI_STI << 25)                     |
		                         (prev_op & (B_111 << 16)) << (22 - 16) |
		                         (curr_op & (B_111 << 16)) << (16 - 16) |
		                         (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			                 (prev_op & (0xFF  <<  8)) >> ( 8 -  0);
	      
	      peep_buf[ prev ].reads  |= reads;
	      peep_buf[ prev ].writes |= writes;
	      peep_buf[ prev ].writes &= ~regbit( RR_ST );
	      
	      peepf( "transformed STI, STI into STI || STI" );

	      ++peep_eliminated;
	      ++peep_transformed;
	      
	      return TRUE;
	    }
#endif /* STI_STI_NOW_WORKS_ON_HARDWARE */
	}
    }

  return FALSE;
  
} /* combine_instrs */
  
  
static void
peep_swap(
	  signed int	a,
	  signed int	b,
	  char *	reason )
a10171 20
  peep_data	tmp = peep_buf[ a ];

  peep_buf[ a ] = peep_buf[ b ];
  peep_buf[ b ] = tmp;

  if (asmstream != NULL && (feature & FEATURE_ANNOTATE))
    {
      fprintf( asmstream, "; peepholer: swapped " );

      decode_instruction( peep_buf[ a ].op_code, FALSE );

      fprintf( asmstream, " with " );

      decode_instruction( peep_buf[ b ].op_code, FALSE );
  
      fprintf( asmstream, " because: %s\n", reason );
    }

  ++peep_swapped;
  
a10172 194
  
} /* peep_swap */


static void
append_peep(
	    peep_type		type,
	    int32		op_code,
	    int32		reads,
	    int32		writes,
	    Symstr *		symbol,
	    LabelNumber *	label,
	    int32		reftype )
{
  signed int	next;


  if (!xref_pending && !fref_pending)
    {
      /* see if we have a redundant op-code */

      if (type == OUT_NULL && eliminate_null_op())
	return;

      /* see if we can combine two ops into one */
  
      if (type == OUT_INSTR && combine_instrs( &op_code, &reads, &writes ))
	{
	  return;
	}
    }

  if (peep_protect_pc > 0)
    {
      reads |= regbit( RR_PC );

      --peep_protect_pc;
    }
  
  /* insert the instruction into the table */
  
  peep_buf[ peep_end ].type    = type;
  peep_buf[ peep_end ].op_code = op_code;
  peep_buf[ peep_end ].reads   = reads;
  peep_buf[ peep_end ].writes  = writes;
  peep_buf[ peep_end ].symbol  = symbol;
  peep_buf[ peep_end ].reftype = reftype;
  peep_buf[ peep_end ].label   = label;

  /* check to see if this instruction was a cross reference or a forward reference */

  if (xref_pending)
    {
      if (fref_pending)
	{
	  syserr( "back end: peepholer: pending forward and cross references for same instruction!" );
	}
      
      if (type == OUT_INSTR)
	{
	  if (pending_reftype == LABREF_NONE)
	    {
	      peep_buf[ peep_end ].type    = OUT_SYMREF;
	      peep_buf[ peep_end ].symbol  = pending_symbol;
	    }
	  else
	    {
	      peep_buf[ peep_end ].type    = OUT_XREF;
	      peep_buf[ peep_end ].symbol  = pending_symbol;
	      peep_buf[ peep_end ].reftype = pending_reftype;
	    }
	}
      else if (type == OUT_SYMREF)
	{
	  peep_buf[ peep_end ].type    = OUT_SYMXREF;
	  peep_buf[ peep_end ].reftype = pending_reftype;
	}
      else if (type == OUT_DELSYMREF)
	{
	  peep_buf[ peep_end ].type    = OUT_DELSYMXREF;
	  peep_buf[ peep_end ].reftype = pending_reftype;
	}
      else
	{
	  syserr( "back end: peepholer: special instruction type had a pending cross reference!" );
	}

      xref_pending = FALSE;
    }
  else if (fref_pending)
    {
      if (type == OUT_INSTR)
	{
	  peep_buf[ peep_end ].type    = OUT_LABREF;
	  peep_buf[ peep_end ].label   = pending_label;
	  peep_buf[ peep_end ].reftype = pending_reftype;
	}
      else
	{
	  syserr( "back end: peepholer: special instruction type had a pending forward reference!" );
	}

      fref_pending = FALSE;
    }

  /* adjust pointer to indicate next free slot */

  next = successor_( peep_end );

  if (next == peep_start)
    {
      /* table is full */

      emit_from_peep();
    }

  peep_end = next;

  /*
   * try to avoid pipeline conflicts when using (real) address registers
   */

  if (!in_stubs 	&&	/* do not alter stub generation */
      !no_peepholing 	)	/* only operate if allowed to	*/
    {
      signed int	back1 = previous_( peep_end );
      signed int	back2 = previous_( back1 );
      int32		prev;


      if (num_in_peep_() > 1)
	prev = peep_buf[ back2 ].op_code;
      
      if (peep_pending_swaps > 0)
	{
	  if (num_in_peep_() > 1 		&& /* if there are instructions to swap */
	      is_normal( op_code )		&& /* and first is diadic or triadic	*/
	      is_normal( prev )			&& /* and second is diadic or triadic   */ 
	      can_swap( back1, back2, FALSE )    ) /* and we are allowed to swap them   */
	    {
	      peep_swap( back1, back2, "forwards pipeline conflict avoidance" );
	      
	      --peep_pending_swaps;
	    }
	  else
	    {
	      if (asmstream != NULL && num_in_peep_() > 1 && (feature & FEATURE_ANNOTATE))
		{
		  fprintf( asmstream, "; could not swap op " );
		  
		  decode_instruction( op_code, FALSE );
		  
		  fprintf( asmstream, " with op " );
		  
		  decode_instruction( prev, FALSE );
		  
		  fprintf( asmstream, "\n" );
		}
	      
	      peepf( "%d forward swaps left undone", peep_pending_swaps );
	      
	      /* stop trying to swap instrs */

	      peep_pending_swaps = 0;
	    }
	}
      else if (
	       is_normal( op_code )                    	         && /* is diadic or triadic		*/
	       dest_of( op_code ) == hardware_register( R_ATMP ) && /* and its destination is R_ATMP	*/
	       !is_op( op_code, OP_STI  )              	         && /* and it is not a store		*/
	       !is_op( op_code, OP_STIK )              	     	 && /* of any kind			*/
	       !is_op( op_code, OP_STF  )                         )
	{
	  (void) peep_shift_back( 2 );
	}
      else if (
	       num_in_peep_() > 1			&&	/* there is a previous op to check	*/
	       is_normal( prev ) 			&&	/* diadic or triadic 			*/
	       is_normal( op_code ) 			&&	/* diadic or triadic 			*/
	       is_mode( op_code, ADDR_MODE_INDIRECT ) 	&&	/* current op uses indirect addressing	*/
	       dest_of( prev ) == real_addr_reg( indirect_addr_reg( op_code ) ) )
	{
	  /*
	   * indicate that we would like the current instruction swapped forwards
	   */
      
	  if (is_op( prev, OP_LDPK ))
	    peep_pending_swaps = 0;
	  else if (is_op( prev, OP_LDA))
	    peep_pending_swaps = 1;
	  else
	    peep_pending_swaps = 2;
	}
    }
d10174 1
a10174 361
  return;
  
} /* append_peep */
  

/*
 * returns TRUE if the last instruction in the peepholer
 * is a register based LDI whoes destination is the register
 * given
 */

static bool
peep_reg_transfer_to( RealRegister r )
{
  int32		op;
  

  op = peep_buf[ previous_( peep_end ) ].op_code;
  
  if (peep_end != peep_start            &&	/* if there are any instructions in the peepholer */
      is_op( op, OP_LDI )               &&	/* and the last instruction is a load instruction */
      is_mode( op, ADDR_MODE_REGISTER ) &&	/* and it is a transfer between two registers     */
      dest_of( op ) == hardware_register( r ) )	/* and the destination register is the given reg  */
    {
      return TRUE;
    }
  
  return FALSE;
  
} /* peep_reg_transfer_to */

  
/*
 * returns TRUE if the last instruction in the peepholer
 * which sets the status register will set the condition
 * codes based on the contents of register 'r'
 */

static bool
peep_sets_status_reg( RealRegister r )
{
  signed int	prev;


  if (peep_start == peep_end)
    return FALSE;					/* nothing in the peepholer */

  prev = peep_end;
  
  do
    {
      int32	writes;

      
      prev = previous_( prev );

      writes = peep_buf[ prev ].writes;
      
      if (writes & regbit( RR_ST ))			/* the instruction sets the status register	*/
	{
	  int32		op;

	  
	  if (writes & regbit( r ))			/* the instruction writes to register 'r'	*/
	    return TRUE;

	  op = peep_buf[ prev ].op_code;
      
	  if (is_op(   op, OP_LDI ) 		    &&	/* or the instruction is a load			*/
	      is_mode( op, ADDR_MODE_REGISTER )     &&	/* and it is a register to register transfer	*/
	      (peep_buf[ prev ].reads & regbit( r )) )	/* and the instruction reads from register 'r'	*/
	    return TRUE;

	  return FALSE;
	}
      else if (writes & regbit( r ))
	{
	  return FALSE;					/* the instruction alters 'r' but not ST	*/
	}
            
      /* continue until we run out of instructions */
    }
  while (prev != peep_start);

  return FALSE;
  
} /* peep_sets_status_reg */

  
/*
 * returns TRUE if any of the instructions in the peeholer
 * reference the given label.  Returns FALSE otherwise.
 */

static bool
peep_refs_label( LabelNumber * l )
{
  signed int	i;


  for (i = peep_start; i != peep_end; i = successor_( i ))
    {
      if ((peep_buf[ i ].type == OUT_LABREF || peep_buf[ i ].type == OUT_DELLABREF) &&
	  peep_buf[ i ].label == l)
	{
	  return TRUE;
	}
    }

  return FALSE;
  
} /* peep_refs_label */

  
/*
 * returns the source register of the register transfer
 * instruction that is the last instruction in the peepholer
 */

static RealRegister
peep_eliminate_reg_transfer( RealRegister r )
{
  int32		op;
  

  if (xref_pending || fref_pending)
    {
      syserr( "back end: peepholer: attempting to eliminate instruction whilst a reference is still pending" );
    }

  op = peep_buf[ previous_( peep_end ) ].op_code;
  
  if (peep_end != peep_start            &&
      is_op( op, OP_LDI )               &&
      is_mode( op, ADDR_MODE_REGISTER ) &&
      dest_of( op ) == hardware_register( r ) )
    {
      peep_end = previous_( peep_end );

      return real_register( source_of( op ) );
    }
  
  syserr( "back end: peepholer: trying to eliminate non-existant register transfer" );

  return GAP;
  
} /* peep_eliminate_reg_transfer */


/*
 * Try to push the latest instruction in the peepholer back
 * by the number of instructions indicated.  Returns the
 * actual number of instructions skipped.
 */

static int
peep_shift_back( int n )
{
  signed int	prev;
  signed int	last;
  int		done;
  
  
  /* check that we can move the instructions */
  
  if (xref_pending || fref_pending || peep_end == peep_start || n < 1)
    {
      return 0;
    }

  /* get last instruction */
  
  last = prev = previous_( peep_end );

  /* initialise count of successful swaps */
  
  done = 0;
  
  /* examine previous instructions */
  
  while (prev != peep_start && n--)
    {
      prev = previous_( prev );

      if (can_swap( last, prev, TRUE ))
	{
	  /* swap the two instructions */

	  peep_swap( last, prev, "backwards pipeline conflict avoidance" );
	  
	  /* update pointer to the "last" instruction */
	  
	  last = prev;

	  /* increment count */
	  
	  done++;
	}
      else
	{
#if 0
	  fprintf( asmstream, "; peepholer: could not swap " );

	  decode_instruction(  peep_buf[ last ].op_code, FALSE );

	  fprintf( asmstream, " with " );
	  
	  decode_instruction( peep_buf[ prev ].op_code, FALSE );

	  fprintf( asmstream, "\n" );
#endif	  
	  return done;
	}
    }

  return done;
  
} /* peep_shift_back */

  
/*
 * empty the peephole buffer
 */

static void
flush_peepholer( const char * reason )
{
  flush_pending_pushes();
  
  if (xref_pending)
    {
      syserr( "back end: peepholer: attempting to flush peepholer whilst a cross ref is still pending" );
    }

  if (fref_pending)
    {
      syserr( "back end: peepholer: attempting to flush peepholer whilst a forward ref is still pending" );
    }

  while (peep_start != peep_end)
    {
      emit_from_peep();      
    }

  /* peepf( "flushed: %s ", reason ); */

  if (num_in_peep_() > 0)
    syserr( "peepholer: flush has failed to reset peep count" );
  
  return;
  
} /* flush_peepholer */


/*
 * remove an instruction from the peephole buffer
 * performing any peep hole optimisations that you can
 */

static void
emit_from_peep( void )
{
  peep_data *	instruction;
  int32		offset;
  int32		op;

  
  if (peep_start == peep_end)
    {
      cc_warn( "peepholer: attempting to emit from EMPTY peepholer!" );

      return;
    }

  /*
   * possible futher optimisations :-
   *
   *   parallel load / store & diadic / triadic op
   *
   *   elimination of compare then link-and-jump with a conditional link-and-jump
   *
   */

  /* now send out an instruction */

  instruction = &(peep_buf[ peep_start ]);

  op = instruction->op_code;

  switch (instruction->type)
    {
    default:
      syserr( "back end: peepholer: asked to emit an unknown type %d", instruction->type );
      break;
      
    case OUT_XREF:
      codexrefs = (CodeXref *) global_list3( SU_Other, codexrefs,
					    instruction->reftype + codebase + codep,
					    instruction->symbol );
      
      outcodewordaux( op, LIT_RELADDR, instruction->symbol );
      
      break;

    case OUT_DELLABREF:
    case OUT_LABREF:
      if (lab_isset_( instruction->label ))
	{
	  syserr( "back end: peepholed instruction referencing already set label" );
	}
      else
	{
	  addfref_( instruction->label, codep | instruction->reftype );
	}
      
      /* drop through */

    case OUT_DELAYED:
      /* drop through */
      
    case OUT_NULL:
      /* drop through */

    case OUT_INSTR:
      outcodeword( op, LIT_OPCODE );
      break;

    case OUT_DELSYMXREF:
      /* drop through */
      
    case OUT_SYMXREF:
      codexrefs = (CodeXref *) global_list3( SU_Other, codexrefs,
					    instruction->reftype + codebase + codep,
					    instruction->symbol );
      /* drop through */

    case OUT_SYMREF:
      outcodewordaux( op, LIT_RELADDR, instruction->symbol );
      break;

    case OUT_DELSYMREF:
      offset = mask_and_sign_extend_word( op, 0x00ffffffU );
      
      if (offset != 0)
	{
	  /* subtract codep from offset */
	  
	  op = (op & 0xff000000U) |
	    ((offset - (codep / sizeof_int)) & 0x00ffffffU);
	}
				   
      outcodewordaux( op, LIT_RELADDR, instruction->symbol );
      
      break;
    }

  peep_start = successor_( peep_start );
  
  return;
   
} /* emit_from_peep */
a10175 1
/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^ PEEPHOLER ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
@


1.156
log
@improved asm output
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.155 1992/04/22 16:43:08 nickc Exp nickc $ */
d126 1
a127 1

a188 2
static RealRegister	register_in_R_ATMP = GAP;	/* maintains memory of contents of R_ATMP */
static int32		offset_in_R_ATMP   = 0;		/* word offset added to register in R_ATMP */
d1173 3
a1175 2
  if (register_in_R_ATMP == dest)
    register_in_R_ATMP = GAP;
d1928 1
d1931 1
a1931 1
static void
d1933 10
a1942 4
			  RealRegister	src,		/* register contain byte offset */
			  RealRegister	dest,		/* register to contain word offset */
			  int32		offset )	/* offset in bytes to be added in */
{
d1944 2
d1947 3
a1949 1
  if (dest == R_ATMP)
d1951 1
a1951 1
      if (src == register_in_R_ATMP && !no_peepholing)
d1953 3
a1955 1
	  if (offset == offset_in_R_ATMP)
a1956 2
	      peepf( "eliminated load and add to temporary address register" );

a1957 2

	      return;
d1961 3
a1963 1
	      offset -= offset_in_R_ATMP;
d1965 17
a1981 1
	      if (fits_in_16_bits_signed( offset ))
d1983 1
a1983 5
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, offset,
				examines1( dest ),
		    		alters2( dest, RR_ST ) );
		  
		  peepf( "eliminated load to temporary address register" );
d1985 1
a1985 3
		  ++peep_eliminated;
		  
		  offset_in_R_ATMP += offset;
d1987 1
a1987 1
		  return;
d1989 4
a1992 4
	      else
		{
		  offset += offset_in_R_ATMP;
		}
d1995 9
d2005 7
a2011 2
      register_in_R_ATMP = src;
      offset_in_R_ATMP   = offset;
a2028 2
  /* try to push this instruction back a couple of ops as this may avoid pipeline conflicts */

d2042 1
a2042 1
	syserr( "back end: offset register xconflict" );
d2051 3
a2053 1
  return;
d2066 5
a2070 5
		     int32		op,
		     RealRegister	dst,
		     RealRegister	src,
		     int32		offset,
		     int32		can_corrupt_src )	/* non-zero if 'src' may be courrupted */
d2072 2
a2073 1
  bool	is_store = (op == OP_STI || op == OP_STF);
d2097 10
a2106 3
	      if (!no_peepholing &&
		  register_in_R_ATMP == src &&
		  fits_in_16_bits_signed( offset - offset_in_R_ATMP ) )
d2110 12
a2121 5
		  ++peep_eliminated;
		  
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, offset - offset_in_R_ATMP,
				examines1( R_ATMP ),
				alters2( R_ATMP, RR_ST ) );		  
d2125 6
a2130 1
		  load_integer( R_ATMP, offset, FALSE );
d2132 3
a2134 5
		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, src,
				examines2( src, R_ATMP ),
				alters2( R_ATMP, RR_ST ) );
		  
		  register_in_R_ATMP = src;
d2137 3
a2139 3
	      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, R_ATMP, 0 ),
			    is_store ? examines2( dst, R_ATMP ) : examines1( R_ATMP ),
			    is_store ? alters0()                : alters2( dst, RR_ST ) );
d2141 1
a2141 1
	      offset_in_R_ATMP = offset;
a2170 2
      /* try to push this instruction back a couple of ops as this may avoid pipeline conflicts */

d2197 5
a2201 3
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, src, 0 ),
		    is_store ? examines3( dst, RR_IR0, src ) : examines2( RR_IR0, src ),
		    is_store ? alters0()                     : alters2( dst, RR_ST ) );
d2205 1
a2205 1
      RealRegister	tmp;
d2208 1
d2213 1
a2213 1
	  tmp = RR_AR2;
d2217 11
a2227 1
	  tmp = R_ATMP;
d2230 18
a2247 1
      convert_to_word_alignment( src, tmp, offset );
d2249 4
a2252 1
      /* send the operation */
d2254 1
a2254 3
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, tmp, 0 ),
		    is_store ? examines3( dst, RR_IR0, tmp ) : examines2( RR_IR0, tmp ),
		    is_store ? alters0()                     : alters2( dst, RR_ST ) );
d2257 1
a2257 1
  if ((op == OP_LDI || op == OP_LDF) && dst == register_in_R_ATMP)
d2259 3
a2261 1
      register_in_R_ATMP = GAP;
d2281 3
d2291 2
a2294 13
      /*
       * the stack pointer and frame pointers are always
       * word pointers so no special adjustments should
       * be necessary
       */

      /* check to see if we about to access the stack and there are pushes pending */
      
      if (src == R_SP)
	{
	  flush_pending_pushes();
	}
	  
d2299 1
a2299 1
	  if (!fits_in_8_bits_unsigned( abs( offset + 1 ) ))
d2301 1
a2301 15
	      if (!no_peepholing &&
		  register_in_R_ATMP == src &&
		  fits_in_16_bits_signed( offset - offset_in_R_ATMP ) )
		{
		  peepf( "eliminated load to temporary address register" );

		  ++peep_eliminated;
		  
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, offset - offset_in_R_ATMP,
				examines1( R_ATMP ),
				alters2( R_ATMP, RR_ST ) );		  
		}
	      else
		{
		  load_integer( R_ATMP, offset, FALSE );
d2303 2
a2304 11
		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, src,
				examines2( src, R_ATMP ),
				alters2( R_ATMP, RR_ST ) );
		  
		  register_in_R_ATMP = src;
		}
			    
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_REL, R_ATMP, 0 ),
			    examines1( R_ATMP ),
			    alters2( dst, RR_ST ) );
d2307 2
a2308 2
			    build_indirect( INDIRECT_PRE_ADD, R_ATMP, 1 ),
			    examines1( R_ATMP ),
a2309 2

	      offset_in_R_ATMP = offset;
d2313 1
a2313 4
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_ADD, src, offset ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
d2315 24
a2338 4
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_ADD, src, offset + 1 ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
a2341 5
	      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
			    build_indirect( INDIRECT_PRE_SUB, src, -offset ),
			    examines1( src ),
			    alters2( dst, RR_ST ) );
	      
a2349 5
	  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
			build_indirect( INDIRECT_REL, src, 0 ),
			examines1( src ),
			alters2( dst, RR_ST ) );
	  
a2357 39
      /* convert source pointer to word offset by dividing by sizeof_int (here assumed to be 4) */
      
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, src, -2,
		     examines1( src ),
		     alters2( src, RR_ST ) );

      /* add in the offset */
      
      offset /= sizeof_int;

      if (offset == 0)
	{
	  ;	/* do nothing */
	}
      else if (fits_in_16_bits_signed( offset ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, src, offset,
			examines1( src ),
			alters2( src, RR_ST ) );
	}
      else
	{
	  if (src == R_TMP2)
	    syserr( "back end: register offset conflict" );

	  load_integer( R_TMP2, offset, FALSE );

	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, src, R_TMP2,
			examines2( src, R_TMP2 ),
			alters2( src, RR_ST ) );
	}

      /* send the operation */
      
      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
		    build_indirect( INDIRECT_PRE_INCR_IR0, src, 0 ),
		    examines2( RR_IR0, src ),
		    alters3( dst, src, RR_ST ) );
      
a2364 3
      RealRegister	tmp;


d2369 1
a2369 1
	  tmp = RR_AR2;
d2373 1
a2373 1
	  tmp = R_ATMP;
a2375 9
      convert_to_word_alignment( src, tmp, offset );
      
      /* send the operation */
      
      out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, dst,
		    build_indirect( INDIRECT_PRE_INCR_IR0, tmp, 0 ),
		    examines2( RR_IR0, tmp ),
		    alters3( dst, tmp, RR_ST ) );
      
d2377 2
a2378 2
		    build_indirect( INDIRECT_PRE_ADD, tmp, 1 ),
		    examines1( tmp ),
d2380 2
d2383 1
a2383 6
  
  if (dst == register_in_R_ATMP)
    {
      register_in_R_ATMP = GAP;
    }
  
d2402 3
d2411 2
a2415 13
      /*
       * the stack pointer and frame pointers are always
       * word pointers so no special adjustments should
       * be necessary
       */

      /* check to see if we about to access the stack and there are pushes pending */
      
      if (addr == R_SP)
	{
	  flush_pending_pushes();
	}
	  
d2420 1
a2420 1
	  if (!fits_in_8_bits_unsigned( abs( offset + 1 ) ))
d2422 1
a2422 15
	      if (!no_peepholing &&
		  register_in_R_ATMP == addr &&
		  fits_in_16_bits_signed( offset - offset_in_R_ATMP ) )
		{
		  peepf( "eliminated load to temporary address register" );

		  ++peep_eliminated;
		  
		  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, offset - offset_in_R_ATMP,
				examines1( R_ATMP ),
				alters2( R_ATMP, RR_ST ) );
		}
	      else
		{
		  load_integer( R_ATMP, offset, FALSE );
d2424 2
a2425 11
		  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, addr,
				examines2( addr, R_ATMP ),
				alters2( R_ATMP, RR_ST ) );
		  
		  register_in_R_ATMP = addr;
		}
			    
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val,
			    build_indirect( INDIRECT_REL, R_ATMP, 0 ),
			    examines2( val, R_ATMP ),
			    alters0() );
d2428 2
a2429 2
			    build_indirect( INDIRECT_PRE_ADD, R_ATMP, 1 ),
			    examines2( val, R_ATMP ),
a2430 2

	      offset_in_R_ATMP = offset;
d2434 1
a2434 4
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val,
			    build_indirect( INDIRECT_PRE_ADD, addr, offset ),
			    examines2( val, addr ),
			    alters0() );
d2436 24
a2459 4
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val,
			    build_indirect( INDIRECT_PRE_ADD, addr, offset + 1 ),
			    examines2( val, addr ),
			    alters0() );
a2462 5
	      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val,
			    build_indirect( INDIRECT_PRE_SUB, addr, -offset ),
			    examines2( val, addr ),
			    alters0() );
	      
a2470 5
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, val,
			build_indirect( INDIRECT_PRE_ADD, addr, 1 ),
			examines2( val, addr ),
			alters0() );
	  
a2478 39
      /* convert source pointer to word offset by dividing by sizeof_int (here assumed to be 4) */
      
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
		     examines1( addr ),
		     alters2( addr, RR_ST ) );

      /* add in the offset */
      
      offset /= sizeof_int;

      if (offset == 0)
	{
	  ;	/* do nothing */
	}
      else if (fits_in_16_bits_signed( offset ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, addr, offset,
			examines1( addr ),
			alters2( addr, RR_ST ) );
	}
      else
	{
	  if (addr == R_TMP2)
	    syserr( "back end: offset register xconflict" );

	  load_integer( R_TMP2, offset, FALSE );
      
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, addr, R_TMP2,
			examines2( addr, R_TMP2 ),
			alters2( addr, RR_ST ) );
	}

      /* send the operation */
      
      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val,
		    build_indirect( INDIRECT_PRE_INCR_IR0, addr, 0 ),
		    examines3( val, addr, RR_IR0 ),
		    alters0() );
      
a2485 3
      RealRegister	tmp;


d2490 1
a2490 1
	  tmp = RR_AR2;
d2494 1
a2494 1
	  tmp = R_ATMP;
a2496 9
      convert_to_word_alignment( addr, tmp, offset );
      
      /* send the operation */
      
      out_diadic_op( OP_STF, ADDR_MODE_INDIRECT, val,
		    build_indirect( INDIRECT_PRE_INCR_IR0, tmp, 0 ),
		    examines3( val, tmp, RR_IR0 ),
		    alters0() );
      
d2498 5
a2502 3
		    build_indirect( INDIRECT_PRE_ADD, tmp, 1 ),
		    examines2( val, tmp ),
		    alters1( tmp ) );
d2543 5
d2552 1
a2552 1
      convert_to_word_alignment( offset, R_ATMP, 0 );
d2561 2
a2563 2
      register_in_R_ATMP = GAP;
      
d2579 2
a2580 2
      
      register_in_R_ATMP = GAP;
d2584 3
a2586 1
      convert_to_word_alignment( R_ATMP, R_ATMP, 0 );
a2587 2
      /* complete operation */
  
d2593 1
a2593 1
  if (op == OP_LDI && dst == register_in_R_ATMP)
d2595 1
a2595 1
      register_in_R_ATMP = GAP;
d2627 1
a2627 1
      convert_to_word_alignment( R_ATMP, offset, 0 );
d2636 2
a2637 2
      
      register_in_R_ATMP = GAP;
d2658 2
a2659 2
      
      register_in_R_ATMP = GAP;
d2663 1
a2663 1
      convert_to_word_alignment( R_ATMP, R_ATMP, 0 );
d2675 2
a2676 5
  
  if (dst == register_in_R_ATMP)
    {
      register_in_R_ATMP = GAP;
    }
d2707 1
a2707 1
      convert_to_word_alignment( R_ATMP, offset, 0 );
d2716 2
a2717 2
      
      register_in_R_ATMP = GAP;
d2738 2
a2740 2
      register_in_R_ATMP = GAP;
      
d2743 1
a2743 1
      convert_to_word_alignment( R_ATMP, R_ATMP, 0 );
d2749 1
a2749 1
		    alters0() );
d3091 2
a3093 2
  register_in_R_ATMP = GAP;
  
d3211 2
a3212 2
			RealRegister src,
			RealRegister dst )
d3214 2
a3215 1
  convert_to_word_alignment( src, dst, 0 );
d3217 13
a3229 3
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dst, R_BASE,
		examines2( dst, R_BASE ),
		alters2( dst, RR_ST ) );
d3370 1
a3370 1
      register_in_R_ATMP = GAP;
d4091 1
a4091 1
	      register_in_R_ATMP = GAP;
d4227 2
a4228 5
 
  if (dest == register_in_R_ATMP)
    {
      register_in_R_ATMP = GAP;
    }
d4300 2
a4301 5
    
  if (dest == register_in_R_ATMP)
    {
      register_in_R_ATMP = GAP;
    }
d5096 2
a5097 2
  
  register_in_R_ATMP = GAP;
d5790 3
a5792 1
  /* forget about contents of R_ATMP */
a5793 2
  register_in_R_ATMP = GAP;

d6847 1
a6847 1
      convert_to_word_alignment( start, dst, 0 );
d6863 1
a6863 1
      
d6866 1
a6866 2
	  register_in_R_ATMP = start;
	  offset_in_R_ATMP   = 0;
d6871 1
a6871 1
      convert_to_word_alignment( start, dst, 0 );
d6900 1
a6900 2
	  register_in_R_ATMP = start;
	  offset_in_R_ATMP   = 0;
d6971 1
a6971 2
	  register_in_R_ATMP = start;
	  offset_in_R_ATMP   = length;
d6995 2
a6996 2
  int		restore_ar   = FALSE;
  int		using_R_ATMP = FALSE;
d7014 1
a7014 3
      register_in_R_ATMP = source;

      using_R_ATMP = TRUE;
d7027 1
a7027 3
	  register_in_R_ATMP = dest;

	  using_R_ATMP = TRUE;
d7059 2
a7060 2
      convert_to_word_alignment( src, source, 0 );
      convert_to_word_alignment( dst, dest,   0 );
d7070 2
a7071 2
      if (using_R_ATMP)
	offset_in_R_ATMP = 0;
d7078 2
a7079 2
      convert_to_word_alignment( src, source, 0 );
      convert_to_word_alignment( dst, dest,   0 );
d7139 2
a7140 2
      if (using_R_ATMP)
	offset_in_R_ATMP = 0;
d7259 2
a7260 2
      if (using_R_ATMP)
	offset_in_R_ATMP = length / sizeof_int;
d7429 2
a7430 1

d7441 1
a7441 1
	  offset >>= 2;			/* note assumption about sizeof_int */
d7447 10
a7456 3
		  if (!no_peepholing &&
		      register_in_R_ATMP == address &&
		      fits_in_16_bits_signed( offset - offset_in_R_ATMP ))
d7460 7
a7466 1
		      ++peep_eliminated;
d7468 4
a7471 3
		      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, offset - offset_in_R_ATMP,
				examines1( R_ATMP ),
				alters2( R_ATMP, RR_ST ) );
d7475 6
a7480 1
		      load_integer( R_ATMP, offset, FALSE );
d7482 3
a7484 5
		      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, address,
				examines2( address, R_ATMP ),
				alters2( R_ATMP, RR_ST ) );
			    
		      register_in_R_ATMP = address;
d7486 2
d7489 1
a7489 3
		  offset_in_R_ATMP = offset;
		  
		  indirect_field = build_indirect( INDIRECT_REL, R_ATMP, 0 );
d7491 1
a7491 1
		  address = R_ATMP;
d7603 2
a7604 2
  
  register_in_R_ATMP = GAP;
d7607 5
a7611 5
   *    addr    - byte offset (might be an alias for R_TMP1)
   *    operand - free or value to store
   *    R_TMP1  - free
   *    R_TMP2  - free
   *    R_TMP3  - free
d7968 1
a7968 1
  if (is_load && operand == register_in_R_ATMP)
d7970 1
a7970 1
      register_in_R_ATMP = GAP;
d8570 2
a8571 2
      
      register_in_R_ATMP = GAP;
d8674 2
a8675 2
	  
	  register_in_R_ATMP = GAP;
d8774 1
a8774 1
	  register_in_R_ATMP = GAP;
d9424 1
a9424 3
      else if (!no_peepholing            &&
	       r2r == register_in_R_ATMP &&
	       is_word_addressed_( r2r )  )
d9426 5
d9433 3
a9435 1
	  
a9436 2

	  m -= offset_in_R_ATMP;
d9438 3
a9440 1
	  if (m == 0)
d9442 5
a9446 1
	      peepf( "eliminated unnecessary integer load" );
d9448 7
a9454 7
	      ++peep_eliminated;
	      
	      move_register( R_ATMP, r1r, FALSE );
	    }
	  else if (fits_in_8_bits_signed( m ))
	    {
	      peepf( "eliminated unnecessary integer load" );
d9456 1
a9456 1
	      ++peep_eliminated;
d9458 8
a9465 3
	      out_triadic_op( OP_SUBI3, r1r, R_ATMP, m, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( R_ATMP ),
			     alters2( r1r, RR_ST ) );
d9469 1
a9469 1
	      integer_immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, (m + offset_in_R_ATMP) * sizeof_int, TRUE );
d9471 2
a9482 5
      if (is_word_addressed_( r2r ))
	{
	  convert_to_byte_offset( r1r );
	}
      
d9522 1
a9522 3
      else if (!no_peepholing            &&
	       r2r == register_in_R_ATMP &&
	       is_word_addressed_( r2r )  )
d9524 5
d9534 7
a9540 1
	  m -= offset_in_R_ATMP;
d9542 3
a9544 3
	  if (m == 0)
	    {
	      peepf( "eliminated unnecessary integer load" );
d9546 1
a9546 1
	      ++peep_eliminated;
d9548 5
a9552 5
	      move_register( R_ATMP, r1r, FALSE );
	    }
	  else if (fits_in_8_bits_signed( m ))
	    {
	      peepf( "eliminated unnecessary integer load" );
d9554 1
a9554 1
	      ++peep_eliminated;
d9556 8
a9563 3
	      out_triadic_op( OP_ADDI3, r1r, R_ATMP, m, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( R_ATMP ),
			     alters2( r1r, RR_ST ) );
d9567 1
a9567 1
	      integer_immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, (m + offset_in_R_ATMP) * sizeof_int, TRUE );
d9569 2
a9578 5
	}
      
      if (is_word_addressed_( r2r ))
	{
	  convert_to_byte_offset( r1r );
@


1.155
log
@fixed bug in J_ENDPROC
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.154 1992/04/22 13:59:14 nickc Exp nickc $ */
d128 2
a129 2
#define CONTIGUOUS_ARGS	(PROC_ARGPUSH | PROC_ARGADDR)
#define NONLEAF 	(CONTIGUOUS_ARGS | PROC_BIGSTACK | BLKCALL)
d192 4
a195 1
static int32		peep_protect_pc	   = 0;		/* number of instructions to protect */
d264 1
a264 1
  const char *	format;		/* printf (3) style format string */
d271 2
a272 1
  if (asmstream == NULL)
d1443 2
d1449 2
d1704 2
d1710 2
d1724 2
d1947 2
d1962 2
d2067 2
d2231 2
d2432 2
d2935 2
d6718 2
d7523 2
d9493 2
d9500 2
d9580 2
d9587 2
d9897 2
d9963 2
d10121 5
d10519 1
a10519 1
  /* fprintf( asmstream, "adding push of reg %d (type %d)\n", reg, type ); */
d10630 4
d10635 2
a10636 2
      if (type == PUSH_DOUBLE)
	return 2;
d10638 5
a10642 1
	return 1;
d10674 3
d10687 3
d10718 3
d10772 1
a10772 1
      /* fprintf( asmstream, "forced flush of push of reg %d\n", reg ); */
d10830 1
a10830 1
	  /* fprintf( asmstream, "flushed push of reg %d because of clash\n", reg ); */	
d10925 2
d10930 1
a10930 1
/*    else fprintf( asmstream, "; could not swap %08x and %08x (prev r = %x, w = %x)(delayed r = %x, w = %x)\n",
d11043 2
d11202 2
d11211 1
d11216 1
d11221 1
d11230 1
d11281 2
d11327 3
a11329 1
	  
d11374 2
d11438 2
d11464 3
d11489 3
a11491 1
	  
d11520 3
d11551 3
d11661 2
d11728 2
d11746 2
d11774 2
d11810 2
d11845 2
d11853 2
d11910 3
d11936 3
d11957 2
d11972 2
d11991 3
d12007 2
d12013 1
a12013 1
		  
d12029 3
d12055 1
a12055 1
  if (asmstream != NULL)
d12068 2
d12217 1
a12217 1
	      if (asmstream != NULL && num_in_peep_() > 1)
d12220 1
d12222 1
d12224 1
d12226 1
d12230 1
a12230 1
	      peepf( "%d forward swaps left undone\n", peep_pending_swaps );
@


1.154
log
@fixed bug in move_register
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.153 1992/04/22 09:41:48 nickc Exp nickc $ */
d5928 2
a5929 2
  /* fprintf( asmstream, "num_args = %d, register masks: used = %x, var = %x, FP var = %x, args = %x\n",
	  num_args, usedmaskvec.map[ 0 ], mask, fmask, maskarg ); */
a10060 2
	  
	  setlabel( returnlab );
@


1.153
log
@fixed bug in can_swap
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.152 1992/04/21 15:04:59 nickc Exp nickc $ */
d245 6
d253 2
a254 1
 * print a message about peepholing */
d1171 3
d8642 1
a8642 1
	  
a11948 6
#ifndef __HELIOS
void IOdebug( char * format, ... )
{
  return;
}  
#endif
a12394 1

@


1.152
log
@unknown change
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.151 1992/04/16 14:05:43 nickc Exp nickc $ */
d3645 1
a3645 9
	  if (fits_in_8_bits_signed( offset ))
	    {
	      out_triadic_op( OP_ADDI3, dest, R_TMP1, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( R_TMP1 ),
			     alters2( dest, RR_ST ) );
	    }
	  else
	    {
	      integer_immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );
d3647 3
a3649 4
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			    examines2( dest, R_TMP1 ),
			    alters2( dest, RR_ST ) );
	    }
d4217 5
a4221 17
		      if (fits_in_8_bits_signed( offset ))
			{
			  out_triadic_op( OP_ADDI3, dest, R_TMP1, offset,
					 ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
					 examines1( R_TMP1 ),
					 alters2( dest, RR_ST ) );
			}
		      else
			{			  
			  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
					examines1( R_TMP1 ),
					alters2( R_TMP1, RR_ST ) );
			  
			  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
					examines2( dest, R_TMP1 ),
					alters2( dest, RR_ST ) );
			}
a4926 7
	  else if (fits_in_8_bits_signed( offset ))
	    {
	      out_triadic_op( OP_ADDI3, R_TMP1, R_ADDR1, offset,
			     ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( R_ADDR1 ),
			     alters2( R_TMP1, RR_ST ) );
	    }
a6262 2
  peepf( "exit: stack_offset = %d, stack_move = %d", stack_offset, stack_move );
  
d10326 3
a10328 1

d10348 12
d11463 1
a11463 1
   *	MPYI	3,  R2, R1
d11465 1
a11465 1
   *    MPYI	3,  R2, R1
d11469 1
a11469 1
   *	MPYI	3,  R1, R1
d11471 1
a11471 1
   *	MPYI	3,  R0, R1
@


1.151
log
@fixed bug in peepholer messages
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.150 1992/04/16 07:40:38 nickc Exp nickc $ */
d12438 1
a12438 1
  
a12510 2


@


1.150
log
@prevented generation of STIK op codes
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.149 1992/04/15 16:43:38 nickc Exp nickc $ */
d6287 6
d8467 1
a8467 1
	cc_msg( "GAP  " );
d8469 1
a8469 1
	cc_msg( "%3ld%c ", (long)mr, r3dead );
d9429 1
a9429 1
      shift_register( (op & J_UNSIGNED) ? FALSE : TRUE, r1r, r2r, m ); 
d11938 3
a11940 1
  fprintf( asmstream, "; peepholer: swapped " );
d11942 1
a11942 1
  decode_instruction( peep_buf[ a ].op_code, FALSE );
d11944 1
a11944 1
  fprintf( asmstream, " with " );
d11946 1
a11946 1
  decode_instruction( peep_buf[ b ].op_code, FALSE );
d11948 2
a11949 1
  fprintf( asmstream, " because: %s\n", reason );
d12104 10
a12113 5
	      fprintf( asmstream, "; could not swap op " );
	      decode_instruction( op_code, FALSE );
	      fprintf( asmstream, " with op " );
	      decode_instruction( prev, FALSE );
	      fprintf( asmstream, " this leaves %d forward swaps undone\n", peep_pending_swaps );
@


1.149
log
@fixed bug with using LAJ to obtain PC
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.148 1992/04/15 14:26:28 nickc Exp nickc $ */
d52 5
d5034 2
a5035 1
  
d5074 1
d6900 1
d6906 9
a6914 1

d6925 1
d6937 12
d6959 3
d6969 17
d7000 3
a7003 2
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */

d7007 8
d7016 6
a7021 2
      flush_peepholer( "end of repeat block" );
      
d11712 1
d11732 2
a11733 3

	  if (fits_in_5_bits_signed( val ) &&
	      val != -12 )		/* amazing hardware bug !!! */
d11753 1
@


1.148
log
@fixed bug in integer_immediate_op
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.147 1992/04/14 16:16:32 nickc Exp nickc $ */
d3683 2
a3684 1
      if ((saved_ivars & regbit( R_LR )) == 0)
d3755 2
a3756 1
      if ((saved_ivars & regbit( R_LR )) == 0)
d3802 2
a3803 1
      if ((saved_ivars & regbit( R_LR )) == 0)
d3844 2
a3845 1
      if ((saved_ivars & regbit( R_LR )) == 0)
d4056 2
a4057 1
	  if ((saved_ivars & regbit( R_LR )) == 0)
d4098 2
a4099 1
	  if ((saved_ivars & regbit( R_LR )) == 0)
d4288 2
a4289 1
  if ((saved_ivars & regbit( R_LR )) == 0)
d4331 2
a4332 1
  if ((saved_ivars & regbit( R_LR )) == 0)
d4773 1
a4773 3
	  if ((saved_ivars & regbit( R_LR )) == 0)
	    {
	      /* save the return address */
d4775 1
a4775 2
	      move_register( R_LR, R_ADDR1, FALSE );
	    }
d4805 1
a4805 1
	      move_register( R_LR, R_TMP1, FALSE );
d4827 1
a4827 3
	  if ((saved_ivars & regbit( R_LR )) == 0)
	    {
	      /* restore link register */
d4829 1
a4829 2
	      move_register( R_ADDR1, R_LR, FALSE );
	    }
d8691 1
d8711 2
a8712 1
	  if ((saved_ivars & regbit( R_LR )) == 0)
d8717 3
d8773 12
a8784 3
	  out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_ATMP, ((codep_of_call + codebase) >> 2) + 3,
			examines1( R_ATMP ),
			alters2( R_ATMP, RR_ST ) );
d8788 2
a8789 1
	  if ((saved_ivars & regbit( R_LR )) == 0)
@


1.147
log
@fixed bug in copy_memeory
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.146 1992/04/14 14:45:39 nickc Exp nickc $ */
d1474 33
a1506 1
	  load_integer( R_TMP1, value, FALSE );
d1508 2
a1509 2
	  out_triadic_op( OP_AND3, dest, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( R_TMP1, source ),
d1515 33
a1547 1
      load_integer( R_TMP1, value, FALSE );
d1549 2
a1550 2
      out_triadic_op( triadic_op, dest, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( R_TMP1, source ),
@


1.146
log
@fixed bug in copy_memory
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.145 1992/04/14 08:09:10 nickc Exp nickc $ */
d7190 1
a7190 1
	offset_in_R_ATMP = length + 2;
@


1.145
log
@fixed bug in peepholer
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.144 1992/04/13 15:47:54 nickc Exp nickc $ */
d3787 1
a3787 1
      bool		must_copy;
d6717 2
a6718 4
 * The list is terminated by a register of value -1.
 * If no free register can be found the last register
 * on the list is returned and 'must_restore' is set
 * to TRUE, (otheriwse it is set to FALSE).
d6723 1
a6723 1
		  bool *	must_restore,
a6725 2
  int32		tmp  = 0;
  RealRegister	last = 0;
d6729 1
d6743 1
a6743 1
  va_start( args, must_restore );
d6745 1
a6745 1
  while (tmp != -1)
d6747 3
a6749 3
      tmp = va_arg( args, int32 );

      if (tmp != -1)
d6751 1
a6751 1
	  last = real_register( tmp );
d6753 1
a6753 5
	  if ((map & regbit( last )) == 0)
	    {
	      /* succeded */
	  
	      *must_restore = FALSE;
d6755 2
a6756 1
	      /* let the front end know that we corrupt this register */
d6758 3
a6760 11
	      augment_RealRegSet( &regmaskvec, last );

	      /* tidy up */
	      
	      va_end( args );

	      /* finished */
	      
	      return last;
	    }
	}
d6763 1
a6763 1
  /* failed */
d6766 2
d6769 1
a6769 3
  *must_restore = TRUE;

  return last;
d6773 1
a6773 1

d6882 1
a6882 1
		   alters1( RR_RC ) );	/* This is to prevent load of RC being done in delayed region */
d6963 1
a6963 1
	  dest = get_free_register( &restore_ar, 0x08, 0x09, 0x0a, 0x0b, -1 );
d6965 1
a6965 1
	  if (restore_ar)
d6967 4
a7005 1
      bool		must_save;
d7015 1
a7015 1
      tmp = get_free_register( &must_save, 0x00, 0x01, 0x02, 0x03, 0x06, 0x07, -1 );
d7017 1
a7017 1
      if (must_save)
a7018 2
	  /* do not bother to use suggested temporary register */

d7075 1
a7075 1
      bool		must_save;
a7098 1
       * note placement of register 0 at end
d7101 1
a7101 1
      tmp = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x06, 0x07, 0x00, -1 );
d7104 4
a7107 1
      if (must_save && tmp != R_ZERO)
d7109 1
a7109 2
      if (must_save)
#endif  
d7111 3
d7131 1
d7147 1
a7147 1
		   alters1( RR_RC ) );	/* This is to prevent load of RC being done in delayed region */
d7176 5
d7183 1
a7183 7
#ifdef TARGET_R0_ALWAYS_ZERO
	  if (tmp == R_ZERO)
	    out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, tmp, 0,
			  examines0(), alters1( tmp ) );
	  else
#else
	    /* restore tmp register */
d7185 2
a7186 1
	    ipop( tmp );
a7187 1
	}
d7926 1
a7926 1
      tmp = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x1c, 0x1d, 0x1e, -1 );
d7930 1
a7930 1
      if (must_save)
d7932 2
d7936 2
a7939 6
	  else
	    {
	      tmp = R_LR;

	      must_save = FALSE;
	    }
d7942 1
a7942 1
      tmp = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x1e, -1 );
d7949 1
a7949 1
      if (must_save)
d7951 2
d7954 3
a7956 1
	    {
a7958 6
	  else
	    {
	      tmp = R_LR;

	      must_save = FALSE;
	    }
d8035 1
a8035 1
	  tmp = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x1c, 0x1d, 0x1e, -1 );
d8050 1
a8050 1
      if (must_save)
d8052 2
d8055 4
a8058 1
	    {
d8060 3
a8062 6
	    }
	  else
	    {
	      tmp = R_LR;

	      must_save = FALSE;
d8099 7
a8105 1
	dpop( tmp );
d9027 1
a9027 1
	  RealRegister	dest;
d9032 2
a9033 1
	  dest = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x1c, 0x1d, 0x1e, -1 );
d9036 1
a9036 1
	  if (must_save)
d9038 2
d9041 1
a9041 1
	      
d9044 7
a9050 7
		  dpush( dest );
		}
	      else
		{
		  dest = R_LR;

		  must_save = FALSE;
d9064 1
a9064 1
	  conditional_load_float( Q_AL, ADDR_MODE_INDIRECT, dest,
d9067 1
a9067 1
				 alters2( R_SP, dest ) );
d9071 1
a9071 1
	  conditional_load_float( Q_GE, ADDR_MODE_IMMEDIATE, dest, 0x8000,
d9073 1
a9073 1
				 alters1( dest ) );
d9077 2
a9078 2
	  out_diadic_op( OP_ADDF, ADDR_MODE_REGISTER, r1r, dest,
			examines2( r1r, dest ),
d9084 7
a9090 1
	    dpop( dest );
d10792 1
a10792 1

d10828 2
a10829 1
      
a10830 1
      peep_buf[ delayed ].type    = type;
@


1.144
log
@fixed bug in peepholer
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.143 1992/04/13 13:46:22 nickc Exp nickc $ */
d7745 15
a7759 4
      out_triadic_op( OP_AND3, R_TMP1, addr, half_word_op ? 0x2 : 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( addr ),
		     alters2( R_TMP1, RR_ST ) );

a10169 1
static int				num_in_peep	= 0;		/* number of instrs in peepholer  */
d10171 1
a10831 2
      num_in_peep -= 2;
      
a11918 2
  ++num_in_peep;
  
d11931 1
a11931 1
      if (num_in_peep > 1)
d11936 1
a11936 1
	  if (num_in_peep > 1 			&& /* if there are instructions to swap */
d11968 1
a11968 1
	       num_in_peep > 1				&&	/* there is a previous op to check	*/
a12125 2
      --num_in_peep;
      
d12233 1
a12233 1
  if (num_in_peep > 0)
d12255 1
a12255 1
  if (--num_in_peep < 0 || peep_start == peep_end)
a12258 2
      num_in_peep = 0;
      
@


1.143
log
@fixed bug in forward instruction swapping
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.142 1992/04/13 10:44:57 nickc Exp nickc $ */
d11637 5
a11641 5
		(OP_LDI_LDI << 25)                     |
		  (prev_op & (B_111 << 16)) << (22 - 16) |
		    (curr_op & (B_111 << 16)) << (19 - 16) |
		      (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			(prev_op & (0xFF  <<  8)) >> ( 8 -  0);
d11660 5
a11664 5
		    (OP_LDI_STI << 25)                     |
		      (prev_op & (B_111 << 16)) << (22 - 16) |
			(curr_op & (B_111 << 16)) << (16 - 16) |
			  (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			    (prev_op & (0xFF  <<  8)) >> ( 8 -  0);
d11698 2
a11699 1
		      *pcurr_op = build_op( OP_LDI, ADDR_MODE_REGISTER, dest_of( curr_op ), dest_of( prev_op ) );
d11708 5
a11712 5
		(OP_LDI_STI << 25)                     |
		  (curr_op & (B_111 << 16)) << (22 - 16) |
		    (prev_op & (B_111 << 16)) << (16 - 16) |
		      (prev_op & (0xFF  <<  8)) << ( 8 -  8) |
			(curr_op & (0xFF  <<  8)) >> ( 8 -  0);
d11722 1
d11741 5
a11745 5
		(OP_STI_STI << 25)                     |
		  (prev_op & (B_111 << 16)) << (22 - 16) |
		    (curr_op & (B_111 << 16)) << (16 - 16) |
		      (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			(prev_op & (0xFF  <<  8)) >> ( 8 -  0);
d11755 1
d11788 7
a11794 1
  
a11896 2
  ++num_in_peep;
  
d11910 2
d12118 2
d12227 3
@


1.142
log
@changed use of RPTS to be RPTBD
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.141 1992/04/10 14:47:50 nickc Exp nickc $ */
d11920 4
a11923 2
	  if (num_in_peep > 1 &&
	      can_swap( back1, back2, FALSE ) )
@


1.141
log
@fixed bug in converting delayed branches into ordinary branches
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.140 1992/04/09 16:28:48 nickc Exp nickc $ */
d6795 1
a6795 1
	     int32		length,			/* number of bytes to clear, guaranteed to be word multiple */
d6875 1
a6875 1
  else if (fits_in_16_bits_unsigned( length - 1 ))
d6877 6
a6882 1
      /* use repeat single instruction mode, loaded from immediate */
d6884 2
a6888 22
  
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC, length - 1,
		    examines0(),
		    alters1( RR_RC ) );
      
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
		    alters1( dst ) );

      if (dst == R_ATMP)
	{
	  register_in_R_ATMP = start;
	  offset_in_R_ATMP   = length;
	}
    }
  else
    {
      /* use repeat single instruction mode, loaded from register */
d6890 1
a6890 7
      /* convert destinttaion pointer to word offset */

      convert_to_word_address( start, dst );
  
      /* pre-load RC with value - this saves using another temporary */
      
      load_integer( RR_RC, length - 1, FALSE );
d6892 5
a6896 1
       /* load RC from itself ! */
d6898 1
a6898 5
      out_diadic_op( OP_RPTS, ADDR_MODE_REGISTER, RR_RC, RR_RC,
		    examines1( RR_RC ),
		    alters1( RR_RC ) );

      /* repeat this instruction 'length' times */
d6901 1
a6901 1
      
d6906 2
d7089 4
d7094 1
d7096 10
a7105 1
      /* convert to word pointers */
d7130 1
a7130 1
	   * as all three are used by the RPTS instruction below
d7149 1
a7149 10
      length = length / sizeof_int - 2;
      
      /*
       * the -2 is because we have already loaded one word, and the RPTS
       * instruction takes 'number of itterations - 1' as its count
       */
      
      if (fits_in_16_bits_unsigned( length ))
	{
	  /* use repeat single instruction mode, loaded from immediate */
d7151 5
a7155 7
	  out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC, length,
			examines0(),
			alters1( RR_RC ) );
	}
      else
	{
	  /* load repeat count with length  */
d7157 1
a7157 3
	  load_integer( RR_RC, length, FALSE );

	  /* XXX load RC from itself ! - WILL THIS WORK ? */
a7158 5
	  out_diadic_op( OP_RPTS, ADDR_MODE_REGISTER, RR_RC, RR_RC,
			examines1( RR_RC ),
			alters1( RR_RC ) );
	}

a7199 4
      
      /* restore length to original value, so that it is correct for test below */
	
      length = (length + 2) * sizeof_int;      
@


1.140
log
@oops, fixed bug introduced in previous delta
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.139 1992/04/09 13:46:16 nickc Exp nickc $ */
d8343 14
a8356 1
      cc_msg( "%ld%c %ld%c %ld%c\n", (long)r1r, r1dead, (long)r2r, r2dead, (long)mr,  r3dead );
d10744 2
a10745 1
      
a10764 3
	      int32	off;
	      
	      
a10780 3
	  int32		off;	
	  

d10805 2
a10806 2
      peep_buf[ delayed ].op_code = op;
	  
d10809 27
a10835 4
	case OUT_DELLABREF:		type = OUT_LABREF;  break;
	case OUT_DELSYMREF:		type = OUT_SYMREF;  break;
	case OUT_DELSYMXREF:		type = OUT_SYMXREF; break;
	case OUT_DELAYED:		type = OUT_INSTR;   break;
d10841 2
a10842 1
      peep_buf[ delayed ].type = type;
@


1.139
log
@fixed bug in routine entry
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.138 1992/04/08 17:19:10 nickc Exp nickc $ */
d1333 12
d1378 1
a1378 4
      if (r == R_TMP3)
	move_register( R_TMP2, RR_ST, FALSE );
      else
	move_register( R_TMP3, RR_ST, FALSE );
@


1.138
log
@fixed bug in conditional loading of integers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.137 1992/04/08 15:48:55 nickc Exp nickc $ */
a1332 18
  if (must_save_st)
    {
      /*
       * There is no way to load this value using immediate ops
       * without affecting the contents of the status register.
       * Since this routine can be called from anywhere we may
       * not have a temporary register available, but we assume
       * that the third temporary is free ....
       */

      /* save ST */

      if (r == R_TMP3)
	move_register( RR_ST, R_TMP2, FALSE );
      else
	move_register( RR_ST, R_TMP3, FALSE );	
    }
      
d5809 2
a5810 1
      )
@


1.137
log
@fixed bug in conditional_branch_to()
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.136 1992/04/07 15:42:18 nickc Exp nickc $ */
d1345 4
a1348 1
      move_register( RR_ST, R_TMP3, FALSE );
d1384 4
a1387 1
      move_register( R_TMP3, RR_ST, FALSE );
d9249 1
a9249 1
	      load_integer( R_TMP1, m, FALSE );
@


1.136
log
@removed a few more writes to RR_ST
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/gen.c,v 1.135 1992/04/07 14:33:49 nickc Exp nickc $ */
d3061 4
@


1.135
log
@added forward pipeline conflict avoidance
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.134 1992/04/03 15:36:07 nickc Exp nickc $ */
d3764 1
a3764 1
		    alters2( R_TMP2, RR_ST ) );
d4016 1
a4016 1
			alters2( RR_ST, R_TMP2 ) );
d4583 1
a4583 1
			alters2( tmp, RR_ST ) );
d4855 1
a4855 1
			alters2( R_TMP1, RR_ST ) );
d4866 4
d4873 25
a4897 4
	    syserr( "back end: cannot initialise large data offset" );
	  
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
			examines1( R_TMP1 ),
a4899 8
		    
      /*
       * and add R_ADDR1 to R_TMP1
       */

      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_TMP1, R_ADDR1,
		    examines2( R_ADDR1, R_TMP1 ),
		    alters2( R_TMP1, RR_ST ) );
@


1.134
log
@removed (nearly all) warning messages produced by self-compilation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.133 1992/04/03 14:32:58 nickc Exp nickc $ */
d127 1
d3558 1
a3558 1
			alters2( R_TMP1, RR_ST ) );
a3568 5
      if (offset)
	{
	  integer_immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );
	}
      
d3573 23
a3595 3
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
		    examines2( dest, R_TMP1 ),
		    alters2( dest, RR_ST ) );
d4142 1
a4142 1
				alters2( R_TMP1, RR_ST ) );
d4144 4
d4150 17
a4166 3
		      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
				    examines1( R_TMP1 ),
				    alters2( R_TMP1, RR_ST ) );
d4168 6
d4187 4
a4191 8
	      
	      /*
	       * and add R_TMP1 into dest
	       */
	      
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			    examines2( dest, R_TMP1 ),
			    alters2( dest, RR_ST ) );
d10153 2
a10155 2

#define num_in_peep_()			(peep_end - peep_start + (peep_end < peep_start ? PEEP_BUF_SIZE : 0))
d10797 2
d10830 2
a10831 2
	  if (dest_of( other_op ) - hardware_register( RR_AR0 ) == reg ||
	      indirect_addr_reg( other_op )                     == reg  )
d11022 3
a11024 3
	  indirect_addr_reg( prev_op ) == (dest - hardware_register( RR_AR0 )) && /* same register affected */
	  ((prev_op >> 11) & 0x1f) == INDIRECT_POST_INCR                   && /* op was *ARx++() */
	  fits_in_8_bits_unsigned( amount ))				      /* new addition total fits */
d11333 1
a11333 1
	      if (((src2 & 0x7) + hardware_register( RR_AR0 )) == dest)
d11338 1
a11338 1
	      if (((src1 & 0x7) + 0x08) == dest)
d11343 2
a11344 2
	      if (((src1 & 0x7) + 0x08) == dest ||
		  ((src2 & 0x7) + 0x08) == dest)
d11589 1
a11589 4
  if (prev_load + prev_store + curr_load + curr_store < 2)
    return FALSE;

  if (prev_load)
d11591 1
a11591 1
      if (curr_load)
d11593 1
a11593 5
	  /* previous and current LDI */
	  
	  /* check that the destination of the loads */
      
	  if (((prev_op >> 16) & 0x1F) == ((curr_op >> 16) & 0x1F))
d11595 30
a11624 8
	      peepf( "WARNING: two successive loads with the same destination" );

	      /* ignore first load */
	  
	      peep_buf[ prev ].op_code = curr_op;
	      peep_buf[ prev ].reads   = reads;
	      peep_buf[ prev ].writes  = writes;
	  
d11627 24
a11650 15
      
	  peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                             (OP_LDI_LDI << 25)                     |
	                             (prev_op & (B_111 << 16)) << (22 - 16) |
		                     (curr_op & (B_111 << 16)) << (19 - 16) |
		                     (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
		                     (prev_op & (0xFF  <<  8)) >> ( 8 -  0);

	  peep_buf[ prev ].reads  |= reads;
	  peep_buf[ prev ].writes |= writes;
	  peep_buf[ prev ].writes &= ~regbit( RR_ST );
	  
	  peepf( "transformed LDI, LDI into LDI || LDI" );
      
	  return TRUE;
d11652 1
a11652 1
      else
d11654 1
a11654 5
	  /* previous LDI, current STI */
	  
	  /* check that the destination of the load is not the source of the store */

	  if (((prev_op >> 16) & 0x1F) != ((curr_op >> 16) & 0x1F))
d11656 26
d11683 6
a11688 6
		                         (OP_LDI_STI << 25)                     |
		                         (prev_op & (B_111 << 16)) << (22 - 16) |
		                         (curr_op & (B_111 << 16)) << (16 - 16) |
		                         (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
			                 (prev_op & (0xFF  <<  8)) >> ( 8 -  0);

d11693 2
a11694 2
	      peepf( "transformed LDI, STI into LDI || STI" );
      
d11697 1
a11697 9
	}
    }
  else /* prev op is STI */
    {
      if (curr_load)
	{
	  /* previous STI, current LDI */
	  
	  if (source_of( prev_op ) == source_of( curr_op ))
d11699 3
a11701 3
	      /* weird - a store followed by a load from the same place ! */

	      if (dest_of( prev_op ) == dest_of( curr_op ))
d11703 5
a11707 7
		  peepf( "eliminated register load" );

		  return TRUE;
		}
	      else
		{
		  /* transform load into register move */
d11709 1
a11709 5
		  *preads   = regbit( dest_of( prev_op ) );
		  *pwrites  = regbit( dest_of( curr_op ) ) | regbit( RR_ST );
		  *pcurr_op = build_op( OP_LDI, ADDR_MODE_REGISTER, dest_of( curr_op ), dest_of( prev_op ) );

		  peepf( "transformed memory access into register transfer" );
d11711 1
a11711 1
		  return FALSE;
d11713 15
d11729 2
a11730 7
	  
	  peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                             (OP_LDI_STI << 25)                     |
	                             (curr_op & (B_111 << 16)) << (22 - 16) |
	                             (prev_op & (B_111 << 16)) << (16 - 16) |
	                             (prev_op & (0xFF  <<  8)) << ( 8 -  8) |
		                     (curr_op & (0xFF  <<  8)) >> ( 8 -  0);
d11732 12
a11743 11
	  peep_buf[ prev ].reads  |= reads;
	  peep_buf[ prev ].writes |= writes;
	  peep_buf[ prev ].writes &= ~regbit( RR_ST );
	  
	  peepf( "transformed STI, LDI into LDI || STI" );

	  return TRUE;
	}
      else
	{
	  /* previous and current STI */
d11745 2
a11746 3
	  if (source_of( prev_op ) == source_of( curr_op ))
	    {
	      /* weird two stores to the same place ! */
d11748 1
a11748 1
	      peepf( "eliminating duplicate store!" );
d11750 1
a11750 3
	      /* eliminate the first store */
	      
	      SWAP_OPS;
d11752 1
a11752 13
	      return TRUE;
	    }
	  
	  peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                             (OP_STI_STI << 25)                     |
	                             (prev_op & (B_111 << 16)) << (22 - 16) |
	                             (curr_op & (B_111 << 16)) << (16 - 16) |
	                             (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
		                     (prev_op & (0xFF  <<  8)) >> ( 8 -  0);

	  peep_buf[ prev ].reads  |= reads;
	  peep_buf[ prev ].writes |= writes;
	  peep_buf[ prev ].writes &= ~regbit( RR_ST );
d11754 1
a11754 5
	  peepf( "transformed STI, STI into STI || STI" );
      
	  return TRUE;
	}
    }
d11756 3
a11758 1
   return FALSE;
d11760 1
a11760 1
} /* combine_instrs */
d11762 1
a11762 1
  
d11863 2
d11882 3
a11884 9
  
  if (
      !in_stubs                                         &&	/* do not muck up stub generation        */
      !no_peepholing                            	&&	/* if we can peephole, and the latest op */
      is_normal( op_code )                      	&&	/* is diadic or triadic 		 */
      dest_of( op_code ) == hardware_register( R_ATMP ) &&	/* and its destination is R_ATMP 	 */
      !is_op( op_code, OP_STI  )                	&&	/* and it is not a store                 */
      !is_op( op_code, OP_STIK )                	&&	/* of any kind                           */
      !is_op( op_code, OP_STF  )                         )
d11886 57
a11942 1
      (void) peep_shift_back( 2 );
d12131 1
a12131 1
	  peep_data	tmp = peep_buf[ last ];
d12133 1
a12133 1
	  /* swap the two instructions */
a12134 13
	  peep_buf[ last ] = peep_buf[ prev ];
	  peep_buf[ prev ] = tmp;

	  fprintf( asmstream, "swapped " );

	  decode_instruction( peep_buf[ prev ].op_code, FALSE );

	  fprintf( asmstream, " with " );

	  decode_instruction( peep_buf[ last ].op_code, FALSE );

	  fprintf( asmstream, "\n" );

d12176 1
a12176 1
      syserr( "back end: peepholer: attempting to flush peepholer whilst a cross reference is still pending" );
d12181 1
a12181 1
      syserr( "back end: peepholer: attempting to flush peepholer whilst a forward reference is still pending" );
d12189 1
a12189 1
  /* fprintf( asmstream, "; flushed: %s (after %dth instruction in function)\n", reason, codep / 4 + 1 ); */
d12210 1
a12210 1
  if (peep_start == peep_end)
d12212 1
a12212 1
      cc_warn( "peepholer: attempting to flush EMPTY peepholer!" );
d12214 2
d12301 1
a12301 3
  ++peep_start;

  peep_start &= (PEEP_BUF_SIZE - 1);
@


1.133
log
@debugger support finalised
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.132 1992/04/02 16:03:26 nickc Exp nickc $ */
d226 5
a1728 3
  int32		disp;
  

d5786 1
d5788 1
a5788 1

d8103 1
a8103 1
    cc_msg( "debugger: generating _notify_command of: %s at line %d\n", filename, linenumber );
d8240 1
a8240 1
  int			dead;
d11498 1
a11498 1
	  int	val;
d12022 1
a12022 1
	  fprintf( asmstream, "swapped %" );
@


1.132
log
@removed debugging
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.131 1992/04/02 12:14:28 nickc Exp nickc $ */
d98 2
a99 1
   */
d435 1
a435 1
static int32
d6050 1
a6050 1
  if (usrdbg(DBG_ANY))
d6204 1
a6204 1
  if (usrdbg(DBG_ANY))
@


1.131
log
@removed spurious error message
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.130 1992/04/02 11:45:51 nickc Exp nickc $ */
d10033 1
a10033 1
      
@


1.130
log
@improved peepholer messaging
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.129 1992/04/01 17:11:43 nickc Exp nickc $ */
d266 2
d5959 1
a5959 1
	  /* place number of words we require in R_TMP2 */
a5963 4
	    }
	  else
	    {
	      syserr( "back end: cannot load required stack size (%d)\n", require );
@


1.129
log
@fixed bug in call()
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.128 1992/03/31 17:45:10 nickc Exp nickc $ */
d233 42
d1282 3
a1284 3
  if (fits_in_16_bits_unsigned( n ) &&
      hardware_register( r ) == 0x10 /* DP */ &&
      var_cc_private_flags == 0)	/* simulator cannot cope with LDPK */
d1417 1
a1417 1
	      fprintf( asmstream, "; peepholer: transformed addition into move" );
d1421 1
a1421 1
	      fprintf( asmstream, "; peepholer: eliminating op %lx with value 0", diadic_op );
d1610 1
a1610 1
		  fprintf( asmstream, "; peepholer: transformed FP addition of 0.0 into move" );
d1614 1
a1614 1
		  fprintf( asmstream, "; peepholer: eliminating op %lx with value 0", op );
d1626 1
a1626 1
	      fprintf( asmstream, "; peepholer: transformed FP multiplication of 0.0 into load" );
d1849 1
a1849 1
	      fprintf( asmstream, "; peepholer: eliminated load and add to temporary address register\n" );
d1863 1
a1863 1
		  fprintf( asmstream, "; peepholer: eliminated load to temporary address register\n" );
d1966 1
a1966 1
		  fprintf( asmstream, "; peepholer: eliminated load to temporary address register\n" );
d2128 1
a2128 1
		  fprintf( asmstream, "; peepholer: eliminated load to temporary address register\n" );
d2327 1
a2327 1
		  fprintf( asmstream, "; peepholer: eliminated load to temporary address register\n" );
d2827 1
a2827 1
	      fprintf( asmstream, "; peepholer: eliminated compare!\n" );
d6575 1
a6575 1
	      fprintf( asmstream, "; peepholer: converted branch to next instruction into NOP\n" );
d7359 1
a7359 1
		      fprintf( asmstream, "; peepholer: eliminated load to temporary address register\n" );
d8523 1
a8523 1
	      fprintf( stderr, "Unused label L%ld\n", lab_name_( l ) & 0x7fffffffU );
d9274 1
a9274 1
	      fprintf( asmstream, "; peepholer: eliminated unnecessary integer load\n" );
d9280 1
a9280 1
	      fprintf( asmstream, "; peepholer: eliminated unnecessary integer load\n" );
d9357 1
a9357 1
	      fprintf( asmstream, "; peepholer: eliminated unnecessary integer load\n" );
d9363 1
a9363 1
	      fprintf( asmstream, "; peepholer: eliminated unnecessary integer load\n" );
d9671 1
a9671 1
	  fprintf( asmstream, "; peepholer: eliminated register transfer\n" );
d9735 1
a9735 1
	  fprintf( asmstream, "; peepholer: swapped order of register transfer and store\n" );
d10383 1
a10383 1
      fprintf( asmstream, "; peepholer: eliminated push/pop pair\n" );
d10418 1
a10418 1
	  fprintf( asmstream, "; peepholer: transformed integer push/pop pair\n" );
d10429 1
a10429 1
	      fprintf( asmstream, "; peepholer: transformed float push/pop pair\n" );
d10457 1
a10457 1
	      fprintf( asmstream, "; peepholer: transformed double push/pop pair\n" );
d10661 1
a10661 1
 	  fprintf( asmstream, "; peepholer: eliminated a NOP\n" );
d10709 1
a10709 1
	  fprintf( asmstream, "; peepholer: converted a delayed conditional branch into undelayed\n" );
d10733 1
a10733 1
	  fprintf( asmstream, "; peepholer: converted a delayed unconditional branch into undelayed\n" );
d10915 1
a10915 1
			  fprintf( asmstream, "; peepholer: combined multiple additions\n" );
d10922 1
a10922 1
		  fprintf( asmstream, "; peepholer: eliminated multiple identical LDIs\n" );
d10926 1
a10926 1
		  fprintf( asmstream, "; peepholer: eliminated multiple identical LDAs\n" );
d10930 1
a10930 1
		  fprintf( asmstream, "; peepholer: eliminated multiple identical LDFs\n" );
d10938 1
a10938 1
		  fprintf( asmstream, "; peepholer: eliminated multiple identical ANDs\n" );
d10942 1
a10942 2
		  fprintf( asmstream, "; peepholer: failed to combine multiple indentical op codes (%lx)\n",
			  curr_op );
d10988 1
a10988 1
	  fprintf( asmstream, "; peepholer: transformed indirect addition\n" );
d11032 1
a11032 1
		      fprintf( asmstream, "; peepholer: merged load and diadic op into diadic op\n" );
d11077 1
a11077 1
		  fprintf( asmstream, "; peepholer: merged load and register op into triadic op\n" );
d11139 1
a11139 1
		  fprintf( asmstream, "; peepholer: merged load and immediate op into triadic op\n" );
d11163 1
a11163 1
	      fprintf( asmstream, "; peepholer: transformed and swapped register store\n" );
d11185 1
a11185 1
	      fprintf( asmstream, "; peepholer: eliminated unnecessary register load\n" );
d11214 1
a11214 1
	      fprintf( asmstream, "; peepholer: swapped and transformed register loads\n" );
d11242 1
a11242 1
	  fprintf( asmstream, "; peepholer: transformed and swapped register diadic\n" );
d11348 1
a11348 1
	  fprintf( asmstream, "; peepholer: eliminated unnecessary register load before triadic\n" );
d11413 3
a11415 1
	  fprintf( asmstream, "; peepholer: removed unnecessary register load after monadic\n" );
d11429 3
a11431 1
	  fprintf( asmstream, "; peepholer: removed unnecessary register load after diadic\n" );
d11455 1
a11455 1
      fprintf( asmstream, "; peepholer: eliminated unnecessary indirect load\n" );
d11490 1
a11490 1
	  fprintf( asmstream, "; peepholer: transformed load register into load immeadiate\n" );
d11523 1
a11523 1
		  fprintf( asmstream, "; peepholer: eliminated register load and transformed register store\n" );
d11529 1
a11529 1
		  fprintf( asmstream, "; peepholer: transformed store register into store immeadiate\n" );
d11556 1
a11556 1
	  /* LDI || LDI */
d11562 1
a11562 1
	      fprintf( asmstream, "; peepholer: WARNING: two successive loads with the same destination\n" );
d11584 1
a11584 1
	  fprintf( asmstream, "; peepholer: transformed LDI, LDI into LDI || LDI\n" );
d11590 1
a11590 1
	  /* LDI || STI */
d11607 1
a11607 1
	      fprintf( asmstream, "; peepholer: transformed LDI, STI into LDI || STI\n" );
d11617 25
a11641 1
	  /* STI || LDI */
d11654 1
a11654 1
	  fprintf( asmstream, "; peepholer: transformed STI, LDI into LDI || STI\n" );
d11660 14
a11673 1
	  /* STI || STI */
d11686 1
a11686 1
	  fprintf( asmstream, "; peepholer: transformed STI, STI into STI || STI\n" );
d12020 1
a12020 1
	  fprintf( asmstream, "; peepholer: swapped " );
d12107 1
a12107 1
      fprintf( stderr, "peepholer: attempting to flush EMPTY peepholer!\n" );
@


1.128
log
@oops, fixed typo in previous delta
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.127 1992/03/31 17:43:35 nickc Exp nickc $ */
d4982 7
d9989 2
@


1.127
log
@improved debugger support
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.126 1992/03/31 10:27:41 nickc Exp nickc $ */
d4617 1
a4617 1
	  if ((saved_vars & regbit( R_LR )) == 0)
@


1.126
log
@added support for Helios Debugger
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.125 1992/03/31 09:21:35 nickc Exp nickc $ */
d185 1
a3571 2
      
      /* adjust symbol offset to be relative to next instruction */
d3577 4
d3588 2
d3591 1
a3591 3
      /* prevent this NOP from being peepholed */
  
      flush_peepholer( "LAJ bug 3" );
d3602 2
a3625 8
      /*
       * we have now had three instructions after the LAJ
       * flush the peepholer to prevent another branch or
       * LAJ from being shifted back into these instructions
       */

      flush_peepholer( "LAJ protection" );

d3682 2
a3712 8
      /*
       * we have now had three instructions after the LAJ
       * flush the peepholer to prevent another branch or
       * LAJ from being shifted back into these instructions
       */

      flush_peepholer( "LAJ protection 2" );

d3934 3
a3936 1
      
a3964 8
	  /*
	   * we have now had three instructions after the LAJ
	   * flush the peepholer to prevent another branch or
	   * LAJ from being shifted back into these instructions
	   */

	  flush_peepholer( "LAJ protection 3" );

d4145 2
a4175 8
  /*
   * we have now had three instructions after the LAJ
   * flush the peepholer to prevent another branch or
   * LAJ from being shifted back into these instructions
   */
  
  flush_peepholer( "LAJ protection 4" );

d4300 3
a4302 1
      
d4305 1
a4305 1
   * silicon, whereby R_LR is occiaisionally not set by the
d4617 3
a4619 1
	  /* save the return address */
d4621 2
a4622 1
	  move_register( R_LR, R_ADDR1, FALSE );
d4627 1
a4627 1
      
d4632 2
d4649 1
a4649 1
	  
d4652 1
a4652 1
	  move_register( R_LR, R_TMP1, FALSE );
d4674 3
a4676 9
	  /*
	   * we have now had three instructions after the LAJ
	   * flush the peepholer to prevent another branch or
	   * LAJ from being shifted back into these instructions
	   */

	  flush_peepholer( "LAJ protection 5" );
      
	  /* restore link register */
d4678 2
a4679 1
	  move_register( R_ADDR1, R_LR, FALSE );
d5181 1
a5181 1
    cc_msg( "debugger: generating enter notify for: %s\n", symname_( current_proc ) );
d5207 2
a5231 8
  /*
   * we have now had three instructions after the LAJ
   * flush the peepholer to prevent another branch or
   * LAJ from being shifted back into these instructions
   */
  
  flush_peepholer( "LAJ protection 10" );

a5650 14
static int32
count_bits( signed long mask )
{
  int32	count = 0;


  while (mask)
    {
      ++count;

      mask = mask & ~(mask & -mask);
    }

  return count;
a5651 2
} /* count_bits */

d5852 1
a5852 1
      already_placed = count_bits( maskarg ) + (saved_frame ? 1 : 0);
d5861 1
a5861 1
      require = greatest_stackdepth / sizeof_int + count_bits( mask ) + count_bits( fmask ) * 2;
d5914 4
a6045 2
  proc_label = nextlabel();

d6055 2
a6079 8
  /*
   * we have now had three instructions after the LAJ
   * flush the peepholer to prevent another branch or
   * LAJ from being shifted back into these instructions
   */
  
  flush_peepholer( "LAJ protection 10" );

d6478 5
d8045 1
a8045 1
  extern LabelNumber *	filenamelabel( char * );
d8052 1
a8052 2
    cc_msg( "debugger: generating _notify_command at line %d in file %s\n",
	   linenumber, filename );
d8058 4
a8061 2
  Ireg_mask = regbit( R_A1  + NARGREGS    ) - regbit( R_A1  ) | regbit( R_T1  + NTEMPREGS    ) - regbit( R_T1 ) ;
  Freg_mask = regbit( R_FA1 + NFLTARGREGS ) - regbit( R_FA1 ) | regbit( R_FT1 + NFLTTEMPREGS ) - regbit( R_FT1 );
d8080 2
a8081 2
  label = filenamelabel( filename );
  
d8089 1
a8089 1

d8092 4
d8102 7
a8108 2
  
  peep_fref( label, LABREF_LIT16 ); 
d8110 10
a8119 3
  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_A1 + 1, -3,
		examines0(),
		alters2( R_A1 + 1, RR_ST ) );
d8122 1
a8122 1
  
d8126 1
a8126 1

d8128 1
a8128 1

a8130 8
  /*
   * we have now had three instructions after the LAJ
   * flush the peepholer to prevent another branch or
   * LAJ from being shifted back into these instructions
   */
  
  flush_peepholer( "LAJ protection 11" );

d8155 1
a8155 1
} /* do_notifty_leave */
d8563 2
d10608 1
a10608 1
	  peep_buf[ delayed ].reads |= regbit( RR_PC );	  /* ensure that the NOP does get swapped again */
d11634 7
@


1.125
log
@improved non word loads
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.124 1992/03/27 17:27:19 nickc Exp nickc $ */
d8077 114
d10011 2
a10012 2
      
      debugger_command( (void *)vr1.p, vr2.str, m, codebase + codep );
a10016 4
      flush_peepholer( "J_INFOBODY" );
      
      debugger_command( NULL, NULL, 0, 0 /* codebase + codep */ );
      
a10019 4
      flush_peepholer( "J_INFOSCOPE" );
      
      debugger_command( NULL, NULL, 0, codebase + codep );
      
@


1.124
log
@added code to support "compiling for simulator" pragma
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.123 1992/03/27 15:33:49 nickc Exp nickc $ */
a222 1
extern LabelNumber *	request_proc_stub( Symstr * name, int32 stack_used );
d426 1
a426 1
    syserr( "baxck end: hardware_register: trying to evaluate illegal register 0x%x", r );
d688 1
a688 1
		  syserr( "back end: out_triadic_op: illegal indirect/indirect triadic addressing\n" );
d704 1
a704 1
	      if ((source2 & 0xff) != 1)
d706 10
a715 1
		  syserr( "back end: out_triadic_op: illegal displacement in indirect triadic addressing\n" );
d740 1
a740 1
		  syserr( "back end: out_triadic_op: immediate value too large for indirect addressing\n" );
d747 1
a747 1
		  syserr( "back end: out_triadic_op: immediate value too large for indirect addressing\n" );
d760 1
a760 1
	  syserr( "back end: out_triadic_op: unknown kind of triadic addressing %d\n", source2_type );
d769 10
a778 1
	  if ((source1 & 0xff) != 1)
d780 1
a780 1
	      syserr( "back end: out_triadic_op: illegal displacement for indirect/register addressing\n" );
d805 1
a805 1
		  syserr( "back end: out_triadic_op: displacement out of range for indirect/indirect\n" );
d822 24
a845 2
	      if ((source1 & 0xff) != 1 ||
		  (source2 & 0xff) != 1  )
d847 1
a847 1
		  syserr( "back end: out_triadic_op: illegal displacements for indirect/indirect\n" );
d868 1
a868 1
	      syserr( "back end: out_triadic_op: illegal indirect addressing mode\n" );
d875 1
a875 1
	      syserr( "back end: out_triadic_op: displacement out of range\n" );
d897 1
a897 1
	  syserr( "back end: out_triadic_op: unknown kind of triadic addressing %d\n", source2_type );
d5193 1
a5193 3
do_notify_entry(
		Symstr *	name,
		int32 		stack_used )
d5195 3
a5197 1
  LabelNumber *	label;
d5199 2
d5202 2
d5209 1
a5209 1
  /* second argument is the frame pointer */
d5213 1
a5213 1
  /* first argument is the address of the Proc & ProcInfo structures */
d5215 1
a5215 1
  label = request_proc_stub( name, stack_used );
d5233 1
a5233 1
  peep_fref( label, LABREF_LIT16 ); 
d5235 1
a5235 1
  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_A1, 0,
d5747 5
a5751 1
  if (procflags & BLKCALL)
d6041 1
a6041 1
      do_notify_entry( NULL, greatest_stackdepth );
d6050 91
d6200 7
d7586 1
a7586 24
	   * load word into R_TMP2
	   */
      
	  if (absolute)
	    {
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_REL, addr, 0 ),
			    examines1( addr ),
			    alters2( R_TMP2, RR_ST ) );
	    }
	  else
	    {
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, addr, 0 ),
			    examines2( addr, RR_IR0 ),
			    alters2( R_TMP2, RR_ST ) );
	    }
      
	  /*
	   *    addr    - free
	   *    operand - free
	   *    R_TMP1  - inverted bit position (16 or 0) or (24, 16, 8 or 0)
	   *    R_TMP2  - word at destination
	   *    R_TMP3  - free
	   *
	   * shift source half-word up into R_TMP2
d7589 12
a7600 3
	  out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, R_TMP2, R_TMP1,
			examines1( R_TMP1 ),
			alters2( R_TMP2, RR_ST ) );
d7642 1
a7642 24
	   * load word into R_TMP2
	   */
      
	  if (absolute)
	    {
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_REL, addr, 0 ),
			    examines1( addr ),
			    alters2( R_TMP2, RR_ST ) );
	    }
	  else
	    {
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, addr, 0 ),
			    examines2( addr, RR_IR0 ),
			    alters2( R_TMP2, RR_ST ) );
	    }
      
	  /*
	   *    addr    - free
	   *    operand - free
	   *    R_TMP1  - negate bit position (0 or -16) or (0, -8, -16 or -24)
	   *    R_TMP2  - word at destination
	   *    R_TMP3  - free
	   *
	   * shift word to correct source alignment and place in operand
d7645 11
a7655 2
	  out_triadic_op( OP_LSH3, operand, R_TMP2, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( R_TMP2, R_TMP1 ),
d7750 4
a7753 8
      if (half_word_op)
	out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFFFF,
		      examines1( R_TMP1 ),
		      alters2( R_TMP1, RR_ST ) );
      else
	out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFF,
		      examines1( R_TMP1 ),
		      alters2( R_TMP1, RR_ST ) );
d7777 1
a7777 1
       * get word at destination into R_TMP2
d7780 12
a7791 12
      if (absolute)
	{
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_REL, addr, 0 ),
			examines1( addr ),
			alters2( R_TMP2, RR_ST ) );
	}
      else
	{
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, addr, 0 ),
			examines2( addr, RR_IR0 ),
			alters2( R_TMP2, RR_ST ) );
	}
d7797 2
a7798 2
       *              byte mask (0x000000FF, 0x0000FF00, 0x00FF0000 or 0xFF000000)
       *    R_TMP2  - word at destination
d7801 1
a7801 1
       * mask out unwanted half-word (using an inverted mask)
d7804 3
a7806 3
      out_diadic_op( OP_ANDN, ADDR_MODE_REGISTER, R_TMP2, R_TMP1,
		    examines2( R_TMP2, R_TMP1 ),
		    alters2( R_TMP2, RR_ST ) );
d7815 1
a7815 1
       * OR in half-word
d9749 5
d9905 1
a9905 1
      debugger_command( /* codebase + codep */ );
@


1.123
log
@removed bogus peephole
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.122 1992/03/27 13:13:37 nickc Exp nickc $ */
d183 2
a184 1
static int32		offset_in_R_ATMP   = 0;
d1053 2
a1054 1
      else if (is_special_register( hardware_register( dest ) ))
d1200 3
a1202 1
  if (fits_in_16_bits_unsigned( n ) && hardware_register( r ) == 0x10 /* DP */)
d1215 2
a1216 1
      if (is_special_register( hardware_register( r ) ))
a1267 6
       * XXX - NC - drat, all bits significant,
       *
       * NB/ do not use LDPK or LDA instructions - we cannot cope with their pipeline effects
       */

      /*
d2727 1
a2727 1
      if (n == 0 && !no_peepholing)
d2732 1
a2732 4
	   * add: 
	   *  && pp_pragmavec[ 'q' - 'a' ] == 0)
	   *
	   * to above test if simulator is still broken.  Reason:
d5168 1
a5168 1
  move_register( R_FP, R_A1 + 1 );
d5991 1
a5991 1
#if defined TARGET_HAS_DEBUGGER && defined TARGET_IS_HELIOS
d5994 1
a5994 1
      do_notify_entry( greatest_stackdepth );
a7974 2

static int32	death;	/* mask of dead registers at end of current J_opcode */
@


1.122
log
@fixed bug in generating calling stubs
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.121 1992/03/26 10:31:02 nickc Exp nickc $ */
d11137 1
d11192 2
a11193 1
      
@


1.121
log
@added dubious peephole to routine_exit
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.120 1992/03/26 09:39:54 nickc Exp nickc $ */
d222 1
d4138 1
a4138 1
  /* add in offset into string table */
d4193 2
d4603 1
a4603 1
	  move_register( R_LR, R_DS, FALSE );
d4663 1
a4663 1
	  move_register( R_DS, R_LR, FALSE );
d4679 1
a4679 1
	  move_register( R_MT, R_DS, FALSE );
d4689 3
a4691 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_DS, 0,
			examines1( R_DS ),
			alters2( R_DS, RR_ST ) );
d4695 3
a4697 3
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_DS, build_indirect( INDIRECT_REL, R_DS, 0 ),
			examines1( R_DS ),
			alters2( R_DS, RR_ST ) );
d4703 3
a4705 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_DS, 0,
			examines1( R_DS ),
			alters2( R_DS, RR_ST ) );
d4709 2
a4710 2
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, R_DS, 0 ),
			examines1( R_DS ),
d5151 77
d5994 7
d7782 10
a7791 1
	  dpush( tmp );
d7803 10
a7812 1
	  move_register( tmp, R_TMP1, FALSE );
d7906 10
a7915 1
	  dpush( tmp );
d8165 4
a8168 2
      
      routine_exit( TRUE );   /* effectively includes correct_stack() */
d8170 3
a8172 2
      if (stack_move)
	syserr( "back end: TAILCALLK stack mis-aligned\n" );
d8635 1
a8635 1
#endif
d8747 1
a8747 1
	      fprintf( asmstream, "ufix\n" );
d8749 10
a8758 1
	      dpush( dest );
d9086 2
a9087 1
#endif
d9780 25
a9804 1
#endif
d9819 1
a9819 1
#endif
d11596 1
a11596 1
      if (writes & regbit( RR_ST ))			/* the instruction sets the status register */      
d11601 1
a11601 1
	  if (writes & regbit( r ))			/* the instruction writes to register 'r'   */
d11613 5
a11617 1
      
@


1.120
log
@removed spurious saving of link register
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.119 1992/03/25 19:07:33 nickc Exp nickc $ */
d125 2
d692 1
a692 1
	      source2 = ((source2 & 0x1f) << 3) | ((source2 >> 8) & 0x7);
d710 1
a710 1
	      source2 = (((source2 >> 11) & 0x1f) << 3) | ((source2 >> 8) & 0x7);
d766 1
a766 1
	  source1 = ((source1 >> 11) & 0x1f) << 3 | (source1 >> 8) & 0x7;
d791 2
a792 2
	      source1 = ((source1 & 0x1f) << 3) | ((source1 >> 8) & 0x7);
	      source2 = ((source2 & 0x1f) << 3) | ((source2 >> 8) & 0x7);
d811 2
a812 2
	      source1 = (((source1 >> 11) & 0x1f) << 3) | ((source1 >> 8) & 0x7);
	      source2 = (((source2 >> 11) & 0x1f) << 3) | ((source2 >> 8) & 0x7);
d839 1
a839 1
	  source1 = ((source1 & 0x1f) << 3) | ((source1 >> 8) & 0x7);
a1762 2
      fprintf( asmstream, "convert: src = %d, reg in R_ATMP = %d\n", src, register_in_R_ATMP );
      
d5923 3
d6021 10
d6032 2
a6033 1
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_LR, build_indirect( INDIRECT_PRE_ADD, R_SP, count ),
d6035 1
a6035 1
			    alters2( R_LR, RR_ST ) );
d6140 2
a6141 2
      outdelayed( OP_BRcrD << 24 | 0x1U << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_LR ),
		 examines1( R_LR ),
d10384 2
a10385 1
			 int32	potential_op )
a10388 1
      !has_indirect_side_effects( op )	&&	/* which does not have side effects	*/
d10392 14
d10592 1
a10592 1
	  ((prev_op >>  8) & 0x07) == (dest - hardware_register( RR_AR0 )) && /* same register affected */
d10903 1
a10903 1
	      if (((src2 & 0x7) + 0x08) == dest)
d11148 4
a11151 4
  prev_load  = is_potential_parallel_op( prev_op, OP_LDI );
  prev_store = is_potential_parallel_op( prev_op, OP_STI );
  curr_load  = is_potential_parallel_op( curr_op, OP_LDI );
  curr_store = is_potential_parallel_op( curr_op, OP_STI );
d11160 2
d11194 2
d11221 2
d11240 2
@


1.119
log
@re-enabled experimental flushing upon routine exit
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/gen.c,v 1.118 1992/03/25 18:52:33 nickc Exp nickc $ */
d1761 2
d1993 1
a1993 1
    {      
d2439 1
a2439 1
      /* do not remember contents of R_ATMP as we are about to corrupt it */
d3518 3
a3520 1
      /* save link register */
d3522 8
a3529 7
      if (dest == R_TMP1)
	{
	  move_register( R_LR, R_TMP2, FALSE );
	}
      else
	{
	  move_register( R_LR, R_TMP1, FALSE );
d3592 4
d3597 8
a3604 9
      /* restore saved link register */
      
      if (dest == R_TMP1)
	{
	  move_register( R_TMP2, R_LR, FALSE );
	}
      else
	{
	  move_register( R_TMP1, R_LR, FALSE );
d3639 3
a3641 1
      /* save link register */
d3643 2
a3644 1
      move_register( R_LR, R_TMP1, FALSE );
d3685 4
d3690 2
a3691 3
      /* restore saved link register */
      
      move_register( R_TMP1, R_LR, FALSE );
d3897 3
a3899 1
	  /* save link register */
d3901 2
a3902 1
	  move_register( R_LR, R_TMP1, FALSE );
d3943 4
a3946 2
      
	  /* restore saved link register */
d3948 2
a3949 1
	  move_register( R_TMP1, R_LR, FALSE );
d4113 3
a4115 1
  /* save link register */
d4117 2
a4118 1
  move_register( R_LR, R_TMP1, FALSE );
d4160 4
d4165 2
a4166 3
  /* restore saved link register */
      
  move_register( R_TMP1, R_LR, FALSE );
a4968 2
      register_in_R_ATMP = GAP;
      
a5823 2
	  /* ... otherwise save return address in R_TMP3 */

a7982 5

      if (r1r == register_in_R_ATMP)
	{
	  register_in_R_ATMP = GAP;
	}
d8224 4
a8227 2
	     
	  /* save the return address */
d8229 2
a8230 1
	  move_register( R_LR, R_TMP2, FALSE );
d8260 3
a8262 1
	  out_triadic_op( OP_ADDI3, R_ATMP, r1r, 3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d8287 3
a8289 1
	  /* restore return address */
d8291 2
a8292 1
	  move_register( R_TMP2, R_LR, FALSE );
d11086 1
a11086 1
	  val = mask_and_sign_extend_word( prev_op, 0x1F );
@


1.118
log
@added STIK peephole
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/expriment/c40/RCS/gen.c,v 1.117 1992/03/25 16:06:48 nickc Exp nickc $ */
d5942 3
a5944 1
#if 0
a5945 1
	/* experimental - eg for int func( int arg ){ return arg * arg; } */
d5947 2
a5948 1
	flush_peepholer( "routine_exit" );
d5950 2
a5951 1
      setlabel( returnlab );
@


1.117
log
@fixed bug in copy memory
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/expriment/c40/RCS/gen.c,v 1.116 1992/03/23 18:12:40 nickc Exp nickc $ */
d7827 2
d7846 1
a7846 1
  int32			dead;
d7897 11
d10344 5
a10348 5
  if (((op & (B_111 << 29)) == 0)            &&		/* currently diadic             */
      (is_op( op, potential_op ))            &&		/* matches sought op            */
      (is_mode( op, ADDR_MODE_INDIRECT ))    &&		/* uses indirect addressing     */
      ((op & (B_11111 << 16)) <= (7 << 16))  &&		/* references registers R0 - R7 */
      ((op & 0xFF) < 2))				/* displacement is 0 or 1       */
d10371 1
a10371 1
      ((op & (B_11111 << 16)) <= (7     << 16))	&&	/* dst  uses register R0 - R7          */
d11009 1
a11009 11
   * check for a load constant followed by a move register
   *
   * eg turns:
   *    LDIu	0,  R5
   *	LDI	R5, R0
   * into:
   *    LDIu	0, R5
   *    LDIu	0, R0
   *
   * Why bother, I hear you ask.  The answer is that I hope
   * at a later date, to be able to eliminate the first load
d11012 3
a11014 5
  if ((prev_op >> 28) == OP_LDIc                  &&	/* previous of is a load (un)conditional	*/
      is_op(   curr_op, OP_LDI )		  &&	/* current op is a load				*/
      is_mode( prev_op, ADDR_MODE_IMMEDIATE ) 	  &&	/* previous operation uses immediate addressing	*/
      is_mode( curr_op, ADDR_MODE_REGISTER  ) 	  &&	/* current  operation uses register  addressing	*/
      dest_of( prev_op ) == source_of( curr_op  )  ) 	/* previous op's dest is current op's source	*/
d11016 17
a11032 1
      *pcurr_op = curr_op = (prev_op & 0xFFE0FFFFU) | (curr_op & 0x001F0000U);
d11034 3
a11036 1
      *preads = reads = 0;
d11038 43
a11080 1
      fprintf( asmstream, "; peepholer: transformed load register into load immeadiate\n" );
@


1.116
log
@forgot that LDA does not set ST
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/expriment/c40/RCS/gen.c,v 1.115 1992/03/20 19:10:44 nickc Exp nickc $ */
d6513 6
d6535 6
d6561 6
d6593 6
d6621 2
a6622 1
  int		restore_ar = FALSE;
d6639 4
d6654 4
d6695 3
d6767 3
d6888 3
@


1.115
log
@minor register ordering change
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.114 1992/03/19 18:05:11 nickc Exp nickc $ */
d1053 1
a1053 1
			alters2( dest, RR_ST ) );
@


1.114
log
@removed optimisation which did not work
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.113 1992/03/19 17:59:15 nickc Exp nickc $ */
d2451 1
a2451 1
      out_triadic_op( OP_ADDI3, R_ATMP, src, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d5942 1
a5942 1
#if 1
@


1.113
log
@improved register allocation by using new global variable usedmaskvec
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.112 1992/03/19 13:56:53 nickc Exp nickc $ */
d5749 6
a5754 2

#if 0
a5755 3
#else /* compiler has already allowed for register that must be saved */
      require = greatest_stackdepth / sizeof_int;
#endif
@


1.112
log
@fixed bug allowing branches to intrude on LAJs
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.111 1992/03/19 09:21:54 nickc Exp nickc $ */
d401 7
a407 7
      0x08,	/* 10 => AR0 */
      0x09,	/* 11 => AR1 */
      0x0a,	/* 12 => AR2 */
      0x0b, 	/* 13 => AR3 */
      0x1c,	/* 14 => R8  */
      0x1d,	/* 15 => R9  */
      0x1e,	/* 16 => R10 */
d5602 1
a5602 1
  mask = regmaskvec.map[ 0 ] & M_VARREGS;
d5618 1
a5618 1
  fmask = regmaskvec.map[ 0 ] & M_FVARREGS;
d5652 1
a5652 1
       * registers USED by the function, and they may not include
d5657 2
a5658 2
  /* fprintf( asmstream, "; routine entry: num_args = %d, register masks: all = %x, variable = %x, FP variable = %x, args = %x\n",
	  num_args, regmaskvec.map[ 0 ], mask, fmask, maskarg ); */
d5678 1
a5678 1
   * this should not be necessary, but lets be paranoid ....
d5749 2
a5750 1
      
d5752 3
d6396 1
a6396 1
  int32		map = regmaskvec.map[ 0 ];	/* XXX - assumes less than 32 registers */
d6399 12
d6428 6
d6435 3
a6437 1
      
d6675 1
a6675 1
      tmp = get_free_register( &must_save, 0x00, 0x01, 0x02, 0x03, -1 );
d6747 1
a6747 1
      tmp = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x00, -1 );
@


1.111
log
@added optimisation to the ordering of register pops
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.110 1992/03/19 08:34:56 nickc Exp nickc $ */
d3579 8
d3667 8
d3919 8
d4130 8
d4624 8
@


1.110
log
@fixed bug in branches and added small optimisation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.109 1992/03/18 11:02:37 nickc Exp nickc $ */
d185 4
a188 4
#define examines1( r1 )			 (1L << (r1))
#define examines2( r1, r2 )		((1L << (r1)) | (1L << (r2)))
#define examines3( r1, r2, r3 )		((1L << (r1)) | (1L << (r2)) | (1L << (r3)))
#define examines4( r1, r2, r3, r4 )	((1L << (r1)) | (1L << (r2)) | (1L << (r3)) | (1L << (r4)))
d5917 78
a5994 1
      restore_regs( saved_ivars, FALSE );
d9605 2
a9606 2
      a_writes &= ~(1U << RR_ST);
      b_writes &= ~(1U << RR_ST);
d10106 1
a10106 1
	  peep_buf[ delayed ].reads |= (1U << RR_PC);	  /* ensure that the NOP does get swapped again */
d10590 2
a10591 2
	      reads  &= ~(1U << dest_of( curr_op ));
	      reads  |=  (1U << dest_of( prev_op ));
d10641 2
a10642 2
	      reads &= ~(1U << source_of( curr_op ));
	      reads |=  (1U << source_of( prev_op ));
d10669 2
a10670 2
	  reads  &= ~(1U << dest_of( curr_op ));
	  reads  |=  (1U << dest_of( prev_op ));
d10843 2
a10844 2
	  peep_buf[ prev ].writes &= ~(1U << dest_of( prev_op ));
	  peep_buf[ prev ].writes |=  (1U << dest_of( curr_op ));	  
d10960 1
a10960 1
	  peep_buf[ prev ].writes &= ~(1U << RR_ST);
d10981 1
a10981 1
	      peep_buf[ prev ].writes &= ~(1U << RR_ST);
d11002 1
a11002 1
	  peep_buf[ prev ].writes &= ~(1U << RR_ST);
d11019 1
a11019 1
	  peep_buf[ prev ].writes &= ~(1U << RR_ST);
d11213 1
a11213 1
      if (writes & (1U << RR_ST))			/* the instruction sets the status register */      
d11218 1
a11218 1
	  if (writes & (1U << r))			/* the instruction writes to register 'r'   */
d11223 3
a11225 3
	  if (is_op(   op, OP_LDI ) 		  &&	/* or the instruction is a load			*/
	      is_mode( op, ADDR_MODE_REGISTER )   &&	/* and it is a register to register transfer	*/
	      (peep_buf[ prev ].reads & (1U << r)) )	/* and the instruction reads from register 'r'	*/
@


1.109
log
@oops, fixed bug in LAJ nop elimination
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.108 1992/03/17 17:59:54 nickc Exp nickc $ */
d2971 4
d5982 5
a5989 6
   * make sure that all of the op codes have been emitted
   */
  
  flush_peepholer( "end of function" );
  
  /*
d6531 1
a6531 1
       * find a register that can be used in a parallel op
d6534 1
a6534 1
      tmp = get_free_register( &must_save, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, -1 );
d6602 1
a6602 1
       * find a register than can be used in a parallel op
d6606 1
a6606 1
      tmp = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00, -1 );
d6609 1
a6609 1
      if (must_save && tmp != 0x00)
d6619 3
d6696 1
a6696 1
	  if (tmp == 0x00)
d7827 2
d7859 2
d11112 2
a11113 2
 * will set the condition codes in the status register
 * based on the contents of register 'r'
d11122 4
a11125 1
  prev = previous_( peep_end );
d11127 1
a11127 2
  if (peep_end != peep_start                    &&	/* if there is an instruction in the peepholer  */
      (peep_buf[ prev ].writes & (1U << RR_ST))  )	/* and the instruction sets the status register */      
d11129 16
a11144 1
      int32	op;
d11146 4
a11149 2
      if ((peep_buf[ prev ].writes & (1U << r))  )	/* and the instruction writes to register 'r'   */
	return TRUE;
d11151 2
a11152 1
      op = peep_buf[ prev ].op_code;
d11154 1
a11154 4
      if (is_op(   op, OP_LDI ) 		&&	/* or the instruction is a load			*/
	  is_mode( op, ADDR_MODE_REGISTER ) 	&&	/* and it is a register to register transfer	*/
	  (peep_buf[ prev ].reads & (1U << r))	)	/* and the instruction reads from register 'r'	*/
	return TRUE;
d11156 2
a11157 1
  
@


1.108
log
@fixed bug in setlabel() whereby branches to next instruction plus one were being eliminated
@
text
@d1 1
a1 1
/* C compiler file c40/gen.c :  Copyright (c) Perihelion Software Ltd, 1991.     */
d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.107 1992/03/17 14:18:30 nickc Exp nickc $ */
d58 2
a59 4
/* XXX - the definition of ul is because of the pesky HP ANSI compiler *sigh* */

#define fits_in_5_bits( val )		(((val) & 0xfffffff0U) == 0 || ((val) & 0xfffffff0U) == 0xfffffff0U)
#define fits_in_8_bits( val )		(((val) & 0xffffff80U) == 0 || ((val) & 0xffffff80U) == 0xffffff80U)
d61 1
a61 1
#define fits_in_16_bits( val )		(((val) & 0xffff8000U) == 0 || ((val) & 0xffff8000U) == 0xffff8000U)
d63 1
a63 1
#define fits_in_24_bits( val )		(((val) & 0xff800000U) == 0 || ((val) & 0xff800000U) == 0xff800000U)
d733 1
a733 1
	      if (!fits_in_8_bits( source2 ))
d841 1
a841 1
	  if (!fits_in_8_bits( source2 ))
d1032 1
d1049 6
d1195 10
a1204 1
  if (fits_in_16_bits( n ))
d1208 12
a1219 3
      conditional_load( Q_AL, ADDR_MODE_IMMEDIATE, r, n,
		       examines0(),
		       alters1( r ) );
d1245 2
a1246 4
      
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_TMP3, RR_ST,
		    examines1( RR_ST ),
		    alters2( R_TMP3, RR_ST ) );
d1287 2
a1288 4
      
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, RR_ST, R_TMP3,
		    examines1( R_TMP3 ),
		    alters1( RR_ST ) );
d1331 1
a1331 3
	      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, source,
			    examines1( source ),
			    alters2( dest, RR_ST ) );
d1348 1
a1348 1
  if (dest == source && (signed_op ? fits_in_16_bits( value ) : fits_in_16_bits_unsigned( value )))
d1355 1
a1355 1
  else if (signed_op ? fits_in_8_bits( value ) : fits_in_8_bits_unsigned( value ))
d1357 1
a1357 1
  else if (fits_in_8_bits( value ))
d1375 1
a1375 1
      else if (fits_in_8_bits( ~value ))
d1773 1
a1773 1
	      if (fits_in_16_bits( offset ))
d1817 1
a1817 1
  else if (fits_in_16_bits( offset ))
d1880 1
a1880 1
		  fits_in_16_bits( offset - offset_in_R_ATMP ) )
d1941 1
a1941 1
      else if (fits_in_16_bits( offset ))
d2042 1
a2042 1
		  fits_in_16_bits( offset - offset_in_R_ATMP ) )
d2127 1
a2127 1
      else if (fits_in_16_bits( offset ))
d2241 1
a2241 1
		  fits_in_16_bits( offset - offset_in_R_ATMP ) )
d2326 1
a2326 1
      else if (fits_in_16_bits( offset ))
d2681 1
a2681 1
  if (!fits_in_16_bits( move ))
d2723 1
a2723 1
  if (fits_in_16_bits( n ))
d2875 1
a2875 1
  else if (fits_in_16_bits( val ))
d2877 1
a2877 1
      if (fits_in_8_bits( val ))
d2942 1
a2942 1
  if (!fits_in_16_bits( num_to_skip ))
d3009 1
a3009 1
      if (condition == Q_AL && fits_in_24_bits( off ))
d3017 1
a3017 1
      else if (fits_in_16_bits( off ))		/* short branch */
d3246 2
a3247 4
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, tmp, R_MT,
		    examines1( R_MT ),
		    alters2( tmp, RR_ST ) );
  
d3741 1
a3741 3
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, R_MT,
		    examines1( dest ),
		    alters2( R_MT, RR_ST ) );
d3921 2
a3922 4
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, tmp, R_MT,
			examines1( R_MT ),
			alters2( tmp, RR_ST ) );
d3980 1
a3980 1
	      if (!fits_in_16_bits( offset ))
d4345 1
a4345 1
  if (fits_in_8_bits( offset ) && asmstream == NULL)
d4353 1
a4353 1
      if (asmstream != NULL && !fits_in_16_bits( offset ))
d4605 2
a4607 4
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_DS, R_MT,
			examines1( R_MT ),
			alters2( R_DS, RR_ST ) );

d4696 1
a4696 1
	  if (!fits_in_16_bits( offset ))
d4728 1
a4728 1
  else if (fits_in_8_bits( len ))
d4774 1
a4774 1
  if (fits_in_5_bits( value ))
d4791 1
a4791 1
      else if (fits_in_8_bits( increment ))
d4819 1
a4819 1
      else if (fits_in_8_bits( increment ))
d4947 1
a4947 1
      if (fits_in_24_bits( off ))
d5723 1
a5723 1
	  if (!fits_in_8_bits( require ))
d5757 1
a5757 1
	  if (fits_in_8_bits( require ))
d5864 1
a5864 1
      if (fits_in_16_bits( stack_offset ))
d6165 1
a6165 1
	  if (!fits_in_24_bits( d ))
d6189 1
a6189 1
	  if (!fits_in_16_bits( d ))
d6202 1
a6202 1
	  if (!fits_in_16_bits( d ))
d6215 1
a6215 1
	  if (!fits_in_8_bits( d ))
d6790 1
a6790 1
  return fits_in_16_bits( n );
d6891 1
a6891 1
		      fits_in_16_bits( offset - offset_in_R_ATMP ))
d7010 1
a7010 1
	  else if (fits_in_8_bits( offset ))
d8310 3
a8312 4
      
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, r1r, mr,
		    examines1( mr ),
		    alters2( r1r, RR_ST ) );
d8560 1
a8560 1
	  if (fits_in_16_bits( m ))
d8662 1
a8662 1
	  else if (fits_in_8_bits_unsigned( m ))
a8669 8
	  else if (fits_in_8_bits_unsigned( -m ))
	    {
	      fprintf( asmstream, "; peepholer: eliminated unnecessary integer load\n" );
	      
	      out_triadic_op( OP_ADDI3, r1r, R_ATMP, -m, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( R_ATMP ),
			     alters2( r1r, RR_ST ) );
	    }
d8744 1
a8744 1
	  else if (fits_in_8_bits_unsigned( m ))
a8751 8
	  else if (fits_in_8_bits_unsigned( -m ))
	    {
	      fprintf( asmstream, "; peepholer: eliminated unnecessary integer load\n" );
	      
	      out_triadic_op( OP_SUBI3, r1r, R_ATMP, -m, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			     examines1( R_ATMP ),
			     alters2( r1r, RR_ST ) );
	    }
d9490 4
d10095 4
d10257 1
a10257 1
		      if (fits_in_16_bits( val ))
d10270 4
d10275 4
d10343 1
a10343 1
   * is a register based LDI or LDF and the current instruction is diadic
d10346 3
a10348 3
  if ((is_op(    prev_op, OP_LDI ) || is_op( prev_op, OP_LDF ) )	&&
      is_mode(   prev_op, ADDR_MODE_REGISTER )				&&
      is_diadic( curr_op )                  				)
d10469 1
a10469 1
		  if (!fits_in_8_bits( mask_and_sign_extend_word( curr_op, 0xFFFF )))
d10611 12
a10622 12
  if (is_op(     prev_op, OP_LDI )		&&
      is_mode(   prev_op, ADDR_MODE_REGISTER )	&&
      is_triadic( curr_op )                  	&&
      dest_of(   prev_op ) == dest_of( curr_op ) )
    {
      bool	src1_is_prev = FALSE;
      bool	src2_is_prev = FALSE;
      bool	uses_prev    = FALSE;
      int32	T    = (curr_op >> 21) & 3;
      int32	dest = dest_of( prev_op );
      int32	src1 = (curr_op >> 8) & 0xFF;
      int32	src2 = curr_op & 0xFF;
d10740 6
a10745 6
  if (is_diadic( prev_op )					&&
      is_mode(   prev_op, ADDR_MODE_REGISTER )			&&
      (is_op(    curr_op, OP_LDI ) || is_op( curr_op, OP_LDF ) )&&
      is_mode(   curr_op, ADDR_MODE_REGISTER )			&&
      dest_of(   prev_op ) == source_of( curr_op )		&&
      dest_of(   curr_op ) == source_of( prev_op )		)
@


1.107
log
@fixed bug in fix()
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.106 1992/03/17 13:57:05 nickc Exp nickc $ */
d203 4
a206 3
static bool		saved_frame        = FALSE;	/* true if frame pointer saved on stack       */
static int32		saved_tmps         = 0;		/* mask of temporary registers saved on stack */
static int32		saved_args         = 0;		/* mask of argument registers saved on stack  */
d221 1
a221 1
extern void		decode_instruction( int32 op_code );
d4991 3
a4993 1
save_regs( int32	mask )	/* bit mask of registers to save */
d5003 1
a5003 1
  for (i = 31; i >= 0; i--)
d5005 1
a5005 1
      if (mask & regbit( i ))
d5007 14
a5020 1
	  ipush( i );
d5034 3
a5036 1
restore_regs( int32 mask )	/* bit mask of registers to remove from stack     */
d5041 13
a5053 1
  while (mask)
d5055 3
a5057 1
      RealRegister r1  = firstbit( mask );
d5060 1
a5060 1
      ipop( r1 );
d5062 2
a5063 1
      mask ^= regbit( r1 );
d5507 1
d5519 3
a5521 2
      saved_tmps = 0;
      saved_args = 0;
d5563 1
a5563 1
  /* also include FP variable registers */
d5565 1
a5565 1
  mask |= regmaskvec.map[ 0 ] & M_FVARREGS;
d5567 4
d5604 2
a5605 2
  /* fprintf( asmstream, "; routine entry: num_args = %d, register masks: all = %x, variable = %x, args = %x\n",
	  num_args, regmaskvec.map[ 0 ], mask, maskarg ); */
d5638 1
a5638 1
      save_regs( maskarg );
d5697 1
a5697 1
      require = greatest_stackdepth / sizeof_int + count_bits( mask );
d5819 6
a5824 1
      save_regs( mask );
d5831 3
a5833 2
  saved_tmps = mask;
  saved_args = maskarg;
d5897 6
a5902 1
  if (saved_tmps)
d5904 1
a5904 1
      restore_regs( saved_tmps );
d6159 1
a6159 1
	  if (d == 1)
d6164 2
d9954 1
a9968 3
      peep_type	type;


d10030 2
a10031 2
		   peep_buf[ prev ].op_code, peep_buf[ delayed ].op_code,
		   peep_buf[ prev ].reads, peep_buf[ prev ].writes,
d10073 1
a10073 9
	  peep_buf[ delayed ].op_code = op;
	  
	  /* remove previous two inserted NOPs */
	  
	  peep_end = successor_( delayed );

	  /* fprintf( asmstream, "; converted a conditional branch\n" ); */
	  
	  return TRUE;
d10077 2
a10078 2
	  int32	off;	
  
d10096 5
d10102 12
a10113 1
	  peep_buf[ delayed ].op_code = op;
d10115 1
a10115 1
	  /* remove previous two inserted NOPs */
d10117 1
a10117 1
	  peep_end = successor_( delayed );
d10119 1
a10119 2
	  return TRUE;
	}
d10221 2
a10222 2
 
  /* get the op code of the previous instruction */
d10226 7
d11233 1
a11233 1
	  decode_instruction( peep_buf[ prev ].op_code );
d11237 1
a11237 1
	  decode_instruction( peep_buf[ last ].op_code );
d11254 1
a11254 1
	  decode_instruction(  peep_buf[ last ].op_code );
d11258 1
a11258 1
	  decode_instruction( peep_buf[ prev ].op_code );
d11401 1
a11401 1

@


1.106
log
@fixed bug in pushing doubles
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.105 1992/03/16 17:47:09 nickc Exp nickc $ */
d7395 2
a7396 2
      
      /* get hold of a free floating point register */
d7398 2
a7399 1
      tmp = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x1c, 0x1d, 0x1e, -1 );
d7407 7
d7415 5
d7447 7
a7453 1
	dpop( tmp );
@


1.105
log
@fixed passing doubles as arguments to functions
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.104 1992/03/11 16:37:40 nickc Exp nickc $ */
d9686 6
d9696 2
a9697 2
	case PUSH_FLOAT:  fpop( dest ); return 1;
	case PUSH_DOUBLE: dpop( dest ); return 2;	  
d9744 1
@


1.104
log
@tidied up peepholing
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.103 1992/03/11 15:27:06 nickc Exp nickc $ */
d5480 2
d5490 2
d5527 2
a5547 7
       *
       * Also since all floats are promoted to
       * doubles, and on the C40 all doubles held in
       * registers only occupy one register, (not two
       * as the compiler thinks), then we need save only
       * every other register in the floating point mask.
       *
d5552 1
d5556 2
a5557 1

d7239 1
a7239 1
       *    R_TMP1  - free
d7253 1
a7253 1
       *    R_TMP1  - free
d7259 9
a7268 4
      out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_TMP1, half_word_op ? 0xFFFF : 0xFF,
		    examines1( R_TMP1 ),
		    alters2( R_TMP1, RR_ST ) );
      
d8218 1
a8218 1
       * move the contents of integer registers 'mr' (msb) and 'r2r' (lsb)
d8228 2
a8229 16
      /* see comment below */

      if (is_float( r2r ))
	{
	  /* compiler will conspire to put full floating point value in the "integer" register */

	  if (r1r != r2r)
	    out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, r1r, r2r,
			  examines1( r2r ),
			  alters2( r1r, RR_ST ) );      
	}
      else
	{
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_TMP1, mr,
			examines1( mr ),
			alters2( R_TMP1, RR_ST ) );
d8231 3
a8233 9
	  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, r1r, R_TMP1,
			examines1( R_TMP1 ),
			alters2( r1r, RR_ST ) );
      
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, r1r, r2r,
			examines1( r2r ),
			alters2( r1r, RR_ST ) );
	}
      
d8248 3
a8250 28
#endif      
      /*
       * XXX
       *
       * This wierd operation is because an LDF will copy all 40 bits
       * from 'mr' if it is R0 - R11, rather than shifting the 32 bits
       * up into the top bits as a normal LDF would do.
       */

      if (is_float( mr ))
	{
	  /* compiler will conspire to put full floating point value in the "integer" register */

	  if (r1r != mr)
	    out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, r1r, mr,
			  examines1( r2r ),
			  alters2( r1r, RR_ST ) );      
	}
      else
	{
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_TMP1, mr,
			examines1( mr ),
			alters2( R_TMP1, RR_ST ) );
      
	  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, r1r, R_TMP1,
			examines1( R_TMP1 ),
			alters2( r1r, RR_ST ) );
	}
d9738 4
a9741 2
	      
	      move_register( src, dest, TRUE );
d9752 1
a9752 1
	      ipop( dest );
d10339 1
a10339 1
	       *	ADDI	1, R0
d10467 6
a10472 2
      if (!swapped					&&
	  is_mode( curr_op, ADDR_MODE_REGISTER )	&&
d11017 1
a11017 2
      (peep_buf[ prev ].writes & (1U << RR_ST)) &&	/* and the instruction sets the status register */
      (peep_buf[ prev ].writes & (1U <<     r))  )	/* and the instruction writes to register 'r'   */
d11019 11
a11029 1
      return TRUE;
@


1.103
log
@added another peephole optimisation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.102 1992/03/11 14:58:08 nickc Exp nickc $ */
d144 1
a144 1
typedef struct mcpeepdata
d146 7
a152 7
    peep_type		type;		/* e.g. OUT_INSTR 				*/
    int32 		op_code;	/* 32 bits of data 				*/
    int32 		reads;		/* registers accessed 				*/
    int32 		writes;		/* registers clobbered, plus usage class 	*/
    Symstr *		symbol;		/* external symbol (if needed) 			*/
    int32 		reftype;	/* symbol reference type (if needed) 		*/
    LabelNumber *	label;		/* label (if needed) 				*/
d10282 1
a10282 1
   * is a register based LDI and the current instruction is diadic
d10285 3
a10287 3
  if (is_op(     prev_op, OP_LDI )		&&
      is_mode(   prev_op, ADDR_MODE_REGISTER )	&&
      is_diadic( curr_op )                  	)
d10295 29
a10334 3
	      unsigned long	op = OP_NOP;
		  
	      
d10346 1
a10346 1
		case OP_OR:		  op = OP_OR3;		  break;
d10394 1
a10394 1
		case OP_OR:		  op = OP_OR3;	 is_signed = FALSE;	break;
d10430 2
a10431 2
	  else if (is_op( curr_op, OP_STI )		 &&	/* current op is a  store		   */
		   is_mode( curr_op, ADDR_MODE_INDIRECT ) )	/* current op is NOT a STIK 		   */
d10453 1
a10453 1
      if (!swapped                                    &&	/* make sure our knowledge of prev is OK     */
d10503 23
a10658 31
   * check for loading a register
   * followed by a register based diadic op with
   * that register as both source and destination
   *
   * eg turns:
   *	LDI	R0, R1
   *	NEGI	R1, R1
   * into:
   *    NEGI	R0, R1
   */
  
  if ((is_op(   prev_op, OP_LDI )             	||	/* previous operation is a integer load or */
       is_op(   prev_op, OP_LDF ) )              &&	/* previous operation is a floating load   */
      is_mode( curr_op, ADDR_MODE_REGISTER ) 	 &&	/* and current operation is register based */
      is_diadic( curr_op )                   	 &&	/* and current operation is diadic         */
      dest_of( curr_op ) == source_of( curr_op ) &&	/* and current op's dest is its source     */
      dest_of( curr_op ) == dest_of( prev_op  )	  )	/* and they both have the same destination */
    {
      /* avoid the case of LDF followed by LDI */
      
      if (!is_op( prev_op, OP_LDF) || !is_op( curr_op, OP_LDI ))
	{
	  peep_buf[ prev ].op_code = (curr_op & 0xff800000U) | (prev_op & 0x007fffffU);
	  
	  fprintf( asmstream, "; peepholer: merged load and diadic op into diadic op\n" );
	  
	  return TRUE;
	}
    }
      
  /*
d10675 6
a10680 6
  if (is_diadic( prev_op )                         &&
      is_mode(   prev_op, ADDR_MODE_REGISTER )     &&
      is_op(     curr_op, OP_LDI )                 &&
      is_mode(   curr_op, ADDR_MODE_REGISTER )     &&
      dest_of(   prev_op ) == source_of( curr_op ) &&
      dest_of(   curr_op ) == source_of( prev_op ) )
d10684 1
d10687 2
d10698 1
d10700 1
@


1.102
log
@added another peephole
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.101 1992/03/11 14:26:43 nickc Exp nickc $ */
d10616 1
a10616 1
   *	NEG	R1, R1
d10618 1
a10618 1
   *    NEG	R0, R1
d10636 50
@


1.101
log
@stack offsets can now be any size
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.100 1992/03/11 09:23:41 nickc Exp nickc $ */
d10135 13
d10163 1
d10404 21
d10427 2
a10428 1
      if (is_op(   curr_op, OP_LDI )                  &&	/* current  operation is an integer load     */
d10472 1
a10472 13
	      /* swap ops */
	      
	      *pcurr_op = prev_op;
	      *preads   = peep_buf[ prev ].reads;
	      *pwrites  = peep_buf[ prev ].writes;
	      
	      peep_buf[ prev ].op_code = prev_op = curr_op;
	      peep_buf[ prev ].reads   = reads;
	      peep_buf[ prev ].writes  = writes;

	      curr_op = *pcurr_op;
	      reads   = *preads;
	      writes  = *pwrites;
d10476 1
a10476 1
	}	  
@


1.100
log
@improved loading of floating point constants
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.99 1992/03/10 19:05:25 nickc Exp nickc $ */
d1293 3
d1860 26
a1885 2
	      syserr( "back end: out_immediate_offset: byte offset from stack pointer is too large - %d",
		     offset * sizeof_int );
d1887 1
a1887 2

	  if (offset > 0)
d1932 1
a1932 1
	    syserr( "back end: offset register xconflict" );
d1973 3
a1975 1
    register_in_R_ATMP = GAP;
d2022 32
a2053 2
	      syserr( "back end: load_double_relative: byte offset from stack pointer is too large - %d",
		     offset * sizeof_int );
d2055 1
a2055 2

	  if (offset > 0)
d2171 3
a2173 1
    register_in_R_ATMP = GAP;
d2221 32
a2252 2
	      syserr( "back end: store_double_relative: byte offset from stack pointer is too large - %d",
		     offset * sizeof_int );
d2254 1
a2254 2

	  if (offset > 0)
d2453 3
a2455 1
    register_in_R_ATMP = GAP;
d2536 3
a2538 1
    register_in_R_ATMP = GAP;
d4033 3
a4035 1
    register_in_R_ATMP = GAP;
d4099 3
a4101 1
    register_in_R_ATMP = GAP;
d6327 1
a6327 1
      /* convert destinttaion pointer to word offset */
a6777 2
  register_in_R_ATMP = GAP;
  
d6827 26
a6852 2
		  syserr( "back end: non_word_op: byte offset from stack pointer is too large - %d",
			 offset * sizeof_int );
d6854 1
a6854 2

	      if (offset > 0)
d6965 2
d7346 4
a7349 2
    register_in_R_ATMP = GAP;
  
d7671 3
a7673 1
	register_in_R_ATMP = GAP;
d8600 8
a8607 2
      
      if (m < 0)
d8609 33
a8641 1
	  integer_immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, -m, TRUE );
d8643 1
a8643 1
      else if (m > 0)
d8645 1
a8645 1
	  integer_immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, m, TRUE );
d8649 1
a8649 1
	  move_register( r2r, r1r, FALSE );
d8694 38
@


1.99
log
@fixed another bug in copy_memory()
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.98 1992/03/10 10:22:05 nickc Exp nickc $ */
d1388 1
a1388 1
 * a C40 short floating point format number.  Returns
d1617 1
a1617 1
  int32		val;
a1618 1

a1625 21
  val = convert_to_C40_format( fc, is_double );

  if (val != 0xFFFFFFFFU)
    {
      out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r, val,
		    examines0(),
		    alters2( r, RR_ST ) );

      return;
    }

  /* fprintf( asmstream, "failed to load %s as a single instruction, val = %x\n", fc->floatstr, val ); */
  
  /*
   * Other op codes we could try ....
   *
   * FLOAT, LDE, LDM, RND, FLOAT
   */
  
  /* place value in constant table */
  
d1628 2
a1629 16
      (void) lit_findwordaux( fc->floatbin.db.msd,
			     LIT_FPNUM1, fc->floatstr,
			     LITF_DOUBLE | LITF_INCODE | LITF_FIRST );
      
      /* use the second address in case overflow */

      disp = lit_findwordaux( fc->floatbin.db.lsd,
			     LIT_FPNUM2, fc->floatstr,
			     LITF_INCODE | LITF_LAST ) - sizeof_int;
    }
  else
    {
      disp = lit_findwordaux( fc->floatbin.fb.val,
			     LIT_FPNUM, fc->floatstr,
			     LITF_INCODE | LITF_FIRST | LITF_LAST );      
    }
a1630 1
  /* save link register */
d1632 5
a1636 1
  move_register( R_LR, R_TMP1, FALSE );
d1638 20
a1657 10
  /* put PC of next instruction into R_LR */

  outinstr( OP_LAJ << 24 | (1 & 0xffffff), examines0(), alters2( R_LR, RR_PC ) );

  /*
   * add in offset of start of literal pool
   *
   * NB/ beware of assumption that literal pool is within 16
   * (signed) bits of this instruction - this may not be true
   */
d1659 3
a1661 1
  peep_fref( litlab, LABREF_LIT16 ); 
d1663 3
a1665 3
  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_ATMP, 0,
		examines0(),
		alters2( R_ATMP, RR_ST ) );
d1667 3
a1669 15
  register_in_R_ATMP = GAP;
  
  /* prevent peepholer from moving this instructions before the LAJ */
  
  flush_peepholer( "load_float" );
  
  /* add in offset into literal table */
  
  /*
   * XXX - this is done as a seperate instruction becuase we cannot
   * reliably use R_LR immediately after a LAJ (due to a silicon bug)
   * and so I have reordered the ops
   */
  
  integer_immediate_op( OP_ADDI, OP_ADDI3, R_ATMP, R_ATMP, disp - 4 + 1, TRUE );
d1671 13
a1683 1
  /* add in value in link register */
a1684 3
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_LR,
		examines2( R_LR, R_ATMP ),
		alters2( R_ATMP, RR_ST ) );
d1686 1
a1686 1
  /* restore saved link register */
d1688 1
a1688 1
  move_register( R_TMP1, R_LR, FALSE );
d1690 1
a1690 1
  /* and load the floating point value */
d1692 30
a1721 3
  out_diadic_op( OP_LDF, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, R_ATMP, 0 ),
		examines1( R_ATMP ),
		alters2( r, RR_ST ) );
a1722 2
  return;

d6463 1
a6463 1
	   * NB/ we do not need tp dpush() this as we are only doing integer
@


1.98
log
@fixed bugs in struct copy and is_C40_float_register()
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.97 1992/03/09 16:07:45 nickc Exp nickc $ */
d6460 5
d6541 4
d6549 1
a6549 1
      if (length > 2)
d9122 1
a9122 1
       * restore the registers indicate by the bits set in 'm' from the stack
d9540 2
d9551 2
d9574 4
@


1.97
log
@tidied up a few Norcroft detected compiler warnings
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.96 1992/03/09 15:19:43 nickc Exp nickc $ */
d431 1
a431 1
int
d434 5
a438 1
  return (r < 12);
d440 2
d1097 1
a1097 1
    syserr( "back end: trying to float push a non-floating point register" );
d1116 1
a1116 1
    syserr( "back end: trying to float push a non-floating point register" );
d1135 1
a1135 1
    syserr( "back end: trying to float push a non-floating point register" );
d1160 1
a1160 1
    syserr( "back end: trying to float push a non-floating point register" );
d6316 1
a6316 1
  if (!can_corrupt_dest || !is_address_register( hardware_register( dst )))
d6324 3
a6326 1
	  dest = get_free_register( &restore_ar, 0x08, 0x09, 0x0a, 0x0b, 0x0d, -1 );
d6330 1
a6330 1
	      if (length > 2)
d6446 3
a6448 1
#ifndef TARGET_R0_ALWAYS_ZERO
d6452 6
a6457 1
	  /* preserve register 0 */
d6459 1
a6459 1
	  move_register( tmp, R_TMP1, FALSE );
d6526 4
a6529 2
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, tmp, 0,
			examines0(), alters1( tmp ) );
d6531 3
a6533 3
	  /* restore register 0 */
	  
	  move_register( R_TMP1, tmp, FALSE );
d7266 3
a7268 1
	dpush( tmp );
d7354 3
a7356 1
	dpush( tmp );
d8207 5
a8211 1
	    dpush( dest );
d9550 1
a9550 1
	      
d9662 1
a9662 1
      
d9673 2
a9674 2
	  /* fprintf( asmstream, "flushed push of reg %d because of clash\n", reg ); */
	  
@


1.96
log
@fixed bug in converting diadic into triadic op
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.95 1992/03/09 14:34:59 nickc Exp nickc $ */
d220 1
d555 1
d577 1
a578 1

d585 6
a590 6
	      int32		op_code,		/* 32 bit operand */
	      int32		addressing_mode,	/* form of addressing */
	      RealRegister	destination,		/* registers written to */
	      int32		source,			/* NB/ doubles up as a RealRegister */
	      unsigned long	reads,			/* mask of registers examined by op_code */
	      unsigned long	writes )		/* mask of registers altered by op_code */
d997 1
d1022 1
d1444 1
a1444 1
  if (convert_to_C40_format( fc, J_fltisdouble( op ) ) != 0xFFFFFFFFU)
d2546 1
a2546 1
  int	move;
a6651 1
  bool		must_copy = FALSE;
d8248 1
a8248 1
      fix( mr, r1r, opm & J_SIGNED );
d9098 1
a9098 1
	  if (pop_pending_push( r, m & regbit( r + 1 ) ) == 2)
d9365 3
a9367 2
add_pending_push( RealRegister	reg,	/* the register to be pushed 		*/
		  push_type	type )	/* the kind of push being performed	*/
d9863 1
d9885 1
a9885 1

d9971 1
a9971 1
		  fprintf( asmstream, "; peepholer: failed to combine multiple indentical op codes (%x)\n",
d10220 1
a10220 1
   *	MPYI	3, R2, R1
d10222 1
a10222 1
   *    MPYI	3, R2, R1
a10334 9
	      
	      peep_buf[ prev ].op_code = curr_op;

	    }
	  else
	    {
	      /* eliminate load altogether */
	      
	      peep_buf[ prev ].op_code = curr_op;
d10337 2
@


1.95
log
@fixed bug whereby stack was being adjusted between pushes
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.94 1992/03/04 17:53:48 nickc Exp nickc $ */
d10218 6
d10231 3
a10233 1
      bool	uses_prev = FALSE;
d10241 1
a10241 1
      
d10248 1
a10248 1
		uses_prev == TRUE;
d10252 4
a10255 2
	      if (src1 == dest ||
		  ((src2 & 0x7) + 0x08) == dest)
d10276 6
a10281 2
	      if (src1 == dest || src2 == dest)
		uses_prev = TRUE;
d10285 4
a10288 2
	      if (  src2 == dest ||
		  ((src1 & 0x7) + 0x08) == dest)
d10293 4
a10296 2
	      if (  src1 == dest ||
		  ((src2 & 0x7) + 0x08) == dest)
a10311 1
	  peep_buf[ prev ].op_code = curr_op;
d10314 26
@


1.94
log
@added another peephole optimisation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.93 1992/03/03 19:11:38 nickc Exp nickc $ */
d1628 2
a1629 3
  fprintf( asmstream, "failed to load %s as a single instruction, val = %x\n",
     fc->floatstr, val );
	      
d1635 1
a1635 1

d2542 3
d2546 3
a2548 1
    return;
d2554 10
d2565 1
a2565 1
  if (!fits_in_16_bits( stack_move ) || stack_move > 0)
d2567 3
a2569 1
      integer_immediate_op( OP_ADDI, OP_ADDI3, R_SP, R_SP, stack_move, TRUE );
d2573 3
a2575 1
      integer_immediate_op( OP_SUBI, OP_ADDI3, R_SP, R_SP, -stack_move, TRUE );
d2579 1
a2579 1

a7507 2
      fprintf( asmstream, "correcting stack because SP is used, offset = %d\n", stack_move );
      
d9376 7
d9389 1
a9389 4
  /* adjust the stack offset */
  
  if (stack_move != 0)
    correct_stack( FALSE );
d9401 2
d9407 1
a9407 1
  
d10872 1
a10872 1
      fprintf( stderr, "attempting to flush empty peepholer!\n" );
@


1.93
log
@fixed logical triadics
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.92 1992/03/03 16:05:00 nickc Exp nickc $ */
d6526 2
a6527 1
	    RealRegister	source2 )
d6535 6
d8579 1
a8579 1
      register_op( OP_ADDF, OP_ADDF3, r1r, r2r, mr );
d8589 1
a8589 1
      register_op( OP_ADDI, OP_ADDI3, r1r, r2r, mr );
d8612 1
a8612 1
      register_op( OP_SUBF, OP_SUBF3, r1r, r2r, mr );
d8622 1
a8622 1
      register_op( OP_SUBI, OP_SUBI3, r1r, r2r, mr );
d8644 1
a8644 1
      register_op( OP_MPYF, OP_MPYF3, r1r, r2r, mr );
d8649 1
a8649 1
      register_op( OP_MPYI, OP_MPYI3, r1r, r2r, mr );
d8659 1
a8659 1
      register_op( OP_AND, OP_AND3, r1r, r2r, mr );
d8669 1
a8669 1
      register_op( OP_OR, OP_OR3, r1r, r2r, mr );
d8679 1
a8679 1
      register_op( OP_XOR, OP_XOR3, r1r, r2r, mr );
d8689 1
a8689 1
      register_op( OP_ASH, OP_ASH3, r1r, r2r, mr );
d8699 1
a8699 1
      register_op( OP_LSH, OP_LSH3, r1r, r2r, mr );
d9204 8
a9211 7
#define is_op( instruction, op_code )	 (((instruction) >> 23)        == (op_code))
#define is_mode( instruction, mode )	((((instruction) >> 21) & 0x3) == (mode))
#define is_diadic( instruction )	 (((instruction) >> 29)        == 0)
#define is_normal( instruction )	 (((instruction) >> 30)        == 0)
#define dest_of( instruction )		 (((instruction) >> 16) & 0x1f)
#define source_of( instruction )	  ((instruction) & 0xffff)
#define has_indirect_side_effects( inst ) ((((inst) >> 11) & 0x6) != 0)
d9868 3
a9870 3
	      int32	curr_op,
	      int32	reads,
	      int32	writes )
d9874 3
d9956 6
d9998 2
a9999 8
   * check for moving one register into another followed
   * by a register based diadic op on that register
   *
   * eg turns:
   *	LDI	R1, R0
   *	ADDI	R2, R0
   * into:
   *	ADDI3	R1, R2, R0
d10002 5
a10006 28
  if (is_op(   prev_op, OP_LDI )               &&	/* previous operation is a load 		*/
      is_mode( prev_op, ADDR_MODE_REGISTER )   &&	/* from one register to another 		*/
      is_mode( curr_op, ADDR_MODE_REGISTER )   &&	/* and current operation is register based 	*/
      is_diadic( curr_op )                     &&	/* and it is diadic 				*/
      dest_of( prev_op ) == dest_of( curr_op )  )	/* and they both have the same destination 	*/
    {
      unsigned long	op = OP_NOP;

      
      switch ((curr_op >> 23) & 0x3f)
	{
	case OP_ADDC:	  op = OP_ADDC3;	  break;
	case OP_ADDF:	  op = OP_ADDF3;	  break;
	case OP_ADDI:	  op = OP_ADDI3;	  break;
	case OP_AND:	  op = OP_AND3;		  break;
	case OP_ANDN:	  op = OP_ANDN3;	  break;
	case OP_ASH:	  op = OP_ASH3;		  break;
	case OP_LSH:	  op = OP_LSH3;		  break;
	case OP_MPYF:	  op = OP_MPYF3;	  break;
	case OP_MPYI:	  op = OP_MPYI3;	  break;
	case OP_OR:	  op = OP_OR3;		  break;
	case OP_SUBB:	  op = OP_SUBB3;	  break;
	case OP_SUBF:	  op = OP_SUBF3;	  break;
	case OP_SUBI:	  op = OP_SUBI3;	  break;
	case OP_XOR:	  op = OP_XOR3;		  break;
	default:
	  break;
	}      
d10008 1
a10008 1
      if (op != OP_NOP)
d10010 61
a10070 2
	  peep_buf[ prev ].op_code = (B_0010 << 28) | op << 23 | 0x0U << 21 |
	    prev_op & 0x001f0000U | (prev_op & 0x1f) << 8 | (curr_op & 0x1f);
d10072 89
a10160 2
	  peep_buf[ prev ].writes |= writes;
	  peep_buf[ prev ].reads  |= reads;
d10162 14
a10175 1
	  fprintf( asmstream, "; peepholer: merged load and register op into triadic op\n" );
d10177 7
a10183 2
	  return TRUE;
	}
d10185 1
a10185 1
   
d10187 3
a10189 2
   * check for moving one register into another followed
   * by an immediate diadic op on that register
d10192 2
a10193 2
   *	LDI	R1, R0
   *	ADDI	1, R0
d10195 1
a10195 1
   *	ADDI3	1, R1, R0
d10197 12
d10210 1
a10210 31
  if (is_op(   prev_op, OP_LDI )               &&	/* previous operation is a load 		*/
      is_mode( prev_op, ADDR_MODE_REGISTER  )  &&	/* from one register to another 		*/
      is_mode( curr_op, ADDR_MODE_IMMEDIATE )  &&	/* and current operation is immediate	 	*/
      is_diadic( curr_op )                     &&	/* and it is diadic 				*/
      dest_of( prev_op ) == dest_of( curr_op )  )	/* and they both have the same destination 	*/
    {
      unsigned long	op        = OP_NOP;
      bool		is_signed = TRUE;
      
      
      switch ((curr_op >> 23) & 0x3f)
	{
	case OP_ADDC:	  op = OP_ADDC3;	  		break;
	case OP_ADDI:	  op = OP_ADDI3;	  		break;
	case OP_AND:	  op = OP_AND3;	 is_signed = FALSE;	break;
	case OP_ANDN:	  op = OP_ANDN3; is_signed = FALSE;	break;
	case OP_ASH:	  op = OP_ASH3;  is_signed = FALSE;	break;
	case OP_LSH:	  op = OP_LSH3;  is_signed = FALSE;	break;
	case OP_MPYI:	  op = OP_MPYI3;	  		break;
	case OP_OR:	  op = OP_OR3;	 is_signed = FALSE;	break;
	case OP_SUBB:	  op = OP_SUBB3;	  		break;
	case OP_SUBI:	  op = OP_SUBI3;	  		break;
	case OP_XOR:	  op = OP_XOR3;	 is_signed = FALSE;	break;
	default:
	  break;
	}      
#ifndef TRIADIC_BINARY_OPS_ARE_UNSIGNED
      is_signed = TRUE;
#endif
      
      /* check that immediate value will fit in triadic operation */
d10212 1
a10212 1
      if (is_signed)
d10214 24
a10237 2
	  if (!fits_in_8_bits( mask_and_sign_extend_word( curr_op, 0xFFFF )))
	    op = OP_NOP;
d10241 25
a10265 2
	  if (curr_op & 0xFF00 != 0)
	    op = OP_NOP;
d10267 2
a10268 2
      
      if (op != OP_NOP)
d10270 1
a10270 2
	  peep_buf[ prev ].op_code = (B_0011 << 28) | op << 23 | 0x0U << 21 |
	    prev_op & 0x001f0000U | (prev_op & 0x1f) << 8 | (curr_op & 0xff);
d10272 4
a10275 5
	  peep_buf[ prev ].writes |= writes;
	  peep_buf[ prev ].reads  |= reads;

	  fprintf( asmstream, "; peepholer: merged load and immediate op into triadic op\n" );

d10279 1
a10279 1
   
d10291 1
a10291 1

d10304 1
a10304 1

d10306 1
a10306 1

d10310 1
a10310 24

  /*
   * check for two register to register loads
   * with the source and destinations swapped
   *
   * eg turns:
   *	LDI	R0, R1
   *	LDI	R1, R0
   * into:
   *    LDI	R0, R1
   */

  if (is_op(   prev_op, OP_LDI )             	 &&	/* previous operation is an integer load     */
      is_op(   curr_op, OP_LDI )                 &&	/* current  operation is an integer load     */
      is_mode( prev_op, ADDR_MODE_REGISTER ) 	 &&	/* previous operation is register based      */
      is_mode( curr_op, ADDR_MODE_REGISTER ) 	 &&	/* current  operation is register based      */
      dest_of( curr_op ) == source_of( prev_op ) &&	/* current  op's dest is prev    op's source */
      dest_of( prev_op ) == source_of( curr_op  ) )	/* previous op's dest is current op's source */
    {
      fprintf( asmstream, "; peepholer: eliminated unnecessary register load\n" );

      return TRUE;
    }

a10330 3
      fprintf( asmstream, "PREV = %x, CURR = %x, source = %x or %x\n",
	      prev_op, curr_op, source_of( prev_op ), source_of( curr_op ) );
      
d10334 27
d10500 1
a10500 1
      if (type == OUT_INSTR && combine_instrs( op_code, reads, writes ))
@


1.92
log
@fixed bug in call() whereby contents of R_ATMP were only forgotten if call was to external function
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.91 1992/03/02 11:59:53 nickc Exp nickc $ */
a1279 4
#ifndef TRIADIC_BINARY_OPS_ARE_UNSIGNED
  signed_op = TRUE;
#endif
  
d1323 1
d1325 3
d1341 1
d1343 3
@


1.91
log
@fixed unsigned triadic ops
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.90 1992/02/28 18:04:25 nickc Exp nickc $ */
d4750 4
a4850 4
  /* forget about contents of R_ATMP after a function call */
  
  register_in_R_ATMP = GAP;
  
d5530 1
a5530 1
/*      fprintf( asmstream, "; words required = %ld, already placed = %ld, greatest depth = %ld\n",
@


1.90
log
@added code to optimise function initialisations
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.89 1992/02/28 12:45:22 nickc Exp nickc $ */
d44 8
d715 1
d724 1
a724 1
	      
d1280 4
d3091 1
a3091 1
  
d3302 5
a3306 3
      /*
       * load R_TMP1 with the high part offset of 'symbol' into the data table
       */
d3308 1
a3308 1
      peep_xref( X_DataSymbHi, symbol );
d3310 3
a3312 3
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
		    examines0(),
		    alters1( R_TMP1 ) );
d3314 7
a3320 7
      /*
       * load R_TMP1 with the low part offset of 'symbol' into the data table
       *
       * Note that we cannot include 'offset' in this part of the addition because
       * the sum of 'offset' and the low part of 'symbol's offset might exceeed 16
       * bits
       */
d3322 1
a3322 1
      peep_xref( X_DataSymbLo, symbol );
d3324 7
a3330 3
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
		    examines1( R_TMP1 ),
		    alters2( R_TMP1, RR_ST ) );
d3332 5
a3849 3
	       *
	       * Note that we assume here, (and elsewhere) that there will never be more than
	       * 32767 functions in one module.
d3851 9
d3861 3
a3863 1
	      peep_xref( X_DataSymbHi, symbol );
d3865 3
a3867 3
	      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
			    examines0(),
			    alters1( R_TMP1 ) );
d3869 1
a3869 6
	      /*
	       * load R_TMP1 with the low part offset of 'name' into the data slots or function table
	       *
	       * XXX - there is a potential bug here if the given offset plus the
	       * symbol's offset exceed 16 bits.
	       */
d3871 14
a3884 1
	      peep_xref( X_DataSymbLo, symbol );
d3886 9
a3894 3
	      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
			    examines1( R_TMP1 ),
			    alters2( R_TMP1, RR_ST ) );
d4265 8
d4274 1
a4274 1
      peep_xref( X_DataSymbHi, bindsym_( datasegment ) );
d4276 7
a4282 5
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, tmp, 0,
		    examines1( tmp ),
		    alters2( tmp, RR_ST ) );
      
      peep_xref( X_DataSymbLo, bindsym_( datasegment ) );
d4284 4
a4287 3
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, tmp, 0,
		    examines1( tmp ),
		    alters2( tmp, RR_ST ) );
d4528 37
a4564 19
      peep_xref( X_DataSymbHi, name );
     
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
		    examines0(),
		    alters1( R_TMP1 ) );

      /*
       * load R_TMP1 with the low part offset of 'symbol' into the data table
       *
       * XXX - this is a potential bug if the given offset plus the symbol's offset
       * exceeds 16 bits!
       */

      peep_xref( X_DataSymbLo, name );
     
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
		    examines1( R_TMP1 ),
		    alters2( R_TMP1, RR_ST ) );

d10067 4
a10070 1

@


1.89
log
@fixed more bugs with push caching
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.88 1992/02/28 12:17:05 nickc Exp nickc $ */
d3943 1
a3943 1
  if (!data_init)
d3945 22
a3966 1
      /* if we are only initialising data then skip all stages except stage 0 */
d3968 1
a3968 1
      out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, R_A1, 0,
d3978 1
a3978 1
      /* if we are initialisaing data and function then */
d4179 1
a4179 1
  
a4187 1
  
d4202 35
@


1.88
log
@updated comments and version numbers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.87 1992/02/28 12:09:42 nickc Exp nickc $ */
d1273 2
a1816 2
      offset /= sizeof_int;

d1824 2
a1953 2
      offset /= sizeof_int;
      
d1961 2
d6497 3
d8280 3
d8332 3
d8445 3
d8478 3
@


1.87
log
@changed register allocation scheme - not at version 7
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.86 1992/02/28 11:25:09 nickc Exp nickc $ */
d2994 2
a2995 2
 * version: 	2
 * date:	14/8/91
d4783 1
a4783 1
 * version:	3
d4786 5
@


1.86
log
@fixed bug whereby pending flushes were not being flushed before stack accesses
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.85 1992/02/27 17:52:43 nickc Exp nickc $ */
d391 10
a400 10
      0x08,	/*  8 => AR0 */
      0x09,	/*  9 => AR1 */
      0x0a,	/* 10 => AR2 */
      0x0b,	/* 11 => AR3 */
      0x1c,	/* 12 => R8  */
      0x1d, 	/* 13 => R8  */
      0x1e,	/* 14 => R10 */
      0x10,	/* 15 => DP  */
      0x13,	/* 16 => BK  */
      0x1f,	/* 17 => R11  */
@


1.85
log
@fixed bug in copy_memory
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.84 1992/02/27 14:09:11 nickc Exp nickc $ */
d1814 2
d1817 1
a1817 1
      offset /= sizeof_int;
d1819 5
d1954 7
d2120 7
d2275 7
d2358 7
d2439 7
d7339 2
a9177 1

@


1.84
log
@changed to reflect altererations to register naming in target.h
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.83 1992/02/27 13:42:20 nickc Exp nickc $ */
d1806 1
a1806 1
  
d1910 3
d2070 3
d2307 3
d2381 3
d3817 3
d3881 3
d5946 3
a5948 3
	     RealRegister	start,
	     int32		length,
	     int32		can_corrupt_start )
a5949 1
  int32		extra;
d5953 1
a5953 1
  if (length < 1)
a5978 4
  /* convert to word offset */

  convert_to_word_address( start, dst );
  
a5982 1
  extra   = length & (sizeof_int - 1);
d5989 1
a5989 1
  if (length == 0)
d5991 2
a5992 5
      /* do nothing */
      ;
    }
  else if (length == 1)		/* XXX - can this ever happen ? */
    {
d5995 3
a5997 3
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
		    alters1( dst ) );
d6001 2
d6005 2
a6006 2
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
d6011 1
a6011 1
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
d6013 1
a6013 1
		    alters1( dst ) );
d6019 4
d6039 4
a6060 75

  if (extra)
    {
      /* handle few remaining bytes */

      switch (extra)
	{
	case 1:
	  /* get word at current location */
	  
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines1( dst ),
			alters2( R_TMP1, RR_ST ) );

	  /* remove bottom byte */
	    
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFF,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );

	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines2( R_TMP1, dst ),
			alters0() );
	  break;
	  
	case 2:
	  /* get word at current location */
	  
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines1( dst ),
			alters2( R_TMP1, RR_ST ) );

	  /* clear bottom two bytes */
	    
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFFFF,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );

	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines2( R_TMP1, dst ),
			alters0() );
	  break;
	  
	case 3:
	  /* this instruction is load unsigned byte from address in ar into R_TMP1, ie LBU3 *AR, R_TMP1 */

	  /* load top byte of *AR into bottom byte of R_TMP1 (no sign extension) */
	  
	  outinstr( FUNC_LOAD << 28 | OP_LBU << 24 | 0x3U << 23 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_REL, dst, 0 ),
		   examines1( dst ),
		   alters2( R_TMP1, RR_ST ) );

	  /* move byte into top 8 bits */
	  
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP1, 24,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );

	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines2( R_TMP1, dst ),
			alters0() );
	  break;
	  
	default:
	  syserr( syserr_bad_length, extra );
	  return;
	}
    }
d6113 1
a6113 1
	  dest = get_free_register( &restore_ar, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, -1 );
d6984 3
@


1.83
log
@fixed bugs in peepholer
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.82 1992/02/24 11:19:34 nickc Exp nickc $ */
d383 18
a400 18
      0x00,	/*  0 =>  R0 */
      0x01,	/*  1 =>  R1 */
      0x02,	/*  2 =>  R2 */
      0x03,	/*  3 =>  R3 */
      0x04,	/*  4 =>  R4 */
      0x05,	/*  5 =>  R5 */
      0x06,	/*  6 =>  R6 */
      0x07,	/*  7 =>  R7 */
      0x1f,	/*  8 => R11 */
      0x1c,	/*  9 =>  R8 */
      0x1d,	/* 10 =>  R9 */
      0x1e,	/* 11 => R10 */
      0x10,	/* 12 =>  DP */
      0x13, 	/* 13 =>  BK */
      0x08,	/* 14 => AR0 */
      0x09,	/* 15 => AR1 */
      0x0a,	/* 16 => AR2 */
      0x0b,	/* 17 => AR3 */
@


1.82
log
@added COND_EXEC support
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.81 1992/02/21 14:52:52 nickc Exp nickc $ */
d1775 8
a1782 1
      syserr( syserr_offset_out_of_range, offset );
d1869 2
a1870 1
	  syserr( syserr_offset_out_of_range, offset );
d1872 5
a1876 1
	  return;
d2014 4
a2017 1
	  syserr( syserr_offset_out_of_range, offset );
d2019 3
a2021 1
	  return;
d2172 2
a2173 1
	  syserr( syserr_offset_out_of_range, offset );
d2175 5
a2179 1
	  return;
d2811 1
a2811 1
	  syserr( syserr_offset_out_of_range, off );
d4632 1
a4632 1
	  syserr( syserr_offset_out_of_range, off );
d5547 1
a5547 1
       * for the frmae pointer, BUT, if we did not push any
d6125 1
a6135 1
  int32		extra;
d6141 2
a6142 4
  /*
   * NB/ This code assumes that the addresses
   * in the pointers are WORD aligned.
   */
d6144 3
a6146 2
  if (length < 1)
    return;
a6148 7
   * round length down to nearest word
   */
  
  extra   = length & (sizeof_int - 1);
  length &= ~(sizeof_int - 1);

  /*
a6184 5
  /* convert to word pointers */

  convert_to_word_address( src, source );
  convert_to_word_address( dst, dest );
  
d6189 1
a6189 1
  if (length == 0)
d6191 6
a6196 7
      ;
    }
  else if (length == sizeof_int)
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, source, 1 ),
		    examines1( source ),
		    alters3( R_TMP1, RR_ST, source ) );
d6198 3
a6200 3
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
		    examines2( dest, R_TMP1 ),
		    alters1( dest ) );
d6208 3
d6212 1
a6212 1
       * find a register than can be used in a parallel op
a6220 2
	  tmp = R_TMP1;
	  
d6223 3
a6225 3
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, source, 1 ),
			examines1( source ),
			alters3( tmp, RR_ST, source ) );
d6229 2
a6230 2
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
			examines2( dest, R_TMP1 ),
d6235 1
a6235 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, source, 1 ),
d6237 1
a6237 1
			alters3( tmp, RR_ST, source ) );
d6239 1
a6239 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
d6241 1
a6241 1
			alters1( dest ) );
d6247 2
a6248 2
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, source, 1 ),
			examines1( source ),
d6261 3
a6263 3
		   build_parallel_indirect( INDIRECT_POST_INCR, dest ) << 8 |
		   build_parallel_indirect( INDIRECT_POST_INCR, source ),
		   examines3( source, tmp, dest ),
d6266 1
a6266 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
d6268 1
a6268 1
			alters1( dest ) );
d6277 5
d6349 4
a6371 75
  if (extra)
    {
      /* oh oh, copy bytes at end of block */

      /* get the word at 'dest' into R_TMP1 */
	  
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dest, 0 ),
		    examines1( dest ),
		    alters2( R_TMP1, RR_ST ) );
      
      switch (extra)
	{
	case 1:
	  /* merge bottom byte at 'source' into R_TMP1 */
	  
	  outinstr( FUNC_LOAD << 28 | OP_MB << 24 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_REL, source, 0 ),
		   examines1( source ),
		   alters2( R_TMP1, RR_ST ) );
	  
	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( dest, R_TMP1 ),
			alters0() );
	  break;
	  
	case 2:
	  /* merge bottom half-word at 'source' into R_TMP1 */
	  
	  outinstr( FUNC_LOAD << 28 | OP_MH << 24 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_REL, source, 0 ),
		   examines1( source ),
		   alters2( R_TMP1, RR_ST ) );
	  
	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( R_TMP1, dest ),
			alters0() );
	  break;
	  
	case 3:
	  /* get the word pointed to by 'source' into 'source' */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_REL, source, 0 ),
			examines1( source ),
			alters2( source, RR_ST ) );

	  /* shift up by 8 bits to remove top byte */

	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, source, 8,
			examines1( source ),
			alters2( source, RR_ST ) );

	  /* load contents of 'source' into R_TMP1 right shifted by 1 byte and merged with the top byte of R_TMP1 */
	  
	  outinstr( FUNC_LOAD << 28 | OP_LWR << 24 | 0x1U << 23 | ADDR_MODE_REGISTER << 21 |
		   hardware_register( R_TMP1 ) << 16 | source,
		   examines2( source, R_TMP1 ),
		   alters2( R_TMP1, RR_ST ) );

	  /* store R_TMP1 into 'dest' */

	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( R_TMP1, dest ),
			alters0() );
	  break;
	  
	default:
	  syserr( syserr_bad_length, extra );
	  return;
	}
    }

d6689 1
a6689 1
       *    addr    - byte offset
d6699 15
a6713 5
      out_triadic_op( OP_AND3, R_TMP1, addr,
		     half_word_op ? 0x2 : 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( addr ),
		     alters2( R_TMP1, RR_ST ) );
  
d8170 1
a8170 1
#ifdet TARGET_HAS_COND_EXEC
d9055 2
a9056 1
#define source_of( instruction )	  ((instruction) & 0xff)
d9660 2
a9661 2
 * returns TRUE if the op_code has the potential to be converted into
 * a parallel operation, returns FALSE otherwise
d9664 1
a9664 1
static bool
d9675 1
a9675 1
      return TRUE;
d9678 1
a9678 1
  return FALSE;
d9720 4
a9723 4
  bool		prev_store;
  bool		prev_load;
  bool		curr_store;
  bool		curr_load;
d10007 26
d10047 1
a10047 1
  if (!prev_load && !prev_store && !curr_load && !curr_store)
d10050 1
a10050 1
  if (prev_load && curr_load)
d10052 3
a10054 1
      /* check that the destination of the loads */
d10056 3
a10058 3
      if (((prev_op >> 16) & 0x1F) == ((curr_op >> 16) & 0x1F))
	{
	  fprintf( asmstream, "; peepholer: WARNING: two successive loads with the same destination\n" );
d10060 1
a10060 1
	  /* ignore first load */
d10062 3
a10064 3
	  peep_buf[ prev ].op_code = curr_op;
	  peep_buf[ prev ].reads   = reads;
	  peep_buf[ prev ].writes  = writes;
d10066 2
a10067 18
	  return TRUE;
	}
      
      peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                         (OP_LDI_LDI << 25)                     |
	                         (prev_op & (B_111 << 16)) << (22 - 16) |
	                         (curr_op & (B_111 << 16)) << (19 - 16) |
	                         (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
		                 (prev_op & (0xFF  <<  8)) >> ( 8 -  0);

      fprintf( asmstream, "; peepholer: transformed LDI, LDI into LDI || LDI\n" );
      
      return TRUE;
    }

  if (prev_load && curr_store)
    {
      /* check that the destination of the load is not the source of the store */
a10068 2
      if (((prev_op >> 16) & 0x1F) != ((curr_op >> 16) & 0x1F))
	{
d10070 5
a10074 5
	                             (OP_LDI_STI << 25)                     |
				     (prev_op & (B_111 << 16)) << (22 - 16) |
				     (curr_op & (B_111 << 16)) << (16 - 16) |
				     (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
				     (prev_op & (0xFF  <<  8)) >> ( 8 -  0);
d10076 5
a10080 1
	  fprintf( asmstream, "; peepholer: transformed LDI, STI into LDI || STI\n" );
d10084 3
a10086 1
    }
d10088 14
a10101 10
  if (prev_store && curr_load)
    {
      peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                         (OP_LDI_STI << 25)                     |
	                         (curr_op & (B_111 << 16)) << (22 - 16) |
	                         (prev_op & (B_111 << 16)) << (16 - 16) |
	                         (prev_op & (0xFF  <<  8)) << ( 8 -  8) |
		                 (curr_op & (0xFF  <<  8)) >> ( 8 -  0);

      fprintf( asmstream, "; peepholer: transformed STI, LDI into LDI || STI\n" );
d10103 3
a10105 15
      return TRUE;
    }

  if (prev_store && curr_store)
    {
      peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                         (OP_STI_STI << 25)                     |
	                         (prev_op & (B_111 << 16)) << (22 - 16) |
	                         (curr_op & (B_111 << 16)) << (16 - 16) |
	                         (curr_op & (0xFF  <<  8)) << ( 8 -  8) |
		                 (prev_op & (0xFF  <<  8)) >> ( 8 -  0);

      fprintf( asmstream, "; peepholer: transformed STI, STI into STI || STI\n" );
      
      return TRUE;
d10107 1
a10107 5

  if (!prev_store && !curr_store)
    return FALSE;

  if (prev_store && is_suitable_triadic( curr_op ))
d10109 1
a10109 6
      int32	new_op = 0;

      
      /* find new op code */
      
      switch ((curr_op >> 23) & B_11111)
d10111 6
a10116 23
	case OP_ADDF3:  new_op = OP_ADDF3_STF;  break;
	case OP_ADDI3:  new_op = OP_ADDI3_STI;  break;
	case OP_AND3:   new_op = OP_AND3_STI;   break;
	case OP_ASH3:   new_op = OP_ASH3_STI;   break;
	case OP_LSH3:   new_op = OP_LSH3_STI;   break;
	case OP_MPYF3:  new_op = OP_MPYF3_STF;  break;
	case OP_MPYI3:  new_op = OP_MPYI3_STI;  break;
	case OP_OR3:    new_op = OP_OR3_STI;    break;
	case OP_SUBF3:  new_op = OP_SUBF3_STF;  break;
	case OP_SUBI3:  new_op = OP_SUBI3_STI;  break;
	case OP_XOR3:   new_op = OP_XOR3_STI;   break;
	
	case OP_ADDC3:
	case OP_ANDN3:
	case OP_CMPF3:
	case OP_CMPI3:
	case OP_SUBB3:
	case OP_TSTB3:
	case OP_MPYSHI3:
	case OP_MPYUHI3:
	default:
	  break;
	}
d10118 3
a10120 9
      if (new_op)
	{
	  peep_buf[ prev ].op_code = (B_11   << 30)                         |
	                             (new_op << 25)                         |
	                             (curr_op & (B_111 << 16)) << (22 - 16) |
		                     (curr_op & (B_111 <<  8)) << (19 -  8) |
		                     (prev_op & (B_111 << 16)) << (16 - 16) |
		                     (prev_op & (0xFF  <<  8)) << ( 8 -  8) |
		                     (curr_op & 0xFF)                       ;
d10122 2
a10123 2
	  fprintf( asmstream, "; peepholer: transformed triadic & store into parallel op\n" );
	  
d10126 1
a10126 35
    }
  else if (is_suitable_triadic( prev_op ))
    {
      int32	new_op = 0;

      
      /* find new op code */
      
      switch ((prev_op >> 23) & B_11111)
	{
	case OP_ADDF3:  new_op = OP_ADDF3_STF;  break;
	case OP_ADDI3:  new_op = OP_ADDI3_STI;  break;
	case OP_AND3:   new_op = OP_AND3_STI;   break;
	case OP_ASH3:   new_op = OP_ASH3_STI;   break;
	case OP_LSH3:   new_op = OP_LSH3_STI;   break;
	case OP_MPYF3:  new_op = OP_MPYF3_STF;  break;
	case OP_MPYI3:  new_op = OP_MPYI3_STI;  break;
	case OP_OR3:    new_op = OP_OR3_STI;    break;
	case OP_SUBF3:  new_op = OP_SUBF3_STF;  break;
	case OP_SUBI3:  new_op = OP_SUBI3_STI;  break;
	case OP_XOR3:   new_op = OP_XOR3_STI;   break;
	  
	case OP_ADDC3:
	case OP_ANDN3:
	case OP_CMPF3:
	case OP_CMPI3:
	case OP_SUBB3:
	case OP_TSTB3:
	case OP_MPYSHI3:
	case OP_MPYUHI3:
	default:
	  break;
	}

      if (new_op)
d10129 1
a10129 1
	                             (new_op << 25)                         |
d10131 10
a10140 7
		                     (prev_op & (B_111 << 8))  << (19 -  8) |
		                     (curr_op & (B_111 << 16)) << (16 - 16) |
		                     (curr_op & (0xFF << 8))   << ( 8 -  8) |
		                     (prev_op & 0xFF)                       ;
	  
	  fprintf( asmstream, "; peepholer: transformed triadic and store into parallel op\n" );
	  
d10144 2
a10145 2

  return FALSE;
@


1.81
log
@added code to support unsigned FIX and FLOAT
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.80 1992/02/20 18:51:14 nickc Exp nickc $ */
d895 6
a900 6
		 int32		condition,
		 int32		addressing_mode,
		 RealRegister	destination,
		 int32		source,		/* NB/ doubles up as a RealRegister */
		 int32		reads,
		 int32		writes )
d1980 1
a1980 1
      /* convert source pointer to word  offset by dividing by sizeof_int (here assumed to be 4) */
d3169 4
d7091 180
d7292 3
d7407 9
d7427 1
a7427 1
      return;
d7437 1
a7437 1
      return;
d7452 1
a7452 1
      return;
d7468 1
a7468 1
      return;
d7485 1
a7485 1
      return;
d7545 1
a7546 7
      if (r1r == R_SP)
	{
	  syserr( "back end: show_instruction: loading stack pointer with a constant address is not yet supported" );
	}
      
      return;
      
d7595 14
a7608 1
      conditional_branch_to( op & Q_MASK, (LabelNumber *)m );
d7619 1
a7619 1
      return;
d7757 1
a7757 1
      return;
d7798 5
d7804 1
a7804 2

/* XXX - unary ops */
d7820 1
a7820 1
      return;      
d7829 1
a7829 1
      return;
d7839 1
a7839 2
      
      return;
d7850 1
a7850 2
      
      return;
d7860 2
a7862 3
      return;
#endif
      
a7899 1
#endif
a7900 3
      /* drop through */
      
#ifdef CHECK_FLOAT_OPS      
d7907 12
a7918 1
      move_register( mr, r1r, TRUE );
d7923 1
a7923 1
      if (r1r == mr && opm == J_MOVR)
d7925 14
a7938 3
      
      move_register( mr, r1r, FALSE );
      
d7980 1
a7980 1
      return;
d8023 1
a8023 1
      return;
d8106 3
a8108 3
#endif
      
      return;
d8134 2
a8135 161
#ifdef CHECK_FLOAT_OPS
      if (!is_float( mr ))
	{
	  syserr( "back end: trying a fix a non floating point register" );
	}      
#endif
#ifndef TARGET_LACKS_UNSIGNED_FIX
      if (opm & J_SIGNED)
#endif
	{
	  bool		must_save = FALSE;
	  RealRegister	dest;


	  out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, r1r, mr,
			examines1( mr ),
			alters2( r1r, RR_ST ) );
	      
	  /*
	   * ANSI spec says that J_FIX must truncate floating point
	   * numbers, but the OP_FIX rounds towards negative infinity
	   * so ....
	   */
	  
	  /* get hold of a free floating point register */
	      
	  dest = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x1c, 0x1d, 0x1e, -1 );
	  /* if we must then save a register on the stack */
	  
	  if (must_save)
	    dpush( dest );
	  
	  /* negate original number */
	  
	  out_diadic_op( OP_NEGF, ADDR_MODE_REGISTER, dest, mr,
			examines1( mr ),
			alters2( dest, RR_ST ) );
	  
	  /* fix this number */
	  
	  out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, dest, dest,
			examines1( dest ),
			alters2( dest, RR_ST ) );
	  
	  /* negate the result */
	  
	  out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, dest, dest,
			examines1( dest ),
			alters2( dest, RR_ST ) );
	  
	  /* if the result is negative, then so was the original */
	  
	  conditional_load( Q_LT, ADDR_MODE_REGISTER, r1r, dest,
			   examines2( dest, RR_ST ),
			   alters1( r1r ) );
	  
	  /* restore register if necessary */
	      
	  if (must_save)
	    dpop( dest );
	}
#ifndef TARGET_LACKS_UNSIGNED_FIX
      else
	{
	  bool		must_save = FALSE;
	  RealRegister	dest;
	  LabelNumber *	l;
	  
	  
	  /*
	   * ANSI spec does not say what to do if the FP value is < 0.0
	   * All the compilers I have tested so far just return the bit
	   * pattern for the negative number, ie
	   *    ((unsigned int) -2.0) = 0xfffffffe
	   * which I consider to be wrong.  I would expect rounding to 0.0, ie
	   *    ((unsigned int) -2.0) = 0x00000000
	   *
	   * The real problem, however is when the FP number does not fit
	   * in a signed int, but it would fit in an unsigned int.  The
	   * compiler has code to cope with this, but I am hoping that I
	   * will be able to produce better code here.
	   */

	  /* convert the number */
	  
	  out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, r1r, mr,
			examines1( mr ),
			alters2( r1r, RR_ST ) );

#ifdef UNSIGNED_FIX_GIVES_0_FOR_NEGATIVE
	  conditional_load( Q_LT, ADDR_MODE_IMMEDIATE, r1r, 0,
			   examines1( RR_ST ),
			   alters1( r1r ) );
#endif
	  if (mr == r1r)
	    {
	      /* get hold of a free floating point register */
	  
	      dest = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x1c, 0x1d, 0x1e, -1 );
	    }
	  else
	    {
	      dest = r1r;
	    }

	  l = nextlabel();
	  
	  /* if integer overflow did not occur, then skip the next bit */
	  
	  conditional_branch_to( C_NV, l );

	  /* if we must then save a register on the stack */

	  if (must_save)
	    dpush( dest );
	  
	  /* load 2e31 */
	  
	  load_integer( R_TMP1, 0x1f000000U, FALSE );

	  /* save on stack as an integer */
	  
	  ipush( R_TMP1 );

	  /* pop the value off the stack as a float */
		 
	  fpop( dest );

	  /* subtract 2^31 from the original number */
	      
	  out_triadic_op( OP_SUBF3, r1r, mr, dest, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			 examines2( mr, dest ),
			 alters2( r1r, RR_ST ) );

	  /* convert the number again */
	      
	  out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, r1r, r1r,
			examines1( r1r ),
			alters2( r1r, RR_ST ) );

	  /* then add back in 2^31 */

	  load_integer( R_TMP1, 0x80000000U, FALSE );

	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, r1r, R_TMP1,
			examines2( r1r, R_TMP1 ),
			alters2( r1r, RR_ST ) );

	  if (must_save)
	    dpop( dest );

	  /* prevent these instructions from being peepholed */
	     
	  flush_peepholer( "unsigned fix" );

	  /* target the end of the branch */
	  
	  setlabel( l );
	}
#endif /* ! TARGET_LACKS_UNSIGNED_FIX */
      return;
d8156 1
a8156 1
      return;
d8168 1
a8168 2

      return;
d8180 1
a8180 2
      
      return;
d8188 20
a8207 3
      
      load_float( r1r, (FloatCon *)m, TRUE );
      
d8216 19
a8235 2
      load_float( r1r, (FloatCon *)m, FALSE );
      
d8244 24
a8267 2
      
      load_integer( r1r, m, FALSE );
d8295 1
a8295 1
      return;
d8297 22
d8344 1
a8344 1
      return;
d8347 1
a8347 1
    case J_SUBFK:
d8349 3
a8351 3
       * subtract floating point value 'm' from
       * the contents of register 'r2r' and place
       * result in register 'r1r'
d8354 2
a8355 3
      float_immediate_op( OP_SUBF, r1r, r2r, (FloatCon *)m, FALSE );

      return;
d8357 1
a8357 1
    case J_SUBDK:
d8359 3
a8361 3
       * subtract double precision value 'm' from
       * the contents of register 'r2r' and place
       * result in register 'r1r'
d8364 2
a8365 3
      float_immediate_op( OP_SUBF, r1r, r2r, (FloatCon *)m, TRUE );

      return;
d8387 1
a8387 1

d8392 2
a8393 2
      
      return;
d8396 1
a8396 1
    case J_ADDFK:
d8398 1
a8398 1
       * add floating point value 'm' to the
d8403 2
a8404 3
      float_immediate_op( OP_ADDF, r1r, r2r, (FloatCon *)m, FALSE );

      return;
d8406 1
a8406 1
    case J_ADDDK:
d8408 1
a8408 1
       * add double precision value 'm' to the
d8413 3
a8415 4
      float_immediate_op( OP_ADDF, r1r, r2r, (FloatCon *)m, TRUE );

      return;
#endif
d8433 1
a8433 26

      return;

#ifdef TARGET_HAS_FP_LITERALS
    case J_MULFK:
      /*
       * multiply the floating point value 'm' with the
       * contents of register 'r2r' and place
       * the result in register 'r1r'
       */

      float_immediate_op( OP_MPYF, r1r, r2r, (FloatCon *)m, FALSE );

      return;
      
    case J_MULDK:
      /*
       * multiply the double precision value 'm' with the
       * contents of register 'r2r' and place
       * the result in register 'r1r'
       */

      float_immediate_op( OP_MPYF, r1r, r2r, (FloatCon *)m, TRUE );

      return;
#endif
d8443 1
a8443 2
      
      return;
d8453 1
a8453 2
      
      return;
d8463 1
a8463 2
      
      return;
d8482 1
a8482 1
      return;
d8486 1
a8486 1

d8492 1
a8492 1
      return;
d8512 1
a8512 1
      return;
d8522 1
a8522 1
      return;
d8539 1
a8539 1
      return;
d8543 1
a8543 2

      return;
d8553 1
a8553 2

      return;
d8563 1
a8563 2
      
      return;
d8573 1
a8574 2
      return;
      
d8583 1
a8583 2

      return;
d8593 1
a8593 2

      return;
d8613 1
a8613 2

      return;
d8633 1
a8633 2

      return;
d8635 1
a8635 1
/* XXX integer loads and stores */
d8645 1
a8645 1
      return;
d8655 1
a8655 1
      return;
d8664 2
d8674 1
a8674 1
      return;
d8685 1
a8685 2
      
      return;
d8696 1
a8696 2
      
      return;
d8706 1
a8706 1
      return;
d8716 1
a8716 1
      return;
d8737 1
d8741 1
a8741 2
      
      return;
d8751 1
a8751 1
      return;
d8761 1
a8761 2
      
      return;
d8771 1
a8771 1
      return;
d8781 1
a8781 1
      return;
d8791 1
a8791 1
      return;
d8802 1
a8802 2
      
      return;
d8813 1
a8813 2
      
      return;
d8823 1
a8823 1
      return;
d8833 1
a8833 1
      return;
d8843 1
a8843 1
      return;
d8853 1
a8853 2
      
      return;
d8863 1
a8863 3
      
      return;
      
a8864 2
      /* XXX - routine entry and exit */
      
d8889 1
a8889 1
      return;
d8900 1
a8900 1
      return;
a8910 1

d8938 1
a8938 1
      return;
d8948 1
a8948 1
      return;
d8958 1
a8958 1
      return;
d8978 2
a8979 1
      return;
d9026 2
d9029 7
d9610 1
a9610 1
/* 	  fprintf( asmstream, "; eliminated a NOP\n" ); */
d10396 1
a10396 1
      dest_of( op ) == r                 )	/* and the destination register is the given reg  */
d10478 1
a10478 1
      dest_of( op ) == r                 )
d10482 1
a10482 1
      return source_of( op );
@


1.80
log
@moved comment
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.79 1992/02/20 17:48:03 nickc Exp nickc $ */
d889 35
a923 1
#ifdef NOT_USED
d926 1
a926 1
 * build and send a simple load conditional op code
d930 7
a936 7
out_conditional_load(
		     int32		condition,
		     int32		addressing_mode,
		     RealRegister	destination,
		     int32		source,		/* NB/ doubles up as a RealRegister */
		     int32		reads,
		     int32		writes )
a940 1
  condition       &= 0x1f;
d945 1
a945 1
  op = (OP_LDIc << 28) | C_FROMQ( condition ) << 23 | hardware_register( destination ) << 16;
d958 1
a958 1
} /* out_conditional_load */
a959 2
#endif /* NOT_USED */

d1174 5
a1178 7
      outinstr( (OP_LDIc << 28)               |
	       (C_FROMQ( Q_AL ) << 23)        |
	       (ADDR_MODE_IMMEDIATE << 21)    |
	       (hardware_register( r ) << 16) |
	       (n & 0xFFFFU),
	       examines0(),
	       alters1( r ) );
d1187 19
d1207 2
a1208 1
  else if ((n & 0xffff0000U) == 0xffff0000U)
d1212 1
a1212 10
      if (must_save_st)
	{
	  /* save ST */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_TMP3, RR_ST,
			examines1( RR_ST ),
			alters2( R_TMP3, RR_ST ) );
	}
      
      out_diadic_op( OP_NOT, ADDR_MODE_IMMEDIATE, r, ~n,
a1214 9
      
      if (must_save_st)
	{
	  /* restore ST */
      
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, RR_ST, R_TMP3,
			examines1( R_TMP3 ),
			alters1( RR_ST ) );
	}
a1229 17
      if (must_save_st)
	{
	  /*
	   * There is no way to load this value using immediate ops
	   * without affecting the contents of the status register.
	   * Since this routine can be called from anywhere we may
	   * not have a temporary register available, but we assume
	   * that the third temporary is free ....
	   */

	  /* save ST */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_TMP3, RR_ST,
			examines1( RR_ST ),
			alters2( R_TMP3, RR_ST ) );
	}
      
d1241 5
a1245 4

      if (must_save_st)
	{
	  /* restore ST */
d1247 3
a1249 4
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, RR_ST, R_TMP3,
			examines1( R_TMP3 ),
			alters1( RR_ST ) );
	}
d1251 1
a1251 1

d1582 4
a1585 4
load_floating_point(
		    RealRegister	r,		/* register into which constant is to be loaded	*/
		    FloatCon * 		fc,		/* constant to be loaded 			*/
		    bool		is_double )	/* true if the constant is double precision	*/
d1609 2
a1610 2
  /* fprintf( asmstream, "failed to load %s as a single instruction, high = %x, low = %x\n",
     fc->floatstr, high, low ); */
d1646 1
a1646 1
      
d1662 4
d1694 1
a1694 1
} /* load_floating_point */
d2705 2
a2706 2
			      int32	condition,
			      int32	num_to_skip )
d2718 2
a2719 2
  outdelayed( OP_BRcD << 24 | 0x1U << 21 | C_FROMQ( condition ) << 16 | (num_to_skip & 0xffff),
	     condition == Q_AL ? examines0() : examines1( RR_ST ),
d2785 1
a2785 1
	  conditional_skip_instructions( condition, off );
d7804 3
d7817 3
d7832 1
a7832 1
#endif      
d7837 49
d7889 3
d7902 3
d7917 149
a8065 4
#endif      
      out_diadic_op( OP_FIX, ADDR_MODE_REGISTER, r1r, mr,
		    examines1( mr ),
		    alters2( r1r, RR_ST ) );
d8067 5
d8128 1
a8128 1
      load_floating_point( r1r, (FloatCon *)m, TRUE );
d8139 1
a8139 1
      load_floating_point( r1r, (FloatCon *)m, FALSE );
@


1.79
log
@added support for small module model
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.78 1992/02/20 16:36:23 nickc Exp nickc $ */
a2982 5
  /*
   * XXX - we are assuming that the module number fits into 16 bits
   * (ie that there will never be more that 32767 modules) ...
   */

d2986 5
d3042 5
@


1.78
log
@fixed latest peephole optimisations
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.77 1992/02/20 10:20:15 nickc Exp nickc $ */
a2981 1

d2985 1
a2985 1
   * (ie that there will never be more that 65535 modules) ...
d2988 5
a2992 3
  /*
   * load the module table address into temporary address register
   */
d2994 3
a2996 3
  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, tmp, R_MT,
		examines1( R_MT ),
		alters2( tmp, RR_ST ) );
d2998 3
a3000 4
  /*
   * add in the offset of our module's entry in the module table
   * we are assuming that there will never be more than 65535 modules
   */
d3002 9
a3010 9
  /*
   * indicate that the following instruction loads the module
   * number of the current module as the least 16 significant bits
   * of the instruction.  This number will actually have to be
   * inserted at link time (rather than now), so we use the cross
   * reference facility to ensure that the linker will patch
   * this instruction.  This instruction loads the WORD offset
   * from the module table pointer.
   */
d3012 1
a3012 1
  peep_xref( X_Modnum, symbol );
d3014 18
a3031 2
  if (iscode && split_module_table)
    {
d3033 1
a3033 4
       * if we are accessing the function table of a split
       * module table then we actually want the next word on
       *
       * XXX - we are assuming that there will never be more than 32767 modules
d3035 4
a3038 4
      
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 1,
		    examines0(),
		    alters2( tmp, RR_ST ) );
d3042 21
a3062 3
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
		    examines0(),
		    alters2( tmp, RR_ST ) );
a3064 8
  /*
   * get the appropriate pointer out of the module table
   */
  
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, tmp, 0 ),
		examines1( tmp ),
		alters2( r, RR_ST ) );

@


1.77
log
@added support for floating point immediate operations
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.76 1992/02/19 17:06:11 nickc Exp nickc $ */
d1139 1
a1139 9
  if (n == 0)
    {
      /*
       * we use OP_LDHI here which does not set the condition codes
       */
	 
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, r, 0, examines0(), alters1( r ) );
    }
  else if (fits_in_16_bits( n ))
d1141 1
a1141 1
      /* 16 bit signed immediate  */
d1143 7
a1149 3
      out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, r, n,
		    examines0(),
		    alters2( r, RR_ST ) );
d1163 9
d1174 10
a1183 1
		    alters1( r ) );
a1688 3
  int	n;

  
a1744 12
  if (!no_peepholing)
    {
      n = peep_shift_back( 2 );
      
      if (n)
	fprintf( asmstream, "; peepholer: swapped order of instructions\n" );
    }
  else
    {
      n = 0;
    }
      
a1753 3
      
      if (n)
	n = peep_shift_back( n );
a1821 3
      int	n;

      
a1829 12
      if (!no_peepholing)
	{
	  n = peep_shift_back( 2 );

	  if (n)
	    fprintf( asmstream, "; peepholer: swapped order of instructions" );
	}
      else
	{
	  n = 0;
	}
      
a1840 3

	  if (n)
	    n = peep_shift_back( n );
d2448 1
a2448 1
  
d2492 1
a2492 1
	  if (peep_sets_status_reg( r )) /* XXX - do I need to check what kind of test is being made ? */
d3175 1
a3175 1
       * the sum of 'offset' and the low part of 'symbol's offset mihgt exceeed 16
d3248 4
d3887 5
a3891 1
      
d4173 4
a6858 1
#if 0	  
d6867 6
a6877 1
#endif
d8338 1
a8338 1
      non_word_op( r1r, r2r, m, FALSE, dead & J_DEAD_R2, opm == J_LDRBK + J_SIGNED, FALSE, TRUE );
d8743 1
d8754 3
a8756 2
	 int32	a,
	 int32	b )
d8769 6
d9243 1
a9243 1
      if (can_swap( delayed, prev ))
d9696 2
d9699 1
a9699 1
    return FALSE;		/* both instructions alter the same register (except the status register) */
d10000 17
a10016 1
       
d10170 1
a10170 1
      if (can_swap( last, prev ))
d10179 1
a10179 1
	  fprintf( asmstream, "swapped " );
d10199 2
a10200 1
	  fprintf( asmstream, "could not swap " );
d10202 1
a10202 1
	  decode_instruction( peep_buf[ prev ].op_code );
d10206 1
a10206 1
	  decode_instruction(  peep_buf[ last ].op_code );
d10209 1
a10209 1
	  
@


1.76
log
@added some more peepholing
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.75 1992/02/19 15:57:19 nickc Exp nickc $ */
d167 1
d211 1
d1330 3
a1332 1
 * returns TRUE if the floating point value is suitable for use by the op code indicated
d1335 5
a1339 4
bool
fpliteral(
	  FloatCon *	fc,
	  J_OPCODE	op )
d1341 7
a1347 2
  int32		high;
  int32		low;
d1349 14
d1364 3
a1366 3
  high = IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &low );
  
  /* check to see if the value fits in 16 bits */
a1367 2
  if (low == 0 && high == 0x80000000U)
    {
d1369 3
d1373 2
a1374 1
      return TRUE;
d1376 19
a1394 5
  else if ((low & 0xfffff) == 0 &&
	   (((high & 0xf8000000U) == 0) || ((high & 0xf8000000U) == 0xf8000000U)))
    {
      return TRUE;
    }
d1408 5
a1412 4
		   int32	diadic_op,	/* diadic version of the operation */
		   RealRegister	dest,		/* detination register for operation */
		   RealRegister	source,		/* source register for operation */
		   FloatCon *	fc )		/* the immediate value */
d1414 3
a1416 4
  int32		high;
  int32		low;


d1421 1
a1421 1
  if (!is_float( dest ))
d1424 6
d1431 2
a1432 1
  high = IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &low );
d1436 1
a1436 1
  if (low == 0 && high == 0x80000000U)
d1438 1
a1438 3
      if ((diadic_op == OP_ADDF ||
	   diadic_op == OP_SUBF ) &&
	  !no_peepholing)
d1440 1
a1440 1
	  if (source != dest)
d1442 12
a1453 3
	      out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, dest, source,
			    examines1( source ),
			    alters2( dest, RR_ST ) );
d1455 1
a1455 1
	      fprintf( asmstream, "; peepholer: transformed addition into move" );
d1457 1
a1457 1
	  else
d1459 8
a1466 1
	      fprintf( asmstream, "; peepholer: eliminating op %lx with value 0", diadic_op );
d1468 2
a1469 2

	  return;
d1471 1
a1471 5
      else
	{
	  cc_warn( "possibly generating unneccessary op code %lx!", diadic_op );
	}

d1474 1
a1474 1
	  out_diadic_op( diadic_op, ADDR_MODE_IMMEDIATE, source,
d1485 1
a1485 1
	  out_diadic_op( diadic_op, ADDR_MODE_IMMEDIATE, dest,
d1491 2
a1492 2
  else if ((low & 0xfffff) == 0 &&
	   (((high & 0xf8000000U) == 0) || ((high & 0xf8000000U) == 0xf8000000U)))
d1494 2
a1495 9
      if (dest != source)
	{
	  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, dest, source,
			examines1( source ),
			alters2( dest, RR_ST ) );
	}

      out_diadic_op( diadic_op, ADDR_MODE_IMMEDIATE, dest, high >> 12,
		    examines1( dest ),
a1496 2
      
      return;
d1498 4
a1501 4
  else
    {
      syserr( "back end: float_immediate_op: asked to perform an op with a floating point value that does not fit" );
    }
d1514 7
a1520 9
		RealRegister	r,
		FloatCon *	fc,
		int32 		test )
{ 
  int32		high;
  int32		low;


  high = IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &low );
d1529 1
a1529 1
  /* check to see if the value fits in 16 bits */
d1531 1
a1531 1
  if (low == 0 && high == 0x80000000U)
d1533 1
a1533 6
      /* catch 0.0 */
	  
      out_diadic_op( OP_CMPF, ADDR_MODE_IMMEDIATE, r,
		    0x8000,
		    examines1( r ),
		    alters1( RR_ST ) );
d1537 5
a1541 10
  else if ((low & 0xfffff) == 0 &&
	   (((high & 0xf8000000U) == 0) || ((high & 0xf8000000U) == 0xf8000000U)))
    {
      out_diadic_op( OP_CMPF, ADDR_MODE_IMMEDIATE, r,
		    high >> 12,
		    examines1( r ),
		    alters1( RR_ST ) );

      return;
    }
a1542 2
  syserr( "back end: compare_float: asked to compare with a floating point value that does not fit" );
  
d1555 3
a1557 3
		    RealRegister	r,	/* register into which constant is to be loaded	*/
		    FloatCon * 		fc,	/* constant to be loaded 			*/
		    bool		dble )	/* true if the constant is double precision	*/
d1559 2
a1560 1
  int32	disp;
d1570 1
a1570 1
  /* handle special cases */
d1572 1
a1572 1
  if (dble)
d1574 3
a1576 2
      int32	high;
      int32	low;
d1578 2
d1581 8
a1588 25
      high = IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &low );
      
      /* check to see if the value fits in 16 bits */

      if (low == 0 && high == 0x80000000U)
	{
	  /* catch 0.0 */
	  
	  out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r,
			0x8000,
			examines0(),
			alters2( r, RR_ST ) );

	  return;
	}
      else if ((low & 0xfffff) == 0 &&
	  (((high & 0xf8000000U) == 0) || ((high & 0xf8000000U) == 0xf8000000U)))
	{
	  out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r,
			high >> 12,
			examines0(),
			alters2( r, RR_ST ) );

	  return;
	}
d1590 1
a1590 10
      /* fprintf( asmstream, "failed to load %s as a single instruction, high = %x, low = %x\n",
	      fc->floatstr, high, low ); */
	      
      /*
       * Other op codes we could try ....
       *
       * FLOAT, LDE, LDM, RND, FLOAT
       */
      
      /* place value in constant table */
d1592 2
a1605 18
      int32	val = IEEE_to_single_float( fc->floatbin.fb.val );


      /* check to see if the value fits in 16 bits */
      
      if (((val & 0xfff) == 0) &&
	  (((val & 0xf8000000U) == 0) || ((val & 0xf8000000U) == 0xf8000000U)))
	{
	  out_diadic_op( OP_LDF, ADDR_MODE_IMMEDIATE, r,
			val >> 12,
			examines0(),
			alters2( r, RR_ST ) );

	  return;
	}
      
      /* place value in constant table */
  
d1675 3
d1732 14
d1755 3
d1826 3
d1835 14
d1860 3
d7594 12
d7614 1
a7614 1
      compare_float( r2r, (FloatCon *)m, op & Q_MASK );
d7617 1
d7957 11
d7970 1
a7970 1
       * subtract floating point value 'm' from
d7975 1
a7975 1
      float_immediate_op( OP_SUBF, r1r, r2r, (FloatCon *)m );
d8008 11
d8021 1
a8021 1
       * add floating point value 'm' to the
d8026 1
a8026 1
      float_immediate_op( OP_ADDF, r1r, r2r, (FloatCon *)m );
d8051 11
d8064 1
a8064 1
       * multiply the floating point value 'm' with the
d8069 1
a8069 1
      float_immediate_op( OP_MPYF, r1r, r2r, (FloatCon *)m );
d10091 5
d10112 84
a10195 1
} /* peep_reg_transfer_to */
@


1.75
log
@oops, fixed bug introduced into non-word stores
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.74 1992/02/19 14:49:00 nickc Exp nickc $ */
d156 15
a170 14
static void	append_peep( peep_type, int32 op_code, int32 reads, int32 writes,
			    Symstr *, LabelNumber *, int32 reftype );
static void	flush_peepholer( const char * reason );
static void	emit_from_peep( void );
static void	peep_xref( int32 reftype, Symstr * symbol );
static void	peep_fref( LabelNumber * label, int32 reftype );
static bool	peep_sets_status_reg( RealRegister r );
static bool	peep_reg_transfer_to( RealRegister r );
static bool	peep_refs_label( LabelNumber * l );
static void	peep_symref( Symstr * symbol );
static void	add_pending_push( RealRegister reg, push_type type );
static int	pop_pending_push( RealRegister reg, bool can_pop_double );
static void	maybe_flush_pending_push( RealRegister reg );
static void	flush_pending_pushes( void );
d8232 1
a8232 1
      if (r1r == r2r && peep_reg_transfer_to( r2r ))
d8234 3
a8236 1
	  fprintf( asmstream, "XXXXXXXXXXX IT HAPPENS WITH REG %d\n", r2r );
d8293 16
a8308 1
      out_immediate_offset( OP_STI, r1r, r2r, m, dead & J_DEAD_R2 );
a9928 1
  signed int	prev;
d9932 1
a9932 3
  prev = previous_( peep_end );

  op = peep_buf[ prev ].op_code;
d9934 4
a9937 4
  if (peep_end != peep_start            &&
      is_op( op, OP_LDI )               &&
      is_mode( op, ADDR_MODE_REGISTER ) &&
      dest_of( op ) == r                 )
d9996 30
@


1.74
log
@improved order of instructions in non-word loads + added sign extend code
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.73 1992/02/18 15:44:17 nickc Exp nickc $ */
d6665 1
a6665 1
		     examines1( address ),
d6862 2
a6863 2
      out_triadic_op( OP_LSH3, R_ATMP, address, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( address ),
@


1.73
log
@added a few more peephole optimisations, based on code produced for dhry.c
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.72 1992/02/13 12:51:49 nickc Exp nickc $ */
d90 1
a90 1
   void		export_data_float( RealRegister source, RealRegister dest ); 
d163 1
d266 5
a270 1
    
d293 5
a297 1
    
d339 5
a343 1
    
d412 1
a412 1
    syserr( "hardware_register: trying to evaluate illegal register 0x%x", r );
d471 1
a471 1
    syserr( "real_register: trying to evaluate illegal register 0x%x", r );
d534 1
a534 1
      syserr( "build_op: bad addressing mode %d\n", addressing_mode );
d667 1
a667 1
		  syserr( "out_triadic_op: illegal indirect/indirect triadic addressing\n" );
d685 1
a685 1
		  syserr( "out_triadic_op: illegal displacement in indirect triadic addressing\n" );
d709 1
a709 1
		  syserr( "out_triadic_op: immediate value too large for indirect addressing\n" );
d716 1
a716 1
		  syserr( "out_triadic_op: immediate value too large for indirect addressing\n" );
d729 1
a729 1
	  syserr( "out_triadic_op: unknown kind of triadic addressing %d\n", source2_type );
d740 1
a740 1
	      syserr( "out_triadic_op: illegal displacement for indirect/register addressing\n" );
d765 1
a765 1
		  syserr( "out_triadic_op: displacement out of range for indirect/indirect\n" );
d785 1
a785 1
		  syserr( "out_triadic_op: illegal displacements for indirect/indirect\n" );
d806 1
a806 1
	      syserr( "out_triadic_op: illegal indirect addressing mode\n" );
d813 1
a813 1
	      syserr( "out_triadic_op: displacement out of range\n" );
d835 1
a835 1
	  syserr( "out_triadic_op: unknown kind of triadic addressing %d\n", source2_type );
d841 1
a841 1
      syserr( "out_triadic_op: what is this mess? %d\n", source1_type );
d1044 1
a1044 1
    syserr( "trying to float push a non-floating point register" );
d1063 1
a1063 1
    syserr( "trying to float push a non-floating point register" );
d1082 1
a1082 1
    syserr( "trying to float push a non-floating point register" );
d1107 1
a1107 1
    syserr( "trying to float push a non-floating point register" );
d1378 1
a1378 1
    syserr( "trying to perform a floating point operation with a non floating point source" );
d1381 1
a1381 1
    syserr( "trying to perform a floating point operation with a non floating point destination" );
d1451 1
a1451 1
      syserr( "float_immediate_op: asked to perform an op with a floating point value that does not fit" );
d1477 1
a1477 1
      syserr( "compare_float: asked to perform void comparision" );
d1506 1
a1506 1
  syserr( "compare_float: asked to compare with a floating point value that does not fit" );
d1783 1
a1783 1
	      syserr( "out_immediate_offset: byte offset from stack pointer is too large - %d",
d1884 1
a1884 1
    syserr( "ldr: trying to load a double into a non-floating point register" );
d1903 1
a1903 1
	      syserr( "load_double_relative: byte offset from stack pointer is too large - %d",
d2037 1
a2037 1
    syserr( "sdr: trying to store a double from a non-floating point register" );
d2056 1
a2056 1
	      syserr( "store_double_relative: byte offset from stack pointer is too large - %d",
d2259 1
a2259 1
    syserr( "ldi: trying to load a double into a non-floating point register" );
d2330 1
a2330 1
    syserr( "sdi: trying to store a double from a non-floating point register" );
d2451 1
a2451 1
      syserr( "compare_integer: asked to perform void comparision" );
a2550 3
   * we also know that the peepholer prefers triadic ops as these can
   * more easily be combined with loads and stores, hence we do not
   * bother checking to see if source and dest are the same.
d2553 1
a2553 1
  if (arithmetic)
d2555 3
a2557 2
      out_triadic_op( OP_ASH3, dest, source, amount, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( source ),
d2562 2
a2563 1
      out_triadic_op( OP_LSH3, dest, source, amount, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d2567 1
a2567 1

d2677 1
a2677 1
      syserr( "conditional_skip_instructions: too many instructions to skip! (%d)",
d3202 1
a3202 1
	syserr( "load_address_constant: trying to take address of non-function!" );
d3240 1
a3240 1
	syserr( "load_address_constant: function pointer not word aligned!" );
d3245 1
a3245 1
	syserr( "load_address_constant: offset from function pointer not word aligned!" );
d3305 1
a3305 1
	syserr( "load_address_constant: it is illegal to take an offset from a function pointer" );
d3368 1
a3368 1
	  syserr( "load_address_constant: taking offset from function pointer - this does not work\n" );
d3640 1
a3640 1
		syserr( "load_address_constant: cannot take an offset from function pointer %s",
d3674 1
a3674 1
		  syserr( "external data: offset too big (offset = %d)", offset );
d3992 1
a3992 1
	  syserr( "assembly code output is missing a patch directive\n" );
d4065 1
a4065 1
    syserr( "export_data_symbol: not ready for repeated exports!" );
d4086 1
a4086 1
	syserr( "export_data_symbol: non word aligned offset!" );
d4111 1
a4111 1
	syserr( "export_data_symbol: cannot take an offset from a function pointer!" );
d4157 1
a4157 1
	    syserr( "export_data_symbol: function pointer '%s' not word aligned!", symname_( name ) );
d4237 1
a4237 1
	syserr( "export_data_symbol: asked to export non-data: %s", symname_( name ) );
d4286 1
a4286 1
    syserr( "export_data: non word aligned address increment" );
d4340 1
a4340 1
    syserr( "export_data_value: non word increment for word pointer" );
d4467 2
a4468 13
      /*
       * and jump to it
       *
       * (the following instruction is a conditional CALL, register relative)
       */

      /*
       * XXX
       *
       * WILL THIS WORK - offset in register is probably a byte offset without the correct
       * value (1 or 3) added in
       */

d4471 4
d4481 1
a4481 7
	  outinstr( OP_LAJcr << 24 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_ATMP ),
		   examines1( R_ATMP ),
		   alters2( R_LR, RR_PC ) );

	  nop( TRUE );
	  nop( TRUE );
	  nop( TRUE );
d4555 4
d4598 1
a4598 1
restore_regs( int32	mask )	/* bit mask of registers to remove from stack     */
d4602 1
a4602 1
  
d6381 12
a6392 3
  out_triadic_op( triadic_op, dest, source1, source2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		 examines2( source1, source2 ),
		 alters2( dest, RR_ST ) );
a6394 2

  UNUSED( diadic_op );
d6404 2
d6414 1
a6414 1
  return ((r) >= R_ADDR1 && (r) <= R_ADDR1 + NADDRREGS);
d6416 2
d6419 2
a6420 1
  
d6475 1
a6475 1
  RealRegister	addr      = R_ATMP;
d6528 1
a6528 1
		  syserr( "non_word_op: byte offset from stack pointer is too large - %d",
a6624 5

	      if (!can_corrupt_address || !is_address_register( hardware_register( address ) ))
		{
		  must_copy = TRUE;
		}
d6644 1
a6644 1
   *    addr    - byte offset
a6648 2
   *
   * save non-word selector of address into R_TMP1
a6649 4

  out_triadic_op( OP_AND3, R_TMP1, addr, half_word_op ? 0x2 : 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		 examines1( addr ),
		 alters2( R_TMP1, RR_ST ) );
a6650 8
  /*
   *    addr    - byte offset
   *    operand - free or value to store
   *    R_TMP1  - half-word selector (0 or 2) or byte selector (0, 1, 2, or 3)
   *    R_TMP2  - free
   *    R_TMP3  - free
   */

d6653 7
a6659 1
      /* 
d6661 1
d6663 4
a6666 4
      
      if (must_copy)
	{
	  addr = R_ATMP;
d6668 17
a6684 10
	  out_triadic_op( OP_LSH3, addr, address, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( address ),
			 alters2( addr, RR_ST ) );
	}
      else
	{
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			examines1( addr ),
			alters2( addr, RR_ST ) );
	}
a6691 2
       *
       * load word into R_TMP2
a6693 13
      if (absolute)
	{
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_REL, addr, 0 ),
			examines1( addr ),
			alters2( R_TMP2, RR_ST ) );
	}
      else
	{
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, addr, 0 ),
			examines2( addr, RR_IR0 ),
			alters2( R_TMP2, RR_ST ) );
	}
      
d6697 1
a6697 1
	   *    addr    - free
d6700 1
a6700 1
	   *    R_TMP2  - word at destination
d6704 1
d6712 1
a6712 1
	   *    addr    - free
d6715 1
a6715 1
	   *    R_TMP2  - word at destination
d6719 1
d6733 23
d6779 1
a6779 1
      else
d6782 1
a6782 1
	   *    addr    - free
d6785 1
a6785 1
	   *    R_TMP2  - word at destination
d6789 1
d6797 23
d6832 1
a6832 1
	  
d6846 1
d6852 33
a6884 1
       *    addr    - byte offset
d6904 1
a6904 1
       * shift source to correct alignment and place in R_TMP3
d6912 1
a6912 1
       *    addr    - byte offset
d6926 1
a6926 1
       *    addr    - byte offset
a6939 26
       *    addr    - byte offset
       *    operand - free (not corruptible)
       *    R_TMP1  - half-word mask (0x0000FFFF or 0xFFFF0000) or
       *              byte mask (0x000000FF, 0x0000FF00, 0x00FF0000 or 0xFF000000)
       *    R_TMP2  - free
       *    R_TMP3  - shifted source value
       *
       * loose bottom two bits of byte offset (ie convert to word offset)
       */
      
      if (must_copy)
	{
	  addr = R_ATMP;
	  
	  out_triadic_op( OP_LSH3, addr, address, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( address ),
			 alters2( addr, RR_ST ) );
	}
      else
	{
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, addr, -2,
			examines1( addr ),
			alters2( addr, RR_ST ) );
	}
      
      /*
d7139 3
d7173 1
a7173 1
      
d7175 1
a7175 1
	syserr( "CALLK stack mis-aligned\n" );
d7191 1
a7191 1
	syserr( "TAILCALLK stack mis-aligned\n" );
d7202 1
a7202 1
	syserr( "CALLR stack mis-aligned\n" );
d7208 4
d7219 1
a7219 1
	syserr( "TAILCALLR stack mis-aligned\n" );
d7275 1
a7275 1
	  syserr( "show_instruction: loading stack pointer with a constant address is not yet supported" );
d8231 5
d8538 41
d8788 1
a8788 1
      syserr( "pending pushes: array overflow" );
d8810 1
a8810 1
      syserr( "add pending push: unknown push type" );
d8860 1
a8860 1
      syserr( "pop pending push: unknown push type" );
d8993 1
a8993 1
	  syserr( "flush pending pushes: unknown push type" );
d9051 1
a9051 1
	      syserr( "maybe flush pending push: unknown push type" );
d9192 1
a9192 1
		syserr( "peepholer: no offset in branch!" );
d9225 1
a9225 1
	    syserr( "peepholer: no offset in branch!" );
d9313 2
a9326 5
  /* do not eliminate instructions put here by NOP elimination  */

  if (peep_buf[ prev ].reads & (1U << RR_PC))
    return FALSE;

d9803 3
a9805 1
  /* see if we have a redundant op-code */
d9807 2
a9808 2
  if (type == OUT_NULL && eliminate_null_op())
    return;
d9810 1
a9810 1
  /* see if we can combine two ops into one */
d9812 4
a9815 3
  if (type == OUT_INSTR && combine_instrs( op_code, reads, writes ))
    {
      return;
d9834 1
a9834 1
	  syserr( "peepholer: pending forward and cross references for same instruction!" );
d9863 1
a9863 1
	  syserr( "peepholer: special instruction type had a pending cross reference!" );
d9878 1
a9878 1
	  syserr( "peepholer: special instruction type had a pending forward reference!" );
d9904 30
d9946 3
a9948 3
  if (peep_end != peep_start                    &&
      (peep_buf[ prev ].writes & (1L << RR_ST)) &&
      (peep_buf[ prev ].writes & (1L <<     r))  )
d9994 1
a9994 1
      syserr( "peepholer: attempting to flush peepholer whilst a cross reference is still pending" );
d9999 1
a9999 1
      syserr( "peepholer: attempting to flush peepholer whilst a forward reference is still pending" );
d10053 1
a10053 1
      syserr( "peepholer: asked to emit an unknown type %d", instruction->type );
d10069 1
a10069 1
	  syserr( "peepholed instruction referencing already set label" );
@


1.72
log
@fixed bug when generating functions pointed for libraries
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.71 1992/02/12 18:51:25 nickc Exp nickc $ */
d170 5
d1621 2
d1637 1
a1637 1
		examines1( R_LR ),
d1656 84
d1842 2
a1844 25
      /* divide address by sizeof_int (here assumed to be 4) and place in temporary */

      out_triadic_op( OP_LSH3, tmp, src, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		    examines1( src ),
		    alters2( tmp, RR_ST ) );

      offset /= sizeof_int;

      if (offset == 0)
	{
	  ;	/* do nothing */
	}
      else if (fits_in_16_bits( offset ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, offset,
			examines1( tmp ),
			alters2( tmp, RR_ST ) );
	}
      else
	{
	  syserr( syserr_offset_out_of_range, offset );

	  return;
	}

d1988 2
a1990 25
      /* divide address by sizeof_int (here assumed to be 4) and place in temporary */

      out_triadic_op( OP_LSH3, tmp, src, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		    examines1( src ),
		    alters2( tmp, RR_ST ) );

      offset /= sizeof_int;

      if (offset == 0)
	{
	  ;	/* do nothing */
	}
      else if (fits_in_16_bits( offset ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, offset,
			examines1( tmp ),
			alters2( tmp, RR_ST ) );
	}
      else
	{
	  syserr( syserr_offset_out_of_range, offset );

	  return;
	}

d2141 2
a2143 25
      /* divide address by sizeof_int (here assumed to be 4) and place in temporary */

      out_triadic_op( OP_LSH3, tmp, addr, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		    examines1( addr ),
		    alters2( tmp, RR_ST ) );

      offset /= sizeof_int;

      if (offset == 0)
	{
	  ;	/* do nothing */
	}
      else if (fits_in_16_bits( offset ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, offset,
			examines1( tmp ),
			alters2( tmp, RR_ST ) );
	}
      else
	{
	  syserr( syserr_offset_out_of_range, offset );

	  return;
	}

d2192 2
a2193 4
      out_triadic_op( OP_LSH3, R_ATMP, offset, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( offset ),
		     alters2( R_ATMP, RR_ST ) );

d2200 4
d2218 4
d2224 2
a2225 4
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2,
		    examines1( R_ATMP ),
		    alters2( R_ATMP, RR_ST ) );

d2255 2
a2256 4
      out_triadic_op( OP_LSH3, R_ATMP, offset, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( offset ),
		     alters2( R_ATMP, RR_ST ) );

d2263 4
d2285 4
d2291 2
a2292 4
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2,
		    examines1( R_ATMP ),
		    alters2( R_ATMP, RR_ST ) );

d2326 2
a2327 4
      out_triadic_op( OP_LSH3, R_ATMP, offset, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( offset ),
		     alters2( R_ATMP, RR_ST ) );

d2334 4
d2356 4
d2362 1
a2362 3
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2,
		    examines1( R_ATMP ),
		    alters2( R_ATMP, RR_ST ) );
a2365 1
      
d2808 2
a2809 13
  if (src == dst)
    {
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dst, -2,
		    examines1( dst ),
		    alters2( dst, RR_ST ) );
    }
  else
    {
      out_triadic_op( OP_LSH3, dst, src, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( src ),
		     alters2( dst, RR_ST ) );
    }

d2950 4
d2955 1
d3592 2
d4453 2
d5049 4
d6465 2
d7257 4
d7336 2
a9229 38
#if OLD_CODE
  /* XXX - NC _ I am not sure this if this one is working properly */
  if (prev_op == curr_op)
    {
      int32	type = (curr_op >> 29) & 0x7;


      /* see if they have any side effects */
      
      if (type == 0)
	{
	  if (!is_mode( curr_op, ADDR_MODE_INDIRECT ) ||  /* if it does not use indirect addressing       */
	      ((curr_op >> 13) & 1) == 0)		  /* or the indirect addressing does not auto inc */
	    {
	      fprintf( asmstream, "; peepholer: eliminated multiple indentical diadic op codes (%x)\n",
		      curr_op );
	      
	      return TRUE;
	    }
	}
      else if (type == 1)
	{
	  int32	mode = (curr_op >> 21) & 0x3;

	  
	  if ((((curr_op >> 28) & 1) == 1) ||
	      (mode == 0) ||
	      (mode == 1 && ((curr_op >> 13) & 1) == 0) ||
	      (mode == 2 && ((curr_op >>  5) & 1) == 0) ||
	      (mode == 3 && ((curr_op >>  5) & 1) == 0 && ((curr_op >> 13) & 1) == 0))
	    {
	      fprintf( asmstream, "; peepholer: eliminated multiple indentical triadic op codes\n" );
	      
	      return TRUE;
	    }
	}
    }
#else /* ie NEW_CODE */
d9263 8
a9280 2
#endif /* OLD_CODE */
  
d9323 6
d9343 1
a9347 1
	case OP_CMPI:	  op = OP_CMPI3;	  break;
d9349 1
d9352 2
a9354 1
	case OP_TSTB:	  op = OP_TSTB3;	  break;
d9363 66
a9428 1
	    prev_op &0x001f0000U | (prev_op & 0x1f) << 8 | (curr_op & 0x1f);
d9433 1
a9433 1
	  fprintf( asmstream, "; peepholer: merged load and op into triadic op\n" );
d9443 6
d9470 23
d9990 1
@


1.71
log
@improved register saving upon function entry and use of labrefs
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.70 1992/02/12 18:06:07 nickc Exp nickc $ */
d3277 1
a3277 1
       * XXX - potential bug.  The value loaded here should be
d3279 1
a3279 2
       * we assume that the '+ 3' will be lost in the shifting
       * but this is not necessarily true ...
d3291 1
a3291 1
		    examines0(),
d3507 2
d3513 15
a3527 1
	  
d3530 1
a3530 1
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, 0, dest,
d3532 1
a3532 1
			alters2( RR_ST, dest ) );
d3536 17
a3552 3
	  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, 0, dest,
			examines0(),
			alters2( RR_ST, dest ) );
@


1.70
log
@fixed bug in routine_exit whereby return label was being set before peepholer was flushed
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.69 1992/02/12 15:36:52 nickc Exp nickc $ */
a144 1
    unsigned32 		offset;		/* label offset (if needed) 			*/
d157 1
a157 1
			    Symstr *, unsigned32 offset, LabelNumber *, int32 reftype );
d161 1
a161 1
static void	peep_fref( LabelNumber * label, unsigned32 offset );
d222 1
a222 1
  append_peep( OUT_INSTR, op_code, reads, writes, NULL, 0, NULL, LABREF_NONE );
d238 1
a238 1
	      alters0(), NULL, 0, NULL, LABREF_NONE );
d255 1
a255 1
  append_peep( OUT_DELAYED, op_code, reads, writes, NULL, 0, NULL, LABREF_NONE );
a265 22
#ifdef NOT_USED 

/*
 * output an instruction that references a label
 */

static void
outlabref(
	  int32		op_code,	/* the 32 bit op code */
	  LabelNumber *	label,		/* the label referenced */
	  int32		offset,		/* the size of the offset field */
	  int32		reads,		/* mask of registers read by the op code */
	  int32		writes )	/* mask of registers altered by the op code */
{
  append_peep( OUT_LABREF, op_code, reads, writes, NULL, offset, label, LABREF_NONE );
    
  return;
    
} /* outlabref */

#endif /* NOT_USED */

d278 1
a278 1
  append_peep( OUT_DELLABREF, op_code, reads, writes, NULL, 0, label, reftype );
d301 1
a301 1
  append_peep( OUT_SYMREF, op_code, reads, writes, name, 0, NULL, LABREF_NONE );
d320 1
a320 1
  append_peep( OUT_DELSYMREF, op_code, reads, writes, name, 0, NULL, LABREF_NONE );
d541 1
a541 1
	      reads, writes, name, 0, NULL, ref_type );
d5049 8
a5056 1
       * types
d5061 1
a5061 1
      fn = ((n <= NFLTARGREGS) ? n : NFLTARGREGS) * (sizeof_double / sizeof_int);
a8462 1
static unsigned32			pending_offset  = 0;		/* the forward reference's offset */
d8576 1
a8576 1
	  unsigned32	offset )
d8578 3
a8580 3
  fref_pending   = TRUE;
  pending_label  = label;
  pending_offset = offset;
a9553 1
	    unsigned32		offset,
a9580 1
  peep_buf[ peep_end ].offset  = offset;
d9626 3
a9628 3
	  peep_buf[ peep_end ].type   = OUT_LABREF;
	  peep_buf[ peep_end ].label  = pending_label;
	  peep_buf[ peep_end ].offset = pending_offset;
d9791 1
a9791 1
      if (!lab_isset_( instruction->label ))
d9793 1
a9793 1
	  addfref_( instruction->label, codep | instruction->offset );
d9797 1
a9797 36
	  offset = instruction->label->u.defn & 0x7fffffffU;
	  offset = (offset - codep) / sizeof_int - 3;		/* -3 because of delays */

	  switch (instruction->reftype)
	    {
	    default:
	      syserr( "peepholer: unknown label reference type %d\n", instruction->reftype );
	      break;
	      
	    case LABREF_NONE:
	      break;

	    case LABREF_OFF24:
	      offset += mask_and_sign_extend_word( op, 0x00FFFFFFU );

	      if (!fits_in_24_bits( offset ))
		{
		  syserr( "peepholer: offset to label does not fit in 24 bits\n" );
		}

	      op = (op & 0xFF000000U) | (offset & 0x00FFFFFFU);
	      
	      break;
	      
	    case LABREF_OFF16:
	      offset += mask_and_sign_extend_word( op, 0x0000FFFFU );

	      if (!fits_in_16_bits( offset ))
		{
		  syserr( "peepholer: offset to label does not fit in 16 bits\n" );
		}
	      
	      op = (op & 0xFFFF0000U) | (offset & 0x0000FFFFU);

	      break;
	    }
@


1.69
log
@fixed bug whereby registers could be saved upon entry to the data initialisation code
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.68 1992/02/12 11:29:21 nickc Exp nickc $ */
d123 11
a133 11
    OUT_NULL,		/* a padding op-code that can potentially be eliminated */
    OUT_INSTR,		/* normal op-code */
    OUT_DELAYED,	/* a delayed instruction */
    OUT_SYMREF,		/* op-code that references a symbol */
    OUT_DELSYMREF,	/* (delayed) op-code that references a symbol */
    OUT_XREF,		/* op-code that cross references a symbol */
    OUT_SYMXREF,	/* op-code that references and cross references a symbol */
    OUT_DELSYMXREF,	/* (delayed) op-code that references and cross references a symbol */
    OUT_LABREF,		/* op-code that references a label */
    OUT_DELLABREF	/* (delayed) op-code that references a label */
    }
d138 8
a145 8
    peep_type		type;		/* e.g. OUT_INSTR */
    int32 		op_code;	/* 32 bits of data */
    int32 		reads;		/* registers accessed */
    int32 		writes;		/* registers clobbered, plus usage class */
    Symstr *		symbol;		/* external symbol (if needed) */
    int32 		reftype;	/* symbol reference type (if needed) */
    LabelNumber *	label;		/* label (if needed) */
    unsigned32 		offset;		/* label offset (if needed) */
d164 1
d297 1
a297 1
	     int32		offset,		/* the size of the offset field */
d301 1
a301 1
  append_peep( OUT_DELLABREF, op_code, reads, writes, NULL, offset, label, LABREF_NONE );
d2744 1
a2744 1
      
d5362 4
a5365 2
      
      if (returnlab->u.frefs != NULL)	/* experimental - eg for int func( int arg ){ return arg * arg; } */
d5367 1
a5367 1
      
d5655 1
a5655 1
	  
d8487 1
a8487 1
#define is_op( instruction, op_code )	(((instruction)  >> 23)        == (op_code))
d8489 3
a8491 3
#define is_diadic( instruction )	(((instruction) >> 29)         == 0)
#define dest_of( instruction )		(((instruction) >> 16) & 0x1f)
#define source_of( instruction )	((instruction) & 0xff)
d8625 1
a8625 1
  fprintf( asmstream, "adding push of reg %d (type %d)\n", reg, type );
d8838 1
a8838 1
      fprintf( asmstream, "forced flush of push of reg %d\n", reg );
d8896 1
a8896 1
	  fprintf( asmstream, "flushed push of reg %d because of clash\n", reg );
d9702 25
d9822 1
a9822 1
	      syserr( "peepholer: unknown label refernce type %d\n", instruction->reftype );
d9849 1
a9849 1
	      
@


1.68
log
@fixed bug in the static initialisation of function pointers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.67 1992/02/11 17:50:13 nickc Exp nickc $ */
d5011 8
d5167 1
a5167 1
  if (!no_stack_checks && !in_stubs)
d8622 1
a8622 1
  /* fprintf( asmstream, "adding push of reg %d (type %d)\n", reg, type ); */
d8835 1
a8835 1
      /* fprintf( asmstream, "forced flush of push of reg %d\n", reg ); */
d8893 1
a8893 1
	  /* fprintf( asmstream, "flushed push of reg %d because of clash\n", reg ); */
@


1.67
log
@removed redundant j_opcodes
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.66 1992/02/11 12:01:22 nickc Exp nickc $ */
d3994 2
a3995 2
 * store it in the word pointed to by 'dest', and
 * increment 'dest' by 'len' bytes.
d4002 1
a4002 1
 * Note dest is a now a word pointer
d4004 1
a4004 1
 * Also note that 'dest' is very probably 'R_ATMP'.
d4144 3
a4146 3
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_ATMP, R_MT,
			examines1( R_ATMP ),
			alters2( R_MT, RR_ST ) );
d4156 3
a4158 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, 0,
			examines1( R_ATMP ),
			alters2( R_ATMP, RR_ST ) );
d4162 3
a4164 3
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ATMP, build_indirect( INDIRECT_REL, R_ATMP, 0 ),
			examines1( R_ATMP ),
			alters2( R_ATMP, RR_ST ) );
d4170 3
a4172 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, 0,
			examines1( R_ATMP ),
			alters2( R_ATMP, RR_ST ) );
d4176 2
a4177 2
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, R_ATMP, 0 ),
			examines1( R_ATMP ),
@


1.66
log
@fixed bug in LDI, STI combination peephole
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.65 1992/02/10 12:07:04 nickc Exp nickc $ */
d7781 1
d7792 1
d7821 1
d7832 1
d7853 1
d7864 1
a8408 7
      /* XXX - Now the floating point part of the instruction set */
      
    case J_ADCONF:
    case J_ADCOND:
      syserr( "back end: floating point address constants not yet supported" );
      break;

@


1.65
log
@fixed the peepholer's elimination of multiple identical instructions
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.64 1992/02/06 14:29:47 nickc Exp nickc $ */
d202 1
a203 1

d1231 1
a1231 1
 * output an instruction using immediate addressing
d1236 7
a1242 7
immediate_op(
	     int32		diadic_op,		/* diadic version of the operation */
	     int32		triadic_op,		/* triadic version of the operation */
	     RealRegister	dest,			/* detination register for operation */
	     RealRegister	source,			/* source register for operation */
	     int32		value,			/* the immediate value */
	     bool		signed_op )		/* TRUE if value op takes signed immediate values */
d1263 2
d1268 1
a1268 1
	      fprintf( asmstream, "; immediate_op(): eliminating op %lx with value 0", diadic_op );
d1325 1
a1325 1
} /* immediate_op */
d1329 5
d1339 2
a1340 2
  int32	high = IEEE_to_extended_float( fc->floatbin.irep[ 0 ], fc->floatbin.irep[ 1 ], TRUE );
  int32	low  = IEEE_to_extended_float( fc->floatbin.irep[ 0 ], fc->floatbin.irep[ 1 ], FALSE );
d1342 3
a1344 1

d1363 153
d1530 1
a1530 1
  
d1534 1
a1534 2
      syserr( "back end: trying to load floating point constant into a non-floating point register %d",
	     r );
d1542 2
a1543 2
      int32	high = IEEE_to_extended_float( fc->floatbin.irep[ 0 ], fc->floatbin.irep[ 1 ], TRUE );
      int32	low  = IEEE_to_extended_float( fc->floatbin.irep[ 0 ], fc->floatbin.irep[ 1 ], FALSE );
d1546 2
d1595 1
a1595 1
      int32	val = IEEE_to_single_float( fc->floatbin.irep[ 0 ] );
d1647 1
a1647 1
  immediate_op( OP_ADDI, OP_ADDI3, R_ATMP, R_ATMP, disp - 4 + 1, TRUE );
d2401 1
a2401 1
      immediate_op( OP_ADDI, OP_ADDI3, R_SP, R_SP, stack_move, TRUE );
d2405 1
a2405 1
      immediate_op( OP_SUBI, OP_ADDI3, R_SP, R_SP, -stack_move, TRUE );
a2483 52
 * Compare register 'r' with the floating point constant 'fc' using comparison 'test'
 */

static void
compare_float(
		RealRegister	r,
		FloatCon *	fc,
		int32 		test )
{ 
  int32	high = IEEE_to_extended_float( fc->floatbin.irep[ 0 ], fc->floatbin.irep[ 1 ], TRUE );
  int32	low  = IEEE_to_extended_float( fc->floatbin.irep[ 0 ], fc->floatbin.irep[ 1 ], FALSE );


  if (test == Q_AL)
    {
      syserr( "compare_float: asked to perform void comparision" );
    }
  
  correct_stack( TRUE );

  /* check to see if the value fits in 16 bits */

  if (low == 0 && high == 0x80000000U)
    {
      /* catch 0.0 */
	  
      out_diadic_op( OP_CMPF, ADDR_MODE_IMMEDIATE, r,
		    0x8000,
		    examines1( r ),
		    alters1( RR_ST ) );

      return;
    }
  else if ((low & 0xfffff) == 0 &&
	   (((high & 0xf8000000U) == 0) || ((high & 0xf8000000U) == 0xf8000000U)))
    {
      out_diadic_op( OP_CMPF, ADDR_MODE_IMMEDIATE, r,
		    high >> 12,
		    examines1( r ),
		    alters1( RR_ST ) );

      return;
    }

  syserr( "compare_float: asked to compare with a floating point value that does not fit" );
  
  return;
  
} /* compare_float */


/*
d3155 1
a3155 1
	  immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );
d3240 1
a3240 1
	  immediate_op( OP_SUBI, OP_SUBI3, dest, dest, d, TRUE );
d3711 1
a3711 1
  immediate_op( OP_ADDI, OP_ADDI3, dest, dest, litpoolp -4 + 1, TRUE );
d4050 1
a4050 1
      immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset, TRUE );
d4119 1
a4119 1
	      immediate_op( OP_SUBI, OP_SUBI3, R_TMP1, R_TMP1, offset, TRUE );
d7763 1
a7763 1
	  immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, -m, TRUE );
d7767 1
a7767 1
	  immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, m, TRUE );
d7781 11
d7805 1
a7805 1
	  immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, -m, TRUE );
d7809 1
a7809 1
	  immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, m, TRUE );
d7819 11
d7849 11
d7867 1
a7867 1
      immediate_op( OP_AND, OP_AND3, r1r, r2r, m, FALSE );
d7878 1
a7878 1
      immediate_op( OP_OR, OP_OR3, r1r, r2r, m, FALSE );
d7889 1
a7889 1
      immediate_op( OP_XOR, OP_XOR3, r1r, r2r, m, FALSE );
d9365 4
a9368 4
  prev_load  = is_potential_parallel_op(  prev_op, OP_LDI );
  prev_store = is_potential_parallel_op(  prev_op, OP_STI );
  curr_load  = is_potential_parallel_op(  curr_op, OP_LDI );
  curr_store = is_potential_parallel_op(  curr_op, OP_STI );
d9375 15
d9394 2
a9395 2
	                         (curr_op & (0xFF << 8)) << (8 - 8)     |
		                 (prev_op & (0xFF << 8)) >> (8 - 0);
d9404 10
a9413 6
      peep_buf[ prev ].op_code = (B_11 << 30)                           |
	                         (OP_LDI_STI << 25)                     |
	                         (prev_op & (B_111 << 16)) << (22 - 16) |
	                         (curr_op & (B_111 << 16)) << (16 - 16) |
	                         (curr_op & (0xFF << 8)) << (8 - 8)     |
		                 (prev_op & (0xFF << 8)) >> (8 - 0);
d9415 1
a9415 1
      fprintf( asmstream, "; peepholer: transformed LDI, STI into LDI || STI\n" );
d9417 2
a9418 1
      return TRUE;
d9427 2
a9428 2
	                         (prev_op & (0xFF << 8)) << (8 - 8)     |
		                 (curr_op & (0xFF << 8)) >> (8 - 0);
d9441 2
a9442 2
	                         (curr_op & (0xFF << 8)) << (8 - 8)     |
		                 (prev_op & (0xFF << 8)) >> (8 - 0);
@


1.64
log
@added pragma to disable peepholing
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.63 1992/02/05 16:56:42 nickc Exp nickc $ */
d82 1
d1180 6
d1289 1
a1289 1
  else if (diadic_op == OP_AND && fits_in_16_bits_unsigned( ~value ))
d1291 20
a1310 3
      out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, dest, ~value,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
d1326 30
d1387 12
a1398 1
      if ((low & 0xfffff) == 0 &&
d1407 10
a1416 1
	}      
d2232 3
a2234 1
    flush_pending_pushes();
d2321 52
d7322 11
d8191 1
a8191 1
	   * NB/ in SAME order to pop because add_pending_push stacks up
d8193 2
d8198 10
a8207 2
	  
	  for (i = 0; i < 32; i++)
d8209 5
a8213 2
	      if (m & regbit( i ))
		add_pending_push( i, PUSH_INT );
d8471 1
a8471 2
  /* fprintf( asmstream, "adding push of reg %d (type %d), offset = %d, move = %d\n",
	  reg, type, stack_offset, stack_move ); */
d8502 3
a8504 1
    flush_pending_pushes();
d8662 1
a8662 1
  for (i = 0; i < pend_push_free; i++)
d8684 1
a8684 1
      /* fprintf( asmstream, "flushing push of reg %d\n", reg ); */
d8742 1
a8742 2
	  /* fprintf( asmstream, "flushed push of reg %d because of clash, stack offset = %d, move = %d\n",
		  reg, stack_offset, stack_move ); */
d9021 2
d9058 46
a9103 1
     
@


1.63
log
@fixed unpacking of variable arguments
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.62 1992/02/05 15:44:05 nickc Exp nickc $ */
d182 1
a182 1
static void 		correct_stack( void );
d1244 1
a1244 1
  if (value == 0)
d2152 1
a2152 1
correct_stack( void )
d2157 3
d2191 1
a2191 1
  correct_stack();
d2195 1
a2195 1
      if (n == 0 && pp_pragmavec[ 'q' - 'a' ] == 0)
d2200 5
d5081 2
d5280 1
a5280 1
      correct_stack();
d6757 1
a6757 1
	    correct_stack();
d6766 1
a6766 1
	    correct_stack();
d6774 1
a6774 1
	  correct_stack();
d6782 1
a6782 1
      correct_stack();
d6817 2
a6819 2
      correct_stack();
      
d6845 1
a6845 1
      correct_stack();
d6871 1
a6871 1
      correct_stack();
d6951 1
a6951 1
	      correct_stack();
d6964 1
a6964 1
      correct_stack();
d7166 1
a7166 1
      correct_stack();
d7175 1
a7175 1
      correct_stack();
a8163 8
#define ENABLE_PEEP_OPTS

/*
 * this function indicates that the next instruction to be appended
 * to the peepholer's buffer is a cross reference type instruction, rather than
 * an ordinary instruction
 */

d8166 9
a8174 9
static peep_data	peep_buf[ PEEP_BUF_SIZE ];	/* circular buffer of op codes */
static signed int	peep_start 	= 0;		/* next instruction to be emitted */
static signed int	peep_end   	= 0;		/* next free slot in table */
static bool		xref_pending    = FALSE;	/* true if a cross reference is pending */
static int32		pending_reftype = 0;		/* the cross reference type */
static Symstr *		pending_symbol  = NULL;		/* the cross reference's symbol */
static bool		fref_pending    = FALSE;	/* true if a forward reference is pending */
static unsigned32	pending_offset  = 0;		/* the forward reference's offset */
static LabelNumber *	pending_label   = NULL;		/* the forward reference's label */
d8177 3
a8179 3
#define num_in_peep_()		(peep_end - peep_start + (peep_end < peep_start ? PEEP_BUF_SIZE : 0))
#define previous_( var )	(((var) - 1) & (PEEP_BUF_SIZE - 1))
#define successor_( var )	(((var) + 1) & (PEEP_BUF_SIZE - 1))
d8188 2
a8189 1
 * returns TRUE if the two instructions can be swapped
d8241 5
d8261 5
d8278 6
d8319 2
a8320 1
  /* fprintf( asmstream, "adding push of reg %d (type %d)\n", reg, type ); */
d8337 2
a8338 2
  if (stack_move < 0)
    correct_stack();
d8349 3
d8463 1
a8463 1
		correct_stack();
d8484 1
a8484 1
		correct_stack();
d8509 1
a8509 1
  for (i = pend_push_free; i--;)
d8589 2
a8590 1
	  /* fprintf( asmstream, "flushed push of reg %d\n", reg ); */
d8597 2
d8617 3
a8619 3
#ifndef ENABLE_PEEP_OPTS
  return FALSE;
#endif
d8848 2
a8849 3
#ifndef ENABLE_PEEP_OPTS
  return FALSE;
#endif
@


1.62
log
@fixed immediate operations whoes value is unsigned
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.61 1992/02/05 11:32:38 nickc Exp nickc $ */
d705 1
a705 1
	  if (!fits_in_8_bits( source2 ))
d707 15
a721 1
	      syserr( "out_triadic_op: immediate value too large for indirect addressing\n" );
d723 1
a723 1

d4818 2
a4819 2
      
      maskarg  = regbit( R_A1  + n ) - regbit( R_A1   );
d4825 5
a4829 1
      maskarg = regmaskvec.map[ 0 ] & maskarg;
d8300 2
d8507 2
d8566 2
@


1.61
log
@fixed order of flushing pending pushes
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.60 1992/02/04 15:17:30 nickc Exp nickc $ */
d1216 6
a1221 5
	      int32		diadic_op,
	      int32		triadic_op,
	      RealRegister	dest,
	      RealRegister	source,
	      int32		value )
d1256 1
a1256 1
  if (dest == source && fits_in_16_bits( value ))
d1262 1
a1262 1
  else if (fits_in_8_bits( value ))
d1268 6
d1396 1
a1396 1
  immediate_op( OP_ADDI, OP_ADDI3, R_ATMP, R_ATMP, disp - 4 + 1 );
d2145 1
a2145 1
      immediate_op( OP_ADDI, OP_ADDI3, R_SP, R_SP, stack_move );
d2149 1
a2149 1
      immediate_op( OP_SUBI, OP_ADDI3, R_SP, R_SP, -stack_move );
d2894 1
a2894 1
	  immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset );
d2979 1
a2979 1
	  immediate_op( OP_SUBI, OP_SUBI3, dest, dest, d );
d3450 1
a3450 1
  immediate_op( OP_ADDI, OP_ADDI3, dest, dest, litpoolp -4 + 1 );
d3789 1
a3789 1
      immediate_op( OP_ADDI, OP_ADDI3, R_TMP1, R_TMP1, offset );
d3858 1
a3858 1
	      immediate_op( OP_SUBI, OP_SUBI3, R_TMP1, R_TMP1, offset );
d7485 1
a7485 1
	  immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, -m );
d7489 1
a7489 1
	  immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, m );
d7516 1
a7516 1
	  immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, -m );
d7520 1
a7520 1
	  immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, m );
d7556 1
a7556 1
      immediate_op( OP_AND, OP_AND3, r1r, r2r, m );
d7567 1
a7567 1
      immediate_op( OP_OR, OP_OR3, r1r, r2r, m );
d7578 1
a7578 1
      immediate_op (OP_XOR, OP_XOR3, r1r, r2r, m );
@


1.60
log
@fixed poping doubles when only one argument register is left
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.59 1992/02/04 13:46:47 nickc Exp nickc $ */
d8016 6
a8021 2
	  /* NB/ in reverse order to pop */
	  /* NB/ beware if number of registers > 32 */
d8023 1
a8023 1
	  for (i = 31; i >= 0; i--)
d8274 1
a8274 1
  
d8459 1
a8459 1
  for (i = 0; i < pend_push_free; i++)
d8627 1
a8627 3
	  peep_buf[ delayed ].reads |= (1U << RR_PC);

	  /* ensure that the NOP does get swapped again */
d8804 5
d8822 2
a8823 3
	  if (!(peep_buf[ prev ].reads & (1U << RR_PC)) &&  /* if has not been put here by NOP elimination  */
	      (!is_mode( curr_op, ADDR_MODE_INDIRECT )  ||  /* and it does not use indirect addressing      */
	      ((curr_op >> 13) & 1) == 0))		    /* or the indirect addressing does not auto inc */
d8825 2
a8826 1
	      fprintf( asmstream, "; peepholer: eliminated multiple indentical diadic op codes (%x)\n", curr_op );
a8875 1
	  !(peep_buf[ prev ].reads & (1U << RR_PC))                        && /* not put here by NOP removal  */
@


1.59
log
@fixed (I hope) pushing and poping of floats and doubles
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.58 1992/01/31 18:02:21 nickc Exp nickc $ */
d165 1
a165 1
static int	pop_pending_push( RealRegister reg );
d7092 1
a7092 1
      
a7225 2
      /* XXX - NC - I have no idea how this J_opcode is ever used ! */
      
d7237 5
a7241 4
	  
	  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, r1r, r2r,
			examines1( r2r ),
			alters2( r1r, RR_ST ) );      
a7266 2
      /* XXX - NC - I have no idea how this J_opcode is ever used ! */

d7284 5
a7288 4
	  
	  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, r1r, mr,
			examines1( r2r ),
			alters2( r1r, RR_ST ) );      
d8058 3
a8060 1
	  if (pop_pending_push( r ) == 2)
a8061 1
	      m ^= regbit( r );
a8063 4
	  else
	    {
	      m ^= regbit( r );
	    }
d8310 3
a8312 1
pop_pending_push( RealRegister dest )
d8338 1
a8338 1
   case PUSH_DOUBLE:	stack_offset -= sizeof_double; break;
d8343 20
d8868 5
a8872 3
      if (((prev_op >>  8) & 0x07) == (dest - hardware_register( RR_AR0 )) &&
	  ((prev_op >> 11) & 0x1f) == INDIRECT_POST_INCR &&
	  fits_in_8_bits_unsigned( amount ))
@


1.58
log
@fixed compare_integer when checking against large numbers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.57 1992/01/16 13:28:56 nickc Exp nickc $ */
d59 1
a59 1
#define is_float( reg ) 	is_extended_precision_register( hardware_register( reg ) )
a117 8
typedef enum
  {
    REG_TYPE_INTEGER,
    REG_TYPE_FLOAT,
    REG_TYPE_DOUBLE
  }
register_type;

d148 8
d164 4
a167 1

d374 2
d422 8
d1297 2
a1298 1
      syserr( "back end: trying to load floating point constant into a non-floating point register" );
d4296 1
a4296 1
      int32 r1  = firstbit( mask );
d4301 1
a4301 1
      mask ^= 1L << r1;
a6652 2
  static RealRegister	pend_float_push  = GAP;
  static RealRegister	pend_double_push = GAP;
d6750 1
a6750 54
  /*
   * floating point push / pop elimination
   */
  
  if (pend_float_push != GAP)
    {
      if (opm == J_POPM)
	{
	  int32	dest = lastbit( m );

	  
	  if (dest == pend_float_push)
	    {
	      /* remove floating point register from pop list */
	  
	      m &= ~(1U << dest);

	      fprintf( asmstream, "; peepholer: eliminated float push/pop pair\n" );
	    }
	  else if (is_float( dest ))
	    {
	      /* push followed by pop into different register */
		  
	      move_register( pend_float_push, dest, TRUE );
		  
	      fprintf( asmstream, "; peepholer: transformed float push/pop pair\n" );

	      m &= ~(1U << dest);
	    }
	  else
	    {
	      /* wierd - pushing float then poping into non float register */
		  
	      if (stack_move < 0)
		correct_stack();

	      fpush( pend_float_push );
	  
	      stack_offset += sizeof_int;
	    }
	}
      else
	{
	  if (stack_move < 0)
	    correct_stack();

	  fpush( pend_float_push );
	  
	  stack_offset += sizeof_int;
	}

      pend_float_push = GAP;
    }
  else if (pend_double_push != GAP)
d6752 1
a6752 51
      if (opm == J_POPM)
	{
	  int32	dest = lastbit( m );

	  
	  if (dest > 0 && ((1U << --dest) & m))
	    {
	      if (dest & pend_double_push)
		{
		  /* remove double precision registers from pop list */
	  
		  m &= ~(3U << dest);
		  
		  fprintf( asmstream, "; peepholer: eliminated double push/pop pair\n" );
		}
	      else if (is_float( dest ))
		{
		  /* push followed by pop into different register */

		  out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, dest, pend_double_push,
				examines1( pend_double_push ),
				alters2( dest, RR_ST ) );
		  
		  fprintf( asmstream, "; peepholer: transformed double push/pop pair\n" );

		  m &= ~(3U << dest);
		}
	      else
		{
		  /* wierd - pushing double then poping into non float register */
		  
		  if (stack_move < 0)
		    correct_stack();

		  dpush( pend_double_push );
	  
		  stack_offset += sizeof_int * 2;
		}
	    }
	}
      else
	{
	  if (stack_move < 0)
	    correct_stack();

	  dpush( pend_double_push );
	  
	  stack_offset += sizeof_int * 2;
	}

      pend_double_push = GAP;
d6773 1
a6773 1
      
d6826 1
a6826 1
	syserr( "TAILCALLK stack mis-aligned\n" );
d7106 1
a7106 1
	  
d7115 2
a7165 2
      fprintf( asmstream, "MOVDFR: r1r = %x, r2r = %x, mr = %x\n", r1r, r2r, mr );
      
d7238 6
a7243 5
	  if (r2r != r1r)
	    out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, r1r, r2r,
			  examines1( r2r ),
			  alters2( r1r, RR_ST ) );
      	}
d7258 1
a7258 1

d7286 5
a7290 4
	  if (mr != r1r)
	    out_diadic_op( OP_LDF, ADDR_MODE_REGISTER, r1r, mr,
			  examines1( mr ),
			  alters2( r1r, RR_ST ) );
d8015 2
a8016 2
	  if (stack_move < 0)
	    correct_stack();
d8018 8
a8025 3
	  save_regs( m );
      
	  stack_offset += sizeof_int * bitcount( m );
d8031 7
a8037 2
      pend_float_push = r1r;
      
d8041 7
a8047 2
      pend_double_push = r1r;
      
a8049 5
    case J_POPD:
      dpop( firstbit( m ) ); 
      
      return;
      
d8054 16
a8069 4
      
      restore_regs( m );
      
      stack_offset -= sizeof_int * bitcount( m );
d8255 270
d9254 2
@


1.57
log
@fixed load_string_constant()
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.56 1991/12/16 11:55:03 nickc Exp nickc $ */
d59 2
d118 8
d495 3
a497 3
  op_code &= 0x3f;
  source  &= 0xffff;
  dst     &= 0x1f;
d524 1
a524 1
      syserr( "out_diadic_op: bad addressing mode %d\n", addressing_mode );
d929 26
d961 2
a962 1
	      RealRegister	dest )
d966 12
a977 4
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, source,
		    examines1( source ),
		    alters2( dest, RR_ST )
		    );
d985 67
a1051 1
/* push a register onto the stack */
d1054 1
a1054 1
push( RealRegister reg )
d1056 7
d1067 4
d1073 1
a1073 1
} /* push */
d1076 1
a1076 1
/* pop a register from the stack */
d1079 1
a1079 1
pop( RealRegister reg )
d1081 11
d1098 1
a1098 1
} /* push */
d1197 202
d1412 3
d1436 2
a1437 2
			    examines1( src ),
			    op == OP_STI ? alters1( dst ) : alters2( dst, RR_ST ) );
d1442 2
a1443 2
			    examines1( src ),
			    op == OP_STI ? alters1( dst ) : alters2( dst, RR_ST ) );
d1449 2
a1450 2
			    examines1( src ),
			    op == OP_STI ? alters1( dst ) : alters2( dst, RR_ST ) );
d1483 164
d1648 6
a1653 1
		    op == OP_STI ? alters1( dst ) : alters2( dst, RR_ST ) );
d1698 2
a1699 1
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, tmp, 0 ),
d1701 182
a1882 1
		    op == OP_STI ? alters1( dst ) : alters2( dst, RR_ST ) );
d1887 1
a1887 1
} /* out_immediate_offset */
d1898 4
a1901 4
		    int32		op,		/* operation to perform (OP_LDI or OP_STI) */
		    RealRegister	dst,		/* destintaion of operation */
		    RealRegister	src,		/* address of value for operation */
		    RealRegister	offset )	/* offset from source address */
d1903 3
d1924 1
a1924 1
      /* add to the source register */
d1933 2
a1934 2
		    examines1( R_ATMP ),
		    op == OP_STI ? alters1( dst ) : alters2( dst, RR_ST ) );
d1953 2
a1954 2
		    examines2( RR_IR0, R_ATMP ),
		    op == OP_STI ? alters1( dst ) : alters2( dst, RR_ST ) );
d1962 16
a1977 3
typedef union count_position
  {
    int32 i;
d1979 3
a1981 9
    struct s
      {
	unsigned int posn : 12,
                     line : 16,
                     file : 4;
      }
    s;
  }
count_position;
d1983 5
d1989 1
a1989 4
/*
 * output an instruction using immediate addressing
 * handles the case when triadic addressing may be necessary
 */
d1991 9
a1999 9
static void
immediate_op(
	      int32		diadic_op,
	      int32		triadic_op,
	      RealRegister	dest,
	      RealRegister	source,
	      int32		value )
{
  if (is_word_addressed_( source ) || is_word_addressed_( dest ))
d2001 17
a2017 1
      /* calculations use word addressing */
d2019 3
a2021 1
      value /= sizeof_int;
d2023 2
d2026 2
a2027 17
  if (value == 0)
    {
      if (diadic_op == OP_OR   ||
	  diadic_op == OP_XOR  ||
	  diadic_op == OP_ADDI ||
	  diadic_op == OP_SUBI )
	{
	  if (source != dest)
	    {
	      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, source,
			    examines1( source ),
			    alters2( dest, RR_ST ) );
	    }
	  else
	    {
	      fprintf( asmstream, "; immediate_op(): eliminating op %lx with value 0", diadic_op );
	    }
d2029 12
a2040 7
	  return;
	}
      else
	{
	  cc_warn( "possibly generating unneccessary op code %lx!", diadic_op );
	}
    }
d2042 1
a2042 1
  if (dest == source && fits_in_16_bits( value ))
d2044 21
a2064 9
      out_diadic_op( diadic_op, ADDR_MODE_IMMEDIATE, dest, value,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
    }
  else if (fits_in_8_bits( value ))
    {
      out_triadic_op( triadic_op, dest, source, value, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( source ),
		     alters2( dest, RR_ST ) );
d2068 18
a2085 1
      load_integer( R_TMP1, value, FALSE );
d2087 3
a2089 3
      out_triadic_op( triadic_op, dest, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( R_TMP1, source ),
		     alters2( dest, RR_ST ) );
d2091 2
d2094 17
a2110 4
  return;
  
} /* immediate_op */
  
d2191 1
a2191 1
      out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, R_TMP1, r,
d2222 1
a2222 1
      move_register( source, dest );
d2291 1
a2291 1
      move_register( source, dest );
d2909 1
a2909 1
	  move_register( R_LR, R_TMP2 );
d2913 1
a2913 1
	  move_register( R_LR, R_TMP1 );
d2926 8
d2936 1
a2936 1
      move_register( R_LR, dest );
d2969 1
a2969 1
	  move_register( R_TMP2, R_LR );
d2973 1
a2973 1
	  move_register( R_TMP1, R_LR );
d3010 1
a3010 1
      move_register( R_LR, R_TMP1 );
d3047 1
a3047 1
      move_register( R_TMP1, R_LR );
d3181 1
a3181 1
	  move_register( dest, real_dest );
d3402 1
a3402 1
  move_register( R_LR, R_TMP1 );
d3417 1
a3417 1
  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_LR, -4 + 1,
d3419 9
a3427 1
		alters2( R_TMP2, RR_ST ) );
d3429 1
a3429 1
  /* add in offset into string table and move result into destination register */
d3431 1
a3431 1
  immediate_op( OP_ADDI, OP_ADDI3, dest, R_LR, litpoolp );
d3433 4
d3439 1
a3439 1
  move_register( R_TMP1, R_LR );
d3513 1
a3513 1
  move_register( R_LR, R_DS );
d3532 8
d3548 1
a3548 1
  move_register( R_LR, R_ADDR1 );
d3557 1
a3557 1
  move_register( R_DS, R_LR );
d3798 1
a3798 1
	  move_register( R_LR, R_DS );
d3812 8
d3822 1
a3822 1
	  move_register( R_LR, R_TMP1 );
d3846 1
a3846 1
	  move_register( R_DS, R_LR );
d4243 1
a4243 1
 * pushes every integer register whoes bit is set in 'mask'
d4247 1
a4247 1
save_iregs( int32 mask )
d4249 1
a4249 1
  int32	i;
d4256 2
a4257 2
  
  for (i = 31; i >= 0; i--)	/* XXX beware if number of registers > 32 */
d4261 1
a4261 1
	  push( i );
d4267 1
a4267 1
} /* save_iregs */
d4275 1
a4275 1
restore_iregs( int32 mask )
d4279 1
d4285 1
a4285 1
      pop( r1 );
d4292 2
a4293 1
} /* restore_iregs */
d4311 1
a4311 1
 *	stack extension code now implimented
d4827 1
a4827 1
      save_iregs( maskarg );
d4853 1
a4853 1
      push( R_FP );
d4857 1
a4857 1
      move_register( R_SP, R_FP );
d4888 2
a4889 2
      fprintf( asmstream, "; words required = %ld, already placed = %ld, greatest depth = %ld\n",
	      require, already_placed, greatest_stackdepth );
d4933 1
a4933 1
	  move_register( R_LR, R_TMP3 );
d4979 1
a4979 1
	  move_register( R_LR, R_TMP3 );
d5008 1
a5008 1
      save_iregs( mask );
d5078 1
a5078 1
      restore_iregs( saved_tmps );
d5734 1
a5734 1
		  push( dest );
d5738 1
a5738 1
		  move_register( dest, R_TMP2 );
d5854 1
a5854 1
	  move_register( tmp, R_TMP1 );
d5922 1
a5922 1
	  move_register( R_TMP1, tmp );
d6006 1
a6006 1
	  pop( dest );
d6010 1
a6010 1
	  move_register( R_TMP2, dest );
d6223 7
a6229 7
	      /* merge in half-word */
	      
	      outinstr( FUNC_LOAD                            << 28  |
		       half_word_op ? (OP_MH << 24) : (OP_MB << 24) |
		       selector                              << 23  |
		       ADDR_MODE_REGISTER                    << 21  |
		       hardware_register( R_TMP1 )           << 16  |
d6631 11
a6641 8
  RealRegister	r1  = vr1.r;
  RealRegister	r2  = vr2.r;
  int32		m   = vm.i;
  RealRegister	r1r = r1;
  RealRegister	r2r = r2;
  RealRegister	mr  = m;
  int32		opm;
  int32		dead;
a6642 1
  
d6738 108
d6973 1
a6973 1
	  syserr( "show_code: loading stack pointer with a constant address is not yet supported" );
d7060 1
a7060 1
	  move_register( R_LR, R_TMP2 );
d7115 1
a7115 1
	  move_register( R_TMP2, R_LR );
d7212 2
a7213 1
    case J_CMPR:
d7222 9
d7248 54
d7303 49
d7353 2
a7354 2
       * move the contents of register 'mr'
       * into register 'r1'
d7357 29
d7387 16
a7402 2
      if (r1r == mr)
	syserr( syserr_movr );
d7404 29
a7432 1
      move_register( mr, r1r );
d7434 18
d7454 21
d7501 22
d7577 1
a7577 1
	  move_register( r2r, r1r );
d7596 1
a7596 1
	  move_register( r2r, r1r );
d7666 2
a7667 1
    case J_ADDR:
d7673 7
d7681 5
d7695 2
a7696 1
    case J_SUBR:
d7703 13
d7725 2
a7726 1
    case J_MULR:
d7731 10
a7740 1
       */
d7742 1
d7846 20
d7868 1
a7868 1
       * load register 'r1r' with the "word"
d7900 20
d7951 20
d8005 20
d8102 9
a8110 2
      if (stack_move < 0)
	correct_stack();
d8112 4
a8115 1
      save_iregs( m );
d8117 4
a8120 1
      stack_offset += sizeof_int * bitcount( m );
d8123 3
d8127 1
d8134 1
a8134 1
      restore_iregs( m );
a8139 1
      
a8141 2
    case J_PUSHF:
    case J_PUSHD:
d8144 3
a8146 34
    case J_MOVFK:
    case J_MOVDK:
    case J_LDRFK:
    case J_LDRDK:
    case J_STRFK:
    case J_STRDK:
    case J_LDRFR:
    case J_LDRDR:
    case J_STRFR:
    case J_STRDR:
    case J_MOVIFR:
    case J_MOVIDR:
    case J_MOVFR:
    case J_MOVDR:
    case J_NEGFR:
    case J_NEGDR:
    case J_FIXFR + J_SIGNED:
    case J_FIXDR + J_SIGNED:
    case J_FLTFR + J_SIGNED:
    case J_FLTDR + J_SIGNED:
    case J_MOVFDR:
    case J_MOVDFR:
    case J_ADDFR:
    case J_ADDDR:
    case J_SUBFR:
    case J_SUBDR:
    case J_MULFR:
    case J_MULDR:
    case J_DIVFR:
    case J_DIVDR:
    case J_CMPFR:
    case J_CMPDR:
      syserr( "back end: floating point operations not yet supported" );
      
d8197 2
d8224 3
a8226 1

d8336 4
a8339 1

d8348 2
d8352 2
d8357 1
a8357 1
	  /* reached end of peep hole buffer */
d8364 2
d8368 2
d8383 2
d8411 1
a8411 1
/*    else fprintf( asmstream, "; could not swap %08x and %08x (prev read = %x, write = %x)(delayed read = %x, write = %x)\n",
d8569 4
d8577 1
a8577 1

d8595 3
a8597 2
	  if (!is_mode( curr_op, ADDR_MODE_INDIRECT ) ||
	      ((curr_op >> 13) & 1) == 0)
d8599 1
a8599 1
	      fprintf( asmstream, "; peepholer: eliminated multiple indentical diadic op codes\n" );
d8623 1
a8623 1
   * check for and indirect post incr 
d8665 5
a8669 5
  if (is_op(   prev_op, OP_LDI )             		  &&	/* previous operation is a load */
      is_mode( prev_op, ADDR_MODE_REGISTER ) 		  &&	/* from one register to another */
      is_mode( curr_op, ADDR_MODE_REGISTER ) 		  &&	/* and current operation is register based */
      (curr_op >> 29) == 0                   		  &&	/* and it is diadic */
      ((prev_op >> 16) & 0x1f) == ((curr_op >> 16) & 0x1f) )	/* and they both have the same destination */
d8706 25
@


1.56
log
@added a pragma (-Zpq1) to enable code for the C40 simulator
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.55 1991/12/13 15:06:59 nickc Exp nickc $ */
a341 19
 * output an instruction which cross references symbol 'name'
 */

static void
outxref(
	int32		op_code,	/* 32 bit op code */
	Symstr *	name,		/* symbol used by op code */
	int32		ref_type,	/* type of cross reference */
	int32		reads,		/* mask of registers examined by op code */
	int32		writes )	/* mask of registers altered by op_code */
{
  append_peep( OUT_XREF, op_code, reads, writes, name, 0, NULL, ref_type );
    
  return;
    
} /* outxref */


/*
d459 1
a459 1
 * build and send a simple diadic operation
d461 8
a468 9
  
static void
out_diadic_op(
	      int32		op_code,		/* 32 bit operand */
	      int32		addressing_mode,	/* form of addressing */
	      RealRegister	destination,		/* registers written to */
	      int32		source,			/* NB/ doubles up as a RealRegister */
	      unsigned long	reads,			/* mask of registers examined by op_code */
	      unsigned long	writes )		/* mask of registers altered by op_code */
d518 41
a558 2
  op |= source;
  
d561 1
a561 1
  outinstr( op, reads, writes );
d1312 10
a1321 1
	  fprintf( asmstream, "; immediate_op(): eliminating op %lx with value 0", diadic_op );
d1729 53
d2636 25
a2660 1
  cc_warn( "load_string_constant() has been called - this is not supported!" );
d2662 8
d2920 1
a2920 7
  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, reg, -2,
		 examines1( reg ),
		 alters2( reg, RR_ST ) );

  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, reg, R_BASE,
		 examines2( reg, R_BASE ),
		 alters2( reg, RR_ST ) );
a4720 4
  
  out_triadic_op( OP_LSH3, dst, start, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		 examines1( start ),
		 alters2( dst, RR_ST ) );
d4722 1
a4722 5
  /* and add to IR0 */

  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dst, R_BASE,
		 examines2( dst, R_BASE ),
		 alters2( dst, RR_ST ) );
a4951 12
  
  out_triadic_op( OP_LSH3, source, src, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		 examines1( src ),
		 alters2( source, RR_ST ) );
      
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, source, R_BASE,
		 examines2( source, R_BASE ),
		 alters2( source, RR_ST ) );
  
  out_triadic_op( OP_LSH3, dest, dst, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		 examines1( dst ),
		 alters2( dest, RR_ST ) );
d4953 2
a4954 3
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_BASE,
		 examines2( dest, R_BASE ),
		 alters2( dest, RR_ST ) );
a5819 21
 * convert the absolute word address in 'reg'
 * into a byte offset from IR0
 */

static void
convert_to_byte_offset( RealRegister reg )
{
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, reg, R_BASE,
		examines2( reg, R_BASE ),
		alters2( reg, RR_ST ) );

  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, reg, 2,
		 examines1( reg ),
		 alters2( reg, RR_ST ) );

 return;
  
} /* convert_to_byte_offset */

  
/*
d6083 4
d6088 3
d6807 4
a6817 2
      flush_peepholer( "end of procedure" );
      
d6912 3
a6914 3
  branch_round_literals( LabelNumber * m )
  {
    conditional_branch_to( Q_AL, m );
d6916 1
a6916 1
    return;
d6918 1
a6918 1
  } /* branch_round_literals */
@


1.55
log
@fixed (guess what) in_function (again)
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.54 1991/12/13 14:18:36 nickc Exp nickc $ */
d1374 1
a1374 2
#ifndef STUPID_BUG_IN_C40_SIMULATOR_FIXED
      if (n == 0)
d1376 10
a1394 1
#endif
@


1.54
log
@fixed is_function agaian
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.53 1991/12/13 12:16:58 nickc Exp nickc $ */
d1916 20
a1935 1
    return FALSE; 	
d2197 1
a2197 1
  else if (is_function( symbol ) && in_stubs)
@


1.53
log
@fixed is_function to cope with __dataseg having different names
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.52 1991/12/12 10:21:18 nickc Exp nickc $ */
d1894 1
a1894 1
  if (symbol == bindsym_(datasegment)) /* __dataseg has no data associated with it */
d1897 18
d1916 1
a1916 1
    return TRUE; 	/* Default to true becuase functions like 'stackoverflow' & 'printf' have no data */
@


1.52
log
@tidied up to pass through ncc without warnings
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.51 1991/12/10 18:30:01 nickc Exp nickc $ */
d1894 1
a1894 1
  if (streq( symname_( symbol ), "__dataseg" )) /* __dataseg has no data associated with it */
d2421 2
a2422 1
		syserr( "load_address_constant: cannot take an offset from a function pointer" );
@


1.51
log
@fixed code for loading function pointers when building resident libraries
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.50 1991/12/10 17:36:46 nickc Exp nickc $ */
d157 4
a160 4
#define examines1( r1 )			 (1 << (r1))
#define examines2( r1, r2 )		((1 << (r1)) | (1 << (r2)))
#define examines3( r1, r2, r3 )		((1 << (r1)) | (1 << (r2)) | (1 << (r3)))
#define examines4( r1, r2, r3, r4 )	((1 << (r1)) | (1 << (r2)) | (1 << (r3)) | (1 << (r4)))
d186 2
d189 1
a190 1
int			in_stubs = 0;
d252 2
d272 1
d296 1
d315 1
d339 2
a360 2
 * XXX
 *
d374 2
d487 2
a488 2
	      int32		reads,			/* mask of registers examined by op_code */
	      int32		writes )		/* mask of registers altered by op_code */
d806 1
a806 1
static unsigned int
d833 2
d871 1
d912 2
a913 1
		    alters2( dest, RR_ST ) );
d1056 1
a1056 1
		     bool		can_corrupt_src )
d1293 1
a1293 1
	  fprintf( asmstream, "; immediate_op(): eliminating op %x with value 0", diadic_op );
d1299 1
a1299 1
	  cc_warn( "possibly generating unneccessary op code %x!", diadic_op );
d2360 3
a2363 2
	  cc_warn( "Comparing the addresses of an external functions may not work with -Zl or -Zr" );

d2795 1
a2795 1
		   int		len,		/* amount to increment 'reg' (in bytes) after storing */
a2959 1
      int32 		d = obj_symref( name, xr_code, 0 );
d3753 1
a3753 1
static int
d3756 1
a3756 1
  unsigned int	count = 0;
d3930 2
a3931 2
      int		require;
      int		already_placed;
d3942 1
a3942 1
      fprintf( asmstream, "; words required = %d, already placed = %d, greatest depth = %d\n",
d4535 1
a4535 1
	     bool		can_corrupt_start )
d4742 5
a4746 5
	    RealRegister	src,
	    RealRegister	dst,
	    int32		length,
	    bool		can_corrupt_source,
	    bool		can_corrupt_dest )
d5147 1
d5170 2
a5171 1
  
d5182 5
a5186 5
	    bool		offset_in_register,	/* true if offset is a RealRegister */
	    bool		can_corrupt_address,	/* true if address register can be corrupted */
	    bool		is_signed,		/* true if loading a signed quantity */
	    bool		half_word_op,		/* true if operand is a half-word quantity */
	    bool		is_load )		/* true if the operation is a load op */
d6672 3
a6674 3


/* XXX - routine entry and exit */
d6684 1
a6684 1
	   
d6686 1
a6686 1

d6689 1
a6689 1

d6691 1
a6691 1

d6693 1
a6693 1

d6695 1
a6695 1

d6699 1
a6699 1

d6715 1
a6715 1

d6718 1
a6718 1

d6720 1
a6720 1

d6724 2
a6725 2


d6730 1
a6730 1

d6732 1
a6732 1

d6736 3
a6738 1

a6739 2
/* XXX - Now the floating point part of the instruction set */

d6783 1
a6783 1

d6792 5
a6796 5
branch_round_literals( LabelNumber * m )
{
  conditional_branch_to( Q_AL, m );
  
  return;
d6798 1
a6798 1
} /* branch_round_literals */
d6802 5
a6806 5
mcdep_init( void )
{
  return;
  
} /* mcdep_init */
d6810 5
a6814 5
localcg_tidy( void )
{
  return;

} /* localcg_tidy */
d6817 5
a6821 5
localcg_reinit( void )
{
  return;
  
} /* localcd_reinit */
d7017 1
a7017 1
	  peep_buf[ delayed ].reads |= ( 1 << RR_PC);
d7198 1
a7198 1
      int	type = (curr_op >> 29) & 0x7;
d7215 1
a7215 1
	  int	mode = (curr_op >> 21) & 0x3;
d7249 2
a7250 2
      int32		dest;
      signed int	amount;
d7261 1
a7261 1
	  peep_buf[ prev ].op_code = (prev_op & 0xffffff00U) | (amount & 0xff);
d7391 1
a7391 1
      int	new_op = 0;
d7424 1
a7424 1
	  peep_buf[ prev ].op_code = (B_11 << 30)                           |
d7427 1
a7427 1
		                     (curr_op & (B_111 << 8))  << (19 -  8) |
d7429 1
a7429 1
		                     (prev_op & (0xFF << 8))   << ( 8 -  8) |
d7439 1
a7439 1
      int	new_op = 0;
d7616 3
a7618 3
  if (peep_end != peep_start                   &&
      (peep_buf[ prev ].writes & (1 << RR_ST)) &&
      (peep_buf[ prev ].writes & (1 <<     r))  )
@


1.50
log
@added comment
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.49 1991/12/10 17:33:30 nickc Exp nickc $ */
d2327 1
a2327 40
      /* we need an address register to load the pointer */
      
      if (is_address_register( hardware_register( dest ) ))
	{
	  tmp = dest;
	}
      else
	{
	  tmp = R_ATMP;
	}

      /*
       * get address of module table into 'tmp'
       */
      
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, tmp, R_MT,
		    examines1( R_MT ),
		    alters2( tmp, RR_ST ) );
      
      /*
       * add in the offset of the module containing 'name'
       *
       * XXX - we asssume that there will never be more than 32767 modules
       */

      peep_xref( X_DataModule, symbol );
      
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
		    examines1( tmp ),
		    alters2( tmp, RR_ST ) );
      
      /*
       * get the address of the module's function table or data slots
       */
      
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, is_func ? tmp : dest, build_indirect( INDIRECT_REL, tmp, 0 ),
		    examines1( tmp ),
		    alters2( is_func ? tmp : dest, RR_ST ) );

      if (is_func)
a2328 3
	  if (offset != 0)
	    syserr( "load_address_constant: cannot take an offset from a function pointer" );

d2330 1
a2330 1
	   * add in the offset of the function
d2332 7
a2338 2
	   * XXX - we are assuming that there will never be more than 32767
	   * functions in one module
d2340 4
a2343 1
	   * This code is used by :-
d2345 1
a2345 4
	   * int use( int (* f )() ) { return (*f)(); }
	   * int func( void );
	   * int main( void ) { return use( func ); }
	   * int func( void ) { return 1; }
d2348 3
a2350 1
	  peep_xref( X_DataSymb, symbol );
d2352 3
a2354 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
			examines1( tmp ),
			alters2( tmp, RR_ST ) );
d2356 1
a2356 1
	  /* and fetch the address out of the function table */
d2358 3
a2360 3
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, tmp, 0 ),
			examines1( tmp ),
			alters2( dest, RR_ST ) );
d2364 7
a2370 1
	  if (!fits_in_16_bits( offset ))
d2372 1
a2372 1
	      syserr( "external data: offset too big (offset = %d)", offset );
d2374 1
a2374 1

d2376 1
a2376 4
	   * load R_TMP1 with the high part offset of 'name' into the data table
	   *
	   * Note that we assume here, (and elsewhere) that there will never be more than
	   * 32767 functions in one module.
d2378 5
a2382 7

	  peep_xref( X_DataSymbHi, symbol );
      
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
			examines0(),
			alters1( R_TMP1 ) );

d2384 1
a2384 1
	   * load R_TMP1 with the low part offset of 'name' into the data slots or function table
d2386 1
a2386 2
	   * XXX - there is a potential bug here if the given offset plus the
	   * symbol's offset exceed 16 bits.
d2388 7
a2394 7

	  peep_xref( X_DataSymbLo, symbol );
      
	  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );

d2396 1
a2396 1
	   * and add R_TMP1 into dest
d2398 80
a2477 5
      
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
			examines2( dest, R_TMP1 ),
			alters2( dest, RR_ST ) );
	}
@


1.49
log
@oops, fixed calculation of address of external function pointers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.48 1991/12/05 10:35:26 nickc Exp nickc $ */
d2376 7
@


1.48
log
@fixed coping with large offsets of data symbols
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.47 1991/12/04 11:31:12 nickc Exp nickc $ */
d1280 1
a1280 1
	  fprintf( asmstream, "* immediate_op(): eliminating op %x with value 0", diadic_op );
d1368 1
a1368 1
	      fprintf( asmstream, "* peepholer: eliminated compare!\n" );
d2378 2
d2641 4
d2647 1
a2647 1
  if (fits_in_8_bits( offset ))
d2655 7
d3778 1
a3778 1
      maskarg  = regbit( R_A1  + n ) - regbit( R_A1  );
d3783 2
d3787 2
a3788 2
  /* fprintf( asmstream, "routine entry: registers used: %x, saved = %x and %x\n",
	  regmaskvec.map[ 0 ], mask, maskarg ); */
d3882 3
d6959 1
a6959 1
/* 	  fprintf( asmstream, "* eliminated a NOP\n" ); */
d6963 1
a6963 1
/*    else fprintf( asmstream, "* could not swap %08x and %08x (prev read = %x, write = %x)(delayed read = %x, write = %x)\n",
d7013 1
a7013 1
	  /* fprintf( asmstream, "* converted a conditional branch\n" ); */
d7146 1
a7146 1
	      fprintf( asmstream, "* peepholer: eliminated multiple indentical diadic op codes\n" );
d7162 1
a7162 1
	      fprintf( asmstream, "* peepholer: eliminated multiple indentical triadic op codes\n" );
d7201 1
a7201 1
	  fprintf( asmstream, "* peepholer: transformed indirect addition\n" );
d7247 1
a7247 1
	  fprintf( asmstream, "* peepholer: merged load and op into triadic op\n" );
d7277 1
a7277 1
      fprintf( asmstream, "* peepholer: transformed LDI, LDI into LDI || LDI\n" );
d7291 1
a7291 1
      fprintf( asmstream, "* peepholer: transformed LDI, STI into LDI || STI\n" );
d7305 1
a7305 1
      fprintf( asmstream, "* peepholer: transformed STI, LDI into LDI || STI\n" );
d7319 1
a7319 1
      fprintf( asmstream, "* peepholer: transformed STI, STI into STI || STI\n" );
d7370 1
a7370 1
	  fprintf( asmstream, "* peepholer: transformed triadic & store into parallel op\n" );
d7418 1
a7418 1
	  fprintf( asmstream, "* peepholer: transformed triadic and store into parallel op\n" );
d7588 1
a7588 1
  /* fprintf( asmstream, "* flushed: %s (after %dth instruction in function)\n", reason, codep / 4 + 1 ); */
@


1.47
log
@fixed new use of LAJ to get PC
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.46 1991/12/03 19:14:13 nickc Exp nickc $ */
a1914 5
  if (!fits_in_16_bits( offset ))
    {
      syserr( "load_address_constant: offset too big (offset = %d)", offset );
    }

d1966 3
a1968 2
       * XXX - this is a potential bug if the given offset plus the symbol's offset
       * exceeds 16 bits!
d1973 1
a1973 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
d1977 5
d2099 1
a2099 5
       *  static int
       *  func( void )
       *  {
       *    return 1;
       *  }
d2206 1
a2206 1
       *   LDI   modnum + offset_of_MT, R_ATMP	- get offset of module table plus offset of module table pointer into temp
d2215 1
a2215 1
       * assume the pessimistic case , but we will allow the linker
d2390 5
d2399 1
a2399 1
	   * 65535 functions in one module.
d2673 1
a2673 3
 * code we have just compiled.  This function is used to get
 * hold to the PC once, rather than every time a symbol is
 * referenced
@


1.46
log
@changed use of CALL to use LAJ (not yet fully tested)
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.45 1991/11/13 18:54:04 nickc Exp nickc $ */
d1997 1
a1997 1
       *   extern int munge( int (*f)() );
d2001 1
a2001 1
       *   int func2( void ) { return munge( func1 ); }
d2111 1
a2111 1
      move_register( R_LR, R_TMP3 );
a2116 4
      /* retreive PC from R_LR */

      move_register( R_LR, R_TMP1 );

d2119 2
a2120 2
       * 'top 16 bits of offset of symbol from this label + 4'
       * we assume that the '+ 4' will be lost in the shifting
d2132 1
a2132 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP2, 1 + 4,
d2142 2
a2143 2
      out_triadic_op( OP_ADDI3, dest, R_TMP1, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( R_TMP1, R_TMP2 ),
d2148 1
a2148 1
      move_register( R_TMP3, R_LR );
d2357 1
a2357 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, (is_func && split_module_table) ? 1 : 0,
d2856 1
a2856 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, split_module_table ? 1 : 0,
d5953 2
a5954 3
	   * get address of jump table (set later)
	   *
	   * XXX - we assume this offset will fit in 8 bits
d5956 1
a5956 5

	  peep_fref( tablelab, LABREF_LIT8 );

	  /* add the offset of start of table and switch index into temp register */

d5973 1
a5973 1
	   * are 3 instructions between the instruction now pionted at by the link
d5977 10
d5989 1
a5989 1
			 alters2( R_ATMP, RR_ST ) );  /* relative to the LAJ instruction below */
@


1.45
log
@fixed decoding of static function references
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.44 1991/11/11 14:24:03 nickc Exp nickc $ */
d1361 1
a1361 1
#ifdef STUPID_BUG_IN_C40_SIMULATOR_FIXED
d1366 1
a1366 9
	  if (peep_sets_status_reg( r ) &&
	      (test == Q_EQ  ||
	       test == Q_NE  ||
	       test == Q_UEQ ||
	       test == Q_UNE ||
	       test == Q_GT  ||
	       test == Q_GE  ||
	       test == Q_LT  ||
	       test == Q_LE   ))
d1368 1
a1368 1
	      fprintf( asmstream, "* peepholer: eliminated compare!\n" ); */
d2009 11
d2021 1
a2021 1
      /* put PC of next instruction on stack */
d2023 1
a2023 1
      outinstr( OP_CALL << 24, examines0(), alters1( RR_PC ) );
d2027 1
a2027 1
      flush_peepholer( "getting address of POP" );
d2029 1
a2029 1
      d = codep + codebase - d;
d2031 3
a2033 1
      /* retreive PC from stack */
a2034 4
      out_diadic_op( OP_POP, ADDR_MODE_DIRECT, dest, 0,
		    examines1( RR_SP ),
		    alters3( dest, RR_ST, RR_PC ) );

d2057 15
d2109 5
a2113 9
      /*
       * get hold of PC
       *
       * we do this by doing a CALL 0 (ie jsr to next instruction)
       * followed by a POP into our temporary register
       *
       * XXX - this is inefficient as the CALL takes 4 cycles
       * XXX - improve sometime - use RPTS or LAJ ?
       */
d2115 1
a2115 1
      outinstr( OP_CALL << 24, examines0(), alters1( RR_PC ) );
d2117 1
a2117 3
      out_diadic_op( OP_POP, ADDR_MODE_DIRECT, R_TMP1, 0,
		    examines1( RR_SP ),
		    alters3( R_TMP1, RR_ST, RR_SP ) );
d2119 2
d2123 2
a2124 2
       * 'top 16 bits of offset of symbol from this label + 1'
       * we assume that the '+ 1' will be lost in the shifting
d2136 1
a2136 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP2, 2,
d2149 4
d2448 1
a2448 48
  /*
   * get hold of PC
   *
   * we do this by doing a CALL 0 (ie jsr to next instruction)
   * followed by a POP into our temporary register
   *
   * XXX - this is inefficient as the CALL takes 4 cycles
   * XXX - improve sometime - use RPTS ??
   */

  outinstr( OP_CALL << 24, examines0(), alters1( RR_PC ) );
      
  out_diadic_op( OP_POP, ADDR_MODE_DIRECT, dest, 0,
		examines1( RR_SP ),
		alters3( dest, RR_SP, RR_ST ) );

  /*
   * subtract PC from base address register
   */

  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, dest, R_BASE,
		examines2( dest, R_BASE ),
		alters2( dest, RR_ST ) );

  /*
   * BEWARE - the following code may fail on literal pool overflow
   */

  /*
   * note that the next instruction needs the address of label 'litpool'
   */
  
  peep_fref( litlab, LABREF_LIT16 );

  /*
   * the '3' in the following instruction is
   * because there are 3 op codes between the
   * CALL and this instruction
   */
  
  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, litpoolp + 3,
		examines1( dest ),
		alters2( dest, RR_ST ) );

  /*
   * place string into literal pool at 'litpoolp'
   * the TRUE indicated that we are inside code
   */
a2449 11
  codeseg_stringsegs( (StringSegList *)string_constant, TRUE );

  /*
   * convert to a byte offset
   *
   * note assumption that sizeof_int == 4 * sizeof_char
   */

  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dest, 2,
		examines1( dest ),
		alters2( dest, RR_ST ) );
d2516 1
a2516 9
  /*
   * get hold of PC (into our temporary register)
   *
   * we do this by doing a CALL +0 (ie jsr to next instruction)
   * followed by a POP into our temporary register
   *
   * XXX - this is inefficient as the CALL takes 4 cycles
   * XXX - improve sometime - use LAJ ??
   */
d2518 2
a2519 2
  outinstr( OP_CALL << 24, examines0(), alters1( RR_PC ) );

d2521 1
a2521 1
   * make sure that the instruction is emitted
d2532 4
d2543 1
a2543 3
  out_diadic_op( OP_POP, ADDR_MODE_DIRECT, R_ADDR1, 0,
		examines1( RR_SP ),
		alters3( R_ADDR1, RR_SP, RR_ST ) );
d2545 2
d2549 1
a2549 1
   * address of the POP instruction.
d2552 10
d2566 2
a2567 1
  
d2612 1
a2612 1
   * IR0    start of code    start of 'name'     start of init code   CALL +0
d2616 4
d2621 1
a2621 1
  offset = ((codep_of_call + codebase) - obj_symref( name, xr_code, 0 )) / sizeof_int - 1;
d2790 5
a2794 1
	  /* put PC of next instruction on stack */
d2796 1
a2796 1
	  outinstr( OP_CALL << 24, examines0(), alters1( RR_PC ) );
d2800 1
a2800 1
	  flush_peepholer( "getting address of POP" );
d2804 1
a2804 1
	  offset = codep + codebase - offset;
d2806 3
a2808 5
	  /* retreive PC from stack */
      
	  out_diadic_op( OP_POP, ADDR_MODE_DIRECT, R_TMP1, 0,
			examines1( RR_SP ),
			alters3( reg, RR_ST, RR_PC ) );
d2825 8
d5966 1
a5966 3
	  out_triadic_op( OP_ADDI3, R_ATMP, r1r, 5, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( r1r ),
			 alters2( R_ATMP, RR_ST ) );  /* relative to the CALL instruction below */
d5968 3
a5970 1
	  /* get hold of PC */
d5972 1
a5972 1
	  outinstr( OP_CALL << 24, examines0(), alters1( RR_PC ) );
d5974 2
d5978 1
a5978 3
	  out_diadic_op( OP_POP, ADDR_MODE_DIRECT, R_TMP1, 0,
			examines1( RR_SP ),
			alters2( RR_SP, R_TMP1 ) );
d5980 5
a5984 1
	  codep_of_call = codep;
d5986 3
a5988 1
	  flush_peepholer( "switch table 1" );
d5990 1
a5990 1
	  /* and add into address */
d5992 1
a5992 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_TMP1,
d5998 1
a5998 1
	  out_triadic_op( OP_ADDI3, R_ATMP, R_TMP1, build_indirect( INDIRECT_REL, R_ATMP, 1 ),
d6000 1
a6000 1
			 examines2( R_TMP1, R_ATMP ),
d6003 1
a6003 1
	  /* adjust offset to be relative to the POP instruction */
d6005 1
a6005 1
	  out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_ATMP, (codep_of_call + codebase) >> 2,
d6010 4
d6023 1
a6023 1
	  flush_peepholer( "switch table" );
@


1.44
log
@added support for pragma -b1 to turn off delayed branches + fixed bug in required size of stack calculation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.43 1991/11/08 17:10:06 nickc Exp nickc $ */
d1274 15
a1288 1
    cc_warn( "possibly creating unneccessary op codes!" );
d1361 1
d1376 1
a1376 1
	      /* fprintf( stderr, "eliminating compare!\n" ); */
d1381 1
a1400 2

  UNUSED( test );
d2064 1
a2064 1
       * BYTE offset = (PC of current position in code - IR0) * number of bytes in a word +
d2066 22
d2090 3
a2092 3
      fprintf( stderr, "symbol is not previously defined; it is static\n" );
      fprintf( stderr, "WARNING THIS CODE NOT YET EXAMINED\n" );
      
d2096 1
a2096 1
       * we do this by doing a CALL 0 (ie jsr to next instrcution)
d2100 1
a2100 1
       * XXX - improve sometime - use RPTS ??
d2110 4
a2113 1
       * XXX - we are assuming that there will be no more than 65535 words of data per module
d2116 5
a2120 9
      /*
       * load offset into second temporary
       *
       * this instruction will need to be patched by the linker
       * hence the cross reference
       *
       * XXX - there is a potential bug here if the given offset plus
       * the symbol's offset exceeds 16 bits
       */
d2122 1
a2122 1
      peep_xref( X_PCreloc, symbol ); 
d2124 1
a2124 1
      out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_ATMP, offset,
d2126 1
a2126 1
		    alters2( R_ATMP, RR_ST ) );
d2134 2
a2135 2
      out_triadic_op( OP_ADDI3, dest, R_TMP1, R_ATMP, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( R_TMP1, R_ATMP ),
d2435 1
a2435 1
   * we do this by doing a CALL 0 (ie jsr to next instrcution)
d2561 1
a2561 1
   * we do this by doing a CALL +0 (ie jsr to next instrcution)
d3891 5
d3897 1
a3897 1
      if (require > 0)
d6929 2
a6930 2

  if (count < 3 && delayed != peep_start && !suppress_delayed_branches)
@


1.43
log
@added new peephole optimisation and improved stack size adjustment code
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.42 1991/11/07 17:49:40 nickc Exp nickc $ */
d3855 1
a3855 1
      require = greatest_stackdepth / sizeof_int;
d4524 1
a4524 1
  else if (fits_in_16_bits_unsigned( length ))
d4548 1
a4548 1
       /* XXX load RC from itself ! - WILL THIS WORK ? */
d4847 1
a4847 1
      length = (length - 2) / sizeof_int;
d4849 5
d6889 2
a6890 2
    
  if (count < 3 && delayed != peep_start)
@


1.42
log
@fixed bug in out_diadic_op whereby the 'destination' value of a OP_STIK instruction was being translated intoa register number
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.41 1991/11/06 12:00:07 nickc Exp nickc $ */
d81 1
d85 1
a85 1
   void		export_data_symbol( Symstr * name, RealRegister dest, int rpt, int offset, int len );
d513 1
a513 1
      op |= 0x1 << 21;
d517 1
a517 1
      op |= 0x2 << 21;
d521 1
a521 1
      op |= 0x3 << 21;
d592 1
a592 1
  op = (0x1L << 29) | (op_code << 23) | (dst << 16);
d608 2
a609 2
	  op |= (0x0 << 21);	/* set the T    field */
	  op |= (0x0 << 28);	/* set the type field */
d628 2
a629 2
	      op |= (0x1 << 21);	/* set the T field */
	      op |= (0x1 << 28);	/* set the type field */
d661 2
a662 2
	  op |= (0x0 << 21);	/* set the T field */
	  op |= (0x1 << 28);	/* set the type field */
d689 2
a690 2
	  op |= (0x1 << 21);	/* set the T field */
	  op |= (0x0 << 28);	/* set the type field */
d713 2
a714 2
	      op |= (0x3 << 21);	/* set the T field */
	      op |= (0x1 << 28);	/* set the type field */
d733 2
a734 2
	      op |= (0x3 << 21);	/* set the T field */
	      op |= (0x0 << 28);	/* set the type field */
d767 2
a768 2
	  op |= (0x2 << 21);	/* set the T field */
	  op |= (0x1 << 28);	/* set the type field */
a978 8
  else if (fits_in_16_bits_unsigned( n ) && hardware_register( r ) == 0x10 /* DP */)
    {
      /* can use special load instruction */
      
      out_diadic_op( OP_LDPK, ADDR_MODE_IMMEDIATE, r, n,
		    examines0(),
		    alters1( r ) );
    }
d983 2
d1312 1
a1312 1
  if (!fits_in_16_bits( stack_move ))
d1314 1
a1314 1
      syserr( "correct_stack: too much stack space has been used!" );
a1315 5
  
  if (stack_move > 0)
    {
      immediate_op( OP_ADDI, OP_SUBI3, R_SP, R_SP, stack_move );
    }
d1570 1
a1570 1
  outdelayed( OP_BRcD << 24 | 0x1 << 21 | C_FROMQ( condition ) << 16 | (num_to_skip & 0xffff),
d1624 1
a1624 1
      w   = (destination->u.defn) & 0x7fffffffL;	/* get position of label in our code */
d1661 1
a1661 1
	  outdellabref( OP_BRcD << 24 | 0x1 << 21 | C_FROMQ( condition ) << 16 | (-3 & 0xffff),
d2463 44
d3199 1
a3199 1
      outdelsymref( (OP_BRD << 24) | (-3 & 0x00ffffff), name, examines0(), alters1( RR_PC ) );
d3203 1
a3203 1
      outdelsymref( (OP_LAJ << 24) | (-3 & 0x00ffffff), name, examines0(), alters2( R_LR, RR_PC ) );
d4101 1
a4101 1
      outdelayed( OP_BRcrD << 24 | 0x1 << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_LR ),
d4271 1
a4271 1
      int32 		q = (v & 0x00ffffff);   /* BYTE address */
d4283 1
a4283 1
      switch (v & (unsigned long) 0xff000000)
d4302 1
a4302 1
	      w = (w & (unsigned long) 0xFF000000U) | (d & 0x00FFFFFFU);
d4316 1
a4316 1
	  w = (w & (unsigned long) 0xffff0000U) | (d & 0xffff);
d4329 1
a4329 1
	  w = (w & (unsigned long) 0xffff0000) | (d & 0xffff);
d4342 1
a4342 1
	  w = (w & (unsigned long) 0xffffff00) | (d & 0xff);
d4373 1
a4373 1
  lab_setloc_( l, codep | (unsigned long) 0x80000000 ); /* cheapo union checker for ->frefs */
d4614 1
a4614 1
	  outinstr( FUNC_LOAD << 28 | OP_LBU << 24 | 0x3 << 23 | ADDR_MODE_INDIRECT << 21 |
d4961 1
a4961 1
	  outinstr( FUNC_LOAD << 28 | OP_LWR << 24 | 0x1 << 23 | ADDR_MODE_REGISTER << 21 |
d5792 1
a5792 1
      outdelayed( (OP_LAJcr << 24) | 0x1L << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( mr ),
d5805 1
a5805 1
      outdelayed( OP_BRcrD << 24 | 0x1L << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( mr ),
d5859 1
a5859 3
	  /* XXX - what now ??? */

	  /* fp_minus_sp += xx; */
d5882 1
a5882 1
	      fprintf( stderr, "Unused label L%ld\n", lab_name_( l ) & 0x7fffffffL );
d6018 1
a6018 1
				      bindsym_( codesegment ), codebase + (l->u.defn & 0x00ffffff));
d6068 2
a6069 1
	  stack_move  -= diff;
d6951 1
a6951 1
	      op = (op & (unsigned long)0xFFFF0000L) | (off & 0x0000FFFFL);
d6977 1
a6977 1
	  off = mask_and_sign_extend_word( op, 0x00FFFFFFL );
d6984 1
a6984 1
	  op = (op & (unsigned long)0xFF000000L) | (off & 0x00FFFFFFL);
d7146 1
a7146 1
	  peep_buf[ prev ].op_code = (prev_op & (unsigned long)0xffffff00L) | (amount & 0xff);
d7154 46
d7601 1
a7601 1
	  offset = instruction->label->u.defn & 0x7fffffffL;
d7614 1
a7614 1
	      offset += mask_and_sign_extend_word( op, 0x00FFFFFFL );
d7621 1
a7621 1
	      op = (op & (unsigned long)0xFF000000L) | (offset & 0x00FFFFFFL);
d7626 1
a7626 1
	      offset += mask_and_sign_extend_word( op, 0x0000FFFFL );
d7633 1
a7633 1
	      op = (op & (unsigned long)0xFFFF0000L) | (offset & 0x0000FFFFU);
d7665 1
a7665 1
      offset = mask_and_sign_extend_word( op, 0x00ffffffL );
d7671 2
a7672 2
	  op = (op & (unsigned long)0xff000000L) |
	    ((offset - (codep / sizeof_int)) & 0x00ffffffL);
@


1.41
log
@fixed data initialisation code
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.40 1991/11/05 17:28:43 nickc Exp nickc $ */
d484 8
a491 1
  dst = hardware_register( destination );
d1852 2
d2804 5
a2808 1
	  /* add in the offset of the module containing 'name' */
d2972 1
a2972 1
	  out_diadic_op( OP_STI, ADDR_MODE_IMMEDIATE, value,
d2979 1
a2979 1
	  out_diadic_op( OP_STI, ADDR_MODE_IMMEDIATE, value, build_indirect( INDIRECT_REL, dest, 0 ),
@


1.40
log
@can now initialise global variables with the address of a function
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.39 1991/11/05 16:50:35 nickc Exp nickc $ */
d79 1
a79 1
   void		load_static_data_ptr( RealRegister r, bool iscode );
d156 4
a159 4
#define examines1( r1 )			(1 << r1)
#define examines2( r1, r2 )		((1 << r1) | (1 << r2))
#define examines3( r1, r2, r3 )		((1 << r1) | (1 << r2) | (1 << r3))
#define examines4( r1, r2, r3, r4 )	((1 << r1) | (1 << r2) | (1 << r3) | (1 << r4))
d1710 5
d1751 1
a1751 1
 *                        (byte offset from IR0 of ...)              (word pointer to)
d1773 6
d1795 2
a1796 1
		     bool		iscode )
d1838 1
a1838 1
  peep_xref( X_Modnum, 0 );
d1951 1
a1951 1
      load_static_data_ptr( dest, FALSE );
d2104 1
a2104 1
  else if (is_function( symbol ))
d2111 1
a2111 1
       * External code reference
d2116 5
d2181 1
a2181 1
       * number of 'name' is less than 256
d2191 1
a2191 1
       * add in the offset of the module containing 'name'
d2193 1
a2193 1
       * XXX - we asssume that there will never be more than 65535 modules
d2213 1
a2213 1
       * add in the offset of 'name' into the function table
d2241 1
d2246 1
a2246 1
       * All we have left are external data symbols
d2250 3
d2257 1
a2257 1
       * functions, except that we must assume that there can be more than 65535
d2284 2
d2296 1
a2296 1
       * get address of module table into 'dest'
d2306 1
a2306 1
       * XXX - we asssume that there will never be more than 65535 modules
d2311 1
a2311 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, tmp, 0,
d2316 1
a2316 1
       * get the address of the module's function table
d2319 1
a2319 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, tmp, 0 ),
d2321 34
a2354 1
		    alters2( dest, RR_ST ) );
d2356 10
a2365 3
      /*
       * load R_TMP1 with the high part offset of 'name' into the data table
       */
d2367 1
a2367 1
      peep_xref( X_DataSymbHi, symbol );
d2369 3
a2371 10
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
		    examines0(),
		    alters1( R_TMP1 ) );
      
      /*
       * load R_TMP1 with the low part offset of 'name' into the data table
       *
       * XXX - there is a potential bug here if the given offset plus the
       * symbol's offset exceed 16 bits.
       */
d2373 3
a2375 1
      peep_xref( X_DataSymbLo, symbol );
d2377 4
a2380 11
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, offset,
		    examines1( R_TMP1 ),
		    alters2( R_TMP1, RR_ST ) );
      
      /*
       * and add R_TMP1 into dest
       */
      
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1,
		    examines2( dest, R_TMP1 ),
		    alters2( dest, RR_ST ) );
a2726 9
      /*
       * This is can happen with the following code:
       *
       *   int func1( void ) { return 3; }
       *
       *   int (* func_ptr)() = func;
       *
       */

d2730 14
a2743 1
      /* put PC of next instruction on stack */
d2745 1
a2745 1
      outinstr( OP_CALL << 24, examines0(), alters1( RR_PC ) );
d2747 1
a2747 1
      /* adjust symbol offset to be relative to next instruction */
d2749 1
a2749 1
      flush_peepholer( "getting address of POP" );
d2751 1
a2751 1
      /* calculate required offset */
d2753 1
a2753 1
      offset = codep + codebase - obj_symref( name, xr_code, 0 );
d2755 1
a2755 1
      /* retreive PC from stack */
d2757 31
a2787 3
      out_diadic_op( OP_POP, ADDR_MODE_DIRECT, R_TMP1, 0,
		    examines1( RR_SP ),
		    alters3( reg, RR_ST, RR_PC ) );
d2789 5
a2793 1
      /* compute compound offset */
d2795 1
a2795 2
      if (offset & 3)
	syserr( "export_data_symbol: function pointer not word aligned!" );
d2797 5
a2801 1
      offset /= sizeof_int;
d2803 13
a2815 5
      if (offset)
	{
	  /* indicate that the next instruction will reference 'symbol' */
  
	  peep_symref( name );
d2817 5
a2821 1
	  immediate_op( OP_SUBI, OP_SUBI3, R_TMP1, R_TMP1, offset );
d2823 1
a2823 1

d2828 49
a2876 2
      syserr( "exporting data relative to (non-function) symbol %s - currently unsupported",
	     symname_( name ) );
d3027 1
a3027 1
} /* RealRegister */
d6852 1
a6852 1
	  
d6856 1
a6856 1
	  peep_buf[ delayed ].reads |= RR_PC;
d6864 1
a6864 1
/*    else fprintf( asmstream, "* could not swap %x and %x (prev read = %x, write = %x)(delayed read = %x, write = %x)\n",
@


1.39
log
@added more stack checking code
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.38 1991/11/04 11:00:04 nickc Exp nickc $ */
d2672 25
a2696 1
      /* ensure word pointer's increment is in words */
d2698 3
a2700 2
      if (len & 3)
	syserr( "export_data: non word aligned address increment" );
d2702 5
a2706 1
      len /= sizeof_int;
d2708 2
a2709 1
      /* and store resultant address, incrementing word pointer */
d2711 3
a2713 1
      if (len == 0)
d2715 5
a2719 3
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, reg, 0 ),
			examines2( reg, R_TMP1 ),
			alters0() );
d2721 2
a2722 18
      else if (fits_in_8_bits( len ))
	{
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, reg, len ),
			examines2( reg, R_TMP1 ),
			alters1( reg ) );
	}
      else
	{
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, reg, 0 ),
			examines2( reg, R_TMP1 ),
			alters0() );

	  load_integer( R_TMP1, len, FALSE );

	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, reg, R_TMP1,
			 examines2( reg, R_TMP1 ),
			 alters2( reg, RR_ST ) );
	}      
d2726 1
a2726 1
      syserr( "exporting data relative to symbol %s - currently unsupported",
d2728 34
@


1.38
log
@fixed addressing mode of pop instructions
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.37 1991/11/03 14:27:31 nickc Exp nickc $ */
d3598 2
d3601 3
d3657 1
a3657 1
	  load_integer( R_TMP1, count_bits( maskarg ) + (saved_frame ? 1 : 0), FALSE );
d3668 43
@


1.37
log
@fixed is_function to take into account __dataseg having no symbol data
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.36 1991/11/03 11:54:37 nickc Exp nickc $ */
d2005 1
a2005 1
      out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, dest, 0,
d2058 1
a2058 1
      out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
d2359 1
a2359 1
  out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, dest, 0,
d2460 1
a2460 1
  out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, R_ADDR1, 0,
d5658 1
a5658 1
	  out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
d6314 1
@


1.36
log
@removed OP_LDPK from load-integer as it is suspect
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.35 1991/10/31 11:29:08 nickc Exp nickc $ */
d1680 1
a1680 1
/* have lots of __dataseg symbols.                                 */
d1862 1
a1862 1
is_function( Symstr * name )
d1864 4
a1867 1
  if (symdata_( name ) == NULL)
d1870 1
a1870 1
  return ((bindstg_( symdata_( name ) ) & b_fnconst) != 0 );
@


1.35
log
@changed LDA back to LDI because of confusion over execution sequence
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.34 1991/10/29 10:40:24 nickc Exp nickc $ */
a938 8
  if (r == RR_DP && fits_in_16_bits_unsigned( n ))
    {
      out_diadic_op( OP_LDPK, ADDR_MODE_IMMEDIATE, r, n,
		    examines0(), alters1( r ) );

      return;
    }
  
d3626 1
a3626 1
	  out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, R_TMP1, R_SE,
@


1.34
log
@fixed use of RPTS to take account of -1 in count
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.33 1991/10/28 15:28:05 nickc Exp nickc $ */
d890 3
a892 12
      if (is_special_register( hardware_register( dest ) ))
	{
	  out_diadic_op( OP_LDA, ADDR_MODE_REGISTER, dest, source,
			examines1( source ),
			alters2( dest, RR_ST ) );
	}
      else
	{
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, source,
			examines1( source ),
			alters2( dest, RR_ST ) );
	}
d939 8
d957 1
a957 11
      if (is_special_register( hardware_register( r ) ))
	{
	  /* this instruction is 1 cycle faster than ordinary load */
	  
	  out_diadic_op( OP_LDA, ADDR_MODE_IMMEDIATE, r, n,
			examines0(),
			alters1( r ) );
	}
      else
	{
	  /* 16 bit signed immediate  */
d959 3
a961 4
	  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, r, n,
			examines0(),
			alters2( r, RR_ST ) );
	}
d1815 1
a1815 1
  out_diadic_op( OP_LDA, ADDR_MODE_REGISTER, tmp, R_MT,
d1858 1
a1858 1
  out_diadic_op( OP_LDA, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, tmp, 0 ),
d2174 1
a2174 1
      out_diadic_op( OP_LDA, ADDR_MODE_REGISTER, dest, R_MT,
d2196 1
a2196 1
      out_diadic_op( OP_LDA, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ),
d2218 1
a2218 1
      out_diadic_op( OP_LDA, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ),
d2281 1
a2281 1
      out_diadic_op( OP_LDA, ADDR_MODE_REGISTER, tmp, R_MT,
d2301 1
a2301 1
      out_diadic_op( OP_LDA, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, tmp, 0 ),
@


1.33
log
@added stack size checking code
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.32 1991/10/18 10:49:45 nickc Exp nickc $ */
d890 12
a901 3
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, source,
		    examines1( source ),
		    alters2( dest, RR_ST ) );
d1827 1
a1827 1
  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, tmp, R_MT,
d1870 1
a1870 1
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, tmp, 0 ),
d1885 1
a1885 1
    return 0; /* Default to false */
d2186 1
a2186 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, R_MT,
d2208 1
a2208 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ),
d2230 1
a2230 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ),
d2293 1
a2293 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, tmp, R_MT,
d2313 1
a2313 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, tmp, 0 ),
d2381 1
a2381 1
   * subtract PC from IR0
d2384 2
a2385 2
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, dest, RR_IR0,
		examines2( dest, RR_IR0 ),
d2614 2
a2615 2
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, reg, RR_IR0,
		 examines2( reg, RR_IR0 ),
d2675 2
a2676 2
      out_triadic_op( OP_SUBI3, R_TMP1, reg, RR_IR0, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( reg, RR_IR0 ),
d4203 2
a4204 2
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dst, RR_IR0,
		 examines2( dst, RR_IR0 ),
d4251 1
a4251 1
      out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC, length,
d4267 1
a4267 1
      load_integer( RR_RC, length, FALSE );
d4440 2
a4441 2
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, source, RR_IR0,
		 examines2( source, RR_IR0 ),
d4448 2
a4449 2
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, RR_IR0,
		 examines2( dest, RR_IR0 ),
d4567 2
d4570 1
a4570 1
      if (fits_in_16_bits_unsigned( (length - 1) / sizeof_int ))
d4574 1
a4574 1
	  out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC,  (length - 1) / sizeof_int,
d4580 1
a4580 1
	  /* load repeat count with length - 1 */
d4582 1
a4582 1
	  load_integer( RR_RC, (length - 1) / sizeof_int, FALSE );
d5316 2
a5317 2
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, reg, RR_IR0,
		examines2( reg, RR_IR0 ),
@


1.32
log
@fixed switch table generation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.31 1991/10/17 10:07:37 nickc Exp nickc $ */
d167 1
d169 1
a172 1
static bool		saved_link         = FALSE;	/* true if link register saved on stack       */
a1564 693
 * pushes every integer register whoes bit is set in 'mask'
 */

static void
save_iregs( int32 mask )
{
  int32	i;


  /*
   * NB/ save in reverse order so that argument registers are
   * placed on the stack in descending order
   */
  
  for (i = 31; i >= 0; i--)	/* XXX beware if number of registers > 32 */
    {
      if (mask & regbit( i ))
	{
	  push( i );
	}
    }

  return;
    
} /* save_iregs */


/*
 * pops every integer register whoes bit is set in 'mask'
 */

static void
restore_iregs( int32 mask )
{
  /* NB/ restore must be done in opposite order to save */

  while (mask)
    {
      int32 r1  = firstbit( mask );

      
      pop( r1 );

      mask ^= 1L << r1;
    }

  return;
  
} /* restore_iregs */


/*
 * XXX - CALLING SCHEME
 *
 * version:	2
 * date:	7th October 1991
 * designed:	NC
 *
 * This scheme uses a frame pointer, a stack pointer, a stack end pointer
 * and a module table pointer.  Arguments are accesssed relative to the
 * frame pointer.  Local variables are accessed relative to the stack
 * pointer.  External functions and data are accessed relative to the
 * module table.  If the stack fills up, a new chunk is allocated for it
 * by the compiler, so that the program can carry on execution normally.
 *
 * This scheme does not use a display, but if we need one then it would
 * be placed on the stack and accessed via the stack pointer.  The display
 * is a dynamic structure that cannot be a fixed because languages like
 * PASCAL require function tables in the display on a per function basis.
 *
 * We use an falling, full, stack pointer
 *
 *
 * before entry to a (non-leaf) function has completed :-
 * (NB/ arguments 1 to 4 held in registers, return address held in link register)
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ----------------------------------------  -  -  -  -  - --------
 *                  |     |     |     |     |                      |
 *      previous ...| arg | ... | arg | arg |                      |
 *      functions   |  n  |     |  6  |  5  |                      |
 *                  |     |     |     |     |                      |
 *     ----------------------------------------  -  -  -  -  - --------
 *              ^                        ^                           ^
 *              |                        |                           |
 *              FP'                      SP                          SE
 *              |
 *              FP
 *
 *    FP' - frame pointer of previous function
 *    FP  - current frame pointer
 *    SP  - current stack pointer
 *    SE  - stack end pointer
 *
 *
 * after entry to a (non-leaf) function has completed (if the address of any argument is not used):-
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     -------------------------------------------------------------------------- - - - - ---------
 *                  |     |     |     |     |     |     |       |     |       |            |
 *      previous ...| arg | ... | arg | arg | LNK | FP' | saved | ... | saved |            |
 *      functions   |  n  |     |  6  |  5  |     |     |  reg  |     |  reg  |            |
 *                  |     |     |     |     |     |     |       |     |       |            |
 *     -------------------------------------------------------------------------- - - - - ---------
 *              ^                                   | ^                   ^                  ^
 *              |___________________________________| |                   |                  |
 *                                                    |                   |                  |
 *                                                    FP                  SP                 SE
 *
 *     LNK - return address to previous function (used to be held in link register)
 *
 *
 * after entry to a (non-leaf) function has completed (if the address of any argument is used):-
 * (NB/ arguments 1 to 4 now on stack, all arguments accessed via FP)
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ------------------------------------------------------------------------- - - - - ------
 *                  |     |     |     |     |     |     |       |     |       |           |
 *      previous ...| arg | ... | arg | arg | LNK | FP' | saved | ... | saved |           |
 *      functions   |  n  |     |  2  |  1  |     |     |  reg  |     |  reg  |           |
 *                  |     |     |     |     |     |     |       |     |       |           |
 *     ------------------------------------------------------------------------- - - - - -------
 *              ^                                   | ^                   ^                 ^
 *              |___________________________________| |                   |                 |
 *                                                    |                   |                 |
 *                                                    FP                  SP                SE
 *
 * during execution of a (non-leaf) function :-
 * (note locals on the stack)
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ---------------------------------------------------------------------------------------------------- -
 *               |     |     |     |     |     |     |       |     |       |       |     |       |       |
 *     previous  | arg | ... | arg | arg | LNK | FP' | saved | ... | saved | local | ... | local | local |
 *     functions |  n  |     |  2  |  1  |     |     |  reg  |     |  reg  |   n   |     |   2   |   1   |
 *               |     |     |     |     |     |     |       |     |       |       |     |       |       |
 *     ---------------------------------------------------------------------------------------------------- -
 *         ^                                     | ^                                                 ^
 *         |_____________________________________| |                                                 |
 *                                                 |                                                 |
 *                                                 FP                                                SP
 *
 *
 * before entry to a (leaf) function has completed :-
 * (leaf functions call no other functions,
 *                 have all their arguments passed in registers,
 *                 do not take the address of any argument,
 *                 do not use varargs
 *                 and do not need a large amount of stack space)
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ------------------  -  -  -  -  - -------------------
 *                   |                        |
 *      previous ... |                        |
 *      functions    |                        |
 *                   |                        |
 *     ------------------  -  -  -  -  - --------------------
 *       ^         ^                            ^
 *       |         |                            |
 *       FP'       SP                           SE
 *       |
 *       FP
 *
 * after entry to a (leaf) function has completed :-
 * (NB/ link register not saved, and no new stack frame allocated)
 *
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     --------------------------------------- - - - - -----
 *                   |       |     |       |            |
 *      previous ... | saved | ... | saved |            |
 *      functiions   |  reg  |     |  reg  |            |
 *                   |       |     |       |            |
 *     --------------------------------------- - - - - -----
 *        ^                             ^                 ^
 *        |                             |                 |
 *        |                             |                 |
 *        FP                            SP                SE
 *
 *
 * after entry to a (non-leaf) function has completed (when there is insufficient stack space) :-
 * (NB/ insufficient space is defined to be less than STACK_GUARD words, (usually 64 words),
 *      the code will fail if there is insufficient room to store 6 words on stack).
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ---------------------------------------------------- - ----
 *                  |     |     |     |     |     |     |      |
 *      previous ...| arg | ... | arg | arg | LNK | FP' |      |
 *      functions   |  n  |     |  2  |  1  |     |     |      |
 *                  |     |     |     |     |     |     |      |
 *     ---------------------------------------------------- - ----
 *        ^                                         | ^  
 *        |_________________________________________| |  
 *                                                    |  
 *                                                    FP 
 *                                                    ^
 *  __________________________________________________|
 *  |
 *  |              <this is a new chunk of memory>
 *  |      - - ------------------------------------------------------------ - - - - -----
 *  |            |        |       |        |      |       |     |       |            |
 *  |            | Prev   | Next  | Chunk  | LNK' | saved | ... | saved |            |
 *  |            | Chunk  | Chunk | Size   |      |  reg  |     |  reg  |            |
 *  |            |        |       |        |      |       |     |       |            |
 *  |      - - ------------------------------------------------------------ - - - - -----
 *  |                |                                              ^                  ^
 *  |________________|                                              |                  |
 *                                                                  SP                 SE
 *
 *     LNK' - link address of a special assembler routine that frees up the newly allocated stack chunk
 *            (or more probably frees up the chunk after this one)
 *     
 *
 *
 * after entry to a (leaf) function has completed (when there is insufficient stack space) :-
 *
 *         This is the execution stack, memory DECREASES this way -->
 *     ---------------------------- - ----
 *                  |     |     |      |
 *      previous ...| LNK'| FP' |      |
 *      functions   |     |     |      |
 *                  |     |     |      |
 *     ---------------------------- - ----
 *        ^                 | ^  
 *        |_________________| |  
 *                            |  
 *                            FP 
 *
 *                 <this is a new chunk of memory>
 *         - - ---------------------------------------------------------- - - - - ----
 *               |       |       |       |       |      |     |       |            |
 *               | Prev  | Next  | Chunk | dummy |saved | ... | saved |            | 
 *               | Chunk | Chunk | Size  |       | reg  |     |  reg  |            |
 *               |       |       |       |       |      |     |       |            |
 *         - - ---------------------------------------------------------- - - - - ----
 *                                                                ^                  ^
 *                                                                |                  |
 *                                                                SP                 SE
 *
 *	NB/ Link register now points to the special free_extension_stack routine
 *          and the original value of the link register has been saved on the old stack
 *          
 *     
 *
 *
 * STILL TO DO
 *  setjmp, longjmp
 */

#ifdef NOT_NEEDED
static int
count_bits( signed long mask )
{
  int	count = 0;


  while (mask)
    {
      ++count;

      mask = mask & ~(mask & -mask);
    }

  return count;

} /* count_bits */
#endif /* NOT_NEEDED */

/*
 * emit code to handle entry to a routine
 * this routine is being passed 'm' arguments
 */

#define STACK_GUARD	64		/* number of words left clear at end of stack */

static void
routine_entry( int32 num_args )
{
  int32	n        = 0;
  int32	mask     = 0;
  int32	maskarg  = 0;


  if (num_args < 0)
    {
      syserr( syserr_enter, num_args );

      num_args = 0;
    }

  /*
   * n 		- is the number of arguments we have in registers
   * mask 	- is a bit mask of registers used by this function which MUST be saved before use
   * maskarg	- is a bit mask of the argument registers that must be saved (since their address will be used)
   */

  n = (num_args <= NARGREGS) ? num_args : NARGREGS;

  /*
   * note that the compiler is paranoid - even if only
   * one argument has its address taken then it will ask
   * us to save all of the arguments on the stack - such is life
   */
  
  mask = regmaskvec.map[ 0 ] & M_VARREGS;

  if (procflags & BLKCALL)
    {
      /*
       * if we are going to call another procedure then we must
       * save the link register
       *
       * XXX - should I check against BLK2CALL aswell ?
       */
      
      mask |= regbit( R_LR );
    }
  
  mask |= regmaskvec.map[ 0 ] & M_FVARREGS;

  if (procflags & PROC_ARGPUSH)
    {
      int32	fn;

      
      /*
       * XXX
       *
       * since we do not know if an argument is a
       * floating point or integer argument, we have
       * to assume the worst case for both types.
       *
       * Note, however that since we share integer and
       * floating point argument registers, we only need
       * to save the intersection of masks for the two
       * types
       */
      
      maskarg  = regbit( R_A1  + n ) - regbit( R_A1  );

      fn = ((n <= NFLTARGREGS) ? n : NFLTARGREGS) * (sizeof_double / sizeof_int);
      
      maskarg |= regbit( R_FA1 + fn ) - regbit( R_FA1 );
    }

  /* fprintf( asmstream, "routine entry: registers used: %x, saved = %x and %x\n",
	  regmaskvec.map[ 0 ], mask, maskarg ); */
  
  /*
   * The return label is created here, but it is not set until its first use.
   * When it is used then routine_exit code is generated and from then on all
   * return statements will branch to that label.  If the function does not
   * return then the return code will never be generated!
   */
		    
  returnlab = nextlabel();

  /*
   * at the start of a function that stack is set correctly
   * and there are no local variables
   */
  
  stack_move   = 0;
  stack_offset = 0;

  /*
   * this should not be necessary, but lets be paranoid ....
   */
  
  flush_peepholer( "start of function" );
  
  /*
   * If necessary, push arguments onto stack.
   * We do not need to keep the stack double word
   * aligned, so do not bother.
   * We are, however, interested in the number
   * of words we are going to push onto the stack
   */

  if (maskarg)
    {
      save_iregs( maskarg );

      /* There is a problem here:                                             */
      /* Given a fn f(int x, ...) then the 2nd arg will be expected in        */
      /* an int reg and so f(1,3.4) will cause va_arg to look in the          */
      /* wrong place for ...va_start(x); va_arg(double)...  The solution      */
      /* is probably to save the 2nd arg reg in this case in a slightly       */
      /* unusual position and have va_arg take more care with access.         */

      /* XXX - NC - not sure if this applies to the C40 */
      
#define gen_warn_va_double "calls to va_arg(double) may be mis-compiled in this function"
  
      if ((procflags & PROC_ARGADDR) && (suppress & D_VARARGWARN))
	cc_warn( gen_warn_va_double );
    }

  /*
   * next save the link register and frame pointer (if necessary)
   */

  if (mask & regbit( R_LR ))		/* if we are going to use the link register */
    {
      /**/                              /* then we must save link register */

      push( R_LR );

      /* remove link register from set of registers to save */
      
      mask &= ~regbit( R_LR );

      /* make a note that we have saved LR */

      saved_link = TRUE;
    }
  else
    {
      saved_link = FALSE;
    }
  
  if (num_args > NARGREGS ||		/* if we have arguments passed on the stack */
      maskarg              )		/* or we have had to save arguments on the stack */
    {
      /**/                              /* then we must save old frame pointer */
      
      push( R_FP );

      /* set new frame pointer to be current stack position */

      move_register( R_SP, R_FP );

      /* make a note that we have saved LR */

      saved_frame = TRUE;
   }
  else
    {
      saved_frame = FALSE;
    }

  /*
   * now check to see if we have sufficient stack remaining
   * or if we need to allocate a new stack hunk
   */

#ifdef NOT_YET_IMPLEMENTED
  if (stack_checking_enabled)
    {
      /*
       * get stack end pointer into temporary register
       * subtract stack pointer from temporary register
       * if the result is less than STACK_GUARD then
       *   discover if there is a previously allocated stack chunk
       *     if there is, and it is sufficiently large use it
       *     otherwise allocate a new stack chunk
       *   save the link register and frame pointer if this has not already been done
       *   fill in the first three words of the new stack chunk
       *   if we are a leaf function then
       *     set link register to point to stack restore function and push a dummy word
       *     otherwise push address of stack restore function
       *   then carry on as normal
       */
    }
#endif /* NOT_YET_IMPLEMENTED */
  
  /*
   * now save any register we are going to corrupt in this function
   */

  if (mask)
    {
      save_iregs( mask );
    }
  
  /*
   * OK we are done - set up the remaining statics used by routine_exit()
   */

  saved_tmps = mask;
  saved_args = maskarg;
  
  return;
  
} /* routine_entry */


static void
routine_exit( bool tailcall )
{
  /*
   * ensure that the stack pointer is back at start of local variables
   * this should remove local variables and effectively resets any
   * stack manipulations
   */

  if (stack_offset >= sizeof_int)
    {
      stack_offset /= sizeof_int;

      if (fits_in_16_bits( stack_offset ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, stack_offset,
			examines1( R_SP ),
			alters2( R_SP, RR_ST ) );
	}
      else
	{
	  load_integer( R_TMP1, stack_offset, FALSE );
	  
	  out_triadic_op( OP_ADDI3, R_SP, R_SP, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			examines2( R_SP, R_TMP1 ),
			alters2( R_SP, RR_ST ) );
	}

      stack_offset = 0;
    }

  stack_move = 0;
  
  /*
   * if the return label has not yet been set
   * and we are not doing a tail call then
   * set the label
   */
  
  if (!tailcall && !lab_isset_( returnlab ))
    {
      /* note to NC from NC - this flush is necessary! */
      
      if (returnlab->u.frefs != NULL)	/* experimental - eg for int func( int arg ){ return arg * arg; } */
	flush_peepholer( "routine_exit" );
      
      setlabel( returnlab );
    }
  
  /*
   * if registers were saved onto the stack then pop them back
   */

  if (saved_tmps)
    {
      restore_iregs( saved_tmps );
    }

  /*
   * if the previous frame pointer and link register
   * were saved on the stack then pop them
   *
   * NB/ reverse order to push
   */

  if (saved_frame)
    {      
      pop( R_FP );
    }

  if (saved_link)
    {
      pop( R_LR );
    }

  /*
   * if arguments were pushed onto the stack then adjust
   * the stack pointer, (do not bother to pop)
   */

  if (saved_args)
    {
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, bitcount( saved_args ),
		     examines1( R_SP ),
		     alters2( R_SP, RR_ST ) );
    }
  
  /*
   * if we are doing a tailcall then the next instruction output
   * will be a branch to the next function, otherwise we have to
   * return through the link (by doing a conditional branch)
   */

  if (!tailcall)
    {
      /* this is a conditional, delayed branch, register relative */
      
      outdelayed( OP_BRcrD << 24 | 0x1 << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_LR ),
		 examines1( R_LR ),
		 alters1( RR_PC ) );
    }

  /*
   * make sure that all of the op codes have been emitted
   */
  
  flush_peepholer( "end of function" );
  
  /*
   * finished
   */

  return;
    
} /* routine_exit */


/*
 * this function returns the register, relative to which
 * the given symbol may be accessed
 */

RealRegister
local_base( Binder * b )
{
  int32	addr = bindaddr_( b );

  
  /*
   * arguments are accessed relative to frame pointer
   * locals    are accessed relative to stack pointer
   */
  
  switch (addr & BINDADDR_MASK)
    {
    default:
      syserr( syserr_local_base, (long)addr );
      
    case BINDADDR_ARG:
      return R_FP;
      
    case BINDADDR_LOC:
      return R_SP;
    }
  
} /* local_base */


/*
 * This function gives the offset of the
 * symbol passed in from the
 * register given by the 'local_base()'
 */
  
int32
local_address( Binder * b )
{
  int32 	addr = bindaddr_( b );
  int32 	off  = addr & ~BINDADDR_MASK;

  
  switch (addr & BINDADDR_MASK)
    {
    default:
      syserr( syserr_local_address, (long)addr );

      /* drop through */
      
    case BINDADDR_LOC:	/* relative to stack pointer */

      /*
       * The values look like this:
       *
       *           decreasing memory -->
       * ___________________________________________________ _ _
       *  |           |       |                           |
       *  | arguments | saved | locals    (local)         |
       *  |           | regs  |           (sought)        |
       *  |           |       |               |           |
       * --------------------------------------------------- - - 
       *            ^                                    ^
       *            |                                    |
       *            FP                                   SP
       *                       <------stack offset-------> <---stack move--->
       *                       <----offset--->
       *
       */
       
      correct_stack();

      return (stack_offset - off);

    case BINDADDR_ARG:	/* relative to frame pointer */

      return (off + (saved_frame ? 4 : 0) + (saved_link ? 4 : 0));
    }
  
} /* local_address */


/*
a1593 135
 * Although the idea of setlabel is machine independent, it stays here
 * because it back-patches code.  In the long term setlabel should be
 * in codebuf.c and call a machine dependent backpatch routine.
 */

void
setlabel( LabelNumber * l )
{
  List *	p;
  

  /* do not flush the peepholer - this is done elsewhere */
  
  if (asmstream)
    {
      asm_lablist = mkLabList( asm_lablist, l );
    }
  
  /* resolve all the forward references to this label */

  p = l->u.frefs;	/* XXX should this be before the mkLabList() call ??? */

  while (p != NULL)
    {
      int32		v = car_( p );
      int32 		q = (v & 0x00ffffff);   /* BYTE address */
      int32 		w = code_inst_( q );
      unsigned32	d;


      /*
       * v	- the type of forward reference
       * q	- the address (in code space) of the instruction to be patched
       * w	- the instruction to be patched
       * d	- work variable
       */

      switch (v & (unsigned long) 0xff000000)
        {
	case LABREF_OFF24:     /* e.g. forw. BR ref. */
	  
	  /* note assumption that sizeof_int == 4 */

	  d = (codep - q  >> 2) + mask_and_sign_extend_word( w, 0x00ffffffU );

	  if (!fits_in_24_bits( d ))
	    syserr( syserr_displacement, (long)d );

	  if (d == 1)
	    {
	      /* we have a branch to the next instruction ! */

	      w = OP_NOP << 23;
	    }
	  else
	    {
	      w = (w & (unsigned long) 0xFF000000U) | (d & 0x00FFFFFFU);
	    }

	  break;

	case LABREF_OFF16:     /* e.g. forw. Bc ref. */

	  /* note assumption that sizeof_byte * 4 == sizeof_int */
	  
	  d = (codep - q  >> 2) + mask_and_sign_extend_word( w, 0xffff );

	  if (!fits_in_16_bits( d ))
	    syserr( syserr_displacement, (long)d );
	  
	  w = (w & (unsigned long) 0xffff0000U) | (d & 0xffff);
	  
	  break;
	  
	case LABREF_LIT16:     /* e.g. forw. LDI ref. */

	  /* note assumption that sizeof_byte * 4 == sizeof_int */
	  
	  d = (codep - q  >> 2) + mask_and_sign_extend_word( w, 0xffff );

	  if (!fits_in_16_bits( d ))
	    syserr( syserr_displacement, (long)d );
	  
	  w = (w & (unsigned long) 0xffff0000) | (d & 0xffff);
	  
	  break;
	  
	case LABREF_LIT8:     /* e.g. forw. ADDI3 ref. */

	  /* note assumption that sizeof_byte * 4 == sizeof_int */
	  
	  d = ((codep - q  >> 2) >> 16) + mask_and_sign_extend_word( w, 0xff );

	  if (!fits_in_8_bits( d ))
	    syserr( syserr_displacement, (long)d );
	  
	  w = (w & (unsigned long) 0xffffff00) | (d & 0xff);
	  
	  break;
	  
	case LABREF_ABS32:     /* e.g. BXX */
	  {
	    CodeXref *	z = (CodeXref *) (((List3 *)p)->csr);

	    
	    /* note assumption that sizeof_byte * 4 == sizeof_int */
	  
	    z->codexrlitoff += (codebase + codep) >> 2;
	    
	    p = discard3( p );

	    code_inst_( q ) = z->codexrlitoff;
	    
	    continue;
	  }
	  
	default:
	  syserr( syserr_labref, (long)v );
        }

      code_inst_( q ) = w;
      
      p = discard2( p );
    }

  /* and set the label */

  lab_setloc_( l, codep | (unsigned long) 0x80000000 ); /* cheapo union checker for ->frefs */

  return;
  
} /* setlabel */


/*
a1687 637
/*
 * Locates a free register from the list of hardware
 * registers supplied.
 * The list is terminated by a register of value -1.
 * If no free register can be found the last register
 * on the list is returned and 'must_restore' is set
 * to TRUE, (otheriwse it is set to FALSE).
 */

static RealRegister
get_free_register(
		  bool *	must_restore,
		  ... 		)
{
  int32		tmp  = 0;
  RealRegister	last = 0;
  int32		map = regmaskvec.map[ 0 ];	/* XXX - assumes less than 32 registers */
  va_list	args;


  va_start( args, must_restore );

  while (tmp != -1)
    {
      tmp = va_arg( args, int32 );

      if (tmp != -1)
	{
	  last = real_register( tmp );

	  if ((map & regbit( last )) == 0)
	    {
	      /* succeded */
	  
	      *must_restore = FALSE;

	      va_end( args );
      
	      return last;
	    }
	}
    }
  
  /* failed */
  
  va_end( args );
  
  *must_restore = TRUE;

  return last;
  	    
} /* get_free_register */
  

/*
 * set to zero the 'length' "bytes" of memory pointed to by 'start'
 */

static void
clear_memory(
	     RealRegister	start,
	     int32		length,
	     bool		can_corrupt_start )
{
  int32		extra;
  RealRegister	dst;
  
  
  if (length < 1)
    {
      syserr( syserr_bad_block_length, length );
      
      return;
    }

  /*
   * XXX
   *
   * NB/ we are assuming that the address given to us
   * will be word aligned - THIS HAD BETTER BE TRUE!
   *
   */

  if (!can_corrupt_start || !is_address_register( hardware_register( start ) ))
    {
      /* use temporary address register */

      dst = R_ATMP;
    }
  else
    {
      dst = start;
    }

  /* convert to word offset */
  
  out_triadic_op( OP_LSH3, dst, start, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		 examines1( start ),
		 alters2( dst, RR_ST ) );

  /* and add to IR0 */

  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dst, RR_IR0,
		 examines2( dst, RR_IR0 ),
		 alters2( dst, RR_ST ) );
  
  /*
   * round length down to nearest word
   */
  
  extra   = length & (sizeof_int - 1);
  length /= sizeof_int;
  
  /*
   * store temporary into block
   */

  if (length == 0)
    {
      /* do nothing */
      ;
    }
  else if (length == 1)		/* XXX - can this ever happen ? */
    {
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
		    alters1( dst ) );
    }
  else if (length == 2)		/* XXX - can this ever happen ? */
    {
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
		    alters1( dst ) );

      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
		    alters1( dst ) );
    }
  else if (fits_in_16_bits_unsigned( length ))
    {
      /* use repeat single instruction mode, loaded from immediate */

      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC, length,
		    examines0(),
		    alters1( RR_RC ) );
      
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
		    alters1( dst ) );
    }
  else
    {
      /* use repeat single instruction mode, loaded from register */

      /* pre-load RC with value - this saves using another temporary */
      
      load_integer( RR_RC, length, FALSE );

       /* XXX load RC from itself ! - WILL THIS WORK ? */
      
      out_diadic_op( OP_RPTS, ADDR_MODE_REGISTER, RR_RC, RR_RC,
		    examines1( RR_RC ),
		    alters1( RR_RC ) );

      /* repeat this instruction 'length' times */
      
      /* XXX - this addressing mode is actually ADDR_MODE_INDIRECT ! */
      
      out_diadic_op( OP_STIK, ADDR_MODE_IMMEDIATE, 0, build_indirect( INDIRECT_POST_INCR, dst, 1 ),
		    examines1( dst ),
		    alters1( dst ) );
    }

  if (extra)
    {
      /* handle few remaining bytes */

      switch (extra)
	{
	case 1:
	  /* get word at current location */
	  
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines1( dst ),
			alters2( R_TMP1, RR_ST ) );

	  /* remove bottom byte */
	    
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFF,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );

	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines2( R_TMP1, dst ),
			alters0() );
	  break;
	  
	case 2:
	  /* get word at current location */
	  
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines1( dst ),
			alters2( R_TMP1, RR_ST ) );

	  /* clear bottom two bytes */
	    
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFFFF,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );

	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines2( R_TMP1, dst ),
			alters0() );
	  break;
	  
	case 3:
	  /* this instruction is load unsigned byte from address in ar into R_TMP1, ie LBU3 *AR, R_TMP1 */

	  /* load top byte of *AR into bottom byte of R_TMP1 (no sign extension) */
	  
	  outinstr( FUNC_LOAD << 28 | OP_LBU << 24 | 0x3 << 23 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_REL, dst, 0 ),
		   examines1( dst ),
		   alters2( R_TMP1, RR_ST ) );

	  /* move byte into top 8 bits */
	  
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP1, 24,
			examines1( R_TMP1 ),
			alters2( R_TMP1, RR_ST ) );

	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ),
			examines2( R_TMP1, dst ),
			alters0() );
	  break;
	  
	default:
	  syserr( syserr_bad_length, extra );
	  return;
	}
    }
  
  return;
      
} /* clear_memory */


/*
 * copy the 'length' "bytes" of memory pointed to by 'src' to the area pointed to by 'dst'
 */

static void
copy_memory(
	    RealRegister	src,
	    RealRegister	dst,
	    int32		length,
	    bool		can_corrupt_source,
	    bool		can_corrupt_dest )
{
  int32		extra;
  RealRegister	source;
  RealRegister	dest;
  int		restore_ar = FALSE;
  

  /*
   * NB/ This code assumes that the addresses
   * in the pointers are WORD aligned.
   */

  if (length < 1)
    return;
    
  /*
   * round length down to nearest word
   */
  
  extra   = length & (sizeof_int - 1);
  length &= ~(sizeof_int - 1);

  /*
   * get registers into address registers
   */
  
  if (!can_corrupt_source || !is_address_register( hardware_register( src ) ))
    {
      source = R_ATMP;
    }
  else
    {
      source = src;
    }
      
  if (!can_corrupt_dest || !is_address_register( hardware_register( dst )))
    {
      if (source != R_ATMP)
	{
	  dest = R_ATMP;
	}
      else
	{
	  dest = get_free_register( &restore_ar, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, -1 );

	  if (restore_ar)
	    {
	      if (length > 2)
		{
		  push( dest );
		}
	      else
		{
		  move_register( dest, R_TMP2 );
		}
	    }
	}
    }
      
  /* convert to word pointers */
  
  out_triadic_op( OP_LSH3, source, src, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		 examines1( src ),
		 alters2( source, RR_ST ) );
      
  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, source, RR_IR0,
		 examines2( source, RR_IR0 ),
		 alters2( source, RR_ST ) );
  
  out_triadic_op( OP_LSH3, dest, dst, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		 examines1( dst ),
		 alters2( dest, RR_ST ) );

  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, RR_IR0,
		 examines2( dest, RR_IR0 ),
		 alters2( dest, RR_ST ) );
  
  /*
   * copy whole number of words
   */

  if (length == 0)
    {
      ;
    }
  else if (length == sizeof_int)
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, source, 1 ),
		    examines1( source ),
		    alters3( R_TMP1, RR_ST, source ) );
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
		    examines2( dest, R_TMP1 ),
		    alters1( dest ) );
    }
  else if (length == sizeof_int * 2)
    {
      RealRegister	tmp;
      bool		must_save;
      

      /*
       * find a register than can be used in a parallel op
       */
      
      tmp = get_free_register( &must_save, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, -1 );

      if (must_save)
	{
	  /* do not bother to use suggested temporary register */

	  tmp = R_TMP1;
	  
	  /* get first word into tmp */
      
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, source, 1 ),
			examines1( source ),
			alters3( tmp, RR_ST, source ) );

	  /* store first word */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
			examines2( dest, R_TMP1 ),
			alters1( dest ) );

	  /* do second word */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, source, 1 ),
			examines1( source ),
			alters3( tmp, RR_ST, source ) );

	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
			examines2( dest, R_TMP1 ),
			alters1( dest ) );
	}
      else
	{
	  /* get first word into tmp */
      
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, source, 1 ),
			examines1( source ),
			alters3( tmp, RR_ST, source ) );
	  
	  /*
	   * instruction is:
	   *
	   *    LDI  *<source>++(1), tmp
	   * || STI  tmp, *<dest>++(1)
	   *
	   */
	  
	  outinstr( B_1101 << 28 | B_1010 << 24 |
		   hardware_register( tmp ) << 22 | hardware_register( tmp ) << 16 |
		   build_parallel_indirect( INDIRECT_POST_INCR, dest ) << 8 |
		   build_parallel_indirect( INDIRECT_POST_INCR, source ),
		   examines3( source, tmp, dest ),
		   alters3(   source, tmp, dest ) );
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
			examines2( dest, R_TMP1 ),
			alters1( dest ) );
	}
    }
  else 
    {
      RealRegister	tmp;
      bool		must_save;
      

      /*
       * find a register than can be used in a parallel op
       * note placement of register 0 at end
       */
      
      tmp = get_free_register( &must_save, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00, -1 );
      
#ifndef TARGET_R0_ALWAYS_ZERO
      if (must_save)
#endif  
	{
	  /* preserve register 0 */

	  move_register( tmp, R_TMP1 );
	}

      /* load first word */

      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, source, 1 ),
		    examines1( source ),
		    alters3( tmp, RR_ST, source ) );

      /* repeat load and save ops */
      
      if (fits_in_16_bits_unsigned( (length - 1) / sizeof_int ))
	{
	  /* use repeat single instruction mode, loaded from immediate */

	  out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC,  (length - 1) / sizeof_int,
			examines0(),
			alters1( RR_RC ) );
	}
      else
	{
	  /* load repeat count with length - 1 */
      
	  load_integer( RR_RC, (length - 1) / sizeof_int, FALSE );

	  /* XXX load RC from itself ! - WILL THIS WORK ? */
      
	  out_diadic_op( OP_RPTS, ADDR_MODE_REGISTER, RR_RC, RR_RC,
			examines1( RR_RC ),
			alters1( RR_RC ) );
	}

      /*
       * instruction repeated is:
       *
       *    LDI  *<source>++(1), tmp
       * || STI  tmp, *<dest>++(1)
       *
       */
      
      outinstr( B_1101 << 28 | B_1010 << 24 |
	       hardware_register( tmp ) << 22 | hardware_register( tmp ) << 16 |
	       build_parallel_indirect( INDIRECT_POST_INCR, dest ) << 8 |
	       build_parallel_indirect( INDIRECT_POST_INCR, source ),
	       examines3( source, tmp, dest ),
	       alters3(   source, tmp, dest ) );

      /* save last word */
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, tmp, build_indirect( INDIRECT_POST_INCR, dest, 1 ),
		    examines2( tmp, dest ),
		    alters1( dest ) );

      if (must_save)
	{
#ifdef TARGET_R0_ALWAYS_ZERO
	  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, tmp, 0,
			examines0(), alters1( tmp ) );
#else
	  /* restore register 0 */
	  
	  move_register( R_TMP1, tmp );
#endif
	}
    }  

  if (extra)
    {
      /* oh oh, copy bytes at end of block */

      /* get the word at 'dest' into R_TMP1 */
	  
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dest, 0 ),
		    examines1( dest ),
		    alters2( R_TMP1, RR_ST ) );
      
      switch (extra)
	{
	case 1:
	  /* merge bottom byte at 'source' into R_TMP1 */
	  
	  outinstr( FUNC_LOAD << 28 | OP_MB << 24 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_REL, source, 0 ),
		   examines1( source ),
		   alters2( R_TMP1, RR_ST ) );
	  
	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( dest, R_TMP1 ),
			alters0() );
	  break;
	  
	case 2:
	  /* merge bottom half-word at 'source' into R_TMP1 */
	  
	  outinstr( FUNC_LOAD << 28 | OP_MH << 24 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_REL, source, 0 ),
		   examines1( source ),
		   alters2( R_TMP1, RR_ST ) );
	  
	  /* and save */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( R_TMP1, dest ),
			alters0() );
	  break;
	  
	case 3:
	  /* get the word pointed to by 'source' into 'source' */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_REL, source, 0 ),
			examines1( source ),
			alters2( source, RR_ST ) );

	  /* shift up by 8 bits to remove top byte */

	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, source, 8,
			examines1( source ),
			alters2( source, RR_ST ) );

	  /* load contents of 'source' into R_TMP1 right shifted by 1 byte and merged with the top byte of R_TMP1 */
	  
	  outinstr( FUNC_LOAD << 28 | OP_LWR << 24 | 0x1 << 23 | ADDR_MODE_REGISTER << 21 |
		   hardware_register( R_TMP1 ) << 16 | source,
		   examines2( source, R_TMP1 ),
		   alters2( R_TMP1, RR_ST ) );

	  /* store R_TMP1 into 'dest' */

	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( R_TMP1, dest ),
			alters0() );
	  break;
	  
	default:
	  syserr( syserr_bad_length, extra );
	  return;
	}
    }

  if (restore_ar)
    {
      if (length > 2)
	{
	  pop( dest );
	}
      else
	{
	  move_register( R_TMP2, dest );
	}
    }

  return;

} /* copy_memory */


/*
 * output an instruction using register addressing
 */

static void
register_op(
	    int32		diadic_op,
	    int32		triadic_op,
	    RealRegister	dest,
	    RealRegister	source1,
	    RealRegister	source2 )
{
  out_triadic_op( triadic_op, dest, source1, source2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		 examines2( source1, source2 ),
		 alters2( dest, RR_ST ) );

  return;

  UNUSED( diadic_op );
  
} /* register_op */
  

d2878 1
a2878 1
       * value (1 or 4) added in
d2902 2
a2903 1
/*  flush_peepholer( "calling another function" ); */
d2975 1752
d4728 1
d5708 4
d6590 1
a6590 1
	  
d6612 3
a6614 1
	  peep_buf[ prev    ].reads |= RR_PC;		/* ensure that this instruction does get swapped again */
d6616 1
a6616 1
/*	  fprintf( asmstream, "* eliminated a NOP\n" ); */
d6620 1
a6620 1
/*      else fprintf( asmstream, "* could not swap %x and %x (prev read = %x, write = %x)(delayed read = %x, write = %x)\n",
d7199 1
a7199 1
  /* fprintf( asmstream, "* flushed: %s (codep = %d)\n", reason, codep ); */
@


1.31
log
@fixed bug in get_free_register
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.30 1991/10/15 12:22:35 nickc Exp nickc $ */
d2396 2
d5333 1
a5333 1

a5339 1
	  int			codep_of_call;
d5364 1
a5364 1
	  out_triadic_op( OP_ADDI3, R_ATMP, r1r, -1, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d5373 1
a5373 3
	  
	  codep_of_call = codep;
	  
d5378 4
d5395 3
a5397 3
	  /* adjust for instructions between here and call */

	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, (codep - codep_of_call) / sizeof_int,
d5400 2
d5447 2
@


1.30
log
@fixed calculation of stack offsets
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.29 1991/10/14 10:39:26 nickc Exp nickc $ */
d480 4
a483 2
  int32	dst = hardware_register( destination );
  
d551 4
a554 1
  int32		dst = hardware_register( destination );
a555 1

d2527 1
a2527 1
  int32		tmp;
d2535 1
a2535 1
  while (last != -1)
d2539 1
a2539 5
      if (tmp == -1)
	{
	  last = -1;
	}
      else
d2958 1
a2958 1
       * note place,ment of register 0 at end
d4654 1
a4654 1
	      
d5222 1
a5222 1
      
@


1.29
log
@fixed subtraction performed when initialising function tables
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.28 1991/10/11 15:26:31 nickc Exp nickc $ */
d2182 1
a2182 1
   * locals are accessed relative to stack pointer
d2191 1
a2191 8
      if (procflags & NONLEAF)
	{
	  /* XXX - why is this test necessary ? */
	  
	  return R_FP;
	}

      /* drop through */
d2222 18
d2242 1
a2242 3
      /* XXX - this has been hacked by hand - do not know if correct */
      
      return (off - 4 /* - stack_offset */ + stack_move); 
d2252 5
d2282 1
a2282 1
 * although the idea of setlabel is machine independent, it stays here
d2510 1
a2510 1
 * locates a free register from the list of hardware
d2512 1
a2512 1
 * the list is terminated by a register of value -1
d2568 1
a2568 1
 * zero the 'length' "bytes" of memory pointed to by 'start'
d3228 1
a3228 1
 *                                 ------------------------------------------
d6524 3
a6526 3
   * check for and indirect post incr of stack pointer
   * followed by an addition to the stack pointer
   * or a STIK followed by an addition to pointer
d6533 1
a6533 1
       (is_op( prev_op, OP_LDI  ) && is_mode( prev_op, ADDR_MODE_INDIRECT  ))
d6575 1
a6575 1
  
d6752 1
a6752 1
  
d6756 1
a6756 1
  /* see if we can create a parallel operation - XXX - I have never seen this happen! */
d6762 1
a6762 1
  
@


1.28
log
@added a few wrinkles to load_integer
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.27 1991/10/10 16:14:47 nickc Exp nickc $ */
d4011 3
a4013 3
      out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, R_TMP1, R_ADDR1,
		    examines2( R_TMP1, R_ADDR1 ),
		    alters2( R_TMP1, RR_ST ) );
@


1.27
log
@changec C_L to C_LT
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.26 1991/10/10 16:09:00 nickc Exp nickc $ */
d52 6
a57 1
#define ul	(unsigned long)
a58 7
#define fits_in_5_bits( val )		(((val) & ul 0xfffffff0L) == 0 || ((val) & ul 0xfffffff0L) == ul 0xfffffff0L)
#define fits_in_8_bits( val )		(((val) & ul 0xffffff80L) == 0 || ((val) & ul 0xffffff80L) == ul 0xffffff80L)
#define fits_in_8_bits_unsigned( val )	(((val) & ul 0xffffff00L) == 0 )
#define fits_in_16_bits( val )		(((val) & ul 0xffff8000L) == 0 || ((val) & ul 0xffff8000L) == ul 0xffff8000L)
#define fits_in_16_bits_unsigned( val )	(((val) & ul 0xffff0000L) == 0 )
#define fits_in_24_bits( val )		(((val) & ul 0xff800000L) == 0 || ((val) & ul 0xff800000L) == ul 0xff800000L)

a173 1
static int32		num_saved          = 0;		/* number of registers saved by routine_entry code */
d937 1
a937 2
       * we could use OP_LDHI here, which would not set the condition codes, but
       * that might prevent us from optimising the load in the peepholer
d963 1
a963 1
      /* 16 msb's set, use special half word load instruction */
d969 16
d1814 1
d1831 1
a1831 1

a1943 2
  num_saved = count_bits( mask ) + count_bits( maskarg );
  
d2000 1
a2000 5

      /* and note that we have saved another register */

      num_saved++;
    }
d2093 4
a2096 19
      if (num_saved > 4)
	{
	  /*
	   * If we have to restore more than 4 registers then
	   * it is more efficient to generate the return from
	   * function code only once and branch to this code
	   */
	  
	  outdellabref( OP_BRD << 24 | (-3 & 0xffffff), returnlab, LABREF_OFF24,
		       examines0(), alters1( RR_PC ) );

	  return;
	}
      else
	{
	  /* note to NC from NC - this flush is necessary! */

	  if (returnlab->u.frefs != NULL)	/* experimental - eg for int func( int arg ){ return arg * arg; } */
	    flush_peepholer( "routine_exit" );
d2098 1
a2098 2
	  setlabel( returnlab );
	}
d2310 2
a2311 2
	  
	  d = (codep - q  >> 2) + mask_and_sign_extend_word( w, 0xffffff );
d2324 1
a2324 1
	      w = (w & (unsigned long) 0xff000000) | (d & 0xffff);
d2338 1
a2338 1
	  w = (w & (unsigned long) 0xffff0000) | (d & 0xffff);
d6297 2
a6298 1

a6384 2
	  /* fprintf( asmstream, "* converted an unconditional branch\n" ); */
	  
d6461 2
d6464 1
a6464 1
    return FALSE;		/* no previous instruction */
d6466 2
d6472 37
d6515 1
a6515 1
  if (
d6967 2
a6968 2
	      
	      op = (op & (unsigned long)0xFF000000L) | offset;
d6980 1
a6980 1
	      op = (op & (unsigned long)0xFFFF0000L) | offset;
@


1.26
log
@changed default action of is_function to be false as it was missing __dataseg
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.25 1991/10/10 15:41:28 nickc Exp nickc $ */
d799 1
a799 1
    case Q_LT:	return C_L;	/* less than (signed) */
@


1.25
log
@fixed load_address_constant to cope with load the address of externals into non address registers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.24 1991/10/10 14:42:18 nickc Exp nickc $ */
d3333 1
a3333 1
    return 1; /* Default to true */
@


1.24
log
@fixed register saving on routine entry (again)
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.23 1991/10/10 13:53:17 nickc Exp nickc $ */
d3689 3
d3727 6
a3732 2
#ifdef NEVER
      if (!is_address_register( hardware_register( dest ) ))
d3734 1
a3734 1
	  syserr( "warning: trying to load address of data into a non-address register\n" );
d3736 1
a3736 1
#endif      
d3741 1
a3741 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, R_MT,
d3743 1
a3743 1
		    alters2( dest, RR_ST ) );
d3753 3
a3755 3
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, 0,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
d3761 2
a3762 2
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ),
		    examines1( dest ),
@


1.23
log
@fixed generation of entry and exit save register sequences
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.22 1991/10/10 10:38:41 nickc Exp nickc $ */
d1847 1
a1847 1
  
d1897 3
d1907 1
a1907 1
  returnlab   = nextlabel();
d1927 2
d2324 11
a2334 2
	  
	  w = (w & (unsigned long) 0xff000000) | (d & 0xffff);
d6377 1
a6377 1
	      
@


1.22
log
@fixed generation of accesses to data slots
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.21 1991/10/09 12:58:04 nickc Exp nickc $ */
d170 7
a176 6
static int32 		stack_move         = 0;	/* number of bytes potentially subtracted from stack     */
static int32 		stack_offset       = 0;	/* number of bytes from stack pointer to first local arg */
static bool		saved_frame;		/* true if frame pointer saved on stack       */
static bool		saved_link;		/* true if link register saved on stack       */
static int32		saved_tmps;		/* mask of temporary registers saved on stack */
static int32		saved_args;		/* mask of argument registers saved on stack  */
d1802 18
d1856 1
a1856 1
  mask = regmaskvec.map[ 0 ] & (M_VARREGS & (int)regbit( R_LR ));
d1896 1
a1896 1
  
d1926 2
d1984 4
d2081 16
a2096 1
      /* note to NC from NC - this flush is necessary! */
d2098 2
a2099 3
      if (codep_of_call == 0 &&		/* ie not needed if in data initialisation phase */
	  returnlab->u.frefs != NULL)	/* experimental - eg for int func( int arg ){ return arg * arg; } */
	flush_peepholer( "routine_exit" );
d2101 2
a2102 1
      setlabel( returnlab );
a2442 13
#ifdef NEVER
      if (off == (1 - 3) && condition == Q_AL)
	{
	  /*
	   * always branch to the next instruction !
	   * do not need to do this branch!
	   *
	   * (this can occur - but why?)
	   */
	  
	  return;
	}
#endif
d5952 2
@


1.21
log
@fixed generation of function stubs
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.20 1991/10/07 16:16:34 nickc Exp nickc $ */
d1918 2
d3213 8
a3220 2
#ifdef NEVER
  if (!is_address_register( hardware_register( r ) ))
d3222 1
a3222 1
      syserr( "load_static_data_ptr: passed a non-address register - %d\n", r );
d3224 1
a3224 1
#endif
d3231 1
a3231 1
   * load the module table address into 'r'
d3234 1
a3234 1
  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, r, R_MT,
d3236 1
a3236 1
		alters2( r, RR_ST ) );
d3262 1
a3262 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, r, 1,
d3264 1
a3264 1
		    alters2( r, RR_ST ) );
d3268 1
a3268 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, r, 0,
d3270 1
a3270 1
		    alters2( r, RR_ST ) );
d3277 2
a3278 2
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, r, 0 ),
		examines1( r ),
d3945 1
a3945 3
   * as a chain of init sequences, but the Bu instruction used to
   * jump out of a function stub adds one to the PC anyway - so
   * we do not have to adjust the offset
d6090 3
d6364 5
a6368 5
  if (((op & (B_111        << 29)) == 0)                          &&	/* currently diadic             */
      ((op & (potential_op << 23)) == (potential_op << 23))       &&	/* matches sought op            */
      ((op & (B_11         << 21)) == (ADDR_MODE_INDIRECT << 21)) &&	/* uses indirect addressing     */
      ((op & (B_11111      << 16)) <= (7 << 16))                  &&	/* references registers R0 - R7 */
      ((op & 0xFF) < 2))						/* displacement is 0 or 1       */
d6431 1
d6434 11
a6444 4
  if (((curr_op >> 23) == OP_ADDI) &&
      ((prev_op >> 23) == OP_LDI)  &&
      (((curr_op >> 21) & 0x3) == ADDR_MODE_IMMEDIATE) &&
      (((prev_op >> 21) & 0x3) == ADDR_MODE_INDIRECT) )
d6460 1
a6460 1
	  fprintf( asmstream, "* peepholer: transformed stack addition\n" );
@


1.20
log
@changed to falling stack
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.19 1991/10/04 10:09:57 nickc Exp nickc $ */
d2056 2
a2057 1
      if (codep_of_call == 0)	/* ie not needed if in data initialisation phase */
d2273 1
a2273 1
	  d = ((codep - q  >> 2) - 3) + mask_and_sign_extend_word( w, 0xffffff );
a2274 2
	  /* -3 because of delay in branch */

d2286 1
a2286 3
	  d = ((codep - q  >> 2) - 3) + mask_and_sign_extend_word( w, 0xffff );

	  /* -3 because of delay in branch */
d2441 1
a2441 1
	  outdellabref( OP_BRD << 24 | 0, destination, LABREF_OFF24,
d2448 1
a2448 1
	  outdellabref( OP_BRcD << 24 | 0x1 << 21 | C_FROMQ( condition ) << 16 | 0,
a3871 4
      
  /*
   * subtract IR0 from the PC
   */
a3872 4
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, R_ADDR1, RR_IR0,
		examines2( R_ADDR1, RR_IR0 ),
		alters2( R_ADDR1, RR_ST ) );

d3874 2
a3875 3
   * our temporary register now contains the word offset
   * from IR0 of the call instruction at the start of this
   * function
d3937 3
a3939 1
   * as a chain of init sequences, so ...
d3959 1
a3959 1
		     examines2( R_ADDR1, offset ),
d4361 1
a4361 1
      outdelsymref( (OP_BRD << 24) | 0, name, examines0(), alters1( RR_PC ) );
d4365 1
a4365 1
      outdelsymref( (OP_LAJ << 24) | 0, name, examines0(), alters2( R_LR, RR_PC ) );
d6248 1
a6248 1
	  /* fprintf( asmstream, "* eliminated a NOP\n" ); */
d6252 4
a6255 1
      /* else fprintf( asmstream, "* could not swap\n" ); */
d6287 3
d6320 4
a6323 1
	      
d6784 1
a6784 1
  /* fprintf( asmstream, "* flushed: %s\n", reason ); */
@


1.19
log
@unknown mods
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.18 1991/10/03 15:04:30 nickc Exp nickc $ */
d418 51
d902 1
a902 1
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_PRE_INCR, R_SP, 0 ),
d916 1
a916 1
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_POST_DECR, R_SP, 0 ),
d1036 1
a1036 1
  if (src == R_SP)
d1039 3
a1041 2
       * the stack pointer is always a word pointer
       * so no special adjustments should be necessary
d1056 2
a1057 2
	      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD, R_SP, offset ),
			    examines1( R_SP ),
d1062 2
a1063 2
	      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_SUB, R_SP, -offset ),
			    examines1( R_SP ),
d1069 2
a1070 2
	  out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, R_SP, 0 ),
			    examines1( R_SP ),
a1076 1
      /* note that we use a triadic op to give a chance at peephole optimisation */
d1078 1
a1078 1
      out_triadic_op( OP_LSH3, src, src, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
a1087 6
      else if (fits_in_8_bits( offset ))
	{
	  out_triadic_op( OP_ADDI3, src, src, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			examines1( src ),
			alters2( src, RR_ST ) );
	}
a1134 6
      else if (fits_in_8_bits( offset ))
	{
	  out_triadic_op( OP_ADDI3, tmp, tmp, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( tmp ),
			 alters2( tmp, RR_ST ) );
	}
d1173 1
a1173 1
  if (src == R_SP)
d1182 1
a1182 1
       *	op    *+AR6(IR1), dst
d1191 1
a1191 1
      /* add to the stack pointer */
d1193 2
a1194 2
      out_triadic_op( OP_ADDI3, R_ATMP, R_ATMP, R_SP, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		    examines2( R_SP, R_ATMP ),
d1213 1
a1213 1
      out_triadic_op( OP_LSH3, R_ATMP, R_ATMP, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d1245 2
a1246 1
 * ensures that the stack is increased or decreased as necessary
d1250 6
a1255 1
correct_stack( void )
d1257 6
a1262 1
  int32	move;
d1264 2
d1267 20
a1286 3
  /*
   * stack pointer is always in multiples of words, NOT bytes
   */
d1288 1
a1288 1
  move = (-stack_move) / sizeof_int;
d1290 2
a1291 5
  if (move != 0)
    {
      /*
       * 'move' is number of words to remove from stack
       */
d1293 3
a1295 15
      if (fits_in_8_bits( move ))
	{
	  out_triadic_op( OP_ADDI3, R_SP, R_SP, move, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( R_SP ),
			 alters2( R_SP, RR_ST ) );
	}
      else if (fits_in_16_bits( move ))
	{
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, move,
			 examines1( R_SP ),
			 alters2( R_SP, RR_ST ) );
	}
      else
	{
	  /* XXX what! a stack move of more than 16 bit size ! */
d1297 5
a1301 1
	  load_integer( R_TMP1, move, FALSE );
d1303 12
a1314 8
	  out_triadic_op( OP_ADDI3, R_SP, R_SP, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
			examines2( R_TMP1, R_SP ),
			alters2( R_SP, RR_ST ) );
	}      

      move *= sizeof_int;
      
      adjust_stack( move );
d1317 2
d1523 1
a1523 1
      out_triadic_op( OP_LSH3, dest, dest, firstbit( -val ), ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d1553 1
a1553 3
  while (mask)
    {
      int32 r1  = firstbit( mask );
a1554 2
      
      push( r1 );
d1556 11
a1566 1
      mask ^= 1L << r1;
d1581 5
a1585 1
  int32	i;
d1587 2
d1590 1
a1590 8
  /* NB/ restore must be done in opposite order to save */
  
  for (i = 31; i >= 0; i--)	/* XXX beware if number of registers > 32 */
    {
      if (mask & regbit( i ))
	{
	  pop( i );
	}
d1601 2
a1602 2
 * version:	1
 * date:	7th August 1991
d1617 1
a1617 1
 * We use an increasing, full, stack pointer
d1621 1
a1621 1
 * (NB/ arguments 1 to 4 held in register, return address held in link register)
d1624 10
a1633 10
 *         This is the execution stack, memory INCREASES this way -->
 *     -------------------------------------------------  -  -  -  -  - ----
 *    |                      |     |     |     |     |                      |
 *    |previous functions ...| arg | ... | arg | arg |                      |
 *    |                      |  n  |     |  6  |  5  |                      |
 *    |                      |     |     |     |     |                      |
 *     -------------------------------------------------  -  -  -  -  - ----
 *              ^                                 ^                          ^
 *              |                                 |                          |
 *              FP'                               SP                         SE
d1646 11
a1656 11
 *         This is the execution stack, memory INCREASES this way -->
 *     ---------------------------------------------------------------------------------- -
 *                           |     |     |     |     |     |     |       |     |       | 
 *     previous functions ...| arg | ... | arg | arg | LNK | FP' | saved | ... | saved | 
 *                           |  n  |     |  6  |  5  |     |     |  reg  |     |  reg  | 
 *                           |     |     |     |     |     |     |       |     |       | 
 *     ----------------------------------------------------------------------------------- -
 *              ^                                            | ^                     ^
 *              |____________________________________________| |                     |
 *                                                             |                     |
 *                                                             FP                    SP
d1665 11
a1675 11
 *         This is the execution stack, memory INCREASES this way -->
 *     ---------------------------------------------------------------------------------- -
 *                           |     |     |     |     |     |     |       |     |       | 
 *     previous functions ...| arg | ... | arg | arg | LNK | FP' | saved | ... | saved | 
 *                           |  n  |     |  2  |  1  |     |     |  reg  |     |  reg  | 
 *                           |     |     |     |     |     |     |       |     |       | 
 *     ----------------------------------------------------------------------------------- -
 *              ^                                            | ^                     ^
 *              |____________________________________________| |                     |
 *                                                             |                     |
 *                                                             FP                    SP
d1681 11
a1691 11
 *         This is the execution stack, memory INCREASES this way -->
 *     ----------------------------------------------------------------------------------------------------------------- -
 *                           |     |     |     |     |     |     |       |     |       |       |     |       |       |
 *     previous functions ...| arg | ... | arg | arg | LNK | FP' | saved | ... | saved | local | ... | local | local |
 *                           |  n  |     |  2  |  1  |     |     |  reg  |     |  reg  |   n   |     |   2   |   1   |
 *                           |     |     |     |     |     |     |       |     |       |       |     |       |       |
 *     ----------------------------------------------------------------------------------------------------------------- -
 *              ^                                            | ^                                                 ^
 *              |____________________________________________| |                                                 |
 *                                                             |                                                 |
 *                                                             FP                                                SP
d1702 12
a1713 12
 *         This is the execution stack, memory INCREASES this way -->
 *     ----------------------------  -  -  -  -  - -------------------
 *                            |                        |
 *     previous functions ... |                        |
 *                            |                        |
 *                            |                        |
 *     ----------------------------  -  -  -  -  - --------------------
 *              ^           ^                            ^
 *              |           |                            |
 *              FP'         SP                           SE
 *              |
 *              FP
d1719 11
a1729 11
 *         This is the execution stack, memory INCREASES this way -->
 *     ------------------------------------------------ - -
 *                            |       |     |       |
 *     previous functions ... | saved | ... | saved |
 *                            |  reg  |     |  reg  |
 *                            |       |     |       |
 *     ------------------------------------------------ - -
 *              ^                                ^  
 *              |                                |
 *              |                                |
 *              FP                               SP
d1736 13
a1748 13
 *         This is the execution stack, memory INCREASES this way -->
 *     ------------------------------------------------------------- -
 *                           |     |     |     |     |     |     |
 *     previous functions ...| arg | ... | arg | arg | LNK | FP' |
 *                           |  n  |     |  2  |  1  |     |     |
 *                           |     |     |     |     |     |     |
 *     ------------------------------------------------------------- -
 *              ^                                            | ^  
 *              |____________________________________________| |  
 *                                                             |  
 *                                                            FP 
 *                                                             ^
 *  ___________________________________________________________|
d1751 9
a1759 9
 *  |      - - ------------------------------------------------------------------ - -
 *  |            |        |       |        |      |       |     |       | 
 *  |            | Prev   | Next  | Chunk  | LNK' | saved | ... | saved | 
 *  |            | Chunk  | Chunk | Size   |      |  reg  |     |  reg  | 
 *  |            |        |       |        |      |       |     |       | 
 *  |      - - ------------------------------------------------------------------ - -
 *  |                |                                              ^
 *  |________________|                                              |
 *                                                                  SP
d1768 11
a1778 11
 *         This is the execution stack, memory INCREASES this way -->
 *     ------------------------------------- -
 *                           |     |     |
 *     previous functions ...| LNK | FP' |
 *                           |     |     |
 *                           |     |     |
 *     ------------------------------------- -
 *              ^                    | ^  
 *              |____________________| |  
 *                                     |  
 *                                     FP 
d1781 9
a1789 9
 *         - - ---------------------------------------------------------- - -
 *               |       |       |       |       |      |     |       | 
 *               | Prev  | Next  | Chunk | dummy |saved | ... | saved | 
 *               | Chunk | Chunk | Size  |       | reg  |     |  reg  | 
 *               |       |       |       |       |      |     |       | 
 *         - - -------------------------------------------------------- - -
 *                                                                ^
 *                                                                |
 *                                                                SP
d1830 6
d1920 1
a1920 1
      if (procflags & PROC_ARGPUSH)
d2026 1
a2026 7
      if (fits_in_8_bits( stack_offset ))
	{
	  out_triadic_op( OP_SUBI3, R_SP, R_SP, stack_offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			examines1( R_SP ),
			alters2( R_SP, RR_ST ) );
	}
      else if (fits_in_16_bits( stack_offset ))
d2028 1
a2028 1
	  out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_SP, stack_offset,
d2036 1
a2036 1
	  out_triadic_op( OP_SUBI3, R_SP, R_SP, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d2095 1
a2095 1
      out_triadic_op( OP_SUBI3, R_SP, R_SP, bitcount( saved_args ), ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
a2129 24
static void
conditional_skip_instructions(
			      int32	condition,
			      int32	num_to_skip )
{
  if (!fits_in_16_bits( num_to_skip ))
    {
      syserr( "conditional_skip_instructions: too many instructions to skip! (%d)",
	     num_to_skip );

      return;
    }
  
  /* output a conditional branch (delayed), PC relative */
  
  outdelayed( OP_BRcD << 24 | 0x1 << 21 | C_FROMQ( condition ) << 16 | (num_to_skip & 0xffff),
	     condition == Q_AL ? examines0() : examines1( RR_ST ),
	     alters1( RR_PC ) );
  
  return;
  
} /* conditional_skip_instructions */


d2191 2
d2194 1
a2194 1
      return (-off + 4 /* - stack_offset */ - stack_move); /* XXX - this has been hacked by hand - do not know if correct */
d2198 1
a2198 1
      return off;
d2204 24
d2272 1
a2272 1
	  d = ((codep - q  >> 2) - 3) + mask_and_sign_extend_word( w, 0xffffff );	/* -3 because of delay in branch */
d2274 2
d2287 3
a2289 1
	  d = ((codep - q  >> 2) - 3) + mask_and_sign_extend_word( w, 0xffff ); 	/* -3 because of delay in branch */
d2404 1
a2404 1

d2416 1
a2416 1

d2465 58
d2568 6
d2592 4
a2595 6
      /* load zero into temporary register */

      load_integer( R_TMP1, 0, FALSE );
  
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( dst, RR_IR0, R_TMP1 ),
d2600 4
a2603 6
      /* load zero into temporary register */

      load_integer( R_TMP1, 0, FALSE );
  
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( dst, RR_IR0, R_TMP1 ),
d2606 4
a2609 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( dst, RR_IR0, R_TMP1 ),
a2613 6
      push( RR_R0 );
      
      /* load zero into temporary register */

      load_integer( RR_R0, 0, FALSE );
  
d2616 2
d2622 4
a2625 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, RR_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( RR_R0, dst, RR_IR0 ),
a2626 2

      pop( RR_R0 );
a2631 6
      push( RR_R0 );
      
      /* load zero into temporary register */

      load_integer( RR_R0, 0, FALSE );
  
d2644 4
a2647 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, RR_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( RR_R0, dst, RR_IR0 ),
a2648 2

      pop( RR_R0 );
d2660 2
a2661 2
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ),
			examines2( RR_IR0, dst ),
d2672 2
a2673 2
	  out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ),
			examines3( R_TMP1, RR_IR0, dst ),
d2680 2
a2681 2
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ),
			examines2( RR_IR0, dst ),
d2692 2
a2693 2
	  out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ),
			examines3( R_TMP1, RR_IR0, dst ),
d2703 2
a2704 2
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ),
		   examines2( dst, RR_IR0 ),
d2715 2
a2716 2
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ),
			examines3( R_TMP1, RR_IR0, dst ),
d2753 3
d2758 7
d2785 1
a2785 1
	  push( RR_AR1 );
d2787 11
a2797 3
	  dest = RR_AR1;

	  restore_ar = TRUE;
d2801 1
a2801 1
  /* convert to word offsets */
d2807 4
d2814 4
a2817 4
      
  /*
   * round length down to nearest word
   */
a2818 3
  extra   = length & (sizeof_int - 1);
  length &= ~(sizeof_int - 1);

a2824 1
      /* do nothing */
d2829 2
a2830 2
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ),
		    examines2( RR_IR0, source ),
d2833 2
a2834 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ),
		    examines3( RR_IR0, dest, R_TMP1 ),
d2839 4
d2844 1
a2844 5
       * this may or may not be a win.  If we can optimize
       * the repeat block below to be a repeat block delayed
       * and if we do not need to use any temporary address
       * registers, then the repeat block code will be one
       * instruction faster/smaller
d2847 9
a2855 3
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ),
		    examines2( RR_IR0, source ),
		    alters3( R_TMP1, RR_ST, source ) );
d2857 15
a2871 3
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ),
		    examines3( RR_IR0, dest, R_TMP1 ),
		    alters1( dest ) );
d2873 7
a2879 3
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ),
		    examines2( RR_IR0, source ),
		    alters3( R_TMP1, RR_ST, source ) );
d2881 23
a2903 3
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ),
		    examines3( RR_IR0, dest, R_TMP1 ),
		    alters1( dest ) );
d2907 11
d2919 7
a2925 1
      /* preserve RR_R0 */
a2926 2
      move_register( RR_R0, R_TMP1 );
#endif  
d2929 3
a2931 3
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, RR_R0, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ),
		    examines2( RR_IR0, source ),
		    alters3( RR_R0, RR_ST, source ) );
d2959 2
a2960 2
       *    LDI  *<source>++(IR0), R0
       * || STI  R0, *<dest>++(IR0)
d2965 5
a2969 5
	       hardware_register( RR_R0 ) << 22 | hardware_register( RR_R0 ) << 16 |
	       build_parallel_indirect( INDIRECT_POST_INCR_IR0, dest ) << 8 |
	       build_parallel_indirect( INDIRECT_POST_INCR_IR0, source ),
	       examines4( source, RR_IR0, RR_R0, dest ),
	       alters2( source, dest ) );
d2973 2
a2974 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, RR_R0, build_indirect( INDIRECT_POST_INCR_IR0, dest, 0 ),
		    examines3( RR_R0, RR_IR0, dest ),
d2977 2
d2980 2
a2981 2
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, RR_R0, 0,
		    examines0(), alters1( RR_R0 ) );
d2983 3
a2985 3
      /* restore RR_R0 */

      move_register( R_TMP1, RR_R0 );
d2987 1
d2994 6
a3002 6
	  /* get the word at 'dest' into R_TMP1 */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ),
			examines2( dest, RR_IR0 ),
			alters2( R_TMP1, RR_ST ) );
	  
d3006 2
a3007 2
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ),
		   examines2( RR_IR0, source ),
d3012 2
a3013 2
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ),
			examines3( RR_IR0, dest, R_TMP1 ),
a3014 1

a3017 6
	  /* get the word at 'dest' into R_TMP1 */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ),
			examines2( RR_IR0, dest ),
			alters2( R_TMP1, RR_ST ) );
	  
d3021 2
a3022 2
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ),
		   examines2( RR_IR0, source ),
d3027 2
a3028 2
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ),
			examines3( R_TMP1, RR_IR0, dest ),
a3032 6
	  /* get the word at 'dest' into  R_TMP1 */

	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ),
			examines2( RR_IR0, dest ),
			alters2( R_TMP1, RR_ST ) );

d3035 2
a3036 2
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ),
			examines2( RR_IR0, source ),
d3054 2
a3055 2
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ),
			examines3( R_TMP1, RR_IR0, dest ),
d3066 10
a3075 1
    pop( RR_AR1 );
a3082 46
 * output an instruction using immediate addressing
 * handles the case when triadic addressing may be necessary
 */

static void
immediate_op(
	      int32		diadic_op,
	      int32		triadic_op,
	      RealRegister	dest,
	      RealRegister	source,
	      int32		value )
{
  if (source == R_SP || dest == R_SP)
    {
      /* calculations on the stack register use word addressing */
      
      value /= sizeof_int;
    }
  
  if (fits_in_8_bits( value ))
    {
      out_triadic_op( triadic_op, dest, source, value, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( source ),
		     alters2( dest, RR_ST ) );
    }
  else if (dest == source && fits_in_16_bits( value ))
    {
      out_diadic_op( diadic_op, ADDR_MODE_IMMEDIATE, dest, value,
		    examines1( dest ),
		    alters2( dest, RR_ST ) );
    }
  else
    {
      load_integer( R_TMP1, value, FALSE );
      
      out_triadic_op( triadic_op, dest, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
		     examines2( R_TMP1, source ),
		     alters2( dest, RR_ST ) );
    }

  return;
  
} /* immediate_op */
  

/*
d3101 1
a3101 1

d3439 2
d3448 1
a3448 1
	  immediate_op( OP_SUBI, OP_SUBI3, dest, dest, d / sizeof_int );
d3772 2
a3773 2
		examines1( R_SP ),
		alters3( dest, R_SP, RR_ST ) );
d3873 2
a3874 2
		examines1( R_SP ),
		alters3( R_ADDR1, R_SP, RR_ST ) );
d3986 1
a3986 1
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, dest, 0 ),
d4014 1
a4014 1
  out_triadic_op( OP_LSH3, reg, reg, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d4018 1
a4018 1
  out_triadic_op( OP_ADDI3, reg, reg, RR_IR0, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d4089 1
a4089 1
      out_triadic_op( OP_LSH3, R_TMP1, R_TMP1, 2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d4122 1
a4122 1
	  out_triadic_op( OP_ADDI3, reg, reg, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d4171 3
a4173 1
	  out_diadic_op( OP_STI, ADDR_MODE_IMMEDIATE, value, build_indirect( INDIRECT_REL, dest, 0 ),
d4192 1
a4192 1
	  out_triadic_op( OP_ADDI3, dest, dest, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d4220 1
a4220 1
	  out_triadic_op( OP_ADDI3, dest, dest, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d4305 4
d4314 2
a4315 1
  flush_peepholer( "calling another function" );
d4333 1
a4333 1
      off  = (dest - (codep + codebase)) / sizeof_int;
d4335 3
a4337 1
      off -= 4;	/* allow for offset built into LAJ instruction */
d4462 1
a4462 1
  if (address == R_SP)
d4473 2
a4474 2
	  out_triadic_op( OP_LSH3, addr, R_SP, 2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( R_SP ),
d4514 1
a4514 1
		  indirect_field = build_indirect( INDIRECT_PRE_ADD, R_SP, offset );
d4518 1
a4518 1
		  indirect_field = build_indirect( INDIRECT_PRE_SUB, R_SP, -offset );
d4523 1
a4523 1
	      indirect_field = build_indirect( INDIRECT_REL, R_SP, 0 );
d4556 1
a4556 1
		       examines1( R_SP ),
d4564 1
a4564 1
			    examines1( R_SP ),
d4581 1
a4581 1
			    examines2( R_TMP1, R_SP ),
d4964 1
a4964 1
  out_triadic_op( OP_SUBI3, reg, reg, RR_IR0, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d4968 1
a4968 1
  out_triadic_op( OP_LSH3, reg, reg, 2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
d5327 2
a5328 2
			examines1( R_SP ),
			alters2( R_SP, R_TMP1 ) );
d5551 4
d5557 1
a5557 1
	  immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, m );
d5560 1
a5560 1
      if (r2r == R_SP && is_address_register( hardware_register( r1r ) ))
d5587 1
a5587 1
      if (r2r == R_SP && is_address_register( hardware_register( r1r ) ))
d5655 1
a5655 1
      if (r2r == R_SP && is_address_register( hardware_register( r1r ) ))
d5671 1
a5671 1
      if (r2r == R_SP && is_address_register( hardware_register( r1r ) ))
d6019 2
d6258 1
a6258 1
	  /* fprintf( asmstream, "eliminated a NOP\n" ); */
d6262 1
a6262 1
      /* else fprintf( asmstream, "could not swap\n" ); */
d6291 1
a6291 1
	      /* branch is PC relative - increase offset by 3 */
d6295 1
a6295 1
	      off += 3;
d6306 1
a6306 1
	  /* fprintf( asmstream, "converted a conditional branch\n" ); */
d6321 1
a6321 1
	  /* branch is PC relative - increase offset by 3 */
d6325 1
a6325 1
	  off += 3;
d6335 1
a6335 1
	  /* fprintf( asmstream, "converted an unconditional branch\n" ); */
d6401 1
a6401 1
	      int32	op_code,
d6418 32
a6452 2
  prev_op = peep_buf[ prev ].op_code;

d6459 2
a6460 2
  curr_load  = is_potential_parallel_op(  op_code, OP_LDI );
  curr_store = is_potential_parallel_op(  op_code, OP_STI );
d6470 2
a6471 2
	                         (op_code & (B_111 << 16)) << (19 - 16) |
	                         (op_code & (0xFF << 8)) << (8 - 8)     |
d6474 1
a6474 1
      fprintf( asmstream, "peepholer: transformed instruction! (1)\n" );
d6484 2
a6485 2
	                         (op_code & (B_111 << 16)) << (16 - 16) |
	                         (op_code & (0xFF << 8)) << (8 - 8)     |
d6488 1
a6488 1
      fprintf( asmstream, "peepholer: transformed instruction! (2)\n" );
d6497 1
a6497 1
	                         (op_code & (B_111 << 16)) << (22 - 16) |
d6500 1
a6500 1
		                 (op_code & (0xFF << 8)) >> (8 - 0);
d6502 1
a6502 1
      fprintf( asmstream, "peepholer: transformed instruction! (3)\n" );
d6512 2
a6513 2
	                         (op_code & (B_111 << 16)) << (16 - 16) |
	                         (op_code & (0xFF << 8)) << (8 - 8)     |
d6516 1
a6516 1
      fprintf( asmstream, "peepholer: transformed instruction! (4)\n" );
d6524 1
a6524 1
  if (prev_store && is_suitable_triadic( op_code ))
d6531 1
a6531 1
      switch ((op_code >> 23) & B_11111)
d6561 2
a6562 2
	                             (op_code & (B_111 << 16)) << (22 - 16) |
		                     (op_code & (B_111 << 8))  << (19 -  8) |
d6565 1
a6565 1
		                     (op_code & 0xFF)                       ;
d6567 1
a6567 1
	  fprintf( asmstream, "peepholer: transformed instruction! (5)\n" );
d6611 2
a6612 2
		                     (op_code & (B_111 << 16)) << (16 - 16) |
		                     (op_code & (0xFF << 8))   << ( 8 -  8) |
d6615 1
a6615 1
	  fprintf( asmstream, "peepholer: transformed instruction! (6)\n" );
d6785 1
a6785 1
  /* fprintf( asmstream, "flushed: %s\n", reason ); */
d6802 2
d6825 2
d6839 1
a6839 1
      outcodeword( instruction->op_code, LIT_OPCODE );
a6850 4
	  int32		offset;
	  int32		op;
	  

a6853 2
	  op = instruction->op_code;
	  
d6898 1
a6898 1
      outcodeword( instruction->op_code, LIT_OPCODE );
d6910 4
d6915 1
a6915 1
      /* drop through */
d6917 10
a6926 2
    case OUT_SYMREF:
      outcodewordaux( instruction->op_code, LIT_RELADDR, instruction->symbol );
@


1.18
log
@updated calling conventions description
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.17 1991/10/03 07:20:20 nickc Exp nickc $ */
d1640 3
a1642 3
 *              ^           ^                       ^
 *              |           |                       |
 *              FP'         SP                      SE
d1657 1
a1657 1
 *              ^                                ^                                                 ^
@


1.17
log
@fixed peepholer unwanted convertion of LAJ into CALL
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.16 1991/10/02 11:05:53 nickc Exp nickc $ */
d1545 1
a1545 1
 * is a dynamic structure that cannot be a fixed because laguages like
d1552 1
a1552 1
 * (NB/ arguments 1 to 3 held in register, return address held in link register)
d1559 1
a1559 1
 *    |                      |  n  |     |  5  |  4  |                      |
d1581 1
a1581 1
 *                           |  n  |     |  5  |  4  |     |     |  reg  |     |  reg  | 
d1593 1
a1593 1
 * (NB/ arguments 1 to 3 now on stack, all arguments accessed via FP)
@


1.16
log
@updated to match latest register allocation scheme (again!)
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.15 1991/10/02 09:20:14 nickc Exp nickc $ */
d181 2
d184 2
d363 3
a365 1
#define _regname( r ) ((((r) & 0x1f) * 4) + regstr)
d1986 3
a1988 2
      
      flush_peepholer( "routine_exit" );
d2027 2
a2028 2
		    examines1( R_SP ),
		    alters2( R_SP, RR_ST ) );
d2042 2
a2043 2
	       examines1( R_LR ),
	       alters1( RR_PC ) );
a3166 7
#ifdef NEVER  
  if (!is_address_register( hardware_register( dest ) ))
    {
      syserr( "warning: trying to load an address constant into a non-address register %s\n",
	     _regname( hardware_register( dest ) ) );
    }
#endif
d3239 11
a3249 1
       * A defined internal code symbol
d3252 43
a3294 1
      syserr( "load_address_constant: asked to load address of defined symbol when not in stubs" );
d3338 1
a3338 1
      peep_xref( X_PCreloc, symbol );
d3356 4
d3375 7
a3381 1
	  syserr( "warning: loading calling stub into register other than AR5 - linker will not work!\n" );
d3478 5
a3666 3
static int32	codep_of_call = 0;


a3684 6
   * remember the address of the next instruction
   */
  
  codep_of_call = codep;
  
  /*
d3701 4
d3706 2
d3770 1
a3770 1
   *                                                     <-codep_of_call->
d3773 1
a3773 1
   *  <---------------------------R_ADDR1 ------------------------------->
d3790 8
d4170 3
a4172 1
      
d4201 1
a4201 1
  peep_xref( X_PCreloc, name );
d5154 4
a5159 2
	  outinstr( OP_CALL << 24, examines0(), alters1( RR_PC ) );
      
d6086 2
d6090 1
d6106 1
a6106 1
      if ((op & (B_011010 << 26)) == (B_011010 << 26))
d6133 2
d6138 1
a6138 1
      else if ((op & (B_0110000 << 25)) == (B_0110000 << 25))
d6163 2
d6272 2
d6286 2
d6300 2
d6314 2
d6365 2
d6413 2
d6583 1
a6583 1
  /* fprintf( stderr, "flushed: %s\n", reason ); */
a6699 1

@


1.15
log
@updated to match changes in target.h
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.14 1991/10/01 13:18:33 nickc Exp nickc $ */
d380 4
a383 4
      0x1c,	/*  8 =>  R8 */
      0x1d,	/*  9 =>  R9 */
      0x1e,	/* 10 => R10 */
      0x13,	/* 11 =>  BK */
d385 9
a393 9
      0x08, 	/* 13 => AR0 */
      0x09,	/* 14 => AR1 */
      0x0a,	/* 15 => AR2 */
      0x0b,	/* 16 => AR3 */
      0x0c,	/* 17 => AR4 */
      0x0d,	/* 18 => AR5 */
      0x0e,	/* 19 => AR6 */
      0x0f,	/* 20 => AR7 */
      0x1f,  	/* 21 => R11 */
@


1.14
log
@added support for static data initialisation
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.13 1991/09/25 12:48:29 nickc Exp nickc $ */
d88 1
d385 9
a393 9
      0x1f, 	/* 13 => R11 */
      0x08,	/* 14 => AR0 */
      0x09,	/* 15 => AR1 */
      0x0a,	/* 16 => AR2 */
      0x0b,	/* 17 => AR3 */
      0x0c,	/* 18 => AR4 */
      0x0d,	/* 19 => AR5 */
      0x0e,	/* 20 => AR6 */
      0x0f,  	/* 21 => AR7 */
d3942 2
a3943 2
	  out_diadic_op( OP_STI, ADDR_MODE_IMMEDIATE, source, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( source, dest ),
d3948 1
a3948 1
	  out_diadic_op( OP_STI, ADDR_MODE_IMMEDIATE, source,
d3950 1
a3950 1
			examines2( source, dest ),
d3955 2
a3956 2
	  out_diadic_op( OP_STI, ADDR_MODE_IMMEDIATE, source, build_indirect( INDIRECT_REL, dest, 0 ),
			examines2( source, dest ),
d4000 19
@


1.13
log
@fixed block copy to cope with not having two address registers
@
text
@d3 1
a3 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/gen.c,v 1.12 1991/09/20 17:18:04 nickc Exp nickc $ */
d54 1
d61 3
d84 1
d86 3
a88 1
   void		finished_function_exporting( void );
d153 1
d201 1
a201 1
  append_peep( OUT_INSTR, op_code, reads, writes, NULL, 0, NULL, 0 );
d217 1
a217 1
	      alters0(), NULL, 0, NULL, 0 );
d234 1
a234 1
  append_peep( OUT_DELAYED, op_code, reads, writes, NULL, 0, NULL, 0 );
d257 1
a257 1
  append_peep( OUT_LABREF, op_code, reads, writes, NULL, offset, label, 0 );
d276 1
a276 1
  append_peep( OUT_DELLABREF, op_code, reads, writes, NULL, offset, label, 0 );
d298 1
a298 1
  append_peep( OUT_SYMREF, op_code, reads, writes, name, 0, NULL, 0 );
d316 1
a316 1
  append_peep( OUT_DELSYMREF, op_code, reads, writes, name, 0, NULL, 0 );
d1057 2
a1058 3
      /* put address in temporary register */
  
      move_register( src, R_ATMP );
d1060 12
a1071 1
      /* divide by sizeof_int (here assumed to be 4) */
d1073 3
a1075 3
      out_triadic_op( OP_LSH3, R_ATMP, R_ATMP, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		    examines1( R_ATMP ),
		    alters2( R_ATMP, RR_ST ) );
d1085 3
a1087 3
	  out_triadic_op( OP_ADDI3, R_ATMP, R_ATMP, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
			 examines1( R_ATMP ),
			 alters2( R_ATMP, RR_ST ) );
d1091 3
a1093 3
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, offset,
			examines1( R_ATMP ),
			alters2( R_ATMP, RR_ST ) );
d1104 2
a1105 2
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ),
		    examines2( RR_IR0, R_ATMP ),
d1122 4
a1125 4
		      int32		op,
		      RealRegister	dst,
		      RealRegister	src,
		      RealRegister	offset )
d1978 4
d2164 7
a2170 1
    asm_lablist = mkLabList( asm_lablist, l );
a2171 4
  /* resolve all the forward references to this label */
  
  p = l->u.frefs;
  
d2318 1
a2318 1
      w   = (destination->u.defn) & 0x7fffffff;		/* get position of label in our code */
a2613 1
  fprintf( stderr, "copying memory\n" );
a2647 2
  fprintf( stderr, "dest assigned as %d, source = %d\n", dest, source );
  
a2664 2
  fprintf( stderr, "length = %d\n", length );

a2776 2
  fprintf( stderr, "copying extras\n" );
  
a2867 2
  fprintf( stderr, "memory copied\n" );
  
d3001 6
a3006 4
 *         The (split)      ->|       .blank |      .      |
 *         Module Table    |  |   |   .      |  |   .   |  |
 *                         |   ---|-------------|-------|---- - - -
 *                         |______|             |       |
d3011 1
a3011 1
 *                        (word pointer to)                      (byte offset from IR0 of ...)
d3014 17
a3030 10
 *        Per Module           ------------------------------ - - -          |
 *     Function Pointers      |       |      |      |      |                 |
 * (shared between processes) |   |   |      |      |      |                 |
 *                             ---|-------------------------- - - -          |
 *                                |                                          |
 *                        (word address of first                             |
 *                         function in module)                               |
 *                                |                                          |
 *                         <------                                           |
 *                                 __________________________________________|
a3032 5
 *      Per Module             ------------------------------ - - -
 *      Data Slots            |       |      |      |      |
 * (one copy per process)     |       |      |      |      |
 *                             ------------------------------ - - -
 *
d3087 1
a3087 1
  if (!iscode && split_module_table)
d3090 1
a3090 1
       * if we are accessing the data slots of a split
d3154 1
a3154 1
  if (offset != 0)
d3156 1
a3156 1
      syserr( "load_address_constant: non-zero offsets not yet supported" );
d3158 1
d3216 3
d3223 1
a3223 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
d3241 1
a3241 7
      /*
       * this case is now taken care of by the
       * prepare_to_export_functions() and
       * export_functions() code
       */
      
      syserr( "loading the address of a defined internal symbol, when not in stubs\n" );
d3280 3
d3287 1
a3287 1
      out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_ATMP, 0,
d3311 5
d3380 1
a3380 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, 0,
d3453 1
a3453 1
      
d3458 1
a3458 1
      
d3475 1
a3475 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, split_module_table ? 1 : 0,
d3499 3
d3506 1
a3506 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0,
d3602 8
d3638 6
d3699 1
a3699 1
   * in prepare_for_function_exporting()
d3725 6
d3732 1
a3732 1
   * we have in R_ADDR1 (see prepare_for_function_exporting())
d3737 1
a3737 1
    {
d3745 1
a3745 1
      
d3750 1
a3750 1

d3764 235
d4000 1
a4000 1
 * we have finished exporting functions
d4004 1
a4004 1
finished_function_exporting( void )
d4006 1
a4006 1
/*  flush_peepholer( "end of function exports" ); */
d4993 1
a4993 1
	      fprintf( stderr, "Unused label L%ld\n", lab_name_( l ) & 0x7fffffff );
d5683 1
a5683 1
      asm_lablist = 0;
d5896 12
d6039 3
a6041 1
	  
d6047 8
d6357 11
a6367 3
	  peep_buf[ peep_end ].type    = OUT_XREF;
	  peep_buf[ peep_end ].symbol  = pending_symbol;
	  peep_buf[ peep_end ].reftype = pending_reftype;
d6524 49
a6572 1
      addfref_( instruction->label, codep | instruction->offset );
@


1.12
log
@removed use of DP as a zero register
@
text
@d3 1
a3 1
/* $Header$ */
d394 3
d2587 1
d2590 1
a2607 1
  
d2613 1
a2613 1
	  dst = R_ATMP;
d2617 5
a2621 5
	  /* we only have one temporary address available */
	  
	  syserr( syserr_cannot_do_block_move );
	  
	  return;
d2625 2
d2644 2
d2758 2
d2847 5
d3032 1
d3037 1
a3037 1
      
d3139 1
a3139 1
  
d3145 1
a3145 1

d5001 9
a5009 2
      
      immediate_op( OP_SUBI, OP_SUBI3, r1r, r2r, m );
d5029 4
d5791 23
d5838 2
a5839 2
  if (writes & peep_buf[ prev ].writes)
    return FALSE;		/* both instructions alter the same register */
d5852 3
d5902 97
a5998 1
  
@


1.11
log
@added code to catch potential parallel loads and stores
@
text
@d3 1
d310 4
d363 13
a375 13
      0x10,	/*  0 =>  DP */
      0x00,	/*  1 =>  R0 */
      0x01,	/*  2 =>  R1 */
      0x02,	/*  3 =>  R2 */
      0x03,	/*  4 =>  R3 */
      0x04,	/*  5 =>  R4 */
      0x05,	/*  6 =>  R5 */
      0x06,	/*  7 =>  R6 */
      0x07,	/*  8 =>  R7 */
      0x1c,	/*  9 =>  R8 */
      0x1d,	/* 10 =>  R9 */
      0x1e,	/* 11 => R10 */
      0x13,	/* 12 =>  BK */
d871 1
a871 1
       * that might prevent us from optimising the ldad in the peepholer
d874 1
a874 1
      move_register( R_R0, r );
d1052 1
a1052 1
      out_triadic_op( OP_LSH3, R_ATMP, R_ATMP, -2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d1420 1
a1420 1
	  out_triadic_op( OP_MPYI3, dest, source, val, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d2385 1
a2385 3
      /* get start address into a temporary address register */
  
      move_register( start, R_ATMP );
d2393 7
a2399 1
      
d2405 1
a2405 1
  length &= ~(sizeof_int - 1);
d2416 1
a2416 1
  else if (length == sizeof_int)		/* XXX - can this ever happen ? */
d2418 6
a2423 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( dst, RR_IR0, R_R0 ),
d2426 1
a2426 1
  else if (length == 2 * sizeof_int)		/* XXX - can this ever happen ? */
d2428 6
a2433 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( dst, RR_IR0, R_R0 ),
d2435 3
a2437 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( dst, RR_IR0, R_R0 ),
d2442 6
d2450 1
a2450 1
      out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC, length / sizeof_int,
d2454 2
a2455 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( R_R0, dst, RR_IR0 ),
d2457 2
d2464 6
d2472 1
a2472 1
      load_integer( RR_RC, length / sizeof_int, FALSE );
d2482 2
a2483 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ),
		    examines3( R_R0, dst, RR_IR0 ),
d2485 2
d2570 1
a2570 1
 * copy the 'length' "bytes" of memory pointed to by 'start' to the area pointed to by 'dest'
d2575 2
a2576 2
	    RealRegister	source,
	    RealRegister	dest,
d2582 2
d2595 1
a2595 1
  if (!can_corrupt_source || !is_address_register( hardware_register( source ) ))
a2596 2
      move_register( source, R_ATMP );

d2599 5
d2605 1
a2605 1
  if (!can_corrupt_dest || !is_address_register( hardware_register( dest )))
d2609 1
a2609 3
	  move_register( dest, R_ATMP );

	  dest = R_ATMP;
d2621 10
d4409 1
a4409 1
  out_triadic_op( OP_LSH3, reg, reg, 2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER,
d5617 1
a5617 1
      
d5625 1
a5625 1
      if (delayed == peep_start)
d5649 1
a5649 1
  
d5667 2
a5668 2
	  
	  return FALSE;
d5671 1
a5671 1
  
d5714 1
a5714 1
	}	      
a5716 2
	  int32	off;
	  
a5723 8
	  /* branch is PC relative - increase offset by 3 */
	  
	  off = mask_and_sign_extend_word( op, 0xFFFFFF );
	  
	  off += 3;
	  
	  op = (op & (unsigned long)0xFF000000L) | (off & 0x00FFFFFFL);
	  
d5729 1
a5729 1
	  
d5731 1
a5731 1
	}	      
@


1.10
log
@peepholer no elimiates delayed branches when they cannot be optimised
@
text
@d4939 1
a4939 1
      immediate_op( OP_SUBB, OP_SUBB3, r1r, r2r, m );
d5046 1
a5046 1
      register_op( OP_SUBB, OP_SUBB3, r1r, r2r, mr );
d5465 3
a5467 1
#define num_in_peep()		(peep_end - peep_start + (peep_end < peep_start ? PEEP_BUF_SIZE : 0))
d5551 10
a5560 11
  
static void
append_peep(
	    peep_type		type,
	    int32		op_code,
	    int32		reads,
	    int32		writes,
	    Symstr *		symbol,
	    unsigned32		offset,
	    LabelNumber *	label,
	    int32		reftype )
d5562 4
a5565 1
  signed int	next;
d5567 1
d5569 3
a5571 3
  /* see if we have a redundant op-code */
  
  if (type == OUT_NULL)
d5573 2
a5574 3
      signed int	delayed;
      int		count;
      int		nulls = 0;
d5576 1
a5576 4

      /* see if we have a delayed instruction somewhere in the previous three op-codes */

      delayed = peep_end - 1;
d5578 1
a5578 1
      for (count = 0; count < 3; count++)
d5580 1
a5580 3
	  if (delayed == peep_start - 1)
	    {
	      /* reached end of peep hole buffer */
d5582 1
a5582 1
	      count = 4;
d5584 2
a5585 4
	      break;
	    }
	  
	  delayed &= (PEEP_BUF_SIZE - 1);
d5587 1
a5587 7
	  if (peep_buf[ delayed ].type == OUT_NULL)
	    {
	      ++nulls;
	    }
	  else if (is_delayed( peep_buf[ delayed ].type ))
	    {
	      /* found delayed instruction */
d5589 11
a5599 4
	      break;
	    }

	  delayed--;
d5601 12
a5612 2

      if (count < 3 && delayed != peep_start)
d5614 6
a5619 4
	  signed int	prev;


	  /* we have a delayed instruction and one other instruction */
d5621 1
a5621 15
	  prev = delayed - 1;

	  prev &= (PEEP_BUF_SIZE - 1);

	  if (can_swap( delayed, prev ))
	    {
	      peep_data		tmp;


	      tmp                 = peep_buf[ delayed ];
	      peep_buf[ delayed ] = peep_buf[ prev    ];
	      peep_buf[ prev    ] = tmp;
	      
	      return;
	    }
d5623 16
a5638 2

      if (count == 2 && nulls == 2)
d5640 3
a5642 2
	  int32	op = peep_buf[ delayed ].op_code;

d5644 1
a5644 7
	  /*
	   * We failed to swap the delayed instruction
	   * but we might be able to convert the delayed insrtuction
	   * and the three following NOPs into a non-delayed insrtuction.
	   * This does not save code execution time, but it will save
	   * code space.
	   */
d5646 1
a5646 33
	  if ((op & (B_011010 << 26)) == (B_011010 << 26))
	    {
	      /* we have a conditional branch */
	      
	      /* removed delayed bit */
	      
	      op &= ~(1 << 21);
	      
	      if (op & (1 << 25))
		{
		  int32	off;
		  
		  
		  /* branch is PC relative - increase offset by 3 */
		  
		  off = mask_and_sign_extend_word( op, 0xFFFF );
		  
		  off += 3;
		  
		  op = (op & (unsigned long)0xFFFF0000L) | (off & 0x0000FFFFL);
		}
	      
	      peep_buf[ delayed ].op_code = op;
	      
	      /* remove previous two inserted NOPs */
	      
	      peep_end = delayed + 1;
	      
	      peep_end &= (PEEP_BUF_SIZE - 1);
	      
	      return;
	    }	      
	  else if ((op & (B_0110000 << 25)) == (B_0110000 << 25))
a5648 1

a5649 1
	      /* we have an unconditional branch */
a5650 4
	      /* removed delayed bit */
	      
	      op &= ~(1 << 24);
		  
a5651 6
		  
	      off = mask_and_sign_extend_word( op, 0xFFFFFF );
		  
	      off += 3;
		  
	      op = (op & (unsigned long)0xFF000000L) | (off & 0x00FFFFFFL);
d5653 1
a5653 1
	      peep_buf[ delayed ].op_code = op;
d5655 1
a5655 1
	      /* remove previous two inserted NOPs */
d5657 185
a5841 7
	      peep_end = delayed + 1;
	      
	      peep_end &= (PEEP_BUF_SIZE - 1);
	      
	      return;
	    }	      
	}
d5905 1
a5905 1
  next = peep_end + 1;
a5906 2
  next &= (PEEP_BUF_SIZE - 1);

d5933 1
a5933 3
  prev = peep_end - 1;

  prev &= (PEEP_BUF_SIZE - 1);
d5996 1
a5996 3
   * possible optimisations :-
   *
   *   parallel load / store & load / store
@


1.9
log
@added first stage peepholer which tries to eliminate NOPs
@
text
@d144 1
d146 1
d1237 5
d1246 20
a5526 1

a5540 1

d5570 1
d5590 1
a5590 1
	  if (is_delayed( peep_buf[ delayed ].type ))
d5592 4
a5603 6
      if (count > 2)
	fprintf( stderr, "failed to find delayed instruction\n" );
      else
	fprintf( stderr, "delayed instruction = %x, num in buf = %d\n",
		peep_buf[ delayed ].op_code, num_in_peep() );

a5614 3
	  fprintf( stderr, "delayed = %x, prev = %x\n", peep_buf[ delayed ].op_code,
		  peep_buf[ prev ].op_code );

d5623 53
d5677 2
a5678 2
	      fprintf( stderr, "peepholer: successfully swapped op codes %x and %x\n",
		      peep_buf[ delayed ], peep_buf[ prev ] ); 
d5680 20
d5701 1
a5701 5
	    }
	  else
	    fprintf( stderr, "cannot swap delayed r = %x w = %x, prev r = %x, w = %x\n",
		    peep_buf[ delayed ].reads, peep_buf[ delayed ].writes,
		    peep_buf[ prev ].reads, peep_buf[ prev ].writes ); 
d5716 1
a5716 1
  /* check to see if this instruction was a cross reference */
d5785 28
d5834 1
a5834 1
 fprintf( stderr, "flushed: %s\n", reason ); 
d5865 1
a5865 3
   *   parallel load / store & triadic op
   *
   *   elimination of unnecssary compare ops
d5867 1
a5867 1
   *   pushing delyed instructions back through instruction list to eliminate no-ops
@


1.8
log
@added declarations of reads and writes to all output instructions - start of peep holing
@
text
@d62 4
a65 4
f(int *x,int *y) { x[5] = y[5];  x[4] = y[4];  x[3] = y[3];
                   x[2] = y[2];  x[1] = y[1];  x[0] = y[0]; }
g(int *x) { h(x[1],x[2],x[3]); }
*/
d73 1
a73 1
      also (beware peephole):
d77 1
a77 1
     added for 'C40
d80 2
a81 1
*/
d112 11
a122 4
    OUT_NULL,
    OUT_INSTR,
    OUT_SYMREF
  }
d128 1
a128 1
    int32 		w;		/* 32 bits of data */
d131 4
a134 4
    Symstr *		s;		/* external symbol (if needed) */
    unsigned32 		off;		/* offset (if needed) */
    LabelNumber *	lab;		/* (if needed) */
    int32 		reftype;	/* label reference type */
d138 6
a143 3
static peep_data	peep_buf[ 5 ];	/* circular buffer of op codes */
static int		peep_start = 0;	/* next instruction to be emitted */
static int		peep_end   = 0;	/* last instruction inserted */
a144 7

static void emit_one_peeped( peep_data * );
static void flush_peepholer( void );
static void add_flush_noop(  void );
static bool insert_one_peep( peep_data * );
static bool swappable( int32, int32, int32, int32 );

a181 2
 * some day soon this will take more parameters,
 * and will be attached to the peepholer
a189 2
/*  outcodeword( op_code, LIT_OPCODE ); */

d191 1
a191 1
  
d193 1
a193 1
  
d195 80
a274 1
  	
a277 2
 * some day soon this will take more parameters,
 * and will be attached to the peepholer
a286 2
/*  outcodewordaux( op_code, LIT_RELADDR, name ); */

d288 1
a288 1
  
d290 1
a290 1
  
d295 1
a295 1
 * send a NO-OP instruction
d299 5
a303 1
nop( void )
d305 10
a314 1
  outinstr( OP_NOP << 23, examines0(), alters0() );
d316 10
d327 3
a329 3
  
} /* nop */
  
d344 1
a344 1
		       
d862 6
a867 3
      /* we could use 'move_register( R_R0, r )' here, but that would set the condition codes */
      
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, r, 0, examines0(), alters1( r ) );
d1000 5
a1004 4

      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, src, -2,
		    examines1( src ),
		    alters2( src, RR_ST ) );
d1012 6
d1045 1
a1045 1
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2,
d1055 6
d1119 1
a1119 1
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_SP,
d1139 1
a1139 1
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2,
d1191 8
a1198 2
      
      if (fits_in_16_bits( move ))
d1201 2
a1202 2
			examines1( R_SP ),
			alters2( R_SP, RR_ST ) );
d1210 1
a1210 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_SP, R_TMP1,
d1367 1
a1367 7
      if (dest == source)
	{
	  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, dest, val,
			examines1( dest ),
			alters2( dest, RR_ST ) );
	}
      else if (fits_in_8_bits( val ))
d1378 6
d1386 1
a1386 1
	  move_register( source, dest );
d1388 2
a1389 2
	  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, dest, val,
			examines1( dest ),
d1399 1
a1399 1
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dest, firstbit( -val ),
d1727 1
a1727 1
       * floating point of integer argument, we have
d1761 6
d1812 2
a1813 2
  if (num_args > NARGREGS   ||		/* if we have arguments passed on the stack */
      maskarg                )          /* or we have had to save arguments on the stack */
d1837 1
a1837 1
#ifdef NEVER
d1855 1
a1855 1
#endif /* NEVER */
d1867 1
a1867 1
   * OK we are done - set up the statics used by routine_exit()
d1889 22
a1910 3
      out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_SP, stack_offset / sizeof_int,
		    examines1( R_SP ),
		    alters2( R_SP, RR_ST ) );
d1961 1
a1961 1
      out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_SP, bitcount( saved_args ),
d1976 4
a1979 3
      outinstr( OP_BRcrD << 24 | 0x1 << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_LR ),
	       examines2( R_LR, RR_ST ),
	       alters0() );
d1981 5
a1985 9
      /*
       * branch does not take place until after next three instructions,
       * so for now, insert padding instructions
       */

      nop();
      nop();
      nop();
    }
d2011 3
a2013 12
  outinstr( OP_BRc << 24 | 0x1 << 21 | C_FROMQ( condition ) << 16 | (num_to_skip & 0xffff),
	   condition == Q_AL ? examines0() : examines1( RR_ST ),
	   alters0() );

  /*
   * branch does not take place until after next three instructions,
   * so for now, insert padding instructions
   */

  nop();
  nop();
  nop();
d2101 2
a2102 1
  List *	p = l->u.frefs;
d2104 2
a2105 1

d2111 2
d2127 1
a2127 1
      
d2253 8
a2260 2
      int32	w   = (destination->u.defn) & 0x7fffffff;	/* get position of label in our code */
      int32	off = (w - codep) / sizeof_int - 3;		/* calculate offset (in words) (the -3 is because of the delay in the branch)  */
d2279 3
a2281 12
	  outinstr( OP_BRD << 24 | (off & 0xffffff),
		   examines0(),
		   alters0() );
	  
	  /*
	   * branch does not take place until after next three instructions,
	   * so for now, insert padding instructions
	   */

	  nop();
	  nop();
	  nop();
d2302 2
a2303 13
	  addfref_( destination, codep | LABREF_OFF24 );
	
	  outinstr( OP_BRD << 24 | 0,
		   examines0(), alters0() );

	  /*
	   * branch does not take place until after next three instructions,
	   * so for now, insert padding instructions
	   */

	  nop();
	  nop();
	  nop();
d2307 7
a2313 3
	  addfref_( destination, codep | LABREF_OFF16 );
      
	  conditional_skip_instructions( condition, 0 );
d2789 7
a2795 1
  if (dest == source && fits_in_16_bits( value ))
a2800 6
  else if (fits_in_8_bits( value ))
    {
      out_triadic_op( triadic_op, dest, source, value, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE,
		     examines1( source ),
		     alters2( dest, RR_ST ) );
    }
d2976 1
a2976 1
  codexrefs = (CodeXref *) global_list3( SU_Other, codexrefs, X_Modnum + codebase + codep, 0 );
d3098 1
a3098 1
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataSymbHi + codebase + codep, symbol );
d3108 1
a3108 1
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataSymbLo + codebase + codep, symbol );
d3158 1
a3158 1
      outinstr( OP_CALL << 24, examines0(), alters0() );
d3175 1
a3175 1
      codexrefs = (CodeXref *) global_list3( SU_Other, codexrefs, X_PCreloc + codebase + codep, symbol );
d3251 1
a3251 1
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataModule1 + codebase + codep, symbol );
d3263 1
a3263 1
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataModule2 + codebase + codep, symbol );
d3272 2
a3274 2
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataModule3 + codebase + codep, symbol );

d3285 1
a3285 1
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataModule4 + codebase + codep, symbol );
d3295 1
a3295 1
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataModule5 + codebase + codep, symbol );
d3357 2
a3359 2
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataModule + codebase + codep, symbol );
      
d3375 2
a3376 2
      
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataSymbHi + codebase + codep, symbol );
d3385 2
a3386 2
      
      codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_DataSymbLo + codebase + codep, symbol );
d3426 1
a3426 1
  outinstr( OP_CALL << 24, examines0(), alters0() );
d3448 1
a3448 1
  addfref_( litlab, codep | LABREF_LIT16 );
d3488 6
d3509 1
a3509 1
  outinstr( OP_CALL << 24, examines0(), alters0() );
a3537 1
  
d3625 13
a3637 1
  
d3674 1
a3674 1
		   alters0() );
d3680 1
a3680 1
		   alters1( R_LR ) );
d3685 2
d3712 2
a3713 2
	      outinstrref( OP_BRD << 24 | (off & 0xffffff), name,
			  examines0(), alters0() );
d3717 1
a3717 1
	      outinstrref( OP_LAJ << 24 | (off & 0xffffff), name,
d3719 1
a3719 1
			  alters1( R_LR ) );
a3721 9
	  /*
	   * link does not take place until after next three instructions,
	   * so for now, insert padding instructions
	   */

	  nop();
	  nop();
	  nop();
	  
d3734 1
a3734 1
  codexrefs = (CodeXref *)global_list3( SU_Other, codexrefs, X_PCreloc + codebase + codep, name );
d3738 1
a3738 1
      outinstrref( (OP_BRD << 24) | 0, name, examines0(), alters0() );
d3742 1
a3742 1
      outinstrref( (OP_LAJ << 24) | 0, name, examines0(), alters1( R_LR ) );
d3744 3
a3746 1
      
a3748 9
  /*
   * link does not take place until after next three instructions,
   * so for now, insert padding instructions
   */

  nop();
  nop();
  nop();
  
d4331 1
a4331 1
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, reg, RR_IR0,
d4335 3
a4337 3
  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, reg, 2,
		examines1( reg ),
		alters2( reg, RR_ST ) );
d4528 3
a4530 7
      outinstr( (OP_LAJcr << 24) | 0x1L << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( mr ),
	       examines1( mr ),
	       alters1( R_LR ) );

      nop();
      nop();
      nop();
d4541 3
a4543 7
      outinstr( OP_BRcrD << 24 | 0x1L << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( mr ),
	       examines1( mr ),
	       alters0() );

      nop();
      nop();
      nop();
d4568 2
d4626 2
d4677 1
a4677 1
	  addfref_( tablelab, codep | LABREF_LIT8 );
d4689 1
a4689 1
	  outinstr( OP_CALL << 24, examines0(), alters0() );
d4718 1
a4718 1
		   alters0() );
d4722 2
d4739 2
d5280 1
a5280 1
	  
d5290 2
d5372 1
a5372 1
      nop();		/* placeholder */
d5415 405
a5819 1
/* End of section c40/gen.c */
@


1.7
log
@fixed target_is_address_register (or whatever its called) and removed conditional loads
@
text
@a79 1
   void		generate_nops( int num );
d107 45
a151 3
/*
 * XXX - peepholer used to be here
 */
d183 4
a186 1
outinstr( int32 op_code )
d188 1
a188 1
  outcodeword( op_code, LIT_OPCODE );
d190 2
d205 4
a208 2
	    int32	op_code,
	    Symstr *	name )
d210 1
a210 1
  outcodewordaux( op_code, LIT_RELADDR, name );
d212 2
d217 15
a231 1
  	
d300 6
a305 4
	      int32		op_code,
	      int32		addressing_mode,
	      RealRegister	destination,
	      int32		source )	/* NB/ doubles up as a RealRegister */
d350 1
a350 1
  outinstr( op );
d372 3
a374 1
	       int		source2_type )
d605 1
a605 1
  outinstr( op );
d648 3
a650 1
		     int32		source )	/* NB/ doubles up as a RealRegister */
d652 3
d660 2
d664 1
a664 2
      outinstr( (OP_LDIc << 28) | C_FROMQ( condition ) << 23 |
	       hardware_register( destination ) << 16 | hardware_register( source ) );
d668 1
a668 2
      outinstr( (OP_LDIc << 28) | C_FROMQ( condition ) << 23 | (addressing_mode << 21) |
	       hardware_register( destination ) << 16 | source );
d713 3
a715 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, source );
d728 3
a730 1
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_PRE_INCR, R_SP, 0 ) );
d742 3
a744 1
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, reg, build_indirect( INDIRECT_POST_DECR, R_SP, 0 ) );
d764 3
a766 1
      move_register( R_R0, r );
d774 3
a776 1
	  out_diadic_op( OP_LDA, ADDR_MODE_IMMEDIATE, r, n );
d782 3
a784 1
	  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, r, n );
d791 3
a793 1
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, r, n >> 16 );
d813 3
a815 1
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_TMP3, RR_ST );
d820 3
a822 1
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, r, n >> 16 );
d826 3
a828 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, r, n );
d834 3
a836 1
	  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, RR_ST, R_TMP3 );
d872 2
a873 1
	      syserr( "out_immediate_offset: byte offset from stack pointer is too large - %d", offset * 4 );
d878 3
a880 1
	      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD, R_SP, offset ) );
d884 3
a886 1
	      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_SUB, R_SP, -offset ) );
d891 3
a893 1
	  out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, R_SP, 0 ) );
d900 3
a902 1
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, src, -2 );
d912 3
a914 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, src, offset );
d925 3
a927 1
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, src, 0 ) );
d937 3
a939 1
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2 );
d949 3
a951 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_ATMP, offset );
d962 3
a964 1
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d987 10
d999 3
a1001 1
      out_triadic_op( OP_LSH3, R_ATMP, offset, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d1005 3
a1007 1
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_SP );
d1011 3
a1013 1
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_REL, R_ATMP, 0 ) );
d1019 3
a1021 1
      out_triadic_op( OP_ADDI3, R_ATMP, src, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d1025 3
a1027 1
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2 );
d1031 3
a1033 1
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d1080 3
a1082 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, move );
d1090 3
a1092 1
	  out_triadic_op( OP_ADDI3, R_SP, R_SP, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d1121 3
a1123 1
      out_diadic_op( OP_CMPI, ADDR_MODE_IMMEDIATE, r, n );
d1131 3
a1133 1
      out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, R_TMP1, r );
d1194 3
a1196 1
      out_triadic_op( OP_ASH3, dest, source, amount, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d1200 3
a1202 1
      out_triadic_op( OP_LSH3, dest, source, amount, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d1222 1
a1222 1
   * bitcount(-m)=1,m!=-1), but are included for completeness and because
d1224 1
a1224 1
   * and invoke mulk recursively
d1237 3
a1239 1
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, dest, source );
d1249 3
a1251 1
	  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, dest, val );
d1260 3
a1262 1
			 ADDR_MODE_IMMEDIATE );
d1268 3
a1270 1
	  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, dest, val );
d1275 7
a1281 3
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, dest, source );
      
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dest, firstbit( -val ) );
d1292 3
a1294 1
		     ADDR_MODE_REGISTER );
d1364 3
a1366 3
 * be placed on the stack and accessed via IR1.  The display is a dynamic
 * structure that cannot be a fixed because laguages like PASCAL require
 * function tables in the display on a per function basis).
a1513 1
 *     FP'' - dummy frame pointer ???
d1549 1
a1549 1
 * setjmp, longjmp
d1763 3
a1765 1
      out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_SP, stack_offset / sizeof_int );
d1816 3
a1818 1
      out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_SP, bitcount( saved_args ) );
d1831 3
a1833 1
      outinstr( OP_BRcr << 24 | 0x1 << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_LR ) );
d1839 4
a1842 4
  
      outinstr( OP_NOP << 23 );
      outinstr( OP_NOP << 23 );
      outinstr( OP_NOP << 23 );
d1859 8
d1869 3
a1871 1
  outinstr( OP_BRc << 24 | 0x1 << 21 | C_FROMQ( condition ) << 16 | (num_to_skip & 0xffff) );
d1877 4
a1880 4
  
  outinstr( OP_NOP << 23 );
  outinstr( OP_NOP << 23 );
  outinstr( OP_NOP << 23 );
d1959 5
a1963 4
/* although the idea of setlabel is machine independent, it stays here
   because it back-patches code.  In the long term setlabel should be
   in codebuf.c and call a machine dependent backpatch routine.
*/
d1997 1
a1997 1
	  d = ((codep - q  >> 2) - 3) + (w & 0xffffff);	/* -3 because of delay in branch */
d2002 1
a2002 1
	  w = (w & (unsigned long) 0xff000000) | d;
d2010 1
a2010 1
	  d = ((codep - q  >> 2) - 3) + (w & 0xffff); 	/* -3 because of delay in branch */
d2015 1
a2015 1
	  w = (w & (unsigned long) 0xffff0000) | d;
d2023 1
a2023 1
	  d = (codep - q  >> 2) + (w & 0xffff);
d2028 14
a2041 1
	  w = (w & (unsigned long) 0xffff0000) | d;
d2045 14
d2069 1
a2069 1
  
d2134 1
a2134 1
	  /* branch, PC relative */
d2136 3
a2138 1
	  outinstr( OP_BRD << 24 | (off & 0xffffff) );
d2144 4
a2147 4
  
	  outinstr( OP_NOP << 23 );
	  outinstr( OP_NOP << 23 );
	  outinstr( OP_NOP << 23 );
d2170 2
a2171 1
	  outinstr( OP_BRD << 24 | 0 );
d2177 4
a2180 4
  
	  outinstr( OP_NOP << 23 );
	  outinstr( OP_NOP << 23 );
	  outinstr( OP_NOP << 23 );
d2255 3
a2257 1
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ) );
d2261 6
a2266 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ) );      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ) );      
d2272 7
a2278 2
      out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC, length / sizeof_int );
      out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT,  R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ) );
d2290 3
a2292 1
      out_diadic_op( OP_RPTS, ADDR_MODE_REGISTER, RR_RC, RR_RC );
d2296 3
a2298 1
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, dst, 0 ) );
d2310 3
a2312 1
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d2314 1
a2314 1
	  /* mask out bottom byte */
d2316 3
a2318 1
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFF );
d2322 3
a2324 1
	  out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d2330 3
a2332 1
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d2334 1
a2334 1
	  /* mask out bottom byte */
d2336 3
a2338 1
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFFFF );
d2342 3
a2344 1
	  out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d2353 3
a2355 1
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d2359 3
a2361 1
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP1, 24 );
d2365 3
a2367 2
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );

d2448 7
a2454 2
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ) );
d2466 15
a2480 4
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ) );
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ) );
d2484 1
d2488 1
a2488 1
      
d2491 3
a2493 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, RR_R0, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
d2501 3
a2503 1
	  out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC,  (length - 1) / sizeof_int );
d2513 3
a2515 1
	  out_diadic_op( OP_RPTS, ADDR_MODE_REGISTER, RR_RC, RR_RC );
d2518 7
a2524 1
      /* instruction repeated is LDI || STI */
d2529 3
a2531 1
	       build_parallel_indirect( INDIRECT_POST_INCR_IR0, source ) );
d2535 8
a2542 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, RR_R0, build_indirect( INDIRECT_POST_INCR_IR0, dest, 0 ) );

d2546 1
d2558 3
a2560 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2565 3
a2567 1
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ) );
d2571 3
a2573 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2580 3
a2582 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2587 3
a2589 1
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ) );
d2593 3
a2595 2
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );

d2599 1
a2599 6
	  /* get the top byte at 'dest' into bottom byte of R_TMP1 */
	  
	  outinstr( FUNC_LOAD << 28 | OP_LBU << 24 | 0x3 << 23 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );

	  /* shift the byte up to top byte */
d2601 3
a2603 1
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP1, 24 );
d2607 9
a2615 5
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ) );

	  /* shift by 8 bits to remove top byte */

	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, source, 8 );
d2620 3
a2622 1
		   hardware_register( R_TMP1 ) << 16 | source );
d2626 3
a2628 2
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );

d2664 3
a2666 1
      out_diadic_op( diadic_op, ADDR_MODE_IMMEDIATE, dest, value );
d2670 3
a2672 1
      out_triadic_op( triadic_op, dest, source, value, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d2678 3
a2680 1
      out_triadic_op( triadic_op, dest, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d2700 3
a2702 8
  if (dest == source1)
    {
      out_diadic_op( diadic_op, ADDR_MODE_REGISTER, dest, source2 );
    }
  else
    {
      out_triadic_op( triadic_op, dest, source1, source2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
    }
d2706 2
d2830 3
a2832 1
  out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, r, R_MT );
d2858 3
a2860 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, r, 1 );    
d2864 3
a2866 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, r, 0 );
d2873 3
a2875 1
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, r, build_indirect( INDIRECT_REL, r, 0 ) );
d2973 3
a2975 1
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0 );
d2983 3
a2985 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0 );
d2991 3
a2993 1
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1 );
d3031 1
a3031 1
      outinstr( OP_CALL << 24 );
d3033 3
a3035 1
      out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, R_TMP1, 0 );
d3050 3
a3052 1
      out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_ATMP, 0 );
d3060 3
a3062 1
      out_triadic_op( OP_ADDI3, dest, R_TMP1, R_ATMP, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER ); 
d3076 1
a3076 1
	  syserr( "warning: loading calling stub into register other than AR5 - linker will not work!\n" );	  
d3126 3
a3128 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, R_MT );
d3138 3
a3140 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, 0 );
d3148 3
a3150 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ) );
d3160 3
a3162 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, 0 );
d3170 3
a3172 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ) );
d3221 3
a3223 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, R_MT );
d3233 3
a3235 1
      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, split_module_table ? 1 : 0 );
d3241 3
a3243 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, dest, 0 ) );
d3251 3
a3253 1
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0 );
d3261 3
a3263 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP1, 0 );
d3269 3
a3271 1
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1 );
d3299 1
a3299 1
  outinstr( OP_CALL << 24 );
d3301 3
a3303 1
  out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, dest, 0 );
d3309 3
a3311 1
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, dest, RR_IR0 );
d3329 3
a3331 1
  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, litpoolp + 3 );
d3346 3
a3348 2
  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dest, 2 );
  
d3376 1
a3376 1
  outinstr( OP_CALL << 24 );
d3385 3
a3387 1
  out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, R_ADDR1, 0 );
d3393 3
a3395 1
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, R_ADDR1, RR_IR0 );
d3468 3
a3470 1
      out_triadic_op( OP_SUBI3, R_TMP1, R_ADDR1, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3476 3
a3478 1
      out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, R_TMP1, R_ADDR1 );
d3486 3
a3488 1
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_POST_INCR, dest, 0 ) );
d3528 3
a3530 1
	  outinstr( OP_BRcr << 24 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_ATMP ) );
d3534 3
a3536 1
	  outinstr( OP_LAJcr << 24 | C_FROMQ( Q_AL ) << 16 | hardware_register( R_ATMP ) );
d3566 2
a3567 1
	      outinstrref( OP_BRD << 24 | (off & 0xffffff), name );
d3571 3
a3573 1
	      outinstrref( OP_LAJ << 24 | (off & 0xffffff), name );
d3580 4
a3584 4
	  outinstr( OP_NOP << 23 );
	  outinstr( OP_NOP << 23 );
	  outinstr( OP_NOP << 23 );
	  
d3601 1
a3601 1
      outinstrref( (OP_BRD << 24) | 0, name );
d3605 1
a3605 1
      outinstrref( (OP_LAJ << 24) | 0, name );
d3614 4
a3618 4
  outinstr( OP_NOP << 23 );
  outinstr( OP_NOP << 23 );
  outinstr( OP_NOP << 23 );
  
d3670 3
a3672 1
	       hardware_register( destination ) | hardware_register( source ) );
d3679 4
d3684 9
a3692 7
load_half_word(
	       RealRegister	dest,			/* register into which to load half-word */
	       RealRegister	source,			/* register that "points to" half word */
	       int32		offset,			/* doubles as a RealRegister */
	       bool		is_signed,		/* true if loading a signed half-word */
	       bool		offset_in_register,	/* true if offset is a RealRegister */
	       bool		can_corrupt_source )	/* true if source register can be corrupted */
d3694 1
a3694 1
  RealRegister	src       = R_ATMP;
d3699 1
a3699 1
  if (source == R_SP)
d3703 6
a3708 1
	  /* copy stack pointer to 'src' adjusting for byte offsets */
d3710 3
a3712 1
	  out_triadic_op( OP_LSH3, src, R_SP, 2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3716 3
a3718 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, src, offset );
d3726 1
a3726 1
	  int32		half_word_selector = (offset & 0x2) >> 1;
d3728 1
a3728 1
	  int32		op;
d3730 8
d3739 1
a3739 1
	  offset >>= 2;
d3745 2
a3746 1
		  syserr( "load_half_word: byte offset from stack pointer is too large - %d", offset * 4 );
d3763 32
a3794 3
	  if (is_signed)
	    {
	      op = OP_LHU;
d3798 22
a3819 1
	      op = OP_LH;
a3821 3
	  outinstr( FUNC_LOAD << 28 | op << 24 | half_word_selector << 23 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( dest ) << 16 | indirect_field );
	  
d3827 1
a3827 1
      /* get byte offset into 'src' */
d3833 3
a3835 1
	  out_triadic_op( OP_ADDI3, src, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3841 1
a3841 1
	      src = source;
d3843 1
a3843 1
	      if (!can_corrupt_source || !is_address_register( hardware_register( source ) ))
d3850 3
a3852 1
	      out_triadic_op( OP_ADDI3, src, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3858 3
a3860 1
	      out_triadic_op( OP_ADDI3, src, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3866 5
a3870 4
   *    src    - byte offset
   *    R_TMP1 - free
   *    R_TMP2 - free
   *    R_TMP3 - free
d3872 1
a3872 1
   * save half-word selector of address into R_TMP1
d3875 3
a3877 1
  out_triadic_op( OP_AND3, R_TMP1, src, 0x2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3880 5
a3884 6
   *    src    - byte offset
   *    R_TMP1 - half-word selector (0 or 2)
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * loose bottom two bits (byte selector) of offset
d3887 1
a3887 1
  if (must_copy)
d3889 18
a3906 1
      src = R_ATMP;
a3907 73
      out_triadic_op( OP_LSH3, src, source, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
    }
  else
    {
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, src, -2 );
    }

  /*
   *    src    - word offset
   *    R_TMP1 - half-word selector (0 or 2)
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * load word into R_TMP2
   */

  if (absolute)
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_REL, src, 0 ) );
    }
  else
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, src, 0 ) );
    }
  
  if (is_signed)
    {
      /*
       *    src    - free
       *    R_TMP1 - half-word selector (0 or 2)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
       *
       * invert half-word selector
       */
  
      out_diadic_op( OP_NOT, ADDR_MODE_REGISTER, R_TMP1, R_TMP1 );

      /*
       *    src    - free
       *    R_TMP1 - NOT half-word selector (2 or 0)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
       *
       * convert to inverted bit position
       */
  
      out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP1, 8 );

      /*
       *    src    - free
       *    R_TMP1 - inverted bit position (16 or 0)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
       *
       * shift source half-word up
       */
  
      out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, R_TMP2, R_TMP1 );

      /*
       *    src    - free
       *    R_TMP1 - free
       *    R_TMP2 - shifted word at destination
       *    R_TMP3 - free
       *
       * shift source half-word down and place in destination
       */
  
      out_triadic_op( OP_ASH3, dest, R_TMP2, -16, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
    }
  else
    {
d3909 5
a3913 4
       *    src    - free
       *    R_TMP1 - half-word selector (0 or 2)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
d3915 1
a3915 1
       * convert half-word selector to negated bit_position
a3916 2

      out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP1, -8 );
d3918 1
a3918 45
      /*
       *    src    - free
       *    R_TMP1 - negate bit position (0 or -16)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
       *
       * shift word to correct source alignment and place in dest
       */

      out_triadic_op( OP_LSH3, dest, R_TMP2, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );

      /*
       *    src    - free
       *    R_TMP1 - free
       *    R_TMP2 - free
       *    R_TMP3 - free
       *
       * ensure top half-word is zero
       */

      out_diadic_op( OP_AND, ADDR_MODE_REGISTER, dest, 0xFFFF );
    }

  return;
  
} /* load_half_word */
  

static void
load_byte(
	  RealRegister	dest,			/* register to receivce the byte */
	  RealRegister	source,			/* register which "points to" the byte */
	  int32		offset,			/* doubles as a RealRegister */
	  bool		is_signed,		/* true if loading a signed byte */
	  bool		offset_in_register,	/* true if offset is a RealRegister */
	  bool		can_corrupt_source )	/* true if source register can be corrupted */
{
  RealRegister	src       = R_ATMP;
  bool		must_copy = FALSE;
  bool		absolute  = FALSE;
  
  
  if (source == R_SP)
    {
      if (offset_in_register)
d3920 3
a3922 11
	  /* copy stack pointer to 'src' adjusting for byte offsets */

	  out_triadic_op( OP_LSH3, src, R_SP, 2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );

	  /* add in the offset */
      
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, src, offset );

	  /* indicate that this is an absolute address */

	  absolute = TRUE;
d3926 34
a3959 4
	  int32		byte_selector;
	  int32		indirect_field;
	  int32		op;

d3961 9
a3969 32
	  byte_selector = offset & 0x3;
	  offset        = offset >> 2;			/* note assumption about sizeof_int */

	  if (offset)
	    {
	      if (!fits_in_8_bits_unsigned( abs( offset ) ))
		{
		  syserr( "load_byte: byte offset from stack pointer is too large - %d", offset * 4 );
		}

	      if (offset > 0)
		{
		  indirect_field = build_indirect( INDIRECT_PRE_ADD, R_SP, offset );
		}
	      else
		{
		  indirect_field = build_indirect( INDIRECT_PRE_SUB, R_SP, -offset );
		}
	    }
	  else
	    {
	      indirect_field = build_indirect( INDIRECT_REL, R_SP, 0 );
	    }

	  if (is_signed)
	    {
	      op = OP_LB;
	    }
	  else
	    {
	      op = OP_LBU;
	    }
d3971 3
a3973 2
	  outinstr( FUNC_LOAD << 28 | op << 24 | byte_selector << 23 | ADDR_MODE_INDIRECT << 21 |
		   hardware_register( dest ) << 16 | indirect_field );
d3975 9
a3983 10
	  return;
	}
    }
  else
    {
      /* get byte offset into 'src' */
      
      if (offset_in_register)
	{
	  /* add offset to address and place in temporary register */
d3985 5
a3989 1
	  out_triadic_op( OP_ADDI3, src, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3993 41
a4033 19
	  if (offset == 0)
	    {
	      src = source;
	      
	      if (!can_corrupt_source || !is_address_register( hardware_register( source ) ))
		{
		  must_copy = TRUE;
		}
	    }
	  else if (fits_in_8_bits( offset ))
	    {
	      out_triadic_op( OP_ADDI3, src, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
	    }
	  else
	    {
	      load_integer( R_TMP1, offset, FALSE );
	      
	      out_triadic_op( OP_ADDI3, src, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
	    }
d4036 1
a4036 51
  
  /*
   *    src    - byte offset
   *    R_TMP1 - free
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * save byte selector of address into R_TMP1
   */

  out_triadic_op( OP_AND3, R_TMP1, src, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
  
  /*
   *    src    - byte offset
   *    R_TMP1 - byte selector (0, 1, 2 or 3)
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * loose bottom two bits (byte selector) of offset
   */

  if (must_copy)
    {
      src = R_ATMP;
      
      out_triadic_op( OP_LSH3, src, source, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
    }
  else
    {
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, src, -2 );
    }

  /*
   *    src    - word offset
   *    R_TMP1 - byte selector (0, 1, 2 or 3)
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * load word into R_TMP2
   */

  if (absolute)
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_REL, src, 0 ) );
    }
  else
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, src, 0 ) );
    }
  
  if (is_signed)
d4039 5
a4043 4
       *    src    - free
       *    R_TMP1 - byte selector (0, 1, 2 or 3)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
d4045 1
a4045 1
       * invert byte selector
d4047 5
a4051 3
  
      out_diadic_op( OP_NOT, ADDR_MODE_REGISTER, R_TMP1, R_TMP1 );

d4053 5
a4057 4
       *    src    - free
       *    R_TMP1 - NOT byte selector (3, 2, 1 or 0)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
d4059 1
a4059 1
       * convert to inverted bit position
d4061 5
a4065 3
  
      out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP1, 8 );

d4067 5
a4071 4
       *    src    - free
       *    R_TMP1 - inverted bit position (24, 16, 8 or 0)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
d4073 1
a4073 1
       * shift source half-word up
d4075 5
a4079 3
  
      out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, R_TMP2, R_TMP1 );

d4081 5
a4085 4
       *    src    - free
       *    R_TMP1 - free
       *    R_TMP2 - shifted word at destination
       *    R_TMP3 - free
d4087 1
a4087 1
       * shift source half-word down and place in destination
d4089 5
a4093 5
  
      out_triadic_op( OP_ASH3, dest, R_TMP2, -24, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
    }
  else
    {
d4095 6
a4100 4
       *    src    - free
       *    R_TMP1 - byte selector (0, 1, 2 or 3)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
d4102 1
a4102 1
       * convert byte selector to negated bit_position
a4103 2

      out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP1, -8 );
d4105 1
a4105 44
      /*
       *    src    - free
       *    R_TMP1 - negate bit position (0, -8, -16 or -24)
       *    R_TMP2 - word at destination
       *    R_TMP3 - free
       *
       * shift word to correct source alignment and place in dest
       */

      out_triadic_op( OP_LSH3, dest, R_TMP2, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );

      /*
       *    src    - free
       *    R_TMP1 - free
       *    R_TMP2 - free
       *    R_TMP3 - free
       *
       * ensure destination only contains a byte
       */

      out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, dest, 0xFF );
    }

  return;
  
} /* load_byte */


static void
store_half_word(
		RealRegister	dest,			/* register which "points to" place to put half-word */
		RealRegister	source,			/* register containing the half-word */
		int32		offset,			/* doubles as a RealRegister */
		bool		offset_in_register, 	/* true if offset is a RealRegister */
		bool		can_corrupt_dest )	/* true if dest register can be corrupted */
{
  RealRegister	dst       = R_ATMP;
  bool		must_copy = FALSE;
  bool		absolute  = FALSE;
  
  
  if (dest == R_SP)
    {
      if (offset_in_register)
d4107 5
a4111 11
	  /* copy stack pointer to 'dst' adjusting for byte offsets */

	  out_triadic_op( OP_LSH3, dst, R_SP, 2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
      
	  /* add the the offset */
      
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dst, offset );

	  /* and indicate that we have an absolute address */

	  absolute = TRUE;
d4115 3
a4117 41
	  int32		half_word_selector = (offset & 0x2) >> 1;
	  int32		indirect_field;

	  
	  offset >>= 2;

	  if (offset)
	    {
	      if (!fits_in_8_bits_unsigned( abs( offset ) ))
		{
		  syserr( "store_half_word: byte offset from stack pointer is too large - %d", offset * 4 );
		}

	      if (offset > 0)
		{
		  indirect_field = build_indirect( INDIRECT_PRE_ADD, R_SP, offset );
		}
	      else
		{
		  indirect_field = build_indirect( INDIRECT_PRE_SUB, R_SP, -offset );
		}
	    }
	  else
	    {
	      indirect_field = build_indirect( INDIRECT_REL, R_SP, 0 );
	    }

	  /* get word on stack */

	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, indirect_field );

	  /* merge in half-word */

	  outinstr( FUNC_LOAD << 28 | OP_MH << 24 | half_word_selector << 23 |
		   hardware_register( R_TMP1 ) << 16 | hardware_register( source ) );

	  /* and store back onto the stack */

	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, indirect_field );

	  return;
d4119 1
a4119 3
    }
  else
    {
d4121 8
a4128 1
       * get byte offset into 'dst'
d4131 1
a4131 3
      dst = R_ATMP;
      
      if (offset_in_register)
d4133 3
a4135 3
	  /* add offset to address and place in 'dst' */
	  
	  out_triadic_op( OP_ADDI3, dst, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d4139 3
a4141 19
	  if (offset == 0)
	    {
	      dst = dest;
	      
	      if (!can_corrupt_dest || !is_address_register( hardware_register( dest ) ))
		{
		  must_copy = TRUE;
		}
	    }
	  else if (fits_in_8_bits( offset ))
	    {
	      out_triadic_op( OP_ADDI3, dst, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
	    }
	  else
	    {
	      load_integer( R_TMP1, offset, FALSE );
	      
	      out_triadic_op( OP_ADDI3, dst, dest, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
	    }
d4143 15
a4157 69
    }
  
  /*
   *    dst    - byte offset
   *    R_TMP1 - free
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * copy half-word selector to R_TMP2
   */

  out_triadic_op( OP_AND3, R_TMP2, dst, 0x2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );

  /*
   *    dst    - byte offset
   *    R_TMP1 - free
   *    R_TMP2 - half-word selector (0 or 2)
   *    R_TMP3 - free
   *
   * convert to bit-position selector
   */

  out_triadic_op( OP_MPYI3, R_TMP1, R_TMP2, 8, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );

  /*
   *    dst    - byte offset
   *    R_TMP1 - bit-position selector (0 or 16)
   *    R_TMP2 - half-word selector (0 or 2)
   *    R_TMP1 - free
   *
   * shift source to correct half-word and place in R_TMP3
   */

  out_triadic_op( OP_LSH3, R_TMP3, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );

  /*
   *    dst    - byte offset
   *    R_TMP1 - bit-position selector (0 or 16)
   *    R_TMP2 - half-word selector (0 or 2)
   *    R_TMP3 - shifted source half-word
   *
   * load half-word mask into R_TMP2
   */

  out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP2, 0xFFFF );

  /*
   *    dst    - byte offset
   *    R_TMP1 - bit-position selector (0 or 16)
   *    R_TMP2 - 0x0000FFFF
   *    R_TMP3 - shifted source half-word
   *
   * shift mask up if necessary
   */

  out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, R_TMP2, R_TMP1 );
		 
  /*
   *    dst    - byte offset
   *    R_TMP2 - free
   *    R_TMP1 - half-word mask (0x0000FFFF or 0xFFFF0000)
   *    R_TMP3 - shifted source half-word
   *
   * loose bottom two bits of byte offset (ie convert to word offset)
   */

  if (must_copy)
    {
      dst = R_ATMP;
d4159 9
a4167 88
      out_triadic_op( OP_LSH3, dst, dest, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
    }
  else
    {
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dst, -2 );
    }

  /*
   *    dst    - word offset
   *    R_TMP1 - free
   *    R_TMP2 - half-word mask (0x0000FFFF or 0xFFFF0000)
   *    R_TMP3 - shifted source half-word
   *
   * get word at destination into R_TMP1
   */

  if (absolute)
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ) );
    }
  else
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
    }

  /*
   *    dst    - word offset
   *    R_TMP1 - word at destination
   *    R_TMP2 - half-word mask (0x0000FFFF or 0xFFFF0000)
   *    R_TMP3 - shifted source half-word
   *
   * mask out unwanted half-word (using an inverted mask)
   */

  out_diadic_op( OP_ANDN, ADDR_MODE_REGISTER, R_TMP1, R_TMP2 );

  /*
   *    dst    - word offset
   *    R_TMP1 - other half of word at destination
   *    R_TMP2 - free
   *    R_TMP3 - shifted source half-word
   *
   * OR in half-word
   */

  out_diadic_op( OP_OR, ADDR_MODE_REGISTER, R_TMP1, R_TMP3 );

  /*
   *    dst    - word offset
   *    R_TMP1 - source half word plus other half of word at destination
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * and store word back in destination
   */
  
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
  
  return;
  
} /* store_half_word */
  
  
static void
store_byte(
	   RealRegister		dest,			/* register which "points to" destination of byte */
	   RealRegister		source,			/* register containing byte */
	   int32		offset,			/* offset to destination (doubles as a RealRegister) */
	   bool			offset_in_register,	/* true if offset is a RealRegister */
	   bool			can_corrupt_dest )	/* true if dest register can be corrupted */
{
  RealRegister	dst       = R_ATMP;
  bool		must_copy = FALSE;
  bool		absolute  = FALSE;
  
  
  if (dest == R_SP)
    {
      if (offset_in_register)
	{
	  /*
	   * copy stack pointer to 'dst' adjusting for byte offsets
	   *
	   * XXX - beware this might overflow if either of the top two
	   * bits of the stack pointer are set !!!
	   */

	  out_triadic_op( OP_LSH3, dst, R_SP, 2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d4169 3
a4171 1
	  /* add the offset */
a4172 53
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dst, offset );

	  /* and indicate that we have an absoluet address */

	  absolute = TRUE;
	}
      else
	{
	  int32		byte_selector = offset & 0x3;
	  int32		indirect_field;
	  
	  
	  offset >>= 2;

	  if (offset)
	    {
	      if (!fits_in_8_bits_unsigned( abs( offset ) ))
		{
		  syserr( "store_half_word: byte offset from stack pointer is too large - %d", offset * 4 );
		}

	      if (offset > 0)
		{
		  indirect_field = build_indirect( INDIRECT_PRE_ADD, R_SP, offset );
		}
	      else
		{
		  indirect_field = build_indirect( INDIRECT_PRE_SUB, R_SP, -offset );
		}
	    }
	  else
	    {
	      indirect_field = build_indirect( INDIRECT_REL, R_SP, 0 );
	    }

	  /* get word on stack */
	  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, indirect_field );

	  /* merge in byte in source */
	  
	  outinstr( FUNC_LOAD << 28 | OP_MB << 24 | byte_selector << 23 | ADDR_MODE_REGISTER << 21 |
		   hardware_register( R_TMP1 ) << 16 | hardware_register( source ) );

	  /* store word back onto stack */
	  
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, indirect_field );

	  return;
	}
    }
  else
    {
d4174 7
a4180 1
       * get byte offset into 'dst'
d4183 3
a4185 28
      if (offset_in_register)
	{
	  /* add offset to address and place in 'dst' */
	  
	  out_triadic_op( OP_ADDI3, dst, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
	}
      else
	{
	  if (offset == 0)
	    {
	      dst = dest;
	      
	      if (!can_corrupt_dest || !is_address_register( hardware_register( dest ) ))
		{
		  must_copy = TRUE;
		}
	    }
	  else if (fits_in_8_bits( offset ))
	    {
	      out_triadic_op( OP_ADDI3, dst, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
	    }
	  else
	    {
	      load_integer( R_TMP1, offset, FALSE );
	      
	      out_triadic_op( OP_ADDI3, dst, dest, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
	    }
	}
d4188 1
a4188 123
  /*
   *    dst    - byte offset
   *    R_TMP1 - free
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * copy byte selector to R_TMP2
   */

  out_triadic_op( OP_AND3, R_TMP2, dst, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );

  /*
   *    dst    - byte offset
   *    R_TMP1 - free
   *    R_TMP2 - byte selector (0, 1, 2 or 3)
   *    R_TMP3 - free
   *
   * convert to bit-position selector
   */

  out_triadic_op( OP_MPYI3, R_TMP1, R_TMP2, 8, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );

  /*
   *    dst    - byte offset
   *    R_TMP1 - bit-position selector (0, 8, 16, or 24)
   *    R_TMP2 - byte selector (0, 1, 2 or 3)
   *    R_TMP1 - free
   *
   * shift source to correct byte and place in R_TMP3
   */

  out_triadic_op( OP_LSH3, R_TMP3, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );

  /*
   *    dst    - byte offset
   *    R_TMP1 - bit-position selector (0, 8, 16 or 24)
   *    R_TMP2 - byte selector (0, 1, 2 or 3)
   *    R_TMP3 - shifted source byte
   *
   * load byte mask into R_TMP2
   */

  out_diadic_op( OP_LDI, ADDR_MODE_IMMEDIATE, R_TMP2, 0xFF );

  /*
   *    dst    - byte offset
   *    R_TMP1 - bit-position selector (0, 8, 16 or 24)
   *    R_TMP2 - 0x000000FF
   *    R_TMP3 - shifted source byte
   *
   * shift mask to byte position
   */

  out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, R_TMP2, R_TMP1 );
		 
  /*
   *    dst    - byte offset
   *    R_TMP1 - free
   *    R_TMP2 - 0xFFFFFF00 or 0xFFFF00FF or 0xFF00FFFF or 0x00FFFFFF
   *    R_TMP3 - shifted source byte
   *
   * loose bottom two bits of byte offset (ie convert to word offset)
   */

  if (must_copy)
    {
      dst = R_ATMP;
      
      out_triadic_op( OP_LSH3, dst, dest, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
    }
  else
    {
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dst, -2 );
    }

  /*
   *    dst    - word offset
   *    R_TMP1 - free
   *    R_TMP2 - 0xFFFFFF00 or 0xFFFF00FF or 0xFF00FFFF or 0x00FFFFFF
   *    R_TMP3 - shifted source byte
   *
   * get word at destination into R_TMP1
   */

  if (absolute)
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_REL, dst, 0 ) );
    }
  else
    {
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
    }

  /*
   *    dst    - word offset
   *    R_TMP1 - word at destination
   *    R_TMP2 - 0xFFFFFF00 or 0xFFFF00FF or 0xFF00FFFF or 0x00FFFFFF
   *    R_TMP3 - shifted source byte
   *
   * mask out unwanted bytem (using inverted mask)
   */

  out_diadic_op( OP_ANDN, ADDR_MODE_REGISTER, R_TMP1, R_TMP2 );

  /*
   *    dst    - word offset
   *    R_TMP1 - other bytes of destination
   *    R_TMP2 - free
   *    R_TMP3 - shifted source byte
   *
   * OR in source byte
   */

  out_diadic_op( OP_OR, ADDR_MODE_REGISTER, R_TMP1, R_TMP3 );

  /*
   *    dst    - word offset
   *    R_TMP1 - new source word
   *    R_TMP2 - free
   *    R_TMP3 - free
   *
   * and store word back in destination
   */
d4190 1
a4190 1
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
a4191 4
  return;
      
} /* store_byte */

d4201 7
a4207 3
  out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, reg, RR_IR0 );

  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, reg, 2 );
d4398 7
a4404 4
      outinstr( (OP_LAJcr << 24) | 0x1L << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( mr ) );
      outinstr( OP_NOP << 23 );
      outinstr( OP_NOP << 23 );
      outinstr( OP_NOP << 23 );
d4415 7
a4421 4
      outinstr( (OP_BRcrD << 24) | 0x1L << 21 | C_FROMQ( Q_AL ) << 16 | hardware_register( mr ) );
      outinstr( OP_NOP << 23 );
      outinstr( OP_NOP << 23 );
      outinstr( OP_NOP << 23 );
a4518 2
      fprintf( stderr, "WARNING: J_CASEBRANCH has not yet been implemented\n" );
      
d4527 37
a4563 1
      fprintf( stderr, "WARNING: J_BXX has not yet been implemented\n" );
d4565 65
d4681 3
a4683 1
      out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, r2r, mr );
d4719 3
a4721 1
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, r1r, mr );
d4732 3
a4734 1
      out_diadic_op( OP_NOT, ADDR_MODE_REGISTER, r1r, mr );
d4973 3
a4975 1
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, r1r, mr );
d4979 3
a4981 1
      out_triadic_op( OP_ASH3, r1r, r2r, r1r, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d4994 3
a4996 1
      out_diadic_op( OP_NEGI, ADDR_MODE_REGISTER, r1r, mr );
d5000 3
a5002 1
      out_triadic_op( OP_LSH3, r1r, r2r, r1r, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d5026 1
a5026 1
      load_half_word( r1r, r2r, m, opm == J_LDRWK + J_SIGNED, FALSE, dead & J_DEAD_R2 );
d5038 1
a5038 1
      load_byte( r1r, r2r, m, opm == J_LDRBK + J_SIGNED, FALSE, dead & J_DEAD_R2 );
d5059 1
a5059 1
      store_half_word( r2r, r1r, m, FALSE, dead & J_DEAD_R2 );
d5069 1
a5069 1
      store_byte( r2r, r1r, m, FALSE, dead & J_DEAD_R2 );
d5091 1
a5091 1
      load_half_word( r1r, r2r, mr, opm == J_LDRWR + J_SIGNED, TRUE, dead & J_DEAD_R2 );
d5103 1
a5103 1
      load_byte( r1r, r2r, mr, opm == J_LDRBR + J_SIGNED, TRUE, dead & J_DEAD_R2 );
d5124 1
a5124 1
      store_half_word( r2r, r1r, mr, TRUE, dead & J_DEAD_R2 );
d5135 1
a5135 1
      store_byte( r2r, r1r, mr, TRUE, dead & J_DEAD_R2 );
d5240 1
a5240 1
      outinstr( OP_NOP << 23 );		/* placeholder */
@


1.6
log
@fixed structure creation on the stack
@
text
@d640 1
a640 1
      out_conditional_load( Q_AL, ADDR_MODE_REGISTER, dest, source );
d691 1
a691 1
	  /* this instruction is 1 cycle faster than conditional load */
d697 1
a697 1
	  /* 16 bit signed immediate  - use conditional load to avoid setting status bits */
d699 1
a699 1
	  out_conditional_load( Q_AL, ADDR_MODE_IMMEDIATE, r, n );
d720 2
a721 3
	   * not have a temporary register available, so we cannot
	   * easily save the contents of the status register in another
	   * register, instead we must save it on the stack *sigh*
d724 1
a724 1
	  /* save ST onto stack */
d726 1
a726 1
	  push( RR_ST );
d739 1
a739 1
	  /* restore ST from stack */
d741 1
a741 1
	  pop( RR_ST );
d877 1
a877 1
      /* add in the stack pointer */
d1206 1
a1206 1
 * We are using an ascending, full stack ...
a1208 1
 *
d1772 1
a1772 1
      return (off - stack_offset - stack_move);
d1994 2
a1995 1
	     int32		length )
d1998 2
a1999 1

a2013 1
   * NB/ we might corrupt start register
d2016 3
a2018 1
  /* get start address into a temporary address register */
d2020 8
a2027 1
  move_register( start, R_ATMP );
d2047 1
a2047 1
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );
d2051 2
a2052 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );      
a2057 2
      move_register( start, R_ATMP );
      
d2059 1
a2059 1
      out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT,  R_R0, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );
d2075 1
a2075 1
      out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_R0, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );
d2087 1
a2087 1
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2095 1
a2095 1
	  out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2101 1
a2101 1
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2109 1
a2109 1
	  out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2115 1
a2115 1
	  /* load top byte of *ar into bottom byte of R_TMP1 (no sign extension) */
d2118 1
a2118 1
		   hardware_register( R_TMP1 ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2126 1
a2126 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2149 3
a2151 1
	    int32		length )
a2161 4
   * NB/ This code might corrupt source &/or dest registers
   */
    
  /*
d2165 1
a2165 1
  if (!is_address_register( hardware_register( source ) ))
d2172 1
a2172 1
  if (!is_address_register( hardware_register( dest )))
d2182 2
d2226 1
a2226 1
  else if (fits_in_16_bits_unsigned( (length - 1) / sizeof_int ))
d2228 1
a2228 1
      /* load first word */
d2230 1
a2230 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ATMP, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
d2232 1
a2232 1
      /* use repeat single instruction mode, loaded from immediate */
d2234 1
a2234 1
      out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC,  (length - 1) / sizeof_int );
d2236 1
a2236 1
      /* instruction repeated is LDI || STI */
d2238 3
a2240 4
      outinstr( B_1101 << 28 | B_1010 << 24 |
	       hardware_register( R_ATMP ) << 22 | hardware_register( R_ATMP ) << 16 |
	       build_parallel_indirect( INDIRECT_POST_INCR_IR0, dest ) << 8 |
	       build_parallel_indirect( INDIRECT_POST_INCR_IR0, source ) );
d2242 5
a2246 11
      /* save last word */
      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_ATMP, build_indirect( INDIRECT_POST_INCR_IR0, dest, 0 ) );
    }  
  else
    {
      /* load first word */

      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_ATMP, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
      
      /* load repeat count with length - 1 */
d2248 1
a2248 1
      load_integer( RR_RC, (length - 1) / sizeof_int, FALSE );
d2250 1
a2250 1
       /* XXX load RC from itself ! - WILL THIS WORK ? */
d2252 2
a2253 1
      out_diadic_op( OP_RPTS, ADDR_MODE_REGISTER, RR_RC, RR_RC );
d2258 1
a2258 1
	       hardware_register( R_ATMP ) << 22 | hardware_register( R_ATMP ) << 16 |
d2264 6
a2269 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_ATMP, build_indirect( INDIRECT_POST_INCR_IR0, dest, 0 ) );
    }
d2427 2
d2433 2
d2439 3
a2441 1
  syserr( syserr_data_sym, dext->extoffset );
d2621 2
a2622 1
      syserr( "warning: trying to load an address constant into a non-address register\n" );
d3301 3
a3303 3
	   int32	which_byte,
	   RealRegister	destination,
	   RealRegister	source )
d3322 1
a3322 1
	       bool		can_corrupt_source)	/* true if source register can be corrupted */
d3383 1
a3383 1

d3392 2
a3393 2
      /* get the byte offset into 'src' */

d3434 1
a3434 1
	  
d3595 1
a3596 1

d3598 1
a3598 1
	  offset      >>= 2;			/* note assumption about sizeof_int */
d3680 1
a3680 1

d3827 1
a3827 1
	  /* add in the offset */
d4075 1
a4075 1
	  /* add in the offset */
d4445 1
a4445 1
      clear_memory( r1r, m );
d4455 1
a4455 1
      copy_memory( r2r, r1r, m );
@


1.5
log
@improved store and load byte and half-word
@
text
@d776 1
a776 1
	  if (!fits_in_8_bits_unsigned( offset ))
d928 1
a928 1
  int32	move = stack_move & (- (sizeof_int * 2)); /* keep stack double-word aligned */
d935 1
a935 1
  move /= sizeof_int;
d945 1
a945 1
	  out_diadic_op( OP_SUBI, ADDR_MODE_IMMEDIATE, R_SP, move );
d953 1
a953 1
	  out_triadic_op( OP_SUBI3, R_SP, R_SP, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d956 1
a956 1
      move *= - sizeof_int;
a958 1
      stack_offset += move;
d1771 2
d3313 3
a3315 2
  RealRegister	src;
  bool		must_copy;
d3322 1
a3322 1
	  /* copy offset to temporary register adjusting for word offsets */
d3324 1
a3324 1
	  out_triadic_op( OP_LSH3, R_ATMP, offset, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3326 1
a3326 1
	  /* add in the stack pointer */
d3328 1
a3328 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_SP );
d3330 1
a3330 1
	  /* and load word */
d3332 1
a3332 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, R_ATMP, 0 ) );
d3336 6
a3341 1
	  offset /= sizeof_int;
d3345 1
a3345 1
	      if (!fits_in_8_bits_unsigned( offset ))
d3352 1
a3352 1
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD, R_SP, offset ) );
d3356 1
a3356 1
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_SUB, R_SP, -offset ) );
d3361 1
a3361 1
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, R_SP, 0 ) );
a3362 1
	}
d3364 8
a3371 1
      /* we will only ever want the bottom half-word off the stack */
d3373 5
a3377 16
      out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, dest, 0xFFFF );
      
      return;
    }
  

  /* get the byte offset into 'src' */

  src       = R_ATMP;
  must_copy = FALSE;
  
  if (offset_in_register)
    {
      /* add offset to address and place in temporary register */

      out_triadic_op( OP_ADDI3, src, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3381 1
a3381 3
      if (offset == 0)
	{
	  src = source;
d3383 1
a3383 6
	  if (!can_corrupt_source || !is_address_register( hardware_register( source ) ))
	    {
	      must_copy = TRUE;
	    }
	}
      else if (fits_in_8_bits( offset ))
d3385 3
a3387 1
	  out_triadic_op( OP_ADDI3, src, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3391 19
a3409 3
	  load_integer( R_TMP1, offset, FALSE );
	  
	  out_triadic_op( OP_ADDI3, src, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3412 1
a3412 1

d3452 9
a3460 2
  
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, src, 0 ) );
d3558 3
a3560 2
  RealRegister	src;
  bool		must_copy;
d3567 1
a3567 1
	  /* copy offset to temporary register adjusting for word offsets */
d3569 1
a3569 1
	  out_triadic_op( OP_LSH3, R_ATMP, offset, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3571 1
a3571 1
	  /* add in the stack pointer */
d3573 1
a3573 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_SP );
d3575 1
a3575 1
	  /* and perform load word */
d3577 1
a3577 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, R_ATMP, 0 ) );
d3581 4
a3584 1
	  offset /= sizeof_int;
d3586 3
d3591 1
a3591 1
	      if (!fits_in_8_bits_unsigned( offset ))
d3598 1
a3598 1
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD, R_SP, offset ) );
d3602 1
a3602 1
		  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_SUB, R_SP, -offset ) );
d3607 10
a3616 1
	      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, R_SP, 0 ) );
d3618 5
a3623 15

      /* we will only ever want the bottom byte off the stack */

      out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, dest, 0xFF );
      
      return;
    }
  
  /* get byte offset into 'src' */

  if (offset_in_register)
    {
      /* add offset to address and place in temporary register */

      out_triadic_op( OP_ADDI3, src, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3627 3
a3629 1
      if (offset == 0)
d3631 3
a3633 10
	  src = source;

	  if (!can_corrupt_source || !is_address_register( hardware_register( source ) ))
	    {
	      must_copy = TRUE;
	    }
	}
      else if (fits_in_8_bits( offset ))
	{
	  out_triadic_op( OP_ADDI3, src, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3637 19
a3655 3
	  load_integer( R_TMP1, offset, FALSE );
	  
	  out_triadic_op( OP_ADDI3, src, source, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3658 1
a3658 1

d3698 9
a3706 2
  
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, src, 0 ) );
d3803 1
a3803 1
  RealRegister	dst;
d3805 1
d3812 1
a3812 1
	  /* copy offset to temporary register adjusting for word offsets */
d3814 1
a3814 1
	  out_triadic_op( OP_LSH3, R_ATMP, offset, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3816 1
a3816 1
	  /* add in the stack pointer */
d3818 1
a3818 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_SP );
d3820 1
a3820 1
	  /* and store word */
d3822 1
a3822 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_REL, R_ATMP, 0 ) );
d3826 5
a3830 1
	  offset /= sizeof_int;
d3834 1
a3834 1
	      if (!fits_in_8_bits_unsigned( offset ))
d3841 1
a3841 1
		  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD, R_SP, offset ) );
d3845 1
a3845 1
		  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_SUB, R_SP, -offset ) );
d3850 1
a3850 1
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, R_SP, 0 ) );
d3852 9
a3860 1
	}
d3862 1
a3862 6
      return;
    }
  
  /*
   * get byte offset into 'dst'
   */
d3864 1
a3864 5
  dst = R_ATMP;
  
  if (offset_in_register)
    {
      /* add offset to address and place in 'dst' */
d3866 2
a3867 1
      out_triadic_op( OP_ADDI3, dst, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3871 7
a3877 1
      if (offset == 0)
d3879 3
a3881 6
	  dst = dest;

	  if (!can_corrupt_dest || !is_address_register( hardware_register( dest ) ))
	    {
	      must_copy = TRUE;
	    }
a3882 4
      else if (fits_in_8_bits( offset ))
	{
	  out_triadic_op( OP_ADDI3, dst, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
	}
d3885 19
a3903 3
	  load_integer( R_TMP1, offset, FALSE );
	  
	  out_triadic_op( OP_ADDI3, dst, dest, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3990 9
a3998 2
  
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d4044 1
a4044 2
	   bool			can_corrupt_dest,	/* true if dest register can be corrupted */
	   bool			can_corrupt_source )	/* true if source register can be corrupted */
d4046 1
a4046 1
  RealRegister	dst;
d4048 1
a4052 2
      /* we only ever stores words on the stack */
      
d4055 6
a4060 1
	  /* copy offset to temporary register adjusting for word offsets */
d4062 1
a4062 1
	  out_triadic_op( OP_LSH3, R_ATMP, offset, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d4064 1
a4064 1
	  /* add in the stack pointer */
d4066 1
a4066 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, R_SP );
d4068 1
a4068 1
	  /* and store word */
d4070 1
a4070 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_REL, R_ATMP, 0 ) );
d4074 5
a4078 1
	  offset /= sizeof_int;
d4082 1
a4082 1
	      if (!fits_in_8_bits_unsigned( offset ))
d4089 1
a4089 1
		  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD, R_SP, offset ) );
d4093 1
a4093 1
		  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_SUB, R_SP, -offset ) );
d4098 1
a4098 1
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_REL, R_SP, 0 ) );
d4100 4
a4103 1
	}
d4105 4
a4108 6
      return;
    }
  
  /*
   * get byte offset into 'dst'
   */
d4110 3
a4112 5
  dst = R_ATMP;
  
  if (offset_in_register)
    {
      /* add offset to address and place in 'dst' */
d4114 2
a4115 1
      out_triadic_op( OP_ADDI3, dst, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d4119 5
a4123 1
      if (offset == 0)
d4125 3
a4127 10
	  dst = dest;

	  if (!can_corrupt_dest || !is_address_register( hardware_register( dest ) ))
	    {
	      must_copy = TRUE;
	    }
	}
      else if (fits_in_8_bits( offset ))
	{
	  out_triadic_op( OP_ADDI3, dst, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d4131 19
a4149 3
	  load_integer( R_TMP1, offset, FALSE );
	  
	  out_triadic_op( OP_ADDI3, dst, dest, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d4236 9
a4244 2
  
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP1, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d4285 17
d4625 1
d4647 1
a4647 2

	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, R_SP, diff / sizeof_int );
d4760 5
d4774 13
a4786 1
      immediate_op( OP_ADDI, OP_ADDI3, r1r, r2r, m );
d4851 5
d4867 5
d5037 1
a5037 1
      store_byte( r2r, r1r, m, FALSE, dead & J_DEAD_R2, dead & J_DEAD_R1 );
d5103 1
a5103 1
      store_byte( r2r, r1r, mr, TRUE, dead & J_DEAD_R2, dead & J_DEAD_R1 );
d5151 2
d5161 2
@


1.4
log
@improved half-word store routine
@
text
@d3312 55
a3366 1
  /* get word into 'dest' */
d3368 3
d3373 52
a3424 1
      out_register_offset( OP_LDI, dest, source, offset );
d3428 1
a3428 1
      out_immediate_offset( OP_LDI, dest, source, offset, can_corrupt_source );
d3430 9
d3440 1
a3440 1
  /* test to see iff second bit of 'source' is set */
d3442 10
a3451 1
  out_triadic_op( OP_AND3, R_ATMP, source, 0x2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3453 10
a3462 1
  /* skip shift up if second bit set */
d3464 1
a3464 1
  conditional_skip_instructions( Q_EQ, 1 );
d3466 8
a3473 1
  /* shift bottom half word up two bytes */
d3475 10
a3484 1
  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dest, 16 );
d3486 1
a3486 5
  /* shift top half-word down by two bytes */
  
  if (is_signed)
    {
      out_diadic_op( OP_ASH, ADDR_MODE_IMMEDIATE, dest, -16 );
d3490 32
a3521 1
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dest, -16 );
d3538 5
a3542 3
  /* get word into 'dest' */

  if (offset_in_register)
d3544 1
a3544 1
      if (source == R_SP)
a3556 8

	  /* we will only ever want the bottom byte off the stack */

	  out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, dest, 0xFF );

	  /* finished */
	  
	  return;
a3559 28
	  /* add offset to address and place in temporary register */

	  out_triadic_op( OP_ADDI3, R_ATMP, source, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );

	  /* save bottom two bits of address in temporary register */

	  out_triadic_op( OP_AND3, R_TMP1, R_ATMP, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
	  
	  /* loose bottom two bits (byte selector) */

	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2 );

	  /* load word */
  
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );

	  /* carry on to byte extracting code below */
	}
    }
  else
    {
      if (source == R_SP)
	{
	  /*
	   * the stack pointer is always a word pointer
	   * so no special adjustments should be necessary
	   */

d3582 3
d3586 6
a3591 1
	  /* we will only ever want the bottom byte off the stack */
d3593 3
a3595 1
	  out_diadic_op( OP_AND, ADDR_MODE_IMMEDIATE, dest, 0xFF );
d3597 5
a3601 5
	  /* finished */
	  
	  return;
	}
      else if (can_corrupt_source && is_address_register( hardware_register( source ) ))
d3603 3
a3605 1
	  if (offset == 0)
d3607 1
a3607 1
	      ;	/* do nothing */
d3609 4
a3612 22
	  else if (fits_in_16_bits( offset ))
	    {
	      out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, source, offset );
	    }
	  else
	    {
	      load_integer( R_TMP1, offset, FALSE );
	      
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, source, R_TMP1 );
	    }
	  
	  /* save bottom two bits of address in temporary register */

	  out_triadic_op( OP_AND3, R_TMP1, source, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );

	  /* remove byte selector from address */
	  
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, source, -2 );
	  
	  /* load the word */
      
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ) );
d3616 5
a3620 2
	  /* put address in temporary register */
  
d3622 8
a3629 3
	  if (offset == 0)
	    {
	      /* save bottom two bits of address in temporary register */
d3631 1
a3631 1
	      out_triadic_op( OP_AND3, R_TMP1, source, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3633 8
a3640 1
	      /* divide by address by sizeof_int (here assumed to be 4) and place in temporary */
d3642 3
a3644 22
	      out_triadic_op( OP_LSH3, R_ATMP, source, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
	    }
	  else
	    {
	      /* get offset into temporary address register */
	      
	      load_integer( R_ATMP, offset, FALSE );

	      /* add the offset and source together */
	      
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, R_ATMP, source );

	      /* save bottom two bits of address in temporary register */

	      out_triadic_op( OP_AND3, R_TMP1, R_ATMP, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );

	      /* divide by sizeof_int (here assumed to be 4) */

	      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2 );
	    }
	  
	  /* send the operation */
d3646 5
a3650 2
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
	}
d3654 6
a3659 2
   * the code to load the word has conspired to leave
   * the bottom two bits of 'byte_offset' in R_TMP1
d3661 3
a3663 1
      
d3667 4
a3670 3
       * get bottom two bits of address into R_TMP1
       * and subtract from 3 in order to convert into
       * 'numer of bytes from top of word'
d3672 1
a3672 6
       *   before         after
       *   ------         -----
       *  00000000       00000011
       *  00000001       00000010
       *  00000010       00000001
       *  00000011       00000000
d3674 2
d3678 6
a3683 1
       * invert bottom two bits of 'R_TMP1'
d3685 2
d3688 10
a3697 1
      out_diadic_op( OP_XOR, ADDR_MODE_IMMEDIATE, R_TMP1, 0x3 );
d3699 10
a3708 11
      /* convert to number of bytes */

      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP1, 3 );
      
      /* shift 'dest' up by number of bytes in R_TMP1 */

      out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, dest, R_TMP1 );
      
      /* shift down by 24 to get into bottom byte */
      
      out_diadic_op( OP_ASH, ADDR_MODE_IMMEDIATE, dest, -24 );
d3712 8
a3719 1
      /* convert byte selector to byte number */
d3723 8
a3730 1
      /* shift 'dest' down by number of bytes selector */
d3732 1
a3732 1
      out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, dest, R_TMP1 );
d3734 8
a3741 1
      /* mask out top bytes - XXX is this necessary ? */
d3760 2
a3761 1

d3809 1
a3809 1
   * get byte offset into R_ATMP
d3824 3
a3826 5
	  if (can_corrupt_dest && is_address_register( hardware_register( dest ) ))
	    {
	      dst = dest;
	    }
	  else
d3828 1
a3828 1
	      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_ATMP, dest );
d3843 8
a3850 1
  /* copy half-word selector to R_TMP2 */
d3854 10
a3863 1
  /* convert to bit-position selector selector */
d3865 8
a3872 1
  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP2, 8 );
d3874 1
a3874 1
  /* shift source to correct half-word and place in R_TMP3 */
d3876 8
a3883 1
  out_triadic_op( OP_LSH3, R_TMP3, source, R_TMP2, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3885 1
a3885 1
  /* load half-word mask into R_TMP1 */
d3887 8
a3894 3
  out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP1, 0xFFFF );
  
  /* shift mask down if necessary */
d3896 1
a3896 1
  out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, R_TMP1, R_TMP2 );
d3898 8
a3905 1
  /* loose bottom two bits of byte offset (ie convert to word offset) */
d3907 10
a3916 1
  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, dst, -2 );
d3918 8
a3925 1
  /* get word at destination into R_TMP2 */
d3927 1
a3927 1
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d3929 8
a3936 1
  /* mask out unwanted half-word */
d3938 1
a3938 1
  out_diadic_op( OP_AND, ADDR_MODE_REGISTER, R_TMP2, R_TMP1 );
d3940 8
a3947 1
  /* OR in half-word */
d3949 1
a3949 1
  out_diadic_op( OP_OR, ADDR_MODE_REGISTER, R_TMP2, R_TMP3 );
d3951 8
a3958 1
  /* and store word back in destination */
d3960 1
a3960 1
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP2, build_indirect( INDIRECT_PRE_ADD_IR0, dst, 0 ) );
d3976 4
d3982 1
a3982 1
      /* we only ever store 'words' on the stack */
d3987 1
a3987 1
	  
d3989 1
a3989 1

d3994 1
a3994 1
	  /* and store 'byte' */
d4006 1
a4006 1
		  syserr( "store_byte: byte offset from stack pointer is too large - %d", offset * 4 );
d4011 1
a4011 1
		  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_PRE_ADD, R_SP, offset ) );
d4015 1
a4015 1
		  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_PRE_SUB, R_SP, -offset ) );
d4020 1
a4020 1
	      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, source, build_indirect( INDIRECT_REL, R_SP, 0 ) );
d4028 1
a4028 5
   * step 1
   *
   * a. calculate destination address
   * b. get byte selector into R_TMP1
   * c. get word offset into R_ATMP
d4031 1
a4031 6
  if (!can_corrupt_dest)
    {
      /* save 'dest' in repeat end register ! */
      
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_TMP2, dest );
    }
d4035 3
a4037 11
      /* add offset to address and place into R_ATMP */
      
      out_triadic_op( OP_ADDI3, R_ATMP, dest, offset, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
      
      /* copy bottom two bits (byte selector) into R_TMP1 */
      
      out_triadic_op( OP_AND3, R_TMP1, R_ATMP, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
      
      /* loose bottom two bits (byte selector) */
      
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_ATMP, -2 );
d4043 6
a4048 1
	  ;	/* do nothing */
d4050 1
a4050 1
      else if (fits_in_16_bits( offset ))
d4052 1
a4052 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_IMMEDIATE, dest, offset );
d4058 1
a4058 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP1 );
a4059 8
      
      /* save bottom two bits of address in temporary register */
      
      out_triadic_op( OP_AND3, R_TMP1, dest, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
      
      /* remove byte selector from address and place resultant into R_ATMP */
      
      out_triadic_op( OP_LSH3, R_ATMP, dest, -2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );	  
d4063 37
a4099 1
   * part 2
d4101 10
a4110 1
   * at this point ...
d4112 10
a4121 3
   * R_TMP1  - contains byte selector
   * R_ATMP - contains word offset
   * dest   - is free
d4123 1
a4123 5
   * a. move byte to correct byte position
   * b. build a mask to remove that byte from destination word
   * c. load destination word
   * d. insert byte
   * e. store composite word
d4125 2
a4126 6
  
  /* convert 'byte selector' into 'byte number' */
  
  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP1, 8 );		/* 8 == number of bits in a byte */
  
  if (!can_corrupt_source)
d4128 1
a4128 1
      /* save source byte in repeat count register! */
d4130 1
a4130 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, R_TMP3, source );
d4132 1
a4132 30
  
  /* shift source byte to correct position */
  
  out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, source, R_TMP1 );
  
  /* load 'dest' with an inverted byte mask */
  
  out_diadic_op( OP_NOT, ADDR_MODE_IMMEDIATE, dest, 0xFF );
  
  /* shift inverted byte mask to correct position and place in R_TMP1 */
  
  out_triadic_op( OP_LSH3, R_TMP1, dest, R_TMP1, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
  
  /* load word at destination */
  
  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
  
  /* mask out byte to be stored */
  
  out_diadic_op( OP_AND, ADDR_MODE_REGISTER, dest, R_TMP1 );
  
  /* OR in byte to be saved */
  
  out_diadic_op( OP_OR, ADDR_MODE_REGISTER, dest, source );
  
  /* save resultant word */
  
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, dest, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
  
  if (!can_corrupt_source)
d4134 1
a4134 3
      /* restore source byte from repeat count register! */
      
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, source, R_TMP3 );
d4136 42
d4179 1
a4179 6
  if (!can_corrupt_dest)
    {
      /* restore 'dest' from repeat end register ! */
      
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, R_TMP2 );
    }
@


1.3
log
@applied changes indicated by change in register scheme in target.h
@
text
@d773 1
a773 1

d776 13
a788 1
	  out_diadic_op( op, ADDR_MODE_INDIRECT, dst, build_indirect( INDIRECT_PRE_ADD, R_SP, offset ) );
a796 3
      int32		source;
  

a802 2
      source = build_indirect( INDIRECT_PRE_ADD_IR0, src, 0 );
      
d820 1
a820 1
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, source );
a823 3
      int32		source;
  

a833 2
      source = build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 );
      
d851 1
a851 1
      out_diadic_op( op, ADDR_MODE_INDIRECT, dst, source );
d3582 51
a3632 1
  /* get contents of dest into R_TMP1 */
d3634 2
d3638 3
a3640 1
      out_register_offset( OP_LDI, R_TMP1, dest, offset );
d3644 21
a3664 1
      out_immediate_offset( OP_LDI, R_TMP1, dest, offset, FALSE );
d3667 15
a3681 1
  /* test to see iff second bit of dest is set */
d3683 9
a3691 3
  out_triadic_op( OP_AND3, R_ATMP, dest, 0x2, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
  
  /* if it is ... */
d3693 1
a3693 3
  conditional_skip_instructions( Q_NE, 2 );
  
  /* ... merge the contents of source with upper half of TMP */
d3695 1
a3695 6
  outinstr( FUNC_LOAD << 28 | OP_MH << 24 | 0x1 << 23 | ADDR_MODE_REGISTER << 21 |
	   hardware_register( R_TMP1 ) << 16 | hardware_register( source ) );
      
  /* and skip next instruction */
      
  conditional_skip_instructions( Q_AL, 1 );
d3697 1
a3697 4
  /* ... otherwise merge with bottom half of R_TMP1 */
      
  outinstr( FUNC_LOAD << 28 | OP_MH << 24 | 0x0 << 23 | ADDR_MODE_REGISTER << 21 |
	   hardware_register( R_TMP1 ) << 16 | hardware_register( source ) );
d3699 1
a3699 1
  /* then save R_TMP1 to dest */
d3701 1
a3701 8
  if (offset_in_register)
    {
      out_register_offset( OP_STI, R_TMP1, dest, offset );
    }
  else
    {
      out_immediate_offset( OP_STI, R_TMP1, dest, offset, can_corrupt_dest );
    }
d3703 4
@


1.2
log
@changed R_TMP to be a repeat engine register ....
@
text
@d949 1
a949 1
	  load_integer( R_TMP, move, FALSE );
d951 1
a951 1
	  out_triadic_op( OP_SUBI3, R_SP, R_SP, R_TMP, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d987 1
a987 1
      load_integer( R_TMP, n, FALSE );
d989 1
a989 1
      out_diadic_op( OP_CMPI, ADDR_MODE_REGISTER, R_TMP, r );
d1125 1
a1125 1
      load_integer( R_TMP, val, FALSE );
d1130 1
a1130 1
		     R_TMP,
d2078 1
a2078 1
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2082 1
a2082 1
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, R_TMP, 0xFF );
d2086 1
a2086 1
	  out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2092 1
a2092 1
	  out_diadic_op( OP_LDI,  ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2096 1
a2096 1
	  out_diadic_op( OP_ANDN, ADDR_MODE_IMMEDIATE, R_TMP, 0xFFFF );
d2100 1
a2100 1
	  out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2104 1
a2104 1
	  /* this instruction is load unsigned byte from address in ar into R_TMP, ie LBU3 *AR, R_TMP */
d2106 1
a2106 1
	  /* load top byte of *ar into bottom byte of R_TMP (no sign extension) */
d2109 1
a2109 1
		   hardware_register( R_TMP ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2113 1
a2113 1
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP, 24 );
d2117 1
a2117 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, R_ATMP, 0 ) );
d2199 2
a2200 2
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ) );
d2212 4
a2215 4
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ) );
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, dest,   0 ) );
d2271 1
a2271 1
	  /* get the word at 'dest' into R_TMP */
d2273 1
a2273 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2275 1
a2275 1
	  /* merge bottom byte at 'source' into R_TMP */
d2278 1
a2278 1
		   hardware_register( R_TMP ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ) );
d2282 1
a2282 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2287 1
a2287 1
	  /* get the word at 'dest' into R_TMP */
d2289 1
a2289 1
	  out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2291 1
a2291 1
	  /* merge bottom half-word at 'source' into R_TMP */
d2294 1
a2294 1
		   hardware_register( R_TMP ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, source, 0 ) );
d2298 1
a2298 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2303 1
a2303 1
	  /* get the top byte at 'dest' into bottom byte of R_TMP */
d2306 1
a2306 1
		   hardware_register( R_TMP ) << 16 | build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2310 1
a2310 1
	  out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP, 24 );
d2320 1
a2320 1
	  /* load contents of 'source' into R_TMP right shifted by 1 byte and merged with the top byte of R_TMP */
d2323 1
a2323 1
		   hardware_register( R_TMP ) << 16 | source );
d2325 1
a2325 1
	  /* store R_TMP into 'dest' */
d2327 1
a2327 1
	  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_PRE_ADD_IR0, dest, 0 ) );
d2372 1
a2372 1
      load_integer( R_TMP, value, FALSE );
d2374 1
a2374 1
      out_triadic_op( triadic_op, dest, source, R_TMP, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d2650 1
a2650 1
       * load R_TMP with the high part offset of 'symbol' into the data table
d2655 1
a2655 1
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP, 0 );
d2658 1
a2658 1
       * load R_TMP with the low part offset of 'symbol' into the data table
d2663 1
a2663 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP, 0 );
d2666 1
a2666 1
       * and add R_TMP into dest
d2669 1
a2669 1
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP );
d2709 1
a2709 1
      out_diadic_op( OP_POP, ADDR_MODE_IMMEDIATE, R_TMP, 0 );
d2732 1
a2732 1
      out_triadic_op( OP_ADDI3, dest, R_TMP, R_ATMP, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER ); 
d2856 3
a2858 3
       *   LDHI byte_offset >> 16, R_TMP
       *   OR   byte_offset, R_TMP
       *   ADDI R_TMP, dest
d2864 3
a2866 3
       *   LDHI byte_offset >> 16, R_TMP
       *   OR   byte_offset, R_TMP
       *   ADDI R_TMP, dest
d2900 1
a2900 1
       * load R_TMP with the high part offset of 'name' into the data table
d2905 1
a2905 1
      out_diadic_op( OP_LDHI, ADDR_MODE_IMMEDIATE, R_TMP, 0 );
d2908 1
a2908 1
       * load R_TMP with the low part offset of 'name' into the data table
d2913 1
a2913 1
      out_diadic_op( OP_OR, ADDR_MODE_IMMEDIATE, R_TMP, 0 );
d2916 1
a2916 1
       * and add R_TMP into dest
d2919 1
a2919 1
      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP );
d3100 1
a3100 1
   * and place the result in R_TMP
d3105 1
a3105 1
      out_triadic_op( OP_SUBI3, R_TMP, R_ADDR1, offset, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3109 1
a3109 1
      load_integer( R_TMP, offset, FALSE );
d3111 1
a3111 1
      out_diadic_op( OP_SUBI, ADDR_MODE_REGISTER, R_TMP, R_ADDR1 );
d3119 1
a3119 1
  out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR, dest, 0 ) );
d3392 1
a3392 1
	  out_triadic_op( OP_AND3, R_TMP, R_ATMP, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3457 1
a3457 1
	      load_integer( R_TMP, offset, FALSE );
d3459 1
a3459 1
	      out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, source, R_TMP );
d3464 1
a3464 1
	  out_triadic_op( OP_AND3, R_TMP, source, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3483 1
a3483 1
	      out_triadic_op( OP_AND3, R_TMP, source, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3501 1
a3501 1
	      out_triadic_op( OP_AND3, R_TMP, R_ATMP, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3516 1
a3516 1
   * the bottom two bits of 'byte_offset' in R_TMP
d3522 1
a3522 1
       * get bottom two bits of address into R_TMP
d3535 1
a3535 1
       * invert bottom two bits of 'R_TMP'
d3538 1
a3538 1
      out_diadic_op( OP_XOR, ADDR_MODE_IMMEDIATE, R_TMP, 0x3 );
d3542 1
a3542 1
      out_diadic_op( OP_LSH, ADDR_MODE_IMMEDIATE, R_TMP, 3 );
d3544 1
a3544 1
      /* shift 'dest' up by number of bytes in R_TMP */
d3546 1
a3546 1
      out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, dest, R_TMP );
d3556 1
a3556 1
      out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP, -8 );
d3560 1
a3560 1
      out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, dest, R_TMP );
d3580 1
a3580 1
  /* get contents of dest into R_TMP */
d3584 1
a3584 1
      out_register_offset( OP_LDI, R_TMP, dest, offset );
d3588 1
a3588 1
      out_immediate_offset( OP_LDI, R_TMP, dest, offset, FALSE );
d3602 1
a3602 1
	   hardware_register( R_TMP ) << 16 | hardware_register( source ) );
d3608 1
a3608 1
  /* ... otherwise merge with bottom half of R_TMP */
d3611 1
a3611 1
	   hardware_register( R_TMP ) << 16 | hardware_register( source ) );
d3613 1
a3613 1
  /* then save R_TMP to dest */
d3617 1
a3617 1
      out_register_offset( OP_STI, R_TMP, dest, offset );
d3621 1
a3621 1
      out_immediate_offset( OP_STI, R_TMP, dest, offset, can_corrupt_dest );
d3689 1
a3689 1
   * b. get byte selector into R_TMP
d3697 1
a3697 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, RR_RE, dest );
d3706 1
a3706 1
      /* copy bottom two bits (byte selector) into R_TMP */
d3708 1
a3708 1
      out_triadic_op( OP_AND3, R_TMP, R_ATMP, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3726 1
a3726 1
	  load_integer( R_TMP, offset, FALSE );
d3728 1
a3728 1
	  out_diadic_op( OP_ADDI, ADDR_MODE_REGISTER, dest, R_TMP );
d3733 1
a3733 1
      out_triadic_op( OP_AND3, R_TMP, dest, 0x3, ADDR_MODE_REGISTER, ADDR_MODE_IMMEDIATE );
d3745 1
a3745 1
   * R_TMP  - contains byte selector
d3758 1
a3758 1
  out_diadic_op( OP_MPYI, ADDR_MODE_IMMEDIATE, R_TMP, 8 );		/* 8 == number of bits in a byte */
d3764 1
a3764 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, RR_RC, source );
d3769 1
a3769 1
  out_diadic_op( OP_LSH, ADDR_MODE_REGISTER, source, R_TMP );
d3775 1
a3775 1
  /* shift inverted byte mask to correct position and place in R_TMP */
d3777 1
a3777 1
  out_triadic_op( OP_LSH3, R_TMP, dest, R_TMP, ADDR_MODE_REGISTER, ADDR_MODE_REGISTER );
d3785 1
a3785 1
  out_diadic_op( OP_AND, ADDR_MODE_REGISTER, dest, R_TMP );
d3799 1
a3799 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, source, RR_RC );
d3806 1
a3806 1
      out_diadic_op( OP_LDI, ADDR_MODE_REGISTER, dest, RR_RE );
@


1.1
log
@Initial revision
@
text
@d31 1
a31 1
 *	+ the instruction set has delayed branches (delayed for 3 instructions) and tailcall
d219 2
a220 2
      0x1b,	/* 25 =>  RC */
      0x15,	/* 26 =>  ST */
d222 1
a222 1
      0x19	/* 28 =>  RS */
a2017 4
  /* put 0 into temporary register */
      
  load_integer( R_TMP, 0, FALSE );

d2036 1
a2036 1
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );
d2040 2
a2041 2
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );      
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );      
d2049 2
a2050 2
      out_diadic_op( OP_RPTS, ADDR_MODE_IMMEDIATE, RR_RC,  length / sizeof_int );
      out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT,  R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );
d2066 1
a2066 1
      out_diadic_op( OP_STI,  ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, R_ATMP, 0 ) );
d2221 1
a2221 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
d2230 1
a2230 1
	       hardware_register( R_TMP ) << 22 | hardware_register( R_TMP ) << 16 |
d2236 1
a2236 1
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, dest, 0 ) );
d2242 1
a2242 1
      out_diadic_op( OP_LDI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, source, 0 ) );
d2255 1
a2255 1
	       hardware_register( R_TMP ) << 22 | hardware_register( R_TMP ) << 16 |
d2261 1
a2261 1
      out_diadic_op( OP_STI, ADDR_MODE_INDIRECT, R_TMP, build_indirect( INDIRECT_POST_INCR_IR0, dest, 0 ) );
d2704 1
a2704 1
       * XXX - improve sometime - use LAJ ??
d2944 1
a2944 1
   * XXX - improve sometime - use LAJ ??
@
