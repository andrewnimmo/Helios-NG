head	1.95;
access;
symbols
	beta_release:1.72;
locks; strict;
comment	@ * @;


1.95
date	93.07.27.09.15.52;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	93.07.15.16.47.25;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	93.07.07.10.20.27;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	93.07.06.15.03.45;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	93.01.12.10.40.47;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	92.12.08.15.58.44;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	92.12.07.18.18.58;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	92.12.07.18.12.05;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	92.12.07.18.11.43;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	92.10.21.17.15.53;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	92.10.07.08.47.15;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	92.10.05.10.16.26;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	92.10.02.16.44.46;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	92.10.02.11.27.41;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	92.09.04.08.42.56;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	92.09.03.17.01.12;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	92.09.03.16.14.19;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	92.09.03.15.41.02;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	92.08.13.10.47.03;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	92.07.29.13.00.54;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	92.07.14.17.46.59;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	92.07.13.10.09.33;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	92.07.06.17.24.02;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	92.06.25.10.55.29;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	92.06.22.15.00.24;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	92.06.19.15.06.14;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	92.06.19.11.22.24;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	92.06.19.11.15.28;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	92.06.11.13.44.18;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	92.06.09.13.40.31;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	92.06.09.08.39.24;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	92.06.08.16.12.51;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	92.06.05.14.28.40;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	92.06.04.17.02.10;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	92.06.04.12.49.31;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	92.06.02.07.59.36;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	92.06.01.11.41.15;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	92.05.20.08.40.00;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	92.05.20.07.53.51;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	92.05.15.15.29.29;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	92.05.14.11.19.54;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	92.05.14.10.38.23;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	92.05.14.10.28.41;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	92.05.13.15.26.20;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	92.05.11.16.27.29;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	92.05.06.13.40.58;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	92.04.30.13.25.40;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	92.04.22.14.56.53;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	92.04.22.11.15.57;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	92.04.21.15.04.38;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	92.04.15.17.19.24;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	92.04.15.16.44.16;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	92.04.03.15.51.37;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	92.03.31.17.51.14;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	92.03.23.11.25.44;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	92.03.13.12.06.12;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	92.03.11.17.36.59;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	92.02.28.18.10.00;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	92.02.28.18.04.06;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	92.02.20.17.47.18;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	92.02.17.11.54.43;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	92.02.13.12.58.07;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	92.02.12.15.36.20;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	92.02.12.11.30.39;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	91.12.13.14.18.56;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	91.12.12.09.12.46;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	91.12.10.17.33.52;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	91.12.10.14.36.27;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	91.12.10.13.04.25;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	91.12.06.17.13.50;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	91.12.05.10.34.51;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	91.12.04.16.33.43;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	91.12.04.16.32.44;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	91.12.03.19.14.36;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	91.11.13.18.54.56;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	91.11.08.17.15.37;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	91.11.06.09.55.44;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	91.11.03.17.03.04;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	91.10.31.14.08.44;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	91.10.18.15.56.08;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	91.10.10.15.40.45;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	91.10.10.15.26.31;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	91.10.09.15.21.25;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	91.10.09.10.18.20;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	91.10.08.13.41.21;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	91.10.03.07.47.44;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	91.10.02.17.17.14;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	91.10.02.15.32.15;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	91.10.02.15.28.35;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	91.10.02.12.54.30;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	91.10.01.13.18.51;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	91.09.26.09.14.57;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	91.09.20.15.24.14;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	91.09.19.15.07.35;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	91.08.22.14.58.57;	author nickc;	state Exp;
branches;
next	;


desc
@helios object code formatter
@


1.95
log
@replaced syserrs with string constants
@
text
@/*
 * C compiler file heliobj.c
 * Copyright (C) Perihelion Software Ltd, 1988 - 1993
 * Adapted by Codemist Ltd, 1989
 * Tidied up by NC 1991-1993
 * 68K and ARM code reiniserted by NC 1993
 */

/* #define STIK_NOW_WORKS_ON_HARDWARE 1 */

/* AM Apr 89: change 'stublist' so that items are merely marked deleted */
/* (by having xr_defloc/xr_defext) instead of physical removeal.        */
/*
 * This was once called heliosobj.c, but to keep file component makes
 * short (e.g. for when we want to host on an MSDOS machine, yuk) it has
 * been contracted to heliobj.c
 */

/*{{{  Header Files */

# ifdef __STDC__
# include <string.h>
# else
# include <strings.h>
# endif

#include <stddef.h>
#include <errno.h>

#ifndef SEEK_SET
#define SEEK_SET  0
#endif

#include </hsrc/include/helios.h>
#include </hsrc/include/module.h>

#include "host.h"
#include "globals.h"
#include "mcdep.h"
#include "mcdpriv.h"
#include "xrefs.h"
#include "store.h"
#include "codebuf.h"
#include "mipvsn.h"
#include "jopcode.h"
#include "ops.h"            /* For R_ADDR1 etc */
#include "regalloc.h"       /* for regmask */
#include "cg.h"             /* for procflags */
#include "errors.h"
#ifdef TARGET_IS_C40
#include "peep.h"
#endif

/*}}}*/
/*{{{ Macros       */

#define xr_definition			(xr_defloc | xr_defext)
#define xr_external_code		(xr_code   | xr_defext)

#define extflags_( x )			((x)->extflags)
#define extsym_( x )			((x)->extsym)
#define extcdr_( x )			((x)->extcdr)
#define extoffset_( x )			((x)->extoffset)

#define is_defined( x )			 (extflags_(x) & xr_definition)
#define is_defined_( flags )		 ((flags)      & xr_definition)
#define is_code( x )			 (extflags_(x) & xr_code)
#define is_code_( flags )		 ((flags)      & xr_code)
#define is_data( x )			 (extflags_(x) & xr_data)
#define is_external_code( x )		((extflags_(x) & xr_external_code) == xr_external_code)
#define is_local( x )			 (extflags_(x) & xr_defloc)
#define is_global( x )			 (extflags_(x) & xr_defext)
#define is_bss( x )			 (extflags_(x) & xr_bss)

#ifndef offsetof
#define offsetof( type, member ) ((char *)&(((type *)0)->member) - (char *)0)
#endif

#ifndef TARGET_IS_C40
#define asmf( str ) 	if (asmstream) fprintf( asmstream, str )
#endif

/*}}}*/
/*{{{ Constants    */

#define OBJCODE      	0x01
#define OBJBSS        	0x02
#define OBJINIT       	0x03

#define OBJBYTE       	0x09	   	/* ls 3 bits = size      */
#define OBJSHORT      	0x0a
#define OBJWORD       	0x0c

#define OBJCODESYMB   	0x0d		/* was funcref   */
#define OBJMODSIZE  	0x0e		/* was imagesize */
#define OBJLABELREF   	0x0f		/* was labeloff  */
#define OBJDATASYMB   	0x10		/* was dataref   */
#define OBJDATAMODULE 	0x11
#define OBJMODNUM     	0x12

#define OBJPATCH      	0x13   		/* PATCHES are 0x13 - 0x1f */
#define OBJPATCHMAX   	0x1f

#define OBJMODULE     	0x20
#define OBJBYTESEX	0x21

#define OBJGLOBAL     	0x22
#define OBJLABEL      	0x23
#define OBJDATA       	0x24
#define OBJCOMMON     	0x25
#define OBJCODETABLE  	0x26
#define OBJREF        	0x27		/* force reference to another library */
#define OBJCODESTUB	0x28		/* address of fn or stub */
#define OBJADDRSTUB	0x29		/* stub returning address of fn */

#define OBJNEWSEG	0x30
#define OBJEND		0x31
#define OBJLITERAL	0x32	   	/* OBJCODE of <= 4 bytes */

#define PATCHADD  	0x13 		/* patch = val1 +  val2 */
#define PATCHSHIFT	0x14 		/* patch = val2 << val1 */ /* right shift for -ve val1 */
#define PATCHSWAP	0x1E		/* patch = byte_swap( val1 ) */
#define PATCHOR		0x1f		/* patch = val1 | val2 */

#ifdef TARGET_IS_ARM
#define PATCHARMLDR    0x15		/* aka armdt		*/
#define PATCHARMADD    0x16		/* aka armdp 		*/
#define PATCHARMBL     0x17		/* aka armjp 		*/
#define PATCHARMADDLO  0x18		/* aka armdplsb 	*/
#define PATCHARMADDHI  0x19		/* aka armdprest 	*/
#define PATCHARMADDMID 0x1a		/* aka armdpmid 	*/
#endif

#ifdef TARGET_IS_C40
#define PATCHC40DATAMODULE1	0x15
#define PATCHC40DATAMODULE2	0x16
#define PATCHC40DATAMODULE3	0x17
#define PATCHC40DATAMODULE4	0x18
#define PATCHC40DATAMODULE5	0x19
#define PATCHC40MASK24ADD	0x1a
#define PATCHC40MASK16ADD	0x1b
#define PATCHC40MASK8ADD	0x1c
#endif

#ifndef NUM_BITS_PER_BYTE
#define NUM_BITS_PER_BYTE 8
#endif

#ifndef R_ATMP
#ifdef TARGET_IS_ARM
#define R_ATMP R_AS
#else
#define R_ATMP R_AS2
#endif
#endif

/*}}}*/
/*{{{ Types        */

typedef struct GSymlist
  {
    struct GSymlist *	cdr;
    Symstr *		sym;
  }
GSymlist;

typedef struct Stub
  {
    struct Stub *	stubcdr;
    Symstr *		stubsym;
  }
Stub;

/*}}}*/
/*{{{ Variables    */

extern int	   	split_module_table;

ExtRef *		obj_symlist;
CodeXref *		codexrefs;
ExtRef *		datasymbols;
int	      		suppress_module;
FILE *		   	objstream;
LabelNumber *		exporting_routines = NULL;

static Stub *		stublist;
static GSymlist *	global_symbols;
#ifdef TARGET_USES_NEW_STUBS
static GSymlist *	stub_symbols;
static GSymlist *	addr_stub_symbols;
#endif
static int32 		obj_symcount;
static ExtRef **	obj_symlistend;
static int32     	codesize;
static int32     	codesizepos;
static int32     	datasize;              /* only for obj file use */
static int32     	datasizepos;
static int32     	maxcodep;
static int32     	maxcodeppos;
static LabelNumber *	datainitlab;

/*}}}*/
/*{{{ Functions    */

/*{{{ objbyte */

static void
objbyte( int32 b )
{
  if (objstream == NULL)
    {
      fprintf( stderr, "WARNING: objbyte has no output stream, wanted to write byte %ld\n", b );
      
      return;
    }
    
  putc( (char)b, objstream );
    
  return;
  
} /* objbyte */

/*}}}*/
/*{{{ objword */

static void
objword( int32 x )
{
  unsigned char	val;
  
#ifdef TARGET_IS_LITTLE_ENDIAN
  val = (unsigned char)(x & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char)((x >> 8) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char)((x >> 16) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char)((x >> 24) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
#else /* ! TARGET_IS_LITTLE_ENDIAN */
  
  val = (unsigned char) ((x >> 24) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char) ((x >> 16) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char) ((x >> 8) & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
  val = (unsigned char) (x & 0xff);
  
  fwrite( &val, 1, sizeof (val), objstream );
  
#endif /* TARGET_IS_LITTLE_ENDIAN */
  
  return;
  
} /* objword */

/*}}}*/
/*{{{ objnum */

#define bitmask( n ) ((1 << (n)) - 1)

static void
objnum( int32 n )
{
  int32 	i;
  int32 	nflag = (n < 0)? n = -n, 1 : 0;
  int32 	mask7 = bitmask( 7 );
  
#define NFLAG 0x40
#define MORE  0x80
  
  /* The prefix notation expressed in this function is described */
  /* in Nick Garnett's description of the Helios Link Format for */
  /* Non-Transputer Processors                                   */
  
  for (i = 28; i != 0; i -= 7)
    if ((n & (mask7 << i)) != 0)
      break;
  
  if ((n >> i) & NFLAG)
    i += 7;
  
  objbyte( (n >> i) | (nflag ? NFLAG : 0) | (i > 0 ? MORE : 0) );
  
  for (i -= 7; i >= 0; i -= 7)
    objbyte( ((n >> i) & mask7) | (i > 0 ? MORE : 0) );
  
  return;
  
} /* objnum */

/*}}}*/
/*{{{ objsymbol */

static void
objsymbol(
	  char		prefix,
	  char *	s )
{
  objbyte( prefix );
    
  fputs( s, objstream );
  
  objbyte( '\0' );
  
  return;
  
} /* objsymbol */

/*}}}*/
/*{{{ globalise */

static void
globalise( Symstr * s )
{
  GSymlist *	g;

  
  for (g = global_symbols; g != NULL; g = g->cdr)
    if (g->sym == s)
      return;
    
  global_symbols = (GSymlist *)global_cons2( SU_Other, global_symbols, s );
    
  return;
  
} /* globalise */

/*}}}*/
/*{{{ dumpglobals */

static void
dumpglobals( void )
{
  GSymlist *	g;
  

  for (g = global_symbols; g != NULL; g = g->cdr)
    {
      objbyte( OBJGLOBAL );

#ifdef TARGET_USES_NEW_STUBS
      if (new_stubs && is_code( symext_( g->sym )))
	objsymbol( '.', symname_( g->sym ) );
      else
#endif
	objsymbol( '_', symname_( g->sym ) );
    }
  
  return;
  
} /* dumpglobals */

/*}}}*/
/*{{{ request_addr_stub */

#ifdef TARGET_USES_NEW_STUBS

void
request_addr_stub( Symstr * s )
{
  GSymlist *	a;
  
  
  for (a = addr_stub_symbols; a != NULL; a = a->cdr)
    if (a->sym == s)
      return;
  
  addr_stub_symbols = (GSymlist *)global_cons2( SU_Other, addr_stub_symbols, s );
  
  return;
  
} /* request_addr_stub */

#endif /*TARGET_USES_NEW_STUBS */

/*}}}*/
/*{{{ request_new_stub  */
#ifdef TARGET_USES_NEW_STUBS
void
request_new_stub( Symstr * s )
{
  GSymlist *	g;
    
  
  for (g = stub_symbols; g != NULL; g = g->cdr)
    if (g->sym == s)
      return;
  
  stub_symbols = (GSymlist *)global_cons2( SU_Other, stub_symbols, s );
  
  return;
  
} /* request_new_stub */
#endif /* TARGET_USES_NEW_STUBS */
/*}}}*/
/*{{{ dump_new_stubs */
#ifdef TARGET_USES_NEW_STUBS
static void
dump_new_stubs( void )
{
  GSymlist *	g;
  
  
  for (g = stub_symbols; g != NULL; g = g->cdr)
    {
      objbyte( OBJGLOBAL );
      
      objsymbol( '.', symname_( g->sym ) );
      
      objbyte( OBJREF );
      
      objsymbol( '_', symname_( g->sym ) );
    }
  
  for (g = addr_stub_symbols; g != NULL; g = g->cdr)
    {
      objbyte( OBJGLOBAL );
      
      fputs( ".addr", objstream );
      
      objsymbol( '.', symname_( g->sym ) );
      
      /*
       * We must generate a REF to the original function name
       * in order to ensure that the module containing the function
       * is linked, even if the function itself is never called.
       */
      
      objbyte( OBJREF );
      
      objsymbol( '.', symname_( g->sym ) );
    }
  
  return;
  
} /* dump_new_stubs */
#endif /* TARGET_USES_NEW_STUBS */
/*}}}*/
/*{{{ objdirective */

/*
 * This functions handles the cross reference directive 'xrtype'
 * and issues suitable linker instructions to ensure the correct
 * patching is performed.  The symbol 'sym' (if needed) is the
 * symbol refered to by the cross reference.  The word 'code'
 * is the instruction that is being patched.
 *
 * The function returns the number of bytes that have been altered
 * in the output file
 */

#if defined TARGET_IS_C40

/*{{{ C40 */

static int32
objdirective(
	     int32	xrtype,
	     Symstr *	sym,
	     int32	code )
{
  switch (xrtype)
    {
    case X_Modnum:				/* see load_static_data_ptr() in c40/gen.c */
      /*
       * take code word and add in module number,
       * shifted up to be a word offset.  (If we
       * are using split modules then there is a
       * two word structure for each module table
       * entry so we make module number be a two
       * word offset).  Note that for the 'C40
       * we are loading a WORD offset, not a BYTE
       * offset, so we may not need to shift at all
       */
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( few_modules ? PATCHC40MASK8ADD :
	      PATCHC40MASK16ADD );		/* ... adding into the bottom 8 or 16 bits of ... */
      objnum( code );				/* ... the current word op code ... */
      if (split_module_table)
	{
	  objbyte( PATCHSHIFT );		/* ... the result of shifting ... */
	  objnum( 1 );				/* ... up by 1 bit ... */
	}
      objbyte( OBJMODNUM );			/* ... the current module number */
      break;
      
    case X_DataAddr:		/* see load_address_constant in c40/gen.c */
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -16 );				/* ... right by 16 bits ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( 14 );				/* ... left by 14 bits ... */
      if (is_function( sym ))
	{
	  objbyte(
#ifdef TARGET_USES_NEW_STUBS
		  new_stubs ? OBJCODESTUB :
#endif
		  OBJLABELREF );	/* ... the offset of ... */
	  objsymbol( '.', symname_( sym ) );	/* ... the symbol */
	}      
      else
	{
	  objbyte( OBJLABELREF );
	  objsymbol( '_', symname_( sym ) );
	}
      break;
      
    case X_DataAddr1:		/* high part of previous patch, see c40/gen.c */
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -18 );				/* ... right by 18 bits ... */
      objbyte( PATCHADD );			/* ... the result of adding ... */
      objnum( -3 * sizeof_int );		/* ... -3 * sizeof_int to ... */
      if (is_function( sym ))
	{
	  objbyte(
#ifdef TARGET_USES_NEW_STUBS
		  new_stubs ? OBJCODESTUB :
#endif
		  OBJLABELREF );	/* ... the offset of ... */
	  objsymbol( '.', symname_( sym ) );	/* ... the symbol */
	}	  
      else
	{
	  objbyte( OBJLABELREF );
	  objsymbol( '_', symname_( sym ) );
	}	  
      break;
      
    case X_FuncAddr:		/* see load_address_constant in c40/gen.c */
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40MASK24ADD );		/* ... adding into the bottom 24 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting right ... */
      objnum( -2 );				/* ... by two bits ... */
      objbyte( OBJADDRSTUB );			/* ... the offset of ... */
      fputs( ".addr", objstream );		/* ... the address obtaining function for ... */
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_PCreloc:		/* see call() in c40/gen.c */
      /*
       * This occurs when we have a call to a function stub
       */
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40MASK24ADD );		/* ... adding into the bottom 24 bits of ... */
      objnum( code );				/* ... the current word of code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... right by two bits ... */
      objbyte(
#ifdef TARGET_USES_NEW_STUBS
	      new_stubs ? OBJCODESTUB :
#endif
	      OBJLABELREF );	/* ... the offset of ... */
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataModule:				/* see load_address_constant in c40/gen.c */
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( few_modules ? PATCHC40MASK8ADD :
	      PATCHC40MASK16ADD );/* ... adding into the bottom 8 or 16 bits of... */	
      objnum( code );				/* ... the current word op code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... down by two bits ... */
      objbyte( OBJDATAMODULE );			/* ... the module number of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataModule1:
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE1 );		/* ... applying 'C40 specific DataModule1 patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... down by two bits ... */
      objbyte( OBJDATAMODULE );			/* ... the module number of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the specified symbol */
      break;
      
    case X_DataModule2:
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE2 );		/* ... applying 'C40 specific DataModule2 patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      if (is_function( sym ))
	{
	  objbyte( PATCHSHIFT );		/* ... the result of shifting ... */
	  objnum( -2 );				/* ... down by 2 bits ... */
	}
      objbyte( split_module_table ?
	      OBJCODESYMB : OBJDATASYMB );	/* ... the offset into the module of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataModule3:
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE3 );		/* ... applying 'C40 specific DataModule3 patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      objbyte( OBJMODNUM );			/* ... another dummy value */
      break;
      
    case X_DataModule4:
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE4 );		/* ... applying 'C40 specific DataModule4 patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      objbyte( OBJMODNUM );			/* ... another dummy value */            
      break;
      
    case X_DataModule5:
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40DATAMODULE5 );		/* ... applying 'C40 specific DataModule5 patch to ... */
      objnum( code );				/* ... a dummy value and ... */
      objbyte( OBJMODNUM );			/* ... another dummy value */
      break;
      
    case X_DataSymbHi:
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
      objnum( code );				/* ... the current word op code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      if (split_module_table && is_function( sym ))
	{
	  objnum( -18 );			/* ... down by 18 bits ... */
	  objbyte( OBJCODESYMB );		/* ... the offset into the module of the function ... */
	}
      else					/* ... or ... */
	{	  
	  objnum( -16 );			/* ... down by 16 bits ... */
	  objbyte( OBJDATASYMB );		/* ... the offset into the module of the datum ... */
	}
      objsymbol( '_', symname_( sym ) );	/* ... specified by symbol */
      break;
      
    case X_DataSymbLo:
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of... */
      objnum( code );				/* ... the current word op code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -16 );				/* ... down by 16 bits ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      if (split_module_table && is_function( sym ))
	{
	  objnum( 14 );				/* ... up by 14 bits ... */
	  objbyte( OBJCODESYMB );		/* ... the offset into the module of the function ... */
	}
      else					/* ... or ... */
	{	  
	  objnum( 16 );				/* ... up by 16 bits ... */
	  objbyte( OBJDATASYMB );		/* ... the offset into the module of the datum ... */
	}
      objsymbol( '_', symname_( sym ) );	/* ... specified by symbol */
      break;
      
    case X_DataSymb:				/* see load_address_constant in c40/gen.c */
      
      objbyte( OBJWORD );			/* patch by ... */
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of... */
      objnum( code );				/* ... the current word op code ... */
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( -2 );				/* ... down by 2 bits ... */
      if (split_module_table)
	{
	  objbyte( OBJCODESYMB );		/* ... the offset into the module of the function ... */
	}
      else					/* ... or ... */
	{	  
	  objbyte( OBJDATASYMB );		/* ... the offset into the module of the datum ... */
	}
      objsymbol( '_', symname_( sym ) );	/* ... specified by symbol */      
      break;
      
#ifdef TARGET_HAS_DEBUGGER
    case X_Debug_Modnum:
      objbyte( OBJWORD );			/* patch by inserting ... */
      objbyte( OBJMODNUM );			/* ... the current module number */
      break;
      
    case X_Debug_Offset:
      objbyte( OBJWORD );			/* patch by inserting ... */
      objbyte( split_module_table ?
	      OBJCODESYMB : OBJDATASYMB );	/* ... the offset in the module table of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the function specified by symbol */
      break;
      
    case X_Debug_Ref:
      objbyte( OBJWORD );			/* patch by inserting ... */
      objbyte( OBJLABELREF );			/* ... the offset of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the start of the function specified by symbol */
      break;
      
#endif /* TARGET_HAS_DEBUGGER */
      
    case X_Init:
      objbyte( OBJINIT );
      break;
      
    default:
      syserr( syserr_heliobj_bad_xref, sym, (long)xrtype );
      
    case X_absreloc:
      return 0;
    }
  
  return 4;
  
} /* objdirective */

/*}}}*/

#elif defined TARGET_IS_68000 || defined TARGET_IS_68020

/*{{{ 68K */

static int32
objdirective(
	     int32	xrtype,
	     Symstr *	sym,
	     int32	code )
{
  switch (xrtype)
    {
    case X_Modnum:
      objbyte( OBJSHORT );			/* patch by ... */
      if (code != 0)
	{
	  objbyte( PATCHADD );			/* ... adding in to ... */
	  objnum( code );			/* ... the current op code ... */
	}
      objbyte( PATCHSHIFT );			/* ... the result of shifting ... */
      objnum( split_module_table ? 3 : 2 );	/* ... up by 2 or 3 bits ... */
      objbyte( OBJMODNUM );			/* ... the current module number */
      break;
      
    case X_PCreloc:
      objbyte( OBJSHORT );			/* patch by ... */
      if (code != 0)
	{
	  objbyte( PATCHADD );			/* ... adding into ... */
	  objnum( code );			/* ... the current op code ... */
	}
      objbyte( OBJLABELREF );			/* ... the offset of ... */
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataModule:
      
      objbyte( OBJSHORT );			/* patch by ... */
      if (code != 0)
	{
	  objbyte( PATCHADD );			/* ... adding into ... */
	  objnum( code );			/* ... the current op code ... */
	}
      objbyte( OBJDATAMODULE );			/* ... the module number of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_DataSymb:
      
      objbyte( OBJSHORT );			/* patch by ... */
      if (code != 0)
	{
	  objbyte( PATCHADD );			/* ... adding into ... */
	  objnum( code );			/* ... the current op code ... */
	}
      objbyte( OBJDATASYMB );			/* ... the offset of ... */
      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
      break;
      
    case X_Init:
      objbyte( OBJINIT );
      
      return 4;
      
    default:
      syserr( syserr_heliobj_bad_xref, sym, (long)xrtype );
      
      return 0;
    }
  
  return 2;
  
} /* objdirective */

/*}}}*/

#elif defined TARGET_IS_ARM

/*{{{ ARM */

static int32
objdirective(
	     int32	xrtype,
	     Symstr *	sym,
	     int32	code )
{
  switch (xrtype)
    {
    case X_Modnum:
      objbyte( OBJWORD );
      /*
       * For module numbers I will stick to 12 bit offsets for now.
       */
      objbyte( PATCHARMLDR );       /* Only format used is LDR xx, [dp, #modnum] */
      objnum(  code );
      objbyte( PATCHSHIFT );
      objnum(  split_module_table ? 3 : 2 );
      objbyte( OBJMODNUM );
      
      return 4;
      
    case X_PCreloc:
      objbyte( OBJWORD );
      objbyte( PATCHARMBL );
      objnum(  code );
      objbyte( OBJLABELREF );
      
      objsymbol( '.', symname_( sym ) );
      break;
      
    case X_PCreloc2:                /* Patch an ADD instruction */
      objbyte( OBJWORD );
      objbyte( PATCHARMADDLO );
      objnum(  code );
      objbyte( OBJLABELREF );
      
      objsymbol( '.', symname_( sym ) );
      break;
      
    case X_DataSymb2:
      objbyte( OBJWORD );
      objbyte( PATCHARMADDLO );
      objnum(  code );
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
      break;

    case X_PCreloc3:                /* Patch an ADD instruction */
      objbyte( OBJWORD );
      objbyte( PATCHARMADDHI );
      objnum(  code );
      objbyte( OBJLABELREF );
      
      objsymbol( '.', symname_( sym ) );
      break;
      
    case X_DataSymb3:
      objbyte( OBJWORD );
      objbyte( PATCHARMADDHI );
      objnum(  code );
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
      break;

    case X_DataSymb6:
      objbyte( OBJWORD );
      objbyte( PATCHARMADDMID );
      objnum(  code );
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
      break;

    case X_DataModule:
      objbyte( OBJWORD );
      objbyte( PATCHARMLDR );
      objnum(  code );
      objbyte( OBJDATAMODULE );
      
      objsymbol( '_', symname_( sym ) );
      break;
      
    case X_DataSymb:
      objbyte( OBJWORD );
      objbyte( PATCHARMLDR );
      objnum(  code );
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
      break;
      
    case X_Init:
      objbyte( OBJINIT );
      break;

    default:
      syserr( syserr_heliobj_bad_xref, sym, (long)xrtype );
      
      return 0;
    }
  
  return 4;
      
} /* objdirective */

/*}}}*/

#else /* not C40, 68K, or ARM */

#error Unknown target processor

#endif /* machine specific versions of objdirective */

/*}}}*/
/*{{{ startcode */

static void
startcode( int32 n )
{
  if (n == 0 || objstream == NULL)
    return;

  objbyte( OBJCODE );
  
  objnum( n );

  return;
  
} /* startcode */

/*}}}*/
/*{{{ startdata */

static void
startdata(
	  int32		n,
	  char *	name )
{
  if (objstream)
    {
      objbyte( OBJDATA );
      
      objnum( n );
      
      objsymbol( '_', name );
    }
  
  datasize += n;

  return;

} /* startdata */

/*}}}*/
/*{{{ startcodetable */

static void
startcodetable(
	       int32	n,
	       char *	name )
{
  if (objstream)
    {
      objbyte( split_module_table ? OBJCODETABLE : OBJDATA );
      
      if (!split_module_table)
	objnum( n );
      
      objsymbol( '_', name );
    }
  
  maxcodep += n;

  return;
  
} /* startcodetable */

/*}}}*/
/*{{{ objlabel */

static void
objlabel(
	 char	prefix,
	 char *	name )
{
  if (objstream)
    {
      /*
       * This guard seems necessary since objlabel is called from obj_symref
       * which itself gets called even when an object file is not needed.
       */
      
      objbyte( OBJLABEL );
      
      objsymbol( prefix, name );
    }

  return;
  
} /* objlabel */

/*}}}*/
/*{{{ obj_outcode */

/* Since an object directive might take us over the end of     */
/* the buffer we are actually outputting this routine returns  */
/* the number of bytes it has encroached into the next buffer. */

static int32
obj_outcode(
	    char *		buff,
	    CodeFlag_t *	flag,
	    int32 		nbytes,
	    int32		segbase )
{
  static bool	inited  = FALSE;
  static long	big_end = FALSE;
  int32 	i;
  int32 	b = 0;
  int32		n;

  
  IGNORE( flag );               /* i.e. no cross-sex compilation */

  if (!inited)
    {
      int	a = 0x12345678;

	  
      if (((char *)&a)[ 0 ] == 0x12)
	{
	  big_end = TRUE;
	}

      inited = TRUE;
    }

  for (b = 0; b < nbytes; b += n)
    {
      bool	xrflag = 0;
      int32	xrtype = 0;
      int32	xcode  = 0;


      if (codexrefs)
        {
	  int32		x = codexrefs->codexroff & 0x00ffffffU;
	  
	  
	  if (x < segbase + nbytes)
            {
	      xrflag = 1;
	      xrtype = codexrefs->codexroff & 0xff000000U;
	      n      = x - segbase - b;
            }
	  else
	    {
	      n = nbytes - b;
	    }
        }
      else
	{
	  n = nbytes - b;
	}
      
      startcode( n );

      if (big_end)
	{
	  for (i = b; i < (b + n); i++)
	    {
	      objbyte( buff[ (i & ~3) + (3 - (i & 3)) ] );
	    }

	  xcode  =  (int32)buff[ i++ ] << 24;
	  xcode |= ((int32)buff[ i++ ] << 16) & 0x00ff0000;
	  xcode |= ((int32)buff[ i++ ] << 8)  & 0x0000ff00;
	  xcode |= ((int32)buff[ i++ ])       & 0x000000ff;
	}
      else
	{
	  /* little endian host */
	  
	  for (i = b; i < (b + n); i++)
	    objbyte( buff[ i ] );

	  xcode  = buff[ i++ ];
	  xcode |= (int32)buff[ i++ ] << 8;
	  xcode |= (int32)buff[ i++ ] << 16;
	  xcode |= (int32)buff[ i++ ] << 24;
	}
      
      if (xrflag)
        {
	  CodeXref *	c = codexrefs;


	  codexrefs = c->codexrcdr;

	  switch (xrtype)
            {
	    case X_absreloc:
	      xcode += c->codexrcode;
	      break;
	      
	    case X_DataSymb:
	    case X_PCreloc:
#ifndef TARGET_IS_C40
	      /*
	       * pick up offset coded into 4th field
	       * (ie by using global_list4)
	       */
	      
	      if (c->codexrcode > 0xffff)
		cc_warn( heliobj_warn_16bits, (long)c->codexrcode );
	      
	      xcode += c->codexrcode;
#endif
	      break;

#ifdef TARGET_IS_ARM
	    case X_PCreloc2:    /* These involve 2 ADD instrns so can cover 16 bits */
	    case X_PCreloc3:

	      if (c->codexrcode > 0xffff)
		cc_warn( heliobj_warn_16bits, (long)c->codexrcode );
	      
	      xcode += c->codexrcode;

	      break;

	    case X_DataSymb2:
	    case X_DataSymb3:
	    case X_DataSymb6:

	      if (c->codexrcode > 0xfff)
		cc_warn( heliobj_warn_12bits, (long)c->codexrcode );
	      
	      xcode += c->codexrcode;

	      break;
#endif
	    default:
	      fprintf( stderr, "heliobj: unknown cross refernce type %lx\n", xrtype );

	      break;
	      
#ifdef TARGET_IS_C40
	    case X_DataModule1:
	    case X_DataModule2:
	    case X_DataModule3:
	    case X_DataModule4:
	    case X_DataModule5:
	    case X_DataSymbHi:
	    case X_DataSymbLo:
	    case X_DataAddr1:
	    case X_FuncAddr:
#endif /* TARGET_IS_C40 */
	      
#ifdef TARGET_HAS_DEBUGGER
	    case X_Debug_Modnum:
	    case X_Debug_Offset:
	    case X_Debug_Ref:
#endif
	    case X_DataAddr:
	    case X_DataModule:
	    case X_Modnum:
	      break;
            }

	  n += objdirective( xrtype, c->codexrsym, xcode );
        }
    }

  return (b - nbytes);

} /* obj_outcode */

/*}}}*/
/*{{{ obj_codewrite */

void
obj_codewrite( Symstr * name )
{
  int32 	i       = 0;
  int32 	overrun = 0;
  int32 	segbase = codebase;

  
  if (codep == 0)
    {
      return;
    }  

  if (codexrefs != NULL)
    {
      /* Odd how the list ALL gets reversed every routine? */
  
      codexrefs = (CodeXref *)dreverse( (List *)codexrefs );
    }
      
  while ((codep / sizeof (int)) - CODEVECSEGSIZE * i > CODEVECSEGSIZE)
    {
      overrun = obj_outcode( (char *)code_instvec_( i ) + overrun, code_flagvec_( i ),
                               CODEVECSEGSIZE * sizeof (int) - overrun, segbase );
      
      segbase += CODEVECSEGSIZE * sizeof (int) + overrun;
      
      i++;
    }
  
  obj_outcode( (char *)code_instvec_( i ) + overrun, code_flagvec_( i ),
                (codep - CODEVECSEGSIZE * i * sizeof (int)) - overrun, segbase );
  
  codesize += codep;

#if defined TARGET_IS_C40 && defined NEVER
  /*
   * XXX
   *
   * one day we would like to align the start of
   * functions (and the initialisation code) to 128
   * byte boundaries to optimize the use of the 'C40's
   * op code cache.  Unfortuanetly this would upset the
   * compiler's calculation of intra function offsets
   * so that these would have to be recoded.
   */
  
  if (name == NULL)
    {
      int32	x = codesize;

      
      /* ensure that code is padded to a 128 byte boundary */
      
      x &= (128 - 1);

      if (x)
	{
	  x = 128 - x;
	  
	  objbyte( OBJBSS );
      
	  objnum( x );

	  codesize += x;
	}
    }
#endif /* TARGET_IS_C40 */
  
  return;

  name = name;
  
} /* obj_codewrite */

/*}}}*/
/*{{{ request_stub */

void
request_stub( Symstr * name )
{
  Stub *	s;


  for (s = stublist; (s != NULL); s = s->stubcdr)
    {
#ifdef TARGET_IS_ARM		/* JGS: 910213 : Deal with our special exception stubs */
      
      if (((Symstr *)((int32)(s->stubsym) & ~(1UL << 31))) == name)
	return;
      
#else /* not TARGET_IS_ARM */
      
      if (s->stubsym == name)
	return;
      
#endif /* TARGET_IS_ARM */
    }
  
  stublist = (Stub *)global_cons2( SU_Other, stublist, name );

  return;
  
} /* request_stub */

/*}}}*/
/*{{{ request_exception_stub */

#ifdef TARGET_IS_ARM
/* JGS: 910213
 *	This is required to register a special exception handling stub. These
 *	stubs will NOT corrupt any registers. This introduces an unnecessary
 *	performance hit for normal PCS conforming functions, but is required
 *	for certain exceptional cases (eg. stack overflow).
 */

void
request_exception_stub( Symstr * name )
{
  Stub *	s;


  /* JGS: 910213 : Deal with our special exception stubs */

  for (s = stublist; (s != NULL); s = s->stubcdr)
    if (((Symstr *)((int32)(s->stubsym) & ~(1UL << 31))) == name)
      return ;
  
  /* We need to use a special marker to highlight that this is an exception */
  
  stublist = (Stub *)global_cons2( SU_Other, stublist, ((int32) name | (1UL << 31)) );

  return;
  
} /* request_exception_stub */

#endif /* TARGET_IS_ARM */

/*}}}*/
/*{{{ show_stubs */

static void
show_stubs( void )
{
  Stub *	s;
  VRegInt 	vr1, vr2, vm;


#ifdef TARGET_USES_NEW_STUBS
  if (!new_stubs)
#endif
    {
      asmf( ";\n; Function Stubs\n" );
  
      in_stubs = YES;

      codebuf_reinit2();
  
      localcg_reinit();
  
      vr1.r = vr2.r = GAP; vm.i = 0;
  
      procflags = 0;

      show_instruction( J_ENTER, vr1, vr2, vm );      
    }

  for (s = stublist; s != NULL; s = s->stubcdr)
    {
      Symstr *	sym = s->stubsym;

#ifdef TARGET_IS_ARM
      /* JGS: 910213
       * We have encoded the exceptional flag in the top bit of the symbol
       * pointer. This assumes things about the environment the compiler
       * is executing under. If we are an exceptional stub, we should generate
       * code that preserve all the registers over the stub call.
       */
     
      if (((int32)sym & (1UL << 31)) != 0)
	{
	  sym = (Symstr *)((int32)sym & ~(1UL << 31)) ; /* clear the flag bit */
	}
#endif /* TARGET_IS_ARM */

      if (!is_defined( symext_( sym ) ))
	{
	  if (debugging( DEBUG_OBJ ))
	   cc_msg( "Stub for $r\n", s );
	  
#ifdef TARGET_USES_NEW_STUBS
	  if (new_stubs)
	    {
	      /*
	       * If 'sym' is not defined locally then make it global
	       */
	     
	      request_new_stub( sym );
	    }
	  else
#endif /* TARGET_USES_NEW_STUBS */
	    {
	      /*
	       * CGS: Changed from show_entry because that makes the symbol defined.
	       * I do not want it defined because when we come to do the init sequence
	       * it will think that the label is defined and would put a pointer
	       * to the stub into the data area. (viz. X problem).
	       * All we do is define the label to the linker and let that worry about
	       * patching up the forward references from the code.
	       */
#if 0
	      show_entry( sym, xr_code | xr_defloc ); /* really a call to obj_symref */
#else
	      objlabel( '.', symname_( sym ) );
#endif
	     
	      /*
	       * Note that the two values passed in the r1 and r2 fields here are a
	       * bit suspect, but something is certainly needed...
	       */
	     
	      /* Beware the sym on the next line -- it probably needs to be a      */
	      /* slighly different Symstr.                                         */
	     
	      vr1.rr = R_A1;
	      vr2.i  = 0;
	      vm.sym = sym;
	     
	      show_instruction( J_TAILCALLK, vr1, vr2, vm );
	     
	      vr1.r = vr2.r = GAP;
	      vm.i  = 0;
	      
	      show_instruction( J_ENDPROC, vr1, vr2, vm );
	      
	      show_code( sym );
	      
	      asm_lablist = NULL;
	    }
	}
    }

#ifndef TARGET_USES_NEW_STUBS
  in_stubs = NO;
#endif
  
  return;

} /* show_stubs */

/*}}}*/
/*{{{ export_routines */

static void
export_routines( void )
{
  ExtRef *	x;
#ifndef TARGET_IS_C40
  VRegInt	vr1, vr2, vm;
#endif


  for (x = obj_symlist; x != NULL; x = extcdr_( x ))
    {
      if (is_external_code( x ))
	{
	  if (objstream)
	    {
	      globalise( extsym_( x ) );
	      
	      startcodetable( 4, symname_( extsym_( x ) ) );
	    }

#ifdef TARGET_IS_C40
	  export_function( extsym_( x ), R_ATMP );
#else
	  /*
	   * get the address of symbol 'x' into the register '_RADDR1'
	   */
	  
	  vr1.rr = R_ADDR1;
	  vr2.i  = 0;
	  vm.sym = extsym_( x );
	  
	  show_instruction( J_ADCON, vr1, vr2, vm );

	  /*
	   * store the address in the word pointed to by R_ATMP
	   * (which contains the address of the current module's
	   *  data area)
	   */
	  
	  vr2.rr = R_ATMP;
	  vm.i   = 0;
	  
	  show_instruction( J_STRK,  vr1, vr2, vm );

	  /*
	   * increase R_ATMP to point to the next word
	   */
	  
	  vr1.rr = R_ATMP;
	  vm.i   = sizeof_int;

	  show_instruction( J_ADDK,  vr1, vr2, vm );
#endif /* TARGET_IS_C40 */
	}
    }

  return;
  
} /* export_routines */

/*}}}*/
/*{{{ output_symbol */

static void
output_symbol(
	      Symstr *	sym,
	      int32	size )
{
  if (objstream)
    {
      if (sym != NULL)
        {
	  if (is_global( symext_( sym ) ))
	    globalise( sym );
        }
    }

  /* AM: NULL changed to "" next line Apr 89.  Why is sym ever 0? */

  startdata( size, sym ? symname_( sym ) : "" );

  return;
  
} /* output_symbol */

/*}}}*/
/*{{{ loopstart */

#ifndef TARGET_IS_C40 

static LabelNumber *
loopstart( int32 rpt )
{
  LabelNumber *	l;
  VRegInt	vr1;
  VRegInt	vr2;
  VRegInt	vm;


  vr1.rr = R_A1;
  vr2.r  = GAP;
  vm.i   = rpt;

  show_instruction( J_MOVK, vr1, vr2, vm );

  l = nextlabel();

  vr1.r = GAP;
  vm.l  = l;

  show_instruction( J_LABEL, vr1, vr2, vm );

  return l;
  
} /* loopstart */

/*}}}*/
/*{{{ loopend */

static void
loopend( LabelNumber * l )
{
  VRegInt vr1;
  VRegInt vr2;
  VRegInt vm;

  
  vr1.rr = vr2.rr = R_A1;
  vm.i   = 1;

  show_instruction( J_SUBK, vr1, vr2, vm );

  vr1.r = GAP;
  vm.i  = 0;

  show_instruction( J_CMPK + Q_NE, vr1, vr2, vm );

  vr2.r = GAP;
  vm.l  = l;

  show_instruction( J_B | Q_NE, vr1, vr2, vm );

  return;
  
} /* loopend */

#endif /* not TARGET_IS_C40 */

/*}}}*/
/*{{{ show_init_entry */

static void
show_init_entry( void )
{
  VRegInt	vr1, vr2, vm;


  datainitlab = nextlabel();

  /* XXX - turn off stack checking and back tracing in initialisation rouitnes */
  
  var_no_stack_checks   = 1;
#ifdef TARGET_IS_C40
  var_backtrace_enabled = 0;
#endif
  
  codebuf_reinit2();                  /* needed before show_inst etc. */
  
  localcg_reinit();
  
  if (objstream != NULL)
    {
      objbyte( OBJINIT );

      codesize += sizeof_int;      
    }
  
  asmf( ";\n; Data / Function Table Initialisation\n" );
  
  codebase += sizeof_int;

  /*
   * register usage not thought out here yet ...
   */

  regmask  = 0;            /* regbit(R_ADDR1); ??? */

#ifdef TARGET_IS_C40
  /* no registers used by init code ! */
  
  memclr( (VoidStar)&usedmaskvec, sizeof(RealRegSet) );
#endif

#ifdef TARGET_HAS_DEBUGGER
  /* no debugging for init code ! */
  
  usrdbgmask = 0;
#endif
  
  vr1.r = vr2.r = GAP;
  vm.i  = 0;
  
  procflags = 0;

  show_instruction( J_ENTER, vr1, vr2, vm );

  /*  show_instruction( J_MOVR, R_A2, GAP, R_DP ); (DP seem not to get corrupted) */
  
  if (split_module_table)
    {
#ifdef TARGET_IS_C40
      DataInit * p;


      /* see if we are going to have to initialise any data */
      
      for (p = datainitp; p != NULL; p = p->datacdr)
	if (p->sort != LIT_LABEL)
	  break;
      
      prepare_for_initialisation( p != NULL, datainitlab );

#else /* ! TARGET_IS_C40 */
      
      vr1.r  = GAP;
      vr2.rr = R_A1;
      vm.i   = 2;
      
      show_instruction( J_CMPK | Q_NE, vr1, vr2, vm );
      
      vr2.r = GAP;
      vm.l  = datainitlab;
      
      show_instruction( J_B | Q_NE, vr1, vr2, vm );

#endif /* TARGET_IS_C40 */
    }

#ifndef TARGET_IS_C40
  load_static_data_ptr( R_ATMP, split_module_table );
#endif
  
  return;
  
} /* show_init_entry */

/*}}}*/
/*{{{ show_init_return */

static void
show_init_return( void )
{
  VRegInt vr1, vr2, vm;


  /*  show_instruction( J_MOVR, R_DP, GAP, R_A2 );          */

  vr1.r = vr2.r = GAP;
  vm.l  = RETLAB;

  show_instruction( J_B | Q_AL, vr1, vr2, vm );

#ifndef TARGET_IS_C40  
  vm.i = 0;

  show_instruction( J_ENDPROC, vr1, vr2, vm );

  asm_lablist = NULL;

  show_code( 0 );
  
#endif /* not TARGET_IS_C40 */
  
  return;
  
} /* show_init_return */

/*}}}*/
/*{{{ IEEE convert */

#ifdef TARGET_IS_C40
/*
 * XXX - WARNING
 *
 * The following code is now highly C40 specific.
 * Subvert at your own risk
 */

/*{{{ IEEE_to_single_float */

/*
 * converts a 32 bit IEEE format floating point value into
 * a C40 format 32 bit floating point value
 */

int32
IEEE_to_single_float( int32 val )
{
  int32	e;
  int32	f;
  int32	s;

  
  /* extract components */
  
  e = (val >> 23) & 0xff;
  s = val & (1U << 31);
  f = val & ((1U << 23) - 1);

  /* decode - this algorithm is taken from the TMS320C4x User's Guide, page 4-12 */
  
  if (e == 0xff)
    {
      if (s == 0)
	{
	  e = 0x7f;
	  /* s = 0; */
	  f = 0x7fffff;
	}
      else
	{
	  e = 0x7f;
	  s = 1;
	  f = 0;
	}
    }
  else if (e == 0)
    {
      e = 0x80;
      s = 0;
      f = 0;
    }
  else
    {
      if (s == 0)
	{
	  e -= 0x7f;
	  /* s = 0; */
	  /* f = f; */
	}
      else
	{
	  if (f == 0)
	    {
	      e -= 0x80;
	      s  = 1;
	      /* f  = 0; */
	    }
	  else
	    {
	      e -= 0x7f;
	      s  = 1;
	      f  = ((~f) + 1);
	    }
	}
    }
  
  return (e << 24) | (s << 23) | (f & ((1 << 23) - 1));
  
} /* IEEE_to_single_float */

/*}}}*/
/*{{{ IEEE_to_extended_float */

/*
 * converts a 64 bit IEEE format number into a 40 bit C40 number
 * returns the most signifcant 32 bits of the result
 */

int32
IEEE_to_extended_float(
		       int32		high,		/* most  significant 32 bits of 64 bit IEEE number */
		       unsigned32	low,		/* least significant 32 bits of 64 bit IEEE number */
		       int32 *		low_return )  	/* least significant 32 bits of the result         */
{
  int32		e;
  unsigned32	f;
  unsigned32	s;


  /*
   * extract components
   *
   * IEEE double precision format is
   *
   *
   *    63 62          52 51                          0
   *    __ ______________ _____________________________
   *   |  |              |                             |
   *   |s | exponent     | mantissa                    |
   *   |__|______________|_____________________________|
   * or                              |
   *    31 30          20 19        0|31              0
   *                                 |
   *
   * C40 extended precision format is
   *
   *              39        32 31 30                 0
   *              ____________ __ ____________________
   *             |            |  |                    |
   *             | exponent   |s | mantissa           |
   *             |____________|__|____________________|
   *   
   */
  
  e = (high >> 20) & 0x7ff;
  s = high & (1U << 31);
  f = (high << (31 - 19)) | (low >> 20);

  /* debug( "converting IEEE number %x (high) %x (low), e = %x, s = %x, f = %x", high, low, e, s, f ); */
  
  /* decode - this algorithm is based on the one in the TMS320C4x User's Guide, page 4-12 */

  e -= 0x3ff;

  if (e > 127)
    {
      if (e < 0x3ff || f != 0xffffffffU)
	{
	  cc_warn( "floating point accuracy completely lost!" );
	}
		
      e = 0x7f;
	      
      if (s == 0)
	{
	  /* largest positive value */
	  
	  f = 0x7fffffffU;
	}
      else
	{
	  /* largest negative value */
	  
	  f = 0;
	}
    }
  else if (e == -1023)
    {
      e = 0x80;
      s = 0;
      f = 0;
    }
  else if (e < -128)
    {
      if (e != 0xfffff400U || f != 0x0U)
	{
	  cc_warn( "floating point accuracy completely lost! (e = 0x%lx, s = 0x%lx, f = 0x%lx)",
		  e + 0x3ff, s, f );
	}
		
      if (s == 0)
	{
	  /* smallest positive value */
	  
	  e = 0x81;	/* beware of 0.0 */
	  f = 0x0;
	}
      else
	{
	  /* smallest negative value */
	  
	  e = 0x80;
	  f = 0x7fffffffU;
	}
    }
  else
    {
      if (s != 0)
	{
	  if (f == 0)
	    {
	      e -= 1;
	    }
	  else
	    {
	      f = ((~f) + 1);
	    }
	}
    }

  /* debug( "after conversion, e = %x, s = %x, f = %x", e, s, f ); */
  
  if (low_return != NULL)
    {
      if (s == 0)
	{
	  /* round towards nearest */

	  if (!(++f))
	    ++e;
	  
	  *low_return = (f >> 1);
	}
      else
	{
	  /* already rounded when converting from two's complement */
	  
	  *low_return = (1U << 31) | (f >> 1);
	}
      
      /* debug( "low return = %x", *low_return ); */
    }

  if (s == 0)
    {
      return (e << 24) | ((f >> 9) & ((1 << 23) - 1));
    }
  else
    {
      return (e << 24) | (1 << 23) | ((f >> 9) & ((1 << 23) - 1));
    }
  
} /* IEEE_to_extended_float */

/*}}}*/

#endif /* TARGET_IS_C40 */
  

/*}}}*/
/*{{{ PHASED data generation */

#ifdef TARGET_IS_C40

/*{{{ Variables */

static int32		skip	     = 0;
static int32		block_size   = 0;
static unsigned32	curdsize     = 0;
static unsigned32	dataslot     = 0;
static unsigned32	old_dataslot = 0;
static unsigned32	words_out    = 0;
static ExtRef *		dsymb        = NULL;
static ExtRef *		curdsymb     = NULL;

/*}}}*/

/*{{{ init_phase */

/*
 * initialise the static variables, (and possibly
 * generate some code), at the start of a phase
 */

static void
init_phase(
	   int 		first_phase,	/* non-0 if this is the first phase */
	   ExtRef *	datasymbols,	/* pointer to the start of the list of data symbols */
	   bool		need_label )	/* non-0 if code will be generated, only valid during first phase */
{
  static LabelNumber *	l;

  
  if (first_phase)
    {
      if (need_label)
	{
	  l = nextlabel();
      
	  prepare_for_block_copying( l );
	}
      else
	{
	  l = NULL;
	}
      
      curdsize     = 0;
      dataslot	   = 0;
      old_dataslot = 0;

      dsymb        = datasymbols;
      curdsymb	   = NULL;
    }
  else
    {
      show_init_return();

      if (l)
	{
	  setlabel( l );

	  words_out = 0;
	}
      else
	{
	  words_out = 1;
	}
    }

  return;

} /* init_phase */

/*}}}*/
/*{{{ phase_export_block */

/*
 * Export a block of data.  The size of the
 * block is 'block_size' words.  The block's
 * source address is held in AR0 and the
 * block's destination address is in AR5
 */

static void
phase_export_block( void )
{
  if (block_size != 0)
    {
      block_copy_data( block_size );

      curdsize += block_size;
      
      block_size = 0;
    }

  return;
  
} /* phase_export_block */
  

/*}}}*/
/*{{{ phase_skip_block */

/*
 * Skip a block of zero data
 */

static void
phase_skip_block( void )
{
  if (skip)
    {
      VRegInt	vr1;
      VRegInt	vr2;
      VRegInt	vm;

	      
      vr1.rr = vr2.rr = R_ATMP;
      vm.i   = skip;
      
      show_instruction( J_ADDK, vr1, vr2, vm );

      curdsize += skip;
      
      skip = 0;
    }

  return;
  
} /* phase_skip_block */

/*}}}*/
/*{{{ phase_export_symbols */

/*
 * perform whatever actions are appropriate
 * so that the exported symbols are registered
 * with the linker
 */

static void
phase_export_symbols(
		     int 	first_phase,
		     int32	length,
		     int32	repeat )
{
  /*
   * Generate directives to allocate space
   * and a label for an exported data symbol
   */
	      
  if (first_phase)
    {
      /* if we have any exported data left */

      if (dsymb != NULL)
	{
	  int32	dataoff = dsymb->extoffset;
		  

	  /* have we reached the location of the next symbol to be exported  ? */
	  
	  if (dataslot == dataoff)
	    {
	      /* do we have a previous symbol to export ? */
	      
	      if (curdsymb != NULL)
		{
		  /*
		   * Export the previous symbol.
		   *
		   * The size of the symbol is not its own size, but
		   * distance between where it is defined and where
		   * the current symbol is defined.  This is because
		   * strings in the code segment must be copied into
		   * the data segment, but they do not have labels
		   * associated with them, and so no symbol is created
		   * for them.  Thus the space used by strings is
		   * amalgamated into the space used by the previous
		   * data symbol.
		   */

		  output_symbol( extsym_( curdsymb ), dataslot - old_dataslot );
		}

	      /* export all but the last symbol with this offset */
	      
	      for (; extcdr_( dsymb ) && extoffset_( extcdr_( dsymb ) ) == dataoff; dsymb = extcdr_( dsymb ) )
		{
		  output_symbol( extsym_( dsymb ), 0 );
		}

	      /* remember the last symbol at this offset, and the size of the data segment at this point */
	      
	      old_dataslot = dataslot;
	      curdsymb     = dsymb;

	      /* point to the next symbol in the list */
	      
	      dsymb = extcdr_( dsymb );

	      if (dsymb != NULL && extoffset_( dsymb ) < dataoff)
		{
		  syserr( heliobj_misplaced_offsets,
			 symname_( extsym_( dsymb ) ),    extoffset_( dsymb ),
			 symname_( extsym_( curdsymb ) ), extoffset_( curdsymb ) );
		}	      
	    }
	  else if (dataoff < dataslot)
	    {
	      /* oh dear - we have mislaid a symbol */

	      debug( "dataoff = %lx, dataslot = %lx", dataoff, dataslot );
	      
	      syserr( syserr_heliobj_dataseggen );
	    }
	}

      /* keep track of how much data has been generated */
      
      dataslot += length * repeat;
    }

  return;
  
} /* phase_export_symbols */
  

/*}}}*/
/*{{{ phase_store */

/*
 * perform whatever actions are appropriate for
 * storing the word 'value', 'repeat' times into
 * the data segment
 */

static void
phase_store(
	    int			first_phase,	/* non-0 iff this is the first phase 			*/
	    unsigned32		value,		/* the word to be stored in the data area 		*/
	    int32		repeat )	/* the number of times this word is to be stored	*/
{
  /* possibly export data symbols */
	      
  phase_export_symbols( first_phase, sizeof_long, repeat );
	      
  if (first_phase)
    {
      /* generate code to do the initialisation */

      if (value == 0)
	{
	  if (block_size != 0)
	    {
	      /*
	       * we have come to the end of a block of non-zero data,
	       * so generate the block
	       */
	      
	      phase_export_block();
	    }
	  	  
	  /* data area is pre-initialised to zero, so just skip over it */

	  skip += repeat;
	}
      else
	{
	  if (skip)
	    {
	      /*
	       * we are about to output some code, so adjust the destination
	       * pointer to allow for the blanks skipped
	       */

	      phase_skip_block();
	    }
	  
	  /*
	   * count the number of words to emit, and generate the code
	   * at the end of the block
	   */

	  block_size += repeat;
	}
    }
  else
    {
      if (value != 0)
	{
	  words_out = 1;
	  
	  while (repeat--)
	    {
	      outcodeword( value, LIT_NUMBER );
	    }
	}
    }

  return;
  
} /* phase_store */

/*}}}*/
/*{{{ phase_store_address_constant */

/*
 * perform whatever actions are appropriate for
 * storing an address constant into the data segment
 */

static void
phase_store_address_constant(
			     int	first_phase,	/* non-0 if this is the first phase		   */
			     Symstr *	symbol,		/* the symbols whoes address is to be stored	   */
			     int32	offset )	/* the offset to be added to this symbol's address */
{
  /* possibly export data symbols */
  
  phase_export_symbols( first_phase, sizeof_ptr, 1 );
	      
  if (first_phase)
    {
      if (skip)
	{
	  phase_skip_block();
	}
      
      if (block_size)
	{
	  phase_export_block();
	}

      export_data_symbol( symbol, offset, curdsize );

      curdsize++;
    }
  else
    {
      /* pretend we are storing 0, so that non-0 blocks are flushed */
      
      phase_store( first_phase, 0, 1 );
    }  

  return;
  
} /* phase_store_address_constant */

/*}}}*/
/*{{{ finish_phase */

static void
finish_phase(
	     int 	first_phase,	/* non-0 if this the end of the first phase */
	     bool	need_label )	/* non-0 if a label was needed */
{
  if (first_phase)
    {
      /* ignore any trailing skip */

      skip = 0;

      /* copy the last block, if there is one */
      
      if (block_size)
	{
	  phase_export_block();
	}

      /* if there is a remaining data symbol to export then do so */
      
      if (curdsymb)
	{
	  output_symbol( extsym_( curdsymb ), dataslot - old_dataslot );
	}
    }
  else
    {
      if (need_label && words_out == 0)
	{
	  /*
	   * we have generated a label, but we have
	   * not actually put any code to follow this
	   * label!  Hence we emit a dummy value, just
	   * to keep the object code formatter happy
	   */
	  
	  outcodeword( 0, LIT_NUMBER );
	}
    }  
  
  return;
  
} /* finish_phase */

/*}}}*/

#endif /* TARGET_IS_C40 */
  

/*}}}*/
/*{{{ insert_dlist */

/*
 * inserts the cross refence for the given data item into
 * the data list, maintaining the ordering of the list.
 */

static void
insert_dlist( ExtRef * x )
{
  ExtRef *	ptr;
  ExtRef *	prev = NULL;
  

  prev = NULL;
  
  for (ptr = datasymbols; ptr != NULL; ptr = ptr->extcdr)
    {
      if (ptr->extoffset > x->extoffset)
	{
	  /* insert before ptr */

	  if (prev == NULL)
	    {
	      x->extcdr = datasymbols->extcdr;
	      
	      datasymbols = x;
	    }
	  else
	    {
	      prev->extcdr = x;
	      x->extcdr    = ptr;
	    }
	  
	  return;	  
	}

      prev = ptr;
    }

  /* append to end of list */
  
  if (prev == NULL)
    {
      datasymbols = x;
    }
  else
    {
      prev->extcdr = x;
    }

  x->extcdr = NULL;
  
  return;
  
} /* insert_dlist */

/*}}}*/
/*{{{ export_functions */

#ifdef TARGET_IS_C40
static void
export_functions( void )
{
  ExtRef *	x;


  if (objstream == NULL)
    return;
  
  for (x = obj_symlist; x != NULL; x = extcdr_( x ) )
    {
      if (is_external_code( x ))
	{
	  globalise( extsym_( x ) );

	  if (
#ifdef TARGET_USES_NEW_STUBS
	      !new_stubs ||
#endif
	      usrdbg( DBG_ANY ))
	    startcodetable( 4, symname_( extsym_( x ) ) );
	}
    }

  return;
  
} /* export_functions */
#endif /* TARGET_IS_C40 */

/*}}}*/
/*{{{ dumpdata */

/*
 * generate code to initialise the module's static data area
 */

static void
dumpdata( void )
{
  static bool	inited  = FALSE;
  static long	big_end = FALSE;
  DataInit *	p;
  
#ifdef TARGET_IS_C40
  
  int		phase;
  bool		need_label;
  
#else
  
  ExtRef *	dsymb;
  ExtRef *	curdsymb    = NULL;
  int32		dataslot    = 0;
  int32		curdsize    = 0;
  int32		justloaded  = 0;
  bool		justvalid   = NO;
  VRegInt	vr1;
  VRegInt	vr2;
  VRegInt	vm;

#endif /* not TARGET_IS_C40 */

  
  if (datainitp == NULL && suppress_module)
    return;

  if (!inited)
    {
      int	a = 0x12345678;

	  
      if (((char *)&a)[ 0 ] == 0x12)
	{
	  big_end = TRUE;
	}

      inited = TRUE;
    }

  /* With any luck the symbols should be in obj_symlist in increasing */
  /* order so all I have to do is fetch the data symbols which are    */
  /* in obj_symlist and append them onto datasymbols to get them in   */
  /* the right order   (ascending order of extoffset)                 */
  
  /*
   * XXX - NC - 8/6/92
   *
   * Unfortunatelty this is not true.
   *
   * What can happen is that a symbol (X) is declared as external,
   * so it gains a place in the obj_symlist, with an offset of zero.
   * Other, normal symbols (Y, Z), are then declared, so they gain later
   * places in obj_symlist with increasing (non-zero) offsets.  Then the
   * external symbol (X) is in fact declared as being defined in the
   * current module!.  (Bad C practice, but legal).  This then gives
   * X a non-zero offset which is greater than Y or Z's, but with X
   * being declared before Y or Z in the obj_symlist.
   */

    {
      ExtRef **	flist;
      ExtRef *	x;
      
      
      datasymbols = NULL;
      flist       = &obj_symlist;

      /* scan linked list of symbols */
      
      for (x = obj_symlist; x != NULL;)
	{
	  ExtRef *	succ;

	  
	  succ = x->extcdr;

	  if (is_data( x ) && is_defined( x ))
	    {
	      /* insert data items into data list */
	      
	      insert_dlist( x );	      
	    }
	  else
	    {
	      /* append function names to function list (these are always sorted) */
	      
	      *flist = x;
	      flist  = &x->extcdr;
	    }

	  x = succ;	  
	}
    }
  
  /* At this point we generate the code to initialise the static data section. */

  codebuf_reinit2();
  
  show_init_entry();

#ifdef TARGET_IS_C40
/*{{{ C40 data exporting */

  if (
#ifdef TARGET_USES_NEW_STUBS
      new_stubs &&
#endif
      !usrdbg( DBG_ANY ))
    {
      export_functions();
    }
  else
    {
      if (!suppress_module)
	{
	  prepare_for_function_exporting();

	  /* generate a label for function address calculation */

	  if (asmstream != NULL)
	    {
	      flush_peepholer( "generating asm label" );
	      
	      exporting_routines = nextlabel();
	      
	      setlabel( exporting_routines );
	    }
	  
	  load_static_data_ptr( R_ATMP, split_module_table, NULL );

	  export_routines();
	}

      /*
       * XXX - beware of assumption of split_module_table == TRUE here
       */
  
      if (!suppress_module)
	{
	  VRegInt	vr1;
	  VRegInt	vr2;
	  VRegInt	vm;

      
	  vr1.r = vr2.r = GAP;
	  vm.l  = RETLAB;
      
	  show_instruction( J_B | Q_AL, vr1, vr2, vm );
	}
    }

  /*
   * scan the data list to see if we are going to have to produce
   * code for data initialisation
   */

  need_label = FALSE;
  phase      = -1;	/* flag used to inidicate if any data needs initialisation */
  
  for (p = datainitp; p != NULL; p = p->datacdr)
    {
      if (p->sort == LIT_LABEL)
	continue;

      phase = 0;	/* we are going to initialise data */
      
      if (p->sort == LIT_ADCON)
	continue;

      if (p->sort == LIT_FPNUM)
	{
	  if (p->len == sizeof_float && ((FloatCon *)p->val)->floatbin.fb.val == 0)
	    continue;

	  if (p->len == sizeof_double 		         &&
	      ((FloatCon *)p->val)->floatbin.db.msd == 0 &&
	      ((FloatCon *)p->val)->floatbin.db.lsd == 0  )
	    continue;

	  need_label = TRUE;
	  
	  break;
	}

      if (p->val != 0)
	{
	  need_label = TRUE;
	  
	  break;
	}
    }
      
  if (phase == 0)
    {
      setlabel( datainitlab );
      
      load_static_data_ptr( R_ATMP, NO, NULL );
	  
      prepare_for_data_exporting( R_ATMP );
  
      /*
       * scan the data list twice
       *
       * The first scan (or phase) generates code to block copy the data
       * from the code segment into the data segment, and to calculate
       * address constants.  The second phase generates word directives
       * to insert the data into the code segment.
       */
      
      for (phase = 2; phase--; )
	{
	  unsigned32	val;
	  
	  
	  init_phase( phase, datasymbols, need_label );
	  
	  if (big_end)
	    {
	      for (p = datainitp; p != NULL; p = p->datacdr)
		{
		  switch (p->sort)
		    {
		    case LIT_LABEL:
		      break;
		      
		    case LIT_ADCON:
		      if (p->rpt != 1)
			syserr( heliobj_repeated_symbol );
		      
		      phase_store_address_constant( phase, (Symstr *)p->len, p->val );
		      break;
		      
		    case LIT_BBBB:
		      val = p->val;
		      
		      val = ((val <<  8) & 0x00FF0000U) |
		            ((val >>  8) & 0x0000FF00U) |
			     (val >> 24)                |
			     (val << 24)                ;
		      
		      phase_store( phase, val, p->rpt );
		      
		      break;
		      
		    case LIT_BBH:
		      val = p->val;
		      phase_store( phase, (val << 16) | (val >> 24) | ((val >>  8) & 0x0000FF00U), p->rpt );
		      break;
		      
		    case LIT_HBB:
		      val = p->val;
		      phase_store( phase, (val >> 16) | (val << 24) | ((val <<  8) & 0x00FF0000U), p->rpt );
		      break;
		      
		    case LIT_HH:
		      val = p->val;		      
		      phase_store( phase, (val << 16) | (val >> 16), p->rpt );
		      break;
		      
		    case LIT_NUMBER:
		      phase_store( phase, p->val, p->rpt );
		      break;
		      
		    case LIT_FPNUM:
		      switch (p->len)
			{
			case sizeof_float:
			  phase_store( phase,
				      IEEE_to_single_float( ((FloatCon *)p->val)->floatbin.fb.val ),
				      p->rpt );
			  break;
			  
			case sizeof_double:		      
			  phase_store( phase,
				      IEEE_to_extended_float(
							     ((FloatCon *)p->val)->floatbin.db.msd,
							     ((FloatCon *)p->val)->floatbin.db.lsd,
							     (int32 *)&val ),
				      p->rpt );
			  phase_store( phase, val, p->rpt );
			  break;
			  
			default:
			  syserr( heliobj_bad_fp_number, p->len );
			  break;
			}
		      
		      break;
		      
		    default:
		      syserr( heliobj_unknown_data_type, p->sort );
		      break;
		    }
		}
	    }
	  else
	    {
	      for (p = datainitp; p != NULL; p = p->datacdr)
		{
		  switch (p->sort)
		    {
		    case LIT_LABEL:
		      break;
		      
		    case LIT_ADCON:
		      if (p->rpt != 1)
			syserr( heliobj_repeated_symbol );
		      
		      phase_store_address_constant( phase, (Symstr *)p->len, p->val );
		      break;
		      
		    case LIT_BBBB:
		    case LIT_BBH:
		    case LIT_HBB:
		    case LIT_HH:
		      if (p->len != sizeof_long)
			syserr( heliobj_bad_packed_length, p->len );
		      
		      phase_store( phase, p->val, p->rpt );
		      break;
		      
		    case LIT_NUMBER:
		      phase_store( phase, p->val, p->rpt );
		      break;
		      
		    case LIT_FPNUM:
		      switch (p->len)
			{
			case sizeof_float:
			  phase_store( phase,
				      IEEE_to_single_float( ((FloatCon *)p->val)->floatbin.fb.val ),
				      p->rpt );
			  break;
			  
			case sizeof_double:		      
			  phase_store( phase,
				      IEEE_to_extended_float(
							     ((FloatCon *)p->val)->floatbin.db.msd,
							     ((FloatCon *)p->val)->floatbin.db.lsd,
							     (int32 *)&val ),
				      p->rpt );
			  phase_store( phase, val, p->rpt );
			  break;
			  
			default:
			  syserr( heliobj_bad_fp_number, p->len );
			  break;
			}
		      break;
		      
		    default:
		      syserr( heliobj_unknown_data_type, p->sort );
		      break;
		    }
		}
	    }
	  
	  finish_phase( phase, need_label );
	}
    }
  
  finished_exporting();
  

/*}}}*/
#else  /* not TARGET_IS_C40 */
/*{{{ others data exporting */

  if (!suppress_module)
    export_routines();
  
  if (split_module_table)
    {
      vr1.r = vr2.r = GAP;
      vm.l  = RETLAB;

      show_instruction( J_B | Q_AL, vr1, vr2, vm );

      setlabel( datainitlab );

      load_static_data_ptr( R_ATMP, NO );
    }

  dsymb = datasymbols;
  
  for (p = datainitp; p != NULL; p = p->datacdr)
    {
      int32 		rpt  = p->rpt;
      int32		sort = p->sort;
      int32		len  = p->len;
      int32		val  = p->val;
      Symstr *		sv;
      FloatCon *	fc;
      LabelNumber *	l;


      if (sort == LIT_LABEL)
	continue;

      if (sort == LIT_ADCON)
	{
	  sv  = (Symstr *)len;
	  len = 4;
	}
      else
	sv = NULL;

      /* Generate the data space offset and label */

      if (dsymb != NULL)
        {
	  int32 	dataoff = dsymb->extoffset;


	  if (dataslot == dataoff)
	    {
              if (curdsymb != NULL)
		output_symbol( curdsymb->extsym, curdsize );
	      
              for (; dsymb->extcdr && dsymb->extcdr->extoffset == dataoff;
		   dsymb = dsymb->extcdr )
		output_symbol( dsymb->extsym, 0 );
	      
              curdsize = 0;
              curdsymb = dsymb;

              dsymb = dsymb->extcdr;
	    }
	  else if (dataoff < dataslot)
	    {
	      syserr( syserr_heliobj_dataseggen );
	    }
        }
      
      curdsize += len * rpt;

      /* Now generate the code to initialise the data */
      
      switch (sort)
        {
	default:
	  syserr( syserr_heliobj_gendata, (long)sort );
	  
	  /* the next 4 are the same as LIT_NUMBER except */
	  /* for (as yet unsupported) cross compilation.  */
	  
	  /* PAB 1/93 added support for cross compilation */
	  /* big endian host, little endian target        */
	  /* code not tested for BBH/HBB/HH combinations. */
	case LIT_BBBB:
	  if (big_end)
	    {
	      int32 x = val;

	      
	      val  =  x << 24;
	      val |= (x << 8 ) & 0x00ff0000;
	      val |= (x >> 8 ) & 0x0000ff00;
	      val |= (x >> 24) & 0x000000ff;
	    }
	  
	  goto	do_dump;

	case LIT_BBH:
	  if (big_end)
	    {
	      int32 x = val;

	      
	      val  =  x << 16;
	      val |= (x >> 8 ) & 0x0000ff00;
	      val |= (x >> 24) & 0x000000ff;
	    }

	  goto	do_dump;

	case LIT_HBB:
	  if (big_end)
	    {
	      int32 x = val;

	      
	      val  =  x << 24;
	      val |= (x << 8 ) & 0x00ff0000;
	      val |= (x >> 16 ) & 0x0000ffff;
	    }
	  
	  goto	do_dump;

	case LIT_HH:
	  if (big_end)
	    {
	      int32 x = val;

	      
	      val  =  x << 16;
	      val |= (x >> 16 ) & 0x0000ffff;
	    }

	  goto	do_dump;

	case LIT_NUMBER:
do_dump:
	  /* cc300+ codebuf.c ensures length == 4. */
	  
	  if (len != 4)
	    syserr( syserr_heliobj_datalen, (long)len );

	  if (val != 0)
	    {
	      if (!justvalid || justloaded != val)
		{
		  vr1.rr = R_DS;
		  vr2.r  = GAP;
		  vm.i   = val;

		  show_instruction( J_MOVK, vr1, vr2, vm );

		  justloaded = val;
		  justvalid  = YES;

		  /* Nothing else in the init code can disturb R_DS... */
		}
	      
	      if (rpt > 1)
		l = loopstart( rpt );
	      else
		l = NULL;
	      
	      vr1.rr = R_DS;
	      vr2.rr = R_ATMP;
	      vm.i   = 0;
	      
	      show_instruction( J_STRK, vr1, vr2, vm );
	      
	      vr1.rr = R_ATMP;
	      vm.i   = len;
	      
	      show_instruction( J_ADDK, vr1, vr2, vm );

	      if (rpt > 1)
		loopend( l );
	    }
	  else    /* val == 0 */
	    {
	      vr1.rr = vr2.rr = R_ATMP;
	      vm.i   = rpt * len;

	      show_instruction( J_ADDK, vr1, vr2, vm );
	    }

	  dataslot += rpt * len;
	  break;

	case LIT_FPNUM:
	  fc = (FloatCon *)val;

	  if (len != sizeof_float && len != sizeof_double)
	    syserr( syserr_heliobj_data, (long)rpt, (long)len, fc->floatstr );
	  
	  val = fc->floatbin.irep[ 0 ];

	  if (len == sizeof_double)
	    val |= fc->floatbin.irep[ 1 ];

	  if (val != 0)
	    {
	      vr1.rr = R_DS;
	      vr2.r  = GAP;
	      vm.i   = fc->floatbin.irep[ 0 ];

	      show_instruction( J_MOVK, vr1, vr2, vm );

	      if (len == 8)
		{
		  vr1.rr = R_ADDR1;
		  vr2.r  = GAP;
		  vm.i   = fc->floatbin.irep[ 1 ];

		  show_instruction( J_MOVK, vr1, vr2, vm );
		}
	    }

	  if (rpt > 1)
	    l = loopstart( rpt );
	  else
	    l = NULL;

	  if (val != 0)
	    {
	      vr1.rr = R_DS;
	      vr2.rr = R_ATMP;
	      vm.i   = 0;

	      show_instruction( J_STRK, vr1, vr2, vm );

	      if (len == 8)
		{
		  vr1.rr = R_ADDR1;
		  vr2.rr = R_ATMP;
		  vm.i   = 4;
		  
		  show_instruction( J_STRK, vr1, vr2, vm );
		}
	    }

	  vr1.rr = vr2.rr = R_ATMP;
	  vm.i   = len;

	  show_instruction( J_ADDK, vr1, vr2, vm );

	  if (rpt > 1)
	    loopend( l );

	  dataslot += rpt * len;

	  break;

	case LIT_ADCON:              /* (possibly external) name + offset */

	  vr1.rr = R_ADDR1;
	  vr2.i  = val;
	  vm.sym = sv;

	  show_instruction( J_ADCON, vr1, vr2, vm );

	  if (rpt > 1)
	    l = loopstart( rpt );
	  else
	    l = NULL;

	  vr1.rr = R_ADDR1;
	  vr2.rr = R_ATMP;
	  vm.i   = 0;
	  
	  show_instruction( J_STRK, vr1, vr2, vm );
	  
	  vr1.rr = R_ATMP;
	  vm.i   = len;
	  
	  show_instruction( J_ADDK, vr1, vr2, vm );
	  
	  if (rpt > 1)
	    loopend( l );

	  dataslot += rpt * len;
	  break;
        }
    }

  if (curdsymb)
    output_symbol( curdsymb->extsym, curdsize );

  show_init_return();

/*}}}*/
#endif /* not TARGET_IS_C40 */
  
  return;

} /* dumpdata */

/*}}}*/
/*{{{ align */

static void
align( void )
{
  int32		x = (int32)(sizeof_int - (codesize & (sizeof_int - 1)));
  

  /* Number of "bytes" to get to next multiple of word */

  if (x != sizeof_int) 
   {
     objbyte( OBJBSS );
     
     objnum( x );
     
     codesize += x;
   }

  return;
  
} /* align */

/*}}}*/
/*{{{ obj_symref */

int32
obj_symref(
	   Symstr *	s,
	   int 		flags,
	   int32 	loc )
{
  ExtRef *		x;


  if ((x = symext_( s )) == NULL)     /* if not already defined */
    {
      x = (ExtRef *)GlobAlloc( SU_Other, sizeof (ExtRef) );

      x->extcdr       = NULL;
      x->extsym       = s,
      x->extindex     = obj_symcount++,
      x->extflags     = 0,
      x->extoffset    = 0;
      
      *obj_symlistend = symext_( s ) = x;
      obj_symlistend  = &x->extcdr;
    }

  /*
   * It is critical that for Helios when I define a symbol the stub that
   * had (maybe) been set up for it gets deleted.  The syserr here can
   * be made recoverable with -zqz
   */

  if (is_defined_( flags ) &&
      is_defined( x ))
    {
      /*
       * XXX - NC - made into a serious error becuase can happen if a programmer
       * created two functions with the same name.  This is reported by the
       * compiler, and should not really generate a fatal error.
       */
	 
      cc_err( syserr_heliobj_2def, s );

      x->extflags &= ~xr_definition;
    }

  /* The next two lines cope with further ramifications of the abolition of */
  /* xr_refcode/refdata in favour of xr_code/data without xr_defloc/defext  */
  /* qualification.  This reduces the number of bits, but needs more        */
  /* checking in that a symbol defined as data, and then called via         */
  /* casting to a code pointer may acquire defloc+data and then get         */
  /* xr_code or'ed in.  Suffice it to say this causes confusion.            */
  /* AM wonders if gen.c ought to be more careful instead.                  */

  if (is_defined_( flags ))
    x->extflags &= ~(xr_code | xr_data);
  
  if (is_defined( x ))
    flags &= ~(xr_code | xr_data);
  
  /* end of fix.                                                             */
  
  x->extflags |= flags;
  
  if (is_defined_( flags ))
    {
      x->extoffset = loc;

      if (is_code( x ))          /* @@@@@@ flags ...? */
	{
	  /* the setting of xr_defloc/defext marks sym as implicitly     */
	  /* deleted from stublist.                                      */

 	  objlabel( '.', symname_( s ) );
	}
    }
  else if ((loc > 0) && !is_code_( flags ) && !is_defined( x ))
    {
      /* common data, not already defined */
      
      x->extoffset = loc;
    }

  /* The next line returns the offset of a function in the codesegment */
  /* if it has been previously defined -- this saves store on the arm  */
  /* and allows short branches on other machines.  Otherwise it        */
  /* returns -1 for undefined objects or data objects.                 */

  return (is_defined( x ) && is_code( x ) ? x->extoffset : -1);

} /* obj_symref */

/*}}}*/
/*{{{ obj_init */

void
obj_init( void )
{
  obj_symcount      = 0;
  obj_symlist       = NULL;
  obj_symlistend    = &obj_symlist;
  dataxrefs         = NULL;
  codexrefs         = NULL;
  global_symbols    = NULL;
  stublist          = NULL;
  in_stubs          = NO;
#ifdef TARGET_USES_NEW_STUBS
  stub_symbols      = NULL;
  addr_stub_symbols = NULL;
#endif
  
  return;
  
} /* obj_init */

/*}}}*/
/*{{{ obj_header */

void
obj_header( void )
{
#ifdef TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_ANY ))
    db_init( sourcefile );
#endif
  
  if (!suppress_module)
    {
      char	sname[ 40 ];
      char *	ptr;      
      int 	len;


      if ((ptr = strrchr( sourcefile, '/' )) != NULL)	/* skip past path components in source name */
	++ptr;
      else
	ptr = sourcefile;
      
      len = strlen( ptr ) - 31;
      
      if (len < 0)
	len = 0;
      
      strcpy( sname, ptr + len );
      
      len = strlen( sname );

      objbyte( OBJMODULE );
      
      objnum( -1 );

      startcode( (int32)offsetof( Module, Name ) + len );
      
      objword( T_Module );

      codesizepos = ftell( objstream );
      
      objword( 0 );

      fputs( sname, objstream );

      objbyte( OBJBSS );
      
      objnum( 32L - len );

      objbyte( OBJWORD );
      
      objbyte( OBJMODNUM );

      startcode( offsetof( Module, Init ) - offsetof( Module, Version ) );

	{
	  int ver;

	  
	  /*
	   * The version number here is a bit dodgy, but I need a single number
	   * and this may be as good as any other that I can invent.
	   */

	  sscanf( MIP_VERSION, "%d", &ver );
	  
	  objword( (int32)ver );
	}
      
      datasizepos = ftell( objstream );
      
      objword( 0 );

      objbyte( OBJINIT );
      
      codesize = sizeof (Module);

      if (split_module_table)
	{
	  startcode( 4 );
	
	  maxcodeppos = ftell( objstream );
	
	  objword( 0 );	  
	}
      else
	{
	  codesize -= sizeof (int32);
	}      
    }

  return;
  
} /* obj_header */

/*}}}*/
/*{{{ obj_makestubs */

void
obj_makestubs( void )          /* maybe this fn is part of flowgraf.c? */
{
  if (!suppress_module)
    {
      procflags = 0;          /* certainly these are owned elsewhere  */
      regmask   = 0;          /* I think the solution is connected to */
                              /* the fact that obj_symref is NOT      */      
      show_stubs();
      
      /* AM: I now think that for each helios extern symbol we should have  */
      /* two Symstr's.  (Either with the same name by avoiding hashing or   */
      /* by prefixing the real extern with '.' or such like, which asm and  */
      /* obj then remove to make the world sweet.)                          */
      /* This forgeing at the JOPCODE level seems a bit fraught.            */
    }

  if (suppress_module != 1)
    {
      padstatic( 4 );       /* @@@@@@ flush vg_wbuff, beware call in cg.c  */
                            /* @@@@@@ rationalise soon.                    */
      dumpdata();

#ifdef TARGET_IS_C40
      asmf( ";       align 128\n" );
#endif
      asmf( "        init\n" );
      
      show_code( NULL );

      asm_lablist = NULL;
    }

  return;
  
} /* obj_makestubs */

/*}}}*/
/*{{{ obj_trailer */

void
obj_trailer( void )
{
#ifdef TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_ANY ))
    db_tidy();
#endif
  
  if (!suppress_module)
   {
     align();

     dumpglobals();

#ifdef TARGET_USES_NEW_STUBS
     if (new_stubs)
       dump_new_stubs();
#endif
     
     if (fseek( objstream, codesizepos, SEEK_SET ) == -1)
       {
	 cc_err( "Failed to seek to start of file to set code size, errno = %d", errno );

	 return;	 
       }

     objword( codesize );

     if (fseek( objstream, datasizepos, SEEK_SET ) == -1)
       {
	 cc_err( "Failed to seek to start of file to set data size, errno = %d", errno );

	 return;	 
       }     
     
     if (split_module_table)
       {
	 objword( datasize );

#ifdef TARGET_USES_NEW_STUBS
	 if (!new_stubs || usrdbg( DBG_ANY ))
#endif
	   {
	     if (fseek( objstream, maxcodeppos, SEEK_SET ) == -1)
	       {
		 cc_err( "Failed to seek to start of file to set max code size, errno = %d", errno );

		 return;
	       }

	     objword( maxcodep );
	   }	 
       }
     else
       {
	 objword( datasize + maxcodep );
       }
   }

  return;
  
} /* obj_trailer */

/*}}}*/

/*}}}*/

/* End of heliobj.c */

@


1.94
log
@minor tidies
@
text
@d19 1
a20 2
/*{{{ Header Files */

d57 18
d177 2
a184 3
#ifndef TARGET_IS_C40
DataXref *		dataxrefs = NULL;
#endif
d188 1
d191 1
d250 1
a250 1
  val = ((x >> 24) & 0xff);
d254 1
a254 1
  val = ((x >> 16) & 0xff);
d258 1
a258 1
  val = ((x >> 8) & 0xff);
d262 1
a262 1
  val = (x & 0xff);
d332 1
a332 1
    
d337 1
a337 1

d348 1
a348 1
 dumpglobals( void )
d352 1
a352 1
  
d356 1
a356 1
      
d1157 2
a1158 2
	      if (c->codexrcode > 0xffffff)
		cc_warn( heliobj_warn_24bits, (long)c->codexrcode );
d1286 1
a1286 1
  
d1291 1
a1291 1
      if (((Symstr *)((int32)(s->stubsym) & ~(1 << 31))) == name)
d1324 1
a1324 1
  
d1328 1
a1328 1
    if (((Symstr *)((int32)(s->stubsym) & ~(1 << 31))) == name)
d1333 1
a1333 1
  stublist = (Stub *)global_cons2( SU_Other, stublist, ((int32) name | (1 << 31)) );
a1364 3
#ifdef TARGET_IS_ARM
      entry_fudge = YES;
#else
a1365 1
#endif
d1367 1
a1367 5
      show_instruction( J_ENTER, vr1, vr2, vm );
      
#ifdef TARGET_IS_ARM
      entry_fudge = NO;
#endif
d1369 1
a1369 1
  
a1373 1

d1382 1
a1382 7
      if (((int32)sym & (1 << 31)) != 0)
	{
	  sym = (Symstr *)((int32)sym & ~(1 << 31)) ; /* clear the flag bit */
	 
	  in_exceptional_stub = YES ;	/* special stub case */
	}
      else
d1384 1
a1384 1
	  in_exceptional_stub = NO ;	/* normal stub */
d1464 2
a1465 2
  
  for (x = obj_symlist; x != NULL; x = x->extcdr)
d1471 1
a1471 1
	      globalise( x->extsym );
d1473 1
a1473 1
	      startcodetable( 4, symname_( x->extsym ) );
d1477 1
a1477 1
	  export_function( x->extsym, R_ATMP );
d1485 1
a1485 1
	  vm.sym = x->extsym;
d1529 1
a1529 3
	    {
	      globalise( sym );
	    }	  
a1657 4
#ifdef TARGET_IS_ARM
  entry_fudge = YES;
#endif

a1661 4
#ifdef TARGET_IS_ARM
   entry_fudge = NO;
#endif
  
d1973 1
a1973 1
#endif /* TARGET_IS_C40
d2003 1
a2003 1
	   bool 	first_phase,	/* non-0 if this is the first phase */
d2119 1
a2119 1
		     bool 	first_phase,
d2159 1
a2159 1
		  output_symbol( curdsymb->extsym, dataslot - old_dataslot );
d2164 1
a2164 1
	      for (; dsymb->extcdr && dsymb->extcdr->extoffset == dataoff; dsymb = dsymb->extcdr )
d2166 1
a2166 1
		  output_symbol( dsymb->extsym, 0 );
d2176 1
a2176 1
	      dsymb = dsymb->extcdr;
d2178 1
a2178 1
	      if (dsymb != NULL && dsymb->extoffset < dataoff)
d2180 3
a2182 3
		  syserr( "heliobj: symbol %s has offset %ld and follows symbol %s with offset %ld",
			 symname_( dsymb->extsym ), dsymb->extoffset,
			 symname_( curdsymb->extsym ), curdsymb->extoffset );
d2216 1
a2216 1
	    bool		first_phase,	/* non-0 iff this is the first phase 			*/
d2291 1
a2291 1
			     bool	first_phase,	/* TRUE if this is the first phase		   */
d2331 1
a2331 1
	     bool 	first_phase,	/* TRUE if this the end of the first phase */
d2351 1
a2351 1
	  output_symbol( curdsymb->extsym, dataslot - old_dataslot );
d2439 1
d2449 1
a2449 1
  for (x = obj_symlist; x != NULL; x = x->extcdr )
d2453 1
a2453 1
	  globalise( x->extsym );
d2460 1
a2460 1
	    startcodetable( 4, symname_( x->extsym ) );
d2467 1
d2490 1
a2490 2
  ExtRef *	datasymbols = NULL;
  ExtRef *	dsymb       = datasymbols;
d2501 1
a2502 1

d2555 1
a2555 1
	  
d2581 2
d2707 1
a2707 1
			syserr( "heliobj: cannot (yet) repeatedly export the same symbol" );
d2763 1
a2763 1
			  syserr( "heliobj: bad size of floating point number %ld", p->len );
d2770 1
a2770 1
		      syserr( "heliobj: unknown data type %lx", p->sort );
d2786 1
a2786 1
			syserr( "heliobj: cannot (yet) repeatedly export the same symbol" );
d2796 1
a2796 1
			syserr( "heliobj: bad length for packed data (%ld)", p->len );
d2825 1
a2825 1
			  syserr( "heliobj: bad size of floating point number %ld", p->len );
d2831 1
a2831 1
		      syserr( "heliobj: unknown data type %lx", p->sort );
d2843 2
d2846 2
a2847 1
  
d2863 3
a2865 1
  for ( p = datainitp; p != NULL; p = p->datacdr)
d2932 1
a2932 1
	      int x = val;
d2946 1
a2946 1
	      int x = val;
d2959 1
a2959 1
	      int x = val;
d2972 1
a2972 1
	      int x = val;
d3134 2
a3135 1
  
d3177 1
a3177 1
  
d3191 1
a3191 1
  
a3276 4
#ifdef TARGET_IS_ARM
  in_exceptional_stub = NO ; /* JGS: 910213 */
#endif /* TARGET_IS_ARM */
  
a3458 1
	 if (
d3460 1
a3460 1
	     !new_stubs ||
a3461 1
	     usrdbg( DBG_ANY ))
@


1.93
log
@fixed compile time warnings
@
text
@d3 1
a3 1
 * Copyright (C) Perihelion Software Ltd, 1988 - 1992
d6 1
d29 1
a37 1
#include <errno.h>
d51 1
d53 1
d62 4
d77 1
a77 1
#define OBJCODESYMB   	0x0d		/* was funcref */
d79 2
a80 2
#define OBJLABELREF   	0x0f
#define OBJDATASYMB   	0x10		/* was dataref */
d108 2
a109 2
#ifdef __HELIOSARM
#define PATHCARMLDR    0x15		/* aka armdt		*/
d133 3
d138 1
a159 1
FILE *			objstream;
a161 1
int 			suppress_module;
d163 2
d166 3
d198 1
a198 1
  
d200 1
a200 1

d212 1
a212 1

d217 1
a217 1

d221 1
a221 1

d225 1
a225 1

d235 1
a235 1

d237 1
a237 1

d239 1
a239 1

d243 1
a243 1

d245 1
a245 1

d247 1
a247 1
   
d249 1
a249 1

d265 1
a265 1

d268 1
a268 1

d272 1
a272 1

d276 1
a276 1

d279 1
a279 1

d281 1
a281 1

d284 1
a284 1

d298 2
a300 2
  fputs( s, objstream );

d302 1
a302 1

d314 2
a315 2


d319 1
a319 1
  
d321 1
a321 1

d330 1
a330 1
dumpglobals( void )
d333 2
a334 2


d339 1
d343 1
d346 1
a346 1

d354 2
d360 2
a361 2


d367 1
a367 1

d372 2
d376 1
a376 1

d381 2
a382 2


d388 1
a388 1

d392 1
a392 1

d395 1
a395 1

d400 2
a401 2


d407 1
a407 1

d412 1
a412 1

d420 1
a420 1

d431 1
a431 1

d435 1
a435 1

d485 1
a485 1
	
d496 5
a500 2
	  objbyte( new_stubs ? OBJCODESTUB :
		               OBJLABELREF );	/* ... the offset of ... */
d509 1
a509 1

d521 5
a525 2
	  objbyte( new_stubs ? OBJCODESTUB :
		               OBJLABELREF );	/* ... the offset of ... */
d534 1
a534 1
            
d545 1
a545 1

d550 1
a550 1
       
d556 5
a560 2
      objbyte( new_stubs ? OBJCODESTUB :
	                   OBJLABELREF );	/* ... the offset of ... */
d565 1
a565 1

d568 1
a568 1
	                     PATCHC40MASK16ADD );/* ... adding into the bottom 8 or 16 bits of... */	
d586 1
a586 1

d601 1
a601 1

d609 1
a609 1

d617 1
a617 1

d644 1
a644 1

d665 1
a665 1

d667 1
a667 1

d708 1
a708 1

d715 1
a715 1

d785 1
a785 1

d791 1
a791 1

d815 2
a816 2
      objbyte( OBJARMLDR );       /* Only format used is LDR xx, [dp, #modnum] */
      objnum( code );
d818 1
a818 1
      objnum( split_module_table ? 3 : 2 );
d825 2
a826 2
      objbyte( OBJARMBL );
      objnum( code );
d828 1
d834 2
a835 2
      objbyte( OBJARMADDLO );
      objnum( code );
d837 1
d843 2
a844 2
      objbyte( OBJARMADDLO );
      objnum( code );
d846 1
d852 2
a853 2
      objbyte( OBJARMADDHI );
      objnum( code );
d855 1
d861 2
a862 2
      objbyte( OBJARMADDHI );
      objnum( code );
d864 1
d870 1
a870 1
      objbyte( OBJARMADDMID );
d873 1
d879 2
a880 2
      objbyte( OBJARMLDR );
      objnum( code );
d882 1
d888 2
a889 2
      objbyte( OBJARMLDR );
      objnum( code );
d891 1
d1051 2
a1052 2


a1159 1
	    case X_DataAddr:
d1168 1
d1256 1
a1256 1
  use( name );
d1276 1
a1276 1
#else /* TARGET_IS_ARM */
d1307 1
a1307 1
    /* JGS: 910213 : Deal with our special exception stubs */
d1315 1
a1315 1
  stublist = (Stub *)global_cons2( SU_Other, stublist, ((int32)name | (1 << 31)));
d1333 1
d1335 1
d1339 1
a1339 1
      in_stubs = 1;
d1361 2
a1362 2
   {
     Symstr *	sym = s->stubsym;
d1366 6
a1371 6
     /* JGS: 910213
      *	We have encoded the exceptional flag in the top bit of the symbol
      * pointer. This assumes things about the environment the compiler
      *	is executing under. If we are an exceptional stub, we should generate
      *	code that preserve all the registers over the stub call.
      */
d1373 3
a1375 3
     if (((int32)sym & (1 << 31)) != 0)
       {
	 sym = (Symstr *)((int32)sym & ~(1 << 31)) ; /* clear the flag bit */
d1377 2
a1378 2
	 in_exceptional_stub = 1 ;	/* special stub case */
       }
d1381 1
a1381 1
	  in_exceptional_stub = 0 ;	/* normal stub */
d1385 3
a1387 3
     if (!is_defined( symext_( sym ) ))
       {
	 if (debugging( DEBUG_OBJ ))
d1389 7
a1395 6

	 if (new_stubs)
	   {
	     /*
	      * If 'sym' is not defined locally then make it global
	      */
d1397 13
a1409 12
	     request_new_stub( sym );
	   }
	 else
	   {
	     /*
	      * CGS: Changed from show_entry because that makes the symbol defined.
	      * I do not want it defined because when we come to do the init sequence
	      * it will think that the label is defined and would put a pointer
	      * to the stub into the data area. (viz. X problem).
	      * All we do is define the label to the linker and let that worry about
	      * patching up the forward references from the code.
	      */
d1411 1
a1411 1
	     show_entry( sym, xr_code | xr_defloc ); /* really a call to obj_symref */
d1413 1
a1413 1
	     objlabel( '.', symname_( sym ) );
d1416 4
a1419 4
	     /*
	      * Note that the two values passed in the r1 and r2 fields here are a
	      * bit suspect, but something is certainly needed...
	      */
d1421 2
a1422 2
	     /* Beware the sym on the next line -- it probably needs to be a      */
	     /* slighly different Symstr.                                         */
d1424 3
a1426 3
	     vr1.rr = R_A1;
	     vr2.i  = 0;
	     vm.sym = sym;
d1428 1
a1428 8
	     /*
	      * indicate that the following instruction marks the
	      * end of the stub, and so the NOPs that follow it
	      * are candidates for removal by the linker
	      * (This code is all to do with generating
	      * calling stubs, see load_address_constant() for
	      * more information)
	      */
d1430 15
a1444 13
	     show_instruction( J_TAILCALLK, vr1, vr2, vm );
	     
	     vr1.r = vr2.r = GAP;
	     vm.i  = 0;
	     
	     show_instruction( J_ENDPROC, vr1, vr2, vm );
	     
	     show_code( sym );
	     
	     asm_lablist = NULL;
	   }
       }
   }
a1445 2
  in_stubs = 0;

d1462 1
a1462 1
  for (x = obj_symlist; x != NULL; x = x->extcdr )
d1526 3
a1528 1
	    globalise( sym );
d1541 63
d1617 1
d1619 1
d1642 1
d1646 1
d1648 1
d1652 1
d1695 1
a1695 1
	  
d1701 4
a1723 4
  
  return;
  
} /* show_init_return */
d1725 2
a1726 2
/*}}}*/
/*{{{ add_data_stubs */
d1728 1
a1728 1
#ifdef NOT_USED
d1730 1
a1730 2
/* We also have to generate stubs for the variables which are      */
/* initialised to point to functions not defined in this module.   */
d1732 3
a1734 5
static void
add_data_stubs( void )
{
  DataInit *	p;

a1735 14
  for (p = datainitp; p != 0; p = p->datacdr)
    {
      if (p->sort == LIT_ADCON)
	{
	  Symstr *	sym = (Symstr *)p->len;
	  ExtRef *	x   = symext_( sym );

	  
	  if (is_function( sym ) && /* redo */
	      !is_defined( x ))
	    request_stub( sym );
	}
    }

d1738 1
a1738 2
} /* add_data_stubs */
#endif /* NOT_USED */
d1743 1
d1980 3
d1986 2
d2010 1
a2010 1
	   int 		first_phase,	/* non-0 if this is the first phase */
d2126 1
a2126 1
		     int 	first_phase,
d2223 1
a2223 1
	    int			first_phase,	/* non-0 iff this is the first phase 			*/
d2298 1
a2298 1
			     int	first_phase,	/* non-0 if this is the first phase		   */
d2338 1
a2338 1
	     int 	first_phase,	/* non-0 if this the end of the first phase */
d2382 3
d2461 5
a2465 1
	  if (!new_stubs || usrdbg( DBG_ANY ))
a2485 3
#if 0
  ExtRef **	dsend;
#endif
d2487 3
d2493 15
d2580 1
a2580 2
  /* At this point we generate the code to initialise the static data */
  /* section. */
d2586 6
a2591 1
  if (new_stubs && !usrdbg( DBG_ANY ))
d2720 3
a2722 3
		        ((val >>  8) & 0x0000FF00U) |
			  (val >> 24)                |
			    (val << 24)                ;
d2846 282
d3129 7
d3175 1
a3175 1

a3179 1
      
d3200 1
a3200 1
       * XXX - NC - made into a serious error becuase can happen if programmer
d3223 1
a3223 1

d3268 3
d3273 1
a3273 2
  stublist          = NULL;
  in_stubs          = 0;
d3276 1
a3276 1
  in_exceptional_stub = 0 ; /* JGS: 910213 */
d3389 1
a3389 3
                              /* the fact that obj_symref is NOT      */
      /*      add_data_stubs();*/       /* really part of xxxobj.c              */
      
d3405 1
d3407 1
d3436 1
d3439 1
d3461 5
a3465 1
	 if (!new_stubs || usrdbg( DBG_ANY ))
@


1.92
log
@upgraded with (some) 68K changes and added folding
@
text
@d683 1
d2094 1
a2094 1
		  syserr( "heliobj: symbol %s has offset %d and follows symbol %s with offset %d",
d2648 1
a2648 1
			  syserr( "heliobj: bad size of floating point number %d", p->len );
d2655 1
a2655 1
		      syserr( "heliobj: unknown data type %x", p->sort );
d2681 1
a2681 1
			syserr( "heliobj: bad length for packed data (%d)", p->len );
d2710 1
a2710 1
			  syserr( "heliobj: bad size of floating point number %d", p->len );
d2716 1
a2716 1
		      syserr( "heliobj: unknown data type %x", p->sort );
@


1.91
log
@fixed debugger support to produce code table initialisation code
@
text
@d4 2
a5 2
 * adapted by Codemist Ltd, 1989
 * tidied up by NC 1991-1992
d19 2
d33 1
a33 8
#ifndef __SMT
#define __SMT
#endif

#ifndef __C40
#define __C40
#endif

a34 1
#include </hsrc/include/helios.h>
d37 1
d52 3
d59 2
a60 1

d71 1
a71 1
#define OBJMODSIZE  	0x0e
d121 10
d146 3
a151 1
DataXref *		dataxrefs;
a155 1

d168 4
d173 1
d181 1
a181 1

d191 2
d240 2
d275 2
d293 2
d312 2
d335 2
d354 2
d373 2
d416 2
d420 1
a420 1
 * this functions handles the cross reference directive 'xrtype'
d430 4
a442 1
#if defined TARGET_IS_C40
d455 2
a456 6

      if (few_modules)
	objbyte( PATCHC40MASK8ADD );		/* ... adding into the bottom 8 bits of ... */
      else
	objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
      
a457 1

a460 1
      
a462 1
      
d464 1
a464 2
      
      return sizeof_int;
a465 27
#elif defined TARGET_IS_68000 || defined TARGET_IS_68020
      
      objbyte( OBJSHORT );
      objbyte( PATCHSHIFT );
      objnum( split_module_table ? 3 : 2 );
      objbyte( OBJMODNUM );
      
      return 2;
      
#elif defined TARGET_IS_ARM
      
      objbyte( OBJWORD );
      /*
       * For module numbers I will stick to 12 bit offsets for now.
       */
      objbyte( OBJARMLDR );       /* Only format used is LDR xx, [dp, #modnum] */
      objnum( code );
      objbyte( PATCHSHIFT );
      objnum( split_module_table ? 3 : 2 );
      objbyte( OBJMODNUM );
      
      return 4;
#else
  #error unknown target
#endif

#if defined TARGET_IS_C40
a467 1

a468 1

a469 1

a470 1

a471 1
      
a472 1

a473 1

d476 2
a477 5
	  if (new_stubs)
	    objbyte( OBJCODESTUB );		/* ... the offset of ... */
	  else
	    objbyte( OBJLABELREF );		/* ... the offset of ... */

d482 2
a483 3
	  objbyte( OBJLABELREF );		/* ... the offset of ... */
	  
	  objsymbol( '_', symname_( sym ) );	/* ... the symbol */
d485 1
a485 2

      return sizeof_int;
a489 1

a490 1

a491 1

a492 1

a493 1

a494 1

a495 1
      
d498 2
a499 5
	  if (new_stubs)
	    objbyte( OBJCODESTUB );		/* ... the offset of ... */
	  else
	    objbyte( OBJLABELREF );		/* ... the offset of ... */

d504 2
a505 3
	  objbyte( OBJLABELREF );		/* ... the offset of ... */
	  
	  objsymbol( '_', symname_( sym ) );	/* ... the symbol */
d507 1
a507 2

      return sizeof_int;
a510 1

a511 1

a512 1

a513 1

a514 1
      
a515 1

a516 1
      
d518 1
a519 4
      return sizeof_int;

#endif /* TARGET_IS_C40 */
      
a520 2
#if defined TARGET_IS_C40

a525 1

a526 1

a527 1

a528 1

d530 2
a531 6
      
      if (new_stubs)
	objbyte( OBJCODESTUB );			/* ... the offset of ... */
      else
	objbyte( OBJLABELREF );			/* ... the offset of ... */

d533 1
a533 126

      return sizeof_int;
      
#elif defined TARGET_IS_68000 || defined TARGET_IS_68020
      
      objbyte( OBJSHORT );
	
      if (code != 0)
	{
	  objbyte( PATCHADD );
	  
	  objnum( code );
	}

      if (xrtype == X_PCreloc)
	{
	  objbyte( OBJLABELREF );
	  
	  objsymbol( '.', symname_( sym ) );
	}
      else
	{
	  objbyte( OBJDATASYMB );
	    
	  objsymbol( '_', symname_( sym ) );
	}
	
      return 2;
      
#elif defined TARGET_IS_ARM
      
      objbyte( OBJWORD );
	  
      if (xrtype == X_PCreloc)
	{
	  objbyte( OBJARMBL );
	  
	  objnum( code );
	  
	  objbyte( OBJLABELREF );
	  
	  objsymbol( '.', symname_( sym ) );
	}
      else
	{
	  objbyte( OBJARMLDR );
	  
	  objnum( code );
	      
	  objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
	      
	  objsymbol( '_', symname_( sym ) );
	}
	  
      return 4;
#else
  #error unknown target
#endif

#ifdef TARGET_IS_ARM
    case X_PCreloc2:                /* Patch an ADD instruction */
    case X_DataSymb2:
      objbyte( OBJWORD );
	 
      if (xrtype == X_PCreloc2)
	{
	  objbyte( OBJARMADDLO );
	  
	  objnum( code );
	  
	  objbyte( OBJLABELREF );
	  
	  objsymbol( '.', symname_( sym ) );
	}
      else
	{
	  objbyte( OBJARMADDLO );
	     
	  objnum( code );
	     
	  objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
	     
	  objsymbol( '_', symname_( sym ) );
	}

      return 4;

    case X_PCreloc3:                /* Patch an ADD instruction */
    case X_DataSymb3:
      
      objbyte( OBJWORD );
	  
      if (xrtype == X_PCreloc3)
	{
	  objbyte( OBJARMADDHI );
	  
	  objnum( code );
	  
	  objbyte( OBJLABELREF );
	  
	  objsymbol( '.', symname_( sym ) );
	}
      else
	{
	  objbyte( OBJARMADDHI );
	  
	  objnum( code );
	  
	  objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
	  
	  objsymbol( '_', symname_( sym ) );
	}

      return 4;

    case X_DataSymb6:

      objbyte( OBJWORD );
	  
      objbyte( OBJARMADDMID );
	  
      objnum(  code );
	  
      objbyte( split_module_table && is_function( sym ) ? OBJCODESYMB : OBJDATASYMB );
      
      objsymbol( '_', symname_( sym ) );
a534 4
      return 4;

#endif /* TARGET_IS_ARM */

a536 4
      /*    globalise(sym); */

#if defined TARGET_IS_C40

d538 2
a539 6

      if (few_modules)
	objbyte( PATCHC40MASK8ADD );		/* ... adding into the bottom 8 bits of... */	
      else
	objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of... */
      
a540 1

a541 1
      
a542 1
      
a543 1

d545 1
d547 1
a547 17
      return sizeof_int;
      
#elif defined TARGET_IS_68000 || defined TARGET_IS_68020
      
      objbyte( OBJSHORT );
      
      objbyte( OBJDATAMODULE );
      
      objsymbol( '_', symname_( sym ) );
      
      return 2;
      
#elif defined TARGET_IS_ARM
      
      objbyte( OBJWORD );
      
      objbyte( OBJARMLDR );
a548 11
      objnum( code );
      
      objbyte( OBJDATAMODULE );
      
      objsymbol( '_', symname_( sym ) );
      
      return 4;
#endif

#if defined TARGET_IS_C40
    case X_DataModule1:
a549 1
      
a550 1
      
a551 1

a552 1

a553 1
	
a554 1
      
d556 1
a556 2
      
      return sizeof_int;
d559 1
a560 1
      
a561 1
      
a562 1

a565 1

d568 4
a571 13
      
      if (split_module_table)
	{
	  objbyte( OBJCODESYMB );		/* ... the offset into the module of the function ... */
	}
      else					/* ... or ... */
	{	  
	  objbyte( OBJDATASYMB );		/* ... the offset into the module of the datum ... */
	}
      
      objsymbol( '_', symname_( sym ) );	/* ... specified by symbol */
      
      return sizeof_int;
d574 1
a575 1
      
a576 1
      
a577 1

d579 1
a579 2
            
      return sizeof_int;
d582 1
a583 1
      
a584 1
      
d586 2
a587 4

      objbyte( OBJMODNUM );			/* ... another dummy value */
            
      return sizeof_int;
d590 1
a591 1
      
a592 1
      
a593 1

d595 2
a596 3
            
      return sizeof_int;

d598 1
a599 1
      
a600 1

a601 1

a602 1

a605 1
      
a610 1
      
a612 1
      
d614 1
a614 2
      
      return sizeof_int;
d617 1
a618 1
      
a619 1
      
a620 1

a621 1

a622 1
      
a623 1

a626 1
      
a631 1
      
a633 1
      
d635 1
a635 2
      
      return sizeof_int;
d638 1
a639 1

a640 1
      
a641 1
     
a642 1
      
a643 1
      
a651 1
      
d653 1
a654 4
      return sizeof_int;

#endif /* TARGET_IS_C40 */

a657 1

d659 1
a660 2
      return sizeof_int;
      
d663 2
a664 10

      if (split_module_table)
	{
	  objbyte( OBJCODESYMB );		/* ... the offset into the function table of ... */
	}
      else					/* ... or ... */
	{	  
	  objbyte( OBJDATASYMB );		/* ... the offset into the data table of ... */
	}
      
d666 1
a666 2
      
      return sizeof_int;
d670 19
d690 33
d724 2
d727 11
a737 1
      objsymbol( '_', symname_( sym ) );	/* ... the start of the function specified by symbol */
d739 1
a739 1
      return sizeof_int;
d741 9
a749 1
#endif /* TARGET_HAS_DEBUGGER */
d758 102
d861 3
a863 1
    case X_absreloc:
d866 8
d875 3
a877 1
} /* objdirective */
d879 2
d896 2
d919 2
d943 2
d967 2
d1144 2
d1222 2
d1252 2
d1285 2
d1307 3
d1311 2
a1312 1
  
d1314 4
d1325 20
d1415 2
d1478 2
d1503 2
a1505 3
static LabelNumber *	datainitlab;


d1599 2
d1619 2
d1623 1
d1652 3
d1662 2
d1735 2
d1889 6
d1905 1
d1907 2
d1963 2
d1990 3
d2021 2
d2118 3
d2194 2
d2239 2
d2285 5
a2289 1
  
d2345 3
a2347 1
  
d2373 2
d2731 2
d2755 2
d2848 2
d2864 1
d2873 3
d2969 2
d3009 2
d3070 4
@


1.90
log
@added missing header file inclusion
@
text
@d2361 1
a2361 1
	  if (!new_stubs)
d2466 1
a2466 1
  if (new_stubs)
d3030 1
a3030 1
	 if (!new_stubs)
@


1.89
log
@oops, removed debugging left in by previous delta
@
text
@d55 1
@


1.88
log
@fixed code generation
@
text
@a2553 2
      debug( "label name = %x", lab_name_( datainitlab ) );
      
@


1.87
log
@added label generating code
@
text
@d2461 2
d2553 2
@


1.86
log
@changed large_model to few_modules and fixed bug associated with few_modules
@
text
@d142 1
d2472 12
a2483 1
      
@


1.85
log
@fixed rounding of positive FP constants
@
text
@d42 1
d263 1
a263 1
  
d418 3
a420 1
      if (large_model)
a421 2
      else
	objbyte( PATCHC40MASK8ADD );		/* ... adding into the bottom 8 bits of ... */
d713 3
a715 1
      if (large_model)
a716 2
      else
	objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 8 bits of... */	
d2995 6
a3000 1
     fseek( objstream, codesizepos, SEEK_SET );
d3004 6
a3009 1
     fseek( objstream, datasizepos, SEEK_SET );
d3017 6
a3022 1
	     fseek( objstream, maxcodeppos, SEEK_SET );
@


1.84
log
@now generates REFs to original fun ction name for function address purposes
@
text
@d366 6
d1806 1
a1806 1
  /* peepf( "converting IEEE number %x (high) %x (low), e = %x, s = %x, f = %x", high, low, e, s, f ); */
d1878 1
a1878 1
  /* peepf( "after conversion, e = %x, s = %d, f = %x", e, s, f ); */
d1884 5
d1893 2
d1897 2
@


1.83
log
@added code for address stub requests
@
text
@d366 4
@


1.82
log
@fixed to support function address generation stubs
@
text
@d146 1
d309 17
d359 9
d2808 10
a2817 9
  obj_symcount   = 0;
  obj_symlist    = NULL;
  obj_symlistend = &obj_symlist;
  dataxrefs      = NULL;
  codexrefs      = NULL;
  global_symbols = NULL;
  stub_symbols   = NULL;
  stublist       = NULL;
  in_stubs       = 0;
@


1.81
log
@*** empty log message ***
@
text
@d39 2
a40 2
#include </helios/include/module.h>
#include </helios/include/helios.h>
d88 2
a89 1
#define OBJCODESTUB	0x28		/* addr of fn or stub */
d321 1
a321 1
} /* reuqest_new_stub */
d492 19
d1160 1
@


1.80
log
@exported globalise()
@
text
@d144 1
d268 1
a268 1
void
d306 39
d1336 1
a1336 1
	     globalise( sym );
d2766 1
d2923 3
@


1.79
log
@fixed bug introduced by previous delta
@
text
@d267 1
a267 1
static void
@


1.78
log
@made new style stubs be a simple globalisation of the symbol
@
text
@d1263 3
a1265 1
  asmf( ";\n; Function Stubs\n" );
d1267 1
a1267 1
  in_stubs = 1;
d1269 3
a1271 1
  codebuf_reinit2();
d1273 1
a1273 1
  localcg_reinit();
d1275 1
a1275 1
  vr1.r = vr2.r = GAP; vm.i = 0;
d1277 2
a1278 5
#ifdef TARGET_IS_ARM
  entry_fudge = YES;
#endif

  procflags = 0;
a1279 6
  show_instruction( J_ENTER, vr1, vr2, vm );

#ifdef TARGET_IS_ARM
  entry_fudge = NO;
#endif

a1284 20
#ifdef TARGET_IS_ARM
     /* JGS: 910213
      *	We have encoded the exceptional flag in the top bit of the symbol
      * pointer. This assumes things about the environment the compiler
      *	is executing under. If we are an exceptional stub, we should generate
      *	code that preserve all the registers over the stub call.
      */
     
     if (((int32)sym & (1 << 31)) != 0)
       {
	 sym = (Symstr *)((int32)sym & ~(1 << 31)) ; /* clear the flag bit */
	 
	 in_exceptional_stub = 1 ;	/* special stub case */
       }
      else
	{
	  in_exceptional_stub = 0 ;	/* normal stub */
	}
#endif /* TARGET_IS_ARM */

d2886 2
a2889 2
	 fseek( objstream, datasizepos, SEEK_SET );

a2900 2
	 fseek( objstream, datasizepos, SEEK_SET );

@


1.77
log
@removed debugging from error message
@
text
@d289 1
a289 1
  
d298 1
a298 1
   }
d1314 19
a1332 9
	 
	 /*
	  * CGS: Changed from show_entry because that makes the symbol defined.
	  * I do not want it defined because when we come to do the init sequence
	  * it will think that the label is defined and would put a pointer
	  * to the stub into the data area. (viz. X problem).
	  * All we do is define the label to the linker and let that worry about
	  * patching up the forward references from the code.
	  */
d1334 1
a1334 1
	 show_entry( sym, xr_code | xr_defloc ); /* really a call to obj_symref */
d1336 1
a1336 1
	 objlabel( '.', symname_( sym ) );
d1338 34
a1371 33

	 /*
	  * Note that the two values passed in the r1 and r2 fields here are a
	  * bit suspect, but something is certainly needed...
	  */
	 
	 /* Beware the sym on the next line -- it probably needs to be a      */
	 /* slighly different Symstr.                                         */
	 
         vr1.rr = R_A1;
	 vr2.i  = 0;
	 vm.sym = sym;
	 
	 /*
	  * indicate that the following instruction marks the
	  * end of the stub, and so the NOPs that follow it
	  * are candidates for removal by the linker
	  * (This code is all to do with generating
	  * calling stubs, see load_address_constant() for
	  * more information)
	  */
  
         show_instruction( J_TAILCALLK, vr1, vr2, vm );
	 
         vr1.r = vr2.r = GAP;
	 vm.i  = 0;
	 
         show_instruction( J_ENDPROC, vr1, vr2, vm );

         show_code( sym );

         asm_lablist = NULL;
      }
d2858 1
a2858 1
  if (!new_stubs && !suppress_module)
d2887 1
a2887 1
  
@


1.76
log
@fixed compile time warnings, and fixed bug in old style stub support
@
text
@d1732 1
a1732 2
	  cc_warn( "floating point accuracy completely lost! (e = 0x%lx, s = 0x%lx, f = 0x%lx)",
		  e + 0x3ff, s, f );
@


1.75
log
@added code to support new stub generation mechanism
@
text
@a9 4
#ifndef NO_VERSION_STRINGS
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.75 $ 20\n";
#endif

d34 2
d37 2
d1191 2
d2265 3
a2267 2
	      
	  /* startcodetable( 4, symname_( x->extsym ) ); */
@


1.74
log
@added processor type definition for module.h inclusion
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.73 $ 20\n";
a37 2

#ifndef __C40
a38 2
#endif

d88 1
d96 1
a96 1
#define PATCHSWAP	0x1E		/* pathc = byte_swap( val1 ) */
a133 1

d142 1
a145 1
static Stub *		stublist;
d294 4
a297 1
      objsymbol( '_', symname_( g->sym ) );
d399 6
a404 1
      objbyte( OBJLABELREF );			/* ... the offset of ... */
d406 2
a407 2
      if (is_function( sym ))
	objsymbol( '.', symname_( sym ) );	/* ... the symbol */
d409 5
a413 1
	objsymbol( '_', symname_( sym ) );	/* ... the symbol */
a432 2
      objbyte( OBJLABELREF );			/* ... the offset of ... */
      
d434 8
a441 1
	objsymbol( '.', symname_( sym ) );	/* ... the symbol */
d443 5
a447 1
	objsymbol( '_', symname_( sym ) );	/* ... the symbol */
d470 5
a474 2
      objbyte( OBJLABELREF );			/* ... the offset of ... */
      
a1222 2


a1367 1

d2249 24
a2359 27
#if 0  
  datasymbols = NULL;
  dsend       = &datasymbols;
  
    {
      ExtRef **		x1 = &obj_symlist;      /* @@@@@@ hands off !!!!!!!!    */

      
      while (*x1 != NULL)
	{
	  ExtRef *	x = *x1;

	  
	  if (is_data( x ) && is_defined( x ))
	    {
	      *x1       = x->extcdr;
	      x->extcdr = NULL;
	      *dsend    = x;
	      dsend     = &x->extcdr;
	    }
	  else
	    {
	      x1 = &(x->extcdr);
	    }
	}
    }
#endif
d2365 6
a2370 2
  
  if (!suppress_module)
d2372 3
a2374 1
      prepare_for_function_exporting();
d2376 4
a2379 1
      load_static_data_ptr( R_ATMP, split_module_table, NULL );
d2381 3
a2383 6
      export_routines();
    }
      
  /*
   * XXX - beware of assumption of split_module_table == TRUE here
   */
d2385 5
a2389 5
  if (!suppress_module)
    {
      VRegInt	vr1;
      VRegInt	vr2;
      VRegInt	vm;
d2392 2
a2393 2
      vr1.r = vr2.r = GAP;
      vm.l  = RETLAB;
d2395 2
a2396 1
      show_instruction( J_B | Q_AL, vr1, vr2, vm );
d2737 1
a2738 1
  global_symbols = NULL;
a2739 1
  
d2743 1
a2743 1

d2845 1
a2845 1
  if (!suppress_module)
d2904 3
a2906 1
	 fseek( objstream, maxcodeppos, SEEK_SET );
d2908 2
a2909 1
	 objword( maxcodep );
@


1.73
log
@prevented path names from being included in module's name
@
text
@d39 4
@


1.72
log
@fixed compile time warnings
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.71 $ 20\n";
d2735 2
a2736 1
      int 	len = strlen( sourcefile ) - 31;
d2738 7
d2749 1
a2749 1
      strcpy( sname, &sourcefile[ len ] );
@


1.71
log
@fixed bug when not initialising any data
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.70 $ 20\n";
d1994 1
a1994 1
	      debug( "dataoff = %x, dataslot = %x", dataoff, dataslot );
@


1.70
log
@fixed bug when initialising only function pointers
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.69 $ 20\n";
a2371 2

      setlabel( datainitlab );
d2417 2
@


1.69
log
@uses asmf() for assembler output
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.68 $ 20\n";
d2382 1
d2388 2
d2417 1
a2417 1
  if (p)
a2421 1
    }
d2423 10
a2432 17
  /*
   * scan the data list twice
   *
   * The first scan (or phase) generates code to block copy the data
   * from the code segment into the data segment, and to calculate
   * address constants.  The second phase generates word directives
   * to insert the data into the code segment.
   */
  
  for (phase = 2; phase--; )
    {
      unsigned32	val;
	      
	      
      init_phase( phase, datasymbols, need_label );

      if (big_end)
d2434 6
a2439 1
	  for (p = datainitp; p != NULL; p = p->datacdr)
d2441 1
a2441 1
	      switch (p->sort)
d2443 1
a2443 43
		case LIT_LABEL:
		  break;
		  
		case LIT_ADCON:
		  if (p->rpt != 1)
		    syserr( "heliobj: cannot (yet) repeatedly export the same symbol" );

		  phase_store_address_constant( phase, (Symstr *)p->len, p->val );
		  break;
		  
		case LIT_BBBB:
		  val = p->val;
		  
		  val = ((val <<  8) & 0x00FF0000U) |
		        ((val >>  8) & 0x0000FF00U) |
		         (val >> 24)                |
			 (val << 24)                ;

		  phase_store( phase, val, p->rpt );
		  
		  break;
		  
		case LIT_BBH:
		  val = p->val;
		  phase_store( phase, (val << 16) | (val >> 24) | ((val >>  8) & 0x0000FF00U), p->rpt );
		  break;
		  
		case LIT_HBB:
		  val = p->val;
		  phase_store( phase, (val >> 16) | (val << 24) | ((val <<  8) & 0x00FF0000U), p->rpt );
		  break;
		  
		case LIT_HH:
		  val = p->val;		      
		  phase_store( phase, (val << 16) | (val >> 16), p->rpt );
		  break;
		  
		case LIT_NUMBER:
		  phase_store( phase, p->val, p->rpt );
		  break;
		  
		case LIT_FPNUM:
		  switch (p->len)
d2445 8
a2452 4
		    case sizeof_float:
		      phase_store( phase,
				  IEEE_to_single_float( ((FloatCon *)p->val)->floatbin.fb.val ),
				  p->rpt );
d2455 8
a2462 7
		    case sizeof_double:		      
		      phase_store( phase,
				  IEEE_to_extended_float(
							 ((FloatCon *)p->val)->floatbin.db.msd,
							 ((FloatCon *)p->val)->floatbin.db.lsd,
							 (int32 *)&val ),
				  p->rpt );
d2464 1
d2467 45
d2513 1
a2513 1
		      syserr( "heliobj: bad size of floating point number %d", p->len );
a2515 6
		  
		  break;
		  
		default:
		  syserr( "heliobj: unknown data type %x", p->sort );
		  break;
d2518 1
a2518 4
	}
      else
	{
	  for (p = datainitp; p != NULL; p = p->datacdr)
d2520 1
a2520 1
	      switch (p->sort)
d2522 1
a2522 26
		case LIT_LABEL:
		  break;
		  
		case LIT_ADCON:
		  if (p->rpt != 1)
		    syserr( "heliobj: cannot (yet) repeatedly export the same symbol" );
		  
		  phase_store_address_constant( phase, (Symstr *)p->len, p->val );
		  break;
		  
		case LIT_BBBB:
		case LIT_BBH:
		case LIT_HBB:
		case LIT_HH:
		  if (p->len != sizeof_long)
		    syserr( "heliobj: bad length for packed data (%d)", p->len );
		  
		  phase_store( phase, p->val, p->rpt );
		  break;
		  
		case LIT_NUMBER:
		  phase_store( phase, p->val, p->rpt );
		  break;
		  
		case LIT_FPNUM:
		  switch (p->len)
d2524 22
a2545 4
		    case sizeof_float:
		      phase_store( phase,
				  IEEE_to_single_float( ((FloatCon *)p->val)->floatbin.fb.val ),
				  p->rpt );
d2548 23
a2570 8
		    case sizeof_double:		      
		      phase_store( phase,
				  IEEE_to_extended_float(
							 ((FloatCon *)p->val)->floatbin.db.msd,
							 ((FloatCon *)p->val)->floatbin.db.lsd,
							 (int32 *)&val ),
				  p->rpt );
		      phase_store( phase, val, p->rpt );
d2574 1
a2574 1
		      syserr( "heliobj: bad size of floating point number %d", p->len );
a2576 5
		  break;
		  
		default:
		  syserr( "heliobj: unknown data type %x", p->sort );
		  break;
d2579 2
a2581 2
      
      finish_phase( phase, need_label );
@


1.68
log
@added comment around alignment statement for asm output
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.67 $ 20\n";
d1239 1
a1239 4
  if (asmstream != NULL)
    {
      fprintf( asmstream, ";\n; Function Stubs\n" );
    }
d1458 1
a1458 4
  if (asmstream != NULL)
    {
      fprintf( asmstream, ";\n; Data / Function Table Initialisation\n" );
    }
d2832 2
a2833 5
      if (asmstream)
	{
	  fprintf( asmstream, ";       align 128\n" );
	  fprintf( asmstream, "        init\n" );
	}
@


1.67
log
@fixed data init chains again
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.66 $ 20\n";
d2840 1
a2840 1
	  fprintf( asmstream, "        align 128\n" );
@


1.66
log
@minor cosmetic change
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.65 $ 20\n";
d1988 7
d2000 2
d2179 56
d2243 1
d2245 1
a2288 1
      ExtRef *	succ;
a2289 1
      ExtRef *	p;
d2292 4
a2295 3
      p     = datasymbols = NULL;
      dsend = &datasymbols;
      flist = &obj_symlist;
d2297 1
a2297 1
      for (x = obj_symlist; x != NULL; x = succ)
d2299 3
d2306 1
a2306 13
	      if (p != NULL && x->extoffset < p->extoffset)
		{
		  ExtRef *	t = p;

		  p = x;
		  x = t;
		}
	      
	      if (p != NULL)
		{
		  *dsend = p;
		  dsend  = &p->extcdr;
		}
d2308 1
a2308 1
	      p = x;
d2312 2
d2316 3
a2318 1
	    }	  
a2319 3

      *dsend    = p;
      p->extcdr = NULL;
@


1.65
log
@fixed bug introdiced by previous delta
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.64 $ 20\n";
d2344 1
a2344 1
	  if (p->len == sizeof_double 		     &&
@


1.64
log
@fixed bug in generation of data stubs
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.63 $ 20\n";
d2221 1
d2229 2
a2230 1
  
d2253 5
@


1.63
log
@fixed bug in generating size of module
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.62 $ 20\n";
d1969 1
a1969 1
		  
d1992 1
a1992 1
	      
d2178 1
a2178 1
  ExtRef **	dsend   = &datasymbols;
a2199 2
  datasymbols = NULL;
  
d2204 48
d2253 7
d2282 2
a2283 1

d2616 1
a2616 1
      
d2639 1
a2639 1
}/* obj_symref */
@


1.62
log
@fixed very minor buglet
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.61 $ 20\n";
d35 4
d1455 2
a1456 1
    objbyte( OBJINIT );
d1458 3
d1467 1
a1467 2
  codesize += sizeof_int;
  
a2670 2
      codesize = sizeof (Module) - sizeof (int32);

d2673 2
a2674 2
      codesize += sizeof_int;
      
d2681 1
a2681 3
	  objword( 0 );
	  
	  codesize += sizeof (int32);
d2683 4
@


1.61
log
@fixed bug in data initialisation code
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.60 $ 20\n";
d2499 1
a2499 1
  if ((x = symext_( s )) == 0)     /* if not already defined */
d2502 1
@


1.60
log
@removed spurious debugging
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.59 $ 20\n";
d2269 1
a2269 1
	break;
@


1.59
log
@fixed ouput of FP numbers
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.58 $ 20\n";
a2329 2
		  debug( "adcon, val = %x", p->val );
		  
@


1.58
log
@removed compiler warnings
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.57 $ 20\n";
d2312 3
a2320 3
	      unsigned32	val;
	      
	      
d2329 2
d2342 1
a2342 1
		  
d2370 3
a2372 1
		      phase_store( phase, ((FloatCon *)p->val)->floatbin.fb.val, p->rpt );
d2375 8
a2382 3
		    case sizeof_double:
		      phase_store( phase, ((FloatCon *)p->val)->floatbin.db.msd, p->rpt );
		      phase_store( phase, ((FloatCon *)p->val)->floatbin.db.lsd, p->rpt );
d2432 3
a2434 1
		      phase_store( phase, ((FloatCon *)p->val)->floatbin.fb.val, p->rpt );
d2437 8
a2444 3
		    case sizeof_double:
		      phase_store( phase, ((FloatCon *)p->val)->floatbin.db.msd, p->rpt );
		      phase_store( phase, ((FloatCon *)p->val)->floatbin.db.lsd, p->rpt );
a2450 1
		  
@


1.57
log
@switches off back tracing during init
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.56 $ 20\n";
d931 1
a931 1
  static int	big_end = FALSE;
d2170 1
a2170 1
  static int	big_end = FALSE;
@


1.56
log
@fixed for little endian compilation
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.55 $ 20\n";
d1441 1
a1441 1
  /* XXX - turn off stack checking in initialisation rouitnes - added by NC 23/10/91 */
d1443 2
a1444 1
  var_no_stack_checks = 1;
@


1.55
log
@minor cosmetic change
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.54 $ 20\n";
d930 2
d939 13
d982 1
d984 1
a984 11
	  int	a = 0x12345678;

	  
	  if (((char *)&a)[ 0 ] == 0x78)
	    {
	      /* little endian host */
	      
	      for (i = b; i < (b + n); i++)
		objbyte( buff[ i ] );
	    }
	  else
d986 1
a986 4
	      for (i = b; i < (b + n); i++)
		{
		  objbyte( buff[ (i & ~3) + (3 - (i & 3)) ] );
		}
a987 1
	}      
d989 11
a999 11
#if defined REVERSE_OBJECT_BYTE_ORDER
      xcode  =  (int32)buff[ i++ ] << 24;
      xcode |= ((int32)buff[ i++ ] << 16) & 0x00ff0000;
      xcode |= ((int32)buff[ i++ ] << 8)  & 0x0000ff00;
      xcode |= ((int32)buff[ i++ ])       & 0x000000ff;
#else
      xcode  = buff[ i++ ];
      xcode |= (int32)buff[ i++ ] << 8;
      xcode |= (int32)buff[ i++ ] << 16;
      xcode |= (int32)buff[ i++ ] << 24;
#endif
d1001 6
d2168 3
a2170 1
  ExtRef **	dsend       = &datasymbols;
d2179 13
d2312 2
a2313 2
      
      for (p = datainitp; p != NULL; p = p->datacdr)
d2315 1
a2315 5
#ifdef REVERSE_BYTE_ORDER
	  unsigned32	val;
#endif

	  switch (p->sort)
d2317 2
a2318 2
	    case LIT_LABEL:
	      break;
d2320 42
a2361 3
	    case LIT_ADCON:
	      if (p->rpt != 1)
		syserr( "heliobj: cannot (yet) repeatedly export the same symbol" );
d2363 16
a2378 13
	      phase_store_address_constant( phase, (Symstr *)p->len, p->val );
	      break;

#ifdef REVERSE_BYTE_ORDER
	    case LIT_BBBB:
	      val = p->val;
		  
	      val = ((val <<  8) & 0x00FF0000U) |
		    ((val >>  8) & 0x0000FF00U) |
		     (val >> 24)                |
		     (val << 24)                ;

	      phase_store( phase, val, p->rpt );
d2380 1
a2380 27
	      break;
			  
	    case LIT_BBH:
	      val = p->val;
	      phase_store( phase, (val << 16) | (val >> 24) | ((val >>  8) & 0x0000FF00U), p->rpt );
	      break;
			  
	    case LIT_HBB:
	      val = p->val;
	      phase_store( phase, (val >> 16) | (val << 24) | ((val <<  8) & 0x00FF0000U), p->rpt );
	      break;
			  
	    case LIT_HH:
	      val = p->val;		      
	      phase_store( phase, (val << 16) | (val >> 16), p->rpt );
	      break;
#else
	    case LIT_BBBB:
	    case LIT_BBH:
	    case LIT_HBB:
	    case LIT_HH:
	      if (p->len != sizeof_long)
		syserr( "heliobj: bad length for packed data (%d)", p->len );
	      
	      phase_store( phase, p->val, p->rpt );
	      break;
#endif /* REVERSE_BYTE_ORDER */
d2382 11
a2392 6
	    case LIT_NUMBER:
	      phase_store( phase, p->val, p->rpt );
	      break;
	      
	    case LIT_FPNUM:
	      switch (p->len)
d2394 22
a2415 2
		case sizeof_float:
		  phase_store( phase, ((FloatCon *)p->val)->floatbin.fb.val, p->rpt );
d2417 12
d2430 5
a2434 3
		case sizeof_double:
		  phase_store( phase, ((FloatCon *)p->val)->floatbin.db.msd, p->rpt );
		  phase_store( phase, ((FloatCon *)p->val)->floatbin.db.lsd, p->rpt );
d2436 1
a2436 1
		      
d2438 1
a2438 1
		  syserr( "heliobj: bad size of floating point number %d", p->len );
a2440 6
		  
	      break;

	    default:
	      syserr( "heliobj: unknown data type %x", p->sort );
	      break;
d2443 1
a2443 1

@


1.54
log
@removed spurious debugging
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.53 $ 20\n";
d114 1
d135 1
a135 1
extern int		split_module_table;
d138 1
a141 1
static GSymlist *	global_symbols;
a2155 2

ExtRef *	datasymbols;
@


1.53
log
@tideid up macros used with ExtRef
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.52 $ 20\n";
a2166 2
  debug( "dumpdata" );
  
a2381 2
  debug( "datadumped" );
  
@


1.52
log
@fixed bugs coping with simple data initialisation
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.51 $ 20\n";
d1276 1
a1276 1
     if (!is_defined( (symext_( sym )->extflags )))
d1348 1
a1348 1
      if (is_external_code( x->extflags ))
d1407 1
a1407 1
	  if ((symext_( sym ))->extflags & xr_defext)
d1425 1
a1425 1
show_init_entry( ExtRef * d )
a1429 2
  IGNORE( d );

d1554 1
a1554 1
	      !is_defined( x->extflags  ))
d2156 2
a2160 1
  ExtRef *	datasymbols = NULL;
d2167 2
d2172 2
d2188 1
a2188 1
	  if (is_data( x->extflags ) && is_defined( x->extflags ))
d2205 1
a2205 1
  show_init_entry( datasymbols );
d2384 2
d2442 2
a2443 2
  if (is_defined( flags ) &&
      is_defined( x->extflags ))
d2464 1
a2464 1
  if (is_defined( flags ))
d2467 1
a2467 1
  if (is_defined( x->extflags ))
d2474 1
a2474 1
  if (is_defined( flags ))
d2478 1
a2478 1
      if (is_code( x->extflags ))          /* @@@@@@ flags ...? */
d2486 1
a2486 1
  else if ((loc > 0) && !is_code( flags ) && !is_defined( x->extflags ))
d2498 1
a2498 1
  return (is_defined( x->extflags ) && is_code( x->extflags ) ? x->extoffset : -1);
@


1.51
log
@added code to support new style block copy data initialisation
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.50 $ 20\n";
a54 9
extern void		prepare_for_initialisation( int data_init, LabelNumber * data_label );
extern void		prepare_for_function_exporting( void );
extern void		prepare_for_data_exporting( RealRegister ptr );
extern void		block_data_init( int32, LabelNumber *, RealRegister );
extern void		export_function( Symstr * name, RealRegister dest );
extern void		export_data_symbol( Symstr *, RealRegister, int32, int32, int32, int32 );
extern void		export_data_value( RealRegister, RealRegister, int32, int32 ); 
extern void		export_data_float( RealRegister source, RealRegister dest ); 
extern void		finished_exporting( void );
a55 4
#ifdef TARGET_HAS_DEBUGGER
extern void		db_init( char * filename );
extern void		db_tidy( void );
#endif
a56 7
#define xr_definition			(xr_defloc | xr_defext)
#define xr_external_code		(xr_code   | xr_defext)
#define is_definition( flags )		((flags) & xr_definition)
#define is_code( flags )		((flags) & xr_code)
#define is_data( flags )		((flags) & xr_data)
#define is_external_code( flags )	(((flags) & xr_external_code) == xr_external_code)

a113 2
#define fits_in_5_bits( val )		(((val) & 0xfffffff0U) == 0 || ((val) & 0xfffffff0U) == 0xfffffff0U)

d130 6
a137 1
ExtRef *		obj_symlist;
a138 2
CodeXref *		codexrefs;
DataXref *		dataxrefs;
a139 1

a140 1

a147 3
int 			suppress_module;
extern int		split_module_table;

d1276 1
a1276 1
     if (!is_definition( (symext_( sym )->extflags )))
a1420 55
static LabelNumber *
loopstart( int32 rpt )
{
  LabelNumber *	l;
  VRegInt 	vr1;
  VRegInt	vr2;
  VRegInt	vm;

  
  vr1.rr = R_A1;
  vr2.r  = GAP;
  vm.i   = rpt;
  
  show_instruction( J_MOVK, vr1, vr2, vm );
  
  l = nextlabel();

  vr1.r = GAP;
  vm.l  = l;

  show_instruction( J_LABEL, vr1, vr2, vm );

  return l;

} /* loopstart */


static void
loopend( LabelNumber * l )
{
  VRegInt	vr1;
  VRegInt	vr2;
  VRegInt	vm;


  vr1.rr = vr2.rr = R_A1;
  vm.i   = 1;

  show_instruction( J_SUBK, vr1, vr2, vm );
  
  vr1.r = GAP;
  vm.i  = 0;

  show_instruction( J_CMPK + Q_NE, vr1, vr2, vm );

  vr2.r = GAP;
  vm.l  = l;

  show_instruction( J_B | Q_NE, vr1, vr2, vm );

  return;
  
} /* loopend */


d1556 1
a1556 1
	      !is_definition( x->extflags  ))
d1788 366
d2163 4
a2166 2
  VRegInt 	vr1, vr2, vm;

d2185 1
a2185 1
	  if (is_data( x->extflags ) && is_definition( x->extflags ))
d2202 3
d2206 3
a2208 8
      DataInit *	p;
      ExtRef *		dsymb      = datasymbols;
      int32 		dataslot   = 0;
      int32 		curdsize   = 0;
      int32		justloaded = 0;
      bool 		justvalid  = NO;
      ExtRef *		curdsymb   = NULL;
      unsigned long	pending_inc = 0;
d2210 2
d2213 10
a2222 1
      show_init_entry( datasymbols );
d2224 2
a2225 8
      if (!suppress_module)
	{
	  prepare_for_function_exporting();
	  
	  load_static_data_ptr( R_ATMP, split_module_table, NULL );

	  export_routines();
	}
d2227 1
a2227 7
      if (split_module_table)
	{
	  if (!suppress_module)
	    {
	      VRegInt	vr1;
	      VRegInt	vr2;
	      VRegInt	vm;
d2229 2
a2230 5
	  
	      vr1.r = vr2.r = GAP;
	      vm.l  = RETLAB;
	  
	      show_instruction( J_B | Q_AL, vr1, vr2, vm );
d2232 4
a2235 2
	      setlabel( datainitlab );
	    }
d2237 9
a2245 7
	  if (p)
	    {
	      load_static_data_ptr( R_ATMP, NO, NULL );

	      prepare_for_data_exporting( R_ATMP );
	    }
	}
d2247 1
a2247 3
      /* pre scan the data to see which kinds of data initialisation is going to be best */
      
      for (p = datainitp; p != NULL; p = p->datacdr)
d2249 2
a2250 4
	  if (p->sort != LIT_LABEL)
	    {
	      curdsize += p->len * p->rpt;
	    }
d2252 4
a2255 5
	  if (p->sort == LIT_ADCON)
	    {
	      /* block copy code cannot (yet) cope with ADCONs */
	      
	      curdsize = 0;
d2257 3
a2259 2
	      break;
	    }	  
d2262 27
a2288 1
      /* use block copy to initialise bulk of data */
d2290 1
a2290 1
      if (curdsize > 2 * sizeof_int)
d2292 3
a2294 8
	  LabelNumber *	l;


	  l = nextlabel();

	  /* generate block copy code */

	  block_data_init( curdsize / sizeof_int, l, R_ATMP );
d2296 1
a2296 7
	  show_init_return();

	  /* start block of data */
	  
	  setlabel( l );

	  for (p = datainitp; p != NULL; p = p->datacdr)
d2298 2
a2299 7
	      int32		rpt;
	      int32		sort;
	      int32		len;
	      unsigned32	val;
	      Symstr *		sv;
	      FloatCon *	fc;
	      LabelNumber *	l;
d2301 6
a2306 5
	  
	      sort = p->sort;
	  
	      if (sort == LIT_LABEL)
		continue;
d2308 8
a2315 3
	      rpt  = p->rpt;
	      len  = p->len;
	      val  = p->val;
d2317 3
a2319 21
	      switch (sort)
		{
		default:  		syserr( syserr_heliobj_gendata, (long)sort );
		case LIT_NUMBER:
		case LIT_HH:		/* these 4 are the same as LIT_NUMBER except   */
		case LIT_BBBB:		/* for (as yet unsupported) cross compilation. */
		case LIT_BBH:
		case LIT_HBB:		/* cc300+ codebuf.c ensures length==4.         */

		  if (len != 4)
		    syserr( syserr_heliobj_datalen, (long)len );

#ifdef REVERSE_OBJECT_BYTE_ORDER		  
		  switch (sort)
		    {
		    case LIT_BBBB:
		      val = ((val << 8) & 0x00FF0000U) |
			    ((val >> 8) & 0x0000FF00U) |
			     (val >> 24)               |
			     (val << 24)               ;
		      break;
d2321 4
a2324 4
		    case LIT_BBH:
		      val =  (val << 16) | (val >> 24) |
			     ((val >> 8) & 0x0000FF00U) ;
		      break;
d2326 4
a2329 4
		    case LIT_HBB:
		      val =  (val >> 16) | (val << 24) |
			     ((val << 8) & 0x00FF0000U) ;
		      break;
d2331 11
a2341 51
		    case LIT_HH:
		      val = (val << 16) | (val >> 16);
		      break;
			  
		    default:
		      break;
		    }
#endif /* REVERSE_OBJECT_BYTE_ORDER */
		  
		  while (rpt--)
		    outcodeword( val, LIT_NUMBER );
		  
		  break;
		  
		case LIT_FPNUM:
		  fc = (FloatCon *)val;
		  
		  if (len != sizeof_float && len != sizeof_double)
		    syserr( syserr_heliobj_data, (long)rpt, (long)len, fc->floatstr );

		  if (len == 4)
		    while (rpt--)
		      {
			outcodeword( fc->floatbin.fb.val, LIT_NUMBER );
		      }
		  else
		    while (rpt--)
		      {
			outcodeword( fc->floatbin.db.msd, LIT_NUMBER );
			outcodeword( fc->floatbin.db.lsd, LIT_NUMBER );
		      }
		  
		  break;
		  
		case LIT_ADCON:
		  syserr( "urg" );		  
		  break;
		}
	    }
	}
      else /* less than 8 bytes of data to init */
	{
	  for (p = datainitp; p != NULL; p = p->datacdr)
	    {
	      int32		rpt;
	      int32		sort;
	      int32		len;
	      unsigned32	val;
	      Symstr *	sv;
	      FloatCon *	fc;
	      LabelNumber *	l;
d2343 3
a2345 25
	      
	      sort = p->sort;
	      
	      if (sort == LIT_LABEL)
		continue;
	      
	      rpt  = p->rpt;
	      len  = p->len;
	      val  = p->val;
	      
	      if (sort == LIT_ADCON)
		{
		  sv  = (Symstr *)len;
		  len = sizeof_int;
		}
	      else
		{
		  sv = NULL;
		}
	      
	      /* Generate the data space offset and label */
	      
	      if (dsymb != NULL)
		{
		  int32	dataoff = dsymb->extoffset;
d2347 3
a2349 27
		  
		  if (dataslot == dataoff)
		    {
		      if (curdsymb != NULL)
			{
			  output_symbol( curdsymb->extsym, curdsize );
			}
		      
		      for (; dsymb->extcdr && dsymb->extcdr->extoffset == dataoff; dsymb = dsymb->extcdr )
			{
			  output_symbol( dsymb->extsym, 0 );
			}
		      
		      curdsize = 0;
		      curdsymb = dsymb;
		      
		      dsymb = dsymb->extcdr;
		    }
		  else if (dataoff < dataslot)
		    {
		      syserr( syserr_heliobj_dataseggen );
		    }
		}
	      
	      curdsize += len * rpt;
	      
	      /* Now generate the code to initialise the data */
d2351 2
a2352 1
	      switch (sort)
d2354 3
a2356 78
		default:  		syserr( syserr_heliobj_gendata, (long)sort );
		  /* the next 4 are the same as LIT_NUMBER except   */
		  /* for (as yet unsupported) cross compilation.    */
		case LIT_HH:
		case LIT_BBBB:
		case LIT_BBH:
		case LIT_HBB:
		case LIT_NUMBER:
		  /* cc300+ codebuf.c ensures length==4.                  */
		  
		  if (len != 4)
		    syserr( syserr_heliobj_datalen, (long)len );
		  
		  if (val != 0)
		    {
		      if (pending_inc != 0)
			{
			  vr1.rr = vr2.rr = R_ATMP;
			  vm.i   = pending_inc;
			  
			  show_instruction( J_ADDK, vr1, vr2, vm );
			  
			  pending_inc = 0;
			}
#ifdef REVERSE_OBJECT_BYTE_ORDER		  
		      switch (sort)
			{
			case LIT_BBBB:
			  val = ((val << 8) & 0x00FF0000L) |
			        ((val >> 8) & 0x0000FF00L) |
			         (val >> 24)               |
				 (val << 24)               ;
			  break;
			  
			case LIT_BBH:
			  val =  (val << 16) | (val >> 24) |
			         ((val >> 8) & 0x0000FF00L) ;
			  break;
			  
			case LIT_HBB:
			  val =  (val >> 16) | (val << 24) |
			         ((val << 8) & 0x00FF0000L) ;
			  break;
			  
			case LIT_HH:
			  val = (val << 16) | (val >> 16);
			  break;
			  
			default:
			  break;
			}
#endif /* REVERSE_OBJECT_BYTE_ORDER */
		      
		      if (!justvalid || justloaded != val)
			{
#if defined STIK_NOW_WORKS_ON_HARDWARE
			  if (!fits_in_5_bits( val ))
#endif 
			    {
			      vr1.rr = R_DS;
			      vr2.r  = GAP;
			      vm.i   = val;
			      
			      show_instruction( J_MOVK, vr1, vr2, vm );
			      
			      justloaded = val;
			      justvalid  = YES;
			    }
			  
			  /* Nothing else in the init code can disturb R_DS... */
			}
		      
		      if (rpt > 1)
			l = loopstart( rpt );
		      else
			l = NULL;
		      
		      export_data_value( R_DS, R_ATMP, val, len );
d2358 3
a2360 12
		      if (rpt > 1)
			{
			  loopend( l );
			}
		    }
		  else    /* val == 0 */
		    {
		      pending_inc += (rpt * len) / sizeof_int;	/* R_ATMP holds a word pointer */
		    }
		  
		  dataslot += rpt * len;
		  
a2361 57
		  
		case LIT_FPNUM:
		  fc = (FloatCon *)val;
		  
		  if (len != sizeof_float && len != sizeof_double)
		    syserr( syserr_heliobj_data, (long)rpt, (long)len, fc->floatstr );
		  
		  if (len == 4)
		    {
		      val = IEEE_to_single_float( fc->floatbin.fb.val );
		    }
		  else
		    {
		      val = IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, NULL );
		    }
		  
		  if (val != 0)
		    {
		      if (pending_inc != 0)
			{
			  vr1.rr = vr2.rr = R_ATMP;
			  vm.i   = pending_inc;
			  
			  show_instruction( J_ADDK, vr1, vr2, vm );
			  
			  pending_inc = 0;
			}
		      
		      vr1.rr = R_DS;
		      vr2.r  = GAP;
		      vm.i   = val;
		      
		      show_instruction( J_MOVK, vr1, vr2, vm );
		      
		      if (len == 8)
			{
			  vr1.rr = R_ADDR1;
			  vr2.r  = GAP;
			  
			  (void) IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &vm.i );

			  show_instruction( J_MOVK, vr1, vr2, vm );
			}
		    }
		  
		  if (rpt > 1)
		    l = loopstart( rpt );
		  else
		    l = NULL;
		  
		  if (val != 0)
		    {
		      vr1.rr = R_DS;
		      vr2.rr = R_ATMP;
		      vm.i   = 0;

		      export_data_float( vr1.rr, vr2.rr );
d2363 2
a2364 21
		      if (len == 8)
			{
			  vr1.rr = R_ADDR1;
			  vr2.rr = R_ATMP;
			  vm.i   = 4;
			  
			  export_data_float( vr1.rr, vr2.rr );
			}
		    }
		  else
		    {
		      pending_inc =+ len / sizeof_int;
		    }
		  
		  if (rpt > 1)
		    {
		      loopend( l );
		    }
		  
		  dataslot += rpt * len;
		  
d2366 1
d2368 1
a2368 1
		case LIT_ADCON:              /* (possibly external) name + offset */
d2370 3
a2372 21
		  if (pending_inc != 0)
		    {
		      vr1.rr = vr2.rr = R_ATMP;
		      vm.i   = pending_inc;
		      
		      show_instruction( J_ADDK, vr1, vr2, vm );
		      
		      pending_inc = 0;
		    }

		  export_data_symbol( sv, R_ATMP, rpt, val, len, dataslot );
		  
		  dataslot += rpt * len;
		  
		  break;
		}
	    }
	  
	  if (curdsymb)
	    {
	      output_symbol( curdsymb->extsym, curdsize );
a2373 2
	  
	  show_init_return();
d2375 2
d2378 1
a2378 1

d2437 2
a2438 2
  if (is_definition( flags ) &&
      is_definition( x->extflags ))
d2459 1
a2459 1
  if (is_definition( flags ))
d2462 1
a2462 1
  if (is_definition( x->extflags ))
d2469 1
a2469 1
  if (is_definition( flags ))
d2481 1
a2481 1
  else if ((loc > 0) && !is_code( flags ) && !is_definition( x->extflags ))
d2493 1
a2493 1
  return (is_definition( x->extflags ) && is_code( x->extflags ) ? x->extoffset : -1);
@


1.50
log
@fixed X_Datamodule to work with large_model pragma
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.49 $ 20\n";
d55 9
a63 8
void		prepare_for_initialisation( int data_init, LabelNumber * data_label );
void		prepare_for_function_exporting( void );
void		prepare_for_data_exporting( RealRegister ptr );
void		export_function( Symstr * name, RealRegister dest );
void		export_data_symbol( Symstr * name, RealRegister dest, int32 rpt, int32 offset, int32 len, int32 current_offset );
void		export_data_value( RealRegister source, RealRegister dest, int32 val, int32 increment ); 
void		export_data_float( RealRegister source, RealRegister dest ); 
void		finished_exporting( void );
d66 2
a67 2
extern void	db_init( char * filename );
extern void	db_tidy( void );
a1610 4
  vm.i = 0;

  show_instruction( J_ENDPROC, vr1, vr2, vm );

d1645 6
a1651 1
#ifdef TARGET_IS_C40
d1769 1
a1769 2
  /* fprintf( asmstream, "converting IEEE number %x (high) %x (low), e = %x, s = %x, f = %x\n",
	  high, low, e, s, f ); */
d1842 1
a1842 1
  /* fprintf( asmstream, "after conversion, e = %x, s = %d, f = %x\n", e, s, f ); */
d1867 3
a1869 1
#endif /* TARGET_IS_C40 */
a1870 1
  
a1920 1
#ifdef TARGET_IS_C40
a1921 1
#endif
a1927 1
#ifdef TARGET_IS_C40
d1929 1
a1929 1
#endif
a1934 4
      for (p = datainitp; p != NULL; p = p->datacdr)
	if (p->sort != LIT_LABEL)
	  break;
      
a1955 1
#ifdef TARGET_IS_C40
d1957 10
a1966 1
#endif
d1968 9
d1979 3
a1981 1
      for (; p != NULL; p = p->datacdr)
a1982 6
	  int32		rpt;
	  int32		sort;
	  int32		len;
	  unsigned32	val;
	  Symstr *	sv;
	  FloatCon *	fc;
d1985 4
a1988 5
	  
	  sort = p->sort;
	  
	  if (sort == LIT_LABEL)
	    continue;
d1990 1
a1990 3
	  rpt  = p->rpt;
	  len  = p->len;
	  val  = p->val;
d1992 1
a1992 9
	  if (sort == LIT_ADCON)
	    {
	      sv  = (Symstr *)len;
	      len = sizeof_int;
	    }
	  else
	    {
	      sv = NULL;
	    }
d1994 1
a1994 1
	  /* Generate the data space offset and label */
d1996 3
a1998 1
	  if (dsymb != NULL)
d2000 7
a2006 2
	      int32	dataoff = dsymb->extoffset;

d2008 5
a2012 22
	      if (dataslot == dataoff)
		{
		  if (curdsymb != NULL)
		    {
		      output_symbol( curdsymb->extsym, curdsize );
		    }
		  
		  for (; dsymb->extcdr && dsymb->extcdr->extoffset == dataoff; dsymb = dsymb->extcdr )
		    {
		      output_symbol( dsymb->extsym, 0 );
		    }
		  
		  curdsize = 0;
		  curdsymb = dsymb;
		  
		  dsymb = dsymb->extcdr;
		}
	      else if (dataoff < dataslot)
		{
		  syserr( syserr_heliobj_dataseggen );
		}
	    }
d2014 3
a2016 1
	  curdsize += len * rpt;
d2018 8
a2025 13
	  /* Now generate the code to initialise the data */
	  
	  switch (sort)
	    {
            default:  		syserr( syserr_heliobj_gendata, (long)sort );
            /* the next 4 are the same as LIT_NUMBER except   */
            /* for (as yet unsupported) cross compilation.    */
            case LIT_HH:
            case LIT_BBBB:
            case LIT_BBH:
            case LIT_HBB:
            case LIT_NUMBER:
	      /* cc300+ codebuf.c ensures length==4.                  */
d2027 2
a2028 12
	      if (len != 4)
		syserr( syserr_heliobj_datalen, (long)len );

	      if (val != 0)
                {
#ifdef TARGET_IS_C40
		  if (pending_inc != 0)
		    {
		      vr1.rr = vr2.rr = R_ATMP;
		      vm.i   = pending_inc;
		      
		      show_instruction( J_ADDK, vr1, vr2, vm );
a2029 2
		      pending_inc = 0;
		    }
d2034 2
a2035 2
		      val = ((val << 8) & 0x00FF0000L) |
			    ((val >> 8) & 0x0000FF00L) |
d2042 1
a2042 1
			    ((val >> 8) & 0x0000FF00L) ;
d2044 1
a2044 1

d2047 1
a2047 1
			    ((val << 8) & 0x00FF0000L) ;
d2057 208
a2264 1
#endif
d2266 17
a2282 1
#endif /* TARGET_IS_C40 */
d2284 1
a2284 5
		  if (!justvalid || justloaded != val)
                    {
#if defined TARGET_IS_C40 && defined STIK_NOW_WORKS_ON_HARDWARE
		      if (!fits_in_5_bits( val ))
#endif /* TARGET_IS_C40 */
d2286 1
a2286 1
			  vr1.rr = R_DS;
d2288 3
a2290 2
			  vm.i   = val;
		      
a2291 3

			  justloaded = val;
			  justvalid  = YES;
d2293 2
a2294 4

		      /* Nothing else in the init code can disturb R_DS... */
                    }

d2299 6
d2306 15
a2320 14
#ifdef TARGET_IS_C40
		  export_data_value( R_DS, R_ATMP, val, len );
#else
		  vr1.rr = R_DS;
		  vr2.rr = R_ATMP;
		  vm.i   = 0;
		  
		  show_instruction( J_STRK, vr1, vr2, vm );
		  
		  vr1.rr = R_ATMP;
		  vm.i   = len;
		  
		  show_instruction( J_ADDK, vr1, vr2, vm );
#endif /* TARGET_IS_C40 */
d2326 6
a2331 18
                }
	      else    /* val == 0 */
                {
#ifdef TARGET_IS_C40
		  pending_inc += (rpt * len) / sizeof_int;	/* R_ATMP holds a word pointer */
#else
		  vr1.rr = vr2.rr = R_ATMP;
		  vm.i   = rpt * len;
		  show_instruction( J_ADDK, vr1, vr2, vm );
#endif
                }

	      dataslot += rpt * len;

	      break;

            case LIT_FPNUM:
	      fc = (FloatCon *)val;
a2332 22
	      if (len != sizeof_float && len != sizeof_double)
		syserr( syserr_heliobj_data, (long)rpt, (long)len, fc->floatstr );

#ifdef TARGET_IS_C40
	      if (len == 4)
		{
		  val = IEEE_to_single_float( fc->floatbin.fb.val );
		}
	      else
		{
		  val = IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, NULL );
		}
#else
	      val = fc->floatbin.irep[ 0 ];
	      
	      if (len == 8)
		val |= fc->floatbin.irep[ 1 ];
#endif
	      
	      if (val != 0)
                {
#ifdef TARGET_IS_C40
d2339 1
a2339 1

d2342 2
a2343 1
#endif /* TARGET_IS_C40 */
d2345 1
a2345 72
		  vr1.rr = R_DS;
		  vr2.r  = GAP;
		  vm.i   = val;
		  
		  show_instruction( J_MOVK, vr1, vr2, vm );

		  if (len == 8)
                    {
		      vr1.rr = R_ADDR1;
		      vr2.r  = GAP;
#ifdef TARGET_IS_C40
		      (void) IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &vm.i );
#else
		      vm.i   = fc->floatbin.fb.val;
#endif		      
		      show_instruction( J_MOVK, vr1, vr2, vm );
                    }
                }
	      
	      if (rpt > 1)
		l = loopstart( rpt );
	      else
		l = NULL;

	      if (val != 0)
                {
		  vr1.rr = R_DS;
		  vr2.rr = R_ATMP;
		  vm.i   = 0;
#ifdef TARGET_IS_C40
		  export_data_float( vr1.rr, vr2.rr );
#else	  
		  show_instruction( J_STRK, vr1, vr2, vm );
#endif	  
		  if (len == 8)
                    {
		      vr1.rr = R_ADDR1;
		      vr2.rr = R_ATMP;
		      vm.i   = 4;
#ifdef TARGET_IS_C40
		      export_data_float( vr1.rr, vr2.rr );
#else	  
		      show_instruction( J_STRK, vr1, vr2, vm );
#endif	  
                    }
                }
#ifdef TARGET_IS_C40
	      else
		{
		  pending_inc =+ len / sizeof_int;
		}
#else
	      vr1.rr = vr2.rr = R_ATMP;
	      vm.i   = len;
	      
	      show_instruction( J_ADDK, vr1, vr2, vm );
#endif
	      if (rpt > 1)
		{
		  loopend( l );
		}

	      dataslot += rpt * len;

	      break;

            case LIT_ADCON:              /* (possibly external) name + offset */
#ifdef TARGET_IS_C40
	      if (pending_inc != 0)
		{
		  vr1.rr = vr2.rr = R_ATMP;
		  vm.i   = pending_inc;
d2347 1
a2347 3
		  show_instruction( J_ADDK, vr1, vr2, vm );

		  pending_inc = 0;
d2349 5
a2353 34
#endif /* TARGET_IS_C40 */
		  
#ifdef TARGET_IS_C40
	      export_data_symbol( sv, R_ATMP, rpt, val, len, dataslot );
#else
	      vr1.rr = R_ADDR1;
	      vr2.i  = val;
	      vm.sym = sv;

	      show_instruction( J_ADCON, vr1, vr2, vm );

	      if (rpt > 1)
		l = loopstart( rpt );
	      else
		l = NULL;

	      vr1.rr = R_ADDR1;
	      vr2.rr = R_ATMP;
	      vm.i   = 0;
	      
	      show_instruction( J_STRK, vr1, vr2, vm );
	      
	      vr1.rr = R_ATMP;
	      vm.i   = len;
	      
	      show_instruction( J_ADDK, vr1, vr2, vm );

	      if (rpt > 1)
		loopend( l );
#endif /* TARGET_IS_C40 */
	      
	      dataslot += rpt * len;
	      
	      break;
d2355 2
a2356 5
	}

      if (curdsymb)
	{
	  output_symbol( curdsymb->extsym, curdsize );
a2357 2
      
      show_init_return();
a2359 1
#ifdef TARGET_IS_C40
a2360 1
#endif
@


1.49
log
@fixed discrepency reporting multiple definitions
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.48 $ 20\n";
d608 5
a612 2
      
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of... */
@


1.48
log
@fixed bug in generating global values
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.47 $ 20\n";
d2366 7
a2372 1
      syserr( syserr_heliobj_2def, s );
@


1.47
log
@minor cosmetic changes
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.46 $ 20\n";
d2088 1
a2088 1
#if defined TARGET_IS_C40 || defined STIK_NOW_WORKS_ON_HARDWARE
@


1.46
log
@fixed for running on C40
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.45 $ 20\n";
d1113 3
a1115 1
    return;
d1117 3
a1119 1
  /* Odd how the list ALL gets reversed every routine? */
d1121 3
a1123 2
  codexrefs = (CodeXref *)dreverse( (List *)codexrefs );

d1133 1
a1133 1

@


1.45
log
@removed support of STIK instruction
@
text
@d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.44 $ 20\n";
d1006 6
a1011 1
#if defined TARGET_IS_ARM
a1015 9
#elif defined TARGET_IS_C40		/* actually this is because the HP9000/700 is big endian */

      xcode  =  (int32)buff[ i++ ] << 24;

      xcode |= ((int32)buff[ i++ ] << 16) & 0x00ff0000;

      xcode |= ((int32)buff[ i++ ] << 8)  & 0x0000ff00;

      xcode |= ((int32)buff[ i++ ])       & 0x000000ff;
d2050 1
a2050 1
		  
d2077 2
@


1.44
log
@fixed bug with combining shorter than word constants into words
@
text
@d8 1
d11 1
a11 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.43 $ 20\n";
d2085 1
a2085 1
#ifdef TARGET_IS_C40
@


1.43
log
@removed warnings produced by self-compilation
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.42 $ 20\n";
d1967 1
a1967 1
	  int32		val;
@


1.42
log
@added Helios Debugger support
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.41 $ 20\n";
d21 5
a25 4
#ifdef __STDC__
#include <string.h>
# if 0
#  include <unistd.h>
d27 1
a27 3
#include <stddef.h>
#else
#include <strings.h>
a28 1
#endif
d34 2
a35 1
#include "module.h"
a36 2
#include "helios.h"
#include "module.h"
d63 5
d1661 2
a1662 2
  s = val & (1 << 31);
  f = val & ((1 << 23) - 1);
d1759 1
a1759 1
  s = high & (1 << 31);
d1773 1
a1773 1
	  cc_warn( "floating point accuracy completely lost! (e = 0x%x, s = 0x%x, f = 0x%x)",
d1802 1
a1802 1
	  cc_warn( "floating point accuracy completely lost!(e = 0x%x, s = 0x%x, f = 0x%x)",
d1846 1
a1846 1
	  *low_return = (1 << 31) | (f >> 1);
@


1.41
log
@added code to clear used register vector
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.40 $ 20\n";
d146 1
d155 1
d804 24
d829 11
d1084 6
d1202 2
d1529 2
d1534 4
d2435 5
d2562 5
@


1.40
log
@changed X_DataSymbHi and X_DataSymbLo so that CODESYMB is treated as returning a byte offset rather than a word offset
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.39 $ 20\n";
d1483 3
a1485 1
  regmask = 0;            /* regbit(R_ADDR1); ??? */
@


1.39
log
@fixed sign extension and shift value bugs in IEEE_to_extended_float()
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.38 $ 20\n";
a729 2
      objnum( -16 );				/* ... down by 16 bits ... */
      
d732 2
d738 2
a759 2
      objnum( 16 );				/* ... up by 16 bits ... */
      
d762 2
d768 2
@


1.38
log
@fixed spurious generation of function initialisation return statement for resident libraries
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.37 $ 20\n";
d1665 3
a1667 3
		       int32	high,		/* most  significant 32 bits of 64 bit IEEE number */
		       int32	low,		/* least significant 32 bits of 64 bit IEEE number */
		       int32 *	low_return )  	/* least significant 32 bits of the result         */
d1701 1
a1701 1
  f = (high << (31 - 19)) | (low >> 19);
d1777 2
@


1.37
log
@minor cosmetic changes
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.36 $ 20\n";
d1876 5
a1880 3
	  VRegInt	vr1;
	  VRegInt	vr2;
	  VRegInt	vm;
d1883 2
a1884 2
	  vr1.r = vr2.r = GAP;
	  vm.l  = RETLAB;
d1886 1
a1886 1
	  show_instruction( J_B | Q_AL, vr1, vr2, vm );
d1888 2
a1889 1
	  setlabel( datainitlab );
@


1.36
log
@added new version of X_modnum patch
@
text
@d3 1
a3 1
 * Copyright (C) Perihelion Software Ltd, 1988
d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.35 $ 20\n";
d1540 1
a1540 1
  
@


1.35
log
@added code to cope with compiling on SPARKY
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.34 $ 20\n";
d127 1
d348 5
a352 2
      
      objbyte( PATCHC40MASK16ADD );		/* ... adding into the bottom 16 bits of ... */
@


1.34
log
@fixed bug in X_DataAddr1 patch
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.33 $ 20\n";
a27 1
#define SEEK_SET  0
d32 4
d38 2
d53 4
d1703 4
a1706 2
  
  if (e == 0x7ff)
d1708 8
d1718 2
a1719 1
	  e = 0x7f;
d1724 2
a1725 2
	  e = 0x7f;
	  s = 1;
d1729 1
a1729 1
  else if (e == 0)
d1735 1
a1735 1
  else 
d1737 14
a1750 3
      e -= 0x3ff;
      
      if (e <= 127 && e >= -128)
d1752 4
a1755 13
	  if (s != 0)
	    {
	      s = 1;
	      
	      if (f == 0)
		{
		  e -= 1;
		}
	      else
		{
		  f = ((~f) + 1);
		}
	    }
d1757 4
a1760 1
      else 
d1762 1
a1762 3
	  /* oh dear value is out of range */

	  if (e > 127)
d1764 1
a1764 21
	      if (e != 0x3ff || f != 0xffffffffU)
		{
		  cc_warn( "floating point accuracy completely lost! (e = 0x%x, s = 0x%x, f = 0x%x)",
			  e + 0x3ff, s, f );
		}
		
	      if (s == 0)
		{
		  /* largest positive value */
		  
		  e = 0x7f;
		  f = 0x7fffffffU;
		}
	      else
		{
		  /* largest negative value */
		  
		  e = 0x7f;
		  s = 1;
		  f = 0;
		}
d1768 1
a1768 21
	      if (e != 0xfffff400U || f != 0x0U)
		{
		  cc_warn( "floating point accuracy completely lost!(e = 0x%x, s = 0x%x, f = 0x%x)",
			  e + 0x3ff, s, f );
		}
		
	      if (s == 0)
		{
		  /* smallest positive value */
		  
		  e = 0x81;	/* beware of 0.0 */
		  f = 0x0;
		}
	      else
		{
		  /* smallest negative value */

		  e = 0x80;
		  s = 1;
		  f = 0x7fffffffU;
		}
d1775 13
a1787 1
      *low_return = (s << 31) | (f >> 1);
d1789 4
a1792 2
  
  return (e << 24) | (s << 23) | ((f >> 9) & ((1 << 23) - 1));  
@


1.33
log
@fixed bug whereby procflags was not being reset before emitting J_ENTER
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.32 $ 20\n";
d416 4
@


1.32
log
@minor cosmetic changes
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.31 $ 20\n";
d1193 2
d1470 2
@


1.31
log
@fixed X_DataAddr to cope with functions and symbols
@
text
@d5 1
a5 1
 * tidied up by NC 1991
d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.30 $ 20\n";
d1564 230
d1848 1
a1848 1

d1898 1
d1929 3
a1931 1
		    output_symbol( curdsymb->extsym,curdsize );
d1934 3
a1936 1
		    output_symbol( dsymb->extsym, 0 );
d2007 1
a2007 1
#endif /*TARGET_IS_C40 */
d2049 3
a2051 1
		    loopend( l );
d2074 10
d2088 1
d2106 1
a2106 1
		  vm.i   = fc->floatbin.irep[ 0 ];
d2109 1
a2109 1
		  
d2114 5
a2118 2
		      vm.i   = fc->floatbin.irep[ 1 ];
		      
d2162 3
a2164 1
		loopend( l );
d2178 1
a2178 1
		  
d2219 3
a2221 1
	output_symbol( curdsymb->extsym, curdsize );
d2229 1
a2229 1
    
d2494 1
a2494 1
     objword( codesize - sizeof_int );
@


1.30
log
@fixed decoding of DATAMODULE
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.29 $ 20\n";
d397 5
a401 2
      
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
d419 4
a422 1
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
@


1.29
log
@added X_DataSymb to cope with references to external function pointers
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.28 $ 20\n";
d52 1
a52 1
void		export_data_symbol( Symstr * name, RealRegister dest, int rpt, int offset, int len, int current_offset );
d162 1
a162 1
      fprintf( stderr, "WARNING: objbyte has no output stream, wanted to write byte %d\n", b );
d180 1
a180 1
  val = x & 0xff;
d184 1
a184 1
  val = ((x >> 8) & 0xff);
d188 1
a188 1
  val = ((x >> 16) & 0xff);
d192 1
a192 1
  val = ((x >> 24) & 0xff);
d585 4
d627 5
a631 1
            
d752 1
a752 1
      
d756 1
a756 1

d758 1
a758 1

d770 1
a770 1
      objsymbol( '_', symname_( sym ) );	/* ... specified by symbol */
d1006 1
a1006 1
	      fprintf( stderr, "heliobj: unknown cross refernce type %x\n", xrtype );
d1283 1
d1285 1
d1287 1
a1287 1

d1528 1
d1555 1
@


1.28
log
@changed asm comment character
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.27 $ 20\n";
d743 7
d751 10
a760 1
      syserr( "objdirective: DataSymb cross references not yet implemented!\n" );
d762 1
a762 1
      return 0;
d764 2
d2194 6
@


1.27
log
@added comment
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.26 $ 20\n";
d1146 1
a1146 1
      fprintf( asmstream, "*\n* Function Stubs\n" );
d1416 1
a1416 1
      fprintf( asmstream, "*\n* Data / Function Table Initialisation\n" );
@


1.26
log
@homm
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.25 $ 20\n";
d1040 11
@


1.25
log
@oops changed wrong test
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.24 $ 20\n";
a32 2
#define SMT	/* use split module tables */

d154 1
a154 5
#ifdef SMT
int			split_module_table = 1;
#else
int			split_module_table = 0;
#endif
d2018 2
a2019 2
	 
	  objlabel( '.', symname_( s ) );
@


1.24
log
@removed redundant test
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.23 $ 20\n";
d650 1
a650 1
      if (split_module_table && is_function( sym ))
d707 1
a707 1
      if (split_module_table)
@


1.23
log
@changed OBJIMAGESIZE to OBJMODSIZE
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.22 $ 20\n";
d707 1
a707 1
      if (split_module_table && is_function( sym ))
@


1.22
log
@changed loading of static data pointer
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.21 $ 20\n";
d75 1
a75 1
#define OBJIMAGESIZE  	0x0e
d750 1
a750 1
      fprintf( stderr, "warning: DataSymb cross references not yet implemented!\n" );
@


1.21
log
@added two new cross reference types X_DataAddr and X_DataAddr1
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.20 $ 20\n";
a1467 2
  load_static_data_ptr( R_ATMP, split_module_table, NULL );

d1585 2
@


1.20
log
@now uses C40 specific start up code
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.19 $ 20\n";
d386 42
d430 1
a430 1
      
d997 3
a999 1
	    case X_DataSymbLo:	      
@


1.19
log
@added third parameter to calls to load_static_data_ptr
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.18 $ 20\n";
d50 9
d1396 14
d1418 1
a1418 1
      
d1420 2
d1644 1
a1644 1
	      
@


1.18
log
@fixed calculation of module size
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.17 $ 20\n";
d1399 1
a1399 1
  load_static_data_ptr( R_ATMP, split_module_table );
d1541 1
a1541 1
	      load_static_data_ptr( R_ATMP, NO );
@


1.17
log
@unknown mods
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.16 $ 20\n";
d2123 1
a2123 1
     objword( codesize );
@


1.16
log
@more little-endian / big endian fixes
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.15 $ 20\n";
d1344 4
@


1.15
log
@fixed X_Datamodule not to shift module number as this already done for us
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.14 $ 20\n";
d113 1
a113 2
#define fits_in_5_bits( val )		(((val) & (unsigned long) 0xfffffff0L) == 0 || \
					 ((val) & (unsigned long) 0xfffffff0L) == (unsigned long) 0xfffffff0L)
d174 2
d177 1
a177 1
  fwrite( &x, 1, sizeof (unsigned char), objstream );
d179 3
a181 1
  x >>= NUM_BITS_PER_BYTE;
d183 3
a185 1
  fwrite( &x, 1, sizeof (unsigned char), objstream );
d187 3
a189 3
  x >>= NUM_BITS_PER_BYTE;
  
  fwrite( &x, 1, sizeof (unsigned char), objstream );
d191 1
a191 1
  x >>= NUM_BITS_PER_BYTE;
a192 2
  fwrite( &x, 1, sizeof (unsigned char), objstream );
  
d195 1
a195 2
  int32	copy;
  
d197 1
a197 3
  copy = x >> NUM_BITS_PER_BYTE * 3;
  
  fwrite( &copy, 1, sizeof (unsigned char), objstream );
d199 1
a199 1
  copy = x >> NUM_BITS_PER_BYTE * 2;
d201 1
a201 1
  fwrite( &copy, 1, sizeof (unsigned char), objstream );
d203 1
a203 1
  copy = x >> NUM_BITS_PER_BYTE;
d205 3
a207 1
  fwrite( &copy, 1, sizeof (unsigned char), objstream );
d209 1
a209 1
  fwrite( &x, 1, sizeof (unsigned char), objstream );
d827 1
a827 1
	  int32		x = codexrefs->codexroff & 0x00ffffffL;
d833 1
a833 1
	      xrtype = codexrefs->codexroff & (unsigned long)0xff000000L;
d848 19
a866 2
      for (i = b; i < (b + n); i++)
	objbyte( buff[ i ] );
@


1.14
log
@fixed X_DataModule to use _name not .name
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.13 $ 20\n";
a537 7
      if (split_module_table)
	{
	  objbyte( PATCHSHIFT );		/* ... the result of shifting ... */
      
	  objnum( 1 );				/* ... up by 1 bit ... */
	}
      
@


1.13
log
@fixed bug in data initialisation skipping nulls
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.12 $ 20\n";
d547 1
a547 1
      objsymbol( '.', symname_( sym ) );	/* ... the symbol */
@


1.12
log
@fixed calculation of entry in function tables for X_DataModule2
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.11 $ 20\n";
d1490 3
a1541 3
#ifdef TARGET_IS_C40
	  unsigned long	pending_inc = 0;
#endif
d1693 1
a1693 1
		  pending_inc += (rpt * len) / sizeof_int;	/* R_ATMP holds a word pointer */		  
@


1.11
log
@now uses new patch types PATCHC40MASK16ADD and PATCHC40MASK24ADD
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.10 $ 20\n";
d597 7
@


1.10
log
@now does not generate data initialisation code if there is no data to initialise
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.9 $ 20\n";
d33 2
d109 2
d148 1
d150 3
a154 1

d334 1
a334 1
      objbyte( PATCHADD );			/* ... adding ... */
d336 1
a336 1
      objnum( code );				/* ... the current word op code to ... */
d379 1
a379 6
       * the instruction we are patching
       * adds 3 to the PC of the instruction, and then adds
       * in the displacement.  (These values are in words).
       * In order to allow for this we subtract 3 words
       * from the value calculated as the label reference.
       * This is done by using a recursive patch! Ta Da!
d384 1
a384 3
      objbyte( PATCHADD );			/* ... adding ... */
	  
      objnum( code );				/* ... the current word of code to ... */
d386 1
a386 1
      objbyte( PATCHADD );			/* ... the result of subtracting ... */
a387 2
      objnum( -3 );				/* ... 3 words from ... */
      
d534 1
a534 1
      objbyte( PATCHADD );			/* ... adding ... */
d536 1
a536 1
      objnum( code );				/* ... the current word op code to ... */
d582 1
a582 1
      objnum( 0 );				/* ... a dummy value and ... */
d595 1
a595 1
      objnum( 0 );				/* ... a dummy value and ... */
d615 1
a615 1
      objnum( 0 );				/* ... a dummy value and ... */
d626 1
a626 1
      objnum( 0 );				/* ... a dummy value and ... */
d637 1
a637 1
      objnum( 0 );				/* ... a dummy value and ... */
d646 1
a646 1
      objbyte( PATCHADD );			/* ... adding ... */
d648 1
a648 1
      objnum( code );				/* ... the current word op code to ... */
d670 1
a670 1
      objbyte( PATCHADD );			/* ... adding ... */
d672 1
a672 1
      objnum( code );				/* ... the current word op code to ... */
@


1.9
log
@fixed PCreloc patching
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.8 $ 20\n";
d975 1
a975 1
#if defined TARGET_IS_C40 && !defined NEVER
d1489 2
d1492 1
a1492 1
      prepare_for_function_exporting();
d1494 6
a1499 3

      if (!suppress_module)
	export_routines();
d1515 3
a1517 3
	  if (datainitp)
	    load_static_data_ptr( R_ATMP, NO );
	}
d1520 1
a1520 2
      if (datainitp)
	prepare_for_data_exporting( R_ATMP );
d1522 4
a1525 2
      
      for (p = datainitp; p != NULL; p = p->datacdr)
d1539 1
a1539 1

@


1.8
log
@removed spurious debug left over from previous delta
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.7 $ 20\n";
d382 5
a386 1
      objbyte( PATCHADD );			/* ... subtracting ... */
d390 1
a390 5
      objbyte( PATCHADD );			/* ... the result of adding ... */
	  
      objnum( code );				/* ... the current word of code ... */

      objbyte( PATCHSHIFT );			/* ... to the result of shifting ... */
d394 1
a394 1
      objbyte( OBJLABELREF );			/* ... to the offset of ... */
d598 9
a606 2
            
      objbyte( OBJDATASYMB );			/* ... the module number of ... */
d608 1
a608 1
      objsymbol( '_', symname_( sym ) );	/* ... the specified symbol */
d656 10
a665 3
      objbyte( OBJDATASYMB );			/* ... the offset into the module table of ... */

      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
d684 10
a693 3
      objbyte( OBJDATASYMB );			/* ... the offset into the module table of ... */

      objsymbol( '_', symname_( sym ) );	/* ... the symbol */
d1510 2
a1511 1
	  load_static_data_ptr( R_ATMP, NO );
d1515 2
a1516 1
      prepare_for_data_exporting( R_ATMP );
d1519 1
a1519 1
      for (p = datainitp; p != 0; p = p->datacdr)
@


1.7
log
@fixed so that labels are displayed during data initialisation
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.6 $ 20\n";
a1486 3
	  if (!asmstream)
	    fprintf( stderr, "UNABLE TO SET LABEL\n" );
	  
@


1.6
log
@added code to avoid redundant additions during data initialisation
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.5 $ 20\n";
d1143 2
a1145 2
	 
         show_code( sym );
a1380 4
  asm_lablist = NULL;

  show_code( 0 );

d1487 3
d1491 1
a1491 1
	  
d2054 4
d2059 1
a2059 1

@


1.5
log
@added support for static data initialisation
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.4 $ 20\n";
d1509 3
a1511 1

d1580 10
d1662 3
a1666 1
		  
d1668 1
d1688 12
d1726 3
a1728 1
		  
d1730 1
a1730 1
		  
d1736 3
a1738 1
		      
d1740 1
d1743 6
a1748 1

d1751 1
a1751 1

d1753 1
a1753 1

d1762 12
@


1.4
log
@enabled split module table
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.3 $ 20\n";
d109 2
d806 1
a806 1
	  int32		x = codexrefs->codexroff & 0x00ffffff;
d812 1
a812 1
	      xrtype = codexrefs->codexroff & (unsigned long)0xff000000;
d939 1
a939 1
  while ((codep / sizeof_int) - CODEVECSEGSIZE * i > CODEVECSEGSIZE)
d942 1
a942 1
                               CODEVECSEGSIZE * sizeof_int - overrun, segbase );
d944 1
a944 1
      segbase += CODEVECSEGSIZE * sizeof_int + overrun;
d950 1
a950 1
                (codep - CODEVECSEGSIZE * i * sizeof_int) - overrun, segbase );
d1156 1
a1163 4
#ifdef TARGET_IS_C40
  prepare_for_function_exporting();
#endif
    
d1207 1
a1207 1
#endif
a1210 4
#ifdef TARGET_IS_C40
  finished_function_exporting();
#endif
    
d1401 1
a1401 1
      if ( p->sort == LIT_ADCON )
d1472 4
d1490 1
a1490 1
	  
d1496 4
d1563 2
d1566 2
a1567 2
            case LIT_BBBB:    /* the next 4 are the same as LIT_NUMBER except   */
            case LIT_BBH:     /* for (as yet unsupported) cross compilation.    */
d1577 29
d1608 7
a1614 3
		      vr1.rr = R_DS;
		      vr2.r  = GAP;
		      vm.i   = val;
d1616 1
a1616 1
		      show_instruction( J_MOVK, vr1, vr2, vm );
d1618 3
a1620 2
		      justloaded = val;
		      justvalid  = YES;
d1630 3
d1643 2
a1644 1

d1725 3
a1727 1

d1752 2
a1753 1

d1766 4
@


1.3
log
@removed padding to 128 byte vboundary - it upset all the function calls
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.2 $ 20\n";
d142 1
a142 1
int			split_module_table = 0;
@


1.2
log
@added finsihed_exporting_functions()
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision: 1.1 $ 20\n";
d702 1
a702 1
  
a929 2
  IGNORE( name );

d952 23
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
char 		heliobj_version[] = "\nheliobj.c $Revision:$ 20\n";
d689 2
a690 1
      
d853 4
d909 1
a909 1
	    case X_Modnum:	      
d1191 4
d1333 1
a1333 1
      show_instruction( J_CMPK + Q_NE, vr1, vr2, vm );
d1338 1
a1338 1
      show_instruction( J_B + Q_NE, vr1, vr2, vm );
@
