head	1.94;
access;
symbols
	beta_release:1.68;
locks; strict;
comment	@ * @;


1.94
date	94.01.18.12.47.22;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	93.08.04.17.01.47;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	93.08.03.15.15.26;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	93.07.27.15.00.24;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	93.07.27.14.39.55;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	93.07.07.10.19.44;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	93.02.22.11.02.50;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	93.01.29.17.57.30;	author paul;	state Exp;
branches;
next	1.86;

1.86
date	93.01.25.11.39.46;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	92.12.16.19.24.13;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	92.12.09.15.53.12;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	92.11.30.15.36.07;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	92.11.04.17.34.50;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	92.10.25.14.02.56;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	92.10.20.16.22.16;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	92.10.20.16.18.01;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	92.10.08.15.33.57;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	92.10.02.11.18.44;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	92.09.11.09.34.56;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	92.09.03.15.41.38;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	92.08.25.15.36.58;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	92.08.24.16.28.26;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	92.07.29.11.25.45;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	92.07.14.17.43.55;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	92.07.13.10.13.50;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	92.07.13.10.07.10;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	92.06.24.07.38.39;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	92.06.19.11.18.48;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	92.06.19.11.04.21;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	92.06.18.08.47.55;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	92.06.10.08.52.17;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	92.06.09.13.17.24;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	92.06.09.11.24.32;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	92.06.05.08.05.51;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	92.06.02.14.19.41;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	92.06.01.11.40.49;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	92.05.20.17.12.37;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	92.05.14.11.17.25;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	92.05.13.14.27.48;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	92.05.06.13.40.38;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	92.04.23.15.23.24;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	92.04.23.08.23.41;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	92.04.22.16.47.33;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	92.04.16.14.02.52;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	92.04.14.08.07.58;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	92.04.13.15.55.41;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	92.04.03.15.38.04;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	92.03.31.17.52.40;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	92.03.19.17.55.54;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	92.03.17.17.55.33;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	92.03.17.14.21.28;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	92.03.16.14.57.39;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	92.03.13.12.05.29;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	92.03.02.11.59.44;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	92.02.28.16.37.45;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	92.02.24.11.33.21;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	92.02.20.17.46.59;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	92.02.19.18.00.25;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	92.02.19.16.14.11;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	92.02.18.16.00.42;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	92.02.17.16.13.37;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	92.02.13.12.57.48;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	92.02.10.15.00.43;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	92.02.10.14.32.45;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	92.02.06.16.40.04;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	92.01.31.18.07.01;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	92.01.28.12.46.49;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	92.01.16.13.28.40;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	91.12.12.09.12.35;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	91.12.10.17.33.05;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	91.12.05.10.39.41;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	91.11.05.16.50.49;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	91.11.03.12.06.25;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	91.10.29.09.39.52;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	91.10.11.15.09.37;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	91.10.11.13.20.17;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	91.10.10.16.14.28;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	91.10.10.13.49.03;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	91.10.07.16.16.59;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	91.10.04.13.51.39;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	91.10.02.15.28.15;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	91.10.02.10.35.12;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	91.10.01.12.38.25;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	91.10.01.12.34.48;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	91.10.01.09.37.00;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	91.09.20.17.18.56;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	91.09.20.09.21.37;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	91.09.19.12.17.19;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	91.09.17.10.47.35;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	91.09.17.09.28.49;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	91.08.30.15.43.20;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	91.08.29.16.54.55;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	91.08.22.16.59.03;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	91.08.22.14.58.57;	author nickc;	state Exp;
branches;
next	;


desc
@C40 disassembler
@


1.94
log
@added folding and applied bug fixes done to 350 version
@
text
@/*{{{  Comments */

/* c40/asm.c: Copyright (C) Codemist Ltd., 1991.                       */
/* c40/asm.c: Copyright (C) Perihelion Software Ltd., 1991, 1992, 1993, 1994. */

/* version 1 */

/* Assembler output is routed to asmstream, annotated if FEATURE_ANNOTATE.  */
/* See aoutobj.c for more details on datastructures.                        */

/* exports: asmstream, 
   display_assembly_code, asm_header, asm_trailer */

/*}}}*/
/*{{{  Includes */

#include <stdarg.h>
#include <errno.h>

#ifdef __STDC__
#  include <string.h>
#else
#  include <strings.h>
#endif

#include <ctype.h>

#include "helios.h"
#ifndef __C40
#define __C40
#endif
#include "module.h"
#include "globals.h"
#include "mcdep.h"
#include "xrefs.h"
#include "store.h"
#include "codebuf.h"
#include "ops.h"
#include "mcdpriv.h"
#include "builtin.h"
#include "version.h"
#include "errors.h"
#include "peep.h"

/*}}}*/
/*{{{  Types */

typedef enum
  {
    TYPE_SIGNED,
    TYPE_UNSIGNED,
    TYPE_FLOATING
  }
immed_type;

/*}}}*/
/*{{{  Macros */

#define toevensex( x, y )	(x)    /* for cross compilation one day */

/*}}}*/
/*{{{  Constants */

#define	ASM_COMMENT_CHAR	';'

/*}}}*/
/*{{{  Variables */

FILE *			asmstream   = NULL;
Symstr *		sym_reladdr = NULL;
static bool		patch_pend  = FALSE;

static int32	fncount;	/* maybe should be more global */
static bool	asm_error;
static int32	current_pos;	/* current byte offset into code */

/*}}}*/
/*{{{  Code */

/*{{{  asmf() */

/*
 * print a string to the assembler output stream
 */

void
asmf( const char * format, ... )
{
  va_list	args;
	

  if (asmstream == NULL)
    return;
  
  va_start( args, format );

/*  fflush( asmstream ); */
	
/*  fseek( asmstream, 0L, SEEK_END ); */

  (void) vfprintf( asmstream, (char *)format, args );

/* fflush( asmstream ); */
	
  va_end( args );

  return;
  
} /* asmf */

/*}}}*/
/*{{{  asm_blank() */

static void
asm_blank( int32 n )
{
  while (n-- > 0)
    asmf( "%c\n", ASM_COMMENT_CHAR );
    
  return;
    
} /* asm_blank */

/*}}}*/

#ifndef TARGET_IS_C40
/*{{{  asm_padcol8() */

static int32
asm_padcol8( int32 n )
{
  if (!annotations)
    n = 7;      /* compact the asm file */
    
  while (n < 8)
    fputc( ' ', asmstream ), n++;
    
  return n;
    
} /* asm_padcol8 */

/*}}}*/
#endif
/*{{{  pr_chars() */

static void
pr_chars( int32 w )   /* works on both sex machines */
{
  int	i, c;
    

  fputc( '\'', asmstream );
    
  for (i = 0; i < sizeof( int32 ); i++)
    {
      switch (c = ((unsigned char *)&w)[ i ])
	{
	case '\\':
	case '\'':
	case '\"':
	  break;
	  
	case '\a':
	  c = 'a';
	  break;
	  
	case '\b':
	  c = 'b';
	  break;
	  
	case CHAR_FF:
	  c = 'f';
	  break;
	  
	case '\n':
	  c = 'n';
	  break;
	  
	case CHAR_CR:
	  c = 'r';
	  break;
	  
	case '\t':
	  c = 't';
	  break;
	  
	case CHAR_VT:
	  c = 'v';
	  break;
	  
	default:
	  if (c < ' ' || c >= 127)
	    asmf( "\\%o", (int)c );
	  else
	    putc( c, asmstream );
	  continue;
	}
      
      putc( '\\', asmstream );
      putc( c,    asmstream );
    }
  
  fputc( '\'', asmstream );
  
  return;
  
} /* pr_chars */

/*}}}*/
/*{{{  pr_asmname() */

/*
 * prints the name of symbol 'sym' to the file 'stream'
 * sets 'asm_error' if the symbol does not exist
 */

static void
pr_asmname( Symstr * sym )
{
  char *	s = sym == 0 ? (asm_error = 1, "?") : symname_( sym );
    

  asmf( s );

  return;  
    
} /* pr_asmname */

/*}}}*/
/*{{{  decode_external() */

static unsigned32 xroffset = 0;

/* decode_external checks if (and by what) a location is to be relocated.  */

static Symstr *
decode_external( int32 p ) /* p is now a byte address */
{
  CodeXref *	x;
  
  
  for (x = codexrefs; x != NULL; x = x->codexrcdr)    /* SLOW loop !!! */
    {
      if (p == (x->codexroff & 0x00ffffffL))
	{
	  switch (x->codexroff & 0xff000000UL)
	    {
	    default:
	      xroffset = 0;
	      break;
	      
	    case X_DataAddr:
	    case X_DataAddr1:
	    case X_FuncAddr:
	    case X_absreloc:
	      xroffset = x->codexrlitoff;
	    }
	  
	  return x->codexrsym;
	}
    }
  
  /* syserr( syserr_decode_external );     *//* may exploit zero return one day */
  
  return 0;	/* not an external reference */
  
} /* decode_external */

/*}}}*/
/*{{{  printlabelname() */

static bool
printlabelname(
	       int32	offset,
	       bool	flag_errs )
{
  LabList *	p;
  
  
  /*
   * For data references, ignore the function name: it will be wrong for backward
   * references to the literal pool of another function.  (Labels which are the
   * subject of data references have already been removed from asm_lablist).
   * For code references, generate a label of the form L<label>F<proc>.
   * Such label names seem a bit long and ugly.
   */
  
  for (p = asm_lablist ; p != NULL ; p = p->labcdr)
    {
      LabelNumber *	lab = p->labcar;
      
      
      if ((lab->u.defn & 0x00ffffffL) == offset)
	{
	  asmf( "L%ldF%ld", (long)(lab_name_( lab ) & 0x7fffffffL), (long)fncount );
	  
	  return 1;
	}
    }
  
  if (flag_errs)
#if 0
    asmf( "<unknown destination> offset + base = %ld, current pos = %ld, offset = %ld",
	 (offset + codebase) / sizeof_int, current_pos / sizeof_int, offset / sizeof_int);
#else
  asmf( "0" );
#endif
  
  return 0;
  
} /* printlabelname */

/*}}}*/
/*{{{  decode_addr() */

/*
 * Decodes the address addr (referenced at code offset off in current function)
 * Works for external addresses
 */

static void
decode_addr( int32 offset )
{   
  Symstr *	name = decode_external( codebase + current_pos );
  
  
  /* First, is it an external name ? */

  if (name == bindsym_( codesegment ))
    {
      LabList *	p;
      

      /*
       * although we have found it in codexrefs, we may still be able to
       * produce a local label name for it
       */
      
      for (p = asm_lablist ; p != NULL ; p = p->labcdr)
	{
	  LabelNumber *	lab = p->labcar;
	  
	  
	  if ((codebase + (lab->u.defn & 0x00ffffff)) / sizeof_int == xroffset)
	    {
	      asmf( "L%ldF%ld", (long)(lab_name_( lab ) & 0x7fffffffL), (long)fncount );
	      
	      return;
	    }
	}
    }

  if (name != 0)
    {
      fputc( '_', asmstream );
      
      pr_asmname( name );
      
      if (xroffset != 0)
	asmf( " + 0x%lx", xroffset );

      return;
    }

  /* Otherwise, assume it is a local label */
  
  (void) printlabelname( codebase + current_pos + offset * sizeof_int, TRUE );	/* not right ??? */
  
  return;
  
} /* decode_addr */

/*}}}*/
/*{{{  _regname() */

/* Disassembler routines                                                 */

static char *	regstr =
  "R0 \0R1 \0R2 \0R3 \0R4 \0R5 \0R6 \0R7 \0"
  "AR0\0AR1\0AR2\0AR3\0AR4\0AR5\0AR6\0AR7\0"
  "DP \0IR0\0IR1\0BK \0SP \0ST \0DIE\0IIE\0"
  "IIF\0RS \0RE \0RC \0R8 \0R9 \0R10\0R11\0";

#define _regname( r ) ((((r) & 0x1f) * 4) + regstr)

/*}}}*/
/*{{{  _condname() */

static char *	condstr =
  "u\0\0\0\0lo\0\0\0ls\0\0\0hi\0\0\0hs\0\0\0eq\0\0\0ne\0\0\0"
  "lt\0\0\0le\0\0\0gt\0\0\0ge\0\0\0<xx>\0nv\0\0\0v\0\0\0\0"
  "nuf\0\0uf\0\0\0nlv\0\0lv\0\0\0nluf\0luf\0\0zuf\0\0"
  "<xx>\0<xx>\0<xx>\0<xx>\0<xx>\0<xx>\0<xx>\0"
  "<xx>\0<xx>\0<xx>\0<xx>\0";

#define _condname( r ) ((((r) & 0x1f) * 5) + condstr)

/*}}}*/
/*{{{  decode_indirect_address() */

/*
 * decodes the indirect addressing field of a 'C40 op code
 */

static void
decode_indirect_address(
			int32	mode,
			int32	addr,
			int32	disp )
{
  switch (mode)
    {
    case B_00000:	asmf( "*+AR%ld(%ld)",         addr, disp ); break;
    case B_00001:	asmf( "*-AR%ld(%ld)",         addr, disp ); break;
    case B_00010:	asmf( "*++AR%ld(%ld)",        addr, disp ); break;
    case B_00011:	asmf( "*--AR%ld(%ld)",        addr, disp ); break;
    case B_00100:	asmf( "*AR%ld++(%ld)",        addr, disp ); break;
    case B_00101:	asmf( "*AR%ld--(%ld)",        addr, disp ); break;
    case B_00110:	asmf( "*AR%ld++(%ld)%%",      addr, disp ); break;
    case B_00111:	asmf( "*AR%ld--(%ld)%%",      addr, disp ); break;
    case B_01000:	asmf( "*+AR%ld(IR0)",         addr       ); break;
    case B_01001:	asmf( "*-AR%ld(IR0)",         addr       ); break;
    case B_01010:	asmf( "*++AR%ld(IR0)",        addr       ); break;
    case B_01011:	asmf( "*--AR%ld(IR0)",        addr       ); break;
    case B_01100:	asmf( "*AR%ld++(IR0)",        addr       ); break;
    case B_01101:	asmf( "*AR%ld--(IR0)",        addr       ); break;
    case B_01110:	asmf( "*AR%ld++(IR0)%%",      addr       ); break;
    case B_01111:	asmf( "*AR%ld--(IR0)%%",      addr       ); break;
    case B_10000:	asmf( "*+AR%ld(IR1)",         addr       ); break;
    case B_10001:	asmf( "*-AR%ld(IR1)",         addr       ); break;
    case B_10010:	asmf( "*++AR%ld(IR1)",        addr       ); break;
    case B_10011:	asmf( "*--AR%ld(IR1)",        addr       ); break;
    case B_10100:	asmf( "*AR%ld++(IR1)",        addr       ); break;
    case B_10101:	asmf( "*AR%ld--(IR1)",        addr       ); break;
    case B_10110:	asmf( "*AR%ld++(IR1)%%",      addr       ); break;
    case B_10111:	asmf( "*AR%ld--(IR1)%%",      addr       ); break;
    case B_11000:	asmf( "*AR%ld",               addr       ); break;
    case B_11001:	asmf( "*AR%ld++(IR0)B",       addr       ); break;
    default:
      syserr( syserr_unknown_indirect_mode, mode );
    }
  
  return;
  
} /* decode_indirect_addressing */

/*}}}*/
/*{{{  mask_and_sign_extend_word() */

/*
 * Extracts the bits specified by 'mask' from the word 'value'
 * If necessary the resulting word is sign extended.
 * 'mask' must be a contigous set of bits starting from
 * the least significant bit.
 */

signed long
mask_and_sign_extend_word(
			  unsigned long	value,
			  unsigned long	mask )
{
  value &= mask;
  
  if (value & ((mask + 1) >> 1))
    {
      value |= ~mask;
    }
  
  return (signed long)value;
  
} /* mask_and_sign_extend_word */

/*}}}*/
/*{{{  decode_short_float() */

/*
 * turns a 16 bit integer into a string
 * representing a short format C40 style
 * floating point number
 */

static const char *
decode_short_float( int32 number )
{
  static char	buffer[ 20 ];
  int32		e;
  int32		s;
  int32		f;
  union
    {
      float		f;	/* XXX beware of assumption that 	*/
      unsigned long	l;	/* sizeof (float) == sizeof (long)	*/
    }
  converter;
  
  
  if (number & 0xffff0000U)
    {
      return "bad format short float";
    }
  
  /*
   * format is ...
   *
   *
   *  15      12   11   10       0
   *  ____________________________
   * |          |      |          |
   * | exponent | sign | mantissa |
   * |          |      |          |
   *  ----------------------------
   *
   * interpretation is ...
   *
   * e = -8, s = 0, m = 0 => 0.0
   * s = 0                =>   01.m  x 2^e
   * s = -1               => -(10.m) x 2^e
   *
   */
  
  /* extract components */
  
  e = (number & 0xf000U) >> 12;
  s =  number & 0x0800U;
  f =  number & 0x07ffU;
  
  e = mask_and_sign_extend_word( e, 0xf );
  
  /* handle the special case */
  
  if (s == 0 && e == -8 && f == 0)
    {
      return "0.0";
    }
  
  /* convert the binary value into host specific floating point value */
  
#ifdef __HELIOSC40
  
  /* convert to C40 single precision */
  
  converter.l = (e << 24) | (s << (23 - 11)) | (f << (22 - 10));
  
#else
  
  /* convert to IEEE single precision */
  
  e += 0x7f;
  
  if (s == 0)
    {
      converter.l = (e << 23) | (f << (22 - 10));
    }
  else
    {
      if (f == 0)
	{
	  converter.l = ((e + 1) << 23) | (1 << 31);
	}
      else
	{
	  converter.l = (e << 23) | (((((~f) + 1) << (22 - 10))) & ((1 << 23) - 1)) | (1 << 31);
	}
    }
#endif /* __HELIOSC40 */
  
  /* convert to a string */
  
  sprintf( buffer, "%f", converter.f );
  
  /* return the string */
  
  return buffer;
  
} /* decode_short_float */

/*}}}*/
/*{{{   * decodes the addressing modes () */

/*
 * decodes the addressing modes (the 'G' field)
 * of a 'C40 diadic op code
 */

static void
decode_diadic_address(
		      int32		op_code,	/* instruction */
		      char *		instruction,	/* string identifying instruction */
		      immed_type	type,		/* type of immediate values */
		      int32		store )		/* non zero if a store operation */
{
  char *	pdest;
  int32		dest;
  int32		src;
  
  
  /*
   * we have a diaidic op code
   *
   * bits 16 - 20 encode destination
   * bits 21 - 22 encode addressing type
   * bits 23 - 28 encode op code
   * bits 29 - 31 are 000
   */
  
  if ((op_code >> 23) == OP_RPTS || (op_code >> 23) == OP_IACK)
    {
      /* this op code has no destination */
      
      pdest = NULL;
      dest  = 0;      
    }
  else
    {
      dest = (op_code >> 16) & 0x1f;
      
      if (type == TYPE_FLOATING && (op_code >> 23) != OP_FIX)
	{
	  /* the destination (or source) register of a floating point op must be R0 - R11 */
	  
	  if (!is_extended_precision_register( dest ))
	    {
	      syserr( syserr_destination_not_FP, instruction, _regname( dest ) );
	    }
	}
      
      pdest = _regname( dest );
    }
  
  asmf( "%s\t", instruction );
  
  switch ((op_code >> 21) & 0x3)
    {
    case 0: /* register to register */
      /*
       * we have a diaidic op code, using register addressing
       *
       * bits  0 - 4  encode source register
       * bits  5 - 15 are 00000000000
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */
      
      if (op_code & 0xffe0)
	{
	  syserr( syserr_bad_source_value, instruction, op_code );
	}
      
      src = op_code & 0x1f;
      
      if (type == TYPE_FLOATING)
	{
	  /* the source register of a floating point op must be R0 - R11 */
	  
	  if (!is_extended_precision_register( src ))
	    {
	      syserr( syserr_source_not_FP, _regname( src ), instruction, op_code );
	    }
	}
      
      asmf( "%s", _regname( src ) );
      
      if (pdest && (dest != src || !is_monadic( op_code )))
	asmf( ", %s", pdest );
      
      break;
      
    case 1: /* direct */
      /*
       * we have a diaidic op code, using direct addressing
       *
       * bits  0 - 15 are an unsigned offset to the data page register
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */
      
      if (store)	/* pdest is actually source */
	asmf( "%s, @@%#04.4lx", pdest, (op_code & 0xffff) );
      else if (pdest)
	asmf( "@@%#04.4lx, %s", (op_code & 0xffff), pdest );
      else
	asmf( "@@%#04.4lx", (op_code & 0xffff) );
      
      break;
      
    case 2: /* indirect */
      /*
       * we have a diaidic op code, using indirect addressing
       *
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */
      
	{
	  int32		disp = op_code & 0xff;
	  int32		addr = (op_code >> 8) & 0x7;
	  
	  
	  if (store)
	    {
	      asmf( "%s, ", pdest );
	      
	      decode_indirect_address( op_code >> 11 & 0x1f, addr, disp );
	    }
	  else
	    {
	      decode_indirect_address( (op_code >> 11) & 0x1f, addr, disp );
	      
	      if (pdest)
		asmf( ", %s", pdest );
	    }
	}
      break;
      
    case 3: /* immediate */
      /*
       * we have a diaidic op code, using immeadiate addressing
       *
       * bits  0 - 15 are a signed immeadiate value
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */
      
      if (type == TYPE_SIGNED)
	dest = mask_and_sign_extend_word( op_code, 0x0000ffffU );
      else
	dest = op_code & 0xffffU;
      
      if (sym_reladdr != NULL)
	{
	  /* we know how this constant was calculated ... */

	  if (exporting_routines)
	    asmf( "L%ldF%ld - .%s, %s", (long)(lab_name_( exporting_routines ) & 0x7fffffffL),
		 (long)fncount, symname_( sym_reladdr ), pdest );	  
	  else
	    /*
	     * XXX
	     * 
	     * The + 1 below comes from the fact that the SUBI is the third instruction after
	     * the LAJ 4 generated by the code loading the address of a function 
	     * [gen.c: load_address_constant()].  This is only true whilst a NOP is being
	     * inserted after the LAJ because of a silicon bug.  Hence if the bug is fixed
	     * and the NOP is removed, the +1 will have to be changed (probably to +2).
	     */

	    asmf( ".%s + 1, %s", symname_( sym_reladdr ), pdest );
	}
      else if (type == TYPE_FLOATING)
	{
	  asmf( "%s, %s", decode_short_float( dest ), pdest );
	}
      else if (dest < 500 && dest > -500 && type == TYPE_SIGNED)
	{
	  asmf( "%-3ld, %s", dest, pdest );
	}
      else if (pdest)
	{
	  asmf( "%#-3lx, %s", dest, pdest );
	}
      else
	{
	  asmf( "%#-3lx", dest );
	}
      
      if (sym_reladdr != NULL)
	{
	  /*
	   * be ready to print out the symbol that is
	   * responsible for the value just display.
	   *
	   * NB/ we must not replace the value in the
	   * instruction with the symbol's name, as it
	   * is almost certain that some calculations
	   * have been performed on the value.
	   */
	  
	  asmf( "\t%c", ASM_COMMENT_CHAR );
	}
      
      break;
      
    }
  
  return;
  
} /* decode_diadic_address */

/*}}}*/
/*{{{  decode_integer_store() */

/*
 * handle the special case of the STI op code
 */

static void
decode_integer_store( int32 op_code )
{
  int32		dest;
  
  
  /*
   * we have an integer store
   *
   * bits  0 - 15 encode destination
   * bits 16 - 20 encode source
   * bits 21 - 22 encode addressing type
   * bits 23 - 31 are 000101010
   */
  
  dest = (op_code >> 16) & 0x1f;
  
  switch ((op_code >> 21) & 0x3)
    {
    case 0: /* indirect immediate */
      /*
       * bits  0 - 15 are an unsigned offset from the data page register
       * bits 16 - 20 encode value
       * bits 21 - 31 are 00010101000
       */
      
      asmf( "STIK\t%-3ld, @@%#04.4lx",
	      mask_and_sign_extend_word( dest, 0x1f ), (op_code & 0xffff) );
      
      break;
      
    case 1: /* direct register */
      /*
       * bits  0 - 15 are an unsigned offset to the data page register
       * bits 16 - 20 encode source register
       * bits 21 - 31 are 00010101001
       */
      
      asmf( "STI\t%s, @@%#04.4lx", _regname( dest ), (op_code & 0xffff) );
      
      break;
      
    case 2: /* indirect register */
      /*
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode source register
       * bits 21 - 31 are 00010101010
       */
      
      asmf( "STI\t%s, ", _regname( dest ) );
      
      decode_indirect_address( (op_code >> 11) & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );
      
      break;
      
    case 3: /* indirect immediate */
      /*
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode source value
       * bits 21 - 31 are 00010101011
       */
      
      asmf( "STIK\t%-3ld, ", mask_and_sign_extend_word( dest, 0x1f ) );
      
      decode_indirect_address( (op_code >> 11) & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );
      
      break;
      
    }
  
  return;
  
} /* decode_integer_store */

/*}}}*/
/*{{{  decode_flow_control() */

/*
 * decodes a 'C40 opcode concerned with handling program execution
 */

static void
decode_flow_control(
		    int32	op_code, 	/* instruction				*/
		    bool	flag_errs )	/* TRUE if errors should be reported	*/
{
  /*
   * we have a flow control op code
   *
   * bits 30 - 31 are 01
   *
   * other bits are semi-random
   */
  
  if (op_code & (1 << 29))
    {
      /* bits 29 - 31 are 011 */
      
      if (op_code & (1 << 28))
	{
	  /* bits 28 - 31 are 0111 */
	  
	  if (op_code & (1 << 27))
	    {
	      /* bits 27 - 31 are 01111 */
	      
	      if (op_code & (1 << 24))
		{
		  /*
		   * we have a repeat block with register addressing
		   *
		   * bits  0 -  4 encode the source
		   * bits  5 - 22 are 000000000000000000
		   * bit  23      encodes the delay
		   * bits 24 - 31 are 01111001
		   */
		  
		  if (op_code & (1 << 23))
		    {
		      asmf( "RPTBD\t%s", _regname( op_code ) );
		    }
		  else
		    {
		      asmf( "RPTB\t%s", _regname( op_code ) );
		    }
		}
	      else
		{
		  /* bits 24 - 31 are 01111xx0 */
		  
		  if (op_code & (1 << 23))
		    {
		      /*
		       * we have a conditional return from subroutine
		       *
		       * bits  0 - 15 are 0000000000000000
		       * bits 16 - 20 encode the condition 
		       * bits 21 - 31 are 01111000100
		       */
		      
		      asmf( "RETS%s", _condname( op_code >> 16 ) );
		    }
		  else
		    {
		      /*
		       * we have a conditional return from interrupt
		       *
		       * bits  0 - 15 are 0000000000000000
		       * bits 16 - 20 encode the condition
		       * bit  21      encodes the delay type
		       * bits 22 - 31 are 0111100000
		       */
		      
		      if (op_code & (1 << 21))
			{
			  asmf( "RETI%sD", _condname( op_code >> 16 ) );
			}
		      else
			{
			  asmf( "RETI%s", _condname( op_code >> 16 ) );
			}
		    }
		}
	    }
	  else
	    {
	      /* bits 27 - 31 are 01110 */
	      
	      if (op_code & (1 << 26))
		{
		  /* bits 26 - 31 are 011101 */
		  
		  if (op_code & (1 << 25))
		    {
		      /*
		       * we have a transfer between register file and expansion register file
		       *
		       * bits  0 -  5 encode the source register
		       * bits  6 - 15 are 0000000000
		       * bits 16 - 20 encode the destination register
		       * bits 21 - 22 are 00
		       * bit  23      encodes the transfer type
		       * bits 24 - 31 are 01110110
		       */
		      
		      if (op_code & (1 << 23))
			{
			  asmf( "LDPE\t%s, %s",
			       _regname( op_code ),
			       (((op_code >> 16) & 0xf) == 0) ? "IVTP" : "TVTP" );
			}
		      else
			{
			  asmf( "LDEP\t%s, %s",
			       ((op_code & 0xf) == 0) ? "IVTP" : "TVTP",
			       _regname( op_code >> 16 ) );
			}
		    }
		  else
		    {
		      char	op[ 10 ];
		      
		      
		      /*
		       * we have a conditional trap
		       *
		       * bits  0 -  8 encode the trap number
		       * bits  9 - 15 are 0000000
		       * bits 16 - 20 encode the condition
		       * bits 21 - 22 are 00
		       * bit  23      encodes the trap type
		       * bits 24 - 31 are 01110100
		       */
		      
		      if (op_code & (1 << 23))
			{
			  strcpy( op, "LAT" );
			}
		      else
			{
			  strcpy( op, "TRAP" );
			}
		      
		      strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		      
		      asmf( "%s\t%lu", op, op_code & 0x1ff );
		    }
		}
	      else
		{
		  char	op[ 10 ];
		  
		  
		  /*
		   * we have a conditional jump to subroutine
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21      encodes the jump type
		   * bits 22 - 24 are 000
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011100
		   */
		  
		  if (op_code & (1 << 21))
		    {
		      strcpy( op, "LAJ" );
		    }
		  else
		    {
		      strcpy( op, "CALL" );
		    }
		  
		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		  
		  if (op_code & (1 << 25))
		    {
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
		      
		      asmf( "%s\t%+ld", op, op_code );
		    }
		  else
		    {
		      asmf( "%s\t%s", op, _regname( op_code & 0x1f ) );
		    }
		}
	    }
	}
      else
	{
	  /* bits 28 - 31 are 0110 */
	  
	  if (op_code & (1 << 27))
	    {
	      /* bits 27 - 31 are 01101 */
	      
	      if (op_code & (1 << 26))
		{
		  char	op[ 10 ];
		  int32	addr;
		  int	offset = 0;
		  
		  
		  /*
		   * we have a conditional decrement and branch
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21      encodes delay
		   * bits 22 - 24 encodes the address register to be decremented
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011011
		   */
		  
		  strcpy( op, "DB" );
		  
		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		  
		  if (op_code & (1 << 21))
		    {
		      strcat( op, "D" );
		      
		      offset = 4;
		    }
		  else
		    {
		      offset = 1;
		    }
		  
		  addr = (op_code >> 22) & 0x7;
		  
		  if (op_code & (1 << 25))
		    {
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
		      
		      asmf( "%s\tAR%1ld, ", op, addr );
		      
		      if (!printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs ))
			{
			  asmf( "\t%c offset = %+ld", ASM_COMMENT_CHAR, (op_code + offset) );
			}
		    }
		  else
		    {
		      asmf( "%s\tAR%1ld, %s", op, addr, _regname( op_code & 0x1f ) );
		    }
		}
	      else
		{
		  char	op[ 10 ];
		  int	offset = 0;
		  
		  
		  /*
		   * we have a conditional branch
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21 - 23 encode the type of branch
		   * bits 24      is 0
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011010
		   */
		  
		  strcpy( op, "B" );
		  
		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		  
		  switch ((op_code >> 21) & 0x7)
		    {
		    case B_000:	                    offset = 1; break;
		    case B_001:	strcat( op, "D"  ); offset = 3; break;
		    case B_010:	syserr( syserr_unknown_op_code, op_code ); return;
		    case B_011:	strcat( op, "AT" ); offset = 3; break;
		    case B_100:	syserr( syserr_unknown_op_code, op_code ); return;
		    case B_101:	strcat( op, "AF" ); offset = 3; break;
		    case B_110:	syserr( syserr_unknown_op_code, op_code ); return;
		    case B_111:	syserr( syserr_unknown_op_code, op_code ); return;
		    }
		  
		  if (op_code & (1 << 25))
		    {
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
		      
		      asmf( "%s\t", op );
		      
		      if (!printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs ))
			{
			  asmf( "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code + offset );
			}
		    }
		  else
		    {
		      asmf( "%s\t%s", op, _regname( op_code & 0x1f ) );
		    }
		}
	    }
	  else
	    {
	      int	offset = 0;
	      
	      
	      /* bits 27 - 31 are 01100 */
	      
	      switch ((op_code >> 24) & 0x7)
		{
		case B_000:	asmf( "BR\t"    ); offset = -2; break;
		case B_001:	asmf( "BRD\t"   ); offset = -4; break;
		case B_010:	asmf( "CALL\t"  ); offset = -2; break;
		case B_011:	asmf( "LAJ\t"   ); offset = -4; break;
		case B_100:	asmf( "RPTB\t"  ); offset = 0;  break;
		case B_101:	asmf( "RPTBD\t" ); offset = 3;  break;
		case B_110:	asmf( "SWI\t"   ); return;
		default:
		case B_111:	syserr( syserr_unknown_op_code, op_code ); return;					
		}

	      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffffL );
	      
	      if (op_code == 1 && offset == -4)
		{
		  /*
		   * A 'LAJ' with an offset of 1 is a special case.
		   * What it is doing is putting the PC into R11 so
		   * that the next few instructions can be PC relative
		   * (This is the only way to access the value of the PC
		   * on the 'C40).  See the code for load_address_constant()
		   * in c40/gen.c
		   */
		  
		  asmf( "4\t%c <fetching PC>", ASM_COMMENT_CHAR );
		}
	      else if (offset < 0)
		{
		  if (sym_reladdr != NULL)
		    {
		      /*
		       * this instruction will have been issued as a
		       * LIT_RELADDR and so the function name will be
		       * decoded later
		       */
		    }
		  else
		    {
#if 1
		      if (!printlabelname( current_pos + (op_code - offset - 1) * sizeof_int, FALSE ))
			{
			  asmf( "%ld %c%c offset = %+ld", op_code - offset - 1,
			       patch_pend ? ')' : ' ',
			       ASM_COMMENT_CHAR, op_code - offset - 1 );
			}
#else
		      asmf( "%ld", op_code - offset - 1 );
#endif
		    }
		}
	      else
		{
		  if (!printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs ))
		    {
		      asmf( "%c offset = %+ld", ASM_COMMENT_CHAR, op_code + offset );
		    }
		}
	    }
	}
    }
  else
    {
      char 		op[ 10 ];
      immed_type	type;
      
      
      /*
       * we have a conditional load op
       *
       * bits  0 - 15 encode the source
       * bits 16 - 20 encode the destination
       * bits 21 - 22 encode the addressing mode
       * bits 23 - 27 encode the condition
       * bit  28      encodes op
       * bits 29 - 31 are 010
       */
      
      if (((op_code >> 28) & 0x1) == 0)
	{
	  strcpy( op, "LDF" );
	  
	  type = TYPE_FLOATING;
	}
      else
	{
	  strcpy( op, "LDI" );
	  
	  type = TYPE_SIGNED;
	}
      
      strcat( op, _condname( (op_code >> 23) & 0x1f ) );

      decode_diadic_address( op_code, op, type, FALSE );
      
      return;
    }
  
  return;
  
} /* decode_flow_control */

/*}}}*/
/*{{{  decode_non_word_load() */

/*
 * decodes a 'C40 op code concerened with loading non-word quantities
 */

static void
decode_non_word_load( int32 op_code ) /* instruction */
{
  char	op[ 5 ];
  int	B;
  
  
  /*
   * we have a non-word data transfer
   *
   * bits  0 - 16 encode source
   * bits 17 - 20 encode destination
   * bits 21 - 22 encode addressing type
   * bits 23 - 24 MAY encode a byte selector
   * bits 24 - 27 encode op
   * bits 28 - 31 are 1011
   */

  B = (int)((op_code >> 23) & 0x03);
  
  switch ((op_code >> 24) & 0x0f)
    {
    case OP_LB:
    case B_0001:
      strcpy( op, "LB0" );
      
      op[ 2 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_SIGNED, FALSE );
      
      break;

    case OP_LBU:
    case B_0011:
      strcpy( op, "LBU0" );
      
      op[ 3 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_LWL:
    case B_0101:
      strcpy( op, "LWL0" );

      op[ 3 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_LWR:
    case B_0111:
      strcpy( op, "LWR0" );

      op[ 3 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_MB:
    case B_1001:
      strcpy( op, "MB0" );

      op[ 2 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_LH:
      strcpy( op, "LH0" );

      op[ 2 ] = '0' + (B & 1);
      
      decode_diadic_address( op_code, op, TYPE_SIGNED, FALSE );
      
      break;
      
    case OP_LHU:
      strcpy( op, "LHU0" );

      op[ 3 ] = '0' + (B & 1);
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_MH:
      strcpy( op, "MH0" );

      op[ 2 ] = '0' + (B & 1);
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    default:
      syserr( syserr_unknown_op_code, op_code );
      break;
    }

  return;

} /* decode_non_word_load */

/*}}}*/
/*{{{  decode_special_triadic() */

/*
 * decodes a multiple parallel triadic op code
 */

static void
decode_special_triadic( int32 op_code ) /* instruction */
{
  char *	op1;
  char *	op2;
  int32		src1;
  int32		src2;
  int32		src3;
  int32		src4;
  int32		dst1;
  int32		dst2;
  
  
  /*
   * we have a special form of triadic op code
   *
   * bits  0 -  7 encode src4
   * bits  8 - 15 encode src3
   * bits 16 - 18 encode src2
   * bits 19 - 21 encode src1
   * bit  22      encodes dst2
   * bit  23      encodes dst1
   * bits 24 - 25 encode addressing mode
   * bits 26 - 27 encode operation
   * bits 28 - 31 are 1000
   */

  src4 =  op_code         & 0xff;
  src3 = (op_code >>   8) & 0xff;
  src2 = (op_code >>  16) & 0x7;
  src1 = (op_code >>  19) & 0x7;
  dst2 = ((op_code >> 22) & 0x1) + 2;
  dst1 = (op_code >>  23) & 0x1;
  
  switch ((op_code >> 26) & 0x3)
    {
    default:      
    case OP_MPYF3_ADDF3:	op1 = "MPYF3"; op2 = "ADDF3"; break;
    case OP_MPYF3_SUBF3:	op1 = "MPYF3"; op2 = "SUBF3"; break;
    case OP_MPYI3_ADDI3:	op1 = "MPYI3"; op2 = "ADDI3"; break;
    case OP_MPYI3_SUBI3:	op1 = "MPYI3"; op2 = "SUBI3"; break;
    }

  switch ((op_code >> 24) & 0x3)
    {
    case B_00:	/* src3 op1 src4, src1 op2 src2 */
      
      asmf( "%s\t", op1 );

      decode_indirect_address( src3 >> 3, src3 & 7, 1 );

      asmf( ", " );
      
      decode_indirect_address( src4 >> 3, src4 & 7, 1 );

      asmf( ", %s  || %s\t%s, %s, %s",
	      _regname( dst1 ), op2, _regname( src1 ), _regname( src2 ), _regname( dst2 ) );

      break;
      
    case B_01:	/* src3 op1 src1, src4 op2 src2 */
      
      asmf( "%s\t", op1 );
      
      decode_indirect_address( src3 >> 3, src3 & 7, 1 );

      asmf( ", %s, %s  || %s\t",
	      _regname( src1 ), _regname( dst1 ), op2 );

      decode_indirect_address( src4 >> 3, src4 & 7, 1 );

      asmf( ", %s, %s", _regname( src2 ), _regname( dst2 ) );

      break;
      
    case B_10:	/* src1 op1 src2, src3 op2 src4 */
      
      asmf( "%s\t%s, %s, %s  || %s\t",
	      op1, _regname( src1 ), _regname( src2 ), _regname( dst1 ), op2 );

      decode_indirect_address( src3 >> 3, src3 & 7, 1 );

      asmf( ", " );

      decode_indirect_address( src4 >> 3, src4 & 7, 1 );

      asmf( ", %s", _regname( dst2 ) );

      break;
      
    case B_11:	/* src3 op1 src1, src2 op2 src4 */
      
      asmf( "%s\t", op1 );

      decode_indirect_address( src3 >> 3, src3 & 7, 1 );

      asmf( ", %s, %s  || %s\t, %s, ",
	      _regname( src1 ), _regname( dst1 ), op2, _regname( src2 ) );

      decode_indirect_address( src4 >> 3, src4 & 7, 1 );

      asmf( ", %s", _regname( dst2 ) );

      break;
    }
  
  return;
  
} /* decode_special_triadic */

/*}}}*/
/*{{{  decode_non_word_load_or_triadic() */

static void
decode_non_word_load_or_triadic( int32 op_code ) /* instruction */
{
  /*
   * we have either a special form of triadic op code or a non-word data transfer
   *
   * bits 28 - 29 encode form
   * bits 30 - 31 are 10
   */

  switch ((op_code >> 28) & 0x3)
    {
    case B_00:	decode_special_triadic(         op_code ); break;
    case B_01:	syserr( syserr_unknown_op_code, op_code ); break;
    case B_10:	syserr( syserr_unknown_op_code, op_code ); break;
    case B_11:	decode_non_word_load(           op_code ); break;
    }

  return;

} /* decode_non_word_load_or_triadic */

/*}}}*/
/*{{{  decode_triadic_parallel_addressing() */

static void
decode_triadic_parallel_addressing(
				   int32	op_code,
				   char *	first_op,
				   char *	second_op )
{
  unsigned long	src1;
  unsigned long	src2;
  unsigned long	src3;
  unsigned long	dst1;
  unsigned long	dst2;

  
  /*
   * we have a triadic parallel op code of the form:
   *
   *    first_op  src2, src1, dst1
   * || second_op src3, dst2
   *
   *
   * bits  0 -  7 encode src2
   * bits  8 - 15 encode dst2
   * bits 16 - 18 encode src3
   * bits 19 - 21 encode src1
   * bits 22 - 24 encode dst1
   * bits 25 - 29 encode the operation
   * bits 30 - 31 are 11
   */

  src2 = (op_code      ) & 0xff;
  dst2 = (op_code >>  8) & 0xff;
  src3 = (op_code >> 16) & 0x07;
  src1 = (op_code >> 19) & 0x07;
  dst1 = (op_code >> 22) & 0x07;
  
  asmf( "%s\t", first_op );
  
  decode_indirect_address( src2 >> 3, src2 & 7, 1 );
  
  asmf( ", %s, %s  || %s\t%s, ",
	  _regname( src1 ), _regname( dst1 ), second_op, _regname( src3 ) );
      
  decode_indirect_address( dst2 >> 3, dst2 & 7, 1 );
      
  return;
      
} /* decode_triadic_parallel_addressing */

/*}}}*/
/*{{{  decode_diadic_parallel_addressing() */

  
static void
decode_diadic_parallel_addressing(
				  int32		op_code,
				  char *	first_op,
				  char *	second_op )
{
  unsigned long	src2;
  unsigned long	src3;
  unsigned long	dst1;
  unsigned long	dst2;

  
  /*
   * we have a diaidic parallel op code of the form:
   *
   *    first_op  src2, dst1
   * || second_op src3, dst2
   *
   *
   * bits  0 -  7 encode src2
   * bits  8 - 15 encode dst2
   * bits 16 - 18 encode src3
   * bits 19 - 21 are 000
   * bits 22 - 24 encode dst1
   * bits 25 - 29 encode the operation
   * bits 30 - 31 are 11
   */

  src2 = (op_code      ) & 0xff;
  dst2 = (op_code >>  8) & 0xff;
  src3 = (op_code >> 16) & 0x07;
  dst1 = (op_code >> 22) & 0x07;
  
  /* validity test */
  
  if (((op_code >> 19) & 0x07) != 0)
    {
      syserr( syserr_bad_parallel_addressing, op_code );
    }
      
  asmf( "%s\t", first_op );
      
  decode_indirect_address( src2 >> 3, src2 & 7, 1 );
      
  asmf( ", %s  || %s\t%s, ", _regname( dst1 ), second_op, _regname( src3 ) );
      
  decode_indirect_address( dst2 >> 3, dst2 & 7, 1 );
  
  return;
      
} /* decode_triadic_parallel_addressing */

/*}}}*/
/*{{{  decode_parallel_op() */

  
static void
decode_parallel_op( int32 op_code ) /* instruction */
{
  unsigned long	field1;
  unsigned long	field2;
  unsigned long	field3;
  unsigned long	field4;
  unsigned long	field5;

  
  /*
   * we have a parallel op code
   *
   * bits  0 -  7 encode field1
   * bits  8 - 15 encode field2
   * bits 16 - 18 encode field3
   * bits 19 - 21 encode field4
   * bits 22 - 24 encode field5
   * bits 25 - 29 encode the operation
   * bits 30 - 31 are 11
   */

  field1 = (op_code      ) & 0xff;
  field2 = (op_code >>  8) & 0xff;
  field3 = (op_code >> 16) & 0x07;
  field4 = (op_code >> 19) & 0x07;
  field5 = (op_code >> 22) & 0x07;
  
  switch ((op_code >> 25) & 0x1f)
    {
    case OP_STF_STF:
      /* validity tests */

      if (field4 != 0)
	{
	  syserr( syserr_bad_parallel_addressing, op_code );
	}
      
      asmf( "STF\t%s, ", _regname( field5 ) );
      
      decode_indirect_address( field1 >> 3, field1 & 7, 1 );
      
      asmf( "  || STF\t%s, ", _regname( field3 ) );
      
      decode_indirect_address( field2 >> 3, field2 & 7, 1 );
      
      break;
      
    case OP_STI_STI:
      /* validity tests */

      if (field4 != 0)
	{
	  syserr( syserr_bad_parallel_addressing, op_code );
	}
      
      asmf( "STI\t%s, ", _regname( field5 ) );
      
      decode_indirect_address( field1 >> 3, field1 & 7, 1 );
      
      asmf( "  || STI\t%s, ", _regname( field3 ) );
      
      decode_indirect_address( field2 >> 3, field2 & 7, 1 );
      
      break;
      
    case OP_LDF_LDF:
      /* validity tests */

      if (field3 != 0)
	{
	  syserr( syserr_bad_parallel_addressing, op_code );
	}
      
      asmf( "LDF\t" );
      
      decode_indirect_address( field1 >> 3, field1 & 7, 1 );
      
      asmf( ", %s  || LDF\t", _regname( field5 ) );
      
      decode_indirect_address( field2 >> 3, field2 & 7, 1 );

      asmf( ", %s", _regname( field4 ) );
      
      break;
      
    case OP_LDI_LDI:
      /* validity tests */

      if (field3 != 0)
	{
	  syserr( syserr_bad_parallel_addressing, op_code );
	}
      
      asmf( "LDI\t" );
      
      decode_indirect_address( field1 >> 3, field1 & 7, 1 );
      
      asmf( ", %s  || LDI\t", _regname( field5 ) );
      
      decode_indirect_address( field2 >> 3, field2 & 7, 1 );

      asmf( ", %s", _regname( field4 ) );
      
      break;
      
    case OP_ABSF_STF:	decode_diadic_parallel_addressing(  op_code, "ABSF",   "STF" ); break;
    case OP_ABSI_STI:	decode_diadic_parallel_addressing(  op_code, "ABSI",   "STI" ); break;
    case OP_ADDF3_STF:	decode_triadic_parallel_addressing( op_code, "ADDF3",  "STF" ); break;
    case OP_ADDI3_STI:	decode_triadic_parallel_addressing( op_code, "ADDI3",  "STI" ); break;
    case OP_AND3_STI:	decode_triadic_parallel_addressing( op_code, "AND3",   "STI" ); break;
    case OP_ASH3_STI:	decode_triadic_parallel_addressing( op_code, "ASH3",   "STI" ); break;
    case OP_FIX_STI:	decode_diadic_parallel_addressing(  op_code, "FIX",    "STI" ); break;
    case OP_FLOAT_STF:	decode_diadic_parallel_addressing(  op_code, "FLOAT",  "STF" ); break;
    case OP_LDF_STF:	decode_diadic_parallel_addressing(  op_code, "LDF",    "STF" ); break;
    case OP_LDI_STI:	decode_diadic_parallel_addressing(  op_code, "LDI",    "STI" ); break;
    case OP_LSH3_STI:	decode_triadic_parallel_addressing( op_code, "LSH3",   "STI" ); break;
    case OP_MPYF3_STF:	decode_triadic_parallel_addressing( op_code, "MPYF3",  "STF" ); break;
    case OP_MPYI3_STI:	decode_triadic_parallel_addressing( op_code, "MPYI3",  "STI" ); break;
    case OP_NEGF_STF:	decode_diadic_parallel_addressing(  op_code, "NEGF",   "STF" ); break;
    case OP_NEGI_STI:	decode_diadic_parallel_addressing(  op_code, "NEGI",   "STI" ); break;
    case OP_NOT_STI:	decode_diadic_parallel_addressing(  op_code, "NOT",    "STI" ); break;
    case OP_OR3_STI:	decode_triadic_parallel_addressing( op_code, "OR3",    "STI" ); break;
    case OP_SUBF3_STF:	decode_triadic_parallel_addressing( op_code, "SUBF3",  "STF" ); break;
    case OP_SUBI3_STI:	decode_triadic_parallel_addressing( op_code, "SUBI3",  "STI" ); break;
    case OP_XOR3_STI:	decode_triadic_parallel_addressing( op_code, "XOR3",   "STI" ); break;
    case OP_TOIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "TOIEEE", "STF" ); break;
    case OP_FRIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "FRIEEE", "STF" ); break;
    default:
      syserr( syserr_unknown_parallel_op, op_code );
      break;
    }

  return;

} /* decode_parallel_op */

/*}}}*/
/*{{{  decode_triadic_address() */

/*
 * decodes a 'C40 triadic op code
 */

static void
decode_triadic_address(
		       int32		op_code,	/* the triadic instruction        */
		       char *		instruction,	/* string identifying the op code */
		       immed_type	type )		/* type of immediate values       */
{
  char *	pdest;
  int32		dest;
  unsigned long	addr;
  unsigned long	src1;
  unsigned long	src2;
  

  /*
   * we have a triadic op code
   *
   * bits  0 -  7 encode source2
   * bits  8 - 15 encode source1
   * bits 16 - 20 encode destination register
   * bits 21 - 22 encode addessing mode
   * bits 23 - 27 encode op code
   * bit  28      encodes addressing type
   * bits 29 - 31 are 001
   */

  dest = (op_code >> 16) & 0x1f;

  if (type == TYPE_FLOATING)
    {
      /* the destination (or source) register of a floating point op must be R0 - R11 */

      if (!is_extended_precision_register( dest ))
	{
	  syserr( syserr_non_float_dest );
	}
    }

  pdest = _regname( dest );
  
  /* build combined addressing type */

  addr = (op_code >> 28) & 0x1;

  addr <<= 2;

  addr |= ((op_code >> 21) & 0x3);

  /* extract source fields */
  
  src2 = op_code & 0xff;
  src1 = (op_code >> 8) & 0xff;

  /* and print out result */

  asmf( "%s\t", instruction );
  
  switch (addr)
    {
    case B_000:	/* src1 = register, src2 = register */

      asmf( "%s, %s, %s",
	      _regname( src2 & 0x3f ),
	      _regname( src1 & 0x3f ),
	      pdest );
	      
      break;

    case B_001: /* src1 = indirect, src2 = register */

      asmf( "%s, ", _regname( src2 & 0x3f ) );
      
      decode_indirect_address( src1 >> 3, src1 & 7, 1 );
      
      asmf( ", %s", pdest );
     
      break;
      
    case B_010:	/* src1 = register, src2 = indirect */

      decode_indirect_address( src2 >> 3, src2 & 7, 1 );
      
      asmf( ", %s", _regname( src1 & 0x3f ) );

      asmf( ", %s", pdest );
      
      break;

    case B_011:	/* src1 = indirect, src2 = indirect */

      decode_indirect_address( src2 >> 3, src2 & 7, 1 );

      asmf( ", " );

      decode_indirect_address( src1 >> 3, src1 & 7, 1 );

      asmf( ", %s", pdest );
      
      break;

    case B_100: /* src1 = register, src2 = immediate */

      if (type == TYPE_FLOATING)
	syserr( syserr_no_triadic_FP_imm );
      else if (type == TYPE_SIGNED)
	op_code = mask_and_sign_extend_word( op_code, 0xff );
      else
	op_code &= 0xff;
     
      if (sym_reladdr != NULL)
	{
	  asmf( ".%s, %s, %s",
		  symname_( sym_reladdr ),
		  _regname( src1 & 0x3f ),
		  pdest );

	  sym_reladdr = NULL;
	}
      else if (type == TYPE_UNSIGNED)
	{
	  asmf( "%#-3lx, %s, %s",
		  op_code,
		  _regname( src1 & 0x3f ),
		  pdest );
	}
      else
	{
	  asmf( "%-3ld, %s, %s",
		  op_code,
		  _regname( src1 & 0x3f ),
		  pdest );
	}
      
      break;
      
    case B_101:	/* src1 = register, src2 = indirect */

      asmf( "*+AR%.1ld(%.2lu), %s, %s",
	      src2 & 0x7, (src2 >> 3),
	      _regname( src1 & 0x3f ),
	      pdest );
      
      break;
      
    case B_110:	/* src1 = indirect, src2 = immediate */

      if (type == TYPE_FLOATING)
	{
	  syserr( syserr_no_triadic_FP_imm );
	}
      else if (type == TYPE_SIGNED)
	{
	  asmf( "%-3ld, *+AR%.1ld(%.2lu), %s",
		  mask_and_sign_extend_word( op_code, 0xff ),
		  src1 & 0x7, (src1 >> 3),
		  pdest );      
	}
      else
	{
	  asmf( "%#-3lx, *+AR%.1ld(%.2lu), %s",
		  op_code & 0xff,
		  src1 & 0x7, (src1 >> 3),
		  pdest );
	}
     
      break;
      
    case B_111:	/* src1 = indirect, src2 = indirect */
      
      asmf( "*+AR%.1ld(%.2lu), *+AR%.1ld(%.2lu), %s",
	      src2 & 0x7, (src2 >> 3),
	      src1 & 0x7, (src1 >> 3),
	      pdest );
      break;
      
    default:
      syserr( syserr_unknown_triadic_address, op_code );
      break;
    }

  return;
  
} /* decode_triadic_address */

/*}}}*/
/*{{{  decode_monadic_op() */

static void
decode_monadic_op(
		  int32		op_code,
		  char *	instruction )
{
  asmf( "%s\t%s", instruction, _regname( (op_code >> 16) & 0x1f ) );

  return;
  
} /* decode_mondadic_op */

/*}}}*/
/*{{{  decode_sequential_op() */

  
static void
decode_sequential_op( int32 op_code ) /* instruction */
{
  /*
   * bit  29      encodes diadic or triadic style op codes
   * bits 30 - 31 are 00
   */
  
  if (op_code & 0x20000000L)
    {
      /*
       * triadic op code
       *
       * bits 23 - 27 encode op code
       * bit  28      encodes addressing type
       * bits 29 - 31 are 001
       */

      switch ((op_code >> 23) & 0x1f)
	{
	case OP_ADDC3:	decode_triadic_address( op_code, "ADDC3"   , TYPE_SIGNED   ); return;
	case OP_ADDF3:	decode_triadic_address( op_code, "ADDF3"   , TYPE_FLOATING ); return;
	case OP_ADDI3:	decode_triadic_address( op_code, "ADDI3"   , TYPE_SIGNED   ); return;
	case OP_ASH3:	decode_triadic_address( op_code, "ASH3"    , TYPE_SIGNED   ); return;
	case OP_CMPF3:	decode_triadic_address( op_code, "CMPF3"   , TYPE_FLOATING ); return;
	case OP_CMPI3:	decode_triadic_address( op_code, "CMPI3"   , TYPE_SIGNED   ); return;
	case OP_LSH3:	decode_triadic_address( op_code, "LSH3"    , TYPE_SIGNED   ); return;
	case OP_MPYF3:	decode_triadic_address( op_code, "MPYF3"   , TYPE_FLOATING ); return;
	case OP_MPYI3:	decode_triadic_address( op_code, "MPYI3"   , TYPE_SIGNED   ); return;
	case OP_SUBB3:	decode_triadic_address( op_code, "SUBB3"   , TYPE_SIGNED   ); return;
	case OP_SUBF3:	decode_triadic_address( op_code, "SUBF3"   , TYPE_FLOATING ); return;
	case OP_SUBI3:	decode_triadic_address( op_code, "SUBI3"   , TYPE_SIGNED   ); return;
	case OP_MPYSHI3:decode_triadic_address( op_code, "MPYSHI3" , TYPE_SIGNED   ); return;
#ifdef TRIADIC_BINARY_OPS_ARE_UNSIGNED
	case OP_AND3:	decode_triadic_address( op_code, "AND3"    , TYPE_UNSIGNED ); return;
	case OP_ANDN3:	decode_triadic_address( op_code, "ANDN3"   , TYPE_UNSIGNED ); return;
	case OP_OR3:	decode_triadic_address( op_code, "OR3"     , TYPE_UNSIGNED ); return;
	case OP_TSTB3:	decode_triadic_address( op_code, "TSTB3"   , TYPE_UNSIGNED ); return;
	case OP_XOR3:	decode_triadic_address( op_code, "XOR3"    , TYPE_UNSIGNED ); return;
	case OP_MPYUHI3:decode_triadic_address( op_code, "MPYUHI3" , TYPE_UNSIGNED ); return;
#else
	case OP_AND3:	decode_triadic_address( op_code, "AND3"    , TYPE_SIGNED   ); return;
	case OP_ANDN3:	decode_triadic_address( op_code, "ANDN3"   , TYPE_SIGNED   ); return;
	case OP_OR3:	decode_triadic_address( op_code, "OR3"     , TYPE_SIGNED   ); return;
	case OP_TSTB3:	decode_triadic_address( op_code, "TSTB3"   , TYPE_SIGNED   ); return;
	case OP_XOR3:	decode_triadic_address( op_code, "XOR3"    , TYPE_SIGNED   ); return;
	case OP_MPYUHI3:decode_triadic_address( op_code, "MPYUHI3" , TYPE_SIGNED   ); return;
#endif
	default:
	  syserr( syserr_unknown_triadic_op, (op_code >> 23) & 0x1f );
	}
    }
  else
    {
      /*
       * diaidic op code
       *
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

      switch (op_code >> 23)
	{
	case OP_ABSF:	decode_diadic_address( op_code, "ABSF"   , TYPE_FLOATING, FALSE ); return;
	case OP_ABSI:	decode_diadic_address( op_code, "ABSI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_ADDC:	decode_diadic_address( op_code, "ADDC"   , TYPE_SIGNED,   FALSE ); return;
	case OP_ADDF:	decode_diadic_address( op_code, "ADDF"   , TYPE_FLOATING, FALSE ); return;
	case OP_ADDI:	decode_diadic_address( op_code, "ADDI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_AND:	decode_diadic_address( op_code, "AND"    , TYPE_UNSIGNED, FALSE ); return;
	case OP_ANDN:	decode_diadic_address( op_code, "ANDN"   , TYPE_UNSIGNED, FALSE ); return;
	case OP_ASH:	decode_diadic_address( op_code, "ASH"    , TYPE_SIGNED,   FALSE ); return;
	case OP_CMPF:	decode_diadic_address( op_code, "CMPF"   , TYPE_FLOATING, FALSE ); return;
	case OP_CMPI:	decode_diadic_address( op_code, "CMPI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_FIX:	decode_diadic_address( op_code, "FIX"    , TYPE_FLOATING, FALSE ); return;
	case OP_FLOAT:	decode_diadic_address( op_code, "FLOAT"  , TYPE_SIGNED,   FALSE ); return;
	case OP_IDLE:	asmf( "IDLE" ); return;
	case OP_LDE:	decode_diadic_address( op_code, "LDE"    , TYPE_FLOATING, FALSE ); return;
	case OP_LDF:	decode_diadic_address( op_code, "LDF"    , TYPE_FLOATING, FALSE ); return;
	case OP_LDFI:	decode_diadic_address( op_code, "LDFI"   , TYPE_FLOATING, FALSE ); return;
	case OP_LDI:	decode_diadic_address( op_code, "LDI"    , TYPE_SIGNED,   FALSE ); return;
	case OP_LDII:	decode_diadic_address( op_code, "LDII"   , TYPE_SIGNED,   FALSE ); return;
	case OP_LDM:	decode_diadic_address( op_code, "LDM"    , TYPE_FLOATING, FALSE ); return;
	case OP_LSH:	decode_diadic_address( op_code, "LSH"    , TYPE_SIGNED,   FALSE ); return;
	case OP_MPYF:	decode_diadic_address( op_code, "MPYF"   , TYPE_FLOATING, FALSE ); return;
	case OP_MPYI:	decode_diadic_address( op_code, "MPYI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_NEGB:	decode_diadic_address( op_code, "NEGB"   , TYPE_SIGNED,   FALSE ); return;
	case OP_NEGF:	decode_diadic_address( op_code, "NEGF"   , TYPE_FLOATING, FALSE ); return;
	case OP_NEGI:	decode_diadic_address( op_code, "NEGI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_NOP:	asmf( "NOP" ); return;	/* XXX - not quite true can use indirect addressing to adjust address registers */
	case OP_NORM:	decode_diadic_address( op_code, "NORM"   , TYPE_FLOATING, FALSE ); return;
	case OP_NOT:	decode_diadic_address( op_code, "NOT"    , TYPE_UNSIGNED, FALSE ); return;
	case OP_POP:	decode_monadic_op(     op_code, "POP"    ); return;
	case OP_POPF:	decode_monadic_op(     op_code, "POPF"   ); return;
	case OP_PUSH:	decode_monadic_op(     op_code, "PUSH"   ); return;
	case OP_PUSHF:	decode_monadic_op(     op_code, "PUSHF"  ); return;
	case OP_OR:	decode_diadic_address( op_code, "OR"     , TYPE_UNSIGNED, FALSE ); return;
	case OP_RND:	decode_diadic_address( op_code, "RND"    , TYPE_FLOATING, FALSE ); return;
	case OP_ROL:	decode_monadic_op(     op_code, "ROL"    ); return;
	case OP_ROLC:	decode_monadic_op(     op_code, "ROLC"   ); return;
	case OP_ROR:	decode_monadic_op(     op_code, "ROR"    ); return;
	case OP_RORC:	decode_monadic_op(     op_code, "RORC"   ); return;
	case OP_RPTS:	decode_diadic_address( op_code, "RPTS"   , TYPE_UNSIGNED, FALSE ); return;
	case OP_STF:	decode_diadic_address( op_code, "STF"    , TYPE_FLOATING, TRUE  ); return;
	case OP_STFI:	decode_diadic_address( op_code, "STFI"   , TYPE_FLOATING, TRUE  ); return;
	case OP_STI:	decode_integer_store(  op_code           ); return;
	case OP_SIGI:	decode_diadic_address( op_code, "SIGI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_STII:	decode_diadic_address( op_code, "STII"   , TYPE_SIGNED,   TRUE  ); return;
	case OP_SUBB:	decode_diadic_address( op_code, "SUBB"   , TYPE_SIGNED,   FALSE ); return;
	case OP_SUBC:	decode_diadic_address( op_code, "SUBC"   , TYPE_SIGNED,   FALSE ); return;
	case OP_SUBF:	decode_diadic_address( op_code, "SUBF"   , TYPE_FLOATING, FALSE ); return;
	case OP_SUBI:	decode_diadic_address( op_code, "SUBI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_SUBRB:	decode_diadic_address( op_code, "SUBRB"  , TYPE_SIGNED,   FALSE ); return;
	case OP_SUBRF:	decode_diadic_address( op_code, "SUBRF"  , TYPE_FLOATING, FALSE ); return;
	case OP_SUBRI:	decode_diadic_address( op_code, "SUBRI"  , TYPE_SIGNED,   FALSE ); return;
	case OP_TSTB:	decode_diadic_address( op_code, "TSTB"   , TYPE_UNSIGNED, FALSE ); return;
	case OP_XOR:	decode_diadic_address( op_code, "XOR"    , TYPE_UNSIGNED, FALSE ); return;
	case OP_IACK:	decode_diadic_address( op_code, "IACK"   , TYPE_UNSIGNED, FALSE ); return;
	case OP_TOIEEE:	decode_diadic_address( op_code, "TOIEEE" , TYPE_FLOATING, FALSE ); return;
	case OP_FRIEEE:	decode_diadic_address( op_code, "FRIEEE" , TYPE_FLOATING, FALSE ); return;
	case OP_RSQRF:	decode_diadic_address( op_code, "RSQRF"  , TYPE_FLOATING, FALSE ); return;
	case OP_RCPF:	decode_diadic_address( op_code, "RCPF"   , TYPE_FLOATING, FALSE ); return;
	case OP_MPYSHI:	decode_diadic_address( op_code, "MPYSHI" , TYPE_SIGNED,   FALSE ); return;
	case OP_MPYUHI:	decode_diadic_address( op_code, "MPYUHI" , TYPE_UNSIGNED, FALSE ); return;
	case OP_LDA:	decode_diadic_address( op_code, "LDA"    , TYPE_SIGNED,   FALSE ); return;
	case OP_LDPK:	decode_diadic_address( op_code, "LDPK"   , TYPE_SIGNED,   FALSE ); return;
	case OP_LDHI:	decode_diadic_address( op_code, "LDHI"   , TYPE_UNSIGNED, FALSE ); return;
	default:
	  syserr( syserr_unknown_diadic_op, op_code >> 23 );
	}
    }
  
  return;
  
} /* decode_sequential_op */

/*}}}*/
/*{{{  decode_instruction() */

void
decode_instruction(
		   int32	op_code,	/* instruction 				*/
		   bool		flag_errs )	/* TRUE if errors should be reported	*/
{
  /*
   * bits 30 and 31 encode instruction type
   */
  
  switch ((op_code >> 30) & 0x3)
    {
    default:
    case 0: decode_sequential_op( op_code );            return;
    case 1: decode_flow_control(  op_code, flag_errs ); return;
    case 2: decode_non_word_load_or_triadic( op_code ); return;
    case 3: decode_parallel_op(   op_code );            return;
    }

} /* decode_instruction */

/*}}}*/
/*{{{  decode_DC() */

static void
decode_DC( int32 op_code )
{
  asmf( "word\t0x%.8lx", (long)op_code );

  return;

} /* decode_DC */

/*}}}*/
/*{{{  decode_DCAx() */

static void
decode_DCAx( int32 offset )
{
  asmf( "word \t" );
  
  decode_addr( offset );

  return;
  
} /* decode_DCAx */

/*}}}*/

#ifdef NOT_USED
/*{{{  decode_DCA() */

static void
decode_DCA(
	   Symstr *	s,
	   int32 	op_code )
{
  asmf( "word\t_ " );
  
  /* decode_addr( op_code, 0 ); */
  
  pr_asmname( s );
  
  if (op_code != 0)
    asmf( " %+ld", (long)op_code );

  return;
  
} /* decode_DCA */

/*}}}*/
/*{{{  maybe_export() */

static void
maybe_export( Symstr * sym )
{
  char *	p = symname_( sym );
  char  	c;
  ExtRef *	x;


  /* Unless external there is nothing to do here. */

  if ((x = symext_( sym )) != 0 && !is_global( x ))
    return;

  /*@@@@@@ AM does not see how the following can ever now happen as _dataseg etc. */
  /*@@@@@@ are very local statics.  Is this if error recovery inserted gensyms?   */
  
  while ((c = *p++) != 0)
    {
      /* look for odd characters in _dataseg etc */
      
      if (!(isalnum( c ) || (c == '_')))
	return;
    }

#if 0
  asmf( "\t.export\t_" );
     
  pr_asmname( sym );
     
  fputs( "\n", asmstream );
#endif

  return;
  
} /* maybe_export */

/*}}}*/
#endif /* NOT_USED */
/*{{{  display_assembly_code() */

/* exported functions ...*/

void
display_assembly_code( Symstr *	name )
{
  LabList *	asm_lablist2 = NULL;


  asm_blank( 2 );

  asm_lablist2 = asm_lablist;

  fncount++;

  if (name != NULL)   /* may be NULL for string literals from static inits   */
    {
      asmf( "%c        align 128\n", ASM_COMMENT_CHAR );
  
      if (annotations)
	asmf( "%.6lx  %20s", (long)codebase, "" );

      fputc( '.', asmstream );
      
      pr_asmname( name );
      
      asmf( ":\n" );
    }

  for (current_pos = 0; current_pos < codep; current_pos += sizeof_int)    /* q is now a BYTE offset */
    {
      const int32	op_code    = code_inst_( current_pos );
      const int32	f          = code_flag_( current_pos );
      VoidStar 		aux 	   = code_aux_(  current_pos );
#ifdef TARGET_IS_C40
      int32		pending_fpnum;
#endif
      
      
	{
	  int32 	labq;
	  LabelNumber *	t;

	  
	  while (asm_lablist2 &&
		 (t    = asm_lablist2->labcar,
		  labq = t->u.defn & 0x00ffffff) <= current_pos)
	    {
	      if (annotations)
		asmf( "%28s", "" );

	      asmf( "L%ldF%ld:\n", (long)(lab_name_( t ) & 0x7fffffff), (long)fncount );

	      /* asmf( "\t%c offset = %+ld\n", ASM_COMMENT_CHAR, labq ); */

	      if (labq != current_pos)
		syserr( syserr_asmlab, (long)labq );
      
	      asm_lablist2 = asm_lablist2->labcdr;
	    }
	}

      patch_pend = FALSE;
      
      if (codexrefs)
	{
	  CodeXref *	x;
	  int32		pos = 0;
	  

	  for (x = codexrefs;
	       x && (pos = (x->codexroff & 0x00ffffffU), pos > codebase + current_pos);
	       x = x->codexrcdr )
	    ;

	  if (pos == codebase + current_pos)
	    {
	      int32	xrtype = x->codexroff & 0xff000000U;


	      patch_pend = TRUE;
	      
	      switch (xrtype)
		{
		case X_PCreloc:
		  asmf( "patchinstr( PATCHC40MASK24ADD, shift( -2, %s ( .%s ) ),\n",
		       new_stubs ? "CODESTUB" : "LABELREF",
		       symname_( (Symstr *)(int)aux ) );
		  break;
		  
		case X_PCreloc2:
		  asmf( "patchinstr( PATCHC40MASK16ADD, shift( -2, %s ( .%s ) ),\n",
		       new_stubs ? "CODESTUB" : "LABELREF",
		       symname_( (Symstr *)(int)aux ) );
		  break;
		  
		case X_DataModule1:
		  asmf( "patchinstr( PATCHC40DATAMODULE1, shift( -2, DATAMODULE ( _%s ) ),\n",
			  symname_( (Symstr *)(int)aux ) );
		  break;
		  
		case X_DataModule2:
		  asmf( "patchinstr( PATCHC40DATAMODULE2, shift ( -2, CODESYMB ( _%s ) ),\n",
			  symname_( (Symstr *)(int)aux ) );
		  break;
		  
		case X_DataModule3:
		  asmf( "patchinstr( PATCHC40DATAMODULE3, MODNUM,\n" );
		  break;
		  
		case X_DataModule4:
		  asmf( "patchinstr( PATCHC40DATAMODULE4, MODNUM,\n" );
		  break;
		  
		case X_DataModule5:
		  asmf( "patchinstr( PATCHC40DATAMODULE5, MODNUM,\n" );
		  break;
		  
		case X_DataSymbHi:
		  asmf( "patchinstr( PATCHC40MASK16ADD, " );
		  
		  if (split_module_table && is_function( (Symstr *)(int)aux ))
		    {
		      asmf( "shift ( -18, CODESYMB ( _%s ) ),\n",
			      symname_( (Symstr *)(int)aux ) );
		    }
		  else
		    {
		      asmf( "shift ( -16, DATASYMB ( _%s ) ),\n",
			      symname_( (Symstr *)(int)aux ) );
		    }
		  break;
		  
		case X_DataSymbLo:
		  asmf( "patchinstr( PATCHC40MASK16ADD, " );
		  
		  if (split_module_table && is_function( (Symstr *)(int)aux ))
		    {		      
		      asmf( "shift ( -16, shift ( 14, CODESYMB ( _%s ) ) ),\n",
			      symname_( (Symstr *)(int)aux ) );
		    }
		  else
		    {
		      asmf( "shift ( -16, shift ( 16, DATASYMB ( _%s ) ) ),\n",
			      symname_( (Symstr *)(int)aux ) );
		    }
		  break;
		  
		case X_DataAddr1:
		  asmf( "patchinstr( PATCHC40MASK16ADD, shift ( -18, p_add ( -12, " );

		  if (is_function( (Symstr *)(int)aux ))
		    {
		      if (new_stubs)
			{
			  asmf( "CODESTUB ( .%s ) ) ),\n", symname_( (Symstr *)(int)aux ) );
			}
		      else
			{
			  asmf( "LABELREF ( .%s ) ) ),\n", symname_( (Symstr *)(int)aux ) );
			}		      
		    }
		  else
		    {
		      asmf( "LABELREF ( _%s ) ) ),\n", symname_( (Symstr *)(int)aux ) );
		    }
		  
		  break;
		  
		case X_DataAddr:
		  asmf( "patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 14, " );

		  if (is_function( (Symstr *)(int)aux ))
		    {
		      if (new_stubs)
			{
			  asmf( "CODESTUB ( .%s ) ) ),\n", symname_( (Symstr *)(int)aux ) );
			}
		      else
			{
			  asmf( "LABELREF ( .%s ) ) ),\n", symname_( (Symstr *)(int)aux ) );
			}		      
		    }
		  else
		    {
		      asmf( "LABELREF ( _%s ) ) ),\n", symname_( (Symstr *)(int)aux ) );
		    }
		  
		  break;
		    
		case X_FuncAddr:
		  asmf( "patchinstr( PATCHC40MASK24ADD, shift( -2, " );

		  asmf( "ADDRSTUB ( .addr.%s ) ),\n", symname_( (Symstr *)(int)aux ) );
		  
		  break;
		  
		case X_DataModule:
		  asmf( "patchinstr( %s, shift ( -2, DATAMODULE ( _%s ) ),\n",
			  few_modules ? "PATCHC40MASK8ADD" : "PATCHC40MASK16ADD" ,
			  symname_( (Symstr *)(int)aux ) );

		  break;
		    
		case X_Modnum:
		  asmf( "patchinstr( %s, ",
		       few_modules ? "PATCHC40MASK8ADD" : "PATCHC40MASK16ADD" );
		  
		  if (split_module_table)
		    asmf( "shift ( 1, MODNUM ),\n" );
		  else
		    asmf( "MODNUM,\n" );
		    
		  break;

		case X_DataSymb:
		  asmf( "patchinstr( PATCHC40MASK16ADD, shift ( -2, %s ( _%s ) ),\n",
			  split_module_table ? "CODESYMB" : "DATASYMB",
			  symname_( (Symstr *)(int)aux ) );
		  break;

		case X_Debug_Modnum:
		  asmf( "patchinstr( MODNUM\n" );
		  break;
		  
		case X_Debug_Offset:
		  asmf( "patchinstr( %s ( _%s ) \n",
		       split_module_table ? "CODESYMB" : "DATASYMB",
		       symname_( (Symstr *)(int)aux ) );
		  break;
		  
		case X_Debug_Ref:
		  asmf( "patchinstr( LABELREF ( _%s ) \n",
			  symname_( (Symstr *)(int)aux ) );
		  break;
		  
		default:
		  asmf( "%c unknown cross reference type %lx\n", ASM_COMMENT_CHAR, xrtype );

		  /* drop through */
		  
		case X_absreloc:
		  patch_pend = FALSE;
		  break;	      
		}
	    }
	}

      if (annotations)
        {
	  int32	i;

	  
	  asmf( "%.6lx  ", (long)(current_pos + codebase) );
	  
	  switch (f)
            {
	    case LIT_OPCODE:
	      for (i = 0; i < (sizeof_int * 2); i += sizeof_int)
		if (i < sizeof_int)
		  asmf( "%.8lx ", (long)code_inst_( current_pos + i ) );
		else
		  asmf( "     " );
	      break;

	    case LIT_STRING:
	      asmf( "      %.8lx      ", (long)totargetsex( op_code, LIT_BBBB ) );
	      break;

	    default:
	      asmf( "      %.8lx      ", (long)op_code );
	      break;
            }
        }

      putc( ' ', asmstream );

      switch (f)
	{
	case LIT_OPCODE:
	  /* all instructions are four bytes on 'C40  */
	  /* so a lot of grotty code has been removed */
	  /* concerned with making branch table       */
	  /* entries always four bytes                */

	  sym_reladdr = NULL;
	  
	  decode_instruction( op_code, TRUE );
	  
	  break;

	case LIT_RELADDR:
	  if (patch_pend)
	    sym_reladdr = NULL;
	  else
	    sym_reladdr = (Symstr *)(int)aux;
	  
	  decode_instruction( op_code, TRUE );

	  if (!patch_pend && sym_reladdr && !exporting_routines)
	    {
	      asmf( ".%s", symname_( sym_reladdr ) );
	    }
	  
	  break;
	  
	case LIT_STRING:
	  decode_DC( totargetsex( op_code, LIT_BBBB ) );

	  if (annotations)
	    {
	      asmf( "         %c ", ASM_COMMENT_CHAR );
	      
	      pr_chars( op_code );
	    }

	  break;

	case LIT_NUMBER:
	  decode_DC( op_code );
	  break;

	case LIT_ADCON:
	  decode_DCAx( op_code );	/* ??? */
	  
	  break;

	case LIT_FPNUM:
#ifdef TARGET_IS_C40
	  decode_DC( IEEE_to_single_float( op_code ) );
#else  
	  decode_DC( op_code );
#endif
	  if (annotations)
	    asmf( " %c E'%s'", ASM_COMMENT_CHAR, aux );
	  
	  break;

	case LIT_FPNUM1:
#ifdef TARGET_IS_C40
	  pending_fpnum = op_code;
#else  
	  decode_DC( op_code );

	  if (annotations)
	    asmf( " %c D'%s'", ASM_COMMENT_CHAR, aux );
#endif
	  break;

	case LIT_FPNUM2:    /* all printed by the FPNUM1 */
#ifdef TARGET_IS_C40
	  decode_DC( IEEE_to_extended_float( pending_fpnum, op_code, NULL  ) );
	  
	  asmf( "\n " );
	  
	  IEEE_to_extended_float( pending_fpnum, op_code, &pending_fpnum );
	  
	  decode_DC( pending_fpnum );

	  if (annotations)
	    asmf( " %c D'%s'", ASM_COMMENT_CHAR, aux );
#else  
	  decode_DC( op_code );
#endif
	  break;

	default:
	  syserr( syserr_display_asm, (long)f );
	  
	  asmf( "?" );
        }

      if (patch_pend)
	asmf( " )\n" );
      else
	asmf( "\n" );
    }

  if (asm_lablist2)
    {
      syserr( syserr_asmlab, 0L );
    }  

/*  putc( ' ', asmstream ); */

  asm_lablist = NULL;    /* stop confusion when called from vargen.c  */

  return;

} /* display_assembly_code */

/*}}}*/
/*{{{  asm_header() */

void
asm_header( void )
{
#ifdef TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_ANY ))
    db_init( sourcefile );
#endif
  
  if (asmstream == NULL)
    {
      fprintf( stderr, "WARNING: no assembler output stream!\n" );

      asmstream = stderr;
    }

  asm_error = 0;
  fncount   = 0;

  asmf( "%c generated by %s\n", ASM_COMMENT_CHAR, CC_BANNER );

#if 0	/* assembler automatically inserts this code unless -d option is used */  
  if (!suppress_module)
    {
      asmf( "\talign\n" );
      asmf( "\tmodule  -1\n" );
      asmf( ".ModStart:\n" );      
      asmf( "\tword    %#lx\n", T_Module );
      asmf( "\tword    (.ModEnd - .ModStart) * 4\n" );
      asmf( "\tblkb    32,\"%.31s\"\n", sourcefile );
      asmf( "\tword    modnum\n" );
      asmf( "\tword    1\n" );
      asmf( "\tword    datasymb ( .MaxData )\n" );
      asmf( "\tinit\n" );
      asmf( "\tword    codesymb ( .MaxCodeP )\n" );      
    }
#endif
  
  return;
  
} /* asm_header */

/*}}}*/
/*{{{  asm_outextern() */

/* (not exported) */

static void
asm_outextern( void )
{
  ExtRef *	x;

  if (new_stubs)
    {
      for (x = obj_symlist; x != NULL; x = x->extcdr)
	{
	  if (!is_local( x ))
	    {
	      asmf( "export    ." );

	      pr_asmname( x->extsym );
	  
	      asmf( "\nref       _" );

	      pr_asmname( x->extsym );
	  
	      asmf( "\n" );
	    }
	}
    }
  else
    {
      bool		done_first = FALSE;
  

      for (x = obj_symlist; x != NULL; x = x->extcdr)
	{
	  if (!is_local( x ) && is_global( x ))
	    {
	      if (done_first)
		{
		  asmf( "\n" );
		}
	      else
		{
		  done_first = TRUE;
		}

	      asmf( "codetable _" );
	  
	      pr_asmname( x->extsym );
	  
	      asmf( "\nexport    _" );
	  
	      pr_asmname( x->extsym );
	  
	      asmf( "\n" );
	    }
	}
    }  
  
  asm_blank( 1 );

  return;
  
} /* asm_outextern */

/*}}}*/
/*{{{  asm_output_symbol() */

static void
asm_output_symbol(
		  Symstr *	symbol,
		  unsigned32	size )
{
  if (symbol != NULL)
    {
      asmf( "data   _%s, %ld\n", symname_( symbol ), size );
      
      if (is_global( symext_( symbol ) ))
	{
	  asmf( "export %s\n", symname_( symbol ) );
	}
    }

  return;
  
} /* asm_output_symbol */
  

/*}}}*/
/*{{{  ExtRefList Type*/

/* XXX - NC -> *sigh* do these LISP hackers get everywhere ? */

typedef struct ExtRefList
  {
    struct ExtRefList *	cdr;
    ExtRef *		car;
  }
ExtRefList;

/*}}}*/
/*{{{  asm_trailer() */

void
asm_trailer( void )
{
  DataInit *		p;
  unsigned32		dlen;
  ExtRef *		dsymb;
  ExtRef *		curdsymb;
  unsigned32		old_dlen;
  

#ifdef TARGET_HAS_DEBUGGER
  if (usrdbg( DBG_ANY ))
    db_tidy();
#endif
  
  asm_blank( 1 );

#if 0
  asm_padcol8( 0 );
#endif

  dsymb    = datasymbols;
  curdsymb = NULL;
  dlen     = 0;
  old_dlen = 0;
  
  for (p = datainitp; p != NULL; p = p->datacdr)
    {
      int32	sort = p->sort;
      int32	len  = p->len;
      int32	val  = p->val;
      
      
      if (dsymb != NULL)
	{
	  int32	dataoff = dsymb->extoffset;
		  

	  /* have we reached the location of the next symbol to be exported  ? */
	  
	  if (dlen == dataoff)
	    {
	      /* do we have a previous symbol to export ? */
	      
	      if (curdsymb != NULL)
		{
		  asm_output_symbol( curdsymb->extsym, dlen - old_dlen );
		}

	      /* export all but the last symbol with this offset */
	      
	      for (; dsymb->extcdr && dsymb->extcdr->extoffset == dataoff; dsymb = dsymb->extcdr )
		{
		  asm_output_symbol( dsymb->extsym, 0 );
		}

	      /* remember the last symbol at this offset, and the size of the data segment at this point */
	      
	      old_dlen = dlen;
	      curdsymb = dsymb;

	      /* point to the next symbol in the list */
	      
	      dsymb = dsymb->extcdr;
	    }
	  else if (dataoff < dlen)
	    {
	      /* oh dear - we have mislaid a symbol */
	      
	      syserr( syserr_mislaid_a_symbol );
	    }
	}
#if 0
      if (sort != LIT_LABEL)
	asm_padcol8( 0 );
#endif
      
      switch (sort)
	{
	case LIT_LABEL:
	  break;
	  
	default:
	  syserr( syserr_asm_trailer, (long)sort );
	  
	case LIT_BBBB:
	case LIT_HH:
	case LIT_BBH:
	case LIT_HBB:
	case LIT_NUMBER:
	  if (len != 4)
	    syserr( syserr_datalen, (long)len );
	  
	  dlen += len * (p->rpt);
	  
	  break;
	  
	case LIT_FPNUM:
	    {
	      FloatCon *	fc = (FloatCon *)val;
	      
	      
#ifndef TARGET_IS_C40
	      decode_DC( fc->floatbin.irep[ 0 ] );
#endif
	      if (annotations) 
		asmf( " %c %s", ASM_COMMENT_CHAR, fc->floatstr );
	      
#ifndef TARGET_IS_C40
	      if (len == 8)
		{
		  asmf( "\n" );
		  
		  asm_padcol8( 0 );
		  
		  decode_DC( fc->floatbin.db.lsd );
		}
#endif	      
	      dlen += len;
	      
	      break;
	    }
	  
	case LIT_ADCON:              /* (possibly external) name + offset */
	  if (p->rpt != 1)
	    syserr( syserr_asm_trailer2 );
#if 0
	  decode_DCA( (Symstr *)len, val );
#endif
	  dlen += sizeof_ptr;
	  
	  break;
	}
#if 0
      asmf( "\n" );
#endif
    }

  if (curdsymb)
    {
      asm_output_symbol( curdsymb->extsym, dlen - old_dlen );
    }
  
#ifdef TARGET_HAS_BSS
  if (bss_size != 0)
    {
      int32 		n      = 0;
      ExtRef *		x      = obj_symlist;
      ExtRefList *	zisyms = NULL;

      
      asmf( "%c%c%c Start of BSS\n", ASM_COMMENT_CHAR, ASM_COMMENT_CHAR, ASM_COMMENT_CHAR );
      
      for (; x != NULL; x = x->extcdr)
	{
	  if (is_bss( x ))
	    {
	      ExtRefList **	prev = &zisyms;
	      ExtRefList *	p;

	    
	      for (; (p = *prev) != 0; prev = &cdr_( p ))
		if (x->extoffset < car_( p )->extoffset)
		  break;
	    
	      *prev = syn_cons2( *prev, x );
	    }
	}

      for (; zisyms != NULL; zisyms = cdr_( zisyms ))
	{
	  x = car_( zisyms );
	  
	  if (x->extoffset != n)
	    asmf( ",%ld,%cbss%c\n", x->extoffset-n, '"', '"' );
	  
	  n = x->extoffset;
	  
	  maybe_export( x->extsym );
	  
	  asmf( "\t.common\t_" );
	  
	  pr_asmname( x->extsym );
	}
      
      if (n != bss_size)
	asmf( ",%ld, %cbss%c\n", bss_size - n, '"', '"' );
    }
#endif /* TARGET_HAS_BSS */

  asm_blank( 1 );
  
  asm_outextern();

  asm_blank( 1 );

#if 0	     /* generated automatically by assembler */
  if (!suppress_module)
    {
      asmf( "\tdata      .MaxData, 0\n" );
      asmf( "\tcodetable .MaxCodeP\n%c\n", ASM_COMMENT_CHAR );
      asmf( ".ModEnd:\n" );
    }
#endif
  
  asmf( "%c END\n", ASM_COMMENT_CHAR );

  if (asm_error)
    syserr( syserr_asm_confused );

  return;
  
} /* asm_trailer */

/*}}}*/

/*}}}*/
/* end of asm.c */
@


1.93
log
@fixed syserr usage
@
text
@d1 2
d4 1
a4 1
/* c40/asm.c: Copyright (C) Perihelion Software Ltd., 1991, 1992.      */
d14 3
d45 3
d56 12
a72 4
#define toevensex( x, y )	(x)    /* for cross compilation one day */

#define	ASM_COMMENT_CHAR	';'

d77 5
d111 2
d124 1
d127 2
d141 2
d144 1
d209 2
d229 2
a231 1

d269 2
d313 2
d373 2
d386 3
d398 2
d447 2
d473 2
d577 2
d800 2
d885 2
d1298 2
d1413 2
d1504 1
a1504 1
      decode_indirect_address( src4 >> 4, src4 & 7, 1 );
d1530 2
d1555 2
d1606 3
d1662 3
d1803 2
d1947 1
a1947 1
	      src2 & 0x7, (src2 >> 2),
d1963 1
a1963 1
		  src1 & 0x7, (src1 >> 2),
d1970 1
a1970 1
		  src1 & 0x7, (src1 >> 2),
d1979 2
a1980 2
	      src2 & 0x7, (src2 >> 2),
	      src1 & 0x7, (src1 >> 2),
d1993 2
d2007 3
d2146 2
d2169 2
d2181 2
d2195 2
d2198 2
d2218 2
d2256 2
d2259 1
d2651 2
d2695 2
d2760 2
d2783 3
d2795 2
d3011 5
@


1.92
log
@added decoding of X_PCreloc2
@
text
@d1774 1
a1774 1
	  syserr( syserr_non_float_dest, _regname( dest ) );
@


1.91
log
@oops, fixed typos in previous delta
@
text
@d2261 6
@


1.90
log
@changes syserrs to use constant strings
@
text
@d1511 1
a1511 1
   * we have a triaidic parallel op code of the form:
d1755 1
a1755 1
   * we have a triaidic op code
d1888 1
a1888 1
	  syserr( syserr_no_triaidic_FP_imm );
d1948 1
a1948 1
       * triaidic op code
@


1.89
log
@fixed compile time warnings
@
text
@d397 1
a397 1
      syserr( "disassembler: unknown indirect addressing mode %lx", mode );
d574 1
a574 2
	      syserr( "disassembler: destination of FP op (%s) is not an FP register (%s)",
		     instruction, _regname( dest ) );
d599 1
a599 2
	  syserr( "disassembler: bad value in source field of register addressed op %s (%lx)",
		 instruction, op_code );
d610 1
a610 2
	      syserr( "disassembler: non FP source register %s for op %s (%lx)",
		     _regname( src ), instruction, op_code );
d1843 1
a1843 1
	syserr( "asm: triadic floating point immediate operations are impossible" );
d1888 1
a1888 1
	  syserr( "asm: triadic floating point immediate operations are impossible" );
d2761 1
a2761 1
	      syserr( "asm: mislaid a symbol!" );
@


1.88
log
@Fixed bugs 1142 (contants in asm output) and 1138 (missing register name in asm output)
@
text
@d397 1
a397 1
      syserr( "disassembler: unknown indirect addressing mode %x", mode );
d600 1
a600 1
	  syserr( "disassembler: bad value in source field of register addressed op %s (%x)",
d612 1
a612 1
	      syserr( "disassembler: non FP source register %s for op %s (%x)",
@


1.87
log
@fixed to remove extra bracket in addrstub asm output and change 'add'
patch name to p_add.
@
text
@d268 1
d271 3
d694 1
a694 1
      if (sym_reladdr != NULL && exporting_routines)
d698 15
a712 2
	  asmf( "L%ldF%ld - .%s", (long)(lab_name_( exporting_routines ) & 0x7fffffffL),
	       (long)fncount, symname_( sym_reladdr ) );	  
@


1.86
log
@removed spurious fseek from outputing code
@
text
@d2300 1
a2300 1
		  asmf( "patchinstr( PATCHC40MASK16ADD, shift ( -18, add ( -12, " );
d2344 1
a2344 1
		  asmf( "ADDRSTUB ( .addr.%s ) ) ),\n", symname_( (Symstr *)(int)aux ) );
@


1.85
log
@fixed output speed
@
text
@d78 1
a78 1
  fseek( asmstream, 0L, SEEK_END );
@


1.84
log
@prevented generation  of module header and trailer because this is now done by the assembler
@
text
@d76 1
a76 1
  fflush( asmstream );
d214 1
a214 1
	  switch (x->codexroff & (unsigned long)0xff000000L)
@


1.83
log
@fixed decode of LDEP and LDPE instructions
@
text
@d2563 1
d2578 1
d2874 1
d2881 1
@


1.82
log
@fixed assembler output to be assembler compatible
@
text
@d690 8
a697 1
      if (type == TYPE_FLOATING)
d932 2
a933 2
				  _regname( op_code ),
				  flag_errs ? "<xxx unknown expansion register xxx>" : "" );
d938 2
a939 2
				  flag_errs ? "<xxx unknown expansion register xxx>" : "",
				  _regname( op_code >> 16 ) );
d1221 1
a1221 1
      
d2450 4
a2453 2
	  if (!patch_pend && sym_reladdr)
	    asmf( ".%s", symname_( sym_reladdr ) );
@


1.81
log
@changed large_modle to few_modules
@
text
@d2591 4
d2644 1
a2644 1
      asmf( "data   %s, %ld\n", symname_( symbol ), size );
@


1.80
log
@fixed compile time warning
@
text
@d2343 1
a2343 1
			  large_model ? "PATCHC40MASK16ADD" : "PATCHC40MASK8ADD",
d2350 1
a2350 1
			  large_model ? "PATCHC40MASK16ADD" : "PATCHC40MASK8ADD" );
@


1.79
log
@fixed output to be compatible with assembler
@
text
@d1164 1
a1164 1
			  asmf( "%d %c%c offset = %+ld", op_code - offset - 1,
d1169 1
a1169 1
		      asmf( "%d", op_code - offset - 1 );
@


1.78
log
@fixed unnecessary flushes
@
text
@d45 1
a45 1
    }
d51 1
d1164 3
a1166 1
			  asmf( "%c offset = %+ld", ASM_COMMENT_CHAR, op_code - offset - 1 );
a2183 1
      bool		patch_pend = FALSE;
d2212 2
@


1.77
log
@upgraded to support address generation stubs
@
text
@d81 1
a81 1
  fflush( asmstream );
d401 2
a402 2
 * extracts the bits specified by 'mask' from the word 'value'
 * if necessary the resulting word is sign extended.
d404 1
a404 1
 * the least significant bit
@


1.76
log
@fixed decoding of branch addresses
@
text
@d221 1
d237 1
a237 1
static void
d262 1
a262 1
	  return;
d270 1
a270 1
  return;
d326 1
a326 1
  printlabelname( codebase + current_pos + offset * sizeof_int, TRUE );	/* not right ??? */
d1053 4
a1056 3
		      printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );
		      
		      /* asmf( "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
d1102 4
a1105 3
		      printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );
		      
		      /* asmf( "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
a1149 1
#if 1
d1160 5
a1164 4
		      printlabelname( current_pos + (op_code - offset - 1) * sizeof_int, flag_errs );
		      
		      /* asmf( "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */		      
		    }
d1166 1
a1166 2
		  if (sym_reladdr == NULL)
		    asmf( "%d", op_code - offset - 1 );
d1168 1
d1172 4
a1175 3
		  printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );
		  
		  /* asmf( "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
d2330 7
@


1.75
log
@fixed decoding of exported code symbols
@
text
@d1147 1
a1147 1
#if 0
d1153 1
a1153 1
		       * deocded later
d1164 1
a1164 1
		    asmf( "%d", -offset );
@


1.74
log
@improved address decoding
@
text
@d2570 1
a2570 1
	  if (!is_local( x ) && is_global( x ))
d2573 1
a2573 1
	  
@


1.73
log
@fixed decoding of label addresses
@
text
@d185 2
a186 4
static int32
pr_asmname(
	   Symstr *	sym,
	   FILE *	stream )
d191 3
a193 1
  return fprintf( stream, "%s", s );
d280 1
a280 1
decode_addr( int32 addr )
d286 1
a286 1
  
d291 1
a291 1
      
d302 1
a302 2
	  
	  if ((codebase + (lab->u.defn & 0x00ffffff)) / sizeof_int + addr  == xroffset)
a305 3
	      if (addr != 0)
		asmf( "+0x%lx", addr );
	      
d310 1
a310 1
  
d315 1
a315 1
      pr_asmname( name, asmstream );
d319 1
a319 1
      
d322 1
a322 1
  
d325 1
a325 1
  printlabelname( codebase + current_pos + addr * sizeof_int, TRUE );	/* not right ??? */
d2077 1
a2077 1
decode_DCAx( int32 op_code )
d2079 1
a2079 1
  asmf( "word\t" );
d2081 1
a2081 1
  decode_addr( op_code );
d2093 1
a2093 1
  asmf( "word\t_" );
d2097 1
a2097 1
  pr_asmname( s, asmstream );
d2134 1
a2134 1
  pr_asmname( sym, asmstream );
d2167 1
a2167 1
      pr_asmname( name, asmstream );
d2574 1
a2574 1
	      pr_asmname( x->extsym, asmstream );
d2600 1
a2600 1
	      pr_asmname( x->extsym, asmstream );
d2604 1
a2604 1
	      pr_asmname( x->extsym, asmstream );
d2830 1
a2830 1
	  pr_asmname( x->extsym, asmstream );
@


1.72
log
@fixed to work with new style stub generation
@
text
@d305 2
@


1.71
log
@with new added super Zap
(oh alright then - i have changed the linking scheme to support linker generated stubs)
(see I told you it was new improved super Zap)
@
text
@d24 1
d26 1
d558 1
d1017 1
a1017 1
		  int	offset;
d1066 1
a1066 1
		  int	offset;
d1114 1
a1114 1
	      int	offset;
d1149 1
d1162 1
a1162 1
		      /* asmf( "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
d1164 4
d1373 1
d1883 1
a1883 2
      asmf( "%s\t*+AR%.1ld(%.2lu), *+AR%.1ld(%.2lu), %s",
	      instruction,
d2211 1
a2211 1
	  int32		pos;
d2229 3
a2231 1
		  patch_pend = FALSE;
d2235 1
a2235 2
		  fprintf( asmstream,
			  "patchinstr( PATCHC40DATAMODULE1, shift( -2, DATAMODULE ( _%s ) ),\n",
d2240 1
a2240 2
		  fprintf( asmstream,
			  "patchinstr( PATCHC40DATAMODULE2, shift ( -2, CODESYMB ( _%s ) ),\n",
d2245 1
a2245 2
		  fprintf( asmstream,
			  "patchinstr( PATCHC40DATAMODULE3, MODNUM,\n" );
d2249 1
a2249 2
		  fprintf( asmstream,
			  "patchinstr( PATCHC40DATAMODULE4, MODNUM,\n" );
d2253 1
a2253 2
		  fprintf( asmstream,
			  "patchinstr( PATCHC40DATAMODULE5, MODNUM,\n" );
d2260 1
a2260 1
		    {		      
d2287 18
a2304 3
		  fprintf( asmstream,
			  "patchinstr( PATCHC40MASK16ADD, shift ( -18, add ( -12, LABELREF ( .%s ) ) ),\n",
			  symname_( (Symstr *)(int)aux ) );
d2308 18
a2325 3
		  fprintf( asmstream,
			  "patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 14, LABELREF ( .%s ) ) ),\n",
			  symname_( (Symstr *)(int)aux ) );
d2329 1
a2329 2
		  fprintf( asmstream,
			  "patchinstr( %s, shift ( -2, DATAMODULE ( _%s ) ),\n",
d2347 1
a2347 2
		  fprintf( asmstream,
			  "patchinstr( PATCHC40MASK16ADD, shift ( -2, %s ( _%s ) ),\n",
d2353 1
a2353 2
		  fprintf( asmstream,
			  "patchinstr( MODNUM\n" );
d2357 3
a2359 4
		  fprintf( asmstream,
			  "patchinstr( %s ( _%s ) \n",
			  split_module_table ? "CODESYMB" : "DATASYMB",
			  symname_( (Symstr *)(int)aux ) );
d2363 1
a2363 2
		  fprintf( asmstream,
			  "patchinstr( LABELREF ( _%s ) \n",
d2430 1
a2430 3
	  if (patch_pend)
	    ;
	  else if (sym_reladdr)
a2566 2
  bool		done_first = FALSE;
  
d2568 1
a2568 1
  for (x = obj_symlist; x != NULL; x = x->extcdr)
d2570 3
a2572 3
      if (!is_local( x ) && is_global( x ))
        {
	  if (done_first)
d2574 4
d2580 10
a2589 1
	  else
d2591 10
a2600 4
	      done_first = TRUE;
	    }
	  
	  asmf( "codetable _" );
d2602 1
a2602 1
	  pr_asmname( x->extsym, asmstream );
d2604 1
a2604 3
	  asmf( "\n" );

	  asmf( "export    _" );
d2606 1
a2606 1
	  pr_asmname( x->extsym, asmstream );
d2608 4
a2611 3
	  asmf( "\n" );
        }
    }
@


1.70
log
@oops, fixed previous delta
@
text
@d23 1
a23 1
#ifndef __C40
a24 3
#endif

#include "helios.h"
a2171 1
      bool		stub_pend  = FALSE;
a2220 1
		  stub_pend  = TRUE;
@


1.69
log
@defined processor type for module.h inclusion
@
text
@d23 1
d25 2
@


1.68
log
@minor cosmetic changes
@
text
@d23 1
@


1.67
log
@made asmf() be exported
@
text
@d2192 1
a2192 1
	      
d2481 3
a2483 1
    syserr( syserr_asmlab, 0L );
d2487 1
a2487 1
  asm_lablist = 0;    /* stop confusion when called from vargen.c  */
@


1.66
log
@fixed output to be more realistic
@
text
@d61 1
a61 1
static void
@


1.65
log
@fixed output to be compatible with Helios assembler
@
text
@d46 2
a47 2
FILE *			asmstream = NULL;
Symstr *		sym_reladdr;
a689 5
      else if (sym_reladdr != NULL)
	{
	  asmf( ".%s, %s\t%c value = %+ld,",
		  symname_( sym_reladdr ), pdest, ASM_COMMENT_CHAR, dest );
	}
d703 15
d1820 1
a1820 3
	  /* asmf( "\t%c offset = %ld",
		  ASM_COMMENT_CHAR,
		  op_code ); */
d2403 1
a2403 1
	  else
@


1.64
log
@removed superflous function
@
text
@d2395 1
a2395 1
	  else if (stub_pend)
a2396 2
	  else
	    asmf( "\t%s", symname_( sym_reladdr ) );
@


1.63
log
@removed debugging left in from previous delta
@
text
@d98 1
d111 1
a111 1

@


1.62
log
@hmm - unable to fix ordering of function name characters
@
text
@a2052 2
  debug( "2. before %x", op_code );
  
@


1.61
log
@added some more (commented out) deubgging
@
text
@d2053 2
a2688 2
	  val = totargetsex( val, (int)sort );
	  
@


1.60
log
@changed 'global' to 'export' in assemblr output
@
text
@d1116 1
a1116 1
	      
d2182 2
@


1.59
log
@removed supurious output
@
text
@d2115 2
a2116 1
  /* asmf( "\t.global\t_" );
d2118 1
a2118 1
     pr_asmname( sym, asmstream );
d2120 2
a2121 1
     fputs( "\n", asmstream ); */
d2577 1
a2577 1
	  asmf( "global %s\n", symname_( symbol ) );
@


1.58
log
@slightly improved output
@
text
@d35 1
d610 1
a610 1
      if (pdest /* && dest != src */)
d2698 1
a2698 6
#ifdef TARGET_IS_C40
	      if (len == 4)
		decode_DC( IEEE_to_single_float( fc->floatbin.fb.val ) );
	      else
		decode_DC( IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, NULL ) );
#else  
d2704 1
a2706 4
#ifdef TARGET_IS_C40
		  int32	v;
#endif
		  
a2710 5
#ifdef TARGET_IS_C40
		  (void) IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &v );
		  
		  decode_DC( v );
#else
a2711 1
#endif
d2713 1
a2713 1
	      
@


1.57
log
@fixed output to generate data and global directives
@
text
@d609 1
a609 1
      if (pdest && dest != src)
d2052 1
a2052 1
  asmf( "word\t%#.8lx", (long)op_code );
@


1.56
log
@ammended to work with new version of mcdpriv.h
@
text
@d56 29
d90 1
a90 1
    fprintf( asmstream, "%c\n", ASM_COMMENT_CHAR );
d158 1
a158 1
	    fprintf( asmstream, "\\%o", (int)c );
d254 1
a254 1
	  (void) fprintf( asmstream, "L%ldF%ld", (long)(lab_name_( lab ) & 0x7fffffffL), (long)fncount );
d261 2
a262 2
    (void) fprintf( asmstream, "<unknown destination> offset + base = %ld, current pos = %ld, offset = %ld",
		   (offset + codebase) / sizeof_int, current_pos / sizeof_int, offset / sizeof_int);
d301 1
a301 1
		fprintf( asmstream, "+0x%lx", addr );
d315 1
a315 1
	fprintf( asmstream, " + 0x%lx", xroffset );
d361 26
a386 26
    case B_00000:	fprintf( asmstream, "*+AR%ld(%ld)",         addr, disp ); break;
    case B_00001:	fprintf( asmstream, "*-AR%ld(%ld)",         addr, disp ); break;
    case B_00010:	fprintf( asmstream, "*++AR%ld(%ld)",        addr, disp ); break;
    case B_00011:	fprintf( asmstream, "*--AR%ld(%ld)",        addr, disp ); break;
    case B_00100:	fprintf( asmstream, "*AR%ld++(%ld)",        addr, disp ); break;
    case B_00101:	fprintf( asmstream, "*AR%ld--(%ld)",        addr, disp ); break;
    case B_00110:	fprintf( asmstream, "*AR%ld++(%ld)%%",      addr, disp ); break;
    case B_00111:	fprintf( asmstream, "*AR%ld--(%ld)%%",      addr, disp ); break;
    case B_01000:	fprintf( asmstream, "*+AR%ld(IR0)",         addr       ); break;
    case B_01001:	fprintf( asmstream, "*-AR%ld(IR0)",         addr       ); break;
    case B_01010:	fprintf( asmstream, "*++AR%ld(IR0)",        addr       ); break;
    case B_01011:	fprintf( asmstream, "*--AR%ld(IR0)",        addr       ); break;
    case B_01100:	fprintf( asmstream, "*AR%ld++(IR0)",        addr       ); break;
    case B_01101:	fprintf( asmstream, "*AR%ld--(IR0)",        addr       ); break;
    case B_01110:	fprintf( asmstream, "*AR%ld++(IR0)%%",      addr       ); break;
    case B_01111:	fprintf( asmstream, "*AR%ld--(IR0)%%",      addr       ); break;
    case B_10000:	fprintf( asmstream, "*+AR%ld(IR1)",         addr       ); break;
    case B_10001:	fprintf( asmstream, "*-AR%ld(IR1)",         addr       ); break;
    case B_10010:	fprintf( asmstream, "*++AR%ld(IR1)",        addr       ); break;
    case B_10011:	fprintf( asmstream, "*--AR%ld(IR1)",        addr       ); break;
    case B_10100:	fprintf( asmstream, "*AR%ld++(IR1)",        addr       ); break;
    case B_10101:	fprintf( asmstream, "*AR%ld--(IR1)",        addr       ); break;
    case B_10110:	fprintf( asmstream, "*AR%ld++(IR1)%%",      addr       ); break;
    case B_10111:	fprintf( asmstream, "*AR%ld--(IR1)%%",      addr       ); break;
    case B_11000:	fprintf( asmstream, "*AR%ld",               addr       ); break;
    case B_11001:	fprintf( asmstream, "*AR%ld++(IR0)B",       addr       ); break;
d572 1
a572 1
  fprintf( asmstream, "%s\t", instruction );
d607 1
a607 1
      fprintf( asmstream, "%s", _regname( src ) );
d610 1
a610 1
	fprintf( asmstream, ", %s", pdest );
d626 1
a626 1
	fprintf( asmstream, "%s, @@%#04.4lx", pdest, (op_code & 0xffff) );
d628 1
a628 1
	fprintf( asmstream, "@@%#04.4lx, %s", (op_code & 0xffff), pdest );
d630 1
a630 1
	fprintf( asmstream, "@@%#04.4lx", (op_code & 0xffff) );
d654 1
a654 1
	      fprintf( asmstream, "%s, ", pdest );
d663 1
a663 1
		fprintf( asmstream, ", %s", pdest );
d686 1
a686 1
	  fprintf( asmstream, "%s, %s", decode_short_float( dest ), pdest );
d690 1
a690 1
	  fprintf( asmstream, ".%s, %s\t%c value = %+ld,",
d695 1
a695 1
	  fprintf( asmstream, "%-3ld, %s", dest, pdest );
d699 1
a699 1
	  fprintf( asmstream, "%#-3lx, %s", dest, pdest );
d703 1
a703 1
	  fprintf( asmstream, "%#-3lx", dest );
d745 1
a745 1
      fprintf( asmstream, "STIK\t%-3ld, @@%#04.4lx",
d757 1
a757 1
      fprintf( asmstream, "STI\t%s, @@%#04.4lx", _regname( dest ), (op_code & 0xffff) );
d770 1
a770 1
      fprintf( asmstream, "STI\t%s, ", _regname( dest ) );
d785 1
a785 1
      fprintf( asmstream, "STIK\t%-3ld, ", mask_and_sign_extend_word( dest, 0x1f ) );
d840 1
a840 1
		      fprintf( asmstream, "RPTBD\t%s", _regname( op_code ) );
d844 1
a844 1
		      fprintf( asmstream, "RPTB\t%s", _regname( op_code ) );
d861 1
a861 1
		      fprintf( asmstream, "RETS%s", _condname( op_code >> 16 ) );
d876 1
a876 1
			  fprintf( asmstream, "RETI%sD", _condname( op_code >> 16 ) );
d880 1
a880 1
			  fprintf( asmstream, "RETI%s", _condname( op_code >> 16 ) );
d908 1
a908 1
			  fprintf( asmstream, "LDPE\t%s, %s",
d914 1
a914 1
			  fprintf( asmstream, "LDEP\t%s, %s",
d946 1
a946 1
		      fprintf( asmstream, "%s\t%lu", op, op_code & 0x1ff );
d980 1
a980 1
		      fprintf( asmstream, "%s\t%+ld", op, op_code );
d984 1
a984 1
		      fprintf( asmstream, "%s\t%s", op, _regname( op_code & 0x1f ) );
d1036 1
a1036 1
		      fprintf( asmstream, "%s\tAR%1ld, ", op, addr );
d1040 1
a1040 1
		      /* fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
d1044 1
a1044 1
		      fprintf( asmstream, "%s\tAR%1ld, %s", op, addr, _regname( op_code & 0x1f ) );
d1084 1
a1084 1
		      fprintf( asmstream, "%s\t", op );
d1088 1
a1088 1
		      /* fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
d1092 1
a1092 1
		      fprintf( asmstream, "%s\t%s", op, _regname( op_code & 0x1f ) );
d1105 7
a1111 7
		case B_000:	fprintf( asmstream, "BR\t"    ); offset = -2; break;
		case B_001:	fprintf( asmstream, "BRD\t"   ); offset = -4; break;
		case B_010:	fprintf( asmstream, "CALL\t"  ); offset = -2; break;
		case B_011:	fprintf( asmstream, "LAJ\t"   ); offset = -4; break;
		case B_100:	fprintf( asmstream, "RPTB\t"  ); offset = 0;  break;
		case B_101:	fprintf( asmstream, "RPTBD\t" ); offset = 3;  break;
		case B_110:	fprintf( asmstream, "SWI\t"   ); return;
d1129 1
a1129 1
		  fprintf( asmstream, "4\t%c <fetching PC>", ASM_COMMENT_CHAR );
d1145 1
a1145 1
		      /* fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
d1152 1
a1152 1
		  /* fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
d1362 1
a1362 1
      fprintf( asmstream, "%s\t", op1 );
d1366 1
a1366 1
      fprintf( asmstream, ", " );
d1370 1
a1370 1
      fprintf( asmstream, ", %s  || %s\t%s, %s, %s",
d1377 1
a1377 1
      fprintf( asmstream, "%s\t", op1 );
d1381 1
a1381 1
      fprintf( asmstream, ", %s, %s  || %s\t",
d1386 1
a1386 1
      fprintf( asmstream, ", %s, %s", _regname( src2 ), _regname( dst2 ) );
d1392 1
a1392 1
      fprintf( asmstream, "%s\t%s, %s, %s  || %s\t",
d1397 1
a1397 1
      fprintf( asmstream, ", " );
d1401 1
a1401 1
      fprintf( asmstream, ", %s", _regname( dst2 ) );
d1407 1
a1407 1
      fprintf( asmstream, "%s\t", op1 );
d1411 1
a1411 1
      fprintf( asmstream, ", %s, %s  || %s\t, %s, ",
d1416 1
a1416 1
      fprintf( asmstream, ", %s", _regname( dst2 ) );
d1484 1
a1484 1
  fprintf( asmstream, "%s\t", first_op );
d1488 1
a1488 1
  fprintf( asmstream, ", %s, %s  || %s\t%s, ",
d1538 1
a1538 1
  fprintf( asmstream, "%s\t", first_op );
d1542 1
a1542 1
  fprintf( asmstream, ", %s  || %s\t%s, ", _regname( dst1 ), second_op, _regname( src3 ) );
d1589 1
a1589 1
      fprintf( asmstream, "STF\t%s, ", _regname( field5 ) );
d1593 1
a1593 1
      fprintf( asmstream, "  || STF\t%s, ", _regname( field3 ) );
d1607 1
a1607 1
      fprintf( asmstream, "STI\t%s, ", _regname( field5 ) );
d1611 1
a1611 1
      fprintf( asmstream, "  || STI\t%s, ", _regname( field3 ) );
d1625 1
a1625 1
      fprintf( asmstream, "LDF\t" );
d1629 1
a1629 1
      fprintf( asmstream, ", %s  || LDF\t", _regname( field5 ) );
d1633 1
a1633 1
      fprintf( asmstream, ", %s", _regname( field4 ) );
d1645 1
a1645 1
      fprintf( asmstream, "LDI\t" );
d1649 1
a1649 1
      fprintf( asmstream, ", %s  || LDI\t", _regname( field5 ) );
d1653 1
a1653 1
      fprintf( asmstream, ", %s", _regname( field4 ) );
d1747 1
a1747 1
  fprintf( asmstream, "%s\t", instruction );
d1753 1
a1753 1
      fprintf( asmstream, "%s, %s, %s",
d1762 1
a1762 1
      fprintf( asmstream, "%s, ", _regname( src2 & 0x3f ) );
d1766 1
a1766 1
      fprintf( asmstream, ", %s", pdest );
d1774 1
a1774 1
      fprintf( asmstream, ", %s", _regname( src1 & 0x3f ) );
d1776 1
a1776 1
      fprintf( asmstream, ", %s", pdest );
d1784 1
a1784 1
      fprintf( asmstream, ", " );
d1788 1
a1788 1
      fprintf( asmstream, ", %s", pdest );
d1803 1
a1803 1
	  fprintf( asmstream, ".%s, %s, %s",
d1808 1
a1808 1
	  /* fprintf( asmstream, "\t%c offset = %ld",
d1814 1
a1814 1
	  fprintf( asmstream, "%#-3lx, %s, %s",
d1821 1
a1821 1
	  fprintf( asmstream, "%-3ld, %s, %s",
d1831 1
a1831 1
      fprintf( asmstream, "*+AR%.1ld(%.2lu), %s, %s",
d1846 1
a1846 1
	  fprintf( asmstream, "%-3ld, *+AR%.1ld(%.2lu), %s",
d1853 1
a1853 1
	  fprintf( asmstream, "%#-3lx, *+AR%.1ld(%.2lu), %s",
d1863 1
a1863 1
      fprintf( asmstream, "%s\t*+AR%.1ld(%.2lu), *+AR%.1ld(%.2lu), %s",
d1885 1
a1885 1
  fprintf( asmstream, "%s\t%s", instruction, _regname( (op_code >> 16) & 0x1f ) );
d1967 1
a1967 1
	case OP_IDLE:	fprintf( asmstream, "IDLE" ); return;
d1980 1
a1980 1
	case OP_NOP:	fprintf( asmstream, "NOP" ); return;	/* XXX - not quite true can use indirect addressing to adjust address registers */
d2052 1
a2052 1
  fprintf( asmstream, "word\t%#.8lx", (long)op_code );
d2062 1
a2062 1
  fprintf( asmstream, "word\t" );
d2076 1
a2076 1
  fprintf( asmstream, "word\t_" );
d2083 1
a2083 1
    fprintf( asmstream, " %+ld", (long)op_code );
d2100 1
a2100 1
  if ((x = symext_( sym )) != 0 && (x->extflags & xr_defext) == 0)
d2114 1
a2114 1
  /* fprintf( asmstream, "\t.global\t_" );
d2141 1
a2141 1
      fprintf( asmstream, "%c        align 128\n", ASM_COMMENT_CHAR );
d2144 1
a2144 1
	fprintf( asmstream, "%.6lx  %20s", (long)codebase, "" );
d2150 1
a2150 1
      fprintf( asmstream, ":\n" );
d2175 1
a2175 1
		fprintf( asmstream, "%28s", "" );
d2177 1
a2177 1
	      fprintf( asmstream, "L%ldF%ld:\n", (long)(lab_name_( t ) & 0x7fffffff), (long)fncount );
d2239 1
a2239 1
		  fprintf( asmstream, "patchinstr( PATCHC40MASK16ADD, " );
d2243 1
a2243 1
		      fprintf( asmstream, "shift ( -18, CODESYMB ( _%s ) ),\n",
d2248 1
a2248 1
		      fprintf( asmstream, "shift ( -16, DATASYMB ( _%s ) ),\n",
d2254 1
a2254 1
		  fprintf( asmstream, "patchinstr( PATCHC40MASK16ADD, " );
d2258 1
a2258 1
		      fprintf( asmstream, "shift ( -16, shift ( 14, CODESYMB ( _%s ) ) ),\n",
d2263 1
a2263 1
		      fprintf( asmstream, "shift ( -16, shift ( 16, DATASYMB ( _%s ) ) ),\n",
d2289 1
a2289 1
		  fprintf( asmstream, "patchinstr( %s, ",
d2293 1
a2293 1
		    fprintf( asmstream, "shift ( 1, MODNUM ),\n" );
d2295 1
a2295 1
		    fprintf( asmstream, "MODNUM,\n" );
d2325 1
a2325 1
		  fprintf( asmstream, "%c unknown cross reference type %lx\n", ASM_COMMENT_CHAR, xrtype );
d2341 1
a2341 1
	  fprintf( asmstream, "%.6lx  ", (long)(current_pos + codebase) );
d2348 1
a2348 1
		  fprintf( asmstream, "%.8lx ", (long)code_inst_( current_pos + i ) );
d2350 1
a2350 1
		  fprintf( asmstream, "     " );
d2354 1
a2354 1
	      fprintf( asmstream, "      %.8lx      ", (long)totargetsex( op_code, LIT_BBBB ) );
d2358 1
a2358 1
	      fprintf( asmstream, "      %.8lx      ", (long)op_code );
d2390 1
a2390 1
	    fprintf( asmstream, ".%s", symname_( sym_reladdr ) );
d2392 1
a2392 1
	    fprintf( asmstream, "\t%s", symname_( sym_reladdr ) );
d2401 1
a2401 1
	      fprintf( asmstream, "         %c ", ASM_COMMENT_CHAR );
d2424 1
a2424 1
	    fprintf( asmstream, " %c E'%s'", ASM_COMMENT_CHAR, aux );
d2435 1
a2435 1
	    fprintf( asmstream, " %c D'%s'", ASM_COMMENT_CHAR, aux );
d2443 1
a2443 1
	  fprintf( asmstream, "\n " );
d2450 1
a2450 1
	    fprintf( asmstream, " %c D'%s'", ASM_COMMENT_CHAR, aux );
d2459 1
a2459 1
	  fprintf( asmstream, "?" );
d2463 1
a2463 1
	fprintf( asmstream, " )\n" );
d2465 1
a2465 1
	fprintf( asmstream, "\n" );
d2498 1
a2498 1
  fprintf( asmstream, "%c generated by %s\n", ASM_COMMENT_CHAR, CC_BANNER );
d2502 11
a2512 11
      fprintf( asmstream, "\talign\n" );
      fprintf( asmstream, "\tmodule  -1\n" );
      fprintf( asmstream, ".ModStart:\n" );      
      fprintf( asmstream, "\tword    %#lx\n", T_Module );
      fprintf( asmstream, "\tword    (.ModEnd - .ModStart) * 4\n" );
      fprintf( asmstream, "\tblkb    32,\"%.31s\"\n", sourcefile );
      fprintf( asmstream, "\tword    modnum\n" );
      fprintf( asmstream, "\tword    1\n" );
      fprintf( asmstream, "\tword    datasymb ( .MaxData )\n" );
      fprintf( asmstream, "\tinit\n" );
      fprintf( asmstream, "\tword    codesymb ( .MaxCodeP )\n" );      
d2526 2
a2527 1

d2529 1
a2529 1
  for (x = obj_symlist; x != 0; x = x->extcdr)
d2531 1
a2531 4
      int32	flags = x->extflags;

      
      if (!(flags & xr_defloc) && (flags & xr_defext))
d2533 10
a2542 1
	  fprintf( asmstream, "codetable _" );
d2546 1
a2546 1
	  fprintf( asmstream, "\n" );
d2548 1
a2548 1
	  fprintf( asmstream, "export    _" );
d2552 1
a2552 1
	  fprintf( asmstream, "\n\n" );
d2563 20
d2596 6
a2601 2
  DataInit *	p;
  int32 	i = 0;
a2602 1
  
d2608 2
a2610 1
  asm_blank( 1 );
d2613 5
d2620 10
a2629 5
  {
    int32	rpt  = p->rpt;
    int32	sort = p->sort;
    int32	len  = p->len;
    int32	val  = p->val;
d2631 10
a2640 15
    
    if (sort != LIT_LABEL)
      asm_padcol8( 0 );
    
    switch (sort)
      {
      case LIT_LABEL:
#if 0
	fputc( '_', asmstream );
	
	pr_asmname( (Symstr *)rpt, asmstream );
	
	fprintf( asmstream, ": %c 0x%lx", ASM_COMMENT_CHAR, i );
#endif	
	break;
d2642 6
a2647 37
      default:
	syserr( syserr_asm_trailer, (long)sort );
	
      case LIT_BBBB:
      case LIT_HH:
      case LIT_BBH:
      case LIT_HBB:
	val = totargetsex( val, (int)sort );

      case LIT_NUMBER:
	if (len != 4)
	  syserr( syserr_datalen, (long)len );
#if 0	
	if (rpt == 1)
	  {
	    decode_DC( val );
	  }
	else if (val == 0)
	  {
	    while (rpt-- != 0)      /* yukky -- what is the unixism? */
	      {
		decode_DC( 0 );
		
		if (rpt != 0)
		  {
		    fprintf( asmstream, "\n" );
		    
		    asm_padcol8( 0 );
		  }
	      }
	  }
	else
	  syserr( syserr_asm_trailer1, (long)rpt, (long)val );
#endif
	i += len * (p->rpt);
	
	break;
d2649 4
a2652 3
      case LIT_FPNUM:
        {
	   FloatCon *	fc = (FloatCon *)val;
d2654 14
a2667 8
	   
#ifdef TARGET_IS_C40
	  if (len == 4)
	    decode_DC( IEEE_to_single_float( fc->floatbin.fb.val ) );
	  else
	    decode_DC( IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, NULL ) );
#else  
	  decode_DC( fc->floatbin.irep[ 0 ] );
d2669 20
a2688 2
	  if (annotations) 
	    fprintf( asmstream, " %c %s", ASM_COMMENT_CHAR, fc->floatstr );
d2690 3
a2692 1
	  if (len == 8)
d2694 3
d2698 6
a2703 1
	      int32	v;
d2705 2
d2708 10
a2717 4
	      fprintf( asmstream, "\n" );
	      
	      asm_padcol8( 0 );

d2719 3
a2721 3
	      (void) IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, &v );
	      
	      decode_DC( v );
d2723 1
a2723 1
	      decode_DC( fc->floatbin.db.lsd );
d2725 5
d2731 4
a2734 9
	      
	  i += len;

	  break;
        }

      case LIT_ADCON:              /* (possibly external) name + offset */
	if (rpt != 1)
	  syserr( syserr_asm_trailer2 );
d2736 1
a2736 1
	decode_DCA( (Symstr *)len, val );
d2738 4
a2741 4
	i += 4;

	break;
      }
d2743 1
a2743 1
    fprintf( asmstream, "\n" );
d2745 1
a2745 1
  }
d2747 1
a2747 3
  asm_blank( 1 );

  if (suppress_module != 1)
d2749 1
a2749 1
      fprintf( asmstream, "data %s, %ld\n", symname_( bindsym_( datasegment ) ), i );
a2751 2
  asm_blank( 1 );
  
d2760 1
a2760 1
      fprintf( asmstream, "%c%c%c Start of BSS\n", ASM_COMMENT_CHAR, ASM_COMMENT_CHAR, ASM_COMMENT_CHAR );
d2764 1
a2764 1
	  if (x->extflags & xr_bss)
d2783 1
a2783 1
	    fprintf( asmstream, ",%ld,%cbss%c\n", x->extoffset-n, '"', '"' );
d2789 1
a2789 1
	  fprintf( asmstream, "\t.common\t_" );
d2795 1
a2795 1
	fprintf( asmstream, ",%ld, %cbss%c\n", bss_size - n, '"', '"' );
d2798 2
a2800 2
  asm_blank( 1 );

d2807 3
a2809 3
      fprintf( asmstream, "\tdata      .MaxData, 0\n" );
      fprintf( asmstream, "\tcodetable .MaxCodeP\n" );
      fprintf( asmstream, ".ModEnd:\n" );
d2812 1
a2812 1
  fprintf( asmstream, "%c END\n", ASM_COMMENT_CHAR );
@


1.55
log
@allowed X_DataModel to work with large_model pragma
@
text
@a35 10
#ifdef TARGET_HAS_DEBUGGER
extern void	db_init( char * filename );
extern void	db_tidy( void );
#endif

#ifndef TRUE
#define TRUE	1
#define FALSE	0
#endif

a47 9
extern CodeXref *	codexrefs;
extern int		split_module_table;
extern int 		suppress_module;

extern int32		IEEE_to_single_float( int32 val );
extern int32		IEEE_to_extended_float( int32 high, int32 low, int32 * low_return );

#define annotations (feature & FEATURE_ANNOTATE)

d58 4
a61 4
  asm_blank( int32 n )
  {
    while (n-- > 0)
      fprintf( asmstream, "%c\n", ASM_COMMENT_CHAR );
d63 1
a63 1
    return;
d65 1
a65 1
  } /* asm_blank */
d69 4
a72 4
  asm_padcol8( int32 n )
  {
    if (!annotations)
      n = 7;      /* compact the asm file */
d74 2
a75 2
    while (n < 8)
      fputc( ' ', asmstream ), n++;
d77 1
a77 1
    return n;
d79 1
a79 1
  } /* asm_padcol8 */
d83 3
a85 3
  pr_chars( int32 w )   /* works on both sex machines */
  {
    int	i, c;
d87 2
a88 1
    fputc( '\'', asmstream );
d90 54
a143 54
    for (i = 0; i < sizeof( int32 ); i++)
      {
	switch (c = ((unsigned char *)&w)[ i ])
	  {
	  case '\\':
	  case '\'':
	  case '\"':
	    break;
	    
	  case '\a':
	    c = 'a';
	    break;
	    
	  case '\b':
	    c = 'b';
	    break;
	    
	  case CHAR_FF:
	    c = 'f';
	    break;
	    
	  case '\n':
	    c = 'n';
	    break;
	    
	  case CHAR_CR:
	    c = 'r';
	    break;
	    
	  case '\t':
	    c = 't';
	    break;
	    
	  case CHAR_VT:
	    c = 'v';
	    break;
	    
	  default:
	    if (c < ' ' || c >= 127)
	      fprintf( asmstream, "\\%o", (int)c );
	    else
	      putc( c, asmstream );
	    continue;
	  }
	
	putc( '\\', asmstream );
	putc( c,    asmstream );
      }
    
    fputc( '\'', asmstream );
    
    return;
    
  } /* pr_chars */
d152 5
a156 5
  pr_asmname(
	     Symstr *	sym,
	     FILE *	stream )
  {
    char *	s = sym == 0 ? (asm_error = 1, "?") : symname_( sym );
d158 2
a159 1
    return fprintf( stream, "%s", s );
d161 1
a161 1
  } /* pr_asmname */
d170 30
a199 30
  decode_external( int32 p ) /* p is now a byte address */
  {
    CodeXref *	x;
    
    
    for (x = codexrefs; x != NULL; x = x->codexrcdr)    /* SLOW loop !!! */
      {
	if (p == (x->codexroff & 0x00ffffffL))
	  {
	    switch (x->codexroff & (unsigned long)0xff000000L)
	      {
	      default:
		xroffset = 0;
		break;
		
	      case X_DataAddr:
	      case X_DataAddr1:
	      case X_absreloc:
		xroffset = x->codexrlitoff;
	      }
	    
	    return x->codexrsym;
	  }
      }
    
    /* syserr( syserr_decode_external );     *//* may exploit zero return one day */
    
    return 0;	/* not an external reference */
    
  } /* decode_external */
d203 35
a237 35
  printlabelname(
		 int32	offset,
		 bool	flag_errs )
  {
    LabList *	p;
    
    
    /*
     * For data references, ignore the function name: it will be wrong for backward
     * references to the literal pool of another function.  (Labels which are the
     * subject of data references have already been removed from asm_lablist).
     * For code references, generate a label of the form L<label>F<proc>.
     * Such label names seem a bit long and ugly.
     */
    
    for (p = asm_lablist ; p != NULL ; p = p->labcdr)
      {
	LabelNumber *	lab = p->labcar;
	
	
	if ((lab->u.defn & 0x00ffffffL) == offset)
	  {
	    (void) fprintf( asmstream, "L%ldF%ld", (long)(lab_name_( lab ) & 0x7fffffffL), (long)fncount );
	    
	    return;
	  }
      }
    
    if (flag_errs)
      (void) fprintf( asmstream, "<unknown destination> offset + base = %ld, current pos = %ld, offset = %ld",
		     (offset + codebase) / sizeof_int, current_pos / sizeof_int, offset / sizeof_int);
    
    return;
    
  } /* printlabelname */
a239 2
static void
  decode_addr( int32 addr )
d244 54
a297 51
  {   
    Symstr *	name = decode_external( codebase + current_pos );
    
    
    /* First, is it an external name ? */
    
    if (name == bindsym_( codesegment ))
      {
	LabList *	p;
	
	
	/*
	 * although we have found it in codexrefs, we may still be able to
	 * produce a local label name for it
	 */
	
	for (p = asm_lablist ; p != NULL ; p = p->labcdr)
	  {
	    LabelNumber *	lab = p->labcar;
	    
	    
	    
	    if ((codebase + (lab->u.defn & 0x00ffffff)) / sizeof_int + addr  == xroffset)
	      {
		if (addr != 0)
		  fprintf( asmstream, "+0x%lx", addr );
		
		return;
	      }
	  }
      }
    
    if (name != 0)
      {
	fputc( '_', asmstream );
	
	pr_asmname( name, asmstream );
	
	if (xroffset != 0)
	  fprintf( asmstream, " + 0x%lx", xroffset );
	
	return;
      }
    
    /* Otherwise, assume it is a local label */
    
    printlabelname( codebase + current_pos + addr * sizeof_int, TRUE );	/* not right ??? */
    
    return;
    
  } /* decode_addr */
d325 40
a364 40
  decode_indirect_address(
			  int32	mode,
			  int32	addr,
			  int32	disp )
  {
    switch (mode)
      {
      case B_00000:	fprintf( asmstream, "*+AR%ld(%ld)",         addr, disp ); break;
      case B_00001:	fprintf( asmstream, "*-AR%ld(%ld)",         addr, disp ); break;
      case B_00010:	fprintf( asmstream, "*++AR%ld(%ld)",        addr, disp ); break;
      case B_00011:	fprintf( asmstream, "*--AR%ld(%ld)",        addr, disp ); break;
      case B_00100:	fprintf( asmstream, "*AR%ld++(%ld)",        addr, disp ); break;
      case B_00101:	fprintf( asmstream, "*AR%ld--(%ld)",        addr, disp ); break;
      case B_00110:	fprintf( asmstream, "*AR%ld++(%ld)%%",      addr, disp ); break;
      case B_00111:	fprintf( asmstream, "*AR%ld--(%ld)%%",      addr, disp ); break;
      case B_01000:	fprintf( asmstream, "*+AR%ld(IR0)",         addr       ); break;
      case B_01001:	fprintf( asmstream, "*-AR%ld(IR0)",         addr       ); break;
      case B_01010:	fprintf( asmstream, "*++AR%ld(IR0)",        addr       ); break;
      case B_01011:	fprintf( asmstream, "*--AR%ld(IR0)",        addr       ); break;
      case B_01100:	fprintf( asmstream, "*AR%ld++(IR0)",        addr       ); break;
      case B_01101:	fprintf( asmstream, "*AR%ld--(IR0)",        addr       ); break;
      case B_01110:	fprintf( asmstream, "*AR%ld++(IR0)%%",      addr       ); break;
      case B_01111:	fprintf( asmstream, "*AR%ld--(IR0)%%",      addr       ); break;
      case B_10000:	fprintf( asmstream, "*+AR%ld(IR1)",         addr       ); break;
      case B_10001:	fprintf( asmstream, "*-AR%ld(IR1)",         addr       ); break;
      case B_10010:	fprintf( asmstream, "*++AR%ld(IR1)",        addr       ); break;
      case B_10011:	fprintf( asmstream, "*--AR%ld(IR1)",        addr       ); break;
      case B_10100:	fprintf( asmstream, "*AR%ld++(IR1)",        addr       ); break;
      case B_10101:	fprintf( asmstream, "*AR%ld--(IR1)",        addr       ); break;
      case B_10110:	fprintf( asmstream, "*AR%ld++(IR1)%%",      addr       ); break;
      case B_10111:	fprintf( asmstream, "*AR%ld--(IR1)%%",      addr       ); break;
      case B_11000:	fprintf( asmstream, "*AR%ld",               addr       ); break;
      case B_11001:	fprintf( asmstream, "*AR%ld++(IR0)B",       addr       ); break;
      default:
	syserr( "disassembler: unknown indirect addressing mode %x", mode );
      }
    
    return;
    
  } /* decode_indirect_addressing */
d375 14
a388 14
  mask_and_sign_extend_word(
			    unsigned long	value,
			    unsigned long	mask )
  {
    value &= mask;
    
    if (value & ((mask + 1) >> 1))
      {
	value |= ~mask;
      }
    
    return (signed long)value;
    
  } /* mask_and_sign_extend_word */
d398 55
a452 55
  decode_short_float( int32 number )
  {
    static char	buffer[ 20 ];
    int32		e;
    int32		s;
    int32		f;
    union
      {
	float		f;	/* XXX beware of assumption that 	*/
	unsigned long	l;	/* sizeof (float) == sizeof (long)	*/
      }
    converter;
    
    
    if (number & 0xffff0000U)
      {
	return "bad format short float";
      }
    
    /*
     * format is ...
     *
     *
     *  15      12   11   10       0
     *  ____________________________
     * |          |      |          |
     * | exponent | sign | mantissa |
     * |          |      |          |
     *  ----------------------------
     *
     * interpretation is ...
     *
     * e = -8, s = 0, m = 0 => 0.0
     * s = 0                =>   01.m  x 2^e
     * s = -1               => -(10.m) x 2^e
     *
     */
    
    /* extract components */
    
    e = (number & 0xf000U) >> 12;
    s =  number & 0x0800U;
    f =  number & 0x07ffU;
    
    e = mask_and_sign_extend_word( e, 0xf );
    
    /* handle the special case */
    
    if (s == 0 && e == -8 && f == 0)
      {
	return "0.0";
      }
    
    /* convert the binary value into host specific floating point value */
    
d454 5
a458 5
    
    /* convert to C40 single precision */
    
    converter.l = (e << 24) | (s << (23 - 11)) | (f << (22 - 10));
    
d460 20
a479 20
    
    /* convert to IEEE single precision */
    
    e += 0x7f;
    
    if (s == 0)
      {
	converter.l = (e << 23) | (f << (22 - 10));
      }
    else
      {
	if (f == 0)
	  {
	    converter.l = ((e + 1) << 23) | (1 << 31);
	  }
	else
	  {
	    converter.l = (e << 23) | (((((~f) + 1) << (22 - 10))) & ((1 << 23) - 1)) | (1 << 31);
	  }
      }
d481 10
a490 10
    
    /* convert to a string */
    
    sprintf( buffer, "%f", converter.f );
    
    /* return the string */
    
    return buffer;
    
  } /* decode_short_float */
d499 185
a683 185
  decode_diadic_address(
			int32		op_code,	/* instruction */
			char *		instruction,	/* string identifying instruction */
			immed_type	type,		/* type of immediate values */
			int32		store )		/* non zero if a store operation */
  {
    char *	pdest;
    int32		dest;
    int32		src;
    
    
    /*
     * we have a diaidic op code
     *
     * bits 16 - 20 encode destination
     * bits 21 - 22 encode addressing type
     * bits 23 - 28 encode op code
     * bits 29 - 31 are 000
     */
    
    if ((op_code >> 23) == OP_RPTS || (op_code >> 23) == OP_IACK)
      {
	/* this op code has no destination */
	
	pdest = NULL;
      }
    else
      {
	dest = (op_code >> 16) & 0x1f;
	
	if (type == TYPE_FLOATING && (op_code >> 23) != OP_FIX)
	  {
	    /* the destination (or source) register of a floating point op must be R0 - R11 */
	    
	    if (!is_extended_precision_register( dest ))
	      {
		syserr( "disassembler: destination of FP op (%s) is not an FP register (%s)",
		       instruction, _regname( dest ) );
	      }
	  }
	
	pdest = _regname( dest );
      }
    
    fprintf( asmstream, "%s\t", instruction );
    
    switch ((op_code >> 21) & 0x3)
      {
      case 0: /* register to register */
	/*
	 * we have a diaidic op code, using register addressing
	 *
	 * bits  0 - 4  encode source register
	 * bits  5 - 15 are 00000000000
	 * bits 16 - 20 encode destination register
	 * bits 21 - 22 encode addressing type
	 * bits 23 - 28 encode op code
	 * bits 29 - 31 are 000
	 */
	
	if (op_code & 0xffe0)
	  {
	    syserr( "disassembler: bad value in source field of register addressed op %s (%x)",
		   instruction, op_code );
	  }
	
	src = op_code & 0x1f;
	
	if (type == TYPE_FLOATING)
	  {
	    /* the source register of a floating point op must be R0 - R11 */
	    
	    if (!is_extended_precision_register( src ))
	      {
		syserr( "disassembler: non FP source register %s for op %s (%x)",
		       _regname( src ), instruction, op_code );
	      }
	  }
	
	fprintf( asmstream, "%s", _regname( src ) );
	
	if (pdest && dest != src)
	  fprintf( asmstream, ", %s", pdest );
	
	break;
	
      case 1: /* direct */
	/*
	 * we have a diaidic op code, using direct addressing
	 *
	 * bits  0 - 15 are an unsigned offset to the data page register
	 * bits 16 - 20 encode destination register
	 * bits 21 - 22 encode addressing type
	 * bits 23 - 28 encode op code
	 * bits 29 - 31 are 000
	 */
	
	if (store)	/* pdest is actually source */
	  fprintf( asmstream, "%s, @@%#04.4lx", pdest, (op_code & 0xffff) );
	else if (pdest)
	  fprintf( asmstream, "@@%#04.4lx, %s", (op_code & 0xffff), pdest );
	else
	  fprintf( asmstream, "@@%#04.4lx", (op_code & 0xffff) );
	
	break;
	
      case 2: /* indirect */
	/*
	 * we have a diaidic op code, using indirect addressing
	 *
	 * bits  0 -  7 encode the displacment
	 * bits  8 - 10 encode the address register
	 * bits 11 - 15 encode the mode
	 * bits 16 - 20 encode destination register
	 * bits 21 - 22 encode addressing type
	 * bits 23 - 28 encode op code
	 * bits 29 - 31 are 000
	 */
	
	  {
	    int32		disp = op_code & 0xff;
	    int32		addr = (op_code >> 8) & 0x7;
	    
	    
	    if (store)
	      {
		fprintf( asmstream, "%s, ", pdest );
		
		decode_indirect_address( op_code >> 11 & 0x1f, addr, disp );
	      }
	    else
	      {
		decode_indirect_address( (op_code >> 11) & 0x1f, addr, disp );
		
		if (pdest)
		  fprintf( asmstream, ", %s", pdest );
	      }
	  }
	break;
	
      case 3: /* immediate */
	/*
	 * we have a diaidic op code, using immeadiate addressing
	 *
	 * bits  0 - 15 are a signed immeadiate value
	 * bits 16 - 20 encode destination register
	 * bits 21 - 22 encode addressing type
	 * bits 23 - 28 encode op code
	 * bits 29 - 31 are 000
	 */
	
	if (type == TYPE_SIGNED)
	  dest = mask_and_sign_extend_word( op_code, 0x0000ffffU );
	else
	  dest = op_code & 0xffffU;
	
	if (type == TYPE_FLOATING)
	  {
	    fprintf( asmstream, "%s, %s", decode_short_float( dest ), pdest );
	  }
	else if (sym_reladdr != NULL)
	  {
	    fprintf( asmstream, ".%s, %s\t%c value = %+ld,",
		    symname_( sym_reladdr ), pdest, ASM_COMMENT_CHAR, dest );
	  }
	else if (dest < 500 && dest > -500 && type == TYPE_SIGNED)
	  {
	    fprintf( asmstream, "%-3ld, %s", dest, pdest );
	  }
	else if (pdest)
	  {
	    fprintf( asmstream, "%#-3lx, %s", dest, pdest );
	  }
	else
	  {
	    fprintf( asmstream, "%#-3lx", dest );
	  }
	
	break;
	
      }
    
    return;
    
  } /* decode_diadic_address */
d691 76
a766 76
  decode_integer_store( int32 op_code )
  {
    int32		dest;
    
    
    /*
     * we have an integer store
     *
     * bits  0 - 15 encode destination
     * bits 16 - 20 encode source
     * bits 21 - 22 encode addressing type
     * bits 23 - 31 are 000101010
     */
    
    dest = (op_code >> 16) & 0x1f;
    
    switch ((op_code >> 21) & 0x3)
      {
      case 0: /* indirect immediate */
	/*
	 * bits  0 - 15 are an unsigned offset from the data page register
	 * bits 16 - 20 encode value
	 * bits 21 - 31 are 00010101000
	 */
	
	fprintf( asmstream, "STIK\t%-3ld, @@%#04.4lx",
		mask_and_sign_extend_word( dest, 0x1f ), (op_code & 0xffff) );
	
	break;
	
      case 1: /* direct register */
	/*
	 * bits  0 - 15 are an unsigned offset to the data page register
	 * bits 16 - 20 encode source register
	 * bits 21 - 31 are 00010101001
	 */
	
	fprintf( asmstream, "STI\t%s, @@%#04.4lx", _regname( dest ), (op_code & 0xffff) );
	
	break;
	
      case 2: /* indirect register */
	/*
	 * bits  0 -  7 encode the displacment
	 * bits  8 - 10 encode the address register
	 * bits 11 - 15 encode the mode
	 * bits 16 - 20 encode source register
	 * bits 21 - 31 are 00010101010
	 */
	
	fprintf( asmstream, "STI\t%s, ", _regname( dest ) );
	
	decode_indirect_address( (op_code >> 11) & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );
	
	break;
	
      case 3: /* indirect immediate */
	/*
	 * bits  0 -  7 encode the displacment
	 * bits  8 - 10 encode the address register
	 * bits 11 - 15 encode the mode
	 * bits 16 - 20 encode source value
	 * bits 21 - 31 are 00010101011
	 */
	
	fprintf( asmstream, "STIK\t%-3ld, ", mask_and_sign_extend_word( dest, 0x1f ) );
	
	decode_indirect_address( (op_code >> 11) & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );
	
	break;
	
      }
    
    return;
    
  } /* decode_integer_store */
d774 381
a1154 381
  decode_flow_control(
		      int32	op_code, 	/* instruction				*/
		      bool	flag_errs )	/* TRUE if errors should be reported	*/
  {
    /*
     * we have a flow control op code
     *
     * bits 30 - 31 are 01
     *
     * other bits are semi-random
     */
    
    if (op_code & (1 << 29))
      {
	/* bits 29 - 31 are 011 */
	
	if (op_code & (1 << 28))
	  {
	    /* bits 28 - 31 are 0111 */
	    
	    if (op_code & (1 << 27))
	      {
		/* bits 27 - 31 are 01111 */
		
		if (op_code & (1 << 24))
		  {
		    /*
		     * we have a repeat block with register addressing
		     *
		     * bits  0 -  4 encode the source
		     * bits  5 - 22 are 000000000000000000
		     * bit  23      encodes the delay
		     * bits 24 - 31 are 01111001
		     */
		    
		    if (op_code & (1 << 23))
		      {
			fprintf( asmstream, "RPTBD\t%s", _regname( op_code ) );
		      }
		    else
		      {
			fprintf( asmstream, "RPTB\t%s", _regname( op_code ) );
		      }
		  }
		else
		  {
		    /* bits 24 - 31 are 01111xx0 */
		    
		    if (op_code & (1 << 23))
		      {
			/*
			 * we have a conditional return from subroutine
			 *
			 * bits  0 - 15 are 0000000000000000
			 * bits 16 - 20 encode the condition 
			 * bits 21 - 31 are 01111000100
			 */
			
			fprintf( asmstream, "RETS%s", _condname( op_code >> 16 ) );
		      }
		    else
		      {
			/*
			 * we have a conditional return from interrupt
			 *
			 * bits  0 - 15 are 0000000000000000
			 * bits 16 - 20 encode the condition
			 * bit  21      encodes the delay type
			 * bits 22 - 31 are 0111100000
			 */
			
			if (op_code & (1 << 21))
			  {
			    fprintf( asmstream, "RETI%sD", _condname( op_code >> 16 ) );
			  }
			else
			  {
			    fprintf( asmstream, "RETI%s", _condname( op_code >> 16 ) );
			  }
		      }
		  }
	      }
	    else
	      {
		/* bits 27 - 31 are 01110 */
		
		if (op_code & (1 << 26))
		  {
		    /* bits 26 - 31 are 011101 */
		    
		    if (op_code & (1 << 25))
		      {
			/*
			 * we have a transfer between register file and expansion register file
			 *
			 * bits  0 -  5 encode the source register
			 * bits  6 - 15 are 0000000000
			 * bits 16 - 20 encode the destination register
			 * bits 21 - 22 are 00
			 * bit  23      encodes the transfer type
			 * bits 24 - 31 are 01110110
			 */
			
			if (op_code & (1 << 23))
			  {
			    fprintf( asmstream, "LDPE\t%s, %s",
				    _regname( op_code ),
				    flag_errs ? "<xxx unknown expansion register xxx>" : "" );
			  }
			else
			  {
			    fprintf( asmstream, "LDEP\t%s, %s",
				    flag_errs ? "<xxx unknown expansion register xxx>" : "",
				    _regname( op_code >> 16 ) );
			  }
		      }
		    else
		      {
			char	op[ 10 ];
			
			
			/*
			 * we have a conditional trap
			 *
			 * bits  0 -  8 encode the trap number
			 * bits  9 - 15 are 0000000
			 * bits 16 - 20 encode the condition
			 * bits 21 - 22 are 00
			 * bit  23      encodes the trap type
			 * bits 24 - 31 are 01110100
			 */
			
			if (op_code & (1 << 23))
			  {
			    strcpy( op, "LAT" );
			  }
			else
			  {
			    strcpy( op, "TRAP" );
			  }
			
			strcat( op, _condname( (op_code >> 16) & 0x1f ) );
			
			fprintf( asmstream, "%s\t%lu", op, op_code & 0x1ff );
		      }
		  }
		else
		  {
		    char	op[ 10 ];
		    
		    
		    /*
		     * we have a conditional jump to subroutine
		     *
		     * bits  0 - 15 encode the source register or displacement
		     * bits 16 - 20 encode the condition
		     * bits 21      encodes the jump type
		     * bits 22 - 24 are 000
		     * bit  25      encodes the addressing mode
		     * bits 26 - 31 are 011100
		     */
		    
		    if (op_code & (1 << 21))
		      {
			strcpy( op, "LAJ" );
		      }
		    else
		      {
			strcpy( op, "CALL" );
		      }
		    
		    strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		    
		    if (op_code & (1 << 25))
		      {
			op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
			
			fprintf( asmstream, "%s\t%+ld", op, op_code );
		      }
		    else
		      {
			fprintf( asmstream, "%s\t%s", op, _regname( op_code & 0x1f ) );
		      }
		  }
	      }
	  }
	else
	  {
	    /* bits 28 - 31 are 0110 */
	    
	    if (op_code & (1 << 27))
	      {
		/* bits 27 - 31 are 01101 */
		
		if (op_code & (1 << 26))
		  {
		    char	op[ 10 ];
		    int32	addr;
		    int	offset;
		    
		    
		    /*
		     * we have a conditional decrement and branch
		     *
		     * bits  0 - 15 encode the source register or displacement
		     * bits 16 - 20 encode the condition
		     * bits 21      encodes delay
		     * bits 22 - 24 encodes the address register to be decremented
		     * bit  25      encodes the addressing mode
		     * bits 26 - 31 are 011011
		     */
		    
		    strcpy( op, "DB" );
		    
		    strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		    
		    if (op_code & (1 << 21))
		      {
			strcat( op, "D" );
			
			offset = 4;
		      }
		    else
		      {
			offset = 1;
		      }
		    
		    addr = (op_code >> 22) & 0x7;
		    
		    if (op_code & (1 << 25))
		      {
			op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
			
			fprintf( asmstream, "%s\tAR%1ld, ", op, addr );
			
			printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );
			
			/* fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
		      }
		    else
		      {
			fprintf( asmstream, "%s\tAR%1ld, %s", op, addr, _regname( op_code & 0x1f ) );
		      }
		  }
		else
		  {
		    char	op[ 10 ];
		    int	offset;
		    
		    
		    /*
		     * we have a conditional branch
		     *
		     * bits  0 - 15 encode the source register or displacement
		     * bits 16 - 20 encode the condition
		     * bits 21 - 23 encode the type of branch
		     * bits 24      is 0
		     * bit  25      encodes the addressing mode
		     * bits 26 - 31 are 011010
		     */
		    
		    strcpy( op, "B" );
		    
		    strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		    
		    switch ((op_code >> 21) & 0x7)
		      {
		      case B_000:	                    offset = 1; break;
		      case B_001:	strcat( op, "D"  ); offset = 3; break;
		      case B_010:	syserr( syserr_unknown_op_code, op_code ); return;
		      case B_011:	strcat( op, "AT" ); offset = 3; break;
		      case B_100:	syserr( syserr_unknown_op_code, op_code ); return;
		      case B_101:	strcat( op, "AF" ); offset = 3; break;
		      case B_110:	syserr( syserr_unknown_op_code, op_code ); return;
		      case B_111:	syserr( syserr_unknown_op_code, op_code ); return;
		      }
		    
		    if (op_code & (1 << 25))
		      {
			op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
			
			fprintf( asmstream, "%s\t", op );
			
			printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );
			
			/* fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
		      }
		    else
		      {
			fprintf( asmstream, "%s\t%s", op, _regname( op_code & 0x1f ) );
		      }
		  }
	      }
	    else
	      {
		int	offset;
		
		
		/* bits 27 - 31 are 01100 */
		
		switch ((op_code >> 24) & 0x7)
		  {
		  case B_000:	fprintf( asmstream, "BR\t"    ); offset = -2; break;
		  case B_001:	fprintf( asmstream, "BRD\t"   ); offset = -4; break;
		  case B_010:	fprintf( asmstream, "CALL\t"  ); offset = -2; break;
		  case B_011:	fprintf( asmstream, "LAJ\t"   ); offset = -4; break;
		  case B_100:	fprintf( asmstream, "RPTB\t"  ); offset = 0;  break;
		  case B_101:	fprintf( asmstream, "RPTBD\t" ); offset = 3;  break;
		  case B_110:	fprintf( asmstream, "SWI\t"   ); return;
		  default:
		  case B_111:	syserr( syserr_unknown_op_code, op_code ); return;					
		  }
		
		op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffffL );
		
		if (op_code == 1 && offset == -4)
		  {
		    /*
		     * A 'LAJ' with an offset of 1 is a special case.
		     * What it is doing is putting the PC into R11 so
		     * that the next few instructions can be PC relative
		     * (This is the only way to access the value of the PC
		     * on the 'C40).  See the code for load_address_constant()
		     * in c40/gen.c
		     */
		    
		    fprintf( asmstream, "4\t%c <fetching PC>", ASM_COMMENT_CHAR );
		  }
		else if (offset < 0)
		  {
		    if (sym_reladdr != NULL)
		      {
			/*
			 * this instruction will have been issued as a
			 * LIT_RELADDR and so the function name will be
			 * deocded later
			 */
		      }
		    else
		      {
			printlabelname( current_pos + (op_code - offset - 1) * sizeof_int, flag_errs );
			
			/* fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
		      }
		  }
		else
		  {
		    printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );
		    
		    /* fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
		  }
	      }
	  }
      }
    else
      {
	char 		op[ 10 ];
	immed_type	type;
	
	
	/*
	 * we have a conditional load op
	 *
	 * bits  0 - 15 encode the source
	 * bits 16 - 20 encode the destination
	 * bits 21 - 22 encode the addressing mode
	 * bits 23 - 27 encode the condition
	 * bit  28      encodes op
	 * bits 29 - 31 are 010
	 */
	
	if (((op_code >> 28) & 0x1) == 0)
	  {
	    strcpy( op, "LDF" );
	    
	    type = TYPE_FLOATING;
	  }
	else
	  {
	    strcpy( op, "LDI" );

d1159 1
a1159 1

d1164 1
a1164 1

d1166 1
a1166 1

d1853 1
a1853 1
		  int32	op_code,
@


1.54
log
@improved STIK decoding
@
text
@d2199 2
a2200 2
		  fprintf( asmstream, "patchinstr( " );
		  fprintf( asmstream, "PATCHC40DATAMODULE1, shift( -2, DATAMODULE ( _%s ) ),\n",
d2205 2
a2206 2
		  fprintf( asmstream, "patchinstr( " );
		  fprintf( asmstream, "PATCHC40DATAMODULE2, shift ( -2, CODESYMB ( _%s ) ),\n",
d2211 2
a2212 2
		  fprintf( asmstream, "patchinstr( " );
		  fprintf( asmstream, "PATCHC40DATAMODULE3, MODNUM,\n" );
d2216 2
a2217 2
		  fprintf( asmstream, "patchinstr( " );
		  fprintf( asmstream, "PATCHC40DATAMODULE4, MODNUM,\n" );
d2221 2
a2222 2
		  fprintf( asmstream, "patchinstr( " );
		  fprintf( asmstream, "PATCHC40DATAMODULE5, MODNUM,\n" );
d2256 2
a2257 2
		  fprintf( asmstream, "patchinstr( " );
		  fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -18, add ( -12, LABELREF ( .%s ) ) ),\n",
d2262 2
a2263 2
		  fprintf( asmstream, "patchinstr( " );
		  fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -16, shift ( 14, LABELREF ( .%s ) ) ),\n",
d2268 3
a2270 3
		  fprintf( asmstream, "patchinstr( " );
		  
		  fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _%s ) ),\n",
d2277 1
a2277 3
			  large_model ?
			  "PATCHC40MASK16ADD" :
			  "PATCHC40MASK8ADD" );
d2294 2
a2295 1
		  fprintf( asmstream, "patchinstr( MODNUM\n" );
@


1.53
log
@improved format of output
@
text
@d772 1
a772 1
	fprintf( asmstream, "STIK\t%3ld, ", mask_and_sign_extend_word( dest, 0x1f ) );
@


1.52
log
@minor cosmetic changes
@
text
@d10 1
a10 1
            display_assembly_code, asm_header, asm_trailer */
d51 1
a51 1
  }
d77 8
a84 8
asm_blank( int32 n )
{
  while (n-- > 0)
    fprintf( asmstream, "%c\n", ASM_COMMENT_CHAR );

  return;

} /* asm_blank */
d88 11
a98 11
asm_padcol8( int32 n )
{
  if (!annotations)
    n = 7;      /* compact the asm file */
  
  while (n < 8)
    fputc( ' ', asmstream ), n++;
  
  return n;

} /* asm_padcol8 */
d102 60
a161 42
pr_chars( int32 w )   /* works on both sex machines */
{
  int	i, c;
  
  fputc( '\'', asmstream );
  
  for (i = 0; i < sizeof( int32 ); i++)
    {
      switch (c = ((unsigned char *)&w)[ i ])
	{
	case '\\':
	case '\'':
	case '\"':
	  break;

	case '\a':
	  c = 'a';
	  break;

	case '\b':
	  c = 'b';
	  break;

	case CHAR_FF:
	  c = 'f';
	  break;

	case '\n':
	  c = 'n';
	  break;

	case CHAR_CR:
	  c = 'r';
	  break;

	case '\t':
	  c = 't';
	  break;

	case CHAR_VT:
	  c = 'v';
	  break;
a162 17
	default:
	  if (c < ' ' || c >= 127)
	    fprintf( asmstream, "\\%o", (int)c );
	  else
	    putc( c, asmstream );
	  continue;
	}
      
      putc( '\\', asmstream );
      putc( c,    asmstream );
    }
  
  fputc( '\'', asmstream );

  return;

} /* pr_chars */
a163 1

d170 9
a178 9
pr_asmname(
	   Symstr *	sym,
	   FILE *	stream )
{
  char *	s = sym == 0 ? (asm_error = 1, "?") : symname_( sym );
  
  return fprintf( stream, "%s", s );

} /* pr_asmname */
d187 30
a216 30
decode_external( int32 p ) /* p is now a byte address */
{
  CodeXref *	x;

  
  for (x = codexrefs; x != NULL; x = x->codexrcdr)    /* SLOW loop !!! */
    {
      if (p == (x->codexroff & 0x00ffffffL))
	{
	  switch (x->codexroff & (unsigned long)0xff000000L)
	    {
	    default:
	      xroffset = 0;
	      break;
	  
	    case X_DataAddr:
	    case X_DataAddr1:
	    case X_absreloc:
	      xroffset = x->codexrlitoff;
	    }

	  return x->codexrsym;
	}
    }

  /* syserr( syserr_decode_external );     *//* may exploit zero return one day */

  return 0;	/* not an external reference */

} /* decode_external */
d220 35
a254 31
printlabelname(
	       int32	offset,
	       bool	flag_errs )
{
  LabList *	p;


  /*
   * For data references, ignore the function name: it will be wrong for backward
   * references to the literal pool of another function.  (Labels which are the
   * subject of data references have already been removed from asm_lablist).
   * For code references, generate a label of the form L<label>F<proc>.
   * Such label names seem a bit long and ugly.
   */
  
  for (p = asm_lablist ; p != NULL ; p = p->labcdr)
    {
      LabelNumber *	lab = p->labcar;


      if ((lab->u.defn & 0x00ffffffL) == offset)
	{
	  (void) fprintf( asmstream, "L%ldF%ld", (long)(lab_name_( lab ) & 0x7fffffffL), (long)fncount );

	  return;
	}
    }

  if (flag_errs)
    (void) fprintf( asmstream, "<unknown destination> offset + base = %ld, current pos = %ld, offset = %ld",
		   (offset + codebase) / sizeof_int, current_pos / sizeof_int, offset / sizeof_int);
a255 3
  return;
  
} /* printlabelname */
a256 1

d258 1
a258 1
decode_addr( int32 addr )
d263 51
a313 19
{   
  Symstr *	name = decode_external( codebase + current_pos );


  /* First, is it an external name ? */

  if (name == bindsym_( codesegment ))
    {
      LabList *	p;


      /*
       * although we have found it in codexrefs, we may still be able to
       * produce a local label name for it
       */

      for (p = asm_lablist ; p != NULL ; p = p->labcdr)
	{
	  LabelNumber *	lab = p->labcar;
a315 32
		  
	  if ((codebase + (lab->u.defn & 0x00ffffff)) / sizeof_int + addr  == xroffset)
	    {
	      if (addr != 0)
		fprintf( asmstream, "+0x%lx", addr );
	      
	      return;
	    }
	}
    }

  if (name != 0)
    {
      fputc( '_', asmstream );
      
      pr_asmname( name, asmstream );
      
      if (xroffset != 0)
	fprintf( asmstream, " + 0x%lx", xroffset );

      return;
    }
  
  /* Otherwise, assume it is a local label */

  printlabelname( codebase + current_pos + addr * sizeof_int, TRUE );	/* not right ??? */

  return;
  
} /* decode_addr */


d319 1
a319 1
  "R0\0\0R1\0\0R2\0\0R3\0\0R4\0\0R5\0\0R6\0\0R7\0\0"
d321 2
a322 2
  "DP\0\0IR0\0IR1\0BK\0\0SP\0\0ST\0\0DIE\0IIE\0"
  "IIF\0RS\0\0RE\0\0RC\0\0R8\0\0R9\0\0R10\0R11\0";
d325 1
a325 1
		       
d332 1
a332 1
  
d341 40
a380 40
decode_indirect_address(
			int32	mode,
			int32	addr,
			int32	disp )
{
  switch (mode)
    {
    case B_00000:	fprintf( asmstream, "*+AR%ld(%ld)",         addr, disp ); break;
    case B_00001:	fprintf( asmstream, "*-AR%ld(%ld)",         addr, disp ); break;
    case B_00010:	fprintf( asmstream, "*++AR%ld(%ld)",        addr, disp ); break;
    case B_00011:	fprintf( asmstream, "*--AR%ld(%ld)",        addr, disp ); break;
    case B_00100:	fprintf( asmstream, "*AR%ld++(%ld)",        addr, disp ); break;
    case B_00101:	fprintf( asmstream, "*AR%ld--(%ld)",        addr, disp ); break;
    case B_00110:	fprintf( asmstream, "*AR%ld++(%ld)%%",      addr, disp ); break;
    case B_00111:	fprintf( asmstream, "*AR%ld--(%ld)%%",      addr, disp ); break;
    case B_01000:	fprintf( asmstream, "*+AR%ld(IR0)",         addr       ); break;
    case B_01001:	fprintf( asmstream, "*-AR%ld(IR0)",         addr       ); break;
    case B_01010:	fprintf( asmstream, "*++AR%ld(IR0)",        addr       ); break;
    case B_01011:	fprintf( asmstream, "*--AR%ld(IR0)",        addr       ); break;
    case B_01100:	fprintf( asmstream, "*AR%ld++(IR0)",        addr       ); break;
    case B_01101:	fprintf( asmstream, "*AR%ld--(IR0)",        addr       ); break;
    case B_01110:	fprintf( asmstream, "*AR%ld++(IR0)%%",      addr       ); break;
    case B_01111:	fprintf( asmstream, "*AR%ld--(IR0)%%",      addr       ); break;
    case B_10000:	fprintf( asmstream, "*+AR%ld(IR1)",         addr       ); break;
    case B_10001:	fprintf( asmstream, "*-AR%ld(IR1)",         addr       ); break;
    case B_10010:	fprintf( asmstream, "*++AR%ld(IR1)",        addr       ); break;
    case B_10011:	fprintf( asmstream, "*--AR%ld(IR1)",        addr       ); break;
    case B_10100:	fprintf( asmstream, "*AR%ld++(IR1)",        addr       ); break;
    case B_10101:	fprintf( asmstream, "*AR%ld--(IR1)",        addr       ); break;
    case B_10110:	fprintf( asmstream, "*AR%ld++(IR1)%%",      addr       ); break;
    case B_10111:	fprintf( asmstream, "*AR%ld--(IR1)%%",      addr       ); break;
    case B_11000:	fprintf( asmstream, "*AR%ld",               addr       ); break;
    case B_11001:	fprintf( asmstream, "*AR%ld++(IR0)B",       addr       ); break;
    default:
      syserr( "disassembler: unknown indirect addressing mode %x", mode );
    }
  
  return;
  
} /* decode_indirect_addressing */
d391 14
a404 14
mask_and_sign_extend_word(
			  unsigned long	value,
			  unsigned long	mask )
{
  value &= mask;

  if (value & ((mask + 1) >> 1))
    {
      value |= ~mask;
    }

  return (signed long)value;
  
} /* mask_and_sign_extend_word */
d414 55
a468 55
decode_short_float( int32 number )
{
  static char	buffer[ 20 ];
  int32		e;
  int32		s;
  int32		f;
  union
    {
      float		f;	/* XXX beware of assumption that 	*/
      unsigned long	l;	/* sizeof (float) == sizeof (long)	*/
    }
  converter;
  
  
  if (number & 0xffff0000U)
    {
      return "bad format short float";
    }

  /*
   * format is ...
   *
   *
   *  15      12   11   10       0
   *  ____________________________
   * |          |      |          |
   * | exponent | sign | mantissa |
   * |          |      |          |
   *  ----------------------------
   *
   * interpretation is ...
   *
   * e = -8, s = 0, m = 0 => 0.0
   * s = 0                =>   01.m  x 2^e
   * s = -1               => -(10.m) x 2^e
   *
   */

  /* extract components */
  
  e = (number & 0xf000U) >> 12;
  s =  number & 0x0800U;
  f =  number & 0x07ffU;

  e = mask_and_sign_extend_word( e, 0xf );
  
  /* handle the special case */
  
  if (s == 0 && e == -8 && f == 0)
    {
      return "0.0";
    }

  /* convert the binary value into host specific floating point value */
  
d470 5
a474 5

  /* convert to C40 single precision */
  
  converter.l = (e << 24) | (s << (23 - 11)) | (f << (22 - 10));
  
d476 20
a495 20

  /* convert to IEEE single precision */
  
  e += 0x7f;
  
  if (s == 0)
    {
      converter.l = (e << 23) | (f << (22 - 10));
    }
  else
    {
      if (f == 0)
	{
	  converter.l = ((e + 1) << 23) | (1 << 31);
	}
      else
	{
	  converter.l = (e << 23) | (((((~f) + 1) << (22 - 10))) & ((1 << 23) - 1)) | (1 << 31);
	}
    }
d497 10
a506 10

  /* convert to a string */
  
  sprintf( buffer, "%f", converter.f );

  /* return the string */
  
  return buffer;

} /* decode_short_float */
d515 79
a593 82
decode_diadic_address(
		      int32		op_code,	/* instruction */
		      char *		instruction,	/* string identifying instruction */
		      immed_type	type,		/* type of immediate values */
		      int32		store )		/* non zero if a store operation */
{
  char *	pdest;
  int32		dest;
  int32		src;
  
  
  /*
   * we have a diaidic op code
   *
   * bits 16 - 20 encode destination
   * bits 21 - 22 encode addressing type
   * bits 23 - 28 encode op code
   * bits 29 - 31 are 000
   */

  if ((op_code >> 23) == OP_RPTS || (op_code >> 23) == OP_IACK)
    {
      /* this op code has no destination */
      
      pdest = NULL;
    }
  else
    {
      dest = (op_code >> 16) & 0x1f;

      if (type == TYPE_FLOATING && (op_code >> 23) != OP_FIX)
	{
	  /* the destination (or source) register of a floating point op must be R0 - R11 */

	  if (!is_extended_precision_register( dest ))
	    {
	      syserr( "disassembler: destination of FP op (%s) is not an FP register (%s)",
		     instruction, _regname( dest ) );
	    }
	}

      pdest = _regname( dest );
    }
  
  fprintf( asmstream, "%s\t", instruction );
	      
  switch ((op_code >> 21) & 0x3)
    {
    case 0: /* register to register */
      /*
       * we have a diaidic op code, using register addressing
       *
       * bits  0 - 4  encode source register
       * bits  5 - 15 are 00000000000
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

      if (op_code & 0xffe0)
	{
	  syserr( "disassembler: bad value in source field of register addressed op %s (%x)",
		 instruction, op_code );
	}
      
      src = op_code & 0x1f;
      
      if (type == TYPE_FLOATING)
	{
	  /* the source register of a floating point op must be R0 - R11 */

	  if (!is_extended_precision_register( src ))
	    {
	      syserr( "disassembler: non FP source register %s for op %s (%x)",
		     _regname( src ), instruction, op_code );
	    }
	}

      if (pdest && dest != src)
	fprintf( asmstream, "%s, %s", _regname( src ), pdest );
      else
d595 97
a691 20

      break;
	      
    case 1: /* direct */
      /*
       * we have a diaidic op code, using direct addressing
       *
       * bits  0 - 15 are an unsigned offset to the data page register
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

      if (store)	/* pdest is actually source */
	fprintf( asmstream, "%s, @@%#04.4lx", pdest, (op_code & 0xffff) );
      else if (pdest)
	fprintf( asmstream, "@@%#04.4lx, %s", (op_code & 0xffff), pdest );
      else
	fprintf( asmstream, "@@%#04.4lx", (op_code & 0xffff) );
d693 1
a693 73
      break;

    case 2: /* indirect */
      /*
       * we have a diaidic op code, using indirect addressing
       *
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

	{
	  int32		disp = op_code & 0xff;
	  int32		addr = (op_code >> 8) & 0x7;


	  if (store)
	    {
	      fprintf( asmstream, "%s, ", pdest );

	      decode_indirect_address( op_code >> 11 & 0x1f, addr, disp );
	    }
	  else
	    {
	      decode_indirect_address( (op_code >> 11) & 0x1f, addr, disp );

	      if (pdest)
		fprintf( asmstream, ", %s", pdest );
	    }
	}
      break;
      
    case 3: /* immediate */
      /*
       * we have a diaidic op code, using immeadiate addressing
       *
       * bits  0 - 15 are a signed immeadiate value
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

      if (type == TYPE_SIGNED)
	dest = mask_and_sign_extend_word( op_code, 0x0000ffffU );
      else
	dest = op_code & 0xffffU;
      
      if (type == TYPE_FLOATING)
	{
	  fprintf( asmstream, "%s, %s", decode_short_float( dest ), pdest );
	}
      else if (sym_reladdr != NULL)
	{
	  fprintf( asmstream, ".%s, %s\t%c value = %+ld,",
		  symname_( sym_reladdr ), pdest, ASM_COMMENT_CHAR, dest );
	}
      else if (dest < 500 && dest > -500 && type == TYPE_SIGNED)
	{
	  fprintf( asmstream, "%ld, %s", dest, pdest );
	}
      else if (pdest)
	{
	  fprintf( asmstream, "%#lx, %s", dest, pdest );
	}
      else
	{
	  fprintf( asmstream, "%#lx", dest );
	}
d695 5
a699 3
      break;
      
    }
a700 4
  return;
  
} /* decode_diadic_address */
  
d707 70
a776 65
decode_integer_store( int32 op_code )
{
  int32		dest;

  
  /*
   * we have an integer store
   *
   * bits  0 - 15 encode destination
   * bits 16 - 20 encode source
   * bits 21 - 22 encode addressing type
   * bits 23 - 31 are 000101010
   */

  dest = (op_code >> 16) & 0x1f;

  switch ((op_code >> 21) & 0x3)
    {
    case 0: /* indirect immediate */
      /*
       * bits  0 - 15 are an unsigned offset from the data page register
       * bits 16 - 20 encode value
       * bits 21 - 31 are 00010101000
       */

      fprintf( asmstream, "STIK\t%ld, @@%#04.4lx", mask_and_sign_extend_word( dest, 0x1f ), (op_code & 0xffff) );

      break;
	      
    case 1: /* direct register */
      /*
       * bits  0 - 15 are an unsigned offset to the data page register
       * bits 16 - 20 encode source register
       * bits 21 - 31 are 00010101001
       */

      fprintf( asmstream, "STI\t%s, @@%#04.4lx", _regname( dest ), (op_code & 0xffff) );

      break;

    case 2: /* indirect register */
      /*
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode source register
       * bits 21 - 31 are 00010101010
       */

      fprintf( asmstream, "STI\t%s, ", _regname( dest ) );

      decode_indirect_address( (op_code >> 11) & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );

      break;
      
    case 3: /* indirect immediate */
      /*
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode source value
       * bits 21 - 31 are 00010101011
       */

      fprintf( asmstream, "STIK\t%ld, ", mask_and_sign_extend_word( dest, 0x1f ) );
d778 5
a782 5
      decode_indirect_address( (op_code >> 11) & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );

      break;
      
    }
a783 4
  return;
  
} /* decode_integer_store */
  
d790 380
a1169 380
decode_flow_control(
		    int32	op_code, 	/* instruction				*/
		    bool	flag_errs )	/* TRUE if errors should be reported	*/
{
  /*
   * we have a flow control op code
   *
   * bits 30 - 31 are 01
   *
   * other bits are semi-random
   */

  if (op_code & (1 << 29))
    {
      /* bits 29 - 31 are 011 */

      if (op_code & (1 << 28))
	{
	  /* bits 28 - 31 are 0111 */
	  
	  if (op_code & (1 << 27))
	    {
	      /* bits 27 - 31 are 01111 */

	      if (op_code & (1 << 24))
		{
		  /*
		   * we have a repeat block with register addressing
		   *
		   * bits  0 -  4 encode the source
		   * bits  5 - 22 are 000000000000000000
		   * bit  23      encodes the delay
		   * bits 24 - 31 are 01111001
		   */

		  if (op_code & (1 << 23))
		    {
		      fprintf( asmstream, "RPTBD\t%s", _regname( op_code ) );
		    }
		  else
		    {
		      fprintf( asmstream, "RPTB\t%s", _regname( op_code ) );
		    }
		}
	      else
		{
		  /* bits 24 - 31 are 01111xx0 */

		  if (op_code & (1 << 23))
		    {
		      /*
		       * we have a conditional return from subroutine
		       *
		       * bits  0 - 15 are 0000000000000000
		       * bits 16 - 20 encode the condition 
		       * bits 21 - 31 are 01111000100
		       */

		      fprintf( asmstream, "RETS%s", _condname( op_code >> 16 ) );
		    }
		  else
		    {
		      /*
		       * we have a conditional return from interrupt
		       *
		       * bits  0 - 15 are 0000000000000000
		       * bits 16 - 20 encode the condition
		       * bit  21      encodes the delay type
		       * bits 22 - 31 are 0111100000
		       */

		      if (op_code & (1 << 21))
			{
			  fprintf( asmstream, "RETI%sD", _condname( op_code >> 16 ) );
			}
		      else
			{
			  fprintf( asmstream, "RETI%s", _condname( op_code >> 16 ) );
			}
		    }
		}
	    }
	  else
	    {
	      /* bits 27 - 31 are 01110 */
	      
	      if (op_code & (1 << 26))
		{
		  /* bits 26 - 31 are 011101 */

		  if (op_code & (1 << 25))
		    {
		      /*
		       * we have a transfer between register file and expansion register file
		       *
		       * bits  0 -  5 encode the source register
		       * bits  6 - 15 are 0000000000
		       * bits 16 - 20 encode the destination register
		       * bits 21 - 22 are 00
		       * bit  23      encodes the transfer type
		       * bits 24 - 31 are 01110110
		       */

		      if (op_code & (1 << 23))
			{
			  fprintf( asmstream, "LDPE\t%s, %s",
				  _regname( op_code ),
				  flag_errs ? "<xxx unknown expansion register xxx>" : "" );
			}
		      else
			{
			  fprintf( asmstream, "LDEP\t%s, %s",
				  flag_errs ? "<xxx unknown expansion register xxx>" : "",
				  _regname( op_code >> 16 ) );
			}
		    }
		  else
		    {
		      char	op[ 10 ];

		  
		      /*
		       * we have a conditional trap
		       *
		       * bits  0 -  8 encode the trap number
		       * bits  9 - 15 are 0000000
		       * bits 16 - 20 encode the condition
		       * bits 21 - 22 are 00
		       * bit  23      encodes the trap type
		       * bits 24 - 31 are 01110100
		       */

		      if (op_code & (1 << 23))
			{
			  strcpy( op, "LAT" );
			}
		      else
			{
			  strcpy( op, "TRAP" );
			}
		      
		      strcat( op, _condname( (op_code >> 16) & 0x1f ) );

		      fprintf( asmstream, "%s\t%lu", op, op_code & 0x1ff );
		    }
		}
	      else
		{
		  char	op[ 10 ];
		  
		  
		  /*
		   * we have a conditional jump to subroutine
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21      encodes the jump type
		   * bits 22 - 24 are 000
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011100
		   */

		  if (op_code & (1 << 21))
		    {
		      strcpy( op, "LAJ" );
		    }
		  else
		    {
		      strcpy( op, "CALL" );
		    }

		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );

		  if (op_code & (1 << 25))
		    {
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
		      
		      fprintf( asmstream, "%s\t%+ld", op, op_code );
		    }
		  else
		    {
		      fprintf( asmstream, "%s\t%s", op, _regname( op_code & 0x1f ) );
		    }
		}
	    }
	}
      else
	{
	  /* bits 28 - 31 are 0110 */

	  if (op_code & (1 << 27))
	    {
	      /* bits 27 - 31 are 01101 */

	      if (op_code & (1 << 26))
		{
		  char	op[ 10 ];
		  int32	addr;
		  int	offset;
		  

		  /*
		   * we have a conditional decrement and branch
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21      encodes delay
		   * bits 22 - 24 encodes the address register to be decremented
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011011
		   */

		  strcpy( op, "DB" );

		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		  
		  if (op_code & (1 << 21))
		    {
		      strcat( op, "D" );

		      offset = 4;
		    }
		  else
		    {
		      offset = 1;
		    }

		  addr = (op_code >> 22) & 0x7;
		  
		  if (op_code & (1 << 25))
		    {
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
		      
		      fprintf( asmstream, "%s\tAR%1ld, ", op, addr );
		      
		      printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );
		      
		      /* fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
		    }
		  else
		    {
		      fprintf( asmstream, "%s\tAR%1ld, %s", op, addr, _regname( op_code & 0x1f ) );
		    }
		}
	      else
		{
		  char	op[ 10 ];
		  int	offset;
		  

		  /*
		   * we have a conditional branch
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21 - 23 encode the type of branch
		   * bits 24      is 0
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011010
		   */

		  strcpy( op, "B" );

		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		  
		  switch ((op_code >> 21) & 0x7)
		    {
		    case B_000:	                    offset = 1; break;
		    case B_001:	strcat( op, "D"  ); offset = 3; break;
		    case B_010:	syserr( syserr_unknown_op_code, op_code ); return;
		    case B_011:	strcat( op, "AT" ); offset = 3; break;
		    case B_100:	syserr( syserr_unknown_op_code, op_code ); return;
		    case B_101:	strcat( op, "AF" ); offset = 3; break;
		    case B_110:	syserr( syserr_unknown_op_code, op_code ); return;
		    case B_111:	syserr( syserr_unknown_op_code, op_code ); return;
		    }
		  
		  if (op_code & (1 << 25))
		    {
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
		      
		      fprintf( asmstream, "%s\t", op );
		      
		      printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );
		      
		      /* fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
		    }
		  else
		    {
		      fprintf( asmstream, "%s\t%s", op, _regname( op_code & 0x1f ) );
		    }
		}
	    }
	  else
	    {
	      int	offset;

	      
	      /* bits 27 - 31 are 01100 */

	      switch ((op_code >> 24) & 0x7)
		{
		case B_000:	fprintf( asmstream, "BR\t"    ); offset = -2; break;
		case B_001:	fprintf( asmstream, "BRD\t"   ); offset = -4; break;
		case B_010:	fprintf( asmstream, "CALL\t"  ); offset = -2; break;
		case B_011:	fprintf( asmstream, "LAJ\t"   ); offset = -4; break;
		case B_100:	fprintf( asmstream, "RPTB\t"  ); offset = 0;  break;
		case B_101:	fprintf( asmstream, "RPTBD\t" ); offset = 3;  break;
		case B_110:	fprintf( asmstream, "SWI\t"   ); return;
		default:
		case B_111:	syserr( syserr_unknown_op_code, op_code ); return;					
		}

	      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffffL );
	      
	      if (op_code == 1 && offset == -4)
		{
		  /*
		   * A 'LAJ' with an offset of 1 is a special case.
		   * What it is doing is putting the PC into R11 so
		   * that the next few instructions can be PC relative
		   * (This is the only way to access the value of the PC
		   * on the 'C40).  See the code for load_address_constant()
		   * in c40/gen.c
		   */

		  fprintf( asmstream, "4\t%c <fetching PC>", ASM_COMMENT_CHAR );
		}
	      else if (offset < 0)
		{
		  if (sym_reladdr != NULL)
		    {
		      /*
		       * this instruction will have been issued as a
		       * LIT_RELADDR and so the function name will be
		       * deocded later
		       */
		    }
		  else
		    {
		      printlabelname( current_pos + (op_code - offset - 1) * sizeof_int, flag_errs );

		      /* fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
		    }
		}
	      else
		{
		  printlabelname( current_pos + (op_code + offset) * sizeof_int, flag_errs );

		  /* fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, op_code ); */
		}
	    }
	}
    }
  else
    {
      char 		op[ 10 ];
      immed_type	type;
      
      
      /*
       * we have a conditional load op
       *
       * bits  0 - 15 encode the source
       * bits 16 - 20 encode the destination
       * bits 21 - 22 encode the addressing mode
       * bits 23 - 27 encode the condition
       * bit  28      encodes op
       * bits 29 - 31 are 010
       */

      if (((op_code >> 28) & 0x1) == 0)
	{
	  strcpy( op, "LDF" );

	  type = TYPE_FLOATING;
	}
      else
	{
	  strcpy( op, "LDI" );
d1801 1
a1801 1
	  fprintf( asmstream, "%#lx, %s, %s",
d1808 1
a1808 1
	  fprintf( asmstream, "%ld, %s, %s",
d1833 1
a1833 1
	  fprintf( asmstream, "%ld, *+AR%.1ld(%.2lu), %s",
d1840 1
a1840 1
	  fprintf( asmstream, "%#lx, *+AR%.1ld(%.2lu), %s",
d1868 12
d1970 4
a1973 4
	case OP_POP:	fprintf( asmstream, "POP\t%s",   _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_POPF:	fprintf( asmstream, "POPF\t%s",  _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_PUSH:	fprintf( asmstream, "PUSH\t%s",  _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_PUSHF:	fprintf( asmstream, "PUSHF\t%s", _regname( (op_code >> 16) & 0x1f ) ); return;
d1976 4
a1979 4
	case OP_ROL:	fprintf( asmstream, "ROL\t%s",  _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_ROLC:	fprintf( asmstream, "ROLC\t%s", _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_ROR:	fprintf( asmstream, "ROR\t%s",  _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_RORC:	fprintf( asmstream, "RORC\t%s", _regname( (op_code >> 16) & 0x1f ) ); return;
d1983 1
a1983 1
	case OP_STI:	decode_integer_store( op_code ); return;
d2199 1
a2199 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2205 1
a2205 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2211 1
a2211 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2216 1
a2216 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2221 1
a2221 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2226 1
a2226 1
		  fprintf( asmstream, "patchinstr\n(\n PATCHC40MASK16ADD, " );
d2241 1
a2241 1
		  fprintf( asmstream, "patchinstr\n(\n PATCHC40MASK16ADD, " );
d2256 1
a2256 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2262 1
a2262 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2268 1
a2268 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2276 1
a2276 1
		  fprintf( asmstream, "patchinstr\n(\n %s, ",
d2290 1
a2290 1
			  "patchinstr\n(\n PATCHC40MASK16ADD, shift ( -2, %s ( _%s ) ),\n",
d2296 1
a2296 1
		  fprintf( asmstream, "patchinstr\n(\n MODNUM\n" );
d2301 1
a2301 1
			  "patchinstr\n(\n %s ( _%s ) \n",
d2308 1
a2308 1
			  "patchinstr\n(\n LABELREF ( _%s ) \n",
d2451 1
a2451 1
	fprintf( asmstream, "\n)\n" );
a2458 3
  if (annotations)
    fprintf( asmstream, "%28s", "" );

a2501 3
  
  if (annotations)
    return;   /* do not bore interactive user */
@


1.51
log
@improved error messages
@
text
@d5 1
@


1.50
log
@removed generation of offset comments
@
text
@d522 2
a523 1

d574 7
a580 1
      op_code &= 0x1f;
d586 1
a586 1
	  if (!is_extended_precision_register( op_code ))
d588 2
a589 2
	      syserr( "disassembler: non FP source register %s for op %s",
		     _regname( op_code ), instruction );
d593 2
a594 2
      if (pdest && dest != op_code)
	fprintf( asmstream, "%s, %s", _regname( op_code ), pdest );
d596 1
a596 1
	fprintf( asmstream, "%s", _regname( op_code ) );
@


1.49
log
@improved error message slihjtly
@
text
@d1018 1
a1018 1
		      fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code );
d1066 1
a1066 1
		      fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, op_code );
d1123 1
a1123 1
		      fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, op_code );
d1130 1
a1130 1
		  fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, op_code );
d1781 1
a1781 1
	  fprintf( asmstream, ".%s, %s, %s\t%c offset = %ld",
d1784 3
a1786 1
		  pdest,
d1788 1
a1788 1
		  op_code );
d2107 1
a2107 1
      fprintf( asmstream, "        align 128\n" );
@


1.48
log
@removed warning produced by self-compilation
@
text
@d581 2
a582 1
	      syserr( "disassembler: non FP source register %s", _regname( op_code ) );
@


1.47
log
@added Helios Debugger support
@
text
@d35 5
d957 1
a957 1
		      fprintf( asmstream, "%s\t%+d", op, op_code );
@


1.46
log
@fixed erronous floating point fatal error
@
text
@d2139 1
a2139 1
	      
d2266 17
d2445 5
a2479 16
#if 0  
  fprintf( asmstream, "%c register useage conventions:-\n",           ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   AR7 - Frame Pointer\n",                   ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   AR6 - User Stack Pointer\n",              ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   AR5 - Temporary address register\n",      ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   AR4 - Module Table Pointer\n",            ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   R11 - Link register\n",                   ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   IR0 - Base address for all memory ops\n", ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   IR1 - Stack End pointer\n",               ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   RS  - Temporary integer register\n",      ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   RE  - Temporary integer register\n",      ASM_COMMENT_CHAR );
  fprintf( asmstream, "%c   RC  - Temporary integer register\n",      ASM_COMMENT_CHAR );
  
  asm_blank( 1 );
#endif

d2537 5
@


1.45
log
@added code to suppress error messages from decode_instruction()
@
text
@d369 1
a369 1
      syserr( syserr_unknown_indirect_mode, mode );
d538 1
a538 1
      if (type == TYPE_FLOATING)
d544 2
a545 1
	      syserr( syserr_non_float_dest, _regname( dest ) );
d576 1
a576 1
	      syserr( "disassembler: non FP source register", _regname( op_code ) );
@


1.44
log
@improved output slightly
@
text
@d213 4
a216 2
static int32
printlabelname( int32 offset )
d236 3
a238 1
	  return fprintf( asmstream, "L%ldF%ld", (long)(lab_name_( lab ) & 0x7fffffffL), (long)fncount );
d242 3
a244 2
  return fprintf( asmstream, "<unknown destination> offset + base = %ld, current pos = %ld, offset = %ld",
		 (offset + codebase) / sizeof_int, current_pos / sizeof_int, offset / sizeof_int);
d246 2
d303 1
a303 1
  printlabelname( codebase + current_pos + addr * sizeof_int );	/* not right ??? */
d774 3
a776 1
decode_flow_control( int32 op_code ) 		/* instruction */
d880 2
a881 1
				  _regname( op_code ), "<xxx unknown expansion register xxx>" );
d886 2
a887 1
				  "<xxx unknown expansion register xxx>", _regname( op_code >> 16 ) );
d1009 1
a1009 1
		      printlabelname( current_pos + (op_code + offset) * sizeof_int );
d1057 1
a1057 1
		      printlabelname( current_pos + (op_code + offset) * sizeof_int );
d1114 1
a1114 1
		      printlabelname( current_pos + (op_code - offset - 1) * sizeof_int );
d1121 1
a1121 1
		  printlabelname( current_pos + (op_code + offset) * sizeof_int );
d1986 3
a1988 1
decode_instruction( int32 op_code )			/* instruction */
d1998 1
a1998 1
    case 1: decode_flow_control(  op_code );            return;
d2316 1
a2316 1
	  decode_instruction( op_code );
d2326 1
a2326 1
	  decode_instruction( op_code );
@


1.43
log
@added extra test for FP registers
@
text
@d572 1
a572 1
      if (pdest)
@


1.42
log
@updated patches to match heliobj.c
@
text
@d560 12
d573 1
a573 1
	fprintf( asmstream, "%s, %s", _regname( op_code & 0x1f ), pdest );
d575 1
a575 1
	fprintf( asmstream, "%s", _regname( op_code & 0x1f ) );
@


1.41
log
@patched unsigned triadic ops
@
text
@d2171 1
a2171 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2175 1
a2175 1
		      fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -16, CODESYMB ( _%s ) ),\n",
d2180 1
a2180 1
		      fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _%s ) ),\n",
d2186 1
a2186 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2190 1
a2190 1
		      fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -16, shift ( 16, CODESYMB ( _%s ) ) ),\n",
d2195 1
a2195 1
		      fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _%s ) ) ),\n",
@


1.40
log
@fixed generation of datasegment names for resident libraries
@
text
@a1848 2
	case OP_AND3:	decode_triadic_address( op_code, "AND3"    , TYPE_UNSIGNED ); return;
	case OP_ANDN3:	decode_triadic_address( op_code, "ANDN3"   , TYPE_UNSIGNED ); return;
a1854 1
	case OP_OR3:	decode_triadic_address( op_code, "OR3"     , TYPE_UNSIGNED ); return;
d1858 5
a1864 1
	case OP_MPYSHI3:decode_triadic_address( op_code, "MPYSHI3" , TYPE_SIGNED   ); return;
d1866 8
@


1.39
log
@added some mods based on disassembler
@
text
@d2465 1
a2465 1
	  fprintf( asmstream, "export _" );
d2469 1
a2469 1
	  fprintf( asmstream, "\n" );
d2621 3
a2623 1
    fprintf( asmstream, "data ___dataseg, %ld\n", i );
@


1.38
log
@added new version of X_Modnum patch
@
text
@d2 1
a2 1
/* c40/asm.c: Copyright (C) Perihelion Software Ltd., 1991.            */
d521 1
a521 1
  if ((op_code >> 23) == OP_RPTS)
d544 2
d561 1
a561 1
	fprintf( asmstream, "%s\t%s, %s", instruction, _regname( op_code & 0x1f ), pdest );
d563 1
a563 1
	fprintf( asmstream, "%s\t%s", instruction, _regname( op_code & 0x1f ) );
d579 1
a579 1
	fprintf( asmstream, "%s\t%s, @@%#04.4lx", instruction, pdest, (op_code & 0xffff) );
d581 1
a581 1
	fprintf( asmstream, "%s\t@@%#04.4lx, %s", instruction, (op_code & 0xffff), pdest );
d583 1
a583 1
	fprintf( asmstream, "%s\t@@%#04.4lx", instruction, (op_code & 0xffff) );
d607 1
a607 1
	      fprintf( asmstream, "%s\t%s, ", instruction, pdest );
a612 2
	      fprintf( asmstream, "%s\t", instruction );
	      
d639 1
a639 1
	  fprintf( asmstream, "%s\t%s, %s", instruction, decode_short_float( dest ), pdest );
d643 2
a644 2
	  fprintf( asmstream, "%s\t.%s, %s\t%c value = %+ld,",
		  instruction, symname_( sym_reladdr ), pdest, ASM_COMMENT_CHAR, dest );
d648 1
a648 1
	  fprintf( asmstream, "%s\t%ld, %s", instruction, dest, pdest );
d652 1
a652 1
	  fprintf( asmstream, "%s\t%#lx, %s", instruction, dest, pdest );
d656 1
a656 1
	  fprintf( asmstream, "%s\t%#lx", instruction, dest );
d724 1
a724 1
      decode_indirect_address( op_code >> 11 & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );
d739 1
a739 1
      decode_indirect_address( op_code >> 11 & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );
d928 1
a928 1
		      fprintf( asmstream, "%s\t", op );
d1291 4
a1294 4
  src4 =  op_code        & 0xff;
  src3 = (op_code >>  8) & 0xff;
  src2 = (op_code >> 16) & 0x7;
  src1 = (op_code >> 19) & 0x7;
d1296 1
a1296 1
  dst1 = (op_code >> 23) & 0x1;
d1787 3
a1789 1
	syserr( "asm: triadic floating point immediate operations are impossible" );
d1791 6
a1796 1
	op_code = mask_and_sign_extend_word( op_code, 0xff );
d1798 6
a1803 1
	op_code &= 0xff;
a1804 5
      fprintf( asmstream, "%ld, *+AR%.1ld(%.2lu), %s",
	      op_code,
	      src1 & 0x7, (src1 >> 2),
	      pdest );
      
@


1.37
log
@made decode_instruction global
@
text
@d2205 4
a2208 1
		  fprintf( asmstream, "patchinstr\n(\n PATCHC40MASK16ADD, " );
@


1.36
log
@fixed decoding of RPTS instruction
@
text
@d1946 1
a1946 1
static void
@


1.35
log
@tideid up decoding of X_absreloc
@
text
@a512 2
   * XXX - NC
   *
d521 7
a527 3
  dest = (op_code >> 16) & 0x1f;

  if (type == TYPE_FLOATING)
d529 1
a529 1
      /* the destination (or source) register of a floating point op must be R0 - R11 */
d531 1
a531 1
      if (!is_extended_precision_register( dest ))
d533 6
a538 1
	  syserr( syserr_non_float_dest, _regname( dest ) );
d540 2
a542 2

  pdest = _regname( dest );
a547 2
       * XXX - NC
       *
d558 4
a561 1
      fprintf( asmstream, "%s\t%s, %s", instruction, _regname( op_code & 0x1f ), pdest );
a566 2
       * XXX - NC
       *
d578 2
d581 2
a582 2
	fprintf( asmstream, "%s\t@@%#04.4lx, %s", instruction, (op_code & 0xffff), pdest );

a586 2
       * XXX - NC
       *
d614 3
a616 2
	      
	      fprintf( asmstream, ", %s", pdest );
a622 2
       * XXX - NC
       *
d647 7
a653 1
	fprintf( asmstream, "%s\t%ld, %s", instruction, dest, pdest );
d655 3
a657 1
	fprintf( asmstream, "%s\t%#lx, %s", instruction, dest, pdest );
a678 2
   * XXX - NC
   *
a692 2
       * XXX - NC
       *
a703 2
       * XXX - NC
       *
a714 2
       * XXX - NC
       *
a729 2
       * XXX - NC
       *
a757 2
   * XXX - NC
   *
a779 2
		   * XXX - NC
		   *
a803 2
		       * XXX - NC
		       *
a815 2
		       * XXX - NC
		       *
a845 2
		       * XXX - NC
		       *
a872 2
		       * XXX - NC
		       *
a902 2
		   * XXX - NC
		   *
a952 2
		   * XXX - NC
		   *
a1001 2
		   * XXX - NC
		   *
a1111 2
       * XXX - NC
       *
a1158 2
   * XXX - NC
   *
a1277 2
   * XXX - NC
   *
a1377 2
   * XXX - NC
   *
a1410 2
   * XXX - NC
   *
a1458 2
   * XXX - NC
   *
a1509 2
   * XXX - NC
   *
a1654 2
   * XXX - NC
   *
a1822 2
   * XXX - NC
   *
a1829 2
       * XXX - NC
       *
a1864 2
       * XXX - NC
       *
a1949 2
   * XXX - NC
   *
@


1.34
log
@fixed to compile on sparky
@
text
@d2195 1
d2210 1
d2244 2
a2245 1
		  fprintf( asmstream, "patchinstr\n(\n " );
d2247 1
a2247 1
		    fprintf( asmstream, "PATCHC40MASK16ADD, shift ( 1, MODNUM ),\n" );
d2249 1
a2249 1
		    fprintf( asmstream, "PATCHC40MASK16ADD, MODNUM,\n" );
d2254 4
a2257 11
		  fprintf( asmstream, "patchinstr\n(\n " );
		  if (split_module_table)
		    {		      
		      fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -2, CODESYMB ( _%s ) ),\n",
			      symname_( (Symstr *)(int)aux ) );
		    }
		  else
		    {
		      fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -2, DATASYMB ( _%s ) ),\n",
			      symname_( (Symstr *)(int)aux ) );
		    }
d2260 5
a2265 1
		default:
a2266 3
		  fprintf( asmstream, "%c unknown cross refernce type %lx\n",
			  ASM_COMMENT_CHAR, xrtype );
		  
@


1.33
log
@updated patch for X_DataAddr1
@
text
@d22 2
a23 2
#include </helios/include/helios.h>
#include </helios/include/module.h>
@


1.32
log
@imrpoved new-line insertion
@
text
@d57 1
a57 1
extern int32		IEEE_to_extended_float( int32 high, int32 low, bool high_part );
d2223 1
a2223 1
		  fprintf( asmstream, "PATCHC40MASK16ADD, shift ( -18, LABELREF ( .%s ) ),\n",
d2380 7
a2386 3
	  decode_DC( IEEE_to_extended_float( pending_fpnum, op_code, TRUE  ) );
	  fprintf( asmstream, "\n" );
	  decode_DC( IEEE_to_extended_float( pending_fpnum, op_code, FALSE ) );
d2604 1
a2604 1
	    decode_DC( IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, TRUE ) );
d2613 4
d2622 3
a2624 1
	      decode_DC( IEEE_to_extended_float( fc->floatbin.db.msd, fc->floatbin.db.lsd, FALSE ) );
d2629 1
@


1.31
log
@fixed decoding of FP numbers
@
text
@d2381 1
@


1.30
log
@improved decoding of unsigned instructions
@
text
@d2115 3
d2369 1
a2369 1
	  decode_DC( IEEE_to_extended_float( op_code, 0, TRUE ) );
a2371 1
#endif
d2375 1
a2375 1

d2380 5
a2384 1
	  decode_DC( IEEE_to_extended_float( op_code, 0, FALSE ) );
d2592 3
a2594 3
#if 1
	  int32 *	p = ((FloatCon *)val) -> floatbin.irep;
	  
d2597 1
a2597 1
	    decode_DC( IEEE_to_single_float( p[ 0 ] ) );
d2599 1
a2599 1
	    decode_DC( IEEE_to_extended_float( p[ 0 ], p[ 1 ], TRUE ) );
d2601 1
a2601 1
	  decode_DC( p[ 0 ] );
d2604 1
a2604 1
	    fprintf( asmstream, " %c %s", ASM_COMMENT_CHAR, ((FloatCon *)val) -> floatstr );
d2613 1
a2613 1
	      decode_DC( IEEE_to_extended_float( p[ 0 ], p[ 1 ], FALSE ) );
d2615 1
a2615 1
	      decode_DC( p[ 1 ] );
a2617 1
#endif
@


1.29
log
@fixed indentation of BRD statements
@
text
@d40 9
d503 4
a506 5
		      int32	w,		/* instruction */
		      char *	op_code,	/* string identifying instruction */
		      int32	floating,	/* non zero if floating point operation */
		      int32	store,		/* non zero if a store operation */
		      int32	is_signed )	/* true if immediate operands are signed */
d523 1
a523 1
  dest = (w >> 16) & 0x1f;
d525 1
a525 1
  if (floating)
d537 1
a537 1
  switch ((w >> 21) & 0x3)
d553 1
a553 1
      fprintf( asmstream, "%s\t%s, %s", op_code, _regname( w & 0x1f ), pdest );
d571 1
a571 1
	fprintf( asmstream, "%s\t%s, @@%#04.4lx", op_code, pdest, (w & 0xffff) );
d573 1
a573 1
	fprintf( asmstream, "%s\t@@%#04.4lx, %s", op_code, (w & 0xffff), pdest );
d593 2
a594 2
	  int32		disp = w & 0xff;
	  int32		addr = (w >> 8) & 0x7;
d599 1
a599 1
	      fprintf( asmstream, "%s\t%s, ", op_code, pdest );
d601 1
a601 1
	      decode_indirect_address( w >> 11 & 0x1f, addr, disp );
d605 1
a605 1
	      fprintf( asmstream, "%s\t", op_code );
d607 1
a607 1
	      decode_indirect_address( (w >> 11) & 0x1f, addr, disp );
d627 2
a628 2
      if (is_signed && !floating)
	dest = mask_and_sign_extend_word( w, 0x0000ffffU );
d630 1
a630 1
	dest = w & 0xffffU;
d632 1
a632 1
      if (floating)
d634 1
a634 1
	  fprintf( asmstream, "%s\t%s, %s", op_code, decode_short_float( dest ), pdest );
d639 1
a639 1
		  op_code, symname_( sym_reladdr ), pdest, ASM_COMMENT_CHAR, dest );
d641 2
a642 2
      else if (dest < 500 && dest > -500)
	fprintf( asmstream, "%s\t%ld, %s", op_code, dest, pdest );
d644 1
a644 1
	fprintf( asmstream, "%s\t%#lx, %s", op_code, dest, pdest );
d660 1
a660 1
decode_integer_store( int32 w )
d676 1
a676 1
  dest = (w >> 16) & 0x1f;
d678 1
a678 1
  switch ((w >> 21) & 0x3)
d689 1
a689 1
      fprintf( asmstream, "STIK\t%ld, @@%#04.4lx", mask_and_sign_extend_word( dest, 0x1f ), (w & 0xffff) );
d702 1
a702 1
      fprintf( asmstream, "STI\t%s, @@%#04.4lx", _regname( dest ), (w & 0xffff) );
d719 1
a719 1
      decode_indirect_address( w >> 11 & 0x1f, (w >> 8) & 0x7, w & 0xff );
d736 1
a736 1
      decode_indirect_address( w >> 11 & 0x1f, (w >> 8) & 0x7, w & 0xff );
d752 1
a752 1
decode_flow_control( int32 w ) 		/* instruction */
d764 1
a764 1
  if (w & (1 << 29))
d768 1
a768 1
      if (w & (1 << 28))
d772 1
a772 1
	  if (w & (1 << 27))
d776 1
a776 1
	      if (w & (1 << 24))
d789 1
a789 1
		  if (w & (1 << 23))
d791 1
a791 1
		      fprintf( asmstream, "RPTBD\t%s", _regname( w ) );
d795 1
a795 1
		      fprintf( asmstream, "RPTB\t%s", _regname( w ) );
d802 1
a802 1
		  if (w & (1 << 23))
d814 1
a814 1
		      fprintf( asmstream, "RETS%s", _condname( w >> 16 ) );
d829 1
a829 1
		      if (w & (1 << 21))
d831 1
a831 1
			  fprintf( asmstream, "RETI%sD", _condname( w >> 16 ) );
d835 1
a835 1
			  fprintf( asmstream, "RETI%s", _condname( w >> 16 ) );
d844 1
a844 1
	      if (w & (1 << 26))
d848 1
a848 1
		  if (w & (1 << 25))
d863 1
a863 1
		      if (w & (1 << 23))
d866 1
a866 1
				  _regname( w ), "<xxx unknown expansion register xxx>" );
d871 1
a871 1
				  "<xxx unknown expansion register xxx>", _regname( w >> 16 ) );
d892 1
a892 1
		      if (w & (1 << 23))
d901 1
a901 1
		      strcat( op, _condname( (w >> 16) & 0x1f ) );
d903 1
a903 1
		      fprintf( asmstream, "%s\t%lu", op, w & 0x1ff );
d924 1
a924 1
		  if (w & (1 << 21))
d933 1
a933 1
		  strcat( op, _condname( (w >> 16) & 0x1f ) );
d935 1
a935 1
		  if (w & (1 << 25))
d937 1
a937 1
		      w = mask_and_sign_extend_word( (unsigned long)w, 0xffffL );
d943 1
a943 1
		      fprintf( asmstream, "%s\t%s", op, _regname( w & 0x1f ) );
d952 1
a952 1
	  if (w & (1 << 27))
d956 1
a956 1
	      if (w & (1 << 26))
d978 1
a978 1
		  strcat( op, _condname( (w >> 16) & 0x1f ) );
d980 1
a980 1
		  if (w & (1 << 21))
d991 1
a991 1
		  addr = (w >> 22) & 0x7;
d993 1
a993 1
		  if (w & (1 << 25))
d995 1
a995 1
		      w = mask_and_sign_extend_word( (unsigned long)w, 0xffffL );
d999 1
a999 1
		      printlabelname( current_pos + (w + offset) * sizeof_int );
d1001 1
a1001 1
		      fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, w );
d1005 1
a1005 1
		      fprintf( asmstream, "%s\tAR%1ld, %s", op, addr, _regname( w & 0x1f ) );
d1029 1
a1029 1
		  strcat( op, _condname( (w >> 16) & 0x1f ) );
d1031 1
a1031 1
		  switch ((w >> 21) & 0x7)
d1035 1
a1035 1
		    case B_010:	syserr( syserr_unknown_op_code, w ); return;
d1037 1
a1037 1
		    case B_100:	syserr( syserr_unknown_op_code, w ); return;
d1039 2
a1040 2
		    case B_110:	syserr( syserr_unknown_op_code, w ); return;
		    case B_111:	syserr( syserr_unknown_op_code, w ); return;
d1043 1
a1043 1
		  if (w & (1 << 25))
d1045 1
a1045 1
		      w = mask_and_sign_extend_word( (unsigned long)w, 0xffffL );
d1049 1
a1049 1
		      printlabelname( current_pos + (w + offset) * sizeof_int );
d1051 1
a1051 1
		      fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, w );
d1055 1
a1055 1
		      fprintf( asmstream, "%s\t%s", op, _regname( w & 0x1f ) );
d1066 1
a1066 1
	      switch ((w >> 24) & 0x7)
d1076 1
a1076 1
		case B_111:	syserr( syserr_unknown_op_code, w ); return;					
d1079 1
a1079 1
	      w = mask_and_sign_extend_word( (unsigned long)w, 0xffffffL );
d1081 1
a1081 1
	      if (w == 1 && offset == -4)
d1106 1
a1106 1
		      printlabelname( current_pos + (w - offset - 1) * sizeof_int );
d1108 1
a1108 1
		      fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, w );
d1113 1
a1113 1
		  printlabelname( current_pos + (w + offset) * sizeof_int );
d1115 1
a1115 1
		  fprintf( asmstream, "%c offset = %+ld", ASM_COMMENT_CHAR, w );
d1122 2
a1123 2
      char 	op[ 10 ];
      int32	floating;
d1139 1
a1139 1
      if (((w >> 28) & 0x1) == 0)
d1143 1
a1143 1
	  floating = TRUE;
d1149 1
a1149 1
	  floating = FALSE;
d1152 1
a1152 1
      strcat( op, _condname( (w >> 23) & 0x1f ) );
d1154 1
a1154 1
      decode_diadic_address( w, op, floating, FALSE, TRUE );
d1169 1
a1169 1
decode_non_word_load( int32 w ) /* instruction */
d1188 1
a1188 1
  B = (int)((w >> 23) & 0x03);
d1190 1
a1190 1
  switch ((w >> 24) & 0x0f)
d1198 1
a1198 1
      decode_diadic_address( w, op, FALSE, FALSE, TRUE );
d1208 1
a1208 1
      decode_diadic_address( w, op, FALSE, FALSE, FALSE );
d1218 1
a1218 1
      decode_diadic_address( w, op, FALSE, FALSE, FALSE );
d1228 1
a1228 1
      decode_diadic_address( w, op, FALSE, FALSE, FALSE );
d1238 1
a1238 1
      decode_diadic_address( w, op, FALSE, FALSE, FALSE );
d1247 1
a1247 1
      decode_diadic_address( w, op, FALSE, FALSE, TRUE );
d1256 1
a1256 1
      decode_diadic_address( w, op, FALSE, FALSE, FALSE );
d1265 1
a1265 1
      decode_diadic_address( w, op, FALSE, FALSE, FALSE );
d1270 1
a1270 1
      syserr( syserr_unknown_op_code, w );
d1284 1
a1284 1
decode_special_triadic( int32 w ) /* instruction */
d1312 6
a1317 6
  src4 =  w        & 0xff;
  src3 = (w >>  8) & 0xff;
  src2 = (w >> 16) & 0x7;
  src1 = (w >> 19) & 0x7;
  dst2 = ((w >> 22) & 0x1) + 2;
  dst1 = (w >> 23) & 0x1;
d1319 1
a1319 1
  switch ((w >> 26) & 0x3)
d1327 1
a1327 1
  switch ((w >> 24) & 0x3)
d1329 2
a1330 1
    case B_00:
d1344 2
a1345 1
    case B_01:
d1359 2
a1360 1
    case B_10:
d1374 2
a1375 1
    case B_11:
d1396 1
a1396 1
decode_non_word_load_or_triadic( int32 w ) /* instruction */
d1407 1
a1407 1
  switch ((w >> 28) & 0x3)
d1409 4
a1412 4
    case B_00:	decode_special_triadic( w ); break;
    case B_01:	syserr( syserr_unknown_op_code, w );     break;
    case B_10:	syserr( syserr_unknown_op_code, w );     break;
    case B_11:	decode_non_word_load( w );   break;
d1422 1
a1422 1
				   int32	w,
d1451 5
a1455 5
  src2 = (w      ) & 0xff;
  dst2 = (w >>  8) & 0xff;
  src3 = (w >> 16) & 0x07;
  src1 = (w >> 19) & 0x07;
  dst1 = (w >> 22) & 0x07;
d1473 1
a1473 1
				  int32	w,
d1501 4
a1504 4
  src2 = (w      ) & 0xff;
  dst2 = (w >>  8) & 0xff;
  src3 = (w >> 16) & 0x07;
  dst1 = (w >> 22) & 0x07;
d1508 1
a1508 1
  if (((w >> 19) & 0x07) != 0)
d1510 1
a1510 1
      syserr( syserr_bad_parallel_addressing, w );
d1527 1
a1527 1
decode_parallel_op( int32 w ) /* instruction */
d1550 5
a1554 5
  field1 = (w      ) & 0xff;
  field2 = (w >>  8) & 0xff;
  field3 = (w >> 16) & 0x07;
  field4 = (w >> 19) & 0x07;
  field5 = (w >> 22) & 0x07;
d1556 1
a1556 1
  switch ((w >> 25) & 0x1f)
d1563 1
a1563 1
	  syserr( syserr_bad_parallel_addressing, w );
d1581 1
a1581 1
	  syserr( syserr_bad_parallel_addressing, w );
d1599 1
a1599 1
	  syserr( syserr_bad_parallel_addressing, w );
d1619 1
a1619 1
	  syserr( syserr_bad_parallel_addressing, w );
d1634 22
a1655 22
    case OP_ABSF_STF:	decode_diadic_parallel_addressing(  w, "ABSF",   "STF" ); break;
    case OP_ABSI_STI:	decode_diadic_parallel_addressing(  w, "ABSI",   "STI" ); break;
    case OP_ADDF3_STF:	decode_triadic_parallel_addressing( w, "ADDF3",  "STF" ); break;
    case OP_ADDI3_STI:	decode_triadic_parallel_addressing( w, "ADDI3",  "STI" ); break;
    case OP_AND3_STI:	decode_triadic_parallel_addressing( w, "AND3",   "STI" ); break;
    case OP_ASH3_STI:	decode_triadic_parallel_addressing( w, "ASH3",   "STI" ); break;
    case OP_FIX_STI:	decode_diadic_parallel_addressing(  w, "FIX",    "STI" ); break;
    case OP_FLOAT_STF:	decode_diadic_parallel_addressing(  w, "FLOAT",  "STF" ); break;
    case OP_LDF_STF:	decode_diadic_parallel_addressing(  w, "LDF",    "STF" ); break;
    case OP_LDI_STI:	decode_diadic_parallel_addressing(  w, "LDI",    "STI" ); break;
    case OP_LSH3_STI:	decode_triadic_parallel_addressing( w, "LSH3",   "STI" ); break;
    case OP_MPYF3_STF:	decode_triadic_parallel_addressing( w, "MPYF3",  "STF" ); break;
    case OP_MPYI3_STI:	decode_triadic_parallel_addressing( w, "MPYI3",  "STI" ); break;
    case OP_NEGF_STF:	decode_diadic_parallel_addressing(  w, "NEGF",   "STF" ); break;
    case OP_NEGI_STI:	decode_diadic_parallel_addressing(  w, "NEGI",   "STI" ); break;
    case OP_NOT_STI:	decode_diadic_parallel_addressing(  w, "NOT",    "STI" ); break;
    case OP_OR3_STI:	decode_triadic_parallel_addressing( w, "OR3",    "STI" ); break;
    case OP_SUBF3_STF:	decode_triadic_parallel_addressing( w, "SUBF3",  "STF" ); break;
    case OP_SUBI3_STI:	decode_triadic_parallel_addressing( w, "SUBI3",  "STI" ); break;
    case OP_XOR3_STI:	decode_triadic_parallel_addressing( w, "XOR3",   "STI" ); break;
    case OP_TOIEEE_STF:	decode_diadic_parallel_addressing(  w, "TOIEEE", "STF" ); break;
    case OP_FRIEEE_STF:	decode_diadic_parallel_addressing(  w, "FRIEEE", "STF" ); break;
d1657 1
a1657 1
      syserr( syserr_unknown_parallel_op, w );
d1667 1
a1667 1
 * deocdes a 'C40 triadic op code
d1672 3
a1674 3
		       int32	w,		/* instruction */
		       char *	op_code,	/* string identifying the op code */
		       int32	floating )	/* non zero if floating point operation */
d1678 1
a1678 1
  unsigned long	type;
d1697 1
a1697 1
  dest = (w >> 16) & 0x1f;
d1699 1
a1699 1
  if (floating)
d1713 1
a1713 1
  type = (w >> 28) & 0x1;
d1715 1
a1715 1
  type <<= 2;
d1717 1
a1717 1
  type |= ((w >> 21) & 0x3);
d1721 2
a1722 2
  src2 = w & 0xff;
  src1 = (w >> 8) & 0xff;
d1726 1
a1726 1
  fprintf( asmstream, "%s\t", op_code );
d1728 1
a1728 1
  switch (type)
d1773 7
d1787 1
a1787 1
		  mask_and_sign_extend_word( w, 0xff ) );
d1789 7
d1799 1
a1799 1
		  mask_and_sign_extend_word( w, 0xff ),
d1817 7
d1825 1
a1825 1
	      mask_and_sign_extend_word( w, 0xff ),
d1834 1
a1834 1
	      op_code,
d1841 1
a1841 1
      syserr( syserr_unknown_triadic_address, w );
d1851 1
a1851 1
decode_sequential_op( int32 w ) /* instruction */
d1860 1
a1860 1
  if (w & 0x20000000L)
d1872 1
a1872 1
      switch ((w >> 23) & 0x1f)
d1874 19
a1892 19
	case OP_ADDC3:	decode_triadic_address( w, "ADDC3"   , FALSE ); return;
	case OP_ADDF3:	decode_triadic_address( w, "ADDF3"   , TRUE  ); return;
	case OP_ADDI3:	decode_triadic_address( w, "ADDI3"   , FALSE ); return;
	case OP_AND3:	decode_triadic_address( w, "AND3"    , FALSE ); return;
	case OP_ANDN3:	decode_triadic_address( w, "ANDN3"   , FALSE ); return;
	case OP_ASH3:	decode_triadic_address( w, "ASH3"    , FALSE ); return;
	case OP_CMPF3:	decode_triadic_address( w, "CMPF3"   , TRUE  ); return;
	case OP_CMPI3:	decode_triadic_address( w, "CMPI3"   , FALSE ); return;
	case OP_LSH3:	decode_triadic_address( w, "LSH3"    , FALSE ); return;
	case OP_MPYF3:	decode_triadic_address( w, "MPYF3"   , TRUE  ); return;
	case OP_MPYI3:	decode_triadic_address( w, "MPYI3"   , FALSE ); return;
	case OP_OR3:	decode_triadic_address( w, "OR3"     , FALSE ); return;
	case OP_SUBB3:	decode_triadic_address( w, "SUBB3"   , FALSE ); return;
	case OP_SUBF3:	decode_triadic_address( w, "SUBF3"   , TRUE  ); return;
	case OP_SUBI3:	decode_triadic_address( w, "SUBI3"   , FALSE ); return;
	case OP_TSTB3:	decode_triadic_address( w, "TSTB3"   , FALSE ); return;
	case OP_XOR3:	decode_triadic_address( w, "XOR3"    , FALSE ); return;
	case OP_MPYSHI3:decode_triadic_address( w, "MPYSHI3" , FALSE ); return;
	case OP_MPYUHI3:decode_triadic_address( w, "MPYUHI3" , FALSE ); return;
d1894 1
a1894 1
	  syserr( syserr_unknown_triadic_op, (w >> 23) & 0x1f );
d1908 1
a1908 1
      switch (w >> 23)
d1910 12
a1921 12
	case OP_ABSF:	decode_diadic_address( w, "ABSF"   , TRUE,  FALSE, TRUE ); return;
	case OP_ABSI:	decode_diadic_address( w, "ABSI"   , FALSE, FALSE, TRUE ); return;
	case OP_ADDC:	decode_diadic_address( w, "ADDC"   , FALSE, FALSE, TRUE ); return;
	case OP_ADDF:	decode_diadic_address( w, "ADDF"   , TRUE,  FALSE, TRUE ); return;
	case OP_ADDI:	decode_diadic_address( w, "ADDI"   , FALSE, FALSE, TRUE ); return;
	case OP_AND:	decode_diadic_address( w, "AND"    , FALSE, FALSE, FALSE ); return;
	case OP_ANDN:	decode_diadic_address( w, "ANDN"   , FALSE, FALSE, FALSE ); return;
	case OP_ASH:	decode_diadic_address( w, "ASH"    , FALSE, FALSE, TRUE ); return;
	case OP_CMPF:	decode_diadic_address( w, "CMPF"   , TRUE,  FALSE, TRUE ); return;
	case OP_CMPI:	decode_diadic_address( w, "CMPI"   , FALSE, FALSE, TRUE ); return;
	case OP_FIX:	decode_diadic_address( w, "FIX"    , TRUE,  FALSE, TRUE ); return;
	case OP_FLOAT:	decode_diadic_address( w, "FLOAT"  , FALSE, FALSE, TRUE ); return;
d1923 12
a1934 12
	case OP_LDE:	decode_diadic_address( w, "LDE"    , TRUE,  FALSE, TRUE ); return;
	case OP_LDF:	decode_diadic_address( w, "LDF"    , TRUE,  FALSE, TRUE ); return;
	case OP_LDFI:	decode_diadic_address( w, "LDFI"   , TRUE,  FALSE, TRUE ); return;
	case OP_LDI:	decode_diadic_address( w, "LDI"    , FALSE, FALSE, TRUE ); return;
	case OP_LDII:	decode_diadic_address( w, "LDII"   , FALSE, FALSE, TRUE ); return;
	case OP_LDM:	decode_diadic_address( w, "LDM"    , TRUE,  FALSE, TRUE ); return;
	case OP_LSH:	decode_diadic_address( w, "LSH"    , FALSE, FALSE, TRUE ); return;
	case OP_MPYF:	decode_diadic_address( w, "MPYF"   , TRUE,  FALSE, TRUE ); return;
	case OP_MPYI:	decode_diadic_address( w, "MPYI"   , FALSE, FALSE, TRUE ); return;
	case OP_NEGB:	decode_diadic_address( w, "NEGB"   , FALSE, FALSE, TRUE ); return;
	case OP_NEGF:	decode_diadic_address( w, "NEGF"   , TRUE,  FALSE, TRUE ); return;
	case OP_NEGI:	decode_diadic_address( w, "NEGI"   , FALSE, FALSE, TRUE ); return;
d1936 37
a1972 37
	case OP_NORM:	decode_diadic_address( w, "NORM"   , TRUE,  FALSE, TRUE ); return;
	case OP_NOT:	decode_diadic_address( w, "NOT"    , FALSE, FALSE, FALSE ); return;
	case OP_POP:	fprintf( asmstream, "POP\t%s",   _regname( (w >> 16) & 0x1f ) ); return;
	case OP_POPF:	fprintf( asmstream, "POPF\t%s",  _regname( (w >> 16) & 0x1f ) ); return;
	case OP_PUSH:	fprintf( asmstream, "PUSH\t%s",  _regname( (w >> 16) & 0x1f ) ); return;
	case OP_PUSHF:	fprintf( asmstream, "PUSHF\t%s", _regname( (w >> 16) & 0x1f ) ); return;
	case OP_OR:	decode_diadic_address( w, "OR"     , FALSE, FALSE, FALSE ); return;
	case OP_RND:	decode_diadic_address( w, "RND"    , TRUE,  FALSE, FALSE ); return;
	case OP_ROL:	decode_diadic_address( w, "ROL"    , FALSE, FALSE, FALSE ); return;
	case OP_ROLC:	decode_diadic_address( w, "ROLC"   , FALSE, FALSE, FALSE ); return;
	case OP_ROR:	decode_diadic_address( w, "ROR"    , FALSE, FALSE, FALSE ); return;
	case OP_RORC:	decode_diadic_address( w, "RORC"   , FALSE, FALSE, FALSE ); return;
	case OP_RPTS:	decode_diadic_address( w, "RPTS"   , FALSE, FALSE, FALSE ); return;
	case OP_STF:	decode_diadic_address( w, "STF"    , TRUE,  TRUE,  TRUE  ); return;
	case OP_STFI:	decode_diadic_address( w, "STFI"   , TRUE,  TRUE,  TRUE  ); return;
	case OP_STI:	decode_integer_store( w ); return;
	case OP_STII:	decode_diadic_address( w, "STII"   , FALSE, TRUE,  TRUE  ); return;
	case OP_SIGI:	decode_diadic_address( w, "SIGI"   , FALSE, FALSE, TRUE  ); return;
	case OP_SUBB:	decode_diadic_address( w, "SUBB"   , FALSE, FALSE, TRUE  ); return;
	case OP_SUBC:	decode_diadic_address( w, "SUBC"   , FALSE, FALSE, TRUE  ); return;
	case OP_SUBF:	decode_diadic_address( w, "SUBF"   , TRUE,  FALSE, TRUE  ); return;
	case OP_SUBI:	decode_diadic_address( w, "SUBI"   , FALSE, FALSE, TRUE  ); return;
	case OP_SUBRB:	decode_diadic_address( w, "SUBRB"  , FALSE, FALSE, TRUE  ); return;
	case OP_SUBRF:	decode_diadic_address( w, "SUBRF"  , TRUE,  FALSE, TRUE  ); return;
	case OP_SUBRI:	decode_diadic_address( w, "SUBRI"  , FALSE, FALSE, TRUE  ); return;
	case OP_TSTB:	decode_diadic_address( w, "TSTB"   , FALSE, FALSE, FALSE ); return;
	case OP_XOR:	decode_diadic_address( w, "XOR"    , FALSE, FALSE, FALSE ); return;
	case OP_IACK:	decode_diadic_address( w, "IACK"   , FALSE, FALSE, FALSE ); return;
	case OP_TOIEEE:	decode_diadic_address( w, "TOIEEE" , TRUE,  FALSE, TRUE  ); return;
	case OP_FRIEEE:	decode_diadic_address( w, "FRIEEE" , TRUE,  FALSE, TRUE  ); return;
	case OP_RSQRF:	decode_diadic_address( w, "RSQRF"  , TRUE,  FALSE, TRUE  ); return;
	case OP_RCPF:	decode_diadic_address( w, "RCPF"   , TRUE,  FALSE, TRUE  ); return;
	case OP_MPYSHI:	decode_diadic_address( w, "MPYSHI" , FALSE, FALSE, TRUE  ); return;
	case OP_MPYUHI:	decode_diadic_address( w, "MPYUHI" , FALSE, FALSE, FALSE ); return;
	case OP_LDA:	decode_diadic_address( w, "LDA"    , FALSE, FALSE, TRUE  ); return;
	case OP_LDPK:	decode_diadic_address( w, "LDPK"   , FALSE, FALSE, TRUE  ); return;
	case OP_LDHI:	decode_diadic_address( w, "LDHI"   , FALSE, FALSE, FALSE ); return;
d1974 1
a1974 1
	  syserr( syserr_unknown_diadic_op, w >> 23 );
d1984 1
a1984 1
decode_instruction( int32 w )			/* instruction */
d1992 1
a1992 1
  switch ((w >> 30) & 0x3)
d1995 4
a1998 4
    case 0: decode_sequential_op( w );            return;
    case 1: decode_flow_control(  w );            return;
    case 2: decode_non_word_load_or_triadic( w ); return;
    case 3: decode_parallel_op(   w );            return;
d2005 1
a2005 1
decode_DC( int32 w )
d2007 1
a2007 1
  fprintf( asmstream, "word\t%#.8lx", (long)w );
d2015 1
a2015 1
decode_DCAx( int32 w )
d2019 1
a2019 1
  decode_addr( w );
d2029 1
a2029 1
	   int32 	w )
d2033 1
a2033 1
  /* decode_addr( w, 0 ); */
d2037 2
a2038 2
  if (w != 0)
    fprintf( asmstream, " %+ld", (long)w );
d2110 3
a2112 3
      const int32	w   = code_inst_( current_pos );
      const int32	f   = code_flag_( current_pos );
      VoidStar 		aux = code_aux_(  current_pos );
d2290 1
a2290 1
	      fprintf( asmstream, "      %.8lx      ", (long)totargetsex( w, LIT_BBBB ) );
d2294 1
a2294 1
	      fprintf( asmstream, "      %.8lx      ", (long)w );
d2311 1
a2311 1
	  decode_instruction( w );
d2321 1
a2321 1
	  decode_instruction( w );
d2333 1
a2333 1
	  decode_DC( totargetsex( w, LIT_BBBB ) );
d2339 1
a2339 1
	      pr_chars( w );
d2345 1
a2345 1
	  decode_DC( w );
d2349 1
a2349 1
	  decode_DCAx( w );	/* ??? */
d2355 1
a2355 1
	  decode_DC( IEEE_to_single_float( w ) );
d2357 1
a2357 1
	  decode_DC( w );
d2366 1
a2366 1
	  decode_DC( IEEE_to_extended_float( w, 0, TRUE ) );
d2368 1
a2368 1
	  decode_DC( w );
d2378 1
a2378 1
	  decode_DC( IEEE_to_extended_float( w, 0, FALSE ) );
d2380 1
a2380 1
	  decode_DC( w );
@


1.28
log
@added decoding of floating point immediate values
@
text
@d47 2
d1060 7
a1066 7
		case B_000:	fprintf( asmstream, "BR"    ); offset = -2;  break;
		case B_001:	fprintf( asmstream, "BRD"   ); offset = -4;  break;
		case B_010:	fprintf( asmstream, "CALL"  ); offset = -2; break;
		case B_011:	fprintf( asmstream, "LAJ"   ); offset = -4; break;
		case B_100:	fprintf( asmstream, "RPTB"  ); offset = 0;  break;
		case B_101:	fprintf( asmstream, "RPTBD" ); offset = 3;  break;
		case B_110:	fprintf( asmstream, "SWI"   ); return;
d1084 1
a1084 1
		  fprintf( asmstream, "\t4\t%c <fetching PC>", ASM_COMMENT_CHAR );
d1100 1
a1100 1
		      fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, w );
d1107 1
a1107 1
		  fprintf( asmstream, "\t%c offset = %+ld", ASM_COMMENT_CHAR, w );
d2293 1
a2293 1
	    fprintf( asmstream, "\t.%s", symname_( sym_reladdr ) );
d2321 3
d2325 1
a2325 1

d2332 3
d2336 1
d2344 3
d2348 1
d2553 1
a2553 1
#if 0
d2556 6
a2561 1

d2563 1
a2563 1
	  
d2572 4
a2575 1
	      
d2577 1
@


1.27
log
@removed declarartion of __dataseg if -Zr is being used
@
text
@d384 102
d617 1
a617 1
      if (is_signed)
d623 3
a625 5
#if defined FLOATING_POINT_IS_IN_COMPILER_NOW || !defined __HELIOSC40
	fprintf( asmstream, "%s\t%#4f, %s", op_code, (float)(dest), pdest );
#else
      ;
#endif
@


1.26
log
@fixed decoding of DATAMODULE
@
text
@d2480 2
a2481 1
  fprintf( asmstream, "data ___dataseg, %ld\n", i );
@


1.25
log
@now produces output compatible with Paul's assembler
@
text
@d227 1
a227 1
  return fprintf( asmstream, "<unknown destination> offset + base = %d, current pos = %d, offset = %d",
d324 8
a331 8
    case B_00000:	fprintf( asmstream, "*+AR%ld(%d)",          addr, disp ); break;
    case B_00001:	fprintf( asmstream, "*-AR%ld(%d)",          addr, disp ); break;
    case B_00010:	fprintf( asmstream, "*++AR%ld(%d)",         addr, disp ); break;
    case B_00011:	fprintf( asmstream, "*--AR%ld(%d)",         addr, disp ); break;
    case B_00100:	fprintf( asmstream, "*AR%ld++(%d)",         addr, disp ); break;
    case B_00101:	fprintf( asmstream, "*AR%ld--(%d)",         addr, disp ); break;
    case B_00110:	fprintf( asmstream, "*AR%ld++(%d)%%",       addr, disp ); break;
    case B_00111:	fprintf( asmstream, "*AR%ld--(%d)%%",       addr, disp ); break;
d521 1
d523 3
d528 1
a528 1
	  fprintf( asmstream, "%s\t.%s, %s\t%c value = %+d,",
d532 1
a532 1
	fprintf( asmstream, "%s\t%d, %s", op_code, dest, pdest );
d534 1
a534 1
	fprintf( asmstream, "%s\t%#x, %s", op_code, dest, pdest );
a551 1
  char *	pdest;
d579 1
a579 1
      fprintf( asmstream, "STIK\t%s, @@%#04.4lx", mask_and_sign_extend_word( dest, 0x1f ), (w & 0xffff) );
d624 1
a624 1
      fprintf( asmstream, "STIK\t%d, ", mask_and_sign_extend_word( dest, 0x1f ) );
d891 1
a891 1
		      fprintf( asmstream, "\t%c offset = %+d", ASM_COMMENT_CHAR, w );
d941 1
a941 1
		      fprintf( asmstream, "\t%c offset = %+d", ASM_COMMENT_CHAR, w );
d998 1
a998 1
		      fprintf( asmstream, "\t%c offset = %+d", ASM_COMMENT_CHAR, w );
d1005 1
a1005 1
		  fprintf( asmstream, "\t%c offset = %+d", ASM_COMMENT_CHAR, w );
d1661 1
a1661 1
	  fprintf( asmstream, ".%s, %s, %s\t%c offset = %d",
d1670 1
a1670 1
	  fprintf( asmstream, "%d, %s, %s",
d1689 1
a1689 1
      fprintf( asmstream, "%d, *+AR%.1ld(%.2lu), %s",
d1890 1
a1890 1

d1943 1
a1944 1

d2024 1
a2024 1
		  stub_pend = TRUE;
d2030 1
a2030 1
		  fprintf( asmstream, "PATCHC40DATAMODULE1, DATAMODULE ( _%s ),\n",
d2097 2
a2098 1
		  fprintf( asmstream, "PATCHC40MASK16ADD, DATAMODULE ( _%s ),\n",
d2100 1
d2129 1
a2129 1
		  fprintf( asmstream, "%c unknown cross refernce type %x\n",
d2285 1
a2285 1
      fprintf( asmstream, "\tword    %#x\n", T_Module );
d2407 1
a2407 1
	val = totargetsex( val, (long)sort );
d2440 1
d2443 1
a2443 1
#if 0
d2480 1
a2480 1
  fprintf( asmstream, "data ___dataseg, %d\n", i );
@


1.24
log
@fixed decoding of LAJ + 1
@
text
@d22 2
d40 2
a41 1
FILE *	asmstream;
d43 3
a45 1
#ifndef NO_ASSEMBLER_OUTPUT
d47 1
d52 1
a52 1
#define	ASM_COMMENT_CHAR	'*'
d159 1
a159 1
  return fprintf( stream, "_%s", s );
d273 2
d522 5
d639 1
a639 3
decode_flow_control(
		    int32 	w, 		/* instruction */
		    bool	is_reladdr )	/* true if instruction has a symbol assocaited with it */
d826 1
a826 5
		      fprintf( asmstream, "%s\t%+d\t => ", op, w );

		      if (!is_reladdr)
			fprintf( stderr, "_<some_function>" );
		      
d884 1
a884 1
		      fprintf( asmstream, "%s\tAR%1ld, %+d\t => ", op, addr, w );
d887 2
d934 1
a934 1
		      fprintf( asmstream, "%s\t%+d\t => ", op, w );
d937 2
a967 2
	      fprintf( asmstream, "\t%+d\t => ", w );

d979 1
a979 1
		  fprintf( asmstream, "<fetching PC>" );
d983 1
a983 1
		  if (is_reladdr)
d994 2
d1001 2
d1656 16
a1671 4
      fprintf( asmstream, "%d, %s, %s",
	      mask_and_sign_extend_word( w, 0xff ),
	      _regname( src1 & 0x3f ),
	      pdest );
d1846 1
a1846 3
decode_instruction(
		   int32	w,			/* instruction */
		   bool		is_reladdr )		/* true iff instruction has a symbol associated with it */
d1857 2
a1858 2
    case 0: decode_sequential_op( w ); if (is_reladdr) fprintf( asmstream, "\t => " ); return;
    case 1: decode_flow_control(  w, is_reladdr ); return;
d1860 1
a1860 1
    case 3: decode_parallel_op(   w ); return;
d1869 1
a1869 1
  fprintf( asmstream, ".word\t%#.8lx", (long)w );
d1879 1
a1879 1
  fprintf( asmstream, ".word\t" );
d1893 1
a1893 1
  fprintf( asmstream, ".word\t" );
d1931 1
a1931 1
  /* fprintf( asmstream, "\t.global\t" );
d1956 1
a1956 1
  if (name != NULL)   /* may be 0 for string literals from static inits   */
d1958 2
d1963 2
a1969 15
#ifdef NEVER
  /*
   * XXX
   *
   * one day we would like to align the start of
   * functions (and the initialisation code) to 128
   * byte boundaries to optimize the use of the 'C40's
   * pipeline.  Unfortuanetly this would upset the
   * compiler's calculation of inter function offsets
   * so that these would have to be recoded.
   */
  
  fprintf( asmstream, "        .align 128\n" );
#endif
  
d1975 2
d1978 2
a1979 1
        {
d2000 132
d2169 1
a2169 1
	  decode_instruction( w, FALSE );
d2171 2
d2176 4
a2179 1
	  decode_instruction( w, TRUE );
d2181 8
a2188 1
	  fprintf( asmstream, "%s", symname_( (Symstr *)(int)aux ) );
d2239 4
a2242 1
      fprintf( asmstream, "\n" );
a2247 2
  /* idly ensure code segment stays aligned if no terminating literal pool */

d2272 17
d2293 1
a2293 2
  fprintf( asmstream, "%c generated by %s\n", ASM_COMMENT_CHAR, CC_BANNER );
  
d2307 1
a2307 4
  
  asm_padcol8( 0 );

  fprintf( asmstream, ".text\n        .align 8\n" );
d2329 1
a2329 1
	  fprintf( asmstream, " .global " );
a2333 8
        }
    }
  
  asm_blank( 1 );

  for (x = obj_symlist; x != 0; x = x->extcdr)
    {
      int32 	flags = x->extflags;
d2335 1
a2335 3
      if (!(flags & xr_defloc) && !(flags & xr_defext))
        {
	  fprintf( asmstream, "%c .extern ", ASM_COMMENT_CHAR );
d2342 2
d2367 1
d2370 1
d2372 1
a2372 5
  fprintf( asmstream, ".data\n        .align 8\n" );
  
  asm_blank( 1 );
  
  for (p = datainitp; p != 0; p = p->datacdr)
d2386 3
d2392 1
a2392 1
	
d2407 1
a2407 1
	
d2428 1
a2428 1
	
d2437 1
a2437 1

d2451 1
a2451 1

d2460 1
a2460 1

d2462 1
a2462 1

d2467 1
d2469 1
d2474 4
d2515 1
a2515 1
	  fprintf( asmstream, "\t.common\t" );
d2531 7
a2545 142


#ifdef TEST_DISASSEMBLER

int32 			feature     = 0;
CodeXref * 		codexrefs   = 0;
int32 			codep       = 0;
int32			bss_size    = 0;
ExtRef *		obj_symlist = 0;
Binder *		codesegment = 0;
LabList *		asm_lablist = 0;
VoidStar (*(		codeasmauxvec[ CODEVECSEGMAX ]))[ CODEVECSEGSIZE ];
int32			codebase    = 0;
struct CodeAndFlag *	codeandflagvec[ CODEVECSEGMAX ];
DataInit *		datainitp   = 0;


VoidStar
xsyn_list2( int32 a, int32 b )
{
  return NULL;
}

char *
version_banner( void )
{
  return "Hello World\n";
}

int32
totargetsex( int32 w, int flag )
{
  return 0;
}


void
syserr( syserr_message_type code, ... )
{
  va_list	args;

  
  va_start( args, code );

  fseek( stderr, 0L, SEEK_END );
  
  fprintf( stderr, "warning: " );
  
  vfprintf( stderr, code, args );

  fputc( '\n', stderr );
  
  fflush( stderr );
  
  va_end( args );
  
  return;

} /* syserr */


int
main(
     int	argc,
     char **	argv )
{
  char * 	input_file;
  char * 	output_file;
  FILE *	in;
  int		w;
  

  if (argc > 1)
    {
      input_file = argv[ 1 ];

      in = fopen( input_file, "r" );

      if (in == NULL)
	{
	  fprintf( stderr, "%s: failed to open input file %s\n", argv[ 0 ], input_file );

	  return -1;
	}
    }
  else
    {
      input_file = "<stdin>";

      in = stdin;
    }

  if (argc > 2)
    {
      output_file = argv[ 2 ];
    }
  else
    {
      output_file = "disas.out";
    }

  asmstream = fopen( output_file, "w" );

  if (asmstream == NULL)
    {
      fprintf( stderr, "%s: failed to open output file %s\n", argv[ 0 ], output_file );

      fclose( in );

      return -2;
    }

  fprintf( stderr, "Disassembler starting\n" );
  fprintf( stderr, "Disassembler reading from input file: %s\n", input_file );
  fprintf( stderr, "Disassembler writing to  output file: %s\n", output_file );
  
  (void) fread( &w, sizeof( int ), 1, in );
  
  while (!feof( in ))
    {
      decode_instruction( w );

      fprintf( asmstream, "\n" );
      
      if (fread( &w, sizeof( int ), 1, in ) != 1)
	break;
    }

  fprintf( stderr, "Disassembler finished\n" );

  fclose( asmstream );
  fclose( in );
  
  return 0;
  
} /* main */
  
#endif /* TEST_DISASSEMBLER */

#endif /* ! NO_ASSEMBLER_OUTPUT */

/* end of c40/asm.c */
@


1.23
log
@unknown fixes
@
text
@d959 1
a959 1
	      if (w == 0)
d962 3
a964 3
		   * A 'CALL' with an offset of zero is a special case.
		   * What it is doing is pushing the PC onto the stack
		   * so that the next instruction (a pop) can fetch it
d970 1
a970 2
		  if (offset == -1)
		    fprintf( asmstream, "<fetching PC>" );
@


1.22
log
@added OP_LDPK to diadic op list
@
text
@a2129 1
  fprintf( asmstream, "%c   DP  - Register containing 0\n",           ASM_COMMENT_CHAR );
@


1.21
log
@fixed decoding of special triadics
@
text
@d1760 1
a1760 1
	case OP_IDLE:	decode_diadic_address( w, "IDLE"   , FALSE, FALSE, FALSE ); return;
d1809 1
@


1.20
log
@fixed decoding of unsigned immediate values
@
text
@d270 1
a270 1
	fprintf( asmstream, "+0x%lx", xroffset );
d1191 2
a1192 2
  dst1 = (w >> 22) & 0x1;
  dst2 = (w >> 23) & 0x1;
a1855 2
  /*  fprintf( stderr, "DCAx w=%lx p=%lx\n", w, p ); */
  
d1874 1
a1874 1
  pr_asmname( s,asmstream );
d1877 1
a1877 1
    fprintf( asmstream, "%+ld", (long)w );
d2051 1
@


1.19
log
@oops fixed decoding of offsets fro BR and CALL
@
text
@d385 2
a386 1
		      int32	store )		/* non zero if a store operation */
d507 4
a510 1
      dest = mask_and_sign_extend_word( w, 0xffffL );
d1029 1
a1029 1
      decode_diadic_address( w, op, floating, FALSE );
d1073 1
a1073 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1083 1
a1083 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1093 1
a1093 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1103 1
a1103 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1113 1
a1113 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1122 1
a1122 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1131 1
a1131 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1140 1
a1140 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1748 25
a1772 25
	case OP_ABSF:	decode_diadic_address( w, "ABSF"   , TRUE,  FALSE ); return;
	case OP_ABSI:	decode_diadic_address( w, "ABSI"   , FALSE, FALSE ); return;
	case OP_ADDC:	decode_diadic_address( w, "ADDC"   , FALSE, FALSE ); return;
	case OP_ADDF:	decode_diadic_address( w, "ADDF"   , TRUE,  FALSE ); return;
	case OP_ADDI:	decode_diadic_address( w, "ADDI"   , FALSE, FALSE ); return;
	case OP_AND:	decode_diadic_address( w, "AND"    , FALSE, FALSE ); return;
	case OP_ANDN:	decode_diadic_address( w, "ANDN"   , FALSE, FALSE ); return;
	case OP_ASH:	decode_diadic_address( w, "ASH"    , FALSE, FALSE ); return;
	case OP_CMPF:	decode_diadic_address( w, "CMPF"   , TRUE,  FALSE ); return;
	case OP_CMPI:	decode_diadic_address( w, "CMPI"   , FALSE, FALSE ); return;
	case OP_FIX:	decode_diadic_address( w, "FIX"    , TRUE,  FALSE ); return;
	case OP_FLOAT:	decode_diadic_address( w, "FLOAT"  , FALSE, FALSE ); return;
	case OP_IDLE:	decode_diadic_address( w, "IDLE"   , FALSE, FALSE ); return;
	case OP_LDE:	decode_diadic_address( w, "LDE"    , TRUE,  FALSE ); return;
	case OP_LDF:	decode_diadic_address( w, "LDF"    , TRUE,  FALSE ); return;
	case OP_LDFI:	decode_diadic_address( w, "LDFI"   , TRUE,  FALSE ); return;
	case OP_LDI:	decode_diadic_address( w, "LDI"    , FALSE, FALSE ); return;
	case OP_LDII:	decode_diadic_address( w, "LDII"   , FALSE, FALSE ); return;
	case OP_LDM:	decode_diadic_address( w, "LDM"    , TRUE,  FALSE ); return;
	case OP_LSH:	decode_diadic_address( w, "LSH"    , FALSE, FALSE ); return;
	case OP_MPYF:	decode_diadic_address( w, "MPYF"   , TRUE,  FALSE ); return;
	case OP_MPYI:	decode_diadic_address( w, "MPYI"   , FALSE, FALSE ); return;
	case OP_NEGB:	decode_diadic_address( w, "NEGB"   , FALSE, FALSE ); return;
	case OP_NEGF:	decode_diadic_address( w, "NEGF"   , TRUE,  FALSE ); return;
	case OP_NEGI:	decode_diadic_address( w, "NEGI"   , FALSE, FALSE ); return;
d1774 2
a1775 2
	case OP_NORM:	decode_diadic_address( w, "NORM"   , TRUE,  FALSE ); return;
	case OP_NOT:	decode_diadic_address( w, "NOT"    , FALSE, FALSE ); return;
d1780 9
a1788 9
	case OP_OR:	decode_diadic_address( w, "OR"     , FALSE, FALSE ); return;
	case OP_RND:	decode_diadic_address( w, "RND"    , TRUE,  FALSE ); return;
	case OP_ROL:	decode_diadic_address( w, "ROL"    , FALSE, FALSE ); return;
	case OP_ROLC:	decode_diadic_address( w, "ROLC"   , FALSE, FALSE ); return;
	case OP_ROR:	decode_diadic_address( w, "ROR"    , FALSE, FALSE ); return;
	case OP_RORC:	decode_diadic_address( w, "RORC"   , FALSE, FALSE ); return;
	case OP_RPTS:	decode_diadic_address( w, "RPTS"   , FALSE, FALSE ); return;
	case OP_STF:	decode_diadic_address( w, "STF"    , TRUE,  TRUE  ); return;
	case OP_STFI:	decode_diadic_address( w, "STFI"   , TRUE,  TRUE  ); return;
d1790 20
a1809 20
	case OP_STII:	decode_diadic_address( w, "STII"   , FALSE, TRUE  ); return;
	case OP_SIGI:	decode_diadic_address( w, "SIGI"   , FALSE, FALSE ); return;
	case OP_SUBB:	decode_diadic_address( w, "SUBB"   , FALSE, FALSE ); return;
	case OP_SUBC:	decode_diadic_address( w, "SUBC"   , FALSE, FALSE ); return;
	case OP_SUBF:	decode_diadic_address( w, "SUBF"   , TRUE,  FALSE ); return;
	case OP_SUBI:	decode_diadic_address( w, "SUBI"   , FALSE, FALSE ); return;
	case OP_SUBRB:	decode_diadic_address( w, "SUBRB"  , FALSE, FALSE ); return;
	case OP_SUBRF:	decode_diadic_address( w, "SUBRF"  , TRUE,  FALSE ); return;
	case OP_SUBRI:	decode_diadic_address( w, "SUBRI"  , FALSE, FALSE ); return;
	case OP_TSTB:	decode_diadic_address( w, "TSTB"   , FALSE, FALSE ); return;
	case OP_XOR:	decode_diadic_address( w, "XOR"    , FALSE, FALSE ); return;
	case OP_IACK:	decode_diadic_address( w, "IACK"   , FALSE, FALSE ); return;
	case OP_TOIEEE:	decode_diadic_address( w, "TOIEEE" , TRUE,  FALSE ); return;
	case OP_FRIEEE:	decode_diadic_address( w, "FRIEEE" , TRUE,  FALSE ); return;
	case OP_RSQRF:	decode_diadic_address( w, "RSQRF"  , TRUE,  FALSE ); return;
	case OP_RCPF:	decode_diadic_address( w, "RCPF"   , TRUE,  FALSE ); return;
	case OP_MPYSHI:	decode_diadic_address( w, "MPYSHI" , FALSE, FALSE ); return;
	case OP_MPYUHI:	decode_diadic_address( w, "MPYUHI" , FALSE, FALSE ); return;
	case OP_LDA:	decode_diadic_address( w, "LDA"    , FALSE, FALSE ); return;
	case OP_LDHI:	decode_diadic_address( w, "LDHI"   , FALSE, FALSE ); return;
@


1.18
log
@changed condition code l to be lt
@
text
@d940 1
a940 1
		case B_000:	fprintf( asmstream, "BR"    ); offset = -1;  break;
d942 1
a942 1
		case B_010:	fprintf( asmstream, "CALL"  ); offset = -1; break;
@


1.17
log
@fixed calculation of offsets in delayed branches
@
text
@d2 1
a2 1
/* c40/asm.c: Copyright (C) Peihelion Software Ltd., 1991.             */
d296 1
a296 1
  "l\0\0\0\0le\0\0\0gt\0\0\0ge\0\0\0<xx>\0nv\0\0\0v\0\0\0\0"
@


1.16
log
@fixed decoding of offsets in branches
@
text
@d215 1
a215 1
      if ((lab->u.defn & 0x00ffffff) == offset)
d217 1
a217 1
	  return fprintf( asmstream, "L%ldF%ld", (long)(lab_name_( lab ) & 0x7fffffff), (long)fncount );
d222 1
a222 1
		 offset + codebase, current_pos, offset );
d981 1
a981 1
		      printlabelname( current_pos + (w - offset + 1) * sizeof_int );
d1966 1
d1975 1
a1975 1
	      
d2027 1
a2027 1
	  fprintf( asmstream, "%s", symname_( (Symstr *)aux ) );
@


1.15
log
@fixed decoding of implicit displacement in triadic indirect ops
@
text
@d907 1
a907 1
		    case B_000:	                    offset = 0; break;
@


1.14
log
@fixed so that labels are displayed in data initialisation phase
@
text
@d1203 1
a1203 1
      decode_indirect_address( src3 >> 3, src3 & 7, 0 );
d1207 1
a1207 1
      decode_indirect_address( src4 >> 3, src4 & 7, 0 );
d1217 1
a1217 1
      decode_indirect_address( src3 >> 3, src3 & 7, 0 );
d1222 1
a1222 1
      decode_indirect_address( src4 >> 3, src4 & 7, 0 );
d1232 1
a1232 1
      decode_indirect_address( src3 >> 3, src3 & 7, 0 );
d1236 1
a1236 1
      decode_indirect_address( src4 >> 4, src4 & 7, 0 );
d1245 1
a1245 1
      decode_indirect_address( src3 >> 3, src3 & 7, 0 );
d1250 1
a1250 1
      decode_indirect_address( src4 >> 3, src4 & 7, 0 );
d1326 1
a1326 1
  decode_indirect_address( src2 >> 3, src2 & 7, 0 );
d1331 1
a1331 1
  decode_indirect_address( dst2 >> 3, dst2 & 7, 0 );
d1382 1
a1382 1
  decode_indirect_address( src2 >> 3, src2 & 7, 0 );
d1386 1
a1386 1
  decode_indirect_address( dst2 >> 3, dst2 & 7, 0 );
d1435 1
a1435 1
      decode_indirect_address( field1 >> 3, field1 & 7, 0 );
d1439 1
a1439 1
      decode_indirect_address( field2 >> 3, field2 & 7, 0 );
d1453 1
a1453 1
      decode_indirect_address( field1 >> 3, field1 & 7, 0 );
d1457 1
a1457 1
      decode_indirect_address( field2 >> 3, field2 & 7, 0 );
d1471 1
a1471 1
      decode_indirect_address( field1 >> 3, field1 & 7, 0 );
d1475 1
a1475 1
      decode_indirect_address( field2 >> 3, field2 & 7, 0 );
d1491 1
a1491 1
      decode_indirect_address( field1 >> 3, field1 & 7, 0 );
d1495 1
a1495 1
      decode_indirect_address( field2 >> 3, field2 & 7, 0 );
d1610 1
a1610 1
      decode_indirect_address( src1 >> 3, src1 & 7, 0 );
d1632 1
a1632 1
      decode_indirect_address( src1 >> 3, src1 & 7, 0 );
@


1.13
log
@removed alignment to 128 byte boundaries
@
text
@d1922 1
a1922 1
  LabList *	asm_lablist2 = 0;
d1927 1
a1927 5
  /* XXX - NC -> should this test be against NULL rather than 0 ??? */
  
  if (name != 0)   /* may be 0 for string literals from static inits   */
    {
      asm_lablist2 = asm_lablist;
d1929 1
a1929 1
      fncount++;
d1931 2
a1965 1
	  
@


1.12
log
@fixed typo in previous delta
@
text
@d1943 12
d1956 2
a1957 1

@


1.11
log
@added code to cope with the STIK opcode
@
text
@d529 1
a529 1
decode_integer_store( int32 op )
@


1.10
log
@fixed use of BSS when not required
@
text
@d506 2
d509 3
a511 1
	fprintf( asmstream, "%s\t%#4f, %s", op_code, (double)mask_and_sign_extend_word( w , 0xffffL ), pdest );
d513 94
a606 1
	fprintf( asmstream, "%s\t%d, %s", op_code, mask_and_sign_extend_word( w, 0xffff ), pdest );
d614 1
a614 1
} /* decode_diadic_address */
d1785 1
a1785 1
	case OP_STI:	decode_diadic_address( w, "STI"    , FALSE, TRUE  ); return;
@


1.9
log
@fixed ordering of operands of triadic ops
@
text
@d1733 1
a1733 1
    case 0: decode_sequential_op( w ); return;
d2196 1
d2241 2
a2242 1

@


1.8
log
@fixed calculation of offsets used by non-delayed branches
@
text
@d844 1
a844 1
		case B_001:	fprintf( asmstream, "BRD"   ); offset = -3;  break;
d846 1
a846 1
		case B_011:	fprintf( asmstream, "LAJ"   ); offset = -3; break;
d884 1
a884 1
		      printlabelname( current_pos + (w - offset) * sizeof_int );
d1112 1
a1112 1
      fprintf( asmstream, ", %s\n|| %s\t%s, %s, %s",
d1122 1
a1122 1
      fprintf( asmstream, ", %s, %s\n|| %s\t",
d1132 1
a1132 1
      fprintf( asmstream, "%s\t%s, %s, %s\n|| %s\t",
d1150 1
a1150 1
      fprintf( asmstream, ", %s, %s\n|| %s\t, %s, ",
d1231 1
a1231 1
  fprintf( asmstream, ", %s, %s\n|| %s\t%s, ",
d1287 1
a1287 1
  fprintf( asmstream, ", %s\n|| %s\t%s, ", _regname( dst1 ), second_op, _regname( src3 ) );
d1340 1
a1340 1
      fprintf( asmstream, "\n|| STF\t%s, ", _regname( field3 ) );
d1358 1
a1358 1
      fprintf( asmstream, "\n|| STI\t%s, ", _regname( field3 ) );
d1376 1
a1376 1
      fprintf( asmstream, ", %s\n|| LDF\t", _regname( field5 ) );
d1396 1
a1396 1
      fprintf( asmstream, ", %s\n|| LDI\t", _regname( field5 ) );
d1442 3
a1444 3
		      int32	w,		/* instruction */
		      char *	op_code,	/* string identifying the op code */
		      int32	floating )	/* non zero if floating point operation */
d1495 2
d1501 6
a1506 3
      
      fprintf( asmstream, "%s\t%s, %s, %s",
	      op_code, _regname( src1 & 0x3f ), _regname( src2 & 0x3f ), pdest );
d1510 2
a1511 2
      
      fprintf( asmstream, "%s\t", op_code );
a1513 2

      fprintf( asmstream, ", %s, %s", _regname( src2 & 0x3f ), pdest );
d1515 2
d1520 2
a1521 2
      
      fprintf( asmstream, "%s\t%s, ", op_code, _regname( src1 & 0x3f ) );
d1523 1
a1523 1
      decode_indirect_address( src2 >> 3, src2 & 7, 1 );
d1530 2
a1531 4
      
      fprintf( asmstream, "%s\t", op_code );
      
      decode_indirect_address( src1 >> 3, src1 & 7, 0 );
d1534 2
a1535 2
      
      decode_indirect_address( src2 >> 3, src2 & 7, 1 );
d1542 5
a1547 2
      fprintf( asmstream, "%s\t%s, %d, %s",
	      op_code, _regname( src1 & 0x3f ), mask_and_sign_extend_word( w, 0xff ), pdest );
d1551 5
a1556 2
      fprintf( asmstream, "%s\t%s, *+AR%.1ld(%.2lu), %s",
	      op_code, _regname( src1 & 0x3f ), src2 & 0x7, (src2 >> 2) , pdest );
d1560 5
a1565 3
      fprintf( asmstream, "%s\t*+AR%.1ld(%.2lu), %d, %s",
	      op_code, src1 & 0x7, (src1 >> 2),
	      mask_and_sign_extend_word( w, 0xff ), pdest );
d1571 4
a1574 1
	      op_code, src1 & 0x7,(src1 >> 2), src2 & 0x7, (src2 >> 2), pdest );
@


1.7
log
@improved error message from printlabelname()
@
text
@d810 1
a810 1
		    case B_000:	offset = 1; break;
@


1.6
log
@outputs .align 128 at start of each function
@
text
@d221 2
a222 1
  return fprintf( asmstream, "L%06ld???  /* %ld -> %ld */", offset + codebase, current_pos, offset );
@


1.5
log
@fixed bug in decoding parallel addressing
@
text
@d1831 2
@


1.4
log
@fixed decode_external_addr
@
text
@d1286 1
a1286 1
  fprintf( asmstream, ", %s\n|| %s\t%s, ", _regname( dst1 ), second_op, _regname( dst1 ) );
@


1.3
log
@made mask_and_sign_extend a global function
@
text
@a235 3
  fprintf( stderr, "searched for external, codebase = %d, current pos = %d, addr = %d\n",
	  codebase, current_pos, addr );

d242 5
a246 3
      
      /* although we have found it in codexrefs, we may still be able to
	 produce a local label name for it                                */
d253 2
a254 1
	  if (codebase + (lab->u.defn & 0x00ffffff) + addr == xroffset)
a255 2
	      fprintf( asmstream, "L%ldF%ld", (long)(lab_name_( lab ) & 0x7fffffff), (long)fncount );
	      
d276 1
a276 1
  printlabelname( addr );	/* not right ??? */
@


1.2
log
@changed header
@
text
@d359 1
a359 1
static signed long
@


1.1
log
@Initial revision
@
text
@d2000 3
a2002 1
  fprintf( asmstream, "%c   R3  - Temporary integer register\n",      ASM_COMMENT_CHAR );
@
