head	1.77;
access;
symbols
	beta_release:1.69;
locks; strict;
comment	@ * @;


1.77
date	93.07.29.13.35.12;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	93.07.27.09.13.45;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	93.07.23.08.41.57;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	93.07.22.10.05.46;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	93.07.14.13.23.18;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	93.07.08.08.26.12;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	93.07.07.10.39.48;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	93.06.10.15.54.55;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	92.06.11.17.09.23;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	92.06.04.09.48.34;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	92.05.20.17.07.22;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	92.05.20.13.54.52;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	92.05.07.13.42.48;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	92.04.22.17.27.20;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	92.04.14.09.19.25;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	92.03.31.17.53.12;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	92.03.20.18.22.14;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	92.03.19.17.43.56;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	92.03.19.16.38.46;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	92.03.18.09.56.17;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	92.03.16.16.30.35;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	92.03.16.12.18.51;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	92.03.13.16.26.39;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	92.03.13.15.59.55;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	92.02.28.12.09.25;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	92.02.27.14.09.33;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	92.02.26.17.34.33;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	92.02.25.17.42.56;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	92.02.21.18.36.58;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	92.02.21.11.32.33;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	92.02.20.17.02.40;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	92.02.19.14.49.43;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	92.02.17.16.12.13;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	92.02.12.11.27.33;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	92.02.11.17.48.26;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	92.02.11.17.40.14;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	92.02.03.17.32.03;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	92.02.03.17.31.41;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	92.02.03.14.32.14;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	92.01.31.18.12.36;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	92.01.23.13.04.40;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	92.01.16.17.56.03;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	92.01.16.17.36.29;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	92.01.16.16.38.41;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	91.12.11.16.00.05;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	91.12.04.18.32.45;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	91.10.28.17.52.27;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	91.10.28.15.28.55;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	91.10.23.14.51.23;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	91.10.18.15.55.49;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	91.10.11.15.16.10;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	91.10.10.14.42.32;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	91.10.10.13.52.04;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	91.10.07.16.16.44;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	91.10.04.13.21.17;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	91.10.04.12.39.56;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	91.10.04.12.38.45;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	91.10.03.14.24.48;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	91.10.03.13.24.09;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	91.10.02.11.05.29;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	91.10.02.09.21.19;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	91.10.01.09.37.29;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	91.09.25.12.47.59;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	91.09.20.17.18.29;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	91.09.19.13.01.45;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	91.09.18.08.53.22;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	91.09.18.08.18.29;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	91.08.29.15.08.05;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	91.08.29.14.34.01;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	91.08.29.10.08.58;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	91.08.28.17.00.16;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	91.08.26.10.07.49;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	91.08.26.09.09.14;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	91.08.23.17.13.02;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	91.08.23.08.48.07;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	91.08.22.16.52.00;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	91.08.22.14.58.57;	author nickc;	state Exp;
branches;
next	;


desc
@C40 target definitions
@


1.77
log
@fixed register naming / counting
@
text
@
/* C compiler file sparc/target.h :  Copyright (C) Codemist Ltd., 1991. */
/* Copyright (c) 1991 Perihelion Software Ltd.
   All Rights Reserved */
/* version 5 */
/* $Header: /hsrc/cmds/cc/ncc/cc450/c40/RCS/target.h,v 1.76 1993/07/27 09:13:45 nickc Exp nickc $ */

#ifndef _c40target_LOADED
#define _c40target_LOADED 1

#define TARGET_MACHINE 			"C40"
#define TARGET_PREDEFINES 		{ "__C40", "__JMP_BUF_SIZE=22" }

   #define TARGET_IS_C40				1

/* #define TARGET_IS_BIG_ENDIAN    			0 */	/* but doubles are big endian ! */
   #define TARGET_IS_LITTLE_ENDIAN    			1  	/* because of C40 byte instructions */

#if !(defined TARGET_HAS_AOUT || defined TARGET_HAS_COFF)
   #define TARGET_HAS_AOUT 				1	/* XXX we do not actually care about this */
#endif

   #define target_coff_magic 				0577     /* inspected if TARGET_HAS_COFF */

   #define TARGET_HAS_DEBUGGER				1	/* It may not be DBX, but hey! */

   #define TARGET_HAS_BLOCKMOVE 			1	/* XXX - well, we are faking it */
   #define TARGET_HAS_COND_EXEC				1 	/* can do conditionally execution */
   #define TARGET_HAS_FP_LITERALS			1	/* FP constants can be included in OP codes */
   #define TARGET_HAS_IEEE 				1	/* XXX - not quite true ... */
   #define TARGET_HAS_MULTIPLY 				1   	/* but see also config_init in mcdep.c */
   #define TARGET_HAS_SEPARATE_CODE_DATA_SEGS		1	/* because of seperqte address buses */
   #define TARGET_HAS_SIGN_EXTEND			1	/* XXX we can fake it */
   #define TARGET_HAS_TAILCALL 				1	/* yup we can do tailcalls */
   #define TARGET_HAS_TAILCALLR 			1	/* XXX - does this work ? */
   #define TARGET_ONLY_HAS_CONDITIONAL_LOAD		1	/* but only for load instructions */

/* #define TARGET_HAS_2ADDRESS_CODE 			0 */	/* implies only supports diadic operations */
/* #define TARGET_HAS_370_FP				0 */	/* IBM370 specific */
/* #define TARGET_HAS_BSS 				0 */	/* XXX - do we ? */
/* #define TARGET_HAS_BYTE_INSTRUCTIONS			0 */	/* indicates instructions are byte sized */
/* #define TARGET_HAS_DIVIDE   				0 */
/* #define TARGET_HAS_DIVREM_FUNCTION			0 */
/* #define TARGET_HAS_EBCDIC				0 */
/* #define TARGET_HAS_HALFWORD_INSTRUCTIONS		0 */	/* indicates that instructions can be 16 bits */
/* #define TARGET_HAS_LINKER_NAME_LIMIT			0 */	/* not that I know of */
/* #define TARGET_HAS_NEGATIVE_INDEXING			0 */	/* XXX - what does this do ? */
/* #define TARGET_HAS_NON_FORTRAN_DIVIDE		0 */	/* XXX - we do not have any divide ops */
/* #define TARGET_HAS_OTHER_IEEE_ORDER			0 */	/* IEEE doubles are stored big-endian */
/* #define TARGET_HAS_PROFILE 				0 */	/* XXX - not for now */
/* #define TARGET_HAS_RISING_STACK			0 */	/* XXX - added by NC, see c40/flowgraf.c */
/* #define TARGET_HAS_ROTATE                            0 */	/* C40 rotates not sufficient for this */
/* #define TARGET_HAS_SCALED_ADDRESSING			0 */	/* indicates that load offsets can be in bytes, words, etc */
/* #define TARGET_HAS_SCALED_OPS			0 */	/* XXX - what does this do ? */
/* #define TARGET_HAS_SCCK				0 */	/* m68k specific */
/* #define TARGET_HAS_SWITCH_BRANCHTABLE 		0 */	/* indicates that target has special support for switching */

   #define TARGET_ADDRESSES_UNSIGNED			1
   #define TARGET_ALLOWS_COMPARE_CSES			1 
   #define TARGET_COUNT_IS_PROC 			1
   #define TARGET_FP_ARGS_IN_FP_REGS			1	/* oh yes ! */
   #define TARGET_LACKS_DIVIDE_LITERALS 		1
   #define TARGET_LINKER_OMITS_DOLLAR 			1	/* XXX - what does this do ? */
   #define TARGET_USES_NEW_STUBS			1	/* New style linker generated stubs used */

/* #define TARGET_CALL_USES_DESCRIPTOR			0 */
/* #define TARGET_CORRUPTS_SWITCH_REGISTER 		0 */	/* switch might corrupt index register */
/* #define TARGET_FLAGS_VA_CALLS			0 */	/* IBM370 specific */
/* #define TARGET_GEN_NEEDS_VOLATILE_INFO		0 */	/* do we ? */
/* #define TARGET_INLINES_MONADS			0 */	/* XXX - what does this do ? */
/* #define TARGET_LACKS_3WAY_COMPARE			0 */
/* #define TARGET_LACKS_FP_DIVIDE			0 */	/* we can simulate it efficiently */
/* #define TARGET_LACKS_HALFWORD_STORE			0 */	/* implies that we cannot store half words */
/* #define TARGET_LACKS_MULDIV_LITERALS			0 */	/* cannot multiply or divide by a constant */
/* #define TARGET_LACKS_MULTIPLY_LITERALS		0 */
/* #define TARGET_LACKS_REMAINDER			0 */
/* #define TARGET_LACKS_RIGHTSHIFT			0 */
/* #define TARGET_LACKS_ROL				0 */	/* no Rotate Left instruction */
/* #define TARGET_LACKS_RR_STORE			0 */	/* XXX - what does this do ? */
/* #define TARGET_LACKS_UNSIGNED_FIX 			0 */
/* #define TARGET_LDRK_MAX 				0 */	/* maximum permitted pointer offset */
/* #define TARGET_LDRK_MIN 				0 */	/* maximum permitted negative pointer offset */
/* #define TARGET_LDRK_QUANTUM				0 */	/* superceeded by LDRK_MIN and LDRK_MAX */
/* #define TARGET_NULL_BITPATTERN			0 */	/* defined elsewhere */
/* #define TARGET_R0_ALWAYS_ZERO 			0 */	
/* #define TARGET_SHARES_INTEGER_AND_FP_REGISTERS	0 */ 	/* removed on advice from AM */
/* #define TARGET_STACKS_LINK				0 */	/* link address is placed on stack */
/* #define TARGET_STACK_MOVES_ONCE			0 */	/* Hitachi specific */
/* #define TARGET_STRUCT_RESULT_REGISTER		0 */	/* names register used to return structs */
/* #define TARGET_SWITCH_isdense			0 */	/* advanced tuning for switch statements */

/* #define ADDRESS_REG_STUFF 				0 */	/* indicates seperate address and data regs - we dont support this */
/* #define RANGECHECK_SUPPORED				0 */	/* only for FORTRAN / PASCAL */

/* #define DO_NOT_OPTIMISE_CHAR_AND_SHORT_ARITHMETIC 	0 */	/* XXX - experimentally put in ?? */

   #define NO_INSTORE_FILES				1 
   #define UNIQUE_DATASEG_NAMES				1

#if defined __hp9000s700 || defined _AIX
#define REVERSE_OBJECT_BYTE_ORDER			1 	/* big endian host */
#endif

/* #define SOFTWARE_FLOATING_POINT			0 */	/* defined if no FP support in op codes */


/*
 * XXX - NC
 *
 * Register Ordering
 * Version:		7
 * Date:		29/2/92
 *
 * Naming Scheme:
 * -------------
 * Name:	| R0 |  R1 |  R2 |  R3 | | R4 |  R5 | | R6 |  R7 | | R8 |  R9 | R10 | | R11 |
 *               ----------------------   ----------   ----------   ----------------   -----
 * Number:	|  0 |   1 |   2 |   3 | |  4 |   5 | |  6 |   7 | | 10 |  11 |  12 | |  17 |
 *
 *
 * Name:	| AR0 | AR1 | AR2 | AR3 | | AR4 | AR5 | AR6 | AR7 |
 *		 -----------------------   -----------------------
 * Number:	|  13 |  14 |  15 |  16 | |  18 |  19 |  20 |  21 |
 *
 *
 * Name:	| DP | BK | | IR0 | IR1 | | SP | ST | | RS | RE | RC | | PC |
 *		 ---------   -----------   ---------   --------------   ----
 * Number:	|  8 |  9 | |  22 |  23 | | 24 | 25 | | 26 | 27 | 28 | | 30 |
 */

#define RR_R0	 0
#define RR_R1	 1
#define RR_R2	 2
#define RR_R3	 3
#define RR_R4	 4
#define RR_R5	 5
#define RR_R6	 6
#define RR_R7	 7
#define RR_R8	10
#define RR_R9	11
#define RR_R10	12
#define RR_R11	17
#define RR_AR0	13
#define RR_AR1	14
#define RR_AR2	15
#define RR_AR3	16
#define RR_AR4	18
#define RR_AR5	19
#define RR_AR6	20
#define RR_AR7	21
#define RR_DP	 8
#define RR_IR0	22
#define RR_IR1	23
#define RR_BK	 9
#define RR_SP	24
#define RR_ST	25
#define RR_RS	26
#define RR_RE	27
#define RR_RC	28
#define RR_PST	29	/* pseudo ST register, used by peepholer register checkers */
#define RR_PC	30	/* pseudo register used by peepholer register checkers */


/*
 * Usage:
 * -----
 *
 * Arguments:			R0,  R1, R2,  R3	(arguments passed in to function)
 * Variables:			DP,  BK, R8,  R9	(saved on function entry)
 * Temporaries:			R10			(saved before function call)
 * Floating Point Arg:		R4, R5			(must not intersect variable or temporary registers)
 * Floating Point Var:		R6, R7	 		(must not intersect argument or temporary registers)
 * Floating Point Tmp:  				(must not intersect argument or variable  registers)
 * Link:			R11			(honorary temporary and variable register)
 * Address:			AR0, AR1, AR2, AR3	(address registers or temporary registers)
 * Universal Temporaries:	RS, RE, RC		(NOT available to front end)
 * Module Table Pointer:	AR4			(NOT available to front end)
 * Temporary address:		AR5			(NOT available to front end)
 * User Stack Pointer:		AR6			
 * Frame Pointer:       	AR7
 * Addressing Base:		IR0		(NB/ this is hard coded in gen.c)
 * Stack End Pointer:		IR1		(see load_static_data_ptr() in c40/gen.c)
 * System Stack Pointer:	SP		(used by interrupt handlers)
 */

/*
 * XXX - following definitions must agree with those in:
 *
 * /helios/include/ampp/c40.m
 * c40/gen.c -> hardware_register()
 *           -> get_free_register()
 *
 */

#define R_A1  		RR_R0	/* first argument register */
#define R_A1result 	RR_R0	/* result of function left here (must be able to hold a double) */
#define R_TMP1		RR_RS	/* first  universal temporary register */
#define R_TMP2		RR_RE	/* second universal temporary register */
#define R_TMP3		RR_RC	/* third  universal temporary register */
#define R_T1  		RR_R10	/* first temporary register */
#define R_V1  		RR_DP	/* first variable register */
#define R_FA1		RR_R4	/* first floating point argument register */
#define R_F1		RR_R4	/* first floating point register */
#define R_FV1		RR_R6	/* first floating point variable register */
#define R_FT1		-1	/* first floating point temporary register */

#define R_IP		RR_AR3	/* XXX WHAT IS THIS REGISTER ? */ /* cf regalloc.c line 2131 */
#define R_LR  		RR_R11 	/* Link register */ /* NB/ must be visible to compiler */
#define R_ADDR1		RR_AR0	/* first address register (also used by heliobj.c when initialising data) */
#define R_MT		RR_AR4	/* module table pointer */	/* NB/ linker/genimage.c relies on this */
#define R_ATMP		RR_AR5	/* temporary address register *//* NB/ linker/genimage.c relies on this */
#define R_SP		RR_AR6	/* stack pointer */
#define R_FP		RR_AR7	/* frame pointer */
#define R_BASE		RR_IR0	/* addressing base */
#define R_SE		RR_IR1	/* stack end pointer */
#define R_PC		XXX	/* program counter - this register does not exist */
#define R_DS		RR_AR2	/* second temporary address register, need during data initialisation */

#define NARGREGS	 4L	/* number of argument registers, should really be called NINTARGREGS */
#define NVARREGS	 4L	/* number of variable registers, should really be called NINTVARREGS */
#define NTEMPREGS	 6L	/* number of temporary registers, ... */  /* XXX see comment below */
#define MAXGLOBINTREG	17L	/* maximum index of integer registers ??? */

#define NFLTARGREGS	 2L	/* number of floating point argument registers */
#define NFLTVARREGS	 2L	/* number of floating point variable registers */
#define NFLTTEMPREGS	 0L	/* number of floating point variable registers */
#define MAXGLOBFLTREG	 7L	/* maximum index of floating point registers  */
#define NFLTREGS	 4L	/* number of floating point registers */

#define MAXREGNUMBER	28L	/* maximum legal value of a register */

#define NINTREGS	18L	/* number of "integer" registers */
#define NMAGICREGS	18L	/* maximum valid bit number for a compiler used register (see mip/defs.h) */

#define mask_of_regs_( start, length ) (regbit( start + length ) - regbit( start ))

#define M_VARREGS	mask_of_regs_( R_V1,  NVARREGS )
#define M_FVARREGS	mask_of_regs_( R_FV1, NFLTVARREGS )
#define M_INT_ARG_REGS  mask_of_regs_( R_A1,  NARGREGS )
#define M_FLT_ARG_REGS  mask_of_regs_( R_FA1, NFLTARGREGS )
#define M_ALL_ARG_REGS  (M_INT_ARG_REGS | M_FLT_ARG_REGS)
  
/* This macro is used by c40/gen.c to see if a register has a word address or a byte offset */

#define is_word_addressed_( r )	((r) == R_SP || (r) == R_FP)

/*
 * XXX - NC - 2/10/91
 *
 * What, I hear you cry, is going on ?
 *
 * Well, the situation is this.  mip/regalloc,c uses NMAGICREGS
 * as the NUMBER of registers available to the compiler, and it
 * expects to find this many registers in the ALLOCATION_ORDER
 * array.  What is more it expects the registers in this array
 * to be numbered from 0 to (NMAGICREGS - 1) in some indeterminate
 * order with NO OVERLAPS.  What is more the compiler also expects
 * the special register R_LR (the link register) to be a valid
 * register (ie with a number less than NMAGICREGS), BUT it does
 * not expect to find R_LR in the ALLOCATION_ORDER array!
 *
 * How do I cope, I hear you ask, (and for that matter, how on
 * earth do any of the other targets cope) ?  Well, I do not
 * know how other targets cope, but I have decided to make the link
 * register be one of the TEMPORARY registers available to the
 * compiler.  This way if it is used, it will be saved before calling
 * any other functions.  I have placed R_LR last
 * in the allocation order in the hopes that it will not be used
 * very often.  This does mean that NINTTMPREGS above is set to 6
 * rather than 5 (as might be assumed from the register allocation
 * scheme), so that the compiler knows that R_LR is a variable
 * register.
 */

#define ALLOCATION_ORDER {\
			   RR_R0,  RR_R1,  RR_R2,  RR_R3,	/* params in */   	\
			   RR_R10,		   		/* tmp       */   	\
			   RR_DP,  RR_BK,  RR_R8,  RR_R9,	/* var       */   	\
			   RR_AR0, RR_AR1, RR_AR2, RR_AR3, 	/* address or temp */  	\
			   RR_R4,  RR_R5,			/* flt params */	\
			   RR_R6,  RR_R7,			/* flt var */		\
			   RR_R11,				/* link register */	\
			   255 }

/* theses tests apply to the register numbering as defined by the 'C40, not the scheme above */

#define	is_extended_precision_register( r )	(((r) >= 0x00 && (r) <= 0x07) || ((r) >=  0x1c && (r) <= 0x1f))
#define	is_address_register( r )		 ((r) >= 0x08 && (r) <= 0x0F)
#define	is_index_register( r )			 ((r) >= 0x11 && (r) <= 0x12)

/*
 * decides if register is one of:
 *	address, index, SP, BK, DP
 */

#define	is_special_register( r )		 ((r) >= 0x08 && (r) <= 0x14)

/*
 * XXX - NC
 *
 * Oh Yez! Oh Yez! Oh Yez!
 *
 * Now hear this!
 *
 * We are going to have all pointers be BYTE offsets from
 * a base register (IR0), (where a BYTE is an 8 bit quantity)
 */

#define sizeof_char		1	/* a bit of a tautology, but what the hell */
#define sizeof_short		2
#define sizeof_int      	4
#define sizeof_long		4
#define sizeof_ptr		4
#define sizeof_float		4
#define sizeof_double		8
#define sizeof_ldble		8

#define alignof_short		2
#define alignof_int     	4
#define alignof_long		4
#define alignof_ptr		4
#define algn_of_float		4
#define alignof_double  	4
#define alignof_ldble		4
#define alignof_max		4
#define alignof_struct  	4
#define alignof_toplevel	4

#define NUM_BITS_PER_BYTE	8

/*
 * Finallly a word about doubles.
 *
 * When doubles are passed as arguments, they are passed in register pairs.
 * The pair is arranged in BIG ENDIAN order, (ie the lowered number register
 * of the pair contains the more significant value), because ....
 *
 * When doubles are pushed onto the stack they must be pushed low part then
 * high part, (since the instruction to load the high part (LDF) will overwrite
 * the low part, but the instruction to load the low part (LDI) will not
 * overwrite the high part).  This allows the doubles to be popped as high part
 * followed by low part.  Hence accessing doubles saved on the stack must also
 * use this same method - load high followed by low.  Thus argument registers,
 * when they are saved onto the stack, must be sure to conform to the same
 * convention.  Argument registers are pushed onto the stack in reverse order
 * (higher numbered registers first).  So the higher numbered register of
 * a double containing register pair must contain the lower significant part of
 * the double, as it will be pushed onto the stack first.  Hence a big endian
 * arrangement.
 */
 
#endif /* _c40target_LOADED */

/* end of c40/target.h */
@


1.76
log
@fixed (I hope) FP fast register conventions
@
text
@d6 1
a6 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/target.h,v 1.75 1993/07/23 08:41:57 nickc Exp nickc $ */
d92 1
a92 1
/* #define ADDRESS_REG_STUFF 				0 */	/* indicates seperate address and data regs */
d168 1
a168 1
 * Arguments:			R0,  R1, R2,  R3	 (arguments passed in to function)
d172 8
a179 8
 * Floating Point Var:		R6	 		(must not intersect argument or temporary registers)
 * Floating Point Tmp:  	R7			(must not intersect argument or variable  registers)
 * Universal Temporaries:	RS, RE, RC		
 * Link:			R11			 (honorary temporary and variable register)
 * Address:			AR0, AR1, AR2, AR3	 (address registers or temporary registers)
 * Module Table Pointer:	AR4
 * Temporary address:		AR5
 * User Stack Pointer:		AR6
a199 4

#ifdef ADDRESS_REG_STUFF
#define R_T1  		RR_R8	/* first temporary register */
#else
a200 2
#endif

d219 4
a222 14
#ifdef ADDRESS_REG_STUFF
#define NARGREGS	 4L	/* number of argument registers */
#define NVARREGS	 6L	/* number of variable registers */
#define NTEMPREGS	 4L	/* number of temporary registers */ /* XXX see comment below */
#define NADDRREGS	 4L	/* number of address registers */
#define MAXGLOBINTREG	13L	/* maximum number of integer registers ??? */
#else
#define NARGREGS	 4L	/* number of argument registers */

#define NVARREGS	 4L	/* number of variable registers */
#define NTEMPREGS	 6L	/* number of temporary registers */  /* XXX see comment below */

#define MAXGLOBINTREG	17L	/* maximum number of integer registers ??? */
#endif /* ADDRESS_REG_STUFF */
d227 1
a227 1
#define MAXGLOBFLTREG	 4L	/* maximum number of floating point registers  */
d235 1
a235 2
#define M_VARREGS	((1L << (R_V1 + NVARREGS))          - (1L << R_V1))	/* mask of variable regs */
#define M_FVARREGS	((1L << (R_FV1 + NFLTVARREGS)) - (1L << R_FV1))		/* mask of FP var registers */
d237 6
d269 2
a270 2
 * very often.  This does mean that NTMPREGS above is set to 10
 * rather than 9 (as might be assumed from the register allocation
d276 7
a282 5
			   RR_R0,  RR_R1,  RR_R2,  RR_R3,		/* params in */   	\
			   RR_R6,  RR_R7,  RR_R10, 		 	/* tmp       */   	\
			   RR_R4,  RR_R5,  RR_DP,  RR_BK, RR_R8, RR_R9,	/* var       */   	\
			   RR_AR0, RR_AR1, RR_AR2, RR_AR3, 		/* address or temp */  	\
			   RR_R11,					/* link register */	\
@


1.75
log
@added floating point argument registers
@
text
@d6 1
a6 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/target.h,v 1.74 1993/07/22 10:05:46 nickc Exp nickc $ */
d98 1
a168 7
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
 * Variables:			R4,  R5, R6,  R7, BK, DP (saved on function entry)
 * Temporaries:			R8,  R9, R10		 (saved before function call)
 * Floating Point Arg:		R0 - R1, R2 - R3	 (must not intersect variable or temporary registers)
 * Floating Point Var:		R4 - R5, R6 - R7	 (must not intersect argument or temporary registers)
 * Floating Point Tmp:  	R8 - R9			 (must not intersect argument or variable  registers)
#else
d171 3
a173 4
 * Floating Point Arg:					(must not intersect variable or temporary registers)
 * Floating Point Var:		R4, R5	 		(must not intersect argument or temporary registers)
 * Floating Point Tmp:  	R6, R7			(must not intersect argument or variable  registers)
#endif
a206 7
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
#define R_V1  		RR_R4	/* first variable register */
#define R_FA1		RR_R0	/* first floating point argument register */
#define R_F1		RR_R0	/* first floating point register */
#define R_FV1		RR_R4	/* first floating point variable register */
#define R_FT1		RR_R8	/* first floating point temporary register */
#else
d208 1
a208 1
#define R_FA1		RR_R6	/* first floating point argument register */
d210 2
a211 3
#define R_FV1		RR_R4	/* first floating point variable register */
#define R_FT1		RR_R6	/* first floating point temporary register */
#endif
d216 2
a217 2
#define R_MT		RR_AR4	/* module table pointer */	/* XXX - NB/ ccc40/linker/genimage.c relies on this value */
#define R_ATMP		RR_AR5	/* temporary address register *//* XXX - NB/ ccc40/linker/genimage.c relies on this value */
a233 4
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
#define NVARREGS	 6L	/* number of variable registers */
#define NTEMPREGS	 8L	/* number of temporary registers */  /* XXX see comment below */
#else
a235 1
#endif
a239 1
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
a241 6
#define NFLTTEMPREGS	 1L	/* number of floating point variable registers */
#define MAXGLOBFLTREG	 5L	/* maximum number of floating point registers  */
#define NFLTREGS	 5L	/* number of floating point registers */
#else
#define NFLTARGREGS	 2L	/* number of floating point argument registers */
#define NFLTVARREGS	 2L	/* number of floating point variable registers */
a244 1
#endif
d251 1
a251 4
#define M_VARREGS	((1L << (R_V1 + NVARREGS))          - (1L << R_V1))	/* mask of variable registers */
#ifdef TARGET_SHARES_INTEGER_AND_FP_REGISTERS
#define M_FVARREGS	((1L << (R_FV1 + (NFLTVARREGS * 2))) - (1L << R_FV1))	/* mask of FP var registers */
#else
a252 1
#endif
@


1.74
log
@added TARGET_FP_ARGS_IN_FP_REGS
@
text
@d6 1
a6 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/target.h,v 1.73 1993/07/14 13:23:18 nickc Exp nickc $ */
d28 1
a28 1
   #define TARGET_HAS_COND_EXEC				1	/* can do conditionally execution */
d59 1
a59 1
   #define TARGET_ALLOWS_COMPARE_CSES			1
d222 1
a222 1
#define R_FA1		RR_R0	/* first floating point argument register */
d267 1
a267 1
#define NFLTARGREGS	 0L	/* number of floating point argument registers */
d269 1
a269 1
#define NFLTTEMPREGS	 2L	/* number of floating point variable registers */
@


1.73
log
@added new stub enable
@
text
@d6 1
a6 1
/* $Header: /hsrc/cmds/cc/ncc/cc420/mbe/RCS/target.h,v 1.72 1993/07/08 08:26:12 nickc Exp nickc $ */
d61 1
@


1.72
log
@removed TARGET_HAS_ROTATES as C40 rotates are too puny
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350B/mbe/RCS/target.h,v 1.71 1993/07/07 10:39:48 nickc Exp nickc $ */
d63 1
@


1.71
log
@experimental inclusion of TARGET_ALLOWS_COMPARE_CSES and TARGET_HAS_ROTATE
@
text
@d6 1
a6 1
/* $Header: /scratch/nickc/ncc/cc350B/mbe/RCS/target.h,v 1.70 1993/06/10 15:54:55 nickc Exp nickc $ */
a31 1
   #define TARGET_HAS_ROTATE                            1	/* supports a rotate instruction */
d52 1
@


1.70
log
@fixed byte ordering on RS6000
@
text
@d6 1
a6 1
/* $Header: /hsrc/cmds/cc/ncc/cc350B/mbe/RCS/target.h,v 1.69 1992/06/11 17:09:23 nickc Exp nickc $ */
d28 1
d32 3
a36 3
   #define TARGET_HAS_SEPARATE_CODE_DATA_SEGS		1	/* because of seperqte address buses */
   #define TARGET_HAS_SIGN_EXTEND			1	/* XXX we can fake it */
   #define TARGET_HAS_COND_EXEC				1	/* instructions can be conditionally executed */
d59 1
d76 1
@


1.69
log
@added a new pseudo register RR_PST (value 29)
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/target.h,v 1.68 1992/06/04 09:48:34 nickc Exp nickc $ */
d94 1
a94 1
#ifdef __hp9000s700
@


1.68
log
@enabled inline FP divide
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/target.h,v 1.67 1992/05/20 17:07:22 nickc Exp nickc $ */
d122 1
a122 1
 * Number:	|  8 |  9 | |  22 |  23 | | 24 | 25 | | 26 | 27 | 28 | | 31 |
d154 1
@


1.67
log
@hmm, changed REVERSE_OBJECT_BYTE_ORDER again
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/target.h,v 1.66 1992/05/20 13:54:52 nickc Exp nickc $ */
a59 1
   #define TARGET_LACKS_FP_DIVIDE			1 	
d68 1
@


1.66
log
@removed REVERSE_OBJECT_BYTE_ORDER
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/target.h,v 1.65 1992/05/07 13:42:48 nickc Exp nickc $ */
d94 3
a96 1
/* #define REVERSE_OBJECT_BYTE_ORDER			0 */	/* no longer needed by C40 back end */
@


1.65
log
@tidied up comments
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/target.h,v 1.64 1992/04/22 17:27:20 nickc Exp nickc $ */
d94 1
a94 3
#ifndef __HELIOS_C40
   #define REVERSE_OBJECT_BYTE_ORDER			1	/* XXX - compiling for big endian host */
#endif
@


1.64
log
@unknown changes
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/target.h,v 1.63 1992/04/14 09:19:25 nickc Exp nickc $ */
d33 1
a33 1
   #define TARGET_HAS_SEPARATE_CODE_DATA_SEGS		1	/* indicates that code and data must be kept seperate */
d41 1
a41 1
/* #define TARGET_HAS_BYTE_INSTRUCTIONS			0 */	/* XXX - well, maybe we do */
d45 1
a45 1
/* #define TARGET_HAS_HALFWORD_INSTRUCTIONS		0 */	/* XXX implies that shorts are supported */
a61 1
/* #define TARGET_SHARES_INTEGER_AND_FP_REGISTERS	0 */ 	/* not removed, despite advice from AM */
d81 1
d88 1
d92 1
a92 1
   #define NO_INSTORE_FILES
d94 1
a94 1
#ifndef __CC_NORCROFT
@


1.63
log
@improved comment
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/experimental/mbe/RCS/target.h,v 1.62 1992/03/31 17:53:12 nickc Exp nickc $ */
d93 3
a95 1
   #define REVERSE_OBJECT_BYTE_ORDER			1	/* XXX - forces strings inserted into code buffer to be byte reversed */
@


1.62
log
@added TARGET_HAS_DEBUGGER
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/experimental/c40/RCS/target.h,v 1.61 1992/03/20 18:22:14 nickc Exp nickc $ */
d101 1
a101 1
 * Register Ordering	(cf hardware_register() in c40/gen.c)
d185 6
a190 1
 * XXX - following definitions must agree with those in /helios/include/ampp/c40.m
@


1.61
log
@improved comment
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.60 1992/03/19 17:43:56 nickc Exp nickc $ */
d16 1
a16 1
/* #define TARGET_IS_BIG_ENDIAN    			0 */
d25 1
a25 1
   #undef  TARGET_HAS_DEBUGGER
d336 1
a336 1

@


1.60
log
@oops had RR_R6 twice in ALLOCATIO_ORDER
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.59 1992/03/19 16:38:46 nickc Exp nickc $ */
d184 3
a186 1
/* XXX - following definitions must agree with those in c40/c40.m */
@


1.59
log
@changed register numbering slightly
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.58 1992/03/18 09:56:17 nickc Exp nickc $ */
d304 1
a304 1
			   RR_R6,  RR_R6,  RR_R10, 		 	/* tmp       */   	\
@


1.58
log
@removed special case for DP in is_special_register()
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.57 1992/03/16 16:30:35 nickc Exp nickc $ */
d107 3
a109 3
 * Name:	 R0 |  R1 |  R2 |  R3 | | R4 |  R5 |  R6 |  R7 | | R8 |  R9 | R10 | R11 
 *              -----------------------  ----------------------   ---------------- ----
 * Number:	  0 |   1 |   2 |   3 | |  4 |   5 |   6 |   7 | | 14 |  15 |  16 |  17
d112 3
a114 3
 * Name:	AR0 | AR1 | AR2 | AR3 | | AR4 | AR5 | AR6 | AR7 
 *		----------------------   ----------------------
 * Number:	 10 |  11 |  12 |  13 | |  18 |  19 |  20 |  21 
d117 3
a119 3
 * Name:	 DP | | IR0 | IR1 | | BK | | SP | ST | RS | RE | RC | PC
 *		----   -----------   ----   ----------------------------
 * Number:	  8 | |  22 |  23 | |  9 | | 24 | 25 | 26 | 27 | 28 | 31
d130 3
a132 3
#define RR_R8	14
#define RR_R9	15
#define RR_R10	16
d134 4
a137 4
#define RR_AR0	10
#define RR_AR1	11
#define RR_AR2	12
#define RR_AR3	13
d166 1
a166 1
 * Variables:			R6,  R7, BK, DP 	(saved on function entry)
d170 1
a170 1
 * Floating Point Tmp:  	R8, R9			(must not intersect argument or variable  registers)
d195 1
a195 1
#define R_T1  		RR_AR0	/* first temporary register */
d205 1
a205 1
#define R_V1  		RR_R6	/* first variable register */
d209 1
a209 1
#define R_FT1		RR_R8	/* first floating point temporary register */
d304 2
a305 2
			   RR_R8,  RR_R9,  RR_R10, 		 	/* tmp       */   	\
			   RR_R4,  RR_R5,  RR_R6,  RR_R7, RR_DP, RR_BK,	/* var       */   	\
@


1.57
log
@added comment
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.56 1992/03/16 12:18:51 nickc Exp nickc $ */
d318 1
a318 6
 *	address, index, SP, BK
 * 
 * NB/ DP is not part of this group
 * because the LDA instruction is
 * unsigned for this register, not signed
 *
d320 2
a321 1
#define	is_special_register( r )		 ((r) >= 0x08 && (r) <= 0x14 && (r) != 0x10)
@


1.56
log
@fixed N_FVARREGS
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.55 1992/03/13 16:26:39 nickc Exp nickc $ */
d187 1
a187 1
#define R_A1result 	RR_R0	/* result of function left here */
d360 21
@


1.55
log
@oops, forgot to updated variable register start
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.54 1992/03/13 15:59:55 nickc Exp nickc $ */
d168 1
d264 5
a268 1
#define M_FVARREGS	((1L << (R_F1 + (NFLTVARREGS * 2))) - (1L << R_F1))	/* mask of fp variable registers */
@


1.54
log
@removed TARGET_SHARES_INTEGER_AND_FP_REGISTERS (again)
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.53 1992/02/28 12:09:25 nickc Exp nickc $ */
a189 1
#define R_V1  		RR_R4	/* first variable register */
d198 1
d204 1
@


1.53
log
@changed register allocation scheme, now has 6 variables and 7 temporaries
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.52 1992/02/27 14:09:33 nickc Exp nickc $ */
d62 1
a62 1
   #define TARGET_SHARES_INTEGER_AND_FP_REGISTERS	1 	/* not removed, despite advice from AM */
d159 1
d165 6
a186 1
#define R_FA1		RR_R0	/* first floating point argument register */
d191 1
a191 2
#define R_F1		RR_R4	/* first floating point variable register */
#define R_FV1		RR_R4	/* first floating point variable register */
d197 10
d208 2
d230 2
d234 5
d242 14
a255 4
#define NFLTARGREGS	 2L	/* number of floating point argument registers ??? */
#define NFLTVARREGS	 2L	/* number of floating point variable registers ??? */
#define NFLTTEMPREGS	 1L	/* number of floating point variable registers ??? */
#define MAXGLOBFLTREG	 5L	/* maximum number of floating point registers ??? */
a258 1
#define NFLTREGS	 5L	/* number of floating point registers */
@


1.52
log
@changed register naming to allow address registers to be used as avraible registers
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.51 1992/02/26 17:34:33 nickc Exp nickc $ */
d102 2
a103 2
 * Version:		6
 * Date:		3/10/91
d107 3
a109 3
 * Name:	 R0 |  R1 |  R2 |  R3 |  R4 |  R5 |  R6 |  R7 | | R8 |  R9 | R10 | | R11 
 *              ----------------------------------------------   ----------------   ----
 * Number:	  0 |   1 |   2 |   3 |   4 |   5 |   6 |   7 | | 12 |  13 |  14 | |  17
d114 1
a114 1
 * Number:	  8 |   9 |  10 |  11 | |  18 |  19 |  20 |  21 
d119 1
a119 1
 * Number:	 15 | |  22 |  23 | | 16 | | 24 | 25 | 26 | 27 | 28 | 31
d130 8
a137 8
#define RR_R8	12
#define RR_R9	13
#define RR_R10	14
#define RR_R11	17	/* discontinuity because link register is an honorary variable register */
#define RR_AR0	 8
#define RR_AR1	 9
#define RR_AR2	10
#define RR_AR3	11
d142 1
a142 1
#define RR_DP	15
d145 1
a145 1
#define RR_BK	16
d158 6
a163 6
 * Arguments:			R0,  R1, R2,  R3	(arguments passed in to function)
 * Variables:			R4,  R5, R6,  R7	(saved on function entry)
 * Temporaries:			R8,  R9, R10, BK, DP	(saved before function call)
 * Floating Point Arg:		R0 - R1, R2 - R3	(must not intersect variable or temporary register sets)
 * Floating Point Var:		R4 - R5, R6 - R7	(must not intersect argument or temporary register sets)
 * Floating Point Tmp:  	R8 - R9			(must not intersect argument or variable  register sets)
d165 2
a166 2
 * Link:			R11			(and honorary temporary register)
 * Address:			AR0, AR1, AR2, AR3	(address registers or honary variable registers)
d187 1
d189 3
d193 1
a193 1
#define R_IP		RR_BK	/* XXX WHAT IS THIS REGISTER ? */ /* cf regalloc.c line 2131 */
d207 2
a208 2
#define NVARREGS	 4L	/* number of variable registers */
#define NTEMPREGS	 6L	/* number of temporary registers */ /* XXX see comment below */
d213 2
a214 2
#define NVARREGS	 8L	/* number of variable registers */
#define NTEMPREGS	 6L	/* number of temporary registers */  /* XXX see comment below */
d218 4
a221 4
#define NFLTARGREGS	2L	/* number of floating point argument registers ??? */
#define NFLTVARREGS	2L	/* number of floating point variable registers ??? */
#define NFLTTEMPREGS	1L	/* number of floating point variable registers ??? */
#define MAXGLOBFLTREG	5L	/* maximum number of floating point registers ??? */
d225 1
a225 1
#define NFLTREGS	5L	/* number of floating point registers */
d257 2
a258 2
 * very often.  This does mean that NTMPREGS above is set to 6
 * rather than 5 (as might be assumed from the register allocation
d265 3
a267 3
			   RR_R8,  RR_R9,  RR_R10, RR_BK, RR_DP, 	/* tmp       */   	\
			   RR_R4,  RR_R5,  RR_R6,  RR_R7, 		/* var       */   	\
			   RR_AR0, RR_AR1, RR_AR2, RR_AR3, 		/* address or var */   	\
@


1.51
log
@removed TARGET_LDRK_MAX as kit is not needed
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.50 1992/02/25 17:42:56 nickc Exp nickc $ */
d35 2
a41 2
 #define TARGET_HAS_COND_EXEC				1	/* instructions can be conditionally executed */
 #define TARGET_ONLY_HAS_CONDITIONAL_LOAD		1	/* but only for load instructions */
d62 1
d65 1
a65 1
/* #define TARGET_CORRUPTS_SWITCH_REGISTER 		0 */	/* indicates that a switch instruction might corrupt index register */
d71 1
a71 1
/* #define TARGET_LACKS_MULDIV_LITERALS			0 */	/* indicates that we cannot multiply a register by a constant */
d82 1
a82 2
   #define TARGET_SHARES_INTEGER_AND_FP_REGISTERS	1 	/* XXX - not removed, despite recommendation from AM */
/* #define TARGET_STACKS_LINK				0 */	/* implies that link address is automatically placed on stack */
d107 3
a109 3
 * Name:	 R0 |  R1 |  R2 |  R3 |  R4 |  R5 |  R6 |  R7 |  R8 |  R9 | R10 |  R11 
 *              -----------------------------------------------------------------  ---
 * Number:	  0 |   1 |   2 |   3 |   4 |   5 |   6 |   7 |   9 |   10 |  11 |   8
d112 3
a114 3
 * Name:	AR0 | AR1 | AR2 | AR3 |  AR4 | AR5 | AR6 | AR7 
 *		-----------------------  ---------------------
 * Number:	 14 |  15 |  16 |  17 |   18 |  19 |  20 |  21 
d117 3
a119 3
 * Name:	 DP | IR0 | IR1 |  BK | SP | ST | RS | RE | RC | PC
 *		----------------------------------------------------
 * Number:	 12 |  22 |  23 |  13 | 24 | 25 | 26 | 27 | 28 | 31
d130 8
a137 8
#define RR_R8	 9
#define RR_R9	10
#define RR_R10	11
#define RR_R11	 8	/* discontinuity because link register is an honorary variable register */
#define RR_AR0	14
#define RR_AR1	15
#define RR_AR2	16
#define RR_AR3	17
d142 1
a142 1
#define RR_DP	12
d145 1
a145 1
#define RR_BK	13
d165 2
a166 2
 * Link:			R11			(and honorary variable register)
 * Address:			AR0, AR1, AR2, AR3,
d171 1
a171 1
 * Addressing Base:		IR0		(start address of memory available to process) (NB/ this is hard coded in gen.c)
d201 13
a213 3
#define NARGREGS	4L	/* number of argument registers */
#define NVARREGS	5L	/* number of variable registers */ /* XXX see comment below */
#define NTEMPREGS	5L	/* number of temporary registers */
a216 4
#ifdef ADDRESS_REG_STUFF
#define NADDRREGS	4L	/* number of address registers */
#endif
#define MAXGLOBINTREG	13L	/* maximum number of integer registers ??? */
d249 3
a251 3
 * register be one of the VARIABLE registers available to the
 * compiler.  This way if it is used, it will be saved by the
 * compiler upon entry to the function.  I have placed R_LR last
d253 2
a254 2
 * very often.  This does mean that NVARREGS above is set to 5
 * rather than 4 (as might be assumed from the register allocation
d263 1
a263 1
			   RR_AR0, RR_AR1, RR_AR2, RR_AR3, 		/* address   */   	\
@


1.50
log
@fixed number of floating point temporaries
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.49 1992/02/21 18:36:58 nickc Exp nickc $ */
d26 1
a60 2
   #define TARGET_LDRK_MAX 				(0xffL)	/* XXX - is this really 0xff (8 bit displacements in indirect mode) */
   #define TARGET_LDRK_MIN 				(-TARGET_LDRK_MAX - 1)
d76 2
@


1.49
log
@enabled TARGET_HAS_COND_EXEC and added TARGET_ONLY_CONDITIONAL_LOAD
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.48 1992/02/21 11:32:33 nickc Exp nickc $ */
d162 1
a162 1
 * Floating Point Tmp:  	R8 - R9, R10- BK	(must not intersect argument or variable  register sets)
d205 1
a205 1
#define NFLTTEMPREGS	2L	/* number of floating point variable registers ??? */
d210 1
a210 1
#define MAXGLOBFLTREG	6L	/* maximum number of floating point registers ??? */
d214 1
a214 1
#define NFLTREGS	6L	/* number of floating point registers */
@


1.48
log
@removed TARGET_LACKS_UNSIGNED_FIX
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.47 1992/02/20 17:02:40 nickc Exp nickc $ */
d39 2
a40 1
/* #define TARGET_HAS_COND_EXEC				0 */	/* ie instructions can be conditionally executed */
@


1.47
log
@removed spurious define
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.46 1992/02/19 14:49:43 nickc Exp nickc $ */
a58 1
   #define TARGET_LACKS_UNSIGNED_FIX 			1
d75 1
@


1.46
log
@enabled TARGET_HAS_SIGN_EXTEND
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.45 1992/02/17 16:12:13 nickc Exp nickc $ */
a38 1
/* #define TARGET_HAS_CONDITIONAL_EXECUTION		0 */	/* XXX - this does not appear to be used in the code generator */
@


1.45
log
@changed definition of NFLTREGS
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.44 1992/02/12 11:27:33 nickc Exp nickc $ */
d33 1
a53 1
/* #define TARGET_HAS_SIGN_EXTEND			0 */
d206 1
d208 1
@


1.44
log
@improved a comment
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.43 1992/02/11 17:48:26 nickc Exp nickc $ */
d212 1
a212 1
#define NFLTREGS	12L	/* number of floating point registers (times 2 because they come in pairs) */
@


1.43
log
@added a non existant define
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.42 1992/02/11 17:40:14 nickc Exp nickc $ */
d198 1
a198 1
#define R_DS		RR_AR2	/* XXX WHAT IS THIS REGISTER - (it is used during data initialisation) */
@


1.42
log
@weelll,  I have change NFLTREGS .....  (err)
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.41 1992/02/03 17:32:03 nickc Exp nickc $ */
d93 2
@


1.41
log
@oops, added missing comma
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.40 1992/02/03 17:31:41 nickc Exp nickc $ */
d27 1
a42 1
/* #define TARGET_HAS_FP_LITERALS			0 */	/* ie FP constants can be included in OP codes */
d46 2
a47 2
/* #define TARGET_HAS_NON_FORTRAN_DIVIDE		0 */	/* XXX - we do not have any divide instructions ... */
/* #define TARGET_HAS_OTHER_IEEE_ORDER			0 */	/* indicates that double FP constants are stored big-endian */
d209 2
a210 2
#define NINTREGS	18L	/* number of "integer" registers, see mip/defs.h line 86 and mip/cgdefs.h line 147 */
#define NFLTREGS	 6L	/* number of floating point registers */
@


1.40
log
@resarranged order of ALLOCATION_ORDER (again)
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.39 1992/02/03 14:32:14 nickc Exp nickc $ */
d250 1
a250 1
			   RR_R8,  RR_R9,  RR_R10, RR_BK, RR_DP 	/* tmp       */   	\
@


1.39
log
@re-enabled TARGET_SHARES_INTEGER_AND_FP_REGISTERS
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.38 1992/01/31 18:12:36 nickc Exp nickc $ */
d250 1
a250 1
			   RR_BK,  RR_DP,  RR_R8,  RR_R9,  RR_R10, 	/* tmp       */   	\
@


1.38
log
@unknown changes
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.37 1992/01/23 13:04:40 nickc Exp nickc $ */
d80 1
a80 1
/* #define TARGET_SHARES_INTEGER_AND_FP_REGISTERS	0 */	/* XXX - removed on recommendation from AM */
@


1.37
log
@edited some comments
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.36 1992/01/16 17:56:03 nickc Exp nickc $ */
d261 1
@


1.36
log
@enabled REVERSE_OBJECT_BYTE_ORDER
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.35 1992/01/16 17:36:29 nickc Exp nickc $ */
d158 3
a160 3
 * Floating Point Arg:		R0 - R1, R2 - R3	(must not intersect integer variable or temporary register sets)
 * Floating Point Var:		R4 - R5, R6 - R7	(must not intersect integer argument or temporary register sets)
 * Floating Point Tmp:  	R8 - R9, R10- BK	(must not intersect integer argument or variable  register sets)
d186 1
a186 1
#define R_IP		RR_BK	/* XXX WHAT IS THIS REGISTER ? */ /*regalloc.c line 2131 suggests it is part of temp regs */
@


1.35
log
@reversed previous delta
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.34 1992/01/16 16:38:41 nickc Exp nickc $ */
d92 2
a93 3
#ifdef __hp9000s700						/* XXX - actually should define whenever host is BIG endian */
/* #define REVERSE_OBJECT_BYTE_ORDER			0 */	/* XXX - forces strings inserted into code buffer to be byte reversed */
#endif
@


1.34
log
@changed to big endian format
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.33 1991/12/11 16:00:05 nickc Exp nickc $ */
d16 2
a17 2
   #define TARGET_IS_BIG_ENDIAN    			1  	/* because of C40 byte instructions */
/* #define TARGET_IS_LITTLE_ENDIAN    			0 */
@


1.33
log
@hmm
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.32 1991/12/04 18:32:45 nickc Exp nickc $ */
d16 2
a17 2
/* #define TARGET_IS_BIG_ENDIAN    			0 */	
   #define TARGET_IS_LITTLE_ENDIAN    			1 	/* XXX (semi-) arbitary choice */
@


1.32
log
@minor cosmetic changes
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.31 1991/10/28 17:52:27 nickc Exp nickc $ */
d93 1
a93 1
   #define REVERSE_OBJECT_BYTE_ORDER				/* XXX - forces strings inserted into code buffer to be byte reversed */
d149 1
a149 1
#define RR_PC	31	/* pseudo register used by peepholer register checkers */
@


1.31
log
@added warning about consistency with c40/c40.m
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.30 1991/10/28 15:28:55 nickc Exp nickc $ */
a10 1
#define TARGET_IS_C40			1
d12 1
a12 1
#define TARGET_PREDEFINES 		{"__C40", "__CLK_TCK=1000", "__JMP_BUF_SIZE=22"}
d14 5
a22 3
/* #define TARGET_IS_BIG_ENDIAN    			0 */	
   #define TARGET_IS_LITTLE_ENDIAN    			1 	/* XXX (semi-) arbitary choice */

d30 1
a30 1
   #define TARGET_HAS_TAILCALLR 			1	/* XXX - hmm, not sure about this one - time will tell */
@


1.30
log
@rearranged order of temporaries in allocation order to promote use of LDA
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.29 1991/10/23 14:51:23 nickc Exp nickc $ */
d172 3
a174 1
 
@


1.29
log
@added R_SE
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.28 1991/10/18 15:55:49 nickc Exp nickc $ */
d248 1
a248 1
			   RR_R8,  RR_R9,  RR_R10, RR_BK, RR_DP,	/* tmp       */   	\
@


1.28
log
@added REVERSE_OBJECT_BYTE_ORDER because snake is big-endian
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.27 1991/10/11 15:16:10 nickc Exp nickc $ */
d192 1
@


1.27
log
@removed DP from is_special_register() because of inconsistencies in the documentation
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.26 1991/10/10 14:42:32 nickc Exp nickc $ */
d90 4
@


1.26
log
@undid previous fix as it was bogus!
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.25 1991/10/10 13:52:04 nickc Exp nickc $ */
d254 10
a263 1
#define	is_special_register( r )		 ((r) >= 0x08 && (r) <= 0x14)	/* address, index, DP, SP, BK */
@


1.25
log
@fixed calculation of M_ macros
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.24 1991/10/07 16:16:44 nickc Exp nickc $ */
d206 2
a207 2
#define M_VARREGS	((1L << (R_V1 + NVARREGS + 1))          - (1L << R_V1))	/* mask of variable registers */
#define M_FVARREGS	((1L << (R_F1 + (NFLTVARREGS * 2) + 1)) - (1L << R_F1))	/* mask of fp variable registers */
d243 1
a244 1
			   RR_R8,  RR_R9,  RR_R10, RR_BK, RR_DP,	/* tmp       */   	\
@


1.24
log
@changed to falling stack
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.23 1991/10/04 13:21:17 nickc Exp nickc $ */
d19 2
a20 2
/* #define TARGET_IS_BIG_ENDIAN    			0 */	/* XXX is this right ? nope, the machine is really un-endian! */
   #define TARGET_IS_LITTLE_ENDIAN    			1 	/* XXX is this right ? nope, the machine is really un-endian! */
a25 1
/* #define TARGET_HAS_BSS 				0 */	/* XXX - do we ? */
d30 1
a30 1
/* #define TARGET_HAS_RISING_STACK			0 */	/* XXX - added by NC, see c40/flowgraf.c */
d34 1
d48 1
a51 1
#define TARGET_HAS_SEPARATE_CODE_DATA_SEGS		1	/* indicates that code and data must be kept seperate */
d58 1
a58 1
   #define TARGET_LACKS_FP_DIVIDE			1 	/* XXX - removed because of bugs in cg.c line 873 */
a62 2
/* #define TARGET_SHARES_INTEGER_AND_FP_REGISTERS	0 */	/* XXX - removed on recommendation from AM */
/* #define TARGET_R0_ALWAYS_ZERO 			0 */	
d78 2
d85 1
a85 2
/* #define ADDRESS_REG_STUFF 				1 */	/* XXX - do I want this ? - stolen from 68k version */

d87 1
a87 1
/*   #define DO_NOT_OPTIMISE_CHAR_AND_SHORT_ARITHMETIC 	0 */	/* XXX - experimentally put in */
d206 2
a207 2
#define M_VARREGS	(1L << (R_V1 + NVARREGS))    - (1L << R_V1)	/* mask of variable registers */
#define M_FVARREGS	(1L << (R_F1 + NFLTVARREGS)) - (1L << R_F1)	/* mask of fp variable registers */
@


1.23
log
@added new define TARGET_HAS_RISING_STACK
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.22 1991/10/04 12:39:56 nickc Exp nickc $ */
d31 1
a31 1
   #define TARGET_HAS_RISING_STACK			1	/* XXX - added by NC, see c40/flowgraf.c */
d82 1
a82 1
/* #define TARGET_STRUCT_RESULT_REGISTER		0 */	/* indicates that result register cannot be used for structs */
@


1.22
log
@oops previous delat was because i added a new macro, this delat fixes typos
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.21 1991/10/04 12:38:45 nickc Exp nickc $ */
d31 1
@


1.21
log
@unknown
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.20 1991/10/03 14:24:48 nickc Exp nickc $ */
d234 1
a234 1
 * in the allocatio  order in the hopes that it will not be used
d237 1
a237 1
 * scheme), so that the compiler knowns that R_LR is a variable
@


1.20
log
@minor typo fixed
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.19 1991/10/03 13:24:09 nickc Exp nickc $ */
d209 1
d211 2
d241 2
a242 1
#define ALLOCATION_ORDER { RR_R0,  RR_R1,  RR_R2,  RR_R3,		/* params in */   	\
@


1.19
log
@added date to version information
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.18 1991/10/02 11:05:29 nickc Exp nickc $ */
d161 1
a161 1
 * Temporary addresses:		AR5
@


1.18
log
@fixed (I hope) register allocation for the last time
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.17 1991/10/02 09:21:19 nickc Exp nickc $ */
d96 1
@


1.17
log
@updated to fix minor register naming bug
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.16 1991/10/01 09:37:29 nickc Exp nickc $ */
d101 1
a101 1
 * Number:	  0 |   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 |   21
d106 1
a106 1
 * Number:	 13 |  14 |  15 |  16 |   17 |  18 |  19 |  20 
d111 1
a111 1
 * Number:	 12 |  22 |  23 |  11 | 24 | 25 | 26 | 27 | 28 | 31
d122 12
a133 12
#define RR_R8	 8
#define RR_R9	 9
#define RR_R10	10
#define RR_R11	21	/* discontinuity because temporary registers need to be contiguous */
#define RR_AR0	13
#define RR_AR1	14
#define RR_AR2	15
#define RR_AR3	16
#define RR_AR4	17
#define RR_AR5	18
#define RR_AR6	19
#define RR_AR7	20
d137 1
a137 1
#define RR_BK	11
d151 2
a152 2
 * Variables:			R4,  R5, R6,  R7	(saved by callee)
 * Temporaries:			R8,  R9, R10, BK, DP	(saved by caller)
d157 1
a157 1
 * Link:			R11
d180 1
a180 1
#define R_LR  		RR_R11 	/* Link register */ /* NB/ must not equal NMAGICREGS */
d191 1
a191 1
#define NVARREGS	4L	/* number of variable registers */
d201 1
a201 1
#define NINTREGS	17L	/* number of "integer" registers, see mip/defs.h line 86 and mip/cgdefs.h line 147 */
d203 1
a203 1
#define NMAGICREGS	17L	/* maximum valid bit number for a compiler used register (see mip/defs.h) */
d209 33
a241 4
#define ALLOCATION_ORDER { RR_R0,  RR_R1,  RR_R2,  RR_R3,	/* params in */   \
			   RR_R4,  RR_R5,  RR_R6,  RR_R7, 	/* var       */   \
			   RR_R8,  RR_R9,  RR_R10, RR_BK, RR_DP,/* tmp       */   \
			   RR_AR0, RR_AR1, RR_AR2, RR_AR3, 	/* address   */   \
@


1.16
log
@removed BSS option and forced code and data to be seperate
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.15 1991/09/25 12:47:59 nickc Exp nickc $ */
d95 1
a95 1
 * Version:		5
d99 3
a101 3
 * Name:	 R0 |  R1 |  R2 |  R3 |  R4 |  R5 |  R6 |  R7 |  R8 |  R9 | R10 | R11 
 *              ---------------------------------------------------------------------
 * Number:	  0 |   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 |  13
d104 3
a106 3
 * Name:	AR0 | AR1 | AR2 | AR3 | AR4 | AR5 | AR6 | AR7 
 *		---------------------------------------------
 * Number:	 14 |  15 |  16 |  17 |  18 |  19 |  20 |  21 
d125 9
a133 9
#define RR_R11	13	/* NB/ discontinuity because temporary registers need to be contiguous */
#define RR_AR0	14
#define RR_AR1	15
#define RR_AR2	16
#define RR_AR3	17
#define RR_AR4	18
#define RR_AR5	19
#define RR_AR6	20
#define RR_AR7	21
d180 1
a180 1
#define R_LR  		RR_R11 	/* Link register */
d201 1
a201 1
#define NINTREGS	16L	/* number of "integer" registers, see mip/defs.h line 86 and mip/cgdefs.h line 147 */
@


1.15
log
@removed address reg stuff in an experiment to see if this produces better code
@
text
@d6 1
a6 1
/* $Header: /users/nickc/ncc/cc350/c40/RCS/target.h,v 1.14 1991/09/20 17:18:29 nickc Exp nickc $ */
d26 1
a26 1
   #define TARGET_HAS_BSS 				0	/* XXX - do we ? */
d50 1
a50 1
/* #define TARGET_HAS_SEPARATE_CODE_DATA_SEGS		0 */	/* indicates that code and data must be kept seperate */
d87 1
a87 1
   #define DO_NOT_OPTIMISE_CHAR_AND_SHORT_ARITHMETIC 	1
d188 1
a188 1
#define R_DS		RR_IR1	/* XXX WHAT IS THIS REGISTER - display pointer ??? */
@


1.14
log
@removed DP as a zero register - it is now a full fledged temporary
@
text
@d6 1
a6 1
/* $Header$ */
d84 1
a84 1
   #define ADDRESS_REG_STUFF 				1 	/* XXX - do I want this ? - stolen from 68k version */
@


1.13
log
@added pseudo register RR_PC
@
text
@d5 2
a6 1
/* version 4 */
a7 1

d63 1
a63 1
   #define TARGET_R0_ALWAYS_ZERO 			1	/* XXX - we are faking this with the DP */
d95 1
a95 1
 * Version:		4
d101 1
a101 1
 * Number:	  1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 |  11 |  13
d111 1
a111 1
 * Number:	  0 |  22 |  23 |  12 | 24 | 25 | 26 | 27 | 28 | 31
d114 11
a124 11
#define RR_R0	 1
#define RR_R1	 2
#define RR_R2	 3
#define RR_R3	 4
#define RR_R4	 5
#define RR_R5	 6
#define RR_R6	 7
#define RR_R7	 8
#define RR_R8	 9
#define RR_R9	10
#define RR_R10	11
d134 1
a134 1
#define RR_DP	 0
d137 1
a137 1
#define RR_BK	12
d152 1
a152 1
 * Temporaries:			R8,  R9, R10, BK	(saved by caller)
d156 1
a156 1
 * Universal Temporaries:	R_RS, R_RE, R_RC		
a165 2
 * Specials:			DP		(register 0) (ie always reads as zero)
 *				RS, RE, RC	(repeat engine)
a167 1
#define R_R0		RR_DP	/* register containing 0 */
d192 1
a192 1
#define NTEMPREGS	4L	/* number of temporary registers */
d197 2
a198 2
#define MAXGLOBINTREG	8L	/* maximum number of integer registers ??? */
#define MAXGLOBFLTREG	4L	/* maximum number of floating point registers ??? */
d211 1
a211 1
			   RR_R8,  RR_R9,  RR_R10, RR_BK,	/* tmp       */   \
@


1.12
log
@removed definition of RR_CC
@
text
@d109 3
a111 3
 * Name:	 DP | IR0 | IR1 |  BK | SP | ST | RS | RE | RC 
 *		-----------------------------------------------
 * Number:	  0 |  22 |  23 |  12 | 24 | 25 | 26 | 27 | 28 
d143 1
@


1.11
log
@added definition of RR_CC the condition code pseudo register
@
text
@d109 3
a111 3
 * Name:	 DP | IR0 | IR1 |  BK | SP | ST | RS | RE | RC | CC
*		---------------------------------------------------
 * Number:	  0 |  22 |  23 |  12 | 24 | 25 | 26 | 27 | 28 | 29
d143 1
a143 1
#define RR_CC	29	/* pseudo-register - condition codes */
@


1.10
log
@changed TARGET_CORRUPTS_SWITCH_REGISTER
@
text
@d109 3
a111 3
 * Name:	 DP | IR0 | IR1 |  BK | SP | ST | RS | RE | RC
 *		----------------------------------------------
 * Number:	  0 |  22 |  23 |  12 | 24 | 25 | 26 | 27 | 28
d143 1
@


1.9
log
@fixed NMAGICREGS (again) and changed R_ADDR1
@
text
@a54 1
   #define TARGET_CORRUPTS_SWITCH_REGISTER 		1	/* indicates that a switch instruction might corrupt index register */
d66 1
@


1.8
log
@minor changes and explanations of TARGET_HAS definitons after receiving letter from jpff
@
text
@d16 1
a16 1
#  define TARGET_HAS_AOUT 				1	/* XXX we do not actually care about this */
d22 1
a22 1
#  define target_coff_magic 				0577     /* inspected if TARGET_HAS_COFF */
d77 1
a77 1
/* #define TARGET_LDRK_QUANTUM				0 */	/* XXX - what does this do */
d81 2
a82 2
/* #define TARGET_STRUCT_RESULT_REGISTER		0 */	/* XXX - what does this do ? */
/* #define TARGET_SWITCH_isdense			0 */	/* XXX - what does this do ? */
d182 1
a182 1
#define R_ADDR1		RR_AR1	/* first address register (also used by heliobj.c when initialising data) */
d204 1
a204 1
#define NMAGICREGS	16L	/* maximum valid bit number for a compiler used register (mip/see defs.h) */
@


1.7
log
@added definitions of NMAGICREGS and NFLTREGS and change def of NINTREGS
@
text
@d16 1
a16 1
#  define TARGET_HAS_AOUT 				1	/* XXX is this right ? */
a28 1
   #define TARGET_HAS_SWITCH_BRANCHTABLE 		1	/* XXX - what does this do ? */
d33 1
a33 1
/* #define TARGET_HAS_370_FP				0 */
d36 1
a36 1
/* #define TARGET_HAS_COND_EXEC				0 */	/* XXX - do we ? */
d40 1
a40 1
/* #define TARGET_HAS_FP_LITERALS			0 */	/* XXX - do we ? */
d44 2
a45 2
/* #define TARGET_HAS_NON_FORTRAN_DIVIDE		0 */
/* #define TARGET_HAS_OTHER_IEEE_ORDER			0 */	/* XXX - do we ? */
d47 1
a47 1
/* #define TARGET_HAS_SCALED_ADDRESSING			0 */	/* XXX - what does this do ? */
d49 2
a50 2
/* #define TARGET_HAS_SCCK				0 */	/* XXX - what does this do ? */
/* #define TARGET_HAS_SEPARATE_CODE_DATA_SEGS		0 */	/* XXX - what does this do ? */
d52 1
d55 1
a55 1
   #define TARGET_CORRUPTS_SWITCH_REGISTER 		1	/* XXX - what does this do ? */
d58 1
a58 1
/* #define TARGET_LACKS_FP_DIVIDE			1 */	/* XXX - removed because of bugs in cg.c line 873 */
d60 1
a60 1
   #define TARGET_LDRK_MAX 				(0xffL)	/* XXX - is this 0xff really (8 bit displacements in indirect mode) */
d67 1
a67 1
/* #define TARGET_FLAGS_VA_CALLS			0 */	/* XXX - what does this do ? */
d72 1
a72 1
/* #define TARGET_LACKS_MULDIV_LITERALS			0 */	/* XXX - what does this do ? */
d79 2
a80 2
/* #define TARGET_STACKS_LINK				0 */	/* XXX - what does this do ? */
/* #define TARGET_STACK_MOVES_ONCE			0 */	/* XXX - what does this do ? */
d82 1
a82 1
/* #define TARGET_SWITCH_isdence			0 */	/* XXX - what does this do ? */
@


1.6
log
@added R_FV1 as it is needed by mip/regalloc.c
@
text
@d201 4
a204 1
#define NINTREGS	22L	/* number of "integer" registers, see mip/defs.h line 86 and mip/cgdefs.h line 147 */
@


1.5
log
@removed TARGET_SHARES_INT_AND_FP_REGS on recommendation from AM
@
text
@d177 1
@


1.4
log
@changed alignment of doubles to prevent extraneous stack size adjustments
@
text
@a6 4
/*
 * XXX - this file has been heavily modified by NC
 *
 */
d16 1
a16 1
#  define TARGET_HAS_AOUT 				1	/* XXX ---- is this right ? */
d19 2
a20 2
/* #define TARGET_IS_BIG_ENDIAN    			1 */	/* XXX ---- is this right ?  --- nope, the machine is really un-endian! */
   #define TARGET_IS_LITTLE_ENDIAN    			1 	/* XXX ---- is this right ?  --- nope, the machine is really un-endian! */
d26 1
a26 1
   #define TARGET_HAS_BSS 				0
d30 2
a31 2
   #define TARGET_HAS_TAILCALL 				1	/* XXX - what does this do ? */
   #define TARGET_HAS_TAILCALLR 			1	/* XXX - what does this do ? */
d63 1
a63 1
   #define TARGET_SHARES_INTEGER_AND_FP_REGISTERS	1
d231 7
a237 7
#define sizeof_short	2
#define sizeof_int      4
#define sizeof_long	4
#define sizeof_ptr	4
#define sizeof_float	4
#define sizeof_double	8
#define sizeof_ldble	8
@


1.3
log
@enable halfword stores
@
text
@d186 2
a187 2
#define R_MT		RR_AR4	/* module table pointer */
#define R_ATMP		RR_AR5	/* temporary address register */
d248 2
a249 2
#define alignof_double  	8
#define alignof_ldble		8
@


1.2
log
@changed register allocation scheme (again)
@
text
@d20 1
a20 1
#  define TARGET_HAS_AOUT 		1	/* XXX ---- is this right ? */
d23 2
a24 2
/* #define TARGET_IS_BIG_ENDIAN    	1 */	/* XXX ---- is this right ?  --- nope, the machine is really un-endian! */
#define TARGET_IS_LITTLE_ENDIAN    	1 	/* XXX ---- is this right ?  --- nope, the machine is really un-endian! */
d26 1
a26 1
#  define target_coff_magic 		0577     /* inspected if TARGET_HAS_COFF */
d46 1
a46 1
/* #define TARGET_HAS_HALFWORD_INSTRUCTIONS		0 */	/* oh no it doesn't */
a62 1
   #define TARGET_LACKS_HALFWORD_STORE			1
d75 1
d91 1
a91 1
#define DO_NOT_OPTIMISE_CHAR_AND_SHORT_ARITHMETIC 1
d93 1
a93 1
#define NO_INSTORE_FILES
d98 2
a99 2
 * Register Ordering		(cf hardware_register() in c40/gen.c)
 * Version:	3
@


1.1
log
@Initial revision
@
text
@d113 1
a113 1
 * Name:	 DP | IR0 | IR1 |  BK | SP | RC | ST | RE | RS
d143 2
a144 2
#define RR_RC	25
#define RR_ST	26
d146 1
a146 1
#define RR_RS	28
d152 18
a169 18
 * Arguments:		R0, R1, R2	(arguments passed in to function)
 * Variables:		R4, R5, R6,  R7	(saved by callee)
 * Temporaries:		R8, R9, R10, BK	(saved by caller)
 * Floating Point Arg:	R0-R1, 		(must not intersect integer variable or temporary register sets)
 * Floating Point Var:	R4-R5, R6 - R7  (must not intersect integer argument or temporary register sets)
 * Floating Point Tmp:  R8-R9, R10- BK	(must not intersect integer argument or variable  register sets)
 * Universal Temporary:	R3		
 * Link:		R11
 * Address:		AR0, AR1, AR2, AR3,
 * Module Table Pointer:AR4
 * Temporary addresses:	AR5
 * User Stack Pointer:	AR6
 * Frame Pointer:       AR7
 * Addressing Base:	IR0		(start address of memory available to process) (NB/ this is hard coded in gen.c)
 * Stack End Pointer:	IR1		(see load_static_data_ptr() in c40/gen.c)
 * System Stack Pointer:SP		(used by interrupt handlers)
 * Specials:		DP		(register 0) (ie always reads as zero)
 *			RS, RE, RC	(repeat engine)
d176 3
a178 1
#define R_TMP		RR_R3	/* universal temporary register */
d192 1
a192 1
#define R_DS		RR_IR1	/* display pointer */
d194 1
a194 1
#define NARGREGS	3L	/* number of argument registers */
d197 1
a197 1
#define NFLTARGREGS	1L	/* number of floating point argument registers ??? */
d204 1
a204 1
#define NINTREGS	21L	/* number of "integer" registers, see mip/defs.h line 86 and mip/cgdefs.h line 147 */
d210 1
a210 1
#define ALLOCATION_ORDER { RR_R0,  RR_R1,  RR_R2,		/* params in */   \
@
