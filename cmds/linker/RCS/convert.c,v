head	1.30;
access;
symbols;
locks; strict;
comment	@ * @;


1.30
date	94.05.05.10.27.14;	author vlsi;	state Exp;
branches;
next	1.29;

1.29
date	94.05.04.16.44.58;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	94.04.26.13.33.58;	author vlsi;	state Exp;
branches;
next	1.27;

1.27
date	94.04.26.11.43.04;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	94.04.20.10.33.52;	author vlsi;	state Exp;
branches;
next	1.25;

1.25
date	94.04.15.11.00.06;	author vlsi;	state Exp;
branches;
next	1.24;

1.24
date	94.04.07.10.55.16;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	94.04.05.13.05.44;	author vlsi;	state Exp;
branches;
next	1.22;

1.22
date	94.03.29.10.39.42;	author vlsi;	state Exp;
branches;
next	1.21;

1.21
date	94.03.24.15.23.17;	author vlsi;	state Exp;
branches;
next	1.20;

1.20
date	94.01.25.17.14.47;	author vlsi;	state Exp;
branches;
next	1.19;

1.19
date	94.01.24.17.11.50;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	94.01.24.10.13.56;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	94.01.21.12.58.20;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	94.01.21.12.31.14;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	94.01.20.16.50.01;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	94.01.20.14.31.44;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	94.01.20.12.35.58;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	94.01.17.16.17.00;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	94.01.14.12.15.09;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	94.01.13.15.09.37;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	94.01.13.09.09.30;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	94.01.07.17.46.43;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	94.01.07.14.20.02;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	94.01.05.16.28.44;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	94.01.05.14.44.29;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	94.01.05.10.48.41;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	94.01.04.10.55.25;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	93.12.17.17.09.53;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	93.12.17.16.02.59;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.30
log
@The "putinbuffer" code now checks if the operation will overflow,
and flushes the buffer if it will.
@
text
@/*{{{  Comment */

/*---------------------------------------------------------------------------*/
/* AOF to Helios object convertor.
 *
 * Original Author: JGSmith
 *
 * $Revision: 1.27 $
 *   $Author: vlsi $
 *     $Date: 1994/04/26 11:43:04 $
 *
 * Copyright (c) 1993, VLSI Technology Inc. All Rights Reserved.
 *           (c) 1994, Perihelion Software Ltd.  All Rights Reserved.
 *
 * Notes:
 *
 * Since we cannot add or remove instructions from the code, and we
 * cannot safely use r14, we must use branches to reach the address
 * generating code. This means that every data access will have its
 * own stub code. This will increase the code size by 2 instructions
 * for every data access.
 *
 * The current re-entrant APCS includes code to preserve r9(dp/sb/mt)
 * over function calls. This preservation code is not required by the
 * Helios system, since it uses double indirection. Unfortunately this
 * means that the converted code is slightly larger than it need be.
 */
/*---------------------------------------------------------------------------*/

/*}}}*/

/* FIXME : TODO : The generated code would be optimised by NOT
 * including INIT code for libraries when the object has NO
 * initialised data.
 */

/* If "ZERODATA" is defined at compile time then the
 * data-initialisation code will zero the module table memory (BSS).
 * If it is not defined then it is assumed that the module table will
 * already have been zeroed by the task manager. */

/*{{{  #includes */

typedef long int int32;
typedef unsigned long unsigned32;

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <unistd.h>
#include <stdlib.h>

#include "convert.h"
#include "endian.h"
#include "link.h"

#include <module.h>

/*}}}*/
/*{{{  #defines */

#define trace if (traceflags & db_aof) _trace

#ifndef TRUE
#define TRUE (1 == 1)
#endif
#ifndef FALSE
#define FALSE (1 == 0)
#endif

/*---------------------------------------------------------------------------*/
/* The convertor generates some "local" symbols to reference code and
 * data created during the conversion process. These manifests control
 * the form of these manufactured symbols.
 */
#define LOCALADDRSYM ".__local_addr_"                  /* prefix */
#define DATAINITSYM  ".__local_data_initialisation"
#define UNIQAREA     "AREA"

/*---------------------------------------------------------------------------*/
/* The Helios object output is buffered. The following manifest
 * controls the size of the code buffer used.
 */
#define BUFFERSIZE (16 << 10) /* bytes */

/* To cope with generating unique local symbols (required when linking
 * library and kernel objects), we allocate a single temporary buffer.
 */
#define TBUFFSIZE (4 << 10) /* should be big enough for very large symbols */

/*---------------------------------------------------------------------------*/
/* Nasty constants that should really be defined in an exported Helios
 * header file.
 */

#define HOF_title_len       (32)   /* length of a standard module name */

/*
 * Funky macro to cpoe with fact that kernel/device driver function names
 * strat with a . rather than a _
 */

#define CodePrefix_()       (bDeviceDriver ? '.' : '_')

/*}}}*/
/*{{{  Types & Macros */

/*---------------------------------------------------------------------------*/
/* Useful ARM manifests */

typedef enum
{
 ccEQ = 0x0,
 ccNE = 0x1,
 ccCS = 0x2,
 ccCC = 0x3,
 ccMI = 0x4,
 ccPL = 0x5,
 ccVS = 0x6,
 ccVC = 0x7,
 ccHI = 0x8,
 ccLS = 0x9,
 ccGE = 0xA,
 ccLT = 0xB,
 ccGT = 0xC,
 ccLE = 0xD,
 ccAL = 0xE,
 ccNV = 0xF
} ARMcondcodes ;

/*---------------------------------------------------------------------------*/
/* ARM instructions generated by Helios updates */

/* "B address" */
#define Branch(a,p)      (0xEA000000 | ((((a) - ((p) + 8)) >> 2) & 0xFFFFFF))

/* "B<cc> address" */
#define BranchCC(a,p,c)      (0x0A000000 | ((c) << 28) | ((((a) - ((p) + 8)) >> 2) & 0xFFFFFF))

/* "LDR <r>,[dp,#&00]" */
#define LDRfromdp(r)     (0xE5990000 | ((r) << 12))

/* "ADD <r>,<r>,#&00" */
#define ADDwithoffset(r) (0xE2800000 | ((r) << 16) | ((r) << 12))

/* "LDR <r>,[<r>,#&00]" */
#define LDRfromoffset(r) (0xE5900000 | ((r) << 16) | ((r) << 12))

/* "LDRB <r>,[<r>,#&00]" */
#define LDRBfromoffset(r) (0xE5D00000 | ((r) << 16) | ((r) << 12))

/* "STR <r>,[<r>,#&00]" */
#define STRtooffset(r) (0xE5800000 | ((r) << 16) | ((r) << 12))

/* "STRB <r>,[<r>,#&00]" */
#define STRBtooffset(r) (0xE5C00000 | ((r) << 16) | ((r) << 12))

/* "MOV r0,r0"        NOP */
#define ARMNOP  (0xE1A00000)            /* do nothing for 1cycle */

/* "MOV pc,ip" */
#define stubCall (0xE1A0F00C)           /* call a function from a stub */

/* "MOV pc,lr" */
#define returnCall (0xE1A0F00E)

/* Exception stub code (nasty constants) */
#define stubPush  (0xE92D5000)          /* "STMFD sp!,{ip,lk}" */
#define stubStore (0xE58DC004)          /* "STR   ip,[sp,#4]"  */
#define stubPop   (0xE8Bd9000)          /* "LDMFD sp!,{ip,pc}" */

/* Address generating stub : "ADD r,r,#0" */
#define addrADD(r)  (0xE2800000 | ((r) << 16) | ((r) << 12))
/* Address generating stub : "ADD r,pc,#0" */
#define addrADDpc(r)  (0xE28F0000 | ((r) << 12))

/* Initialisation */
#define initCMP     (0xE3500002)    /* "CMP  a1,#2"      */
#define initCMP1    (0xE3500001)    /* "CMP  a1,#1"      */
#define initReturn1 (0x01A0F00E)    /* "MOVEQ pc,lr"	 */
#define initLDRfn   (0xE599C004)    /* "LDR  ip,[dp,#4]" */
#define initLDRdata (0xE599C000)    /* "LDR  ip,[dp,#0]" */
#define initSUBfn   (0xE24F1000)    /* "SUB  a2,pc,#0"   */
#define initSUBfn2  (0xE2411000)    /* "SUB  a2,a2,#0"   */
#define initSTRfn   (0xE48C1004)    /* "STR  a2,[ip],#4" */
#define initLDRcopy (0xE4913004)    /* "LDR  a4,[a2],#4" */
#define initSTRdata (0xE48C3004)    /* "STR  a4,[ip],#4" */
#define initSUBS    (0xE2522004)    /* "SUBS a3,a3,#4"   */
#define initMOV     (0xE3A02000)    /* "MOV  a3,#0"      */
#define zeroMOVa4   (0xE3A03000)    /* "MOV  a4,#0"      */
#define initADD     (0xE2822000)    /* "ADD  a3,a3,#0"   */
#define initADDa1   (0xE2800000)    /* "ADD  a1,a1,#0"   */
#define initADDip   (0xE28C0000)    /* "ADD  a1,ip,#0"   */
#define initADDinto (0xE082200C)    /* "ADD  a3,a3,ip"   */
#define initADDmore (0xE2822000)    /* "ADD  a3,a3,#0"   */
#define initADDcode (0xE0822001)    /* "ADD  a3,a3,a2"	 */

#define initSUBr(r)  (0xE24F0000 | ((r) << 12))               /* "SUB r,pc,#0"    */
#define initSUBr2(r) (0xE2400000 | ((r) << 16) | ((r) << 12)) /* "SUB r,r,#0"     */
#define initADDr(r)  (0xE2800000 | ((r) << 16) | ((r) << 12)) /* "ADD r,r,#0"     */
#define initLDR(r,a) (0xE5900000 | ((r) << 12) | ((a) << 16)) /* "LDR rr,[ra,#0]" */
#define initSTR(r,a) (0xE5800000 | ((r) << 12) | ((a) << 16)) /* "STR rr,[ra,#0]" */

/*---------------------------------------------------------------------------*/
/* Reference a NUL terminated piece of text within the string table */
#define FINDSTRING(a,o) (char *)((a)->aofstrt + (o))

/*---------------------------------------------------------------------------*/

/*}}}*/
/*{{{  Local Variables */

/*---------------------------------------------------------------------------*/
/* This is a list of symbols that need exception style calling stubs.
 * It is a bit of a bodge, but unfortunately the AOF symbols have no
 * attributes to mark non-APCS conforming code.
 */
static char *symbol_exceptions[] = {
                                    "__rt_stkovf_split_small",
                                    "__rt_stkovf_split_big",
                                    "__stack_overflow",
                                    "__stack_overflow_1",
                                    NULL
                                   } ;

static unsigned32 maxcodep = 0 ;
static unsigned32 maxdata  = 0 ;

/* For quicker access to a simple temporary string buffer */
static char *tmpbuffer = NULL ;

/*}}}*/
/*{{{  Functions */

/*{{{  write_encoded */

#define ENC_NEG         (0x40)
#define ENC_MORE        (0x80)
#define LO6MASK         (0x3F)
#define LO7MASK         (0x7F)

/* write_encoded
 * -------------
 * Write a number in the coded form required by Helios objects.
 *
 * in:  n  : value to be written.
 *      fp : output file descriptor.
 * out: no conditions.
 */
static void write_encoded(int n,FILE *fp)
{
 int sign = ((n < 0) ? ENC_NEG : 0) ;
 int shift ;
 int mask ;
 int more = 0 ;

 if (sign)
  n = -n ;

 mask = LO6MASK ;
 shift = 0 ;
 while ((n & mask) != n)
  {
   more = ENC_MORE ;
   shift += 7 ;
   mask = ((mask << 7) | LO7MASK) ;
  }

 putc((((n & (LO6MASK << shift)) >> shift) | sign | more),fp) ;
 if (more)
  {
   do
    {
     shift -= 7 ;
     putc((((n & (LO7MASK << shift)) >> shift) | ((shift == 0) ? 0 : ENC_MORE)),fp) ;
    } while (shift != 0) ;
  }

 return ;
}

/*}}}*/
/*{{{  write_byte */

static void write_byte(int val,FILE *fp)
{
 putc(val,fp) ;
 return ;
}

/*}}}*/
/*{{{  write_text */

static void write_text(char *text,int length,FILE *fp)
{
 for (; (length > 0); length--)
  putc(*text++,fp) ;
 return ;
}

/*}}}*/
/*{{{  write_number */

static void write_number(unsigned int num,FILE *fp)
{
 char tbuff[9] ;

 sprintf(tbuff,"%X",num) ;
 write_text(tbuff,strlen(tbuff),fp) ;
 return ;
}

/*}}}*/
/*{{{  write_string */

static void write_string(char *text,int length,FILE *fp)
{
 write_text(text,length,fp) ;
 putc('\0',fp) ;
 return ;
}

/*}}}*/
/*{{{  write_data */

static void write_data(unsigned char *data,int amount,FILE *fp)
{
 if (amount > 0)
  {
   putc(OBJCODE,fp) ; (void)write_encoded(amount,fp) ;
   for (; (amount != 0); amount--)
    putc(*data++,fp) ;
  }
 return ;
}

/*}}}*/
/*{{{  write_padding */

static void write_padding(int amount,FILE *fp)
{
 putc(OBJBSS,fp) ;
 (void)write_encoded(amount,fp) ;
 return ;
}

/*}}}*/
/*{{{  putinbuffer */

static void putinbuffer(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,unsigned32 value,FILE *ofp)
{
 if (((*pboff) + sizeof(unsigned32)) > BUFFERSIZE)
  {
   /* Flush the code buffer */
   if (ofp != NULL)
    write_data(buffer,(int)(*pboff),ofp) ;
   (*pboff) = 0 ;
  }

 PWRITE(0,(unsigned32 *)(buffer + *pboff),value) ;
 (*pboff) += sizeof(unsigned32) ;
 (*pcodepos)++ ;
 return ;
}

/*}}}*/
/*{{{  cf_load */

static void *cf_load(s_aof *oep,char *name)
{
 int   cidx = cf_index(oep->cfhdr,name) ;
 void *buffer = NULL ;

 if (cidx == -1)
  error( "Chunk \"%s\" not found in \"%s\"",name,oep->fname) ;
 else
  {
   int32 csize = cf_entrysize(oep->cfhdr,cidx) ;

   if (csize < 0)
    error( "Unable to read the size of Chunk \"%s\" (index %d) in \"%s\"",name,cidx,oep->fname) ;
   else
    {
     if (csize > 0)
      {
       if (cf_seek(oep->cf,cidx) != 0)
        error("Failed to seek to the start of Chunk %d in \"%s\"",cidx,oep->fname) ;
       else
        if ((buffer = (void *)malloc((int)csize)) == NULL)
         error("Failed to allocate 0x%08X bytes for Chunk %d in \"%s\"",csize,cidx,oep->fname) ;
        else
         if (cf_loadentry(oep->cf,buffer,csize) != 0)
          {
           error("Failed to load Chunk %d data from \"%s\"",cidx,oep->fname) ;
           free(buffer) ;
           buffer = NULL ;
          }
      }
    }
  }

 return(buffer) ;
}

/*}}}*/
/*{{{  rotatable */

static int rotatable(unsigned32 value,unsigned32 *shift,int inv,unsigned32 *imm)
{
 int loop ;

 for (loop = 0; (loop <= 1); loop++)
  {
   *shift = 0 ;
   do
    {
     if (value < 0x100)
      {
       *imm = value ;
       return(TRUE) ;
      }

     if (*shift >= 0x10)
      break ; /* out of the loop */

     value = (value << 2) + (value >> 30) ;
     (*shift)++ ;
    } while (1) ; /* loop around until shift too large, or value found */

   if (!inv)
    return(0) ;

   value ^= -1 ; /* and try again */
  }

 return(0) ;
}

/*}}}*/
/*{{{  geninst */

static void geninst(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,unsigned32 sval,unsigned32 i1,unsigned32 i2)
{
 unsigned32 shift ;
 unsigned32 imm ;
 int        first = TRUE ;
 unsigned32 inst ;

 while (!rotatable(sval,&shift,0,&imm))
  {
   /* Generate intermediate instructions */
   shift = 0 ;

   if (sval == 0)
    error("FATAL: Value of zero failed rotatable test") ;

   while (((sval >> shift) & 0x3) == 0)
    shift += 2 ;

   inst = ((first ? i1 : i2) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
   PWRITE(0,(unsigned32 *)(buffer + *pboff),inst); *pboff += sizeof(unsigned32) ; (*pcodepos)++ ;
   first = 0 ;

   sval = (sval & ~(0xFFL << shift)) ;
  }

 /* last instruction */
 inst = ((first ? i1 : i2) | (shift << 8) | imm) ;
 PWRITE(0,(unsigned32 *)(buffer + *pboff),inst); *pboff += sizeof(unsigned32) ; (*pcodepos)++ ;

 return ;
}

/*}}}*/
/*{{{  add_data_ref */

static void add_data_ref(s_aof *adesc,int32 symindex,unsigned32 offset,unsigned32 areanum,unsigned32 destreg,unsigned32 codepos)
{
 s_dataref *new = (s_dataref *)malloc(sizeof(s_dataref)) ;

 if (new == NULL)
  error("Failed to allocate data reference holder") ;

 trace("add_data_ref: symindex %d, offset 0x%08X, areanum %d, destreg %d, codepos 0x%08X",symindex,offset,areanum,destreg,codepos) ;

 new->symindex = symindex ;
 new->offset   = offset ;
 new->areanum  = areanum ;
 new->destreg  = destreg ;
 new->codepos  = codepos ;

 new->next     = adesc->drefs ;
 adesc->drefs  = new ;

 return ;
}

/*}}}*/
/*{{{  find_string */

/* FIXME : There is a macro FINDSTRING defined that does this job */
static char *findstring(s_aof *adesc,int offset)
{
 return((char *)(adesc->aofstrt + offset)) ;
}

/*}}}*/
/*{{{  checkexception */

static int checkexception(char *symname)
{
 int    matched = 0 ;
 char **cptr ;

 for (cptr = &(symbol_exceptions[0]); (*cptr != NULL); cptr++)
  if (strcmp(*cptr,symname) == 0)
   {
    matched = TRUE ;
    break ;
   }

 return(matched) ;
}

/*}}}*/
/*{{{  findsym */

static aof_symbol *findsym(s_aof *adesc,int *sloop,int aname,int index)
{
 aof_symbol *cptr = NULL ;

 /* This code relies on the fact that there is only one copy of each
  * string in the string table. If a string appears multiple times
  * this code will fail to match the string table offsets.
  */
 for (; (*sloop < READ(adesc->be,adesc->aofhdr->aof_nsyms));)
  {
   cptr = &(adesc->aofsymt[*sloop]) ;
   (*sloop)++ ; /* step the index onto the next symbol */
   if ((aname == READ(adesc->be,cptr->sym_areaname)) && (((int32)index << 2) == READ(adesc->be,cptr->sym_value)))
    break ; /* out of the for loop */
   cptr = NULL ; /* no match at this symbol index */
  }

 return(cptr) ;
}

/*}}}*/
/*{{{  find_exported */

static int32 find_exported(s_aof *adesc,int32 slimit,int32 sval,int32 saname)
{
 int32 symindex = -1 ;
 int   sloop ;

 trace("AREA relative: sval = 0x%08X : saname = 0x%08X \"%s\"",sval,saname,findstring(adesc,(int)saname)) ;

 /* scan the symbol table for an exported symbol that can be used */
 for (sloop = 0; (sloop < slimit); sloop++)
  {
   /* Check for exported symbol with matching definition */
#if 0
   trace("sloop %d : sym_areaname 0x%08X : sym_value 0x%08X : exported %s",sloop,READ(adesc->be,adesc->aofsymt[sloop].sym_areaname),READ(adesc->be,adesc->aofsymt[sloop].sym_value),(((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) ? "Yes" : "No")) ;
#endif

   if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && (READ(adesc->be,adesc->aofsymt[sloop].sym_value) == sval) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT))
    {
     symindex = sloop ;
     break ; /* out of the loop */
    }
  }

 return(symindex) ;
}

/*}}}*/
/*{{{  find_local */

static int32 find_local(s_aof *adesc,int32 slimit,int32 sval,int32 saname)
{
 int32 symindex = -1 ;
 int32 maxfound = 0 ;
 int   sloop ;

 trace("AREA relative: sval = 0x%08X : saname = 0x%08X \"%s\"",sval,saname,findstring(adesc,(int)saname)) ;

 /* scan the symbol table for a local symbol that can be used */
 for (sloop = 0; (sloop < slimit); sloop++)
  {
   /* Check for a local symbol closest to the required value */
   trace("sloop %d : sym_areaname 0x%08X : sym_value 0x%08X : exported %s",sloop,READ(adesc->be,adesc->aofsymt[sloop].sym_areaname),READ(adesc->be,adesc->aofsymt[sloop].sym_value),(((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) ? "Yes" : "No")) ;

   if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_DEFAT))
    {
     int32 symval = READ(adesc->be,adesc->aofsymt[sloop].sym_value) ;
     /* Symbol is defined within the required area */
     if (symval <= sval) /* check for exact match or below */
      {
       /* Symbol is beneath the required offset */
       if (symval >= maxfound) /* use the last definition that gives exact or closest below */
        {
         maxfound = symval ;
         symindex = sloop ;
        }
      }
    }
  }

 /* The returned "symindex" will be -1 if no local symbol is found.
  * Otherwise it will reference the local symbol "containing" the required offset.
  */
 return(symindex) ;
}

/*}}}*/
/*{{{  referencedata */

static int referencedata(FILE *ofp,unsigned32 *pcodepos,char *firstdata,int tiny,int dolib)
{
 if (ofp != NULL)
  {
   write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDT,ofp) ; write_encoded(initLDRdata,ofp) ;
   write_byte(PATCHSHIFT,ofp) ; write_byte(0x3,ofp) ; write_byte(OBJMODNUM,ofp) ;
  }
 (*pcodepos)++ ;

 /* We are interested in the base of the data defined by this object
  * when dealing with libraries.
  */
 if (dolib)
  {
   if (firstdata == NULL)
    {
     error("Missing pointer to first DATA directive for this library object") ;
     error("There should always be an exported symbol for the first datum in a library") ;
    }

   trace("referencedata: firstdata = \"%s\"",firstdata) ;

   /* LSB */
   if (ofp != NULL)
    {
     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPLSB,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
     write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
    }
   (*pcodepos)++ ;

   if (!tiny)
    {
     /* MID */
     if (ofp != NULL)
      {
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPMID,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
       write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
      }
     (*pcodepos)++ ;
    }

   /* REST */
   if (ofp != NULL)
    {
     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPREST,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
     write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
    }
   (*pcodepos)++ ;
  }

 return(FALSE) ;
}

/*}}}*/
/*{{{  referenceexternal */

static void referenceexternal(FILE *ofp,char *symname,int armreg,unsigned32 *pcodepos,int tiny)
{
/* TODO : If the linker made two passes we would know whether external
 * symbols were data or code during the object conversion. This would
 * allow the initialisation code to be optimised for loading the
 * address of code or data. At the moment using the AOF patch
 * directives means that 8bytes are wasted whenever the address of a
 * code symbol is required during the initialisation code.
 */

 if (ofp != NULL)
  {
   write_byte(OBJWORD,ofp) ;
   write_byte(PATCHARMDT,ofp) ;
   write_encoded(LDRfromdp(armreg),ofp) ;
   write_byte(OBJDATAMODULE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
  }
 (*pcodepos)++ ;

 /* LSB */
 if (ofp != NULL)
  {
   write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFLSB,ofp) ; write_encoded(armreg,ofp) ;
   write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
  }
 (*pcodepos)++ ;

 if (!tiny) /* shorter access sequence */
  {
   /* MID */
   if (ofp != NULL)
    {
     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFMID,ofp) ; write_encoded(armreg,ofp) ;
     write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
    }
   (*pcodepos)++ ;
  }

 /* REST */
 if (ofp != NULL)
  {
   write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFREST,ofp) ; write_encoded(armreg,ofp) ;
   write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
  }
 (*pcodepos)++ ;

 return ;
}

/*}}}*/
/*{{{  loadcurrentvalue */

static int32 loadcurrentvalue(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,int32 roff,FILE *ofp)
{
 int32 remainder = 0 ;

/* FIXME : We can perform various optimisations:
 *
 * TODO : At the moment the same base "a1/r0" may get continually
 * reloaded. We should optimise the code so that if the last
 * "loadcurrentvalue" involved the same "a1/r0" setup we do not need
 * to generate the instructions.
 *
 * TODO : If current value is zero (in the initialised data) then
 * we do not need to load, we can just overwrite. In-fact we should be
 * able to optimise the relocation sequences to use the initialised
 * value directly, and add it in if non-zero using immediate
 * instructions, rather than loading through the module table.
 */

 /* Load the current value */
 if (roff < 4096)
  putinbuffer(buffer,pboff,pcodepos,(initLDR(0x2,0xC) | roff),ofp) ;
 else
  {
   int base = (int)roff ;

   remainder = (roff & (4096 - 1)) ;
   base -= (int)remainder ;

   geninst(buffer,pboff,pcodepos,(unsigned32)base,initADDip,initADDa1) ;
   putinbuffer(buffer,pboff,pcodepos,(initLDR(0x2,0x0) | remainder),ofp) ;
  }

 return(remainder) ;
}

/*}}}*/
/*{{{  storenewvalue */

static void storenewvalue(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,int32 roff,int32 remainder,FILE *ofp)
{
 /* write the value back into the module table */
 if (roff < 4096)
  putinbuffer(buffer,pboff,pcodepos,(initSTR(0x2,0xC) | roff),ofp) ;
 else
  putinbuffer(buffer,pboff,pcodepos,(initSTR(0x2,0x0) | remainder),ofp) ;
 return ;
}

/*}}}*/
/*{{{  CalculateMaxCodeP */

static void
CalculateMaxCodeP(
                  s_aof *       adesc,
                  int32         slimit,
                  int32         nareas)
{
  int loop;

  
  /* maxcodep = number of exported functions */
  
  for (loop = 0; loop < slimit; loop++)
    {
      unsigned32        sattr = READ( adesc->be, adesc->aofsymt[ loop ].sym_AT ) ;
      

      /* We are only interested in global symbols we define */
      
      if ((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT)
        {
          int32 aname = READ( adesc->be, adesc->aofsymt[ loop ].sym_areaname) ;
          int   aloop ;
          

          for (aloop = 0; (aloop < nareas); aloop++)
            {
             unsigned32 aattr = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_attributes) ;
              if ((READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname) && (aattr & AOF_CODEAT)) /* an exported code symbol */
                maxcodep += sizeof (unsigned32) ;
            }
        }
    }
  
  return;
  
} /* CalculateMaxCodeP */

/*}}}*/
/*{{{  CalculateMaxData */

static void
CalculateMaxData(
                 s_aof *        adesc,
                 int32          nareas )
{
  int   loop;
  
  /*
   * maxdata = size of exported data 
   *
  * This will be the total of all the (non-based and non-shared) data areas
  */
 
  for (loop = 0; loop < nareas; loop++)
    {
      unsigned32        attr = READ( adesc->be, adesc->aofhdr->aof_areas[ loop ].area_attributes) ;

      
      if (!(attr & AOF_CODEAT) &&
          !(attr & AOF_BASEDAT) &&
          !(attr & AOF_SHLDATA))
        {
          maxdata += READ( adesc->be, adesc->aofhdr->aof_areas[ loop ].area_size ) ;
        }
    }
 
 return;
 
} /* CalculateMaxData */

/*}}}*/
/*{{{  CreateObjectHeader */

static long
CreateObjectHeader(
                   s_aof *      adesc,
                   unsigned32 * buffer,
                   FILE *       ofp )
{ 
  int            tlen;
  int            loop;
  long		 swpos ; /* file offset of Size Word */
  unsigned32 vsn = READ(adesc->be,adesc->aofhdr->aof_vsn) ;
  
  /* Output the object header */
  
  write_byte( OBJMODULE, ofp );
  write_encoded( -1, ofp );     /* MODULE -1 */
  
  /* Output the magic identifier and "code size" value */
  
  swpos = (ftell(ofp) + sizeof(unsigned32) + 2) ; /* the "2" is to cover the CODE directive */
  /* NOTE: This can blow up badly if the module header format is ever changed */
  PWRITE( 0, buffer, T_Module );
  PWRITE( 0, buffer + 1, adesc->codesize );
  
  if ((tlen = strlen( adesc->fname )) > (HOF_title_len - 1))
    {
      loop = (tlen - HOF_title_len - 1) ;
      tlen = (HOF_title_len - 1) ;
    }
  else
    loop = 0 ;
  
  memcpy( (char *)(buffer + 2), (unsigned char *)&(adesc->fname[ loop ]), tlen );
  
  write_data( (unsigned char *)buffer, 2 * sizeof (unsigned32) + tlen, ofp );
  write_padding( HOF_title_len - tlen, ofp ) ;
  write_byte( OBJWORD,   ofp );
  write_byte( OBJMODNUM, ofp );
  
  PWRITE( 0, buffer, vsn);
  PWRITE( 0, (buffer + 1), maxdata );
  
  write_data( (unsigned char *)buffer, 2 * sizeof (unsigned32), ofp );
  
  write_byte( OBJINIT, ofp );

  if (smtopt)
    {
      PWRITE( 0, (unsigned32 *)buffer, maxcodep );
  
      write_data( (unsigned char *)buffer, sizeof (unsigned32), ofp ) ;
    }
  
  return(swpos);
  
} /* CreateObjectHeader */

/*}}}*/
/*{{{  defineDATA */

static void defineDATA(FILE *ofp,unsigned32 size,char *symname)
{
 if (ofp != NULL)
  {
   write_byte(OBJDATA,ofp) ;
   write_encoded((int)size,ofp) ;
   write_byte('_',ofp) ;
   write_string(symname,strlen(symname),ofp) ;
  }
 return ;
}

/*}}}*/
/*{{{  declareDATA */

static void declareDATA(s_aof *adesc,FILE *ofp,char *ldaname,int32 slimit,char **firstdata,int32 asize,int32 anoff)
{
 int         hidx ;
 int         last = (int)asize ; /* last possible data position in this area (for zero-length object) */
 int         sloop ;
 int         scount ;
 unsigned32 *ssize = (unsigned32 *)malloc((int)(slimit * 2) * sizeof(unsigned32)) ;
 unsigned32 *sorder = (ssize + slimit) ;

 if (ssize == NULL)
  error("Failed to allocate memory for symbol table size vector") ;

 /* We provide a unique symbol as the first "DATA" element for each of
  * the AOF data areas.
  */
 if ((strlen(ldaname) + 1 + strlen(UNIQAREA) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
  error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",ldaname,infile_duplicate) ;
 sprintf(tmpbuffer,"%s_%s_%s",ldaname,UNIQAREA,infile_duplicate) ;

 for (sloop = 0; (sloop < slimit); sloop++)
  {
   ssize[sloop] = -1 ; /* initialise the size vector */
   sorder[sloop] = -1 ; /* and the position vector */
  }

 /* Process the symbols within this data area */
 /* NOTE: Since the symbol table is not ordered, but we need to
  * order the DATA directives, we must perform multiple scans
  * over the table. We should really update the code to perform
  * a single pass generating a new ordered symbol table, and
  * then create the DATA directives from it.
  */

 /* This first loop scans for symbols in the desired area, and
  * calculates their lengths (relative to the other symbols).
  */

 scount = 0 ; /* no symbols yet found */
 do
  {
   int32 hval = 0 ; /* highest position seen within this area */

   hidx = -1 ;
   /* scan through the symbol table for un-processed symbols in this area */
   for (sloop = 0; (sloop < slimit); sloop++)
    {
     /* Check that the symbol references this data area */
     if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == anoff)
      {
       /* If the size of this symbol has not been calculated,
        * and it is further into the file then we want to
        * process it.
        */
       if ((READ(adesc->be,adesc->aofsymt[sloop].sym_value) >= hval) && (ssize[sloop] == -1))
        {
         hidx = sloop ;
         hval = READ(adesc->be,adesc->aofsymt[sloop].sym_value) ;
        }
      }
    } /* symbol table scan loop */

   if (hidx != -1)
    {
     int32 sval  = READ(adesc->be,adesc->aofsymt[hidx].sym_value) ;
     ssize[hidx] = (last - sval) ;
     if ((int)(ssize[hidx]) < 0)
      error("Negative sized object \"%s\" (should never happen)",findstring(adesc,(int)READ(adesc->be,adesc->aofsymt[hidx].sym_name))) ;
     sorder[scount++] = hidx ; /* remember where this symbol lived */
     last = (int)sval ;
    }
  } while (hidx != -1) ;

 /* We may have un-named (i.e. no symbols defined) datums at the start
  * of the area that still need to be catered for in the DATA
  * declarations.
  */
 if (*firstdata == NULL)
  {
   *firstdata = malloc(strlen(tmpbuffer) + 1) ;
   if (*firstdata == NULL)
    error("Failed to allocate string buffer") ;
   strcpy(*firstdata,tmpbuffer) ;
   trace("declareDATA: firstdata = \"%s\"",*firstdata) ;
  }
 trace("declareDATA: data area start symbol = \"%s\"",tmpbuffer) ;
 defineDATA(ofp,last,tmpbuffer) ; /* "last" offset in the area accounted for by a symbol */
 
 /* Deal with the symbols found, outputting them in the correct order */
 for (; (scount > 0); scount--)
  {
   char *symname ;
   unsigned32 sattr ;

   sloop = sorder[scount - 1] ; /* symbol index we are processing */

   if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) != anoff)
    error("Symbol index %d no longer matches areaname offset 0x%08X",sloop,anoff) ;

   if (ssize[sloop] == -1)
    error("Size not known for symbol %d",sloop) ;

   symname = findstring(adesc,(int)READ(adesc->be,adesc->aofsymt[sloop].sym_name)) ;
   sattr = READ(adesc->be,adesc->aofsymt[sloop].sym_AT) ;

   /* Generate unique symbol names for local data symbols */ 
   if (((sattr & SYM_REFDEFMASK) != SYM_REFAT) && ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT)) /* local symbol */
    {
     if ((strlen(symname) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
      error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",symname,infile_duplicate) ;
     sprintf(tmpbuffer,"%s_%s",symname,infile_duplicate) ;
     symname = tmpbuffer ;
    }

   trace("declareDATA: symname = \"%s\"",symname) ;
   defineDATA(ofp,ssize[sloop],symname) ;
  }

 /* Release the symbol size vector */
 free(ssize) ;

 return ;
}

/*}}}*/

/* Exported functions */
/*{{{  open_aof */

s_aof *open_aof(char *fname)
{
 s_aof *New ; /* AOF file descriptor */

 New = (s_aof *)malloc(sizeof(s_aof)) ;
 
 if (New != NULL)
  {
   FILE *fdesc ;

   New->fname = fname ; /* filename of object this is a descriptor for */
   New->cf = NULL ; /* no ChunkFile descriptor */
   New->cfhdr = NULL ; /* no ChunkFile header */
   New->aofhdr = NULL ; /* no cached areas */
   New->aofsymt = NULL ; /* no symbol table */
   New->aofstrt = NULL ; /* no string table */
   New->codesize = 0xFFFFFFFF ; /* code size not yet known */
   New->drefs = NULL ; /* no data references yet */

   if ((fdesc = fopen(fname,"r")) == NULL)
    warn("Failed to open object file \"%s\"",fname) ;
   else
    {
     if ((New->cf = (ChunkFile *)malloc(sizeof(ChunkFile))) == NULL)
      error("Unable to allocate 0x%08X bytes for ChunkFile \"%s\" descriptor",sizeof(ChunkFile),fname) ;
     else
      if (cf_open(fdesc,New->cf) == NULL)
       error("Failed to open \"%s\" as a ChunkFile",fname) ;
      else
       {
        int32 hdrsize = cf_headersize(New->cf) ;

        if (hdrsize == 0)
         error("ChunkFile \"%s\" did not open properly",fname) ;
        else
         if ((New->cfhdr = (cf_header *)malloc((int)hdrsize)) == NULL)
          error("Unable to allocate 0x%08X bytes for ChunkFile \"%s\" header",hdrsize,fname) ;
         else
          if (cf_readheader(New->cf,New->cfhdr,hdrsize) == NULL)
           error("Failed to read ChunkFile \"%s\" header (0x%08X bytes)",fname,hdrsize) ;
          else
           {
            New->be = LE ; /* default is little-endian */
            switch (cf_endianness(New->cfhdr->cf_magic))
             {
              case CF_BIG :
               New->be = BE ; /* big-endian file */
               /* and fall through to shared processing */
              case CF_LITTLE :
               /* if entered as CF_LITTLE then New->be has already been initialised */
               {
                if ((New->aofhdr = (aof_header *)cf_load(New,OBJ_HEAD)) == NULL)
                 error("Failed to load AOF header from \"%s\"",fname) ;
                else
                 if (READ(New->be,New->aofhdr->aof_type) != AOF_RELOC)
                  error("Invalid AOF ID 0x%08X in ChunkFile \"%s\"",READ(New->be,New->aofhdr->aof_type),fname) ;
                 else
                  if (READ(New->be,New->aofhdr->aof_vsn) > AOF_VERSION)
                   warn("ChunkFile \"%s\" contains New AOF version %d (<=%d expected)",fname,READ(New->be,New->aofhdr->aof_vsn),AOF_VERSION) ;
               }
               break ;

              default : /* unrecognised magic value */
               error("Unrecognised magic identifier 0x%08X in ChunkFile header",New->cfhdr->cf_magic) ;
             }

            if (New->aofhdr != NULL) /* we have an AOF header */
             {
              /* load the symbol table */
              if ((New->aofsymt = (aof_symbol *)cf_load(New,OBJ_SYMT)) == NULL)
               report("Warning: Symbol table not found (or zero length)") ;
              /* load the string table */
              if ((New->aofstrt = (char *)cf_load(New,OBJ_STRT)) == NULL)
               report("Warning: String table not found (or zero length)") ;
              /* load the code and data areas */
              if ((New->aofareas = (char *)cf_load(New,OBJ_AREA)) == NULL)
               report("Warning: Code/Data Areas not found (or zero length)") ;
             }
           }
       }

     fclose(fdesc) ;
    }
  }

 maxdata  = 0;
 maxcodep = 0;
 
 return(New) ;
}

/*}}}*/
/*{{{  convert_aof */

/* Internal symbol flags (above "real" attributes). These are used to
 * mark information within the symbol table of the original AOF file.
 */
#define LSYM_CODE    (SYM_LINKATTR << 1) /* imported as a code symbol */
#define LSYM_LCODE   (SYM_LINKATTR << 2) /* local code symbol */
#define LSYM_DATAREF (SYM_LINKATTR << 3) /* symbol referenced as data */

unsigned32 convert_aof(s_aof *adesc,char *outfile,int dolib,int tiny,int kernel)
{
 unsigned char *buffer = NULL ; /* temporary conversion buffer */
 FILE          *ofp = NULL ; /* file descriptor for 2nd pass GHOF output */
 unsigned32    *codebase = NULL ; /* vector used to hold GHOF offsets for converted areas */
 int            tlen ;
 int            loop ;
 unsigned32     boff ; /* buffer offset */
 unsigned32     base ;
 unsigned32     limit ;
 int32          slimit = READ(adesc->be,adesc->aofhdr->aof_nsyms) ;
 int32          nareas = READ(adesc->be,adesc->aofhdr->aof_nareas) ;
 unsigned32     codepos = 0 ;
 unsigned32     dataplace = 0 ;
 s_dataref     *dref ;
 char          *firstdata = NULL ;
 unsigned32     initdataamount = 0 ; /* amount of initialised data (not BSS) we have */
 long		    swpos = -1L ;

 if ((buffer = (unsigned char *)malloc(BUFFERSIZE)) == NULL)
  error("Failed to allocate temporary buffer") ;

 if ((tmpbuffer = (char *)malloc(TBUFFSIZE)) == NULL)
  error("Failed to allocate temporary symbol name buffer") ;

 if ((outfile != NULL) && ((ofp = fopen(outfile,"wb")) == NULL))
  error("Failed to open output file \"%s\"",outfile) ;
 /* NOTE: The remaining error cases rely on the host OS closing the
  * opened file during its exit handling.
  */

 if ((codebase = (unsigned32 *)malloc((int)nareas * sizeof(unsigned32))) == NULL)
  error("Failed to allocate memory for code area base addresses") ;

 for (loop = 0; (loop < nareas); loop++)
  codebase[loop] = -1 ; /* initialise the vector */

 /* Release any data references that may be hanging around */
 if (adesc->drefs != NULL)
  {
   s_dataref *cptr = adesc->drefs ;

   for (; (cptr != NULL);)
    {
     s_dataref *This = cptr ;
     cptr = This->next ;
     free(This) ;
    }

   adesc->drefs = NULL ;
  }

 CalculateMaxCodeP(adesc,slimit,nareas) ;
 CalculateMaxData(adesc,nareas) ;
 trace("maxcodep = 0x%08X, maxdata = 0x%08X",maxcodep,maxdata) ;
 
/*{{{  generate GHOF module header */

 if (!dolib && !kernel)
  {
   /* Allow for header at start of object file */
   if (ofp == NULL) /* first pass */
    codepos += (sizeof(Module) / sizeof(unsigned32)) ;
   else
    {
     swpos = CreateObjectHeader(adesc,(unsigned32 *)buffer,ofp) ;
     codepos += (sizeof(Module) / sizeof(unsigned32)) ;
    }
  }

/*}}}*/
/*{{{  process (and output) the code areas */

 /* Process (and output) the code areas */
 boff  = 0 ;
 limit = 0 ;
 
 for (loop = 0; (loop < nareas); loop++)
  {
   unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
   int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
   int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
   int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;
   aof_reloc *relocs = NULL ;

   base = limit ;
   limit += (asize + (nrelocs * sizeof(aof_reloc))) ;

   if (attr & AOF_CODEAT)
    {
     if (!(attr & (AOF_32bitAT | AOF_REENTAT)))
      error("Object file Area %d is not APCS-3 re-entrant",loop) ;
     else
      {
       int         iloop ;  /* instruction loop */
       unsigned32  rcount ; /* relocation count */
       unsigned32 *code ;
       aof_reloc  *reloc ;

       codebase[loop] = (codepos << 2) ; /* remember the start of this code area */

       if ((asize % sizeof(unsigned32)) != 0)
        {
         if (ofp != NULL)
          fclose(ofp) ;
         error("Code area is not a word multiple in size") ;
        }

       code = (unsigned32 *)((int)(adesc->aofareas) + base) ;
       if (nrelocs != 0)
        relocs = (aof_reloc *)((int)code + asize) ;
       asize /= sizeof(unsigned32) ;
       rcount = 0 ; reloc = NULL ; /* no active relocations */

       /* Step through the code */
       for (iloop = 0; (iloop < asize); iloop++)
        {
         unsigned32  inst ;
         aof_symbol *symbol ;
         int         snum = 0 ;

         while ((symbol = findsym(adesc,&snum,(int)anoff,iloop)) != NULL)
          {
           char *      symname = findstring(adesc,(int) READ(adesc->be,symbol->sym_name)) ;
           unsigned32  sattr   = READ(adesc->be,symbol->sym_AT) ;

           if (!(sattr & SYM_DATAAT)) /* only output non-data symbols that appear in the code area */
            {
             sattr |= LSYM_LCODE ; WRITE(adesc->be,symbol->sym_AT,sattr) ; /* local function symbol */
             if (ofp == NULL)
              boff = 0 ; /* flush the code buffer */
             else
              {
               write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
               write_byte( OBJLABEL, ofp) ;
               write_byte('.',ofp) ;
               write_string(symname,strlen(symname),ofp) ;
              }
            }
          }

         if ((boff + sizeof(unsigned32)) > BUFFERSIZE)
          {
           if (ofp != NULL)
            write_data(buffer,(int)boff,ofp) ;
           boff = 0 ;
          }

         inst = READ(adesc->be,code[iloop]) ;

         trace( "code[0x%08X] = 0x%08X",(iloop << 2),inst) ;

         if ((rcount > 0) || (nrelocs > 0))
          {
           int        rloop ;
           aof_reloc *newreloc = NULL ;

           for (rloop = 0; (rloop < nrelocs); rloop++)
            if (READ(adesc->be,relocs[rloop].rel_offset) == ((int32)iloop << 2))
             {
              newreloc = &(relocs[rloop]) ;
              break ; /* match against the first only */
             }

           if (rcount > 0)
            {
             if (newreloc != NULL)
              error("Multi-instruction relocation for offset 0x%08X contains another relocation at offset 0x%08X",READ(adesc->be,reloc->rel_offset),(iloop << 2)) ;
             /* we use the previous reloc structure */
            }
           else
            reloc = newreloc ;

           /* "reloc" is non-NULL if this instruction has a relocation field */
           if (reloc != NULL)
            {
             unsigned32 relflags = READ(adesc->be,reloc->rel_flags) ;
             unsigned32 symindex ;
             unsigned32 ft ;
             unsigned32 newcount ;
             int        pcrel ;
             int        area ;
             int        based ;

             symbol = NULL ; /* relocation may be area relative */

             if (rel_type2(relflags))
              {
               symindex = rel2_sid(relflags) ;
               ft = rel2_FT(relflags) ;
               pcrel = (rel2_R(relflags) == REL_PCREL) ;
               area = (rel2_A(relflags) == 0) ;
               based = rel2_B(relflags) ;
               newcount = rel2_ins(relflags) ;
              }
             else
              {
               symindex = rel1_sid(relflags) ;
               ft = rel1_FT(relflags) ;
               pcrel = (rel1_R(relflags) == REL_PCREL) ;
               area = (rel1_A(relflags) == 0) ;
               based = 0 ;
               /* if type1 relocation, then rcount will always be zero at this point */
               newcount = 1 ;
              }

             /* rcount:
              *  0 : the linker may modify as many contiguous
              *      instructions as required
              *  1 : the linker will modify at most 1 instruction
              *  2 : the linker will modify at most 2 instructions
              *  3 : the linker will modify at most 3 instructions
              */
             if (rcount == 0)
              rcount = newcount ;

             if (rcount == 0)
              rcount = 1 ; /* only allow 1 instruction to be modified */

             trace("relocation %d : offset = 0x%08X : symindex = %d : rcount = %d",rloop,READ(adesc->be,reloc->rel_offset),symindex,rcount) ;

             if (!area) /* relocation is symbol relative (otherwise it is AREA relative) */
              symbol = &(adesc->aofsymt[symindex]) ;

             if (ft == 0x3) /* instruction */
              {
               if (pcrel)
                {
                 char *      symname = findstring(adesc,(int) READ(adesc->be,symbol->sym_name)) ;
                 unsigned32  sattr   = READ(adesc->be,symbol->sym_AT) ;

                 trace("PC-relative relocation") ;

                 if (ofp != NULL)
                  write_data(buffer,(int)boff,ofp) ; /* flush existing code */
                 boff = 0 ;

                 if ((sattr & SYM_REFDEFMASK) == SYM_REFAT)
                  {
                   /* imported code symbol */
                   sattr |= LSYM_CODE ; /* we will need a stub */
                   WRITE(adesc->be,symbol->sym_AT,sattr) ;
                  }
                 /* else warning "PC-relative instruction to a non-imported symbol" */

                 /* if (based) then it is a possible tailcall */
                 if (ofp != NULL)
                  {
                   write_byte(OBJWORD,ofp) ; /* WORD */
                   if ((inst & 0x0E000000) == 0x0A000000) /* branch instruction */ 
                    {
                     if (rcount != 1)
                      error("Multi-instruction branch relocations not supported") ;
                     write_byte(PATCHARMJP,ofp) ; /* PATCH ARM JP */
                     write_encoded((int)inst,ofp) ;
                    }
                   else
                    {
                     /* Check that the instruction is an ADD or a SUB */
                     if (((inst & 0x0C000000) != 0) || ((((inst >> 21) & 0xF) != 0x2) && (((inst >> 21) & 0xF) != 0x4)))
                      error("PC-relative relocation to instruction which is not a branch, ADD or SUB") ;

                     if (rcount == newcount) /* 1st instruction */
                      {
                       /* Check that the base instruction is indeed PC relative */
                       if (((inst >> 16) & 0xF) != 0xF)
                        error("1st instruction of PC-relative relocation does not have PC as Rn") ;

                       /* TODO: FIXME: We should remember the Rd of
                        * the first instruction, and check that
                        * subsequent instructions use the same for Rn
                        * and Rd.
                        */
                      }

                     /* Always convert instruction to ADD, and let
                      * linker replace with SUB as necessary. */
                     inst = ((inst & ~0x01E00000) | (0x4 << 21)) ;

                     /* The following assumes that rcount is in the
                      * range 1..3. It is coded that it will generate
                      * LSB and REST for two instruction sequences and
                      * LSB, MID and REST for three instruction
                      * sequences. */
                     if (rcount == newcount)
                      write_byte(PATCHARMDPLSB,ofp) ;
                     else
                      if (rcount > 1)
                       write_byte(PATCHARMDPMID,ofp) ;
                      else
                       write_byte(PATCHARMDPREST,ofp) ;
                     write_encoded((int)inst,ofp) ;
                    }
                   write_byte(OBJLABELREF,ofp) ; /* LABELREF */
                   write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ; /* .symbol */
                  }
                 codepos++ ;
                 rcount-- ;
                }
               else
                {
                 if (based)
                  {
                   int32       offset ;
                   int         aloop ;
                   unsigned32 *dbase = (unsigned32 *)(adesc->aofareas) ;

                   if (rcount > 1)
                    error("Multi-instruction sequences not yet supported for Based relocations") ;

                   /* Check that the instruction is "LDR <r>,[dp,#off]" */
                   if (((inst & 0x0C000000) != 0x04000000) && ((inst & (1 << 20)) != (1 << 20)))
                    error("Based relocation with non-LDR (0x%08X)",inst) ;
                   if (((inst >> 16) & 0xF) != 9)
                    error("Based relocation (LDR) not using r9 (0x%08X)",inst) ;
                   if ((inst & (1 << 25)) != 0)
                    error("Based relocation has non-immediate offset (0x%08X)",inst) ;

                   offset = ((inst & (1 << 23)) ? (inst & 0xFFF) : -(inst & 0xFFF)) ;

                   if (offset < 0)
                    error("Negative offsets are not supported for based loads (%d)",offset) ;

                   trace("Based relocation: offset %d (0x%08X)",offset,offset) ;

                   for (aloop = 0; (aloop < nareas); aloop++)
                    {
                     unsigned32 aattr = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_attributes) ;
                     int32 nrels = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_nrelocs) ;
                     
                     /* If AREA relative then we only need to match the area index */
                     if ((symbol == NULL) ? (aloop == symindex) : (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == READ(adesc->be,symbol->sym_areaname)))
                      {
                       aof_reloc  *relocs = (aof_reloc *)((int)dbase + READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_size)) ;

                       /* Check area is based using r9 */
                       if (aattr & AOF_BASEDAT)
                        {
                         int rloop ;

                         if (((aattr & AOF_BASEMASK) >> AOF_BASESHIFT) != 9)
                          error("Area is based on r%d, should be r9",((aattr & AOF_BASEMASK) >> AOF_BASESHIFT)) ;

                         /* Step through the relocations looking for matches */
                         for (rloop = 0; (rloop < nrels); rloop++)
                          {
                           /* Match against a relocation for the referenced offset */
                           if (READ(adesc->be,relocs[rloop].rel_offset) == offset)
                            {
                             aof_reloc  *reloc = &(relocs[rloop]) ; /* shorthand */
                             unsigned32  relflags ;
                             int32       symindex ;
                             char       *symname ;
                             unsigned32  sattr ;
                             int         arearel = 0 ;
                             int         areanum = -1 ;
                             unsigned32  lval ;

                             /* Load the base offset held in the indirection area */
                             lval = READ(adesc->be,((int *)dbase)[offset >> 2]) ;
                             trace(" Base offset (held in indirection area) = %d (0x%08X)",lval,lval) ;

                             relflags = READ(adesc->be,reloc->rel_flags) ;

                             if (rel_type2(relflags))
                              {
                               symindex = rel2_sid(relflags) ;
                               arearel = (rel2_A(relflags) == 0) ;
                              }
                             else
                              {
                               symindex = rel1_sid(relflags) ;
                               arearel = (rel1_A(relflags) == 0) ;
                              }

                             if (arearel)
                              {
                               unsigned32 areaname ;
                               areanum = symindex ;
                               areaname = READ(adesc->be,adesc->aofhdr->aof_areas[areanum].area_name) ;
                               if ((symindex = find_exported(adesc,slimit,lval,areaname)) == -1)
                                {
                                 if ((symindex = find_local(adesc,slimit,lval,areaname)) == -1)
                                  {
                                   unsigned32 rattr = READ(adesc->be,adesc->aofhdr->aof_areas[areanum].area_attributes) ; /* referenced area attributes */
                                   /* We do not have a global
                                    * (exported) or local symbol that
                                    * references this relocation
                                    * directly.
                                    */
#if 1 /* 940324 : temporary fix */
                                   symname = findstring(adesc,areaname) ;
                                   trace("Relocation into area \"%s\" offset 0x%08X : symbol = \"%s\"",findstring(adesc,areaname),lval,symname) ;
#else
                                   if (rattr & AOF_CODEAT) /* Relocation into code area */
                                    {
                                     trace("Relocation into code area %s offset 0x%08X\n",findstring(adesc,areaname),lval) ;
                                     symname = findstring(adesc,areaname) ;
                                     /* "lval" is the offset into the area */
                                    }
                                   else
                                    {
                                     error("No local data area symbol for relocation : area %s offset 0x%08X : rattr = 0x%08X",findstring(adesc,areaname),lval,rattr) ;
                                    }
#endif
                                  }
                                 else
                                  {
                                   /* We have a local symbol, but we
                                    * may not be referencing the start of it.
                                    */
                                   lval = (lval - READ(adesc->be,adesc->aofsymt[symindex].sym_value)) ; /* get offset from start of local symbol */
                                  }
                                }
                               else
                                lval = 0 ; /* we now have an exported symbol */
                              }
                             else
                              {
                               sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                               /* Check if an exported symbol exists for the same offset and area */
                               if ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT)
                                {
                                 int32 newsi = find_exported(adesc,slimit,READ(adesc->be,adesc->aofsymt[symindex].sym_value),READ(adesc->be,adesc->aofsymt[symindex].sym_areaname)) ;
                                 /* If we cannot find a suitable
                                  * exported symbol, we make do with
                                  * the internal one.
                                  */
                                 if (newsi != -1)
                                  symindex = newsi ;
                                }

                               if (symindex == -1)
                                error("Exported symbol not found for relocation: instruction %d, offset 0x%08X, relflags 0x%08X",iloop,offset,relflags) ;
                              }

                             if (symindex != -1)
                              {
                               /* Mark the symbol as one requiring a data reference */
                               sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                               symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[symindex].sym_name)) ;
                               sattr |= LSYM_DATAREF ; WRITE(adesc->be,adesc->aofsymt[symindex].sym_AT,sattr) ; /* update symbol information */
                              }

                             if (ofp != NULL)
                              write_data(buffer,(int)boff,ofp) ;
                             boff = 0 ; /* flush existing code */

                             /* The branch uses the condition code of the original instruction */
                             if (ofp != NULL)
                              {
                               write_byte(OBJWORD,ofp) ;
                               write_byte(PATCHARMJP,ofp) ;
                               write_encoded( (int) BranchCC(0,0,(inst >> 28)),ofp) ;
                               write_byte(OBJLABELREF,ofp) ;
                               write_text(LOCALADDRSYM,strlen(LOCALADDRSYM),ofp) ;
                               write_number((unsigned int)((inst >> 12) & 0xF),ofp) ;
                               write_byte('_',ofp) ; write_text(symname,strlen(symname),ofp) ; write_byte('_',ofp) ;
                               codepos++ ;
                               write_number((unsigned int)(codepos << 2),ofp) ;
			       
                               if (dolib || kernel)
                                {
                                 /* XXX - NC - 20/1/94
                                  * If building for library/kernel there is a possibility that
                                  * this label will clash with one in a different file.  Hence
                                  * we must make it unique.
                                  */
                                 write_byte('_',ofp);
                                 write_text(outfile,strlen(outfile),ofp);
                                }
                               write_byte('\0',ofp) ;
                              }
                             else
                              codepos++ ;

                             add_data_ref(adesc,symindex,lval,areanum,((inst >> 12) & 0xF),(codepos << 2)) ;
                             break ; /* out of the relocation loop */
                            }
                          }

                         if (rloop == nrels)
                          error("Failed to find relocation for offset %d",offset) ;
                        }
                       else
                        error("Referenced area is not based") ;
                       
                       break ; /* since we have finished processing the referenced area */
                      }

                     /* Zero-initialised data (BSS) areas do not have
                      * any associated data. This code also assumes
                      * that they do not have any relocation
                      * directives either.
                      */
                     if (!(aattr & AOF_0INITAT))
                      dbase = (unsigned32 *)((int)dbase + READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_size) + (nrels * sizeof(aof_reloc))) ;
                     else
                      if (nrels > 0)
                       error("Zero-initialised data (BSS) with relocation directives");
                    }
                   rcount-- ;
                  }
                 else
                  error("Relocation: displaced : %d : 0x%08X : flags 0x%08X (not yet handled)",iloop,inst,relflags) ;
                }
              }
             else
              {
               error("No code to deal with byte, short or long relocations yet") ;
               error("Have you compiled the file with \"-li -apcs 3/reentrant\"?") ;
              }
            }
           else /* output the instruction (always little-endian) */
            putinbuffer(buffer,&boff,&codepos,inst,ofp) ;
          }
         else /* output the instruction (always little-endian) */
          putinbuffer(buffer,&boff,&codepos,inst,ofp) ;
        }
      }
    }
  }

 trace( "code areas processed" );

/*}}}*/
/*{{{  generate stubs to call external functions */

 if (!dolib && !kernel)
  {
   /* For all imported code symbols we generate stubs to indirect to the destination code */
   for (loop = 0; (loop < slimit); loop++)
    {
     if (READ(adesc->be,adesc->aofsymt[loop].sym_AT) & LSYM_CODE)
      {
       char *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
       int   doex = checkexception(symname) ;

       if (ofp == NULL)
        boff = 0 ; /* flush the code buffer */
       else
        {
         write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
         write_byte(OBJLABEL,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       
       if (doex)
        putinbuffer(buffer,&boff,&codepos,stubPush,ofp) ;
 
       if (ofp != NULL)
        write_data(buffer,(int)boff,ofp) ;
       boff = 0 ; /* flush the code buffer */

       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ;
         write_byte(PATCHARMDT,ofp) ;
         write_encoded(LDRfromdp(12),ofp) ;
         write_byte(OBJDATAMODULE,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       codepos++ ;

       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ;
         write_byte(PATCHARMDT,ofp) ;
         write_encoded(LDRfromoffset(12),ofp) ;
         write_byte(OBJCODESYMB,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       codepos++ ;

       if (doex)
        {
         putinbuffer(buffer,&boff,&codepos,stubStore,ofp) ;
         putinbuffer(buffer,&boff,&codepos,stubPop,ofp) ;
        }
       else
        putinbuffer(buffer,&boff,&codepos,stubCall,ofp) ;
      }
    }
  }

/*}}}*/
/*{{{  generate stubs to reference external data */

 trace("Processing external data references") ;
 /* for all external data references */
 for (dref = adesc->drefs; (dref != NULL); dref = dref->next)
  {
   char       *symname ;
   unsigned32  sattr = 0 ;
   int32       aname ;
   int         aloop ;
   int         localarea = FALSE ;
   int         localcode = FALSE ;
   int         forceind = FALSE ;
   unsigned32  symbase = 0 ;

   if (dref->symindex == -1) /* area base reference */
    {
     unsigned32 laattr = READ(adesc->be,adesc->aofhdr->aof_areas[dref->areanum].area_attributes) ;

     /* We are relative to an internal area */
     aname = READ(adesc->be,adesc->aofhdr->aof_areas[dref->areanum].area_name) ;
     symname = findstring(adesc,(int)aname) ;
     if (laattr & AOF_CODEAT)
      {
#if 1
       /* We were adding the codebase value in twice. Since we know
        * that the "dref->offset" is from the start of the area,
        * codebase[dref->areanum] gives the base of that area. We do
        * not need to hold a "symbase" value.
        */
       if (codebase[dref->areanum] == -1)
        error("Invalid base for code area %s reference 0x%08X",symname,dref->offset) ;
       symbase = 0 ;
#else
       symbase = codebase[dref->areanum] ;
       if (symbase == -1)
        error("Invalid base for code area %s reference 0x%08X",symname,dref->offset) ;
#endif
      }
     else
      {
       /* Fake up some local data symbol attributes */
       localarea = TRUE ;
       sattr = (SYM_LOCALDEFAT | SYM_DATAAT) ;
       trace("Reference to local data area %s offset 0x%08X",symname,dref->offset) ;
      }
    }
   else /* symbolic reference */
    {
     symname = findstring(adesc,(int)READ(adesc->be,adesc->aofsymt[dref->symindex].sym_name)) ;
     sattr = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_AT) ;
     aname = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_areaname) ;
     symbase = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_value) ;
    }

   if (ofp == NULL)
    boff = 0 ; /* flush the code buffer */
   else
    {
     write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
     write_byte(OBJLABEL,ofp) ;
     write_text(LOCALADDRSYM,strlen(LOCALADDRSYM),ofp) ;
     write_number((unsigned int)(dref->destreg),ofp) ;
     write_byte('_',ofp) ;
     write_text(symname,strlen(symname),ofp) ;
     write_byte('_',ofp) ;
     write_number((unsigned int)(dref->codepos),ofp) ;
     
     if (dolib || kernel)
      {
       /* XXX - NC - 20/1/94
        * If building for library/kernel there is a possibility that
        * this label will clash with one in a different file.  Hence
        * we must make it unique.
        */
       write_byte('_',ofp);
       write_text(outfile,strlen(outfile),ofp);
      }
     
     write_byte('\0',ofp) ;
    }

   /* See if we can match the symbol area name against the areas in this object */
   for (aloop = 0; (aloop < nareas); aloop++)
    if (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname)
     break ;

   /* The codebase value will only have been initialised for local
    * code areas. This saves having to check the attributes of the
    * areas as we scan through.
    */
   if ((aloop != nareas) && (codebase[aloop] != -1))
    {
#if 1
     if ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT) /* not exported via the module table */
      localcode = TRUE ;
     else
      {
       /* We could set "localcode" to be TRUE for all internal code
        * symbols. This would provide optimisations for referencing
        * code addresses. However, this would result in the internal
        * code not using the module table, and always referencing the
        * local version of the code (and possibly doing the wrong
        * thing if the module table pointer has been patched). If the
        * address is available in the module table then we ALWAYS
        * indirect.
        */
       forceind = TRUE ;
      }
#else
     /* Generate direct PC relative instructions for ALL references to
      * local code addresses. NOTE: This may cause problems if the
      * address/symbol is exported via the module table, and the
      * module table pointer is updated.
      */
     localcode = TRUE ;
#endif
    }

   if (localcode)
    {
     unsigned32 sval ;

     /* This is an optimisation. When the address of a local code
      * symbol is required, we generate the value directly using SUB
      * instructions from the pc. This saves using LABELREF
      * linker directives. */
     sval = (((codepos << 2) + 0x8) - (codebase[aloop] + symbase + dref->offset)) ;
     geninst(buffer,&boff,&codepos,sval,initSUBr(dref->destreg),initSUBr2(dref->destreg)) ;
    }
   else /* code cannot be accessed directly, we must use the symbol */
    {
     if (forceind || (sattr & LSYM_LCODE) || check_symbol(symname)) /* local code symbol or explicit code symbol */
      {
       if (!forceind && (sattr & LSYM_LCODE)) /* local code symbol */
        {
         trace("local code symbol") ;
         /* LSB */
         if (ofp != NULL)
          {
           write_byte(OBJWORD,ofp) ;
           write_byte(PATCHARMDPLSB,ofp) ;
           write_encoded((int)addrADDpc(dref->destreg),ofp) ;
           write_byte(OBJLABELREF,ofp) ;
           write_byte('.',ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
         codepos++ ;

         if (!tiny) /* shorter access sequence */
          {
           /* MID */
           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDPMID,ofp) ;
             write_encoded((int)addrADD(dref->destreg),ofp) ;
             write_byte(OBJLABELREF,ofp) ;
             write_byte('.',ofp) ;
             write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;
          }

         /* REST */
         if (ofp != NULL)
          {
           write_byte(OBJWORD,ofp) ;
           write_byte(PATCHARMDPREST,ofp) ;
           write_encoded((int)addrADD(dref->destreg),ofp) ;
           write_byte(OBJLABELREF,ofp) ;
           write_byte('.',ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
         codepos++ ;
        }
       else /* since we have another conditional above, we know that it is a code symbol */
        {
         /* We ignore "forceind" when building libraries or device drivers */
         if (dolib || kernel) /* (or device driver) treat as a local code access */
          {
           /* LSB */
           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDPLSB,ofp) ;
             write_encoded((int)addrADDpc(dref->destreg),ofp) ;
             write_byte(OBJLABELREF,ofp) ;
             write_byte('.',ofp) ;
             write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;

           if (!tiny) /* shorter access sequence */
            {
             /* MID */
             if (ofp != NULL)
              {
               write_byte(OBJWORD,ofp) ;
               write_byte(PATCHARMDPMID,ofp) ;
               write_encoded((int)addrADD(dref->destreg),ofp) ;
               write_byte(OBJLABELREF,ofp) ;
               write_byte('.',ofp) ;
               write_string(symname,strlen(symname),ofp) ;
              }
             codepos++ ;
            }

           /* REST */
           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDPREST,ofp) ;
             write_encoded((int)addrADD(dref->destreg),ofp) ;
             write_byte(OBJLABELREF,ofp) ;
             write_byte('.',ofp) ;
             write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;
          }
         else /* indirect via the module table */
          {
           /* get address of code symbol (being treated as data) */
           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDT,ofp) ;
             write_encoded(LDRfromdp(dref->destreg),ofp) ;
             write_byte(OBJDATAMODULE,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;

           if (ofp != NULL)
            {
             write_byte(OBJWORD,ofp) ;
             write_byte(PATCHARMDT,ofp) ;
             write_encoded(LDRfromoffset(dref->destreg),ofp) ;
             write_byte(OBJCODESYMB,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
            }
           codepos++ ;
          }
        }
      }
     else /* treat as access to a data symbol */
      {
       trace("treating as access to data symbol") ;
       if (((sattr & SYM_REFDEFMASK) != SYM_REFAT) && ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT)) /* local symbol */
        {
         if ((strlen(symname) + 1 + strlen(UNIQAREA) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
          error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",symname,infile_duplicate) ;
         if (localarea)
          sprintf(tmpbuffer,"%s_%s_%s",symname,UNIQAREA,infile_duplicate) ;
         else
          sprintf(tmpbuffer,"%s_%s",symname,infile_duplicate) ;
         symname = tmpbuffer ;
        }
       
       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ;
         write_byte(PATCHARMDT,ofp) ;
         write_encoded((int)LDRfromdp(dref->destreg),ofp) ;

         if ((sattr & SYM_REFDEFMASK) == SYM_REFAT)
          {
           write_byte(OBJDATAMODULE,ofp) ;
           write_byte('_',ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
         else
          {
           write_byte(PATCHSHIFT,ofp) ;
           write_byte(0x3,ofp) ;
           write_byte(OBJMODNUM,ofp) ;
          }
        }
       codepos++ ;
  
       /* LSB */
       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPLSB,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
         write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       codepos++ ;

       if (!tiny) /* shorter access sequence */
        {
         /* MID */
         if (ofp != NULL)
          {
           write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPMID,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
           write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
          }
         codepos++ ;
        }

       /* REST */
       if (ofp != NULL)
        {
         write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPREST,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
         write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
        }
       codepos++ ;
      }

     if (dref->offset != 0)
      geninst(buffer,&boff,&codepos,dref->offset,initADDr(dref->destreg),initADDr(dref->destreg)) ;
    }

   putinbuffer(buffer,&boff,&codepos,Branch(dref->codepos,(codepos << 2)),ofp) ;

 }

/*}}}*/
 
 if (ofp != NULL)
  write_data(buffer,(int)boff,ofp) ;
 boff = 0 ; /* flush the code buffer */

/*{{{  generate initialisation code */

 /* Kernel objects do not contain any initialisation code or module table declarations */
 if (!kernel)
  {
   unsigned32 *datapos = (unsigned32 *)malloc((int)nareas * sizeof(unsigned32)) ;

   if (datapos == NULL)
    error("Failed to allocate memory for data area position vector") ;

   /* Initialise the vector with a suitable constant */
   for (loop = 0; (loop < nareas); loop++)
    datapos[loop] = (unsigned32)-1 ;
   
   trace("adding initialisation code");

   /* mark the start of the initialisation code */
   if (ofp != NULL)
    write_byte(OBJINIT,ofp) ;
   codepos++ ; /* INIT */

/*{{{  output CODETABLE directives */

   /* provide CODETABLE definitions for each exported function */
   if (!dolib) /* only when constructing normal objects */
    {
     for (loop = 0; (loop < slimit); loop++)
      {
       unsigned32 sattr = READ(adesc->be,adesc->aofsymt[loop].sym_AT) ;

       /* The CODETABLE directives need to be provided in the same order
        * as the initialisation code below.
        */
       if (((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) && (sattr & LSYM_LCODE))
        {
         char *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
         if (ofp != NULL)
          {
           write_byte(OBJCODETABLE,ofp) ;
           write_byte(CodePrefix_(),ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
        }
      }
    }

/*}}}*/
/*{{{  output DATA directives */

   /* provide DATA directives for every exported or referenced data symbol */
   /* first for initialised data */
   for (loop = 0; (loop < nareas); loop++)
    {
     unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;

     if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA) && !(attr & AOF_0INITAT))
      {
       int32  asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
       int32  anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
       char  *ldaname = findstring(adesc,READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name)) ;

       declareDATA(adesc,ofp,ldaname,slimit,&firstdata,asize,anoff) ;
      }
    }

   /* and then for zero-initialised data (BSS) */
   for (loop = 0; (loop < nareas); loop++)
    {
     unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;

     if (attr & AOF_0INITAT)
      {
       int32  asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
       int32  anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
       char  *ldaname = findstring(adesc,READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name)) ;

       declareDATA(adesc,ofp,ldaname,slimit,&firstdata,asize,anoff) ;
      }
    }

/*}}}*/

   /* provide the initialisation code */
   putinbuffer(buffer,&boff,&codepos,initCMP,ofp) ;
   if (ofp == NULL)
    boff = 0 ; /* flush the code buffer */
   else
    {
/* TODO: If there is no function or data initialisation to be done,
 * then we can simply return from this code (saving a couple of
 * instructions).
 */
     write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
     write_byte(OBJWORD,ofp) ; /* WORD */
     write_byte(PATCHARMJP,ofp) ; /* PATCH ARM JP */
     write_encoded(BranchCC(0,0,ccNE),ofp) ; /* BNE 0x???????? */
     write_byte(OBJLABELREF,ofp) ; /* LABELREF */
     if (dolib)
      {
       write_text(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
       write_byte('_',ofp);
       write_string(outfile,strlen(outfile),ofp);
      }
     else
      write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
    }
   codepos++ ;

/*{{{  output function pointer (codetable) initialisation code */

   /* Function initialisation */
   if (!dolib) /* library objects have no function initialisation code */
    {
     if (ofp != NULL)
      {
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDT,ofp) ; write_encoded(initLDRfn,ofp) ;
       write_byte(PATCHSHIFT,ofp) ; write_byte(0x3,ofp) ; write_byte(OBJMODNUM,ofp) ;
      }
     codepos++ ;

     for (loop = 0; (loop < slimit); loop++)
      {
       unsigned32 sattr = READ(adesc->be,adesc->aofsymt[loop].sym_AT) ;
       if (((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) && (sattr & LSYM_LCODE))
        {
         unsigned32 sval = READ(adesc->be,adesc->aofsymt[loop].sym_value) ;
         int32      aname ;
         int        aloop ;
         int        anum ;

         /* By this point we have dumped the code areas, so it is always a
          * negative offset to the required symbol.
          */
         if ((aname = READ(adesc->be,adesc->aofsymt[loop].sym_areaname)) == 0)
          error("Referenced symbol offset 0x%08X does NOT have an area name",sval) ;
         for (aloop = 0; (aloop < nareas); aloop++)
          if (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname)
           {
            anum = aloop ;
            break ;
           }
         if (anum == nareas)
          error("Area for referenced symbol offset 0x%08X not found",sval) ;
         if (codebase[anum] == -1)
          error("Address of area containing symbol offset 0x%08X not known",sval) ;
         sval = (((codepos << 2) + 0x8) - (sval + codebase[anum])) ;
         geninst(buffer,&boff,&codepos,sval,initSUBfn,initSUBfn2) ;
         putinbuffer(buffer,&boff,&codepos,initSTRfn,ofp) ;
        }
      }
    }
   /* finish the function initialisation code */
   putinbuffer(buffer,&boff,&codepos,returnCall,ofp) ;

/*}}}*/
/*{{{  output initialised data */

/* TODO:
 * At the moment the storing of all the initialised data in a single
 * vector, and performing a copy is not always efficient. Sometimes it is
 * more efficient not to bother keeping a binary copy of the data, but to
 * generate explicit instructions for the non-zero values (Assuming that
 * the module table has been pre-zeroed).
 *
 * We could just keep a pool of non-zero values that cannot be
 * generated in a single ARM instruction. We can then build a conversion
 * structure that keeps a list of the original data area offset and the
 * new pool offset, or data value. We can then load the literals from the
 * pool or construct immediate load instructions.
 *
 * For continuous runs of data (where the addresses are consecutive) we can
 * generate loops to initialise the module table. Note: It will be worth
 * keeping small numbers of zeroes in such data blocks to make the
 * initialisation code shorter (and possibly quicker). The pool information
 * we construct can keep length information aswell for non-immediate loads.
 *
 * We can then be super efficient and roll the relocations into the actual
 * initialisation code. For immediate loads and single word copies we can
 * merge any offsets together.
 */

   {
    unsigned32 amount = 0 ; /* number of bytes placed into the module table data */
    int        pass ;

    if (ofp != NULL)
     write_data(buffer,(int)boff,ofp) ;
    boff = 0 ; /* flush the code buffer */
 
    dataplace = (codepos << 2) ; /* where the data is being written within the object file */

#ifndef ZERODATA
/* TODO: Since we know that the module table data area has already
 * been zeroed, we do not need to place zeroes into the initialised data
 * area.
 *
 * A simple optimisation (that has the minimum effect on the rest of
 * convertor) would be to check for a large block of zeroes at the start
 * or the end of a data area. We could then avoid writing the zeroes
 * into the image, and copying them in the data initialisation loop.
 */
#endif /* NOT ZERODATA */

    for (pass = 1; (pass < 3); pass++)
     {
      /* The first pass outputs the initialised data, and the second
       * pass ensures that the BSS space after that is accounted for.
       */
      limit = 0 ;
      for (loop = 0; (loop < nareas); loop++)
       {
        unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
        int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
        int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;

        switch (pass)
         {
          case 1 : /* initialised data */
           if (!(attr & AOF_0INITAT))
            {
             base = limit ;
             limit += (asize + (nrelocs * sizeof(aof_reloc))) ;
      
             if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
              {
               unsigned char *data = (unsigned char *)((int)(adesc->aofareas) + base) ;
               if (ofp != NULL)
                write_data(data,(int)asize,ofp) ;
               codepos += (asize >> 2) ;
               datapos[loop] = amount ; /* where this area is within the module table data */
               amount += asize ;
              }
            }
           break ;
           
          case 2 : /* Zero-initialised data (BSS) */
           if (attr & AOF_0INITAT)
            {
             /* BSS (zero-initialised data) does not have any associated data */
             if (nrelocs > 0)
              error("Zero-initialised data (BSS) with relocation directives");
             datapos[loop] = amount ; /* where this area is within the module table data */
             amount += asize ; /* to keep the maxdata checks in step */
            }
           else
            {
             /* ensure we step over the areas containing information */
             base = limit ;
             limit += (asize + (nrelocs * sizeof(aof_reloc))) ;
            }
           break ;

          default :
           error("Internal control error (pass = %d)",pass) ;   
         } /* switch */
       } /* areas */

      if (pass == 1) /* keep track of the amount of initialised data */
       initdataamount = amount ;
     } /* pass */

    if (amount != maxdata)
     error("Amount of data processed (0x%08X) does not match MaxData (0x%08X)",(int)amount,(int)maxdata) ;

    if ((amount % sizeof(int)) != 0)
     error("Amount of data written is NOT a word multiple") ; /* we will need to pad with NULs */
   }

/*}}}*/
/*{{{  output data initialisation code */

trace("generating data initialisation code") ;
   /* Data initialisation code */
   if (ofp == NULL)
    boff = 0 ; /* flush the code buffer */
   else
    {
     write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
     write_byte(OBJLABEL,ofp) ;
     if (dolib)
      {
       write_text(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
       write_byte('_',ofp);
       write_string(outfile,strlen(outfile),ofp);
      }
     else
      write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
    }

   /* This is a fix to get around the problem of external
    * initialisation routines being called within the header code of
    * modules. Since the INIT chain is processed sequentially, the
    * external functions would be called before the initialisation
    * code for individual modules had occured. This results in the
    * module init. code overwriting values set/modified by the
    * external init. functions.
    */
   putinbuffer(buffer,&boff,&codepos,initCMP1,ofp) ;
   putinbuffer(buffer,&boff,&codepos,initReturn1,ofp) ;
   if (ofp != NULL)
    write_data(buffer,(int)boff,ofp) ;
   boff = 0 ; /* flush the code buffer */

   if (initdataamount != 0) /* data initialisation required */
    {
     int        looppos ;
     unsigned32 sval = dataplace ;
     int        first = TRUE ;

     (void)referencedata(ofp,&codepos,firstdata,tiny,dolib) ;

     /* code to initialise the data vector */
     /* Copy "initdataamount" bytes from above into the module table */ 
     /* load "a2" with the address of the initialised data */
     sval = (((codepos << 2) + 0x8) - sval) ;
     geninst(buffer,&boff,&codepos,sval,initSUBfn,initSUBfn2) ;

     /* load "a3" with the amount of data to be copied */
     if (initdataamount > 4)
      geninst(buffer,&boff,&codepos,initdataamount,initMOV,initADD) ;

     /* and then provide the copy loop instructions */
     looppos = ((int)codepos << 2) ; /* current code position */
     putinbuffer(buffer,&boff,&codepos,initLDRcopy,ofp) ;
     putinbuffer(buffer,&boff,&codepos,initSTRdata,ofp) ;
     if (initdataamount > 4)
      {
       putinbuffer(buffer,&boff,&codepos,initSUBS,ofp) ;
       putinbuffer(buffer,&boff,&codepos,BranchCC(looppos,(codepos << 2),ccNE),ofp) ;
      }

#ifdef ZERODATA
     /* provide code to zero the BSS area */
     if (initdataamount < maxdata)
      {
       unsigned32 bsscount = (maxdata - initdataamount) ;

       if ((bsscount % sizeof(int)) != 0)
        error("Size of zero-initialised data (BSS) is not a word multiple") ;
       
       if (bsscount > 4)
        geninst(buffer,&boff,&codepos,bsscount,initMOV,initADD) ;
       putinbuffer(buffer,&boff,&codepos,zeroMOVa4,ofp) ;
       /* and then provide the zero loop instructions */
       looppos = ((int)codepos << 2) ; /* current code position */
       putinbuffer(buffer,&boff,&codepos,initSTRdata,ofp) ;
       if (bsscount > 4)
        {
         putinbuffer(buffer,&boff,&codepos,initSUBS,ofp) ;
         putinbuffer(buffer,&boff,&codepos,BranchCC(looppos,(codepos << 2),ccNE),ofp) ;
        }
      }
#endif /* ZERODATA */

trace("checking for out-standing relocations") ;

     /* Check for out-standing initialised data relocations */
     if (ofp != NULL)
      write_data(buffer,(int)boff,ofp) ;
     boff = 0 ; /* flush the code buffer */
     limit = 0 ; /* upper-limit of module table data */
     first = TRUE ; /* to ensure only a single "ip" copy is re-loaded */
     for (loop = 0; (loop < nareas); loop++)
      {
       unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
       int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
       int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;
       int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;

       /* Apply relocations to the module table data area we have just initialised */
       if (!(attr & AOF_0INITAT))
        {
         base = limit ;
         limit += (asize + (nrelocs * sizeof(aof_reloc))) ;

         if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
          {
trace("data area %d: nrelocs %d",loop,nrelocs) ;
           if (nrelocs != 0)
            {
             aof_reloc *relocs = (aof_reloc *)((int)((int)(adesc->aofareas) + base) + asize) ;
             int        rloop ;

             /* Add instructions to apply the required relocation to the newly copied data */
             for (rloop = 0; (rloop < nrelocs); rloop++)
              {
               int32       roff = READ(adesc->be,relocs[rloop].rel_offset) ;
               unsigned32  rflags = READ(adesc->be,relocs[rloop].rel_flags) ;
               unsigned32  symindex ;
               unsigned32  ft ;
               int         pcrel ;
               int         area ;
               int         based ;
               aof_symbol *symbol = NULL ;
               char       *symname ;
               int32       symaname ;
               int         localdataarea = -1 ;
               unsigned32  sval ;
               
trace("datainit: reloc %d : rflags 0x%08X : roff 0x%08X",rloop,rflags,roff) ;

               if (rel_type2(rflags))
                {
                 symindex = rel2_sid(rflags) ;
                 ft = rel2_FT(rflags) ;
                 pcrel = (rel2_R(rflags) == REL_PCREL) ;
                 area = (rel2_A(rflags) == 0) ;
                 based = rel2_B(rflags) ;
                }
               else
                {
                 symindex = rel1_sid(rflags) ;
                 ft = rel1_FT(rflags) ;
                 pcrel = (rel1_R(rflags) == REL_PCREL) ;
                 area = (rel1_A(rflags) == 0) ;
                 based = 0 ;
                }

               if (ft == 0x3) /* instruction */
                error("Instruction relocation type on data area") ;

               if (pcrel)
                error("PC-relative relocation type on data area") ;

               if (based)
                error("Based relocation type on data area") ;

               /* Convert "ft" into the number of bytes to be dealt with */
               ft = ((ft == 0) ? 1 : (ft << 1)) ;
               if ((ft == 1) || (ft == 2))
                error("Byte and short AOF relocations are not supported at the moment") ;

               if (area) /* relocation relative to data area start */
                {
                 unsigned32 rattr = READ(adesc->be,adesc->aofhdr->aof_areas[symindex].area_attributes) ;

trace("relocation relative to data area start") ;

                 if (rattr & AOF_CODEAT)
                  {
                   error("Code needed to deal with area based relocation into code area %d",symindex) ;
                  }
                 else /* referencing data area */
                  {
                   localdataarea = symindex ; /* area being referenced */
                   sval = datapos[localdataarea] ;
                   /* The contents are currently loaded and added in below */
                  }
                 symindex = -1 ; /* stop following code treating as symbol access */
                }

               if (symindex != -1) /* relative to a symbol */
                {
trace("relocation relative to symbol %d",symindex) ;
                 symbol = &(adesc->aofsymt[symindex]) ;
                 symname = findstring(adesc,(int)READ(adesc->be,symbol->sym_name)) ;
                 symaname = READ(adesc->be,symbol->sym_areaname) ;
                }

               /* "datapos[loop]" is the offset of the base of this data area within the module table chunk */
               if ((localdataarea == -1) && (symaname == anoff))
                {
trace("relocation relative to local data area") ;
                 localdataarea = loop ; /* within this area */
                 sval = READ(adesc->be,symbol->sym_value) ; /* offset of symbol being used to relocate this data area field */
                 sval += datapos[loop] ; /* referenced offset within this data area within module table */
                }
               else
                {
                 if (symindex != -1)
                  {
                   if ((READ(adesc->be,symbol->sym_AT) & SYM_REFDEFMASK) == SYM_REFAT)
                    {
                     int32 remainder ;

                     if (first)
                      first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ;

                     roff += datapos[loop] ; /* offset within module table to be relocated */
                     remainder = loadcurrentvalue(buffer,&boff,&codepos,roff,ofp) ;

                     if (ofp != NULL)
                      write_data(buffer,(int)boff,ofp) ;
                     boff = 0 ; /* flush the code buffer */

                     /* load the required data or code pointer */
                     referenceexternal(ofp,symname,0x1,&codepos,tiny) ;

                     putinbuffer(buffer,&boff,&codepos,initADDcode,ofp) ; /* add current value into address */
                     storenewvalue(buffer,&boff,&codepos,roff,remainder,ofp) ;
                    }
                   else /* internal symbol */
                    {
                     int iloop ; /* internal area loop */
                     unsigned32 localattr ;

                     for (iloop = 0; (iloop < nareas); iloop++)
                      if (symaname == READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_name))
                       break ; /* out of the for loop */

                     if (iloop == nareas)
                      error("Local area not found for symbol \"%s\"",symname) ;

                     localattr = READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_attributes) ;
                     if (!(localattr & AOF_CODEAT) && !(localattr & AOF_BASEDAT) && !(localattr & AOF_SHLDATA))
                      {
                       localdataarea = iloop ; /* symbol references a local data area */
                       sval = READ(adesc->be,symbol->sym_value) ; /* offset of symbol being used to relocate this data area field */
                       sval += datapos[loop] ; /* referenced offset within this data area within module table */
                      }
                     else /* must be a local code symbol */
                      {
                       int32 remainder ;

                       sval = READ(adesc->be,symbol->sym_value) ;

                       /* We can generate a relocation using a PC-relative
                        * label reference.
                        */
                       for (iloop = 0; (iloop < nareas); iloop++)
                        if (READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_name) == symaname)
                         break ;
                       if (iloop == nareas)
                        error("Referenced symbol offset 0x%08X does NOT have an area name",sval) ;
                       if (codebase[iloop] == -1)
                        error("Address of area containing symbol offset 0x%08X not known",sval) ;

                       roff += datapos[loop] ; /* offset within module table to be relocated */
                       if (first)
                        first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ; /* load the required module table pointer */

                       remainder = loadcurrentvalue(buffer,&boff,&codepos,roff,ofp) ;
                       sval = (((codepos << 2) + 0x8) - (codebase[iloop] + sval)) ;
                       geninst(buffer,&boff,&codepos,sval,initSUBfn,initSUBfn2) ; /* address of symbol in "a2" */
                       putinbuffer(buffer,&boff,&codepos,initADDcode,ofp) ; /* add current value into address */
                       storenewvalue(buffer,&boff,&codepos,roff,remainder,ofp) ;
                      }
                    }
                  }
                }

trace("sval = %d (0x%08X)",sval,sval) ;

               /* We have already dealt with external symbols and
                * local code symbols by this point.
                */
               if (localdataarea != -1) /* are we referencing a local data area */
                {
                 int32 remainder = 0 ;

trace("referencing local data area %d",localdataarea) ;
trace("datapos[loop] = datapos[%d] = 0x%08X",loop,datapos[loop]) ;

                 roff += datapos[loop] ; /* offset within module table to be relocated */

trace("roff = %d (0x%08X)",roff,roff) ;

#if 1 /* 940331 : add in base of referenced data area to the symbol offset within that data area */
                 sval += datapos[localdataarea] ;
#endif

                 if (first)
                  first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ;

                 remainder = loadcurrentvalue(buffer,&boff,&codepos,roff,ofp) ;

                 /* Update the value with the required relocation */
                 putinbuffer(buffer,&boff,&codepos,initADDinto,ofp) ;
                 if ((int32)sval > 0)
                  geninst(buffer,&boff,&codepos,(int32)sval,initADDmore,initADDmore) ;

                 /* and write the value back into the module table */
                 storenewvalue(buffer,&boff,&codepos,roff,remainder,ofp) ;
                }
              } /* relocation loop */
            } /* relocations */
          } /* data area */
        }
       else /* zero-initialised area */
        {
         if (nrelocs > 0)
          error("Zero-initialised data (BSS) with relocation directives");
        }
      } /* area loop */
    }

   putinbuffer(buffer,&boff,&codepos,returnCall,ofp) ;
   if (ofp != NULL)
    write_data(buffer,(int)boff,ofp) ;
   boff = 0 ; /* flush the code buffer */

/*}}}*/
/*{{{  output exported symbols */

   if (!dolib)
    {
     /* declare the symbols we export */
     for (loop = 0; (loop < slimit); loop++)
      {
       if ((READ(adesc->be,adesc->aofsymt[loop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT)
        {
         char * symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
         if (ofp != NULL)
          {
           write_byte(OBJGLOBAL,ofp) ;
           write_byte(CodePrefix_(),ofp) ;
           write_string(symname,strlen(symname),ofp) ;
          }
        }
      }
    }

/*}}}*/

   free(datapos) ;
  }

/*}}}*/
 
 if (swpos != -1L)
  {
   long endpos ;
   fflush(ofp) ;
   endpos = ftell(ofp) ;
   fseek(ofp,swpos,SEEK_SET) ;
   PWRITE(0,buffer,(codepos << 2)) ;
   write_text((char *)buffer,sizeof(unsigned32),ofp) ; /* since write_data adds a leading CODE directive */
   boff = 0 ;
   fflush(ofp) ;
   fseek(ofp,endpos,SEEK_SET) ;
  }

 if (ofp != NULL)
  fclose(ofp) ;

 if (tmpbuffer != NULL)
  free(tmpbuffer) ; /* release temporary symbol name buffer */
 if (buffer != NULL)
  free(buffer) ; /* release the temporary output buffer */

 return(codepos << 2) ; /* and return the size of the code/data generated */
}

/*}}}*/

/*}}}*/
@


1.29
log
@increased BUFFERSIZE to allow linking of cmds/assembler/lex_ARM.o
@
text
@d8 1
a8 1
 * $Revision: 1.28 $
d10 1
a10 1
 *     $Date: 1994/04/26 13:33:58 $
d84 1
a84 1
#define BUFFERSIZE (16 << 11) /* bytes */
d350 1
a350 1
static void putinbuffer(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,unsigned32 value)
d352 8
d726 1
a726 1
static int32 loadcurrentvalue(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,int32 roff)
d746 1
a746 1
  putinbuffer(buffer,pboff,pcodepos,(initLDR(0x2,0xC) | roff)) ;
d755 1
a755 1
   putinbuffer(buffer,pboff,pcodepos,(initLDR(0x2,0x0) | remainder)) ;
d764 1
a764 1
static void storenewvalue(unsigned char *buffer,unsigned32 *pboff,unsigned32 *pcodepos,int32 roff,int32 remainder)
d768 1
a768 1
  putinbuffer(buffer,pboff,pcodepos,(initSTR(0x2,0xC) | roff)) ;
d770 1
a770 1
  putinbuffer(buffer,pboff,pcodepos,(initSTR(0x2,0x0) | remainder)) ;
d1667 1
a1667 1
            putinbuffer(buffer,&boff,&codepos,inst) ;
d1670 1
a1670 1
          putinbuffer(buffer,&boff,&codepos,inst) ;
d1700 1
a1700 1
        putinbuffer(buffer,&boff,&codepos,stubPush) ;
d1726 2
a1727 2
         putinbuffer(buffer,&boff,&codepos,stubStore) ;
         putinbuffer(buffer,&boff,&codepos,stubPop) ;
d1730 1
a1730 1
        putinbuffer(buffer,&boff,&codepos,stubCall) ;
d2046 1
a2046 1
   putinbuffer(buffer,&boff,&codepos,Branch(dref->codepos,(codepos << 2))) ;
d2139 1
a2139 1
   putinbuffer(buffer,&boff,&codepos,initCMP) ;
d2203 1
a2203 1
         putinbuffer(buffer,&boff,&codepos,initSTRfn) ;
d2208 1
a2208 1
   putinbuffer(buffer,&boff,&codepos,returnCall) ;
d2353 2
a2354 2
   putinbuffer(buffer,&boff,&codepos,initCMP1) ;
   putinbuffer(buffer,&boff,&codepos,initReturn1) ;
d2379 2
a2380 2
     putinbuffer(buffer,&boff,&codepos,initLDRcopy) ;
     putinbuffer(buffer,&boff,&codepos,initSTRdata) ;
d2383 2
a2384 2
       putinbuffer(buffer,&boff,&codepos,initSUBS) ;
       putinbuffer(buffer,&boff,&codepos,BranchCC(looppos,(codepos << 2),ccNE)) ;
d2398 1
a2398 1
       putinbuffer(buffer,&boff,&codepos,zeroMOVa4) ;
d2401 1
a2401 1
       putinbuffer(buffer,&boff,&codepos,initSTRdata) ;
d2404 2
a2405 2
         putinbuffer(buffer,&boff,&codepos,initSUBS) ;
         putinbuffer(buffer,&boff,&codepos,BranchCC(looppos,(codepos << 2),ccNE)) ;
d2535 1
a2535 1
                     remainder = loadcurrentvalue(buffer,&boff,&codepos,roff) ;
d2544 2
a2545 2
                     putinbuffer(buffer,&boff,&codepos,initADDcode) ; /* add current value into address */
                     storenewvalue(buffer,&boff,&codepos,roff,remainder) ;
d2587 1
a2587 1
                       remainder = loadcurrentvalue(buffer,&boff,&codepos,roff) ;
d2590 2
a2591 2
                       putinbuffer(buffer,&boff,&codepos,initADDcode) ; /* add current value into address */
                       storenewvalue(buffer,&boff,&codepos,roff,remainder) ;
d2620 1
a2620 1
                 remainder = loadcurrentvalue(buffer,&boff,&codepos,roff) ;
d2623 1
a2623 1
                 putinbuffer(buffer,&boff,&codepos,initADDinto) ;
d2628 1
a2628 1
                 storenewvalue(buffer,&boff,&codepos,roff,remainder) ;
d2642 1
a2642 1
   putinbuffer(buffer,&boff,&codepos,returnCall) ;
@


1.28
log
@Fixed the empty AOF object file problem. A <= 0 check should
just have been < 0. Also added some comments explaining the
new data initialisation comparison.
@
text
@d8 1
a8 1
 * $Revision: 1.27 $
d10 1
a10 1
 *     $Date: 1994/04/26 11:43:04 $
d84 1
a84 1
#define BUFFERSIZE (16 << 10) /* bytes */
@


1.27
log
@Fixed data initialisation to skip stage #1.  This improves the speed of initialisation and fixes the bug with _SysLib_Init() (in nucleus/syslib/misc.c) being called before static data is zeroed rather than after.
@
text
@d8 1
a8 1
 * $Revision: 1.26 $
d10 1
a10 1
 *     $Date: 1994/04/20 10:33:52 $
d180 1
a180 1
#define initReturn1 (0x01A0F00E)    /* "MOVeq pc, lr"	 */
d372 1
a372 1
   if (csize <= 0)
d376 15
a390 12
     if (cf_seek(oep->cf,cidx) != 0)
      error("Failed to seek to the start of Chunk %d in \"%s\"",cidx,oep->fname) ;
     else
      if ((buffer = (void *)malloc((int)csize)) == NULL)
       error("Failed to allocate 0x%08X bytes for Chunk %d in \"%s\"",csize,cidx,oep->fname) ;
      else
       if (cf_loadentry(oep->cf,buffer,csize) != 0)
        {
         error("Failed to load Chunk %d data from \"%s\"",cidx,oep->fname) ;
         free(buffer) ;
         buffer = NULL ;
        }
d1114 1
a1114 1
               error("Symbol table not found") ;
d1117 1
a1117 1
               error("String table not found") ;
d1120 1
a1120 1
               error("Code/Data Areas not found") ;
d2337 10
a2346 2
   putinbuffer( buffer, &boff, &codepos, initCMP1 );
   putinbuffer( buffer, &boff, &codepos, initReturn1 );
d2350 1
a2350 1
   
@


1.26
log
@Fixed a problem highlighted by using armasm. If a local symbol appeared with
the same name as an AREA, then two identical data symbols would be
created. The AREA names have now been extended with some more identification
to try and avoid symbol and area name clashes.
@
text
@d8 3
a10 3
 * $Revision: 1.24 $
 *   $Author: nickc $
 *     $Date: 1994/04/07 10:55:16 $
d179 2
d2334 6
@


1.25
log
@Fixed library initialisation problem to do with the "firstdata" symbol.
@
text
@d78 1
d926 1
a926 1
 if ((strlen(ldaname) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
d928 1
a928 1
 sprintf(tmpbuffer,"%s_%s",ldaname,infile_duplicate) ;
d987 9
a1023 8
   if (*firstdata == NULL)
    {
     *firstdata = malloc(strlen(symname) + 1) ;
     if (*firstdata == NULL)
      error("Failed to allocate string buffer") ;
     strcpy(*firstdata,symname) ;
     trace("declareDATA: firstdata = \"%s\"",*firstdata) ;
    }
a1024 1

d1733 1
d1765 1
d1855 1
a1855 1
      if (forceind || (sattr & LSYM_LCODE) || check_symbol(symname)) /* local code symbol or explicit code symbol */
d1971 1
a1971 1
         if ((strlen(symname) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
d1973 4
a1976 1
         sprintf(tmpbuffer,"%s_%s",symname,infile_duplicate) ;
@


1.24
log
@fixed bug in declareDATA() [Jamie & nick]
@
text
@d8 3
a10 3
 * $Revision: 1.23 $
 *   $Author: vlsi $
 *     $Date: 1994/04/05 13:05:44 $
d624 2
d1015 8
a1022 1
    *firstdata = symname ;
@


1.23
log
@Fixed data area relocs. by adding relative base offset.
Force indirections via module table for accesses to exported symbols.
Added some comments.
@
text
@d8 1
a8 1
 * $Revision: 1.20 $
d10 1
a10 1
 *     $Date: 1994/01/25 17:14:47 $
d915 1
a915 1
 unsigned32 *sorder = (ssize + ((int)slimit * sizeof(unsigned32))) ;
d944 1
d985 1
a985 1

d1772 5
a1776 2
     write_text(LOCALADDRSYM,strlen(LOCALADDRSYM),ofp) ; write_number((unsigned int)(dref->destreg),ofp) ; write_byte('_',ofp) ;
     write_text(symname,strlen(symname),ofp) ; write_byte('_',ofp) ;
d1843 1
a1843 1
     if (forceind || (sattr & LSYM_LCODE) || check_symbol(symname)) /* local code symbol or explicit code symbol */
d1964 1
a1964 1

d2019 2
a2020 1
  }
d2023 1
a2023 1

d2092 1
d2632 1
a2632 1

@


1.22
log
@Fixed Zero-Init DATA declarations.
The program was not defining un-named datums in the DATA area.
@
text
@d32 5
d40 1
a40 2
 * already have been zeroed by the task manager.
 */
d1719 1
a1719 1
   unsigned32  sattr ;
d1723 1
d1799 26
a1824 1
    localcode = TRUE ;
d1833 1
a1833 2
      * linker directives.
      */
d1839 1
a1839 1
     if ((sattr & LSYM_LCODE) || check_symbol(symname)) /* local code symbol or explicit code symbol */
d1841 1
a1841 1
       if (sattr & LSYM_LCODE) /* local code symbol */
d1885 1
d2293 1
d2362 2
d2385 1
d2407 1
a2407 1
               trace("datainit: reloc %d : rflags 0x%08X : roff 0x%08X",rloop,rflags,roff);
d2443 3
d2461 1
d2470 1
d2549 2
d2558 3
d2563 6
d2577 1
a2577 4
                  {
                   trace("sval = 0x%08X",sval) ;
                   geninst(buffer,&boff,&codepos,(int32)sval,initADDmore,initADDmore) ;
                  }
@


1.21
log
@Updated to deal with multi-instruction relocations in the code areas.
@
text
@a37 8
/* If "PROVIDELOCALDATAAREANAMES" is defined then the convertor will
 * generate symbols that reference the start of the individual data areas
 * within the module table data declarations. It may also generate code
 * to reference these if relocations access data areas rather than
 * symbols within the data areas.
 * This option is not required, but does provide more verbose GHOF files.
 */

d222 3
d466 2
d544 1
d546 1
d904 1
a904 1
static void declareDATA(s_aof *adesc,FILE *ofp,int32 slimit,char **firstdata,int32 asize,int32 anoff)
d909 3
a911 1
 unsigned32 *ssize = (unsigned32 *)malloc((int)slimit * sizeof(unsigned32)) ;
d916 7
d924 4
a927 1
  ssize[sloop] = -1 ; /* initialise the vector */
d936 5
d970 1
d975 8
a982 1
 for (sloop = 0; (sloop < slimit); sloop++)
d984 4
a987 6
   if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == anoff)
    {
     if (ssize[sloop] != -1)
      {
       char       *symname = findstring(adesc,(int)READ(adesc->be,adesc->aofsymt[sloop].sym_name)) ;
       unsigned32  sattr = READ(adesc->be,adesc->aofsymt[sloop].sym_AT) ;
d989 2
a990 3
       if (((sattr & SYM_REFDEFMASK) != SYM_REFAT) && ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT)) /* local symbol */
        {
         char *tmpbuffer ;
d992 2
a993 2
         if ((tmpbuffer = (char *)malloc(TBUFFSIZE)) == NULL)
          error("Failed to allocate memory for temporary symbol name buffer") ;
d995 2
a996 4
         if ((strlen(symname) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
          error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",symname,infile_duplicate) ;
         sprintf(tmpbuffer,"%s_%s",symname,infile_duplicate) ;
         symname = tmpbuffer ;
d998 8
a1005 5
         /* FIXME: This introduces a bit of a memory leak, since we do
          * not release this buffer (since it is passed outside the
          * scope of this function).
          */
        }
d1007 2
a1008 2
       if (*firstdata == NULL)
        *firstdata = symname ;
d1010 1
a1010 3
       defineDATA(ofp,ssize[sloop],symname) ;
      }
    }
d1015 1
a1142 1
 char          *tmpbuffer = NULL ;
a1434 2
                   trace("Based relocation") ;

d1448 2
d1485 2
d1515 4
d1523 1
a1523 1
                                     /* lval = 0 ; */ /* "lval" is the offset into the area */
d1526 4
a1529 1
                                    error("No local data area symbol for relocation : area %s offset 0x%08X",findstring(adesc,areaname),lval) ;
d1710 1
a1729 1

d1749 1
a1749 1
       /* error("Reference to local data area %s offset 0x%08X",symname,dref->offset) ; */
d1814 1
d1922 1
a2046 2
     int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
     int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
d2050 5
a2054 8
#if defined(PROVIDELOCALDATAAREANAMES)
       char *ldaname = findstring(adesc,READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name)) ;
       if ((strlen(ldaname) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
        error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",ldaname,infile_duplicate) ;
       sprintf(tmpbuffer,"%s_%s",ldaname,infile_duplicate) ;
       defineDATA(ofp,0,tmpbuffer) ;
#endif /* PROVIDELOCALDATAAREANAMES */
       declareDATA(adesc,ofp,slimit,&firstdata,asize,anoff) ;
a2060 2
     int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
     int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
d2064 5
a2068 8
#if defined(PROVIDELOCALDATAAREANAMES)
       char *ldaname = findstring(adesc,READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name)) ;
       if ((strlen(ldaname) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
        error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",ldaname,infile_duplicate) ;
       sprintf(tmpbuffer,"%s_%s",ldaname,infile_duplicate) ;
       defineDATA(ofp,0,tmpbuffer) ;
#endif /* PROVIDELOCALDATAAREANAMES */
       declareDATA(adesc,ofp,slimit,&firstdata,asize,anoff) ;
a2147 1

@


1.20
log
@Updated to support armcc 1.61 area relative relocations.
@
text
@d8 3
a10 3
 * $Revision: 1.15 $
 *   $Author: nickc $
 *     $Date: 1994/01/20 16:50:01 $
d1199 2
a1200 1
       int         iloop ;
d1202 1
d1217 1
d1257 1
a1257 1
         if (nrelocs > 0)
a1258 1
           aof_reloc *reloc = NULL ;
d1260 1
d1265 1
a1265 1
              reloc = &(relocs[rloop]) ;
d1269 10
a1278 1
           /* "reloc" is non-NULL is this instruction has a relocation field */
d1284 1
a1287 1
             unsigned32 count ;
d1298 1
a1298 1
               count = rel2_ins(relflags) ;
d1307 2
a1308 1
               count = 1 ;
d1311 12
a1322 2
             trace( "relocation %d : offset = 0x%08X",rloop,READ(adesc->be,reloc->rel_offset)) ;
             trace( "symindex = %d", symindex ) ;
d1324 2
d1336 2
d1348 1
a1348 1
              /* else warning "PC-relative instruction to a non-imported symbol" */
d1354 44
a1397 2
                   write_byte(PATCHARMJP,ofp) ; /* PATCH ARM JP */
                   write_encoded((int)inst,ofp) ; /* B 0x???????? */
d1402 1
d1412 4
a1415 1
                   trace( "based relocation" ) ;
d1597 1
@


1.19
log
@Applid upgrade from Jamie to fix 1.61 bug
@
text
@d35 1
a35 1
 * already have been zeroed.
d43 1
d565 1
d573 1
a573 1
   /* Check for exported symbol with matching definition */
d576 1
a576 1
   if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && (READ(adesc->be,adesc->aofsymt[sloop].sym_value) == sval) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_DEFAT))
d578 11
a588 2
     symindex = sloop ;
     break ; /* out of the loop */
d592 3
d1430 6
a1435 1
                                  lval = 0 ; /* we have a symbol */
d1438 1
a1438 1
                                lval = 0 ; /* we now have a symbol */
@


1.18
log
@added support for new 1.61 compiler (Jamie)
@
text
@d1607 11
d1621 1
a2070 1

@


1.17
log
@more patches from Jamie plus fix to memory corruption (turned into a memory leak!)
@
text
@d38 7
d204 6
d463 1
a463 7
static void
add_data_ref(
             s_aof *    adesc,
             int32      symindex,
             unsigned32 offset,
             unsigned32 destreg,
             unsigned32 codepos )
d465 1
a465 1
 s_dataref *New = (s_dataref *)malloc(sizeof(s_dataref)) ;
d467 1
a467 1
 if (New == NULL)
d470 5
a474 4
 New->symindex = symindex ;
 New->offset   = offset ;
 New->destreg  = destreg ;
 New->codepos  = codepos ;
d476 2
a477 2
 New->next     = adesc->drefs ;
 adesc->drefs  = New ;
d485 1
a485 2
/* FIXME : this should really just be a macro */

d488 1
a488 1
 return (char *) (adesc->aofstrt + offset) ;
d559 26
d874 15
d955 9
a963 1
	  char       *tmpbuffer ;
d965 4
a968 9
	  if ((tmpbuffer = (char *)malloc(TBUFFSIZE)) == NULL)
	    error("Failed to allocate memory for temporary symbol name buffer") ;
	  
	  if ((strlen(symname) + 1 + strlen(infile_duplicate) + 1) > TBUFFSIZE)
	   error("Symbol name \"%s\" and filename \"%s\" too long for temporary buffer",
		 symname,infile_duplicate) ;
	  
	  sprintf(tmpbuffer,"%s_%s",symname,infile_duplicate) ;
	  symname = tmpbuffer ;
d972 3
a974 9
	 *firstdata = symname ;
       
       if (ofp != NULL)
        {
         write_byte(OBJDATA,ofp) ;
         write_encoded((int)ssize[sloop],ofp) ;
         write_byte('_',ofp) ;
         write_string(symname,strlen(symname),ofp) ;
        }
d1373 1
d1379 1
a1379 1
                             
d1392 29
a1420 1
                              symindex = find_exported(adesc,slimit,lval,READ(adesc->be,adesc->aofhdr->aof_areas[symindex].area_name)) ;
d1435 3
d1440 7
a1446 6
                             if (symindex == -1)
                              error("Exported symbol not found for relocation") ;

                             sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                             symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[symindex].sym_name)) ;
                             sattr |= LSYM_DATAREF ; WRITE(adesc->be,adesc->aofsymt[symindex].sym_AT,sattr) ; /* update symbol information */
d1480 1
a1480 1
                             add_data_ref(adesc,symindex,lval,((inst >> 12) & 0xF),(codepos << 2)) ;
d1591 3
a1593 3
   char       *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[dref->symindex].sym_name)) ;
   unsigned32  sattr = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_AT) ;
   int32       aname = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_areaname) ;
d1596 29
d1671 1
a1671 1
     sval = (((codepos << 2) + 0x8) - (codebase[aloop] + READ(adesc->be,adesc->aofsymt[dref->symindex].sym_value) + dref->offset)) ;
d1915 10
a1924 1
      declareDATA(adesc,ofp,slimit,&firstdata,asize,anoff) ;
d1934 10
a1943 1
      declareDATA(adesc,ofp,slimit,&firstdata,asize,anoff) ;
d2023 25
d2243 1
a2243 1
               aof_symbol *symbol ;
d2247 1
a2267 3
               if (area)
                error("Relocation is relative to an AREA") ;

d2282 22
a2303 3
               symbol = &(adesc->aofsymt[symindex]) ;
               symname = findstring(adesc,(int)READ(adesc->be,symbol->sym_name)) ;
               symaname = READ(adesc->be,symbol->sym_areaname) ;
d2306 6
a2311 2
               if (symaname == anoff)
                localdataarea = loop ; /* within this area */
d2314 1
a2314 1
                 if ((READ(adesc->be,symbol->sym_AT) & SYM_REFDEFMASK) == SYM_REFAT)
d2316 3
a2318 1
                   int32 remainder ;
d2320 2
a2321 2
                   if (first)
                    first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ;
d2323 2
a2324 2
                   roff += datapos[loop] ; /* offset within module table to be relocated */
                   remainder = loadcurrentvalue(buffer,&boff,&codepos,roff) ;
d2326 3
a2328 3
                   if (ofp != NULL)
                    write_data(buffer,(int)boff,ofp) ;
                   boff = 0 ; /* flush the code buffer */
d2330 2
a2331 2
                   /* load the required data or code pointer */
                   referenceexternal(ofp,symname,0x1,&codepos,tiny) ;
d2333 4
a2336 19
                   putinbuffer(buffer,&boff,&codepos,initADDcode) ; /* add current value into address */
                   storenewvalue(buffer,&boff,&codepos,roff,remainder) ;
                  }
                 else /* internal symbol */
                  {
                   int iloop ; /* internal area loop */
                   unsigned32 localattr ;

                   for (iloop = 0; (iloop < nareas); iloop++)
                    if (symaname == READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_name))
                     break ; /* out of the for loop */

                   if (iloop == nareas)
                    error("Local area not found for symbol \"%s\"",symname) ;

                   localattr = READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_attributes) ;
                   if (!(localattr & AOF_CODEAT) && !(localattr & AOF_BASEDAT) && !(localattr & AOF_SHLDATA))
                    localdataarea = iloop ; /* symbol references a local data area */
                   else /* must be a local code symbol */
d2338 2
a2339 2
                     unsigned32 sval = READ(adesc->be,symbol->sym_value) ;
                     int32      remainder ;
a2340 3
                     /* We can generate a relocation using a PC-relative
                      * label reference.
                      */
d2342 3
a2344 2
                      if (READ(adesc->be,adesc->aofhdr->aof_areas[iloop].area_name) == symaname)
                       break ;
d2346 12
a2357 3
                      error("Referenced symbol offset 0x%08X does NOT have an area name",sval) ;
                     if (codebase[iloop] == -1)
                      error("Address of area containing symbol offset 0x%08X not known",sval) ;
d2359 1
a2359 3
                     roff += datapos[loop] ; /* offset within module table to be relocated */
                     if (first)
                      first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ; /* load the required module table pointer */
d2361 21
a2381 5
                     remainder = loadcurrentvalue(buffer,&boff,&codepos,roff) ;
                     sval = (((codepos << 2) + 0x8) - (codebase[iloop] + sval)) ;
                     geninst(buffer,&boff,&codepos,sval,initSUBfn,initSUBfn2) ; /* address of symbol in "a2" */
                     putinbuffer(buffer,&boff,&codepos,initADDcode) ; /* add current value into address */
                     storenewvalue(buffer,&boff,&codepos,roff,remainder) ;
a2390 1
                 int32 sval = READ(adesc->be,symbol->sym_value) ;
a2392 1
                 sval += datapos[loop] ; /* referenced offset within this data area within module table */
d2402 1
a2402 1
                 if (sval > 0)
d2404 2
a2405 2
                   trace( "sval = 0x%08X", sval ) ;
                   geninst(buffer,&boff,&codepos,sval,initADDmore,initADDmore) ;
@


1.16
log
@added patch created by Jamie
@
text
@d31 7
d81 5
d91 1
a91 1
#define HOF_title_len           (32)   /* length of a standard module name */
d98 1
a98 1
#define CodePrefix_()		(bDeviceDriver ? '.' : '_')
d606 52
a663 10
 /* Load the current value */
 if (roff < 4096)
  putinbuffer(buffer,pboff,pcodepos,(initLDR(0x2,0xC) | roff)) ;
 else
  {
   int base = (int)roff ;

   remainder = (roff & (4096 - 1)) ;
   base -= (int)remainder ;

a675 7
 *
 * TODO : If the linker made two passes we would know whether external
 * symbols were data or code during the object conversion. This would
 * allow the initialisation code to be optimised for loading the
 * address of code or data. At the moment using the AOF patch
 * directives means that 8bytes are wasted whenever the address of a
 * code symbol is required during the initialisation code.
d678 10
d845 3
a847 3
 int hidx ;
 int last = (int)asize ; /* last possible data position in this area (for zero-length object) */
 int sloop ;
d902 6
a907 1
       char *symname = findstring(adesc,(int)READ(adesc->be,adesc->aofsymt[sloop].sym_name)) ;
d909 11
d921 2
a922 13
	 {
	   if (bSharedLib)
	     {
	       *firstdata = malloc( strlen( symname ) + strlen( infile_duplicate ) + 2 );
	       if (*firstdata == NULL) error( "out of memory again" );
	       strcpy( *firstdata, symname );
	       strcat( *firstdata, "_" );
	       strcat( *firstdata, infile_duplicate );
	       symname = *firstdata;
	     }
	   else
	     *firstdata = symname ;
	 }
d1062 2
a1063 1
 long		swpos = -1L ;
d1068 3
d1098 3
a1100 10
#if 0
 if (ofp == NULL) /* only perform these calculations on the first pass */
  {
#endif
   CalculateMaxCodeP(adesc,slimit,nareas) ;
   CalculateMaxData(adesc,nareas) ;
   trace("maxcodep = 0x%08X, maxdata = 0x%08X",maxcodep,maxdata) ;
#if 0
  }
#endif
d1387 11
a1397 12
			       if (dolib || kernel)
				 {
				   /* XXX - NC - 20/1/94
				    * If building for library/kernel there is a possibility that
				    * this label will clash with one in a different file.  Hence
				    * we must make it unique.
				    */
				   write_byte('_',ofp);
				   write_text(outfile,strlen(outfile),ofp);
				 }
			       
			       write_byte('\0',ofp) ;
d1530 9
a1538 9
       {
	 /* XXX - NC - 20/1/94
	  * If building for library/kernel there is a possibility that
	  * this label will clash with one in a different file.  Hence
	  * we must make it unique.
	  */
	 write_byte('_',ofp);
	 write_text(outfile,strlen(outfile),ofp);
       }
d1680 8
d1708 1
a1708 1

d1829 4
d1839 5
a1843 5
       {
	 write_text(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
	 write_byte('_',ofp);
	 write_string(outfile,strlen(outfile),ofp);
       }
d1845 1
a1845 1
       write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
d1908 13
d1997 5
a2001 5
       {
	 write_text(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
	 write_byte('_',ofp);
	 write_string(outfile,strlen(outfile),ofp);
       }
d2003 1
a2003 1
       write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
d2034 1
d2055 1
d2070 1
d2131 1
a2131 1
	       if ((ft == 1) || (ft == 2))
d2145 1
a2145 1
		   int32 remainder ;
d2148 1
a2148 1
		    first = referencedata(ofp,&codepos,firstdata,tiny,dolib) ;
d2150 2
a2151 2
		   roff += datapos[loop] ; /* offset within module table to be relocated */
		   remainder = loadcurrentvalue(buffer,&boff,&codepos,roff) ;
d2153 3
a2155 3
		   if (ofp != NULL)
		    write_data(buffer,(int)boff,ofp) ;
		   boff = 0 ; /* flush the code buffer */
d2158 1
a2158 35
                   if (ofp != NULL)
		    {
		     write_byte(OBJWORD,ofp) ;
		     write_byte(PATCHARMDT,ofp) ;
		     write_encoded(LDRfromdp(1),ofp) ;
		     write_byte(OBJDATAMODULE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
		    }
		   codepos++ ;

		   /* LSB */
		   if (ofp != NULL)
		    {
                     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFLSB,ofp) ; write_encoded((int)0x1,ofp) ;
		     write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
		    }
		   codepos++ ;

		   if (!tiny) /* shorter access sequence */
		    {
		     /* MID */
		     if (ofp != NULL)
		      {
		       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFMID,ofp) ; write_encoded((int)0x1,ofp) ;
		       write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
		      }
		     codepos++ ;
		    }

		   /* REST */
		   if (ofp != NULL)
		    {
		     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMAOFREST,ofp) ; write_encoded((int)0x1,ofp) ;
		     write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
		    }
		   codepos++ ;
d2161 1
a2161 1
		   storenewvalue(buffer,&boff,&codepos,roff,remainder) ;
d2291 1
a2291 1
  
d2294 5
a2298 1
 free(buffer) ; /* release the temporary output buffer */
@


1.15
log
@fixed name of first data item
@
text
@d6 1
a6 1
 * Original Author: Jamie Smith
d8 1
a8 1
 * $Revision: 1.14 $
d10 1
a10 1
 *     $Date: 1994/01/20 14:31:44 $
d1556 1
a1556 1
         if (kernel) /* (or device driver) treat as a local code access */
d1642 1
a1642 1
  
@


1.14
log
@fixed generation of address initialisation labels
@
text
@d8 1
a8 1
 * $Revision: 1.13 $
d10 1
a10 1
 *     $Date: 1994/01/20 12:35:58 $
d848 13
a860 1
        *firstdata = symname ;
@


1.13
log
@fixed label clash for addr stub generation when building libraries
@
text
@d8 1
a8 1
 * $Revision: 1.12 $
d10 1
a10 1
 *     $Date: 1994/01/17 16:17:00 $
d1756 8
a1763 1
     write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
d1900 9
a1908 1
     write_byte(OBJLABEL,ofp) ; write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
@


1.12
log
@latest version from Jamie.  Fixes a few relocation bugs
@
text
@d8 1
a8 1
 * $Revision: 1.11 $
d10 1
a10 1
 *     $Date: 1994/01/14 12:15:09 $
d1314 14
a1327 1
                               write_number((unsigned int)(codepos << 2),ofp) ; write_byte('\0',ofp) ;
d1457 14
a1470 1
     write_number((unsigned int)(dref->codepos),ofp) ; write_byte('\0',ofp) ;
@


1.11
log
@fixed naming of code labels when building kernel
@
text
@d8 1
a8 1
 * $Revision: 1.10 $
d10 1
a10 1
 *     $Date: 1994/01/13 15:09:37 $
d1518 42
a1559 3
         if (ofp == NULL)
          codepos += 2 ;
         else
d1562 7
a1568 4
           write_byte(OBJWORD,ofp) ;
           write_byte(PATCHARMDT,ofp) ;
           write_encoded(LDRfromdp(dref->destreg),ofp) ;
           write_byte(OBJDATAMODULE,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
d1571 7
a1577 4
           write_byte(OBJWORD,ofp) ;
           write_byte(PATCHARMDT,ofp) ;
           write_encoded(LDRfromoffset(dref->destreg),ofp) ;
           write_byte(OBJCODESYMB,ofp) ; write_byte(CodePrefix_(),ofp) ; write_string(symname,strlen(symname),ofp) ;
d1685 1
a1685 1
           write_byte('_',ofp) ;
d2160 1
a2160 1
           write_byte('_',ofp) ;
@


1.10
log
@Fixed data-initialisation bug.
Also added TODOs where the object size could be made smaller.
@
text
@d8 1
a8 1
 * $Revision: 1.6 $
d10 1
a10 1
 *     $Date: 1994/01/05 16:28:44 $
d81 7
d1400 1
a1400 1
         write_byte(OBJDATAMODULE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d1409 1
a1409 1
         write_byte(OBJCODESYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d1526 1
a1526 1
           write_byte(OBJDATAMODULE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d1532 1
a1532 1
           write_byte(OBJCODESYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
@


1.9
log
@Added some comments to highlight how the converted code could be optimised.
Also fixed some compiler warnings.
@
text
@d405 1
a405 1
   /* Generate intermediate subtract instructions */
d2036 1
a2036 1
                     sval = (((codepos << 2) + 0x8) - (sval - codebase[iloop])) ;
a2037 1

d2042 1
@


1.8
log
@fixed compile time warning in SUN world
@
text
@d8 1
a8 1
 * $Revision: 1.7 $
d10 1
a10 1
 *     $Date: 1994/01/07 14:20:02 $
d602 22
d673 2
a674 3
              if ( READ( adesc->be, adesc->aofhdr->aof_areas[ aloop ].area_name) == aname &&
                  (READ( adesc->be, adesc->aofhdr->aof_areas[ aloop ].area_attributes )
                       & AOF_CODEAT)) /* an exported code symbol */
d729 1
a729 1
  
d758 1
a758 1
  PWRITE( 0, buffer,     READ( adesc->be, adesc->aofhdr->aof_vsn ) );
@


1.7
log
@Fixed data relocation
@
text
@d8 1
a8 1
 * $Revision: 1.6 $
d10 1
a10 1
 *     $Date: 1994/01/05 16:28:44 $
d2108 1
a2108 1
   write_text(buffer,sizeof(unsigned32),ofp) ; /* since write_data adds a leading CODE directive */
@


1.6
log
@fixed compile time warnings from SUN4 world
@
text
@d8 1
a8 1
 * $Revision: 1.5 $
d10 1
a10 1
 *     $Date: 1994/01/05 14:44:29 $
d134 2
a135 2
/* "MOVNV r0,r0"        NOP */
#define ARMNOP  (0xF1A00000)            /* do nothing for 1cycle */
d144 3
a146 3
#define stubPush  (0xE92D5000)		/* "STMFD sp!,{ip,lk}" */
#define stubStore (0xE58DC004)		/* "STR   ip,[sp,#4]"  */
#define stubPop	  (0xE8Bd9000)		/* "LDMFD sp!,{ip,pc}" */
d164 1
d166 5
a170 3
#define initADDdp   (0xE2892000)    /* "ADD  a3,dp,#0"   */
#define initADDinto (0xE081100C)    /* "ADD  a2,a2,ip"   */
#define initADDmore (0xE2811000)    /* "ADD  a2,a2,#0"   */
d194 2
a195 2
static unsigned32     maxcodep = 0 ;
static unsigned32     maxdata  = 0 ;
d234 1
a234 2
 if (fp != NULL)
  putc((((n & (LO6MASK << shift)) >> shift) | sign | more),fp) ;
d240 1
a240 2
     if (fp != NULL)
      putc((((n & (LO7MASK << shift)) >> shift) | ((shift == 0) ? 0 : ENC_MORE)),fp) ;
d252 2
a253 2
  putc(val,fp) ;
  return ;
d261 2
a262 3
  for (; (length > 0); length--)
    putc(*text++,fp) ;

a274 1

d283 3
a285 4
  write_text(text,length,fp) ;
  putc('\0',fp) ;

  return ;
d307 7
a313 2
  putc(OBJBSS,fp) ;
  (void)write_encoded(amount,fp) ;
d315 5
d394 35
d433 5
a437 5
	     s_aof *	adesc,
	     int32	symindex,
	     unsigned32 offset,
	     unsigned32 destreg,
	     unsigned32 codepos )
d507 116
d627 3
a629 3
		  s_aof *	adesc,
		  int32		slimit,
		  int32		nareas)
d638 1
a638 1
      unsigned32	sattr = READ( adesc->be, adesc->aofsymt[ loop ].sym_AT ) ;
d644 13
a656 13
	{
	  int32 aname = READ( adesc->be, adesc->aofsymt[ loop ].sym_areaname) ;
	  int   aloop ;
	  

	  for (aloop = 0; (aloop < nareas); aloop++)
	    {
	      if ( READ( adesc->be, adesc->aofhdr->aof_areas[ aloop ].area_name) == aname &&
		  (READ( adesc->be, adesc->aofhdr->aof_areas[ aloop ].area_attributes )
		       & AOF_CODEAT)) /* an exported code symbol */
		maxcodep += sizeof (unsigned32) ;
	    }
	}
d668 2
a669 2
		 s_aof *	adesc,
		 int32		nareas )
d671 1
a671 1
  int	loop;
d681 1
a681 1
      unsigned32 	attr = READ( adesc->be, adesc->aofhdr->aof_areas[ loop ].area_attributes) ;
d685 5
a689 5
	  !(attr & AOF_BASEDAT) &&
	  !(attr & AOF_SHLDATA))
	{
	  maxdata += READ( adesc->be, adesc->aofhdr->aof_areas[ loop ].area_size ) ;
	}
d699 1
a699 1
static void
d701 3
a703 3
		   s_aof * 	adesc,
		   unsigned32 *	buffer,
		   FILE *       ofp )
d706 2
a707 1
  int		 loop;
d713 1
a713 1
  write_encoded( -1, ofp );  	/* MODULE -1 */
d717 2
d751 1
a751 1
  return;
d756 82
a839 1
  
d934 1
a934 3
/*{{{  First_convert_aof */

/*---------------------------------------------------------------------------*/
d943 1
a943 6
unsigned32
First_convert_aof(
		  s_aof *	adesc,
		  int		dolib,
		  int		tiny,
		  int		kernel )
d945 3
a949 1
 unsigned char *buffer = NULL ;
a954 1
 unsigned32    *codebase = NULL ;
d959 2
d963 7
a969 1
   error("Failed to allocate temporary buffer") ;
d971 1
a971 3
 codebase = (unsigned32 *)malloc((int)nareas * sizeof(unsigned32)) ;
 
 if (codebase == NULL)
d973 1
a973 1
 
d977 1
d979 12
a990 1
   error( "drefs not null" );
d992 10
a1001 2
 CalculateMaxCodeP( adesc, slimit, nareas );
 CalculateMaxData(  adesc, nareas );
d1003 1
a1003 1
 trace( "maxcodep = 0x%08X, maxdata = 0x%08X", maxcodep, maxdata ) ;
a1004 2
 /* Allow for header at start of object file */
 
d1006 15
a1020 4
   codepos += sizeof( Module ) / sizeof (unsigned32);
   
 /* Output the code areas */
 
d1048 2
d1073 9
a1081 1
             boff = 0 ; /* flush the code buffer */
d1087 2
d1094 1
a1094 1
	 trace( "code[0x%08X] = 0x%08X",(iloop << 2),inst) ;
d1140 2
a1141 2
	     trace( "relocation %d : offset = 0x%08X",rloop,READ(adesc->be,reloc->rel_offset)) ;
	     trace( "symindex = %d", symindex ) ;
d1153 2
d1163 1
d1165 9
a1173 1
                 /* if (based) then is a possible tailcall */
d1184 1
a1184 1
		   trace( "based relocation" ) ;
d1201 1
d1203 1
a1203 1

a1206 1
                       unsigned32  aattr = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_attributes) ;
a1208 2
		       trace( "area %d : aattr = 0x%08X",aloop,aattr) ;

a1232 1

d1234 1
a1234 1

d1247 1
a1247 30
                              {
                               int   sloop ;
                               int32 sval = lval ; /* FIXME : we don't need another variable */
                               int32 saname = READ(adesc->be,adesc->aofhdr->aof_areas[symindex].area_name) ;

			       trace( "AREA relative: symindex = %d : sval = 0x%08X : saname = 0x%08X",
				     symindex, sval, saname );

/* FIXME : this code can be mostly merged with the code below */

                               symindex = -1 ;

                               /* scan the symbol table for an exported symbol that can be used */
                               for (sloop = 0; (sloop < slimit); sloop++)
                                {
				  trace( "sloop %d : sym_areaname 0x%08X : sym_value 0x%08X : exported %s",
					sloop,
					READ( adesc->be, adesc->aofsymt[ sloop ].sym_areaname ),
					READ( adesc->be, adesc->aofsymt[ sloop ].sym_value ),
					(((READ( adesc->be, adesc->aofsymt[ sloop ].sym_AT) &
					   SYM_REFDEFMASK) == SYM_GLOBALDEFAT) ? "Yes" : "No")) ;

                                 if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && (READ(adesc->be,adesc->aofsymt[sloop].sym_value) == sval) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT))
                                  {
                                   symindex = sloop ;
                                   sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                                   break ; /* out of the loop */
                                  }
                                }
                              }
a1250 1

d1254 7
a1260 15
                                 int   sloop ;
                                 int32 sval = READ(adesc->be,adesc->aofsymt[symindex].sym_value) ;
                                 int32 saname = READ(adesc->be,adesc->aofsymt[symindex].sym_areaname) ;

                                 /* Scan the symbol table for an exported symbol that can be used */
                                 for (sloop = 0; (sloop < slimit); sloop++)
                                  {
                                   /* Check for exported symbol with matching definition */
                                   if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && (READ(adesc->be,adesc->aofsymt[sloop].sym_value) == sval) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT))
                                    {
                                     symindex = sloop ;
                                     sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                                     break ; /* out of the loop */
                                    }
                                  }
d1265 1
a1265 1
                              error("Symbol not found for relocation") ;
d1267 1
d1271 2
d1274 1
d1276 14
a1289 1
                             codepos++ ;
d1305 10
a1314 1
                     dbase = (unsigned32 *)((int)dbase + READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_size) + (nrels * sizeof(aof_reloc))) ;
d1318 1
a1318 1
                  error("Relocation: displaced : %d : 0x%08X : flags 0x%08X (not yet handled)\n",iloop,inst,relflags) ;
d1322 4
a1325 9
	       {
		 error( "No code to deal with byte, short or long relocations yet") ;
		 error( "Have you compiled the file with '-li -apcs 3/reentrant' ?" );
	       }
            }
           else
            {
             /* Output the instruction (always little-endian) */
             PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
d1327 2
a1328 5
          }
         else
          {
           /* Output the instruction (always little-endian) */
           PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
d1330 2
d1339 3
d1352 7
a1358 1
       boff = 0 ; /* flush the code buffer */
d1361 1
a1361 3
        {
         PWRITE(0,(unsigned32 *)(buffer + boff),stubPush) ; boff += sizeof(unsigned32) ; codepos++ ;
        }
d1363 2
d1367 7
d1376 7
d1387 2
a1388 2
         PWRITE(0,(unsigned32 *)(buffer + boff),stubStore) ; boff += sizeof(unsigned32) ; codepos++ ;
         PWRITE(0,(unsigned32 *)(buffer + boff),stubPop) ;   boff += sizeof(unsigned32) ; codepos++ ;
d1391 1
a1391 3
        {
         PWRITE(0,(unsigned32 *)(buffer + boff),stubCall) ; boff += sizeof(unsigned32) ; codepos++ ;
        }
d1396 3
a1399 1
 
d1408 10
a1417 1
   boff = 0 ; /* flush the code buffer */
a1433 4
     unsigned32 inst ;
     unsigned32 shift ;
     unsigned32 imm ;
     int        first = TRUE ;
d1441 1
a1441 18
     while (!rotatable(sval,&shift,0,&imm))
      {
       /* Generate intermediate subtract instructions */
       shift = 0 ;
       if (sval == 0)
        error("FATAL: Value of zero failed rotatable test") ;
       while (((sval >> shift) & 0x3) == 0)
        shift += 2 ;
       inst = ((first ? initSUBr(dref->destreg) : initSUBr2(dref->destreg)) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
       PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
       first = 0 ;

       sval = (sval & ~(0xFFL << shift)) ;
      }

     /* last instruction */
     inst = ((first ? initSUBr(dref->destreg) : initSUBr2(dref->destreg)) | (shift << 8) | imm) ;
     PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
d1443 1
a1443 1
   else
d1445 1
a1445 179
     if (sattr & LSYM_LCODE) /* local code symbol */
      {
	/* LSB */
	codepos++ ;

	if (!tiny) /* shorter access sequence */
	  {
	    /* MID */
	    codepos++ ;
	  }

	/* REST */
	codepos++ ;
      }
     else if (check_symbol(symname)) /* global code symbol */
       {
	 codepos += 2;
       }
     else /* treat as access to a data symbol */
      {
       codepos++ ;
  
       /* LSB */
       codepos++ ;

       if (!tiny) /* shorter access sequence */
        {
         /* MID */
         codepos++ ;
        }

       /* REST */
       codepos++ ;
      }

     if (dref->offset != 0)
      {
       unsigned32 sval = dref->offset ;
       unsigned32 inst ;
       unsigned32 shift ;
       unsigned32 imm ;

       while (!rotatable(sval,&shift,0,&imm))
        {
         /* Generate intermediate instructions */
         shift = 0 ;

         if (sval == 0)
          error("FATAL: Value of zero failed rotatable test") ;

         while (((sval >> shift) & 0x3) == 0)
          shift += 2 ;

         inst = (initADDr(dref->destreg) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
         PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
         sval = (sval & ~(0xFFL << shift)) ;
        }

       /* last instruction */
       inst = (initADDr(dref->destreg) | (shift << 8) | imm) ;
       PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
      }
    }

   PWRITE(0,(unsigned32 *)(buffer + boff),Branch(dref->codepos,(codepos << 2))) ; boff += sizeof(unsigned32) ; codepos++ ;
  }

 boff = 0 ; /* flush the code buffer */

 /* Kernel objects do not contain any initialisation code or module table declarations */
 
 if (!kernel)
  {
    trace( "adding initialisation code ");

   /* mark the start of the initialisation code */
   codepos++ ; /* INIT */

   /* provide CODETABLE definitions for each exported function */
   if (!dolib) /* only when constructing normal objects */
    {
     for (loop = 0; (loop < slimit); loop++)
      {
       unsigned32 sattr = READ(adesc->be,adesc->aofsymt[loop].sym_AT) ;

       /* The CODETABLE directives need to be provided in the same order
        * as the initialisation code below.
        */
       if (((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) && (sattr & LSYM_LCODE))
        {
         char *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
        }
      }
    }

   /* provide DATA directives for every exported or referenced data symbol */
   {
    unsigned32 *ssize = (unsigned32 *)malloc((int) slimit * sizeof(unsigned32)) ;

    if (ssize == NULL)
     error("Failed to allocate memory for symbol table size vector") ;

    /* We step through the data areas in the order they will be
     * initialised below. We need to ensure that the DATA definitions
     * are ordered correctly. Reflecting the order of the data areas and
     * the symbols within the data areas. All the symbols at the same
     * offset have a size value of zero, apart from the last.
     * The "ssize" vector is used to hold the size values calculated
     * for the corresponding symbols.
     */
    for (loop = 0; (loop < slimit); loop++)
     ssize[loop] = -1 ; /* initialise the vector */

    for (loop = 0; (loop < nareas); loop++)
     {
      unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
      int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
      int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;

      if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
       {
        int32 hval = 0 ;
        int   hidx ;
        int   last = (int)asize ;
        int   sloop ;

        /* Process the symbols within this data area */
        do
         {
          hidx = -1 ;
          for (sloop = 0; (sloop < slimit); sloop++)
           {
            /* Check that the symbol references this data area */
            if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == anoff)
             {
              if ((READ(adesc->be,adesc->aofsymt[sloop].sym_value) >= hval) && (ssize[sloop] == -1))
               hidx = sloop ;
             }
           }

          if (hidx != -1)
           {
            int32 sval  = READ(adesc->be,adesc->aofsymt[hidx].sym_value) ;
            ssize[hidx] = (last - sval) ;
            last = (int) sval ;
           }
         } while (hidx != -1) ;

        for (sloop = 0; (sloop < slimit); sloop++)
         {
          if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == anoff)
           {
            if (ssize[sloop] != -1)
             {
              char *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[sloop].sym_name)) ;

              if (firstdata == NULL)
               firstdata = symname ;
             }
           }
         }
       }
     }

    /* Release the symbol size vector */
    free(ssize) ;
   }

   /* provide the initialisation code */
   PWRITE(0,(unsigned32 *)(buffer + boff),initCMP) ; boff += sizeof(unsigned32) ; codepos++ ;
   boff = 0 ; /* flush the code buffer */
   codepos++ ;

   /* Function initialisation */
   if (!dolib) /* library objects have no function initialisation code */
    {
     codepos++ ;

     for (loop = 0; (loop < slimit); loop++)
d1447 1
a1447 2
       unsigned32 sattr = READ(adesc->be,adesc->aofsymt[loop].sym_AT) ;
       if (((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) && (sattr & LSYM_LCODE))
d1449 2
a1450 27
         unsigned32 inst ;
         unsigned32 sval = READ(adesc->be,adesc->aofsymt[loop].sym_value) ;
         unsigned32 shift ;
         unsigned32 imm ;
         int32      aname ;
         int        aloop ;
         int        anum ;
         int        first = TRUE ;

         /* By this point we have dumped the code areas, so it is always a
          * negative offset to the required symbol.
          */
         if ((aname = READ(adesc->be,adesc->aofsymt[loop].sym_areaname)) == 0)
          error("Referenced symbol offset 0x%08X does NOT have an area name",sval) ;
         for (aloop = 0; (aloop < nareas); aloop++)
          if (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname)
           {
            anum = aloop ;
            break ;
           }
         if (anum == nareas)
          error("Area for referenced symbol offset 0x%08X not found",sval) ;
         if (codebase[anum] == -1)
          error("Address of area containing symbol offset 0x%08X not known",sval) ;
         sval = (((codepos << 2) + 0x8) - (sval + codebase[anum])) ;
     
         while (!rotatable(sval,&shift,0,&imm))
d1452 6
a1457 14
           /* Generate intermediate subtract instructions */
           shift = 0 ;

           if (sval == 0)
            error("FATAL: Value of zero failed rotatable test") ;

           while (((sval >> shift) & 0x3) == 0)
            shift += 2 ;

           inst = ((first ? initSUBfn : initSUBfn2) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
           PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
           first = 0 ;

           sval = (sval & ~(0xFFL << shift)) ;
a1458 68

         /* last instruction */
         inst = ((first ? initSUBfn : initSUBfn2) | (shift << 8) | imm) ;
         PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
         PWRITE(0,(unsigned32 *)(buffer + boff),initSTRfn); boff += sizeof(unsigned32) ; codepos++ ;
        }
      }
    }
   /* finish the function initialisation code */
   PWRITE(0,(unsigned32 *)(buffer + boff),returnCall); boff += sizeof(unsigned32) ; codepos++ ;

   /* Initialised data */
   {
    unsigned32 amount = 0 ;

    boff = 0 ; /* flush the code buffer */
 
    dataplace = (codepos << 2) ; /* where the data is being written within the object file */
    limit = 0 ;
    for (loop = 0; (loop < nareas); loop++)
     {
      unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
      int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
      int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;

      base = limit ;
      limit += (asize + (nrelocs * sizeof(aof_reloc))) ;

      if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
       {
        unsigned char *data = (unsigned char *)((int)(adesc->aofareas) + base) ;
        codepos += (asize >> 2) ;
        amount += asize ;
       }
     }

    if (amount != maxdata)
     error("Output amount 0x%08X does not match maxdata amount 0x%08X",(int)amount,(int)maxdata) ;

    if ((amount % sizeof(int)) != 0)
     error("Amount of data written is NOT a word multiple") ; /* we will need to pad with NULs */
   }

   /* Data initialisation code */
   boff = 0 ; /* flush the code buffer */
   if (maxdata != 0) /* data initialisation required */
    {
     int        looppos ;
     unsigned32 inst ;
     unsigned32 sval = dataplace ;
     unsigned32 shift ;
     unsigned32 imm ;
     int        first = TRUE ;
     int        datapos ;

     codepos++ ;

     if (dolib)
      {
       if (firstdata == NULL)
        firstdata = "ERROR_should_be_first_DATA_directive_in_this_object" ;

       /* LSB */
       codepos++ ;

       if (!tiny)
        {
         /* MID */
a1459 89
        }

       /* REST */
       codepos++ ;
      }

     /* code to initialise the data vector */
     /* Copy "maxdata" bytes from above into the module table */ 
     /* Note: we need to deal with BSS correctly. We can have a simple zero
      * initialisation loop.
      */

     /* load "a2" with the address of the initialised data */
     /* TODO * place this duplicated code into a function */
     sval = (((codepos << 2) + 0x8) - sval) ;
     while (!rotatable(sval,&shift,0,&imm))
      {
       /* Generate intermediate subtract instructions */
       shift = 0 ;

       if (sval == 0)
        error("FATAL: Value of zero failed rotatable test") ;

       while (((sval >> shift) & 0x3) == 0)
        shift += 2 ;

       inst = ((first ? initSUBfn : initSUBfn2) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
       PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
       first = 0 ;

       sval = (sval & ~(0xFFL << shift)) ;
      }

     /* last instruction */
     inst = ((first ? initSUBfn : initSUBfn2) | (shift << 8) | imm) ;
     PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;

     /* load "a3" with the amount of data to be copied */
     if (maxdata > 4)
      {
       first = TRUE ;
       sval = maxdata ;
       while (!rotatable(sval,&shift,0,&imm))
        {
         /* Generate intermediate instructions */
         shift = 0 ;

         if (sval == 0)
          error("FATAL: Value of zero failed rotatable test") ;

         while (((sval >> shift) & 0x3) == 0)
          shift += 2 ;

         inst = ((first ? initMOV : initADD) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
         PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
         first = 0 ;

         sval = (sval & ~(0xFFL << shift)) ;
        }

       /* last instruction */
       inst = ((first ? initMOV : initADD) | (shift << 8) | imm) ;
       PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
      }

     /* and then provide the copy loop instructions */
     looppos = ((int)codepos << 2) ; /* current code position */
     PWRITE(0,(unsigned32 *)(buffer + boff),initLDRcopy); boff += sizeof(unsigned32) ; codepos++ ;
     PWRITE(0,(unsigned32 *)(buffer + boff),initSTRdata); boff += sizeof(unsigned32) ; codepos++ ;
     if (maxdata > 4)
      {
       PWRITE(0,(unsigned32 *)(buffer + boff),initSUBS); boff += sizeof(unsigned32) ; codepos++ ;
       PWRITE(0,(unsigned32 *)(buffer + boff),BranchCC(looppos,(codepos << 2),ccNE)) ; boff += sizeof(unsigned32) ; codepos++ ;
      }

     /* Check for out-standing initialised data relocations */
     boff = 0 ; /* flush the code buffer */
     limit = 0 ;
     datapos = 0 ;
     first = TRUE ; /* to ensure only a single "ip" copy is re-loaded */
     for (loop = 0; (loop < nareas); loop++)
      {
       unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
       int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
       int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;
       int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;

       base = limit ;
       limit += (asize + (nrelocs * sizeof(aof_reloc))) ;
d1461 1
a1461 3
       if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
        {
         if (nrelocs != 0) /* we do not cope with relocation directives yet */
d1463 2
a1464 5
           aof_reloc *relocs = (aof_reloc *)((int)((int)(adesc->aofareas) + base) + asize) ;
           int        rloop ;

           /* Add instructions to apply the required relocation to the newly copied data */
           for (rloop = 0; (rloop < nrelocs); rloop++)
d1466 6
a1471 135
             int32       roff = READ(adesc->be,relocs[rloop].rel_offset) ;
             unsigned32  rflags = READ(adesc->be,relocs[rloop].rel_flags) ;
             unsigned32  symindex ;
             unsigned32  ft ;
             int         pcrel ;
             int         area ;
             int         based ;
             aof_symbol *symbol ;
             char       *symname ;

             if (rel_type2(rflags))
              {
               symindex = rel2_sid(rflags) ;
               ft = rel2_FT(rflags) ;
               pcrel = (rel2_R(rflags) == REL_PCREL) ;
               area = (rel2_A(rflags) == 0) ;
               based = rel2_B(rflags) ;
              }
             else
              {
               symindex = rel1_sid(rflags) ;
               ft = rel1_FT(rflags) ;
               pcrel = (rel1_R(rflags) == REL_PCREL) ;
               area = (rel1_A(rflags) == 0) ;
               based = 0 ;
              }

             if (area)
              error("Relocation is relative to an AREA (TODO)") ;

             if (ft == 0x3) /* instruction */
              error("Instruction relocation type on data area") ;

             if (pcrel)
              error("PC-relative relocation type on data area (TODO)") ;

             if (based)
              error("Based relocation type on data area (TODO)") ;

             /* Convert "ft" into the number of bytes to be dealt with */
             ft = ((ft == 0) ? 1 : (ft << 1)) ;

             symbol = &(adesc->aofsymt[symindex]) ;
             symname = findstring(adesc,(int) READ(adesc->be,symbol->sym_name)) ;

             /* "datapos" is the offset of the base of this data area within the module table chunk */

             if (READ(adesc->be,symbol->sym_areaname) == anoff)
              {
               int32 sval = READ(adesc->be,symbol->sym_value) ;
               int32 remainder = 0 ;

               sval += datapos ; /* referenced offset within this data area within module table */
               roff += datapos ; /* offset within module table to be relocated */

               if (first)
                {
		  codepos++ ;
                 first = FALSE ;
                }

               if ((ft == 1) || (ft == 2))
                error("Byte and short relocations are not supported at the moment") ;

               /* Load the current value */
               if (roff < 4096)
                {
                 PWRITE(0,(unsigned32 *)(buffer + boff),(initLDR(0x1,0xC) | roff)) ; boff += sizeof(unsigned32) ; codepos++ ;
                }
               else
                {
                 int        base    = (int)roff ;
                 int        initial = TRUE ;
                 unsigned32 inst ;
                 unsigned32 shift ;
                 unsigned32 imm ;

                 remainder = (roff & (4096 - 1)) ;
                 base     -= (int) remainder ;

                 while (!rotatable(base,&shift,0,&imm))
                  {
                   shift = 0 ;
                   if (base == 0)
                    error("FATAL: Value of zero failed rotatable test") ;
                   while (((base >> shift) & 0x3) == 0)
                    shift += 2 ;

                   inst = ((initial ? initADDdp : initADD) | ((16 - (shift >> 1)) << 8) | (((unsigned32)base >> shift) & 0xFF)) ;
                   PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
                   initial = FALSE ;
                   base = (base & ~(0xFF << shift)) ;
                  }
                 inst = ((initial ? initADDdp : initADD) | (shift << 8) | imm) ;
                 PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
                 PWRITE(0,(unsigned32 *)(buffer + boff),(initLDR(0x1,0x2) | remainder)) ; boff += sizeof(unsigned32) ; codepos++ ;
                }

               /* Update the value with the required relocation */
               PWRITE(0,(unsigned32 *)(buffer + boff),initADDinto) ; boff += sizeof(unsigned32) ; codepos++ ;
               if (sval > 0)
                {
                 unsigned32 shift ;
                 unsigned32 imm ;
                 unsigned32 inst ;

		 trace( "sval = 0x%08X", sval ) ;

                 while (!rotatable(sval,&shift,0,&imm))
                  {
                   shift = 0 ;
                   if (sval == 0)
                    error("FATAL: Value of zero failed rotatable test") ;
                   while (((sval >> shift) & 0x3) == 0)
                    shift += 2 ;
                   inst = (initADDmore | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
                   PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
                   sval = (sval & ~(0xFFL << shift)) ;
                  }
                 inst = (initADDmore | (shift << 8) | imm) ;
                 PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
                }

               /* and write the value back into the module table */
               if (roff < 4096)
                {
                 PWRITE(0,(unsigned32 *)(buffer + boff),(initSTR(0x1,0xC) | roff)) ; boff += sizeof(unsigned32) ; codepos++ ;
                }
               else
                {
                 PWRITE(0,(unsigned32 *)(buffer + boff),(initLDR(0x1,0x2) | remainder)) ; boff += sizeof(unsigned32) ; codepos++ ;
                }
              }
             else
              error("Relocation references some other data area (TODO)") ;
d1473 1
d1476 11
a1486 1
         datapos += (int) asize ; /* update base by the size of this data area */
d1488 1
a1488 11
      }
    }
   PWRITE(0,(unsigned32 *)(buffer + boff),returnCall); boff += sizeof(unsigned32) ; codepos++ ;
   boff = 0 ; /* flush the code buffer */

   if (!dolib)
    {
     /* declare the symbols we export */
     for (loop = 0; (loop < slimit); loop++)
      {
       if ((READ(adesc->be,adesc->aofsymt[loop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT)
d1490 17
a1506 2
         char * symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
         
d1509 1
a1509 92
    }
  }

 /* release the temporary buffer */
 
 free(buffer) ;

 return(codepos << 2) ;
}

/*}}}*/
/*{{{  Second_convert_aof */

void
Second_convert_aof(
		   s_aof *	adesc,
		   char *	outfile,
		   int		dolib,
		   int		tiny,
		   int		kernel )
{
 FILE          *ofp ;
 int            tlen ;
 int            loop ;
 unsigned char *buffer = NULL ;
 unsigned32     boff ; /* buffer offset */
 unsigned32     base ;
 unsigned32     limit ;
 int32          slimit = READ(adesc->be,adesc->aofhdr->aof_nsyms) ;
 int32          nareas = READ(adesc->be,adesc->aofhdr->aof_nareas) ;
 unsigned32    *codebase = NULL ;
 unsigned32     codepos = 0 ;
 unsigned32     dataplace = 0 ;
 s_dataref     *dref ;
 char          *firstdata = NULL ;

 if ((ofp = fopen(outfile,"wb")) == NULL)
   error("Failed to open output file \"%s\"",outfile) ;

 if ((buffer = (unsigned char *)malloc(BUFFERSIZE)) == NULL)
  {
   fclose(ofp) ;
   error("Failed to allocate temporary buffer") ;
  }

 codebase = (unsigned32 *)malloc((int)nareas * sizeof(unsigned32)) ;
 if (codebase == NULL)
  error("Failed to allocate memory for code area base addresses") ;
 for (loop = 0; (loop < nareas); loop++)
  codebase[loop] = -1 ; /* initialise the vector */

 /* Release any data references that may be hanging around */
 if (adesc->drefs != NULL)
  {
   s_dataref *cptr = adesc->drefs ;

   for (; (cptr != NULL);)
    {
     s_dataref *This = cptr ;
     cptr = This->next ;
     free(This) ;
    }

   adesc->drefs = NULL ;
  }

 if (!dolib && !kernel)
  {
    CreateObjectHeader( adesc, (unsigned32 *)buffer, ofp );
  }

 /* Output the code areas */
 
 boff  = 0 ;
 limit = 0 ;
 
 for (loop = 0; (loop < nareas); loop++)
  {
   unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
   int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
   int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;
   int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;
   aof_reloc *relocs = NULL ;

   base = limit ;
   limit += (asize + (nrelocs * sizeof(aof_reloc))) ;

   if (attr & AOF_CODEAT)
    {
     if (!(attr & (AOF_32bitAT | AOF_REENTAT)))
      error("Object file Area %d is not APCS-3 re-entrant",loop) ;
     else
d1511 1
a1511 6
       int         iloop ;
       unsigned32 *code ;

       codebase[loop] = (codepos << 2) ; /* remember the start of this code area */

       if ((asize % sizeof(unsigned32)) != 0)
d1513 3
a1515 38
         fclose(ofp) ;
         error("Code area is not a word multiple in size") ;
        }

       code = (unsigned32 *)((int)(adesc->aofareas) + base) ;
       if (nrelocs != 0)
        relocs = (aof_reloc *)((int)code + asize) ;
       asize /= sizeof(unsigned32) ;

       /* Step through the code */
       for (iloop = 0; (iloop < asize); iloop++)
        {
         unsigned32  inst ;
         aof_symbol *symbol ;
         int         snum = 0 ;

         while ((symbol = findsym(adesc,&snum,(int)anoff,iloop)) != NULL)
          {
           char *      symname = findstring(adesc,(int) READ(adesc->be,symbol->sym_name)) ;
           unsigned32  sattr   = READ(adesc->be,symbol->sym_AT) ;

           if (!(sattr & SYM_DATAAT)) /* only output non-data symbols that appear in the code area */
            {
             sattr |= LSYM_LCODE ; WRITE(adesc->be,symbol->sym_AT,sattr) ; /* local function symbol */
             write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
             write_byte( OBJLABEL, ofp) ;
	     write_byte('.',ofp) ;
	     write_string(symname,strlen(symname),ofp) ;
            }
          }

         if ((boff + sizeof(unsigned32)) > BUFFERSIZE)
          {
           write_data(buffer,(int)boff,ofp) ;
           boff = 0 ;
          }

         inst = READ(adesc->be,code[iloop]) ;
d1517 1
a1517 3
	 trace( "code[0x%08X] = 0x%08X",(iloop << 2),inst );

         if (nrelocs > 0)
d1519 3
a1521 251
           aof_reloc *reloc = NULL ;
           int        rloop ;

           for (rloop = 0; (rloop < nrelocs); rloop++)
            if (READ(adesc->be,relocs[rloop].rel_offset) == ((int32)iloop << 2))
             {
              reloc = &(relocs[rloop]) ;
              break ; /* match against the first only */
             }

           /* "reloc" is non-NULL is this instruction has a relocation field */
           if (reloc != NULL)
            {
             unsigned32 relflags = READ(adesc->be,reloc->rel_flags) ;
             unsigned32 symindex ;
             unsigned32 ft ;
             int        pcrel ;
             int        area ;
             int        based ;
             unsigned32 count ;

             symbol = NULL ; /* relocation may be area relative */

             if (rel_type2(relflags))
              {
               symindex = rel2_sid(relflags) ;
               ft = rel2_FT(relflags) ;
               pcrel = (rel2_R(relflags) == REL_PCREL) ;
               area = (rel2_A(relflags) == 0) ;
               based = rel2_B(relflags) ;
               count = rel2_ins(relflags) ;
              }
             else
              {
               symindex = rel1_sid(relflags) ;
               ft = rel1_FT(relflags) ;
               pcrel = (rel1_R(relflags) == REL_PCREL) ;
               area = (rel1_A(relflags) == 0) ;
               based = 0 ;
               count = 1 ;
              }

	     trace( "relocation %d : offset = 0x%08X",rloop,READ(adesc->be,reloc->rel_offset)) ;
	     trace( "symindex = %d", symindex );

             if (!area) /* relocation is symbol relative (otherwise it is AREA relative) */
              symbol = &(adesc->aofsymt[symindex]) ;

             if (ft == 0x3) /* instruction */
              {
               if (pcrel)
                {
                 char *      symname = findstring(adesc,(int) READ(adesc->be,symbol->sym_name)) ;
                 unsigned32  sattr   = READ(adesc->be,symbol->sym_AT) ;

                 write_data(buffer,(int)boff,ofp) ; /* flush existing code */
                 boff = 0 ;

                 if ((sattr & SYM_REFDEFMASK) == SYM_REFAT)
                  {
                   /* imported code symbol */
                   sattr |= LSYM_CODE ; /* we will need a stub */
                   WRITE(adesc->be,symbol->sym_AT,sattr) ;
                  }
                 else
                  inform("PC-relative instruction relocation to a non-imported symbol") ;

                 /* if (based) then is a possible tailcall */
                 write_byte(OBJWORD,ofp) ; /* WORD */
                 write_byte(PATCHARMJP,ofp) ; /* PATCH ARM JP */
                 write_encoded((int)inst,ofp) ; /* B 0x???????? */
                 write_byte(OBJLABELREF,ofp) ; /* LABELREF */
                 write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ; /* .symbol */
                 codepos++ ;
                }
               else
                {
                 if (based)
                  {
                   int32       offset ;
                   int         aloop ;
                   unsigned32 *dbase = (unsigned32 *)(adesc->aofareas) ;

		   trace( "based relocation") ;

                   /* Check that the instruction is "LDR <r>,[dp,#off]" */
                   if (((inst & 0x0C000000) != 0x04000000) && ((inst & (1 << 20)) != (1 << 20)))
                    error("Based relocation with non-LDR (0x%08X)",inst) ;
                   if (((inst >> 16) & 0xF) != 9)
                    error("Based relocation (LDR) not using r9 (0x%08X)",inst) ;
                   if ((inst & (1 << 25)) != 0)
                    error("Based relocation has non-immediate offset (0x%08X)",inst) ;

                   offset = ((inst & (1 << 23)) ? (inst & 0xFFF) : -(inst & 0xFFF)) ;

                   if (offset < 0)
                    error("Negative offsets are not supported for based loads (%d)",offset) ;

                   for (aloop = 0; (aloop < nareas); aloop++)
                    {
                     int32 nrels = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_nrelocs) ;

                     /* If AREA relative then we only need to match the area index */
                     if ((symbol == NULL) ? (aloop == symindex) : (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == READ(adesc->be,symbol->sym_areaname)))
                      {
                       unsigned32  aattr = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_attributes) ;
                       aof_reloc  *relocs = (aof_reloc *)((int)dbase + READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_size)) ;

		       trace( "area %d : aattr = 0x%08X", aloop, aattr );

                       /* Check area is based using r9 */
                       if (aattr & AOF_BASEDAT)
                        {
                         int rloop ;

                         if (((aattr & AOF_BASEMASK) >> AOF_BASESHIFT) != 9)
                          error("Area is based on r%d, should be r9",((aattr & AOF_BASEMASK) >> AOF_BASESHIFT)) ;

                         /* Step through the relocations looking for matches */
                         for (rloop = 0; (rloop < nrels); rloop++)
                          {
                           /* Match against a relocation for the referenced offset */
                           if (READ(adesc->be,relocs[rloop].rel_offset) == offset)
                            {
                             aof_reloc  *reloc = &(relocs[rloop]) ; /* shorthand */
                             unsigned32  relflags ;
                             int32       symindex ;
                             char       *symname ;
                             unsigned32  sattr ;
                             int         arearel = 0 ;
                             unsigned32  lval ;

                             /* Load the base offset held in the indirection area */
                             lval = READ(adesc->be,((int *)dbase)[offset >> 2]) ;

                             relflags = READ(adesc->be,reloc->rel_flags) ;

                             if (rel_type2(relflags))
                              {
                               symindex = rel2_sid(relflags) ;
                               arearel = (rel2_A(relflags) == 0) ;
                              }
                             else
                              {
                               symindex = rel1_sid(relflags) ;
                               arearel = (rel1_A(relflags) == 0) ;
                              }

                             if (arearel)
                              {
                               int   sloop ;
                               int32 sval = lval ; /* FIXME : we don't need another variable */
                               int32 saname = READ(adesc->be,adesc->aofhdr->aof_areas[symindex].area_name) ;

			       trace( "AREA relative: symindex = %d : sval = 0x%08X : saname = 0x%08X",
				     symindex, sval, saname ); 

/* FIXME : this code can be mostly merged with the code below */

                               symindex = -1 ;

                               /* scan the symbol table for an exported symbol that can be used */
                               for (sloop = 0; (sloop < slimit); sloop++)
                                {
				  trace( "sloop %d : sym_areaname 0x%08X : sym_value 0x%08X : exported %s",
					sloop,
					READ( adesc->be, adesc->aofsymt[ sloop ].sym_areaname ),
					READ( adesc->be, adesc->aofsymt[ sloop ].sym_value),
					(((READ( adesc->be, adesc->aofsymt[ sloop ].sym_AT)
					   & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) ? "Yes" : "No")) ;
				  
                                 if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && (READ(adesc->be,adesc->aofsymt[sloop].sym_value) == sval) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT))
                                  {
                                   symindex = sloop ;
                                   sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                                   break ; /* out of the loop */
                                  }
                                }
                              }
                             else
                              {
                               sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;

                               /* Check if an exported symbol exists for the same offset and area */
                               if ((sattr & SYM_REFDEFMASK) != SYM_GLOBALDEFAT)
                                {
                                 int   sloop ;
                                 int32 sval = READ(adesc->be,adesc->aofsymt[symindex].sym_value) ;
                                 int32 saname = READ(adesc->be,adesc->aofsymt[symindex].sym_areaname) ;

                                 /* Scan the symbol table for an exported symbol that can be used */
                                 for (sloop = 0; (sloop < slimit); sloop++)
                                  {
                                   /* Check for exported symbol with matching definition */
                                   if ((READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == saname) && (READ(adesc->be,adesc->aofsymt[sloop].sym_value) == sval) && ((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT))
                                    {
                                     symindex = sloop ;
                                     sattr = READ(adesc->be,adesc->aofsymt[symindex].sym_AT) ;
                                     break ; /* out of the loop */
                                    }
                                  }
                                }
                              }

                             if (symindex == -1)
                              error("Symbol not found for relocation") ;

                             symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[symindex].sym_name)) ;
                             sattr |= LSYM_DATAREF ; WRITE(adesc->be,adesc->aofsymt[symindex].sym_AT,sattr) ; /* update symbol information */

                             write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush existing code */
                             /* The branch uses the condition code of the original instruction */
                             write_byte(OBJWORD,ofp) ;
			     write_byte(PATCHARMJP,ofp) ;
			     write_encoded( (int) BranchCC(0,0,(inst >> 28)),ofp) ;
                             write_byte(OBJLABELREF,ofp) ;
                             write_text(LOCALADDRSYM,strlen(LOCALADDRSYM),ofp) ;
                             write_number((unsigned int)((inst >> 12) & 0xF),ofp) ;
                             write_byte('_',ofp) ; write_text(symname,strlen(symname),ofp) ; write_byte('_',ofp) ;
                             codepos++ ;
                             write_number((unsigned int)(codepos << 2),ofp) ; write_byte('\0',ofp) ;

                             add_data_ref(adesc,symindex,lval,((inst >> 12) & 0xF),(codepos << 2)) ;
                             break ; /* out of the relocation loop */
                            }
                          }

                         if (rloop == nrels)
                          error("Failed to find relocation for offset %d",offset) ;
                        }
                       else
                        error("Referenced area is not based") ;
                       
                       break ; /* since we have finished processing the referenced area */
                      }

                     dbase = (unsigned32 *)((int)dbase + READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_size) + (nrels * sizeof(aof_reloc))) ;
                    }
                  }
                 else
                  error("Relocation: displaced : %d : 0x%08X : flags 0x%08X (not yet handled)\n",iloop,inst,relflags) ;
                }
              }
             else
              error("No code to deal with byte, short or long relocations yet") ;
            }
           else
            {
             /* Output the instruction (always little-endian) */
             PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
            }
d1525 3
a1527 2
           /* Output the instruction (always little-endian) */
           PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
a1529 30
      }
    }
  }

 trace( "code areas processed");

 if (!dolib && !kernel)
  {
   /* For all imported code symbols we generate stubs to indirect to the destination code */
   for (loop = 0; (loop < slimit); loop++)
    {
     if (READ(adesc->be,adesc->aofsymt[loop].sym_AT) & LSYM_CODE)
      {
       char *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
       int   doex = checkexception(symname) ;

       write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
       write_byte(OBJLABEL,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;

       if (doex)
        {
         PWRITE(0,(unsigned32 *)(buffer + boff),stubPush) ; boff += sizeof(unsigned32) ; codepos++ ;
        }
 
       write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */

       write_byte(OBJWORD,ofp) ;
       write_byte(PATCHARMDT,ofp) ;
       write_encoded(LDRfromdp(12),ofp) ;
       write_byte(OBJDATAMODULE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d1531 3
a1533 8

       write_byte(OBJWORD,ofp) ;
       write_byte(PATCHARMDT,ofp) ;
       write_encoded(LDRfromoffset(12),ofp) ;
       write_byte(OBJCODESYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
       codepos++ ;

       if (doex)
d1535 2
a1536 6
         PWRITE(0,(unsigned32 *)(buffer + boff),stubStore) ; boff += sizeof(unsigned32) ; codepos++ ;
         PWRITE(0,(unsigned32 *)(buffer + boff),stubPop) ;   boff += sizeof(unsigned32) ; codepos++ ;
        }
       else
        {
         PWRITE(0,(unsigned32 *)(buffer + boff),stubCall) ; boff += sizeof(unsigned32) ; codepos++ ;
a1537 77
      }
    }
  }

 /* for all external data references */
 for (dref = adesc->drefs; (dref != NULL); dref = dref->next)
  {
   char       *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[dref->symindex].sym_name)) ;
   unsigned32  sattr = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_AT) ;
   int32       aname = READ(adesc->be,adesc->aofsymt[dref->symindex].sym_areaname) ;
   int         aloop ;
   int         localcode = FALSE ;

   write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
   write_byte(OBJLABEL,ofp) ;
   write_text(LOCALADDRSYM,strlen(LOCALADDRSYM),ofp) ; write_number((unsigned int)(dref->destreg),ofp) ; write_byte('_',ofp) ;
   write_text(symname,strlen(symname),ofp) ; write_byte('_',ofp) ;
   write_number((unsigned int)(dref->codepos),ofp) ; write_byte('\0',ofp) ;

   /* See if we can match the symbol area name against the areas in this object */
   for (aloop = 0; (aloop < nareas); aloop++)
    if (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname)
     break ;

   /* The codebase value will only have been initialised for local
    * code areas. This saves having to check the attributes of the
    * areas as we scan through.
    */
   if ((aloop != nareas) && (codebase[aloop] != -1))
    localcode = TRUE ;

   if (localcode)
    {
     unsigned32 sval ;
     unsigned32 inst ;
     unsigned32 shift ;
     unsigned32 imm ;
     int        first = TRUE ;

     /* This is an optimisation. When the address of a local code
      * symbol is required, we generate the value directly using SUB
      * instructions from the pc. This saves using LABELREF
      * linker directives.
      */
     sval = (((codepos << 2) + 0x8) - (codebase[aloop] + READ(adesc->be,adesc->aofsymt[dref->symindex].sym_value) + dref->offset)) ;
     while (!rotatable(sval,&shift,0,&imm))
      {
       /* Generate intermediate subtract instructions */
       shift = 0 ;
       if (sval == 0)
        error("FATAL: Value of zero failed rotatable test") ;
       while (((sval >> shift) & 0x3) == 0)
        shift += 2 ;
       inst = ((first ? initSUBr(dref->destreg) : initSUBr2(dref->destreg)) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
       PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
       first = 0 ;

       sval = (sval & ~(0xFFL << shift)) ;
      }

     /* last instruction */
     inst = ((first ? initSUBr(dref->destreg) : initSUBr2(dref->destreg)) | (shift << 8) | imm) ;
     PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
    }
   else
    {
     if ((sattr & LSYM_LCODE) || check_symbol(symname)) /* local code symbol or explicit code symbol */
      {
	if (sattr & LSYM_LCODE)
	  {
	/* LSB */
       write_byte(OBJWORD,ofp) ;
       write_byte(PATCHARMDPLSB,ofp) ;
       write_encoded((int)addrADDpc(dref->destreg),ofp) ;
       write_byte(OBJLABELREF,ofp) ;
       write_byte('.',ofp) ;
       write_string(symname,strlen(symname),ofp) ;
d1543 5
a1547 6
         write_byte(OBJWORD,ofp) ;
	 write_byte(PATCHARMDPMID,ofp) ;
	 write_encoded((int)addrADD(dref->destreg),ofp) ;
         write_byte(OBJLABELREF,ofp) ;
	 write_byte('.',ofp) ;
	 write_string(symname,strlen(symname),ofp) ;
d1552 1
a1552 51
       write_byte(OBJWORD,ofp) ;
       write_byte(PATCHARMDPREST,ofp) ;
       write_encoded((int)addrADD(dref->destreg),ofp) ;
       write_byte(OBJLABELREF,ofp) ;
       write_byte('.',ofp) ;
       write_string(symname,strlen(symname),ofp) ;
       codepos++ ;
     }
	else /* since we have another conditional above, we know that it is a code symbol */
	  {
	   /* get address of code symbol (being treated as data) */
       write_byte(OBJWORD,ofp) ;
       write_byte(PATCHARMDT,ofp) ;
       write_encoded(LDRfromdp(dref->destreg),ofp) ;
       write_byte(OBJDATAMODULE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
       codepos++ ;

       write_byte(OBJWORD,ofp) ;
       write_byte(PATCHARMDT,ofp) ;
       write_encoded(LDRfromoffset(dref->destreg),ofp) ;
       write_byte(OBJCODESYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
       codepos++ ;
	  }
	
      }
     else /* treat as access to a data symbol */
      {
       write_byte(OBJWORD,ofp) ;
       write_byte(PATCHARMDT,ofp) ;
       write_encoded((int)LDRfromdp(dref->destreg),ofp) ;

       if ((sattr & SYM_REFDEFMASK) == SYM_REFAT)
        {
         write_byte(OBJDATAMODULE,ofp) ;
	 write_byte('_',ofp) ;
	 write_string(symname,strlen(symname),ofp) ;
        }
       else
        {
         write_byte(PATCHSHIFT,ofp) ;
	 write_byte(0x3,ofp) ;
	 write_byte(OBJMODNUM,ofp) ;
        }
       codepos++ ;
  
       /* LSB */
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPLSB,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
       write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
       codepos++ ;

       if (!tiny) /* shorter access sequence */
d1554 1
a1554 2
         /* MID */
         write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPMID,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
a1555 1
         codepos++ ;
a1556 4

       /* REST */
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPREST,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
       write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d1561 2
a1562 5
      {
       unsigned32 sval = dref->offset ;
       unsigned32 inst ;
       unsigned32 shift ;
       unsigned32 imm ;
d1564 2
a1565 4
       while (!rotatable(sval,&shift,0,&imm))
        {
         /* Generate intermediate instructions */
         shift = 0 ;
d1567 1
a1567 2
         if (sval == 0)
          error("FATAL: Value of zero failed rotatable test") ;
d1569 3
a1571 16
         while (((sval >> shift) & 0x3) == 0)
          shift += 2 ;

         inst = (initADDr(dref->destreg) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
         PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
         sval = (sval & ~(0xFFL << shift)) ;
        }

       /* last instruction */
       inst = (initADDr(dref->destreg) | (shift << 8) | imm) ;
       PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
      }
    }

   PWRITE(0,(unsigned32 *)(buffer + boff),Branch(dref->codepos,(codepos << 2))) ; boff += sizeof(unsigned32) ; codepos++ ;
  }
d1573 1
a1573 1
 write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
d1578 10
a1587 1
    trace( "adding initialisation code");
d1590 3
a1592 1
   write_byte(OBJINIT,ofp) ; codepos++ ; /* INIT */
d1594 2
d1609 6
a1614 1
         write_byte(OBJCODETABLE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d1619 3
d1623 6
a1628 2
   {
    unsigned32 *ssize = (unsigned32 *)malloc((int) slimit * sizeof(unsigned32)) ;
d1630 9
a1638 2
    if (ssize == NULL)
     error("Failed to allocate memory for symbol table size vector") ;
d1640 3
a1642 10
    /* We step through the data areas in the order they will be
     * initialised below. We need to ensure that the DATA definitions
     * are ordered correctly. Reflecting the order of the data areas and
     * the symbols within the data areas. All the symbols at the same
     * offset have a size value of zero, apart from the last.
     * The "ssize" vector is used to hold the size values calculated
     * for the corresponding symbols.
     */
    for (loop = 0; (loop < slimit); loop++)
     ssize[loop] = -1 ; /* initialise the vector */
d1644 1
a1644 42
    for (loop = 0; (loop < nareas); loop++)
     {
      unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
      int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
      int32      anoff = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_name) ;

      if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
       {
        int32 hval = 0 ;
        int   hidx ;
        int   last = (int)asize ;
        int   sloop ;

        /* Process the symbols within this data area */
        do
         {
          hidx = -1 ;
          for (sloop = 0; (sloop < slimit); sloop++)
           {
            /* Check that the symbol references this data area */
            if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == anoff)
             {
              if ((READ(adesc->be,adesc->aofsymt[sloop].sym_value) >= hval) && (ssize[sloop] == -1))
               hidx = sloop ;
             }
           }

          if (hidx != -1)
           {
            int32 sval  = READ(adesc->be,adesc->aofsymt[hidx].sym_value) ;
            ssize[hidx] = (last - sval) ;
            last = (int) sval ;
           }
         } while (hidx != -1) ;

        for (sloop = 0; (sloop < slimit); sloop++)
         {
          if (READ(adesc->be,adesc->aofsymt[sloop].sym_areaname) == anoff)
           {
            if (ssize[sloop] != -1)
             {
              char *symname = findstring(adesc,(int) READ(adesc->be,adesc->aofsymt[sloop].sym_name)) ;
a1645 17
              if (firstdata == NULL)
               firstdata = symname ;

              write_byte(OBJDATA,ofp) ;
	      write_encoded( (int) ssize[sloop],ofp) ;
	      write_byte('_',ofp) ;
	      write_string(symname,strlen(symname),ofp) ;
             }
           }
         }
       }
     }

    /* Release the symbol size vector */
    free(ssize) ;
   }

d1647 12
a1658 7
   PWRITE(0,(unsigned32 *)(buffer + boff),initCMP) ; boff += sizeof(unsigned32) ; codepos++ ;
   write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
   write_byte(OBJWORD,ofp) ; /* WORD */
   write_byte(PATCHARMJP,ofp) ; /* PATCH ARM JP */
   write_encoded(BranchCC(0,0,ccNE),ofp) ; /* BNE 0x???????? */
   write_byte(OBJLABELREF,ofp) ; /* LABELREF */
   write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
d1661 2
d1666 5
a1670 2
     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDT,ofp) ; write_encoded(initLDRfn,ofp) ;
     write_byte(PATCHSHIFT,ofp) ; write_byte(0x3,ofp) ; write_byte(OBJMODNUM,ofp) ;
a1677 1
         unsigned32 inst ;
a1678 2
         unsigned32 shift ;
         unsigned32 imm ;
a1681 1
         int        first = TRUE ;
d1699 2
a1700 23
     
         while (!rotatable(sval,&shift,0,&imm))
          {
           /* Generate intermediate subtract instructions */
           shift = 0 ;

           if (sval == 0)
            error("FATAL: Value of zero failed rotatable test") ;

           while (((sval >> shift) & 0x3) == 0)
            shift += 2 ;

           inst = ((first ? initSUBfn : initSUBfn2) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
           PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
           first = 0 ;

           sval = (sval & ~(0xFFL << shift)) ;
          }

         /* last instruction */
         inst = ((first ? initSUBfn : initSUBfn2) | (shift << 8) | imm) ;
         PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
         PWRITE(0,(unsigned32 *)(buffer + boff),initSTRfn); boff += sizeof(unsigned32) ; codepos++ ;
d1705 1
a1705 1
   PWRITE(0,(unsigned32 *)(buffer + boff),returnCall); boff += sizeof(unsigned32) ; codepos++ ;
d1707 3
a1709 1
   /* Initialised data */
d1711 2
a1712 1
    unsigned32 amount = 0 ;
d1714 3
a1716 1
    write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
d1719 2
a1720 2
    limit = 0 ;
    for (loop = 0; (loop < nareas); loop++)
d1722 9
a1730 3
      unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
      int32      asize = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
      int32      nrelocs = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_nrelocs) ;
d1732 36
a1767 2
      base = limit ;
      limit += (asize + (nrelocs * sizeof(aof_reloc))) ;
d1769 8
a1776 8
      if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
       {
        unsigned char *data = (unsigned char *)((int)(adesc->aofareas) + base) ;
        write_data(data,(int)asize,ofp) ;
        codepos += (asize >> 2) ;
        amount += asize ;
       }
     }
d1779 1
a1779 1
     error("Output amount 0x%08X does not match maxdata amount 0x%08X",(int)amount,(int)maxdata) ;
d1785 3
d1789 9
a1797 3
   write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
   write_byte(OBJLABEL,ofp) ; write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
   if (maxdata != 0) /* data initialisation required */
a1799 1
     unsigned32 inst ;
a1800 2
     unsigned32 shift ;
     unsigned32 imm ;
a1801 9
     int        datapos ;

     write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDT,ofp) ; write_encoded(initLDRdata,ofp) ;
     write_byte(PATCHSHIFT,ofp) ; write_byte(0x3,ofp) ; write_byte(OBJMODNUM,ofp) ; codepos++ ;

     if (dolib)
      {
       if (firstdata == NULL)
        firstdata = "ERROR_should_be_first_DATA_directive_in_this_object" ;
d1803 1
a1803 18
       /* LSB */
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPLSB,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
       write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
       codepos++ ;

       if (!tiny)
        {
         /* MID */
         write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPMID,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
         write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
         codepos++ ;
        }

       /* REST */
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPREST,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
       write_byte(OBJDATASYMB,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
       codepos++ ;
      }
d1806 1
a1806 5
     /* Copy "maxdata" bytes from above into the module table */ 
     /* Note: we need to deal with BSS correctly. We can have a simple zero
      * initialisation loop.
      */

a1807 1
     /* TODO * place this duplicated code into a function */
d1809 1
a1809 4
     while (!rotatable(sval,&shift,0,&imm))
      {
       /* Generate intermediate subtract instructions */
       shift = 0 ;
d1811 3
a1813 2
       if (sval == 0)
        error("FATAL: Value of zero failed rotatable test") ;
d1815 8
a1822 8
       while (((sval >> shift) & 0x3) == 0)
        shift += 2 ;

       inst = ((first ? initSUBfn : initSUBfn2) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
       PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
       first = 0 ;

       sval = (sval & ~(0xFFL << shift)) ;
d1825 4
a1828 3
     /* last instruction */
     inst = ((first ? initSUBfn : initSUBfn2) | (shift << 8) | imm) ;
     PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
d1830 10
a1839 6
     /* load "a3" with the amount of data to be copied */
     if (maxdata > 4)
      {
       first = TRUE ;
       sval = maxdata ;
       while (!rotatable(sval,&shift,0,&imm))
d1841 2
a1842 14
         /* Generate intermediate instructions */
         shift = 0 ;

         if (sval == 0)
          error("FATAL: Value of zero failed rotatable test") ;

         while (((sval >> shift) & 0x3) == 0)
          shift += 2 ;

         inst = ((first ? initMOV : initADD) | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
         PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
         first = 0 ;

         sval = (sval & ~(0xFFL << shift)) ;
a1843 14

       /* last instruction */
       inst = ((first ? initMOV : initADD) | (shift << 8) | imm) ;
       PWRITE(0,(unsigned32 *)(buffer + boff),inst); boff += sizeof(unsigned32) ; codepos++ ;
      }

     /* and then provide the copy loop instructions */
     looppos = ((int)codepos << 2) ; /* current code position */
     PWRITE(0,(unsigned32 *)(buffer + boff),initLDRcopy); boff += sizeof(unsigned32) ; codepos++ ;
     PWRITE(0,(unsigned32 *)(buffer + boff),initSTRdata); boff += sizeof(unsigned32) ; codepos++ ;
     if (maxdata > 4)
      {
       PWRITE(0,(unsigned32 *)(buffer + boff),initSUBS); boff += sizeof(unsigned32) ; codepos++ ;
       PWRITE(0,(unsigned32 *)(buffer + boff),BranchCC(looppos,(codepos << 2),ccNE)) ; boff += sizeof(unsigned32) ; codepos++ ;
d1847 4
a1850 3
     write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
     limit = 0 ;
     datapos = 0 ;
d1859 4
a1862 2
       base = limit ;
       limit += (asize + (nrelocs * sizeof(aof_reloc))) ;
d1864 1
a1864 3
       if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
        {
         if (nrelocs != 0) /* we do not cope with relocation directives yet */
d1866 1
a1866 5
           aof_reloc *relocs = (aof_reloc *)((int)((int)(adesc->aofareas) + base) + asize) ;
           int        rloop ;

           /* Add instructions to apply the required relocation to the newly copied data */
           for (rloop = 0; (rloop < nrelocs); rloop++)
d1868 2
a1869 9
             int32       roff = READ(adesc->be,relocs[rloop].rel_offset) ;
             unsigned32  rflags = READ(adesc->be,relocs[rloop].rel_flags) ;
             unsigned32  symindex ;
             unsigned32  ft ;
             int         pcrel ;
             int         area ;
             int         based ;
             aof_symbol *symbol ;
             char       *symname ;
d1871 2
a1872 1
             if (rel_type2(rflags))
d1874 13
a1886 14
               symindex = rel2_sid(rflags) ;
               ft = rel2_FT(rflags) ;
               pcrel = (rel2_R(rflags) == REL_PCREL) ;
               area = (rel2_A(rflags) == 0) ;
               based = rel2_B(rflags) ;
              }
             else
              {
               symindex = rel1_sid(rflags) ;
               ft = rel1_FT(rflags) ;
               pcrel = (rel1_R(rflags) == REL_PCREL) ;
               area = (rel1_A(rflags) == 0) ;
               based = 0 ;
              }
d1888 16
a1903 2
             if (area)
              error("Relocation is relative to an AREA (TODO)") ;
d1905 2
a1906 2
             if (ft == 0x3) /* instruction */
              error("Instruction relocation type on data area") ;
d1908 2
a1909 2
             if (pcrel)
              error("PC-relative relocation type on data area (TODO)") ;
d1911 2
a1912 2
             if (based)
              error("Based relocation type on data area (TODO)") ;
d1914 2
a1915 2
             /* Convert "ft" into the number of bytes to be dealt with */
             ft = ((ft == 0) ? 1 : (ft << 1)) ;
d1917 17
a1933 2
             symbol = &(adesc->aofsymt[symindex]) ;
             symname = findstring(adesc,(int) READ(adesc->be,symbol->sym_name)) ;
d1935 2
a1936 1
             /* "datapos" is the offset of the base of this data area within the module table chunk */
d1938 2
a1939 4
             if (READ(adesc->be,symbol->sym_areaname) == anoff)
              {
               int32 sval = READ(adesc->be,symbol->sym_value) ;
               int32 remainder = 0 ;
d1941 40
a1980 2
               sval += datapos ; /* referenced offset within this data area within module table */
               roff += datapos ; /* offset within module table to be relocated */
d1982 7
a1988 6
               if (first)
                {
                 write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDT,ofp) ; write_encoded(initLDRdata,ofp) ;
                 write_byte(PATCHSHIFT,ofp) ; write_byte(0x3,ofp) ; write_byte(OBJMODNUM,ofp) ; codepos++ ;
                 first = FALSE ;
                }
d1990 14
a2003 2
               if ((ft == 1) || (ft == 2))
                error("Byte and short relocations are not supported at the moment") ;
d2005 22
a2026 4
               /* Load the current value */
               if (roff < 4096)
                {
                 PWRITE(0,(unsigned32 *)(buffer + boff),(initLDR(0x1,0xC) | roff)) ; boff += sizeof(unsigned32) ; codepos++ ;
d2028 5
a2032 1
               else
d2034 2
a2035 8
                 int        base    = (int)roff ;
                 int        initial = TRUE ;
                 unsigned32 inst ;
                 unsigned32 shift ;
                 unsigned32 imm ;

                 remainder = (roff & (4096 - 1)) ;
                 base     -= (int) remainder ;
d2037 2
a2038 17
                 while (!rotatable(base,&shift,0,&imm))
                  {
                   shift = 0 ;
                   if (base == 0)
                    error("FATAL: Value of zero failed rotatable test") ;
                   while (((base >> shift) & 0x3) == 0)
                    shift += 2 ;

                   inst = ((initial ? initADDdp : initADD) | ((16 - (shift >> 1)) << 8) | (((unsigned32)base >> shift) & 0xFF)) ;
                   PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
                   initial = FALSE ;
                   base = (base & ~(0xFF << shift)) ;
                  }
                 inst = ((initial ? initADDdp : initADD) | (shift << 8) | imm) ;
                 PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
                 PWRITE(0,(unsigned32 *)(buffer + boff),(initLDR(0x1,0x2) | remainder)) ; boff += sizeof(unsigned32) ; codepos++ ;
                }
d2040 2
a2041 7
               /* Update the value with the required relocation */
               PWRITE(0,(unsigned32 *)(buffer + boff),initADDinto) ; boff += sizeof(unsigned32) ; codepos++ ;
               if (sval > 0)
                {
                 unsigned32 shift ;
                 unsigned32 imm ;
                 unsigned32 inst ;
d2043 1
a2043 1
		 trace( "sval = 0x%08X", sval );
d2045 3
a2047 1
                 while (!rotatable(sval,&shift,0,&imm))
d2049 2
a2050 8
                   shift = 0 ;
                   if (sval == 0)
                    error("FATAL: Value of zero failed rotatable test") ;
                   while (((sval >> shift) & 0x3) == 0)
                    shift += 2 ;
                   inst = (initADDmore | ((16 - (shift >> 1)) << 8) | ((sval >> shift) & 0xFF)) ;
                   PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
                   sval = (sval & ~(0xFFL << shift)) ;
a2051 3
                 inst = (initADDmore | (shift << 8) | imm) ;
                 PWRITE(0,(unsigned32 *)(buffer + boff),inst) ; boff += sizeof(unsigned32) ; codepos++ ;
                }
d2053 2
a2054 4
               /* and write the value back into the module table */
               if (roff < 4096)
                {
                 PWRITE(0,(unsigned32 *)(buffer + boff),(initSTR(0x1,0xC) | roff)) ; boff += sizeof(unsigned32) ; codepos++ ;
d2056 8
a2063 11
               else
                {
                 PWRITE(0,(unsigned32 *)(buffer + boff),(initLDR(0x1,0x2) | remainder)) ; boff += sizeof(unsigned32) ; codepos++ ;
                }
              }
             else
              error("Relocation references some other data area (TODO)") ;
            }
          }

         datapos += (int) asize ; /* update base by the size of this data area */
d2065 1
a2065 1
      }
d2067 5
a2071 2
   PWRITE(0,(unsigned32 *)(buffer + boff),returnCall); boff += sizeof(unsigned32) ; codepos++ ;
   write_data(buffer,(int)boff,ofp) ; boff = 0 ; /* flush the code buffer */
d2073 3
d2084 6
a2089 1
         write_byte(OBJGLOBAL,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2093 4
d2099 1
a2099 2
 /* Completed */
 fclose(ofp) ;
d2101 16
a2116 2
 /* release the temporary buffer */
 free(buffer) ;
d2118 1
a2118 1
 return;
@


1.5
log
@changed warning about pc-relative references to be informs
@
text
@d8 1
a8 1
 * $Revision: 1.4 $
d10 1
a10 1
 *     $Date: 1994/01/05 10:48:41 $
d570 1
a570 1
  write_data( (char *)buffer, 2 * sizeof (unsigned32) + tlen, ofp );
d578 1
a578 1
  write_data( (char *)buffer, 2 * sizeof (unsigned32), ofp );
d586 1
a586 1
      write_data( (char *)buffer, sizeof (unsigned32), ofp ) ;
d1042 4
a1045 1
              error("No code to deal with byte, short or long relocations yet") ;
@


1.4
log
@conversion complete - baring results of tests
@
text
@d8 1
a8 1
 * $Revision: 1.3 $
d10 1
a10 1
 *     $Date: 1994/01/04 10:55:25 $
a876 6
                 else
		   {
		     inform( "sattr = %x", sattr );
		     
		     warn("PC-relative instruction relocation to a non-imported symbol") ;
		   }
d1916 1
a1916 1
                  warn("PC-relative instruction relocation to a non-imported symbol") ;
@


1.3
log
@fixed constants to use versions in link.h rather than home-grown
@
text
@d8 1
a8 1
 * $Revision: 1.2 $
d10 1
a10 1
 *     $Date: 1993/12/17 17:09:53 $
d576 1
a576 1
  PWRITE( 0, buffer + 1, maxdata );
d578 1
a578 1
  write_data( (char *)buffer, 2, ofp );
d586 1
a586 1
      write_data( (char *)buffer, 1, ofp ) ;
d684 3
d1163 1
a1163 1
     if ((sattr & LSYM_LCODE) || check_symbol(symname)) /* local code symbol or explicit code symbol */
d1165 2
a1166 2
       /* LSB */
       codepos++ ;
d1168 5
a1172 5
       if (!tiny) /* shorter access sequence */
        {
         /* MID */
         codepos++ ;
        }
d1174 2
a1175 2
       /* REST */
       codepos++ ; 
d1177 4
d2230 9
a2238 3
       /* LSB */
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPLSB,ofp) ; write_encoded((int)addrADDpc(dref->destreg),ofp) ;
       write_byte(OBJLABELREF,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2244 6
a2249 2
         write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPMID,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
         write_byte(OBJLABELREF,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2254 24
a2277 3
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDPREST,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
       write_byte(OBJLABELREF,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
       codepos++ ; 
d2281 3
a2283 1
       write_byte(OBJWORD,ofp) ; write_byte(PATCHARMDT,ofp) ; write_encoded((int)LDRfromdp(dref->destreg),ofp) ;
d2287 3
a2289 1
         write_byte(OBJDATAMODULE,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2293 3
a2295 1
         write_byte(PATCHSHIFT,ofp) ; write_byte(0x3,ofp) ; write_byte(OBJMODNUM,ofp) ;
@


1.2
log
@stage 1 integration completed
@
text
@d1 2
a2 1
/*> convert.c <*/
d6 3
a8 1
 * $Revision: 1.1 $
d10 1
a10 1
 *     $Date: 1993/12/17 16:02:59 $
d13 1
d30 2
a31 1
/* TODO: sort out "errormsg" codes */
d44 1
a44 2

/*---------------------------------------------------------------------------*/
d46 1
a46 2
/* define "SATEST" for a stand-alone test utility version of the convertor */
#define SATEST (0)  /* should be set to (0) when embedded in another program */
d48 2
a49 2
/* define "DEBUG" to include debugging information */
#define DEBUG  (0)  /* should be set to (0) for a external release */
d51 1
a51 1
/*---------------------------------------------------------------------------*/
a78 1
#define HOF_magic_module        (0x60F160F1)    /* module identifier */
d81 2
a82 64
/*---------------------------------------------------------------------------*/

#define HOF_t_code              0x01
#define HOF_t_bss               0x02
#define HOF_t_init              0x03

#define HOF_t_byte              0x09   /* ls 3 bits = size */
#define HOF_t_short             0x0A
#define HOF_t_word              0x0C

#define HOF_t_codesymbol        0x0D
#define HOF_t_modsize           0x0E
#define HOF_t_labelref          0x0F
#define HOF_t_datasymb          0x10
#define HOF_t_datamodule        0x11
#define HOF_t_modnum            0x12

#define HOF_t_patch             0x13
#define HOF_t_maxpatch          0x1F

#define HOF_t_patch_add         0x13
#define HOF_t_patch_shift       0x14

#define HOF_t_patch_armdt       0x15    /* data xfer */
#define HOF_t_patch_armdp       0x16    /* data proc */
#define HOF_t_patch_armjp       0x17    /* jmp */
#define HOF_t_patch_armdplsb    0x18    /* data proc lsbyte (bits 0..7) */
#define HOF_t_patch_armdpmid    0x1A    /* data proc midbyte (bits 8..15) */
#define HOF_t_patch_armdprest   0x19    /* data proc remaining residue */

#define HOF_t_patch_swap        0x1E
#define HOF_t_patch_or          0x1F

#define HOF_t_module            0x20
#define HOF_t_bytesex           0x21
 
#define HOF_t_global            0x22
#define HOF_t_label             0x23
#define HOF_t_data              0x24
#define HOF_t_common            0x25
#define HOF_t_codetable         0x26
#define HOF_t_ref               0x27    /* force reference to another library */

#define HOF_t_newseg            0x30
#define HOF_t_end               0x31
#define HOF_t_literal           0x32   /* t_code of <= 4 bytes */

#define HOF_s_unbound           0x40
#define HOF_s_codesymb          0x41
#define HOF_s_funcsymb          0x42
#define HOF_s_datasymb          0x43
#define HOF_s_commsymb          0x44
#define HOF_s_datadone          0x45
#define HOF_s_funcdone          0x46
#define HOF_s_commdone          0x47

/* traceing */
#define HOF_db_gencode          0x0008
#define HOF_db_genimage         0x0010
#define HOF_db_files            0x0400
#define HOF_db_mem              0x0800
#define HOF_db_sym              0x1000
#define HOF_db_modules          0x2000
#define HOF_db_scancode         0x4000
d175 3
d191 7
a197 1
/*---------------------------------------------------------------------------*/
a203 3
/*---------------------------------------------------------------------------*/
/*-- internal functions -----------------------------------------------------*/
/*---------------------------------------------------------------------------*/
d246 2
a247 1
/*---------------------------------------------------------------------------*/
a250 1
 if (fp != NULL)
d252 1
a252 1
 return ;
d255 2
a256 1
/*---------------------------------------------------------------------------*/
d260 1
a260 3
 if (fp != NULL)
  {
   for (; (length > 0); length--)
d262 1
a262 1
  }
d266 2
a267 1
/*---------------------------------------------------------------------------*/
d273 3
a275 5
 if (fp != NULL)
  {
   sprintf(tbuff,"%X",num) ;
   write_text(tbuff,strlen(tbuff),fp) ;
  }
d279 2
a280 1
/*---------------------------------------------------------------------------*/
d284 2
a285 7
 if (fp != NULL)
  {
   write_text(text,length,fp) ;
   putc('\0',fp) ;
  }
 return ;
}
d287 1
a287 10
/*---------------------------------------------------------------------------*/

static void write_rawdata(unsigned char *data,int amount,FILE *fp)
{
 if ((amount > 0) && (fp != NULL))
  {
   for (; (amount != 0); amount--)
    putc(*data++,fp) ;
  }
 return ;
d290 2
a291 1
/*---------------------------------------------------------------------------*/
d295 1
a295 1
 if ((amount > 0) && (fp != NULL))
d297 1
a297 1
   putc(HOF_t_code,fp) ; (void)write_encoded(amount,fp) ;
d304 2
a305 1
/*---------------------------------------------------------------------------*/
d309 2
a310 45
 if (fp != NULL)
  {
   putc(HOF_t_bss,fp) ;
   (void)write_encoded(amount,fp) ;
  }
 return ;
}

/*---------------------------------------------------------------------------*/

static void errormsg(int fatal,char *format,...)
{
 va_list ap ;

 va_start(ap,format) ;

 if ((format != NULL) && (*format != '\0'))
  {
   fprintf(stderr,"%sError: ",(fatal ? "FATAL " : "")) ;
   vfprintf(stderr,format,ap) ;
   fprintf(stderr,"\n") ;
  }

 va_end(ap) ;

 if (fatal)
  exit(fatal) ;

 return ;
}

/*---------------------------------------------------------------------------*/

static void warning(char *format,...)
{
 va_list ap ;

 va_start(ap,format) ;

 if ((format != NULL) && (*format != '\0'))
  {
   fprintf(stderr,"Warning: ") ;
   vfprintf(stderr,format,ap) ;
   fprintf(stderr,"\n") ;
  }
a311 1
 va_end(ap) ;
d315 2
a316 1
/*---------------------------------------------------------------------------*/
d324 1
a324 1
  errormsg(10,"Chunk \"%s\" not found in \"%s\"",name,oep->fname) ;
d330 1
a330 1
    errormsg(11,"Unable to read the size of Chunk \"%s\" (index %d) in \"%s\"",name,cidx,oep->fname) ;
d334 1
a334 1
      errormsg(12,"Failed to seek to the start of Chunk %d in \"%s\"",cidx,oep->fname) ;
d336 2
a337 2
      if ((buffer = (void *)malloc(csize)) == NULL)
       errormsg(13,"Failed to allocate 0x%08X bytes for Chunk %d in \"%s\"",csize,cidx,oep->fname) ;
d341 1
a341 1
         errormsg(14,"Failed to load Chunk %d data from \"%s\"",cidx,oep->fname) ;
d351 2
a352 1
/*---------------------------------------------------------------------------*/
d385 2
a386 8
/*---------------------------------------------------------------------------*/

static void add_data_ref(s_aof *adesc,int32 symindex,unsigned32 offset,unsigned32 destreg,unsigned32 codepos)
{
 s_dataref *new = (s_dataref *)malloc(sizeof(s_dataref)) ;

 if (new == NULL)
  errormsg(88,"Failed to allocate data reference holder") ;
d388 17
a404 4
 new->symindex = symindex ;
 new->offset = offset ;
 new->destreg = destreg ;
 new->codepos = codepos ;
d406 2
a407 2
 new->next = adesc->drefs ;
 adesc->drefs = new ;
d412 3
a414 1
/*---------------------------------------------------------------------------*/
d416 1
d419 1
a419 2
 char *cptr = (adesc->aofstrt + offset) ;
 return(cptr) ;
d422 2
a423 1
/*---------------------------------------------------------------------------*/
d440 2
a441 1
/*---------------------------------------------------------------------------*/
d455 1
a455 1
   if ((aname == READ(adesc->be,cptr->sym_areaname)) && ((index << 2) == READ(adesc->be,cptr->sym_value)))
d463 135
a597 4
/*---------------------------------------------------------------------------*/
/*-- exported functions -----------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* See the associated header file for a description of these routines */
d601 1
a601 1
 s_aof *new ; /* AOF file descriptor */
d603 3
a605 2
 new = (s_aof *)malloc(sizeof(s_aof)) ;
 if (new != NULL)
d609 8
a616 8
   new->fname = fname ; /* filename of object this is a descriptor for */
   new->cf = NULL ; /* no ChunkFile descriptor */
   new->cfhdr = NULL ; /* no ChunkFile header */
   new->aofhdr = NULL ; /* no cached areas */
   new->aofsymt = NULL ; /* no symbol table */
   new->aofstrt = NULL ; /* no string table */
   new->codesize = 0xFFFFFFFF ; /* code size not yet known */
   new->drefs = NULL ; /* no data references yet */
d619 1
a619 1
    warning("Failed to open object file \"%s\"",fname) ;
d622 2
a623 2
     if ((new->cf = (ChunkFile *)malloc(sizeof(ChunkFile))) == NULL)
      errormsg(0,"Unable to allocate 0x%08X bytes for ChunkFile \"%s\" descriptor",sizeof(ChunkFile),fname) ;
d625 2
a626 2
      if (cf_open(fdesc,new->cf) == NULL)
       errormsg(0,"Failed to open \"%s\" as a ChunkFile",fname) ;
d629 1
a629 1
        int32 hdrsize = cf_headersize(new->cf) ;
d632 1
a632 1
         errormsg(0,"ChunkFile \"%s\" did not open properly",fname) ;
d634 2
a635 2
         if ((new->cfhdr = (cf_header *)malloc(hdrsize)) == NULL)
          errormsg(0,"Unable to allocate 0x%08X bytes for ChunkFile \"%s\" header",hdrsize,fname) ;
d637 2
a638 2
          if (cf_readheader(new->cf,new->cfhdr,hdrsize) == NULL)
           errormsg(0,"Failed to read ChunkFile \"%s\" header (0x%08X bytes)",fname,hdrsize) ;
d641 2
a642 2
            new->be = LE ; /* default is little-endian */
            switch (cf_endianness(new->cfhdr->cf_magic))
d645 1
a645 1
               new->be = BE ; /* big-endian file */
d648 1
a648 1
               /* if entered as CF_LITTLE then new->be has already been initialised */
d650 2
a651 2
                if ((new->aofhdr = cf_load(new,OBJ_HEAD)) == NULL)
                 errormsg(0,"Failed to load AOF header from \"%s\"",fname) ;
d653 2
a654 2
                 if (READ(new->be,new->aofhdr->aof_type) != AOF_RELOC)
                  errormsg(0,"Invalid AOF ID 0x%08X in ChunkFile \"%s\"",READ(new->be,new->aofhdr->aof_type),fname) ;
d656 2
a657 2
                  if (READ(new->be,new->aofhdr->aof_vsn) > AOF_VERSION)
                   warning("ChunkFile \"%s\" contains new AOF version %d (<=%d expected)",fname,READ(new->be,new->aofhdr->aof_vsn),AOF_VERSION) ;
d662 1
a662 1
               errormsg(0,"Unrecognised magic identifier 0x%08X in ChunkFile header",new->cfhdr->cf_magic) ;
d665 1
a665 1
            if (new->aofhdr != NULL) /* we have an AOF header */
d668 2
a669 2
              if ((new->aofsymt = cf_load(new,OBJ_SYMT)) == NULL)
               errormsg(0,"Symbol table not found") ;
d671 2
a672 2
              if ((new->aofstrt = cf_load(new,OBJ_STRT)) == NULL)
               errormsg(0,"String table not found") ;
d674 2
a675 2
              if ((new->aofareas = cf_load(new,OBJ_AREA)) == NULL)
               errormsg(0,"Code/Data Areas not found") ;
d684 1
a684 1
 return(new) ;
d687 3
d699 6
a704 1
unsigned32 convert_aof(s_aof *adesc,char *outfile,int dolib,int tiny,int kernel)
a705 1
 FILE          *ofp ;
a707 3
 unsigned32     version = READ(adesc->be,adesc->aofhdr->aof_vsn) ;
 unsigned32     maxdata = 0 ;
 unsigned32     maxcodep = 0 ;
d712 2
a713 3
 unsigned32     relocsize ;
 int            slimit = READ(adesc->be,adesc->aofhdr->aof_nsyms) ;
 int            nareas = READ(adesc->be,adesc->aofhdr->aof_nareas) ;
a719 8
 if (outfile != NULL)
  {
   if ((ofp = fopen(outfile,"wb")) == NULL)
    errormsg(8,"Failed to open output file \"%s\"",outfile) ;
  }
 else
  ofp = NULL ; /* scanning pass */

d721 1
a721 4
  {
   fclose(ofp) ;
   errormsg(9,"Failed to allocate temporary buffer") ;
  }
d723 2
a724 1
 codebase = (unsigned32 *)malloc(nareas * sizeof(unsigned32)) ;
d726 2
a727 1
  errormsg(81,"Failed to allocate memory for code area base addresses") ;
a730 1
 /* Release any data references that may be hanging around */
d732 372
d1105 48
a1152 1
   s_dataref *cptr = adesc->drefs ;
d1154 5
a1158 1
   for (; (cptr != NULL);)
d1160 58
a1217 3
     s_dataref *this = cptr ;
     cptr = this->next ;
     free(this) ;
d1220 1
a1220 1
   adesc->drefs = NULL ;
d1223 5
a1227 2
 /* maxcodep = number of exported functions */
 for (loop = 0; (loop < slimit); loop++)
d1229 188
a1416 1
   unsigned32 sattr = READ(adesc->be,adesc->aofsymt[loop].sym_AT) ;
d1418 10
a1427 2
   /* We are only interested in global symbols we define */
   if ((sattr & SYM_REFDEFMASK) == SYM_GLOBALDEFAT)
d1429 96
a1524 2
     int32 aname = READ(adesc->be,adesc->aofsymt[loop].sym_areaname) ;
     int   aloop ;
d1526 6
a1531 1
     for (aloop = 0; (aloop < nareas); aloop++)
d1533 9
a1541 1
       if (READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_name) == aname)
d1543 1
a1543 2
         unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[aloop].area_attributes) ;
         if (attr & AOF_CODEAT) /* an exported code symbol */
d1545 142
a1686 1
           maxcodep += sizeof(unsigned32) ;
d1688 2
d1693 2
a1694 1
  }
d1696 1
a1696 6
 /* maxdata = size of exported data */
 /* This will be the total of all the (non-based and non-shared) data areas */
 for (loop = 0; (loop < nareas); loop++)
  {
   unsigned32 attr = READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_attributes) ;
   if (!(attr & AOF_CODEAT) && !(attr & AOF_BASEDAT) && !(attr & AOF_SHLDATA))
d1698 9
a1706 1
     maxdata += READ(adesc->be,adesc->aofhdr->aof_areas[loop].area_size) ;
d1710 35
a1744 3
#if DEBUG
 printf("*DBG* convert_aof: maxcodep 0x%08X : maxdata 0x%08X\n",maxcodep,maxdata) ;
#endif
d1746 1
a1746 1
 if (!dolib && !kernel) /* not building a library or kernel object */
d1748 9
a1756 2
   /* Output the object header */
   boff = 0 ; /* no bytes in the buffer */
d1758 4
a1761 1
   write_byte(HOF_t_module,ofp) ; write_encoded(-1,ofp) ; /* MODULE -1 */
d1763 1
a1763 4
   /* Output the magic identifier and "code size" value */
   PWRITE(0,(buffer + boff),HOF_magic_module) ; boff += sizeof(unsigned32) ; codepos++ ;
   PWRITE(0,(buffer + boff),adesc->codesize) ; boff += sizeof(unsigned32) ; codepos++ ;
   if ((tlen = strlen(adesc->fname)) > (HOF_title_len - 1))
d1765 3
a1767 2
     loop = (tlen - HOF_title_len - 1) ;
     tlen = (HOF_title_len - 1) ;
a1768 6
   else
    loop = 0 ;
   memcpy((buffer + boff),(unsigned char *)&(adesc->fname[loop]),tlen) ; boff += tlen ;
   write_data(buffer,boff,ofp) ;
   write_padding((HOF_title_len - tlen),ofp) ;
   codepos += (HOF_title_len / sizeof(unsigned32)) ; /* words covering title string */
d1770 2
a1771 1
   write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_modnum,ofp) ; codepos++ ; /* WORD MODNUM */
d1773 3
a1775 7
   PWRITE(0,(buffer + 0),version) ;
   PWRITE(0,(buffer + sizeof(unsigned32)),maxdata) ;
   write_data(buffer,(2 * sizeof(unsigned32)),ofp) ; codepos += 2 ;

   write_byte(HOF_t_init,ofp) ; codepos++ ;

   PWRITE(0,buffer,maxcodep) ; write_data(buffer,sizeof(unsigned32),ofp) ; codepos++ ;
d1779 2
a1780 1
 boff = 0 ;
d1782 1
d1797 1
a1797 1
      errormsg(0,"Object file Area %d is not APCS-3 re-entrant",loop) ;
d1808 1
a1808 1
         errormsg(98,"Code area is not a word multiple in size") ;
d1825 2
a1826 2
           char       *symname = findstring(adesc,READ(adesc->be,symbol->sym_name)) ;
           unsigned32  sattr = READ(adesc->be,symbol->sym_AT) ;
d1832 3
a1834 1
             write_byte(HOF_t_label,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
d1845 2
a1846 3
#if DEBUG
 printf("*DBG* code[0x%08X] = 0x%08X\n",(iloop << 2),inst) ;
#endif
d1854 1
a1854 1
            if (READ(adesc->be,relocs[rloop].rel_offset) == (iloop << 2))
d1892 2
a1893 4
#if DEBUG
 printf("*DBG* relocation %d : offset = 0x%08X\n",rloop,READ(adesc->be,reloc->rel_offset)) ;
 printf("*DBG* symindex = %d\n",symindex) ;
#endif
d1902 2
a1903 2
                 char       *symname = findstring(adesc,READ(adesc->be,symbol->sym_name)) ;
                 unsigned32  sattr = READ(adesc->be,symbol->sym_AT) ;
d1915 1
a1915 1
                  warning("PC-relative instruction relocation to a non-imported symbol") ;
d1918 2
a1919 2
                 write_byte(HOF_t_word,ofp) ; /* WORD */
                 write_byte(HOF_t_patch_armjp,ofp) ; /* PATCH ARM JP */
d1921 1
a1921 1
                 write_byte(HOF_t_labelref,ofp) ; /* LABELREF */
d1933 1
a1933 3
#if DEBUG
 printf("*DBG* based relocation\n") ;
#endif
d1937 1
a1937 1
                    errormsg(41,"Based relocation with non-LDR (0x%08X)",inst) ;
d1939 1
a1939 1
                    errormsg(42,"Based relocation (LDR) not using r9 (0x%08X)",inst) ;
d1941 1
a1941 1
                    errormsg(43,"Based relocation has non-immediate offset (0x%08X)",inst) ;
d1946 1
a1946 1
                    errormsg(60,"Negative offsets are not supported for based loads (%d)",offset) ;
d1958 1
a1958 3
#if DEBUG
 printf("*DBG* area %d : aattr = 0x%08X\n",aloop,aattr) ;
#endif
d1966 1
a1966 1
                          errormsg(52,"Area is based on r%d, should be r9",((aattr & AOF_BASEMASK) >> AOF_BASESHIFT)) ;
d2004 2
a2005 3
#if DEBUG
printf("*DBG* AREA relative: symindex = %d : sval = 0x%08X : saname = 0x%08X\n",symindex,sval,saname) ;
#endif
d2014 7
a2020 3
#if DEBUG
 printf("*DBG* sloop %d : sym_areaname 0x%08X : sym_value 0x%08X : exported %s\n",sloop,READ(adesc->be,adesc->aofsymt[sloop].sym_areaname),READ(adesc->be,adesc->aofsymt[sloop].sym_value),(((READ(adesc->be,adesc->aofsymt[sloop].sym_AT) & SYM_REFDEFMASK) == SYM_GLOBALDEFAT) ? "Yes" : "No")) ;
#endif
d2055 1
a2055 1
                              errormsg(33,"Symbol not found for relocation") ;
d2057 1
a2057 1
                             symname = findstring(adesc,READ(adesc->be,adesc->aofsymt[symindex].sym_name)) ;
d2062 4
a2065 2
                             write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armjp,ofp) ; write_encoded(BranchCC(0,0,(inst >> 28)),ofp) ;
                             write_byte(HOF_t_labelref,ofp) ;
d2078 1
a2078 1
                          errormsg(65,"Failed to find relocation for offset %d",offset) ;
d2081 1
a2081 1
                        errormsg(51,"Referenced area is not based") ;
d2090 1
a2090 1
                  errormsg(40,"Relocation: displaced : %d : 0x%08X : flags 0x%08X (not yet handled)\n",iloop,inst,relflags) ;
d2094 1
a2094 1
              errormsg(99,"No code to deal with byte, short or long relocations yet") ;
d2112 1
a2112 3
#if DEBUG
 printf("*DBG* code areas processed\n") ;
#endif
d2121 1
a2121 1
       char *symname = findstring(adesc,READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
d2125 1
a2125 1
       write_byte(HOF_t_label,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2134 2
a2135 2
       write_byte(HOF_t_word,ofp) ;
       write_byte(HOF_t_patch_armdt,ofp) ;
d2137 1
a2137 1
       write_byte(HOF_t_datamodule,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2140 2
a2141 2
       write_byte(HOF_t_word,ofp) ;
       write_byte(HOF_t_patch_armdt,ofp) ;
d2143 1
a2143 1
       write_byte(HOF_t_codesymbol,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2162 1
a2162 1
   char       *symname = findstring(adesc,READ(adesc->be,adesc->aofsymt[dref->symindex].sym_name)) ;
d2169 1
a2169 1
   write_byte(HOF_t_label,ofp) ;
d2205 1
a2205 1
        errormsg(20,"FATAL: Value of zero failed rotatable test") ;
d2212 1
a2212 1
       sval = (sval & ~(0xFF << shift)) ;
d2224 2
a2225 2
       write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdplsb,ofp) ; write_encoded((int)addrADDpc(dref->destreg),ofp) ;
       write_byte(HOF_t_labelref,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2231 2
a2232 2
         write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdpmid,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
         write_byte(HOF_t_labelref,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2237 2
a2238 2
       write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdprest,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
       write_byte(HOF_t_labelref,ofp) ; write_byte('.',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2243 1
a2243 1
       write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdt,ofp) ; write_encoded((int)LDRfromdp(dref->destreg),ofp) ;
d2247 1
a2247 1
         write_byte(HOF_t_datamodule,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2251 1
a2251 1
         write_byte(HOF_t_patch_shift,ofp) ; write_byte(0x3,ofp) ; write_byte(HOF_t_modnum,ofp) ;
d2256 2
a2257 2
       write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdplsb,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
       write_byte(HOF_t_datasymb,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2263 2
a2264 2
         write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdpmid,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
         write_byte(HOF_t_datasymb,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2269 2
a2270 2
       write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdprest,ofp) ; write_encoded((int)addrADD(dref->destreg),ofp) ;
       write_byte(HOF_t_datasymb,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2287 1
a2287 1
          errormsg(20,"FATAL: Value of zero failed rotatable test") ;
d2294 1
a2294 1
         sval = (sval & ~(0xFF << shift)) ;
d2311 1
a2311 3
#if DEBUG
   printf("*DBG* adding initialisation code\n") ;
#endif
d2314 1
a2314 1
   write_byte(HOF_t_init,ofp) ; codepos++ ; /* INIT */
d2328 2
a2329 2
         char *symname = findstring(adesc,READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
         write_byte(HOF_t_codetable,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2336 1
a2336 1
    unsigned32 *ssize = (unsigned32 *)malloc(slimit * sizeof(unsigned32)) ;
d2339 1
a2339 1
     errormsg(80,"Failed to allocate memory for symbol table size vector") ;
d2362 1
a2362 1
        int   last = asize ;
d2381 1
a2381 1
            int32 sval = READ(adesc->be,adesc->aofsymt[hidx].sym_value) ;
d2383 1
a2383 1
            last = sval ;
d2393 1
a2393 1
              char *symname = findstring(adesc,READ(adesc->be,adesc->aofsymt[sloop].sym_name)) ;
d2398 4
a2401 1
              write_byte(HOF_t_data,ofp) ; write_encoded(ssize[sloop],ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2415 2
a2416 2
   write_byte(HOF_t_word,ofp) ; /* WORD */
   write_byte(HOF_t_patch_armjp,ofp) ; /* PATCH ARM JP */
d2418 1
a2418 1
   write_byte(HOF_t_labelref,ofp) ; /* LABELREF */
d2425 2
a2426 2
     write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdt,ofp) ; write_encoded(initLDRfn,ofp) ;
     write_byte(HOF_t_patch_shift,ofp) ; write_byte(0x3,ofp) ; write_byte(HOF_t_modnum,ofp) ;
d2447 1
a2447 1
          errormsg(94,"Referenced symbol offset 0x%08X does NOT have an area name",sval) ;
d2455 1
a2455 1
          errormsg(93,"Area for referenced symbol offset 0x%08X not found",sval) ;
d2457 1
a2457 1
          errormsg(95,"Address of area containing symbol offset 0x%08X not known",sval) ;
d2466 1
a2466 1
            errormsg(20,"FATAL: Value of zero failed rotatable test") ;
d2475 1
a2475 1
           sval = (sval & ~(0xFF << shift)) ;
d2508 1
a2508 1
        write_data(data,asize,ofp) ;
d2515 1
a2515 1
     errormsg(25,"Output amount 0x%08X does not match maxdata amount 0x%08X",(int)amount,(int)maxdata) ;
d2518 1
a2518 1
     errormsg(26,"Amount of data written is NOT a word multiple") ; /* we will need to pad with NULs */
d2523 1
a2523 1
   write_byte(HOF_t_label,ofp) ; write_string(DATAINITSYM,strlen(DATAINITSYM),ofp) ;
d2534 2
a2535 2
     write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdt,ofp) ; write_encoded(initLDRdata,ofp) ;
     write_byte(HOF_t_patch_shift,ofp) ; write_byte(0x3,ofp) ; write_byte(HOF_t_modnum,ofp) ; codepos++ ;
d2543 2
a2544 2
       write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdplsb,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
       write_byte(HOF_t_datasymb,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
d2550 2
a2551 2
         write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdpmid,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
         write_byte(HOF_t_datasymb,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
d2556 2
a2557 2
       write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdprest,ofp) ; write_encoded((int)addrADD(0xC),ofp) ;
       write_byte(HOF_t_datasymb,ofp) ; write_byte('_',ofp) ; write_string(firstdata,strlen(firstdata),ofp) ;
d2576 1
a2576 1
        errormsg(20,"FATAL: Value of zero failed rotatable test") ;
d2585 1
a2585 1
       sval = (sval & ~(0xFF << shift)) ;
d2603 1
a2603 1
          errormsg(20,"FATAL: Value of zero failed rotatable test") ;
d2612 1
a2612 1
         sval = (sval & ~(0xFF << shift)) ;
d2621 1
a2621 1
     looppos = (codepos << 2) ; /* current code position */
d2683 1
a2683 1
              errormsg(65,"Relocation is relative to an AREA (TODO)") ;
d2686 1
a2686 1
              errormsg(44,"Instruction relocation type on data area") ;
d2689 1
a2689 1
              errormsg(45,"PC-relative relocation type on data area (TODO)") ;
d2692 1
a2692 1
              errormsg(46,"Based relocation type on data area (TODO)") ;
d2698 1
a2698 1
             symname = findstring(adesc,READ(adesc->be,symbol->sym_name)) ;
d2712 2
a2713 2
                 write_byte(HOF_t_word,ofp) ; write_byte(HOF_t_patch_armdt,ofp) ; write_encoded(initLDRdata,ofp) ;
                 write_byte(HOF_t_patch_shift,ofp) ; write_byte(0x3,ofp) ; write_byte(HOF_t_modnum,ofp) ; codepos++ ;
d2718 1
a2718 1
                errormsg(67,"Byte and short relocations are not supported at the moment") ;
d2727 1
a2727 1
                 int        base = roff ;
d2734 1
a2734 1
                 base -= remainder ;
d2740 1
a2740 1
                    errormsg(21,"FATAL: Value of zero failed rotatable test") ;
d2744 1
a2744 1
                   inst = ((initial ? initADDdp : initADD) | ((16 - (shift >> 1)) << 8) | ((base >> shift) & 0xFF)) ;
d2762 1
a2762 3
#if DEBUG
printf("*DBG* sval = 0x%08X\n",sval) ;
#endif
d2768 1
a2768 1
                    errormsg(22,"FATAL: Value of zero failed rotatable test") ;
d2773 1
a2773 1
                   sval = (sval & ~(0xFF << shift)) ;
d2790 1
a2790 1
              errormsg(56,"Relocation references some other data area (TODO)") ;
d2794 1
a2794 1
         datapos += asize ; /* update base by the size of this data area */
d2808 2
a2809 2
         char *symname = findstring(adesc,READ(adesc->be,adesc->aofsymt[loop].sym_name)) ;
         write_byte(HOF_t_global,ofp) ; write_byte('_',ofp) ; write_string(symname,strlen(symname),ofp) ;
d2821 1
a2821 33
 return(codepos << 2) ;
}

/*---------------------------------------------------------------------------*/

#if (SATEST == 1) /* stand-alone test routines */

typedef struct symholder
{
 struct symholder *next ;
 char             *name ;
} symholder ;

symholder *symlist = NULL ;

int check_symbol(char *symname)
{
 int        match = FALSE ;
 symholder *cptr ;

 /* Bodge support for the stand-alone object convertor. When the
  * convertor is embedded in the linker this routine should be provided by
  * the normal linker code. The linker will need to keep a hash table (or
  * some such structure) of ALL the code symbols it encounters.
  */
 for (cptr = symlist; (cptr != NULL); cptr = cptr->next)
  if (strcmp(cptr->name,symname) == 0)
   {
    match = TRUE ; /* treat as a code symbol */
    break ;
   }

 return(match) ;
d2824 1
a2824 91
/*---------------------------------------------------------------------------*/

int main(int argc,char **argv)
{
 int         index ; /* used in argument processing */
 char       *fname = NULL ;
 char       *outfile = NULL ;
 char       *symfile = NULL ;
 s_aof      *adesc ;
 int         dolib = FALSE ;
 int         tiny = FALSE ;
 int         kernel = FALSE ;
 unsigned32  csize2 ;

 for (index = 1; (index < argc); index++)
  if (argv[index][0] == '-') /* explicit option */
   {
    char *cptr ; /* general character pointer */
    int   loop ; /* general loop counter */

    switch (tolower((unsigned char)(argv[index][1])))
     {
      case 'o' : /* output object */
       if (argv[index][2] == '\0')
        cptr = argv[++index] ;
       else
        cptr = &argv[index][2] ;
       outfile = cptr ;
       if (cptr != NULL)
        {
         for (; (*cptr && (*cptr != ' ')); cptr++) ;
         if (*cptr && (*cptr == ' '))
          *cptr = '\0' ; /* terminate the string */
        }
       else
        errormsg(5,"No output filename given after the -o option\n") ;
       break ;

      case 'l' : /* library object generation */
       dolib = TRUE ;
       break ;

      case 't' : /* tiny model */
       tiny = TRUE ;
       break ;

      case 'r' : /* kernel model */
       kernel = TRUE ;
       break ;

      case 's' : /* bodge symbol file */
       if (argv[index][2] == '\0')
        cptr = argv[++index] ;
       else
        cptr = &argv[index][2] ;
       symfile = cptr ;
       if (cptr != NULL)
        {
         for (; (*cptr && (*cptr != ' ')); cptr++) ;
         if (*cptr && (*cptr == ' '))
          *cptr = '\0' ; /* terminate the string */
        }
       else
        errormsg(55,"No output filename given after the -o option\n") ;
       break ;

      case 'h' : /* help */
       fprintf(stderr,"Convert AOF objects into Helios objects\n") ;
       fprintf(stderr,"Syntax: tohobj -o <name> [-l|-r] [-t] <AOF>\n") ;
       fprintf(stderr,"-o <name> : output Helios object\n") ;
       fprintf(stderr,"-l        : library object generation\n") ;
       fprintf(stderr,"-r        : kernel object generation\n") ;
       fprintf(stderr,"-t        : short data accessess\n") ;
       fprintf(stderr,"-s <file> : bodge code symbol file\n") ;
       exit(0) ;

      default : /* unrecognised option */
       errormsg(1,"Unrecognised parameter \"%s\"",argv[index]) ;
     }
   }
  else
   if (fname != NULL)
    errormsg(2,"Too many file arguments") ;
   else
    fname = argv[index] ;

 if (fname == NULL)
  errormsg(3,"Filename needs to be specified") ;

 if (outfile == NULL)
  errormsg(4,"Output filename needs to be specified") ;
d2826 1
a2826 53
 if (symfile != NULL)
  {
   FILE *sfile = fopen(symfile,"rb") ;

   if (sfile == NULL)
    errormsg(12,"Failed to open bodge symbol file \"%s\"",symfile) ;

   while (!feof(sfile))
    {
     int tchr ;

     while (((tchr = getc(sfile)) != EOF) && (tchr == ' ') && (tchr == '\n')) ; /* step over newlines and whitespace */
     if (tchr == '#')
      while (((tchr = getc(sfile)) != EOF) && (tchr != '\n')) ; /* step upto next newline */
     else
      if (tchr != EOF)
       {
        char       tline[64] ;
        int        toff = 0 ;
        symholder *new ;
        
        tline[toff++] = (char)tchr ;
        while (((tchr = getc(sfile)) != EOF) && (tchr != '\n'))
         tline[toff++] = (char)tchr ;
        tline[toff] = '\0' ;

        if ((new = (symholder *)malloc(sizeof(symholder))) == NULL)
         errormsg(16,"Failed to allocate bodge symbol holder") ;
        if ((new->name = (char *)malloc(strlen(tline) + 1)) == NULL)
         errormsg(17,"Failed to allocate bodge symbol string") ;
        strcpy(new->name,tline) ;
        new->next = symlist ;
        symlist = new ;
       }
    }

   fclose(sfile) ;
  }

 adesc = open_aof(fname) ;
 if (adesc == NULL)
  errormsg(6,"Failed to open AOF file \"%s\"",fname) ;

 adesc->codesize = convert_aof(adesc,NULL,dolib,tiny,kernel) ;
 if ((csize2 = convert_aof(adesc,outfile,dolib,tiny,kernel)) != adesc->codesize)
  errormsg(9,"Code size changed between 1st (0x%08X) and 2nd (0x%08x) passes",adesc->codesize,csize2) ;

 return(0) ;
}
#endif /* SATEST */

/*---------------------------------------------------------------------------*/
/*> EOF convert.c <*/
@


1.1
log
@AOF to GHOF converter
@
text
@d5 3
a7 3
 * $Revision: 0.2 $
 *   $Author: jsmith $
 *     $Date: 931202 $
d43 1
a43 1
#define SATEST (1)  /* should be set to (0) when embedded in another program */
@
