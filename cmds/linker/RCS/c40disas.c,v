head	1.30;
access;
symbols
	Helios_1_3_1:1.29
	Helios_C40_1_3_Official_Release:1.26
	Alenia_release:1.25
	C40_Field_Test_2:1.23
	C40_Field_Test_R1:1.13;
locks; strict;
comment	@ * @;


1.30
date	94.03.02.15.16.30;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	93.09.20.14.47.58;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	93.08.04.10.41.40;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	93.07.12.15.43.51;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	93.01.15.14.22.40;	author nick;	state Exp;
branches;
next	1.25;

1.25
date	92.12.16.19.11.51;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	92.12.08.09.49.37;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	92.09.14.09.05.01;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	92.09.04.14.35.10;	author paul;	state Exp;
branches;
next	1.21;

1.21
date	92.07.28.09.18.28;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	92.07.28.09.15.48;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	92.07.16.10.56.52;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	92.07.16.10.52.42;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	92.07.16.09.47.52;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	92.07.16.09.19.39;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	92.07.16.09.07.49;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	92.07.07.13.47.17;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	92.06.16.08.52.08;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	92.06.15.12.04.22;	author paul;	state Exp;
branches;
next	1.11;

1.11
date	92.04.21.10.18.18;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	92.01.28.15.07.07;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	92.01.28.13.06.25;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	91.11.22.16.08.40;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	91.10.29.09.37.50;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	91.10.23.13.36.26;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	91.10.21.15.36.43;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	91.10.17.16.07.55;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	91.10.10.16.22.52;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	91.10.09.13.53.14;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	91.10.08.16.17.34;	author paul;	state Exp;
branches;
next	;


desc
@@


1.30
log
@fixed for compilation under Solaris
@
text
@/*
 * c40disas - a stand alone disassembler for the TMS320C40
 *
 * Copyright (c) 1992 - 1993 Perihelion Software Ltd.
 *  All Rights Reserved.
 *
 * Author: 	N Clifton
 * Version:	$Revision: 1.29 $
 * Date:	$Date: 1993/09/20 14:47:58 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.29 1993/09/20 14:47:58 nickc Exp nickc $
 */

/*{{{  Headers   */

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include "c40ops.h"
#include "c40target.h"
#include <helios.h>
#include <module.h>

#ifdef SUN4
#include <unistd.h>	/* for SEEK_SET */
#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS	0
#endif
#ifndef EXIT_FAILURE
#define EXIT_FAILURE	-1
#endif

#define strtoul		strtol
#endif

/*}}}*/
/*{{{  Types     */

typedef enum
  {
    TYPE_SIGNED,
    TYPE_UNSIGNED,
    TYPE_FLOATING
  }
immed_type;

/*}}}*/
/*{{{  Constants */

#ifndef TRUE
#define TRUE	1
#define FALSE	0
#define bool	int
#endif

/*
 * the disassembly layout is as follows:
 *
 * AAAAAAAA WWWWWWWW BBBB OOOOO PPPPPPPPPPPP DDDDDD TTTTTTT
 *
 * where
 *
 *   A - word address
 *   W - value at address
 *   B - byte equivalents of word
 *   O - corresponding op code
 *   P - operands of op code
 *   D - destination of branches
 *   T - trace information
 */

#define COL_ADDR	1
#define COL_WORD	9
#define COL_BYTES	21
#define COL_OP_CODE	35
#define COL_OPERAND	41
#define COL_DESTINATION	56
#define COL_TRACE	73

#ifndef RS6000
#define abs( a )	((a) < 0 ? -(a) : (a))
#endif

/*}}}*/
/*{{{  Variables */

static unsigned char * 		ProgName     = (unsigned char *)"disas"; /* the name of the program */
static unsigned long int	word_address = 0;			 /* address of current instruction */
static unsigned long int	address_base = 0;			 /* offset to word address for displaying addresses */

static unsigned char *		output_file  = (unsigned char *)"-";	 /* name of output destination */
static FILE *			output	     = NULL;			 /* file handle for output */

int	pcsregs = FALSE;	/* default to std machine register names */

/*}}}*/
/*{{{  Functions */

/*{{{  Print Routines */

/*{{{  inform */

/*
 * display an error or information message
 */

#ifdef __CC_NORCROFT
#pragma -v3
#endif

static void
inform(
       char *	message,
       ...		)
{
  va_list	args;


  va_start( args, message );

#if 0
  fflush( stderr );

  fseek( stderr, 0L, SEEK_END );
#endif
  
  if (ProgName)
    fprintf( stderr, "%s: ", ProgName );

  vfprintf( stderr, message, args );

  fprintf( stderr, "\n" );

#if 0
  fflush( stderr );
#endif
  
  va_end( args );

  return;
  
} /* inform */

/*}}}*/
/*{{{  myprint */

static int 	current_column = 0;		/* number of characters printed out on current line */


/*
 * display a message, keeping a track of where we are
 */

static void
myprint( const char * format, ... )
{
  static char	buffer[ 1024 ];			/* XXX */
  va_list	args;
  char *	start;
  char *	ptr;


  if (output == NULL)
    return;
  
  va_start( args, format );

#if 0
  fflush( output );

  fseek( output, 0L, SEEK_END );
#endif
  
  vsprintf( buffer, format, args );

  current_column += strlen( buffer );

  start = buffer;
  
  while ((ptr = (char *)strchr( start, '%' )) != NULL)
    {
      *ptr = '\0';

      fprintf( output, start );

      fprintf( output, "%%" );

      start = ptr + 1;
    }

  fprintf( output, start );

#if 0
  fflush( output );
#endif

  va_end( args );

  return;
    
} /* myprint */

#ifdef __CC_NORCROFT
#pragma -v0
#endif

/*}}}*/
/*{{{  pad_to */

/*
 * output spaces until the given column is reached
 */

static void
pad_to( int goal_column )
{
  if (current_column < goal_column)
    {
      while (current_column < goal_column)
	{
	  fputc( ' ', output );

	  ++current_column;
	}
    }
  else if (current_column > goal_column)
    {
      fputc( ' ', output );
    }

  fflush( output );

  return;

} /* pad_to */

/*}}}*/
/*{{{  new_line */

/*
 * send a newline character, adjusting column count aswell
 */

static void
new_line( void )
{
  fputc( '\n', output );

  current_column = 0;

  return;
  
} /* new_line */

/*}}}*/

/*}}}*/
/*{{{  List Routines */

/*
 * list manipulation routines - stolen from Helios
 */

/*{{{  Types */

typedef struct Node
  {
    struct Node *	next;
    struct Node *	prev;
  }
Node;

typedef struct
  {
    Node *	head;	/* points to first real item on list */
    Node *	earth;	/* always NULL */
    Node *	tail;	/* points to last real item on list */
  }
List;

/*}}}*/
/*{{{  Functions */

/*{{{  seearch_list */

/*
 * search a list using a supplied boolean function
 * returns the first node that "matches" or NULL
 */

static Node *
search_list(
	    register List *	plist,		/* the list to scan */
	    register bool (*	pfunc)(),	/* the function to apply */
	    register long int 	arg )		/* the argument to the applied function */
{
  register Node *	pnode;


  for (pnode = plist->head; pnode->next != NULL; pnode = pnode->next)
    {
      if ((*pfunc)( pnode, arg ))
	return pnode;
    }
  
  return NULL;

} /* search_list */

/*}}}*/
/*{{{  init_list */

/*
 * initialise a list
 */

static void
init_list( register List * plist )
{
  plist->head  = (Node *)&plist->earth;
  plist->earth = NULL;
  plist->tail  = (Node *)&plist->head;
  
  return;
  
} /* init_list */

/*}}}*/
/*{{{  pre_insert */

/*
 * insert a node before another node in a list
 */

static void
pre_insert(
	   register Node *	pnext,
	   register Node *	pnode )
{
  pnode->prev       = pnext->prev;
  pnode->next       = pnext;
  pnext->prev       = pnode;
  pnode->prev->next = pnode;
	
  return;
  
} /* pre_insert */

/*}}}*/
/*{{{  add_tail */

/*
 * add a node to the end of the list
 */

static void
add_tail(
	register List *	plist,
	register Node *	pnode )
{
  pnode->prev       = plist->tail;
  pnode->next       = (Node *)&plist->earth;
  plist->tail->next = pnode;
  plist->tail       = pnode; 
  
  return;

} /* add_tail */

/*}}}*/
/*{{{  remove_head */

/*
 * remove the first node on a list
 * returns the node or NULL
 */

static Node *
remove_head( register List * plist )
{
  register Node *	pnode;
  

  pnode = plist->head;
  
  if (pnode->next == NULL)
    return NULL;
  
  pnode->next->prev = (Node *)plist;
  plist->head       = pnode->next;
  pnode->next       = NULL;
  pnode->prev       = NULL;
	
  return pnode;

} /* remove_head */

/*}}}*/

/*}}}*/

/*}}}*/
/*{{{  Disassembler Routines */

/*
 * Disassembler routines
 */

/*{{{  Macros */

static char *	regstr =
  "R0\0\0R1\0\0R2\0\0R3\0\0R4\0\0R5\0\0R6\0\0R7\0\0"
  "AR0\0AR1\0AR2\0AR3\0AR4\0AR5\0AR6\0AR7\0"
  "DP\0\0IR0\0IR1\0BK\0\0SP\0\0ST\0\0DIE\0IIE\0"
  "IIF\0RS\0\0RE\0\0RC\0\0R8\0\0R9\0\0R10\0R11\0";

#define _regname( r ) ((((r) & 0x1f) * 4) + regstr)
		       
static char *	condstr =
  "u\0\0\0\0lo\0\0\0ls\0\0\0hi\0\0\0hs\0\0\0eq\0\0\0ne\0\0\0"
  "lt\0\0\0le\0\0\0gt\0\0\0ge\0\0\0<xx>\0nv\0\0\0v\0\0\0\0"
  "nuf\0\0uf\0\0\0nlv\0\0lv\0\0\0nluf\0luf\0\0zuf\0\0"
  "<xx>\0<xx>\0<xx>\0<xx>\0<xx>\0<xx>\0<xx>\0"
  "<xx>\0<xx>\0<xx>\0<xx>\0";
  
#define _condname( r ) ((((r) & 0x1f) * 5) + condstr)

/*}}}*/
/*{{{  Functions */

/*{{{  decode_indirect_address */

/*
 * decodes the indirect addressing field of a 'C40 op code
 */

static void
decode_indirect_address(
			long int	mode,	/* the indirect addressing mode (5 bits wide) */
			long int	addr,	/* the address register involved */
			long int	disp )	/* the displacement involved */
{
  pad_to( COL_OPERAND );
  
  switch (mode)
    {
    case B_00000:	myprint( "*+AR%ld(%ld)",         addr, disp ); break;
    case B_00001:	myprint( "*-AR%ld(%ld)",         addr, disp ); break;
    case B_00010:	myprint( "*++AR%ld(%ld)",        addr, disp ); break;
    case B_00011:	myprint( "*--AR%ld(%ld)",        addr, disp ); break;
    case B_00100:	myprint( "*AR%ld++(%ld)",        addr, disp ); break;
    case B_00101:	myprint( "*AR%ld--(%ld)",        addr, disp ); break;
    case B_00110:	myprint( "*AR%ld++(%ld)%%",      addr, disp ); break;
    case B_00111:	myprint( "*AR%ld--(%ld)%%",      addr, disp ); break;
    case B_01000:	myprint( "*+AR%ld(IR0)",         addr       ); break;
    case B_01001:	myprint( "*-AR%ld(IR0)",         addr       ); break;
    case B_01010:	myprint( "*++AR%ld(IR0)",        addr       ); break;
    case B_01011:	myprint( "*--AR%ld(IR0)",        addr       ); break;
    case B_01100:	myprint( "*AR%ld++(IR0)",        addr       ); break;
    case B_01101:	myprint( "*AR%ld--(IR0)",        addr       ); break;
    case B_01110:	myprint( "*AR%ld++(IR0)%%",      addr       ); break;
    case B_01111:	myprint( "*AR%ld--(IR0)%%",      addr       ); break;
    case B_10000:	myprint( "*+AR%ld(IR1)",         addr       ); break;
    case B_10001:	myprint( "*-AR%ld(IR1)",         addr       ); break;
    case B_10010:	myprint( "*++AR%ld(IR1)",        addr       ); break;
    case B_10011:	myprint( "*--AR%ld(IR1)",        addr       ); break;
    case B_10100:	myprint( "*AR%ld++(IR1)",        addr       ); break;
    case B_10101:	myprint( "*AR%ld--(IR1)",        addr       ); break;
    case B_10110:	myprint( "*AR%ld++(IR1)%%",      addr       ); break;
    case B_10111:	myprint( "*AR%ld--(IR1)%%",      addr       ); break;
    case B_11000:	myprint( "*AR%ld",               addr       ); break;
    case B_11001:	myprint( "*AR%ld++(IR0)B",       addr       ); break;
    default:
      return;      
    }
  
  return;
  
} /* decode_indirect_addressing */

/*}}}*/
/*{{{  mask_and_sign_extend_word */

/*
 * extracts the bits specified by 'mask' from the word 'value'
 * if necessary the resulting word is sign extended.
 * 'mask' must be a contigous set of bits starting from
 * the least significant bit
 */

signed long int
mask_and_sign_extend_word(
			  unsigned long	int	value,
			  unsigned long	int	mask )
{
  value &= mask;

  if (value & ((mask + 1) >> 1))
    {
      value |= ~mask;
    }

  return (signed long int)value;
  
} /* mask_and_sign_extend_word */

/*}}}*/
/*{{{  decode_short_float */

/*
 * turns a 16 bit integer into a string
 * representing a short format C40 style
 * floating point number
 */

static const char *
decode_short_float( unsigned long number )
{
  static char	buffer[ 20 ];
  unsigned long	e;
  unsigned long	s;
  unsigned long	f;
  union
    {
      float		f;	/* XXX beware of assumption that 	*/
      unsigned long	l;	/* sizeof (float) == sizeof (long)	*/
    }
  converter;
  
  
  if (number & 0xffff0000U)
    {
      return "bad format short float";
    }

  /*
   * format is ...
   *
   *
   *  15      12   11   10       0
   *  ____________________________
   * |          |      |          |
   * | exponent | sign | mantissa |
   * |          |      |          |
   *  ----------------------------
   *
   * interpretation is ...
   *
   * e = -8, s = 0, m = 0 => 0.0
   * s = 0                =>   01.m  x 2^e
   * s = -1               => -(10.m) x 2^e
   *
   */

  /* extract components */
  
  e = (number & 0xf000U) >> 12;
  s =  number & 0x0800U;
  f =  number & 0x07ffU;

  e = mask_and_sign_extend_word( e, 0xf );
  
  /* handle the special case */
  
  if (s == 0 && e == -8 && f == 0)
    {
      return "0.0";
    }

  /* convert the binary value into host specific floating point value */
  
#ifdef __CROSSCOMP

  /* convert to IEEE single precision */
  
  e += 0x7f;
  
  if (s == 0)
    {
      converter.l = (e << 23) | (f << (22 - 10));
    }
  else
    {
      if (f == 0)
	{
	  converter.l = ((e + 1) << 23) | (1 << 31);
	}
      else
	{
	  converter.l = (e << 23) | (((((~f) + 1) << (22 - 10))) & ((1 << 23) - 1)) | (1 << 31);
	}
    }
#else

  /* convert to C40 single precision */
  
  converter.l = (e << 24) | (s << (23 - 11)) | (f << (22 - 10));
  
#endif /* __C40 */

  /* convert to a string */
  
  sprintf( buffer, "%f", converter.f );

  /* return the string */
  
  return buffer;

} /* decode_short_float */

/*}}}*/
/*{{{  decode_diadic_address */

/*
 * decodes the addressing modes (the 'G' field)
 * of a 'C40 diadic op code
 */

static void
decode_diadic_address(
		      unsigned long	op_code,	/* instruction 			  */
		      char *		instruction,	/* string identifying instruction */
		      immed_type	type,		/* type of immediate value	  */
		      bool		store )		/* non zero if a store operation  */
{
  char *	pdest;
  long int	dest;

  
  /*
   * we have a diaidic op code
   *
   * bits 16 - 20 encode destination
   * bits 21 - 22 encode addressing type
   * bits 23 - 28 encode op code
   * bits 29 - 31 are 000
   */
  
  dest = (op_code >> 16) & 0x1f;

  myprint( instruction );

  pad_to( COL_OPERAND );

  if ((op_code >> 23) == OP_RPTS || (op_code >> 23) == OP_IACK)
    {
      /* this op code has no destination */
      
      pdest = NULL;
    }
  else
    {
      dest = (op_code >> 16) & 0x1f;

      if (type == TYPE_FLOATING)
	{
	  /* the destination (or source) register of a floating point op must be R0 - R11 */

	  if (!is_extended_precision_register( dest ))
	    {
	      myprint( "R<illegal>," );
	    }
	}

      pdest = _regname( dest );
    }
  
  switch ((op_code >> 21) & 0x3)
    {
    case 0: /* register to register */
      /*
       * we have a diaidic op code, using register addressing
       *
       * bits  0 - 4  encode source register
       * bits  5 - 15 are 00000000000
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

      op_code &= 0xffff;
      
      if ((op_code > 0x1f) ||
	  (type == TYPE_FLOATING &&
	  !is_extended_precision_register( (signed long) op_code )))
	{
	  myprint( "R<illegal>" );
	  
	  return;
	}
      
      if (pdest)
	myprint( "%s, %s", _regname( op_code ), pdest );
      else
	myprint( "%s", _regname( op_code ) );

      break;
	      
    case 1: /* direct */
      /*
       * we have a diaidic op code, using direct addressing
       *
       * bits  0 - 15 are an unsigned offset to the data page register
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

      op_code &= 0xffff;
      
      if (store)	/* pdest is actually source */
	myprint( "%s, @@%#04.4lx", pdest, op_code );
      else if (pdest)
	myprint( "@@%#04.4lx, %s", op_code, pdest );
      else
	myprint( "@@%#04.4lx", op_code );
      
      break;

    case 2: /* indirect */
      /*
       * we have a diaidic op code, using indirect addressing
       *
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

	{
	  long int	disp = op_code & 0xff;
	  long int	addr = (op_code >> 8) & 0x7;


	  if (store)
	    {
	      myprint( "%s, ", pdest );

	      decode_indirect_address( op_code >> 11 & 0x1f, addr, disp );
	    }
	  else
	    {
	      decode_indirect_address( (op_code >> 11) & 0x1f, addr, disp );

	      if (pdest)
		myprint( ", %s", pdest );
	    }
	}
      break;
      
    case 3: /* immediate */
      /*
       * we have a diaidic op code, using immeadiate addressing
       *
       * bits  0 - 15 are a signed immeadiate value
       * bits 16 - 20 encode destination register
       * bits 21 - 22 encode addressing type
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

      if (type == TYPE_SIGNED)
	dest = mask_and_sign_extend_word( op_code, 0x0000ffffU );
      else
	dest = op_code & 0xffffU;
      
      if (type == TYPE_FLOATING)
	{
	  myprint( "%s, %s", decode_short_float( dest ), pdest );
	}
      else if (dest < 500 && dest > -500 && type == TYPE_SIGNED)
	{
	  myprint( "%ld, %s", dest, pdest );
	}
      else if (pdest)
	{
	  myprint( "%#lx, %s", dest, pdest );
	}
      else
	{
	  myprint( "%#lx", dest );
	}
	
      break;      
    }

  return;
  
} /* decode_diadic_address */

/*}}}*/
/*{{{  decode_integer_store */

/*
 * handle the special case of the STI op code
 */

static void
decode_integer_store( unsigned long op_code )
{
  long int		dest;

  
  /*
   * we have an integer store
   *
   * bits  0 - 15 encode destination
   * bits 16 - 20 encode source
   * bits 21 - 22 encode addressing type
   * bits 23 - 31 are 000101010
   */

  dest = (op_code >> 16) & 0x1f;

  switch ((op_code >> 21) & 0x3)
    {
    case 0: /* indirect immediate */
      /*
       * bits  0 - 15 are an unsigned offset from the data page register
       * bits 16 - 20 encode value
       * bits 21 - 31 are 00010101000
       */

      myprint( "STIK" );

      pad_to( COL_OPERAND );

      myprint( "%ld, @@%#04.4lx", mask_and_sign_extend_word( dest, 0x1f ), (op_code & 0xffff) );

      break;
	      
    case 1: /* direct register */
      /*
       * bits  0 - 15 are an unsigned offset to the data page register
       * bits 16 - 20 encode source register
       * bits 21 - 31 are 00010101001
       */

      myprint( "STI" );

      pad_to( COL_OPERAND );

      myprint( "%s, @@%#04.4lx", _regname( dest ), (op_code & 0xffff) );

      break;

    case 2: /* indirect register */
      /*
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode source register
       * bits 21 - 31 are 00010101010
       */

      myprint( "STI" );

      pad_to( COL_OPERAND );

      myprint( "%s, ", _regname( dest ) );

      decode_indirect_address( (op_code >> 11) & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );

      break;
      
    case 3: /* indirect immediate */
      /*
       * bits  0 -  7 encode the displacment
       * bits  8 - 10 encode the address register
       * bits 11 - 15 encode the mode
       * bits 16 - 20 encode source value
       * bits 21 - 31 are 00010101011
       */

      myprint( "STIK" );

      pad_to( COL_OPERAND );

      myprint( "%ld, ", mask_and_sign_extend_word( dest, 0x1f ) );
	
      decode_indirect_address( (op_code >> 11) & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );

      break;
      
    }

  return;
  
} /* decode_integer_store */
  

/*}}}*/
/*{{{  decode_flow_control */

/*
 * decodes a 'C40 opcode concerned with handling program execution
 */

static void
decode_flow_control( unsigned long op_code )	/* the instruction to decode */
{
  /*
   * we have a flow control op code
   *
   * bits 30 - 31 are 01
   *
   * other bits are semi-random
   */

  if (op_code & (1 << 29))
    {
      /* bits 29 - 31 are 011 */

      if (op_code & (1 << 28))
	{
	  /* bits 28 - 31 are 0111 */
	  
	  if (op_code & (1 << 27))
	    {
	      /* bits 27 - 31 are 01111 */

	      if (op_code & (1 << 24))
		{
		  /*
		   * we have a repeat block with register addressing
		   *
		   * bits  0 -  4 encode the source
		   * bits  5 - 22 are 000000000000000000
		   * bit  23      encodes the delay
		   * bits 24 - 31 are 01111001
		   */

		  if (op_code & (1 << 23))
		    {
		      myprint( "RPTBD" );
		      
		      pad_to( COL_OPERAND );
		      
		      myprint( "%s", _regname( op_code ) );
		    }
		  else
		    {
		      myprint( "RPTB" );

		      pad_to( COL_OPERAND );

		      myprint( "%s", _regname( op_code ) );
		    }
		}
	      else
		{
		  /* bits 24 - 31 are 01111xx0 */

		  if (op_code & (1 << 23))
		    {
		      /*
		       * we have a conditional return from subroutine
		       *
		       * bits  0 - 15 are 0000000000000000
		       * bits 16 - 20 encode the condition 
		       * bits 21 - 31 are 01111000100
		       */

		      myprint( "RETS%s", _condname( op_code >> 16 ) );
		    }
		  else
		    {
		      /*
		       * we have a conditional return from interrupt
		       *
		       * bits  0 - 15 are 0000000000000000
		       * bits 16 - 20 encode the condition
		       * bit  21      encodes the delay type
		       * bits 22 - 31 are 0111100000
		       */

		      if (op_code & (1 << 21))
			{
			  myprint( "RETI%sD", _condname( op_code >> 16 ) );
			}
		      else
			{
			  myprint( "RETI%s", _condname( op_code >> 16 ) );
			}
		    }
		}
	    }
	  else
	    {
	      /* bits 27 - 31 are 01110 */
	      
	      if (op_code & (1 << 26))
		{
		  /* bits 26 - 31 are 011101 */

		  if (op_code & (1 << 25))
		    {
		      /*
		       * we have a transfer between register file and expansion register file
		       *
		       * bits  0 -  5 encode the source register
		       * bits  6 - 15 are 0000000000
		       * bits 16 - 20 encode the destination register
		       * bits 21 - 22 are 00
		       * bit  23      encodes the transfer type
		       * bits 24 - 31 are 01110110
		       */

		      if (op_code & (1 << 23))
			{
			  myprint( "LDPE" );

			  pad_to( COL_OPERAND );
			  
			  myprint( "%s, %s",
				  _regname( op_code ),
				  (((op_code >> 16) & 0xf) == 0) ? "IVTP" : "TVTP" );
			}
		      else
			{
			  myprint( "LDEP" );

			  pad_to( COL_OPERAND );
			  
			  myprint( "%s, %s",
				  ((op_code & 0xf) == 0) ? "IVTP" : "TVTP",
				  _regname( op_code >> 16 ) );
			}
		    }
		  else
		    {
		      char	op[ 10 ];

		  
		      /*
		       * we have a conditional trap
		       *
		       * bits  0 -  8 encode the trap number
		       * bits  9 - 15 are 0000000
		       * bits 16 - 20 encode the condition
		       * bits 21 - 22 are 00
		       * bit  23      encodes the trap type
		       * bits 24 - 31 are 01110100
		       */

		      if (op_code & (1 << 23))
			{
			  strcpy( op, "LAT" );
			}
		      else
			{
			  strcpy( op, "TRAP" );
			}
		      
		      strcat( op, _condname( (op_code >> 16) & 0x1f ) );

		      myprint( op );

		      pad_to( COL_OPERAND );
		      
		      myprint( "%lu", op_code & 0x1ff );
		    }
		}
	      else
		{
		  char	op[ 10 ];
		  
		  
		  /*
		   * we have a conditional jump to subroutine
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21      encodes the jump type
		   * bits 22 - 24 are 000
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011100
		   */

		  if (op_code & (1 << 21))
		    {
		      strcpy( op, "LAJ" );
		    }
		  else
		    {
		      strcpy( op, "CALL" );
		    }

		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );

		  myprint( op );

		  pad_to( COL_OPERAND );
		  
		  if (op_code & (1 << 25))
		    {
		      op_code = mask_and_sign_extend_word( op_code, 0xffffU );

		      myprint( "%+ld", op_code );

		      pad_to( COL_DESTINATION );

		      myprint( "(branch to %lx)", op_code + 3 + word_address + address_base );
		    }
		  else
		    {
		      myprint( "%s", _regname( op_code & 0x1f ) );
		    }
		}
	    }
	}
      else
	{
	  /* bits 28 - 31 are 0110 */

	  if (op_code & (1 << 27))
	    {
	      /* bits 27 - 31 are 01101 */

	      if (op_code & (1 << 26))
		{
		  char		op[ 10 ];
		  long int	addr;
		  long int	offset = 0;
		  

		  /*
		   * we have a conditional decrement and branch
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21      encodes delay
		   * bits 22 - 24 encodes the address register to be decremented
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011011
		   */

		  strcpy( op, "DB" );

		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		  
		  if (op_code & (1 << 21))
		    {
		      strcat( op, "D" );

		      offset = 4;
		    }
		  else
		    {
		      offset = 1;
		    }

		  addr = (op_code >> 22) & 0x7;

		  myprint( op );

		  pad_to( COL_OPERAND );
		  
		  if (op_code & (1 << 25))
		    {
		      op_code = mask_and_sign_extend_word( op_code, 0xffffU );
		      
		      myprint( "AR%1ld, %+ld", addr, op_code );
		    }
		  else
		    {
		      myprint( "AR%1ld, %s", addr, _regname( op_code & 0x1f ) );
		    }
		}
	      else
		{
		  char		op[ 10 ];
		  long int	offset = 0;
		  

		  /*
		   * we have a conditional branch
		   *
		   * bits  0 - 15 encode the source register or displacement
		   * bits 16 - 20 encode the condition
		   * bits 21 - 23 encode the type of branch
		   * bits 24      is 0
		   * bit  25      encodes the addressing mode
		   * bits 26 - 31 are 011010
		   */

		  strcpy( op, "B" );

		  strcat( op, _condname( (op_code >> 16) & 0x1f ) );
		  
		  switch ((op_code >> 21) & 0x7)
		    {
		    case B_000:	offset = 1; break;
		    case B_001:	strcat( op, "D"  ); offset = 3; break;
		    case B_010: return;
		    case B_011:	strcat( op, "AT" ); offset = 3; break;
		    case B_100:	return;
		    case B_101:	strcat( op, "AF" ); offset = 3; break;
		    case B_110:	return;
		    case B_111:	return;
		    }

		  myprint( op );

		  pad_to( COL_OPERAND );
		  
		  if (op_code & (1 << 25))
		    {
		      signed long int	dest;
		      signed long int	displacement;
		      
		      
		      displacement = mask_and_sign_extend_word( op_code, 0xffffU );

		      dest = displacement + offset + word_address;

		      myprint( "%+ld", displacement );

		      pad_to( COL_DESTINATION );

		      myprint( "(branch to %lx)", dest + address_base );
		    }
		  else
		    {
		      myprint( "%s", _regname( op_code & 0x1f ) );
		    }
		}
	    }
	  else
	    {
	      long int	offset = 0;
	      
	      
	      /* bits 27 - 31 are 01100 */

	      switch ((op_code >> 24) & 0x7)
		{
		case B_000:	myprint( "BR"    ); offset = 1; break;
		case B_001:	myprint( "BRD"   ); offset = 3; break;
		case B_010:	myprint( "CALL"  ); offset = 1; break;
		case B_011:	myprint( "LAJ"   ); offset = 3; break;
		case B_100:	myprint( "RPTB"  ); offset = 1; break;
		case B_101:	myprint( "RPTBD" ); offset = 3; break;
		case B_110:	myprint( "SWI"   ); return;
		default:
		case B_111:	return;
		}

	      op_code = mask_and_sign_extend_word( op_code, 0xffffffU );

	      pad_to( COL_OPERAND );

	      myprint( "%+ld", op_code );

	      pad_to( COL_DESTINATION );

	      myprint( "(branch to %lx)", op_code + offset + word_address + address_base );
	    }
	}
    }
  else
    {
      char 		op[ 10 ];
      immed_type	type;
      
      
      /*
       * we have a conditional load op
       *
       * bits  0 - 15 encode the source
       * bits 16 - 20 encode the destination
       * bits 21 - 22 encode the addressing mode
       * bits 23 - 27 encode the condition
       * bit  28      encodes op
       * bits 29 - 31 are 010
       */

      if (((op_code >> 28) & 0x1) == 0)
	{
	  strcpy( op, "LDF" );

	  type = TYPE_FLOATING;
	}
      else
	{
	  strcpy( op, "LDI" );

	  type = TYPE_SIGNED;
	}
      
      strcat( op, _condname( (op_code >> 23) & 0x1f ) );

      decode_diadic_address( op_code, op, type, FALSE );
      
      return;
    }

  return;

} /* decode_flow_control */

/*}}}*/
/*{{{  decode_non_word_load */

/*
 * decodes a 'C40 op code concerened with loading non-word quantities
 */

static void
decode_non_word_load( unsigned long	op_code )	/* instruction */
{
  char	op[ 5 ];
  char	B;
  
  
  /*
   * we have a non-word data transfer
   *
   * bits  0 - 16 encode source
   * bits 17 - 20 encode destination
   * bits 21 - 22 encode addressing type
   * bits 23 - 24 MAY encode a byte selector
   * bits 24 - 27 encode op
   * bits 28 - 31 are 1011
   */

  B = (char)((op_code >> 23) & 0x03);
  
  switch ((op_code >> 24) & 0x0f)
    {
    case OP_LB:
    case B_0001:
      strcpy( op, "LB0" );
      
      op[ 2 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_SIGNED, FALSE );
      
      break;

    case OP_LBU:
    case B_0011:
      strcpy( op, "LBU0" );
      
      op[ 3 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_LWL:
    case B_0101:
      strcpy( op, "LWL0" );

      op[ 3 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_LWR:
    case B_0111:
      strcpy( op, "LWR0" );

      op[ 3 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_MB:
    case B_1001:
      strcpy( op, "MB0" );

      op[ 2 ] = '0' + B;
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_LH:
      strcpy( op, "LH0" );

      op[ 2 ] = '0' + (B & 1);
      
      decode_diadic_address( op_code, op, TYPE_SIGNED, FALSE );
      
      break;
      
    case OP_LHU:
      strcpy( op, "LHU0" );

      op[ 3 ] = '0' + (B & 1);
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    case OP_MH:
      strcpy( op, "MH0" );

      op[ 2 ] = '0' + (B & 1);
      
      decode_diadic_address( op_code, op, TYPE_UNSIGNED, FALSE );
      
      break;

    default:
      break;
    }

  return;

} /* decode_non_word_load */

/*}}}*/
/*{{{  decode_special_triadic */

/*
 * decodes a multiple parallel triadic op code
 */

static void
decode_special_triadic( unsigned long 	op_code ) 	/* instruction to decode */
{
  char *	op1;
  char *	op2;
  long int	src1;
  long int	src2;
  long int	src3;
  long int	src4;
  long int	dst1;
  long int	dst2;
  
  
  /*
   * we have a special form of triadic op code
   *
   * bits  0 -  7 encode src4
   * bits  8 - 15 encode src3
   * bits 16 - 18 encode src2
   * bits 19 - 21 encode src1
   * bit  22      encodes dst2
   * bit  23      encodes dst1
   * bits 24 - 25 encode addressing mode
   * bits 26 - 27 encode operation
   * bits 28 - 31 are 1000
   */

  src4 =   op_code        & 0xff;
  src3 =  (op_code >>  8) & 0xff;
  src2 =  (op_code >> 16) & 0x07;
  src1 =  (op_code >> 19) & 0x07;
  dst2 = ((op_code >> 22) & 0x01) + 2;
  dst1 =  (op_code >> 23) & 0x01;
  
  switch ((op_code >> 26) & 0x3)
    {
    default:
    case OP_MPYF3_ADDF3:	op1 = "MPYF3"; op2 = "ADDF3"; break;
    case OP_MPYF3_SUBF3:	op1 = "MPYF3"; op2 = "SUBF3"; break;
    case OP_MPYI3_ADDI3:	op1 = "MPYI3"; op2 = "ADDI3"; break;
    case OP_MPYI3_SUBI3:	op1 = "MPYI3"; op2 = "SUBI3"; break;
    }

  switch ((op_code >> 24) & 0x3)
    {
    case B_00:
      myprint( "%s", op1 );

      pad_to( COL_OPERAND );
      
      decode_indirect_address( src3 >> 3, src3 & 7, 1 );

      myprint( ", " );
      
      decode_indirect_address( src4 >> 3, src4 & 7, 1 );

      myprint( ", %s", _regname( dst1 ) );

      new_line();

      pad_to( COL_OP_CODE - 3 );

      myprint( "|| %s", op2 );

      pad_to( COL_OPERAND );
      
      myprint( "%s, %s, %s", _regname( src1 ), _regname( src2 ), _regname( dst2 + 2 ) );

      break;
      
    case B_01:
      myprint( "%s", op1 );

      pad_to( COL_OPERAND );
      
      decode_indirect_address( src3 >> 3, src3 & 7, 1 );

      myprint( ", %s, %s", _regname( src1 ), _regname( dst1 ) );

      new_line();

      pad_to( COL_OP_CODE - 3 );
      
      myprint( "|| %s", op2 );

      pad_to( COL_OPERAND );
      
      decode_indirect_address( src4 >> 3, src4 & 7, 1 );

      myprint( ", %s, %s", _regname( src2 ), _regname( dst2 + 2 ) );

      break;
      
    case B_10:
      myprint( "%s", op1 );

      pad_to( COL_OPERAND );

      myprint( "%s, %s, %s", _regname( src1 ), _regname( src2 ), _regname( dst1 ) );

      new_line();

      pad_to( COL_OP_CODE - 3 );
      
      myprint( "|| %s ", op2 );

      pad_to( COL_OPERAND );
      
      decode_indirect_address( src3 >> 3, src3 & 7, 1 );

      myprint( ", " );

      decode_indirect_address( src4 >> 4, src4 & 7, 1 );

      myprint( ", %s", _regname( dst2 + 2 ) );

      break;
      
    case B_11:
      myprint( "%s", op1 );

      pad_to( COL_OPERAND );
      
      decode_indirect_address( src3 >> 3, src3 & 7, 1 );

      myprint( ", %s, %s", _regname( src1 ), _regname( dst1 ) );

      new_line();

      pad_to( COL_OP_CODE - 3 );
      
      myprint( "|| %s", op2 );

      pad_to( COL_OPERAND );
      
      myprint( "%s, ", _regname( src2 ) );

      decode_indirect_address( src4 >> 3, src4 & 7, 1 );

      myprint( ", %s", _regname( dst2  + 2 ) );

      break;
    }
  
  return;
  
} /* decode_special_triadic */

/*}}}*/
/*{{{  decode_non_word_load_or_triadic */

static void
decode_non_word_load_or_triadic( unsigned long	op_code )	/* instruction to decode */
{
  /*
   * we have either a special form of triadic op code or a non-word data transfer
   *
   * bits 28 - 29 encode form
   * bits 30 - 31 are 10
   */

  switch ((op_code >> 28) & 0x3)
    {
    case B_00:	decode_special_triadic( op_code ); break;
    case B_11:	decode_non_word_load( op_code ); break;
    default:	break;
    }

  return;

} /* decode_non_word_load_or_triadic */

/*}}}*/
/*{{{  decode_triadic_parallel_addressing */

static void
decode_triadic_parallel_addressing(
				   unsigned long	op_code,	/* the instruction to decode */
				   char *		first_op,	/* the name of the first op code */
				   char *		second_op )	/* the name of the second op code */
{
  unsigned long	src1;
  unsigned long	src2;
  unsigned long	src3;
  unsigned long	dst1;
  unsigned long	dst2;

  
  /*
   * we have a triaidic parallel op code of the form:
   *
   *    first_op  src2, src1, dst1
   * || second_op src3, dst2
   *
   *
   * bits  0 -  7 encode src2
   * bits  8 - 15 encode dst2
   * bits 16 - 18 encode src3
   * bits 19 - 21 encode src1
   * bits 22 - 24 encode dst1
   * bits 25 - 29 encode the operation
   * bits 30 - 31 are 11
   */

  src2 = (op_code      ) & 0xff;
  dst2 = (op_code >>  8) & 0xff;
  src3 = (op_code >> 16) & 0x07;
  src1 = (op_code >> 19) & 0x07;
  dst1 = (op_code >> 22) & 0x07;
  
  myprint( "%s ", first_op );

  pad_to( COL_OPERAND );
  
  decode_indirect_address( src2 >> 3, src2 & 7, 1 );
  
  myprint( ", %s, %s", _regname( src1 ), _regname( dst1 ) );

  new_line();
  
  pad_to( COL_OP_CODE - 3 );
  
  myprint( "|| %s", second_op );

  pad_to( COL_OPERAND );
  
  myprint( "%s, ", _regname( src3 ) );
      
  decode_indirect_address( dst2 >> 3, dst2 & 7, 1 );
      
  return;
      
} /* decode_triadic_parallel_addressing */

  

/*}}}*/
/*{{{  decode_diadic_parallel_addressing */

static void
decode_diadic_parallel_addressing(
				  unsigned long	op_code,	/* the instruction to decode */
				  char *	first_op,	/* string identifying the first op code */
				  char *	second_op )	/* string identifying the second op code */
{
  unsigned long	src2;
  unsigned long	src3;
  unsigned long	dst1;
  unsigned long	dst2;

  
  /*
   * we have a diaidic parallel op code of the form:
   *
   *    first_op  src2, dst1
   * || second_op src3, dst2
   *
   *
   * bits  0 -  7 encode src2
   * bits  8 - 15 encode dst2
   * bits 16 - 18 encode src3
   * bits 19 - 21 are 000
   * bits 22 - 24 encode dst1
   * bits 25 - 29 encode the operation
   * bits 30 - 31 are 11
   */

  src2 = (op_code      ) & 0xff;
  dst2 = (op_code >>  8) & 0xff;
  src3 = (op_code >> 16) & 0x07;
  dst1 = (op_code >> 22) & 0x07;
  
  /* validity test */
  
  if (((op_code >> 19) & 0x07) != 0)
    {
      return;
    }

  pad_to( COL_OP_CODE );
  
  myprint( "%s", first_op );

  pad_to( COL_OPERAND );
  
  decode_indirect_address( src2 >> 3, src2 & 7, 1 );

  myprint( ", %s", _regname( dst1 ) );

  new_line();
  
  pad_to( COL_OP_CODE - 3 );
  
  myprint( "|| %s", second_op );

  pad_to( COL_OPERAND );
  
  myprint( "%s, ", _regname( src3 ) );
      
  decode_indirect_address( dst2 >> 3, dst2 & 7, 1 );
  
  return;
      
} /* decode_diadic_parallel_addressing */

  

/*}}}*/
/*{{{  decode_parallel_op */

static void
decode_parallel_op( unsigned long 	op_code ) 	/* instruction to decode */
{
  unsigned long	field1;
  unsigned long	field2;
  unsigned long	field3;
  unsigned long	field4;
  unsigned long	field5;

  
  /*
   * we have a parallel op code
   *
   * bits  0 -  7 encode field1
   * bits  8 - 15 encode field2
   * bits 16 - 18 encode field3
   * bits 19 - 21 encode field4
   * bits 22 - 24 encode field5
   * bits 25 - 29 encode the operation
   * bits 30 - 31 are 11
   */

  field1 = (op_code      ) & 0xff;
  field2 = (op_code >>  8) & 0xff;
  field3 = (op_code >> 16) & 0x07;
  field4 = (op_code >> 19) & 0x07;
  field5 = (op_code >> 22) & 0x07;
  
  switch ((op_code >> 25) & 0x1f)
    {
    case OP_STF_STF:
      /* validity tests */

      if (field4 != 0)
	{
	  return;
	}
      
      myprint( "STF" );
      
      pad_to( COL_OPERAND );

      myprint( "%s, ", _regname( field5 ) );
      
      decode_indirect_address( field1 >> 3, field1 & 7, 1 );

      new_line();

      pad_to( COL_OP_CODE - 3 );
      
      myprint( "|| STF" );

      pad_to( COL_OPERAND );
      
      myprint( "%s, ", _regname( field3 ) );
      
      decode_indirect_address( field2 >> 3, field2 & 7, 1 );
      
      break;
      
    case OP_STI_STI:
      /* validity tests */

      if (field4 != 0)
	{
	  return;
	}
      
      myprint( "STI" );

      pad_to( COL_OPERAND );

      myprint( "%s, ", _regname( field5 ) );
      
      decode_indirect_address( field1 >> 3, field1 & 7, 1 );

      new_line();
      
      pad_to( COL_OP_CODE - 3 );
      
      myprint( "|| STI" );

      pad_to( COL_OPERAND );
      
      myprint( "%s, ", _regname( field3 ) );
      
      decode_indirect_address( field2 >> 3, field2 & 7, 1 );
      
      break;
      
    case OP_LDF_LDF:
      /* validity tests */

      if (field3 != 0)
	{
	  return;
	}
      
      myprint( "LDF" );

      pad_to( COL_OPERAND );
      
      decode_indirect_address( field1 >> 3, field1 & 7, 1 );
      
      myprint( ", %s", _regname( field5 ) );

      new_line();

      pad_to( COL_OP_CODE - 3 );
      
      myprint( "|| LDF" );

      pad_to( COL_OPERAND );
      
      decode_indirect_address( field2 >> 3, field2 & 7, 1 );

      myprint( ", %s", _regname( field4 ) );
      
      break;
      
    case OP_LDI_LDI:
      /* validity tests */

      if (field3 != 0)
	{
	  return;
	}
      
      myprint( "LDI" );

      pad_to( COL_OPERAND );
      
      decode_indirect_address( field1 >> 3, field1 & 7, 1 );
      
      myprint( ", %s", _regname( field5 ) );

      new_line();
      
      pad_to( COL_OP_CODE - 3 );
      
      myprint( "|| LDI" );
      
      pad_to( COL_OPERAND );
      
      decode_indirect_address( field2 >> 3, field2 & 7, 1 );

      myprint( ", %s", _regname( field4 ) );
      
      break;
      
    case OP_ABSF_STF:	decode_diadic_parallel_addressing(  op_code, "ABSF",   "STF" ); break;
    case OP_ABSI_STI:	decode_diadic_parallel_addressing(  op_code, "ABSI",   "STI" ); break;
    case OP_ADDF3_STF:	decode_triadic_parallel_addressing( op_code, "ADDF3",  "STF" ); break;
    case OP_ADDI3_STI:	decode_triadic_parallel_addressing( op_code, "ADDI3",  "STI" ); break;
    case OP_AND3_STI:	decode_triadic_parallel_addressing( op_code, "AND3",   "STI" ); break;
    case OP_ASH3_STI:	decode_triadic_parallel_addressing( op_code, "ASH3",   "STI" ); break;
    case OP_FIX_STI:	decode_diadic_parallel_addressing(  op_code, "FIX",    "STI" ); break;
    case OP_FLOAT_STF:	decode_diadic_parallel_addressing(  op_code, "FLOAT",  "STF" ); break;
    case OP_LDF_STF:	decode_diadic_parallel_addressing(  op_code, "LDF",    "STF" ); break;
    case OP_LDI_STI:	decode_diadic_parallel_addressing(  op_code, "LDI",    "STI" ); break;
    case OP_LSH3_STI:	decode_triadic_parallel_addressing( op_code, "LSH3",   "STI" ); break;
    case OP_MPYF3_STF:	decode_triadic_parallel_addressing( op_code, "MPYF3",  "STF" ); break;
    case OP_MPYI3_STI:	decode_triadic_parallel_addressing( op_code, "MPYI3",  "STI" ); break;
    case OP_NEGF_STF:	decode_diadic_parallel_addressing(  op_code, "NEGF",   "STF" ); break;
    case OP_NEGI_STI:	decode_diadic_parallel_addressing(  op_code, "NEGI",   "STI" ); break;
    case OP_NOT_STI:	decode_diadic_parallel_addressing(  op_code, "NOT",    "STI" ); break;
    case OP_OR3_STI:	decode_triadic_parallel_addressing( op_code, "OR3",    "STI" ); break;
    case OP_SUBF3_STF:	decode_triadic_parallel_addressing( op_code, "SUBF3",  "STF" ); break;
    case OP_SUBI3_STI:	decode_triadic_parallel_addressing( op_code, "SUBI3",  "STI" ); break;
    case OP_XOR3_STI:	decode_triadic_parallel_addressing( op_code, "XOR3",   "STI" ); break;
    case OP_TOIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "TOIEEE", "STF" ); break;
    case OP_FRIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "FRIEEE", "STF" ); break;
    default:
      break;
    }

  return;

} /* decode_parallel_op */

/*}}}*/
/*{{{  decode_triadic_address */

/*
 * deocdes a 'C40 triadic op code
 */

static void
decode_triadic_address(
		       unsigned long	op_code,	/* instruction to decode 	  */
		       char *		instruction,	/* string identifying the op code */
		       immed_type	type )		/* type of immediate values       */
{
  char *	pdest;
  long int	dest;
  unsigned long	addr;
  unsigned long	src1;
  unsigned long	src2;
  

  /*
   * we have a triaidic op code
   *
   * bits  0 -  7 encode source2
   * bits  8 - 15 encode source1
   * bits 16 - 20 encode destination register
   * bits 21 - 22 encode addessing mode
   * bits 23 - 27 encode op code
   * bit  28      encodes addressing type
   * bits 29 - 31 are 001
   */

  myprint( instruction );

  pad_to( COL_OPERAND );
  
  dest = (op_code >> 16) & 0x1f;

  if (type == TYPE_FLOATING)
    {
      /* the destination (or source) register of a floating point op must be R0 - R11 */

      if (!is_extended_precision_register( dest ))
	{
	  myprint( "R<illegal>," );
	  return;
	}
    }

  pdest = _regname( dest );
  
  /* build combined addressing type */

  addr = (op_code >> 28) & 0x1;

  addr <<= 2;

  addr |= ((op_code >> 21) & 0x3);

  /* extract source fields */
  
  src2 = op_code & 0xff;
  src1 = (op_code >> 8) & 0xff;

  /* and print out result */
  
  switch (addr)
    {
    case B_000:	/* src1 = register, src2 = register */
      
      myprint( "%s, %s, %s",
	      _regname( src2 & 0x3f ),
	      _regname( src1 & 0x3f ),
	      pdest );
      break;

    case B_001: /* src1 = indirect, src2 = register */

      myprint( "%s, ", _regname( src2 & 0x3f ) );
	      
      decode_indirect_address( src1 >> 3, src1 & 7, 1 );

      myprint( ", %s", pdest );
      
      break;
      
    case B_010:	/* src1 = register, src2 = indirect */
      
      decode_indirect_address( src2 >> 3, src2 & 7, 1 );

      myprint( ", %s", _regname( src1 & 0x3f ) );
      
      myprint( ", %s", pdest );
      
      break;

    case B_011:	/* src1 = indirect, src2 = indirect */
      
      decode_indirect_address( src2 >> 3, src2 & 7, 1 );

      myprint( ", " );
      
      decode_indirect_address( src1 >> 3, src1 & 7, 1 );

      myprint( ", %s", pdest );
      
      break;

    case B_100: /* src1 = register, src2 = immediate */
      
      if (type == TYPE_FLOATING)
	{
	  myprint( "triadic floating point immediate operations are impossible" );
	}
      else if (type == TYPE_SIGNED)
	{
	  myprint( "%ld, %s, %s",
		  mask_and_sign_extend_word( op_code, 0xff ),
		  _regname( src1 & 0x3f ),
		  pdest );
	}
      else
	{
	  myprint( "%lx, %s, %s",
		  op_code & 0xff,
		  _regname( src1 & 0x3f ),
		  pdest );
	}
      
      break;
      
    case B_101:	/* src1 = register, src2 = indirect */
      
      myprint( "*+AR%.1ld(%.2lu), %s, %s",
	      src2 & 0x7, (src2 >> 3),
	      _regname( src1 & 0x3f ),
	      pdest );
      break;
      
    case B_110:	/* src1 = indirect, src2 = immediate */
      
      if (type == TYPE_FLOATING)
	{
	  myprint( "triadic floating point immediate operations are impossible" );
	}
      else if (type == TYPE_SIGNED)
	{
	  myprint( "%ld, *+AR%.1ld(%.2lu), %s",
		  mask_and_sign_extend_word( op_code, 0xff ),
		  src1 & 0x7, (src1 >> 3),
		  pdest );
	}
      else
	{
	  myprint( "%#lx, *+AR%.1ld(%.2lu), %s",
		  op_code & 0xff,
		  src1 & 0x7, (src1 >> 3),
		  pdest );
	}

      break;
      
    case B_111:	/* src1 = indirect, src2 = indirect */
      
      myprint( "*+AR%.1ld(%.2lu), *+AR%.1ld(%.2lu), %s",
	      src2 & 0x7, (src2 >> 3),
	      src1 & 0x7,(src1 >> 3),
	      pdest );
      break;
      
    default:
      break;
    }

  return;
  
} /* decode_triadic_address */

/*}}}*/
/*{{{  decode_monadic_op */

static void
decode_monadic_op(
		  unsigned long	op_code,
		  char *	instruction )
{
  myprint( instruction );
  
  pad_to( COL_OPERAND );

  myprint( "%s", _regname( (op_code >> 16) & 0x1f ) );

  return;
  
} /* decode_monadic_op */

/*}}}*/
/*{{{  decode_sequential_op */

static void
decode_sequential_op( unsigned long	op_code )	/* instruction to decode */
{
  /*
   * bit  29      encodes diadic or triadic style op codes
   * bits 30 - 31 are 00
   */
  
  if (op_code & 0x20000000L)
    {
      /*
       * triaidic op code
       *
       * bits 23 - 27 encode op code
       * bit  28      encodes addressing type
       * bits 29 - 31 are 001
       */

      switch ((op_code >> 23) & 0x1f)
	{
	case OP_ADDC3:	decode_triadic_address( op_code, "ADDC3"   , TYPE_SIGNED   ); return;
	case OP_ADDF3:	decode_triadic_address( op_code, "ADDF3"   , TYPE_FLOATING ); return;
	case OP_ADDI3:	decode_triadic_address( op_code, "ADDI3"   , TYPE_SIGNED   ); return;
	case OP_AND3:	decode_triadic_address( op_code, "AND3"    , TYPE_UNSIGNED ); return;
	case OP_ANDN3:	decode_triadic_address( op_code, "ANDN3"   , TYPE_UNSIGNED ); return;
	case OP_ASH3:	decode_triadic_address( op_code, "ASH3"    , TYPE_SIGNED   ); return;
	case OP_CMPF3:	decode_triadic_address( op_code, "CMPF3"   , TYPE_FLOATING ); return;
	case OP_CMPI3:	decode_triadic_address( op_code, "CMPI3"   , TYPE_SIGNED   ); return;
	case OP_LSH3:	decode_triadic_address( op_code, "LSH3"    , TYPE_SIGNED   ); return;
	case OP_MPYF3:	decode_triadic_address( op_code, "MPYF3"   , TYPE_FLOATING ); return;
	case OP_MPYI3:	decode_triadic_address( op_code, "MPYI3"   , TYPE_SIGNED   ); return;
	case OP_OR3:	decode_triadic_address( op_code, "OR3"     , TYPE_UNSIGNED ); return;
	case OP_SUBB3:	decode_triadic_address( op_code, "SUBB3"   , TYPE_SIGNED   ); return;
	case OP_SUBF3:	decode_triadic_address( op_code, "SUBF3"   , TYPE_FLOATING ); return;
	case OP_SUBI3:	decode_triadic_address( op_code, "SUBI3"   , TYPE_SIGNED   ); return;
	case OP_TSTB3:	decode_triadic_address( op_code, "TSTB3"   , TYPE_UNSIGNED ); return;
	case OP_XOR3:	decode_triadic_address( op_code, "XOR3"    , TYPE_UNSIGNED ); return;
	case OP_MPYSHI3:decode_triadic_address( op_code, "MPYSHI3" , TYPE_SIGNED   ); return;
	case OP_MPYUHI3:decode_triadic_address( op_code, "MPYUHI3" , TYPE_UNSIGNED ); return;
	default:
	  return;
	}
    }
  else
    {
      /*
       * diaidic op code
       *
       * bits 23 - 28 encode op code
       * bits 29 - 31 are 000
       */

      switch (op_code >> 23)
	{
	case OP_ABSF:	decode_diadic_address( op_code, "ABSF"   , TYPE_FLOATING, FALSE ); return;
	case OP_ABSI:	decode_diadic_address( op_code, "ABSI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_ADDC:	decode_diadic_address( op_code, "ADDC"   , TYPE_SIGNED,   FALSE ); return;
	case OP_ADDF:	decode_diadic_address( op_code, "ADDF"   , TYPE_FLOATING, FALSE ); return;
	case OP_ADDI:	decode_diadic_address( op_code, "ADDI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_AND:	decode_diadic_address( op_code, "AND"    , TYPE_UNSIGNED, FALSE ); return;
	case OP_ANDN:	decode_diadic_address( op_code, "ANDN"   , TYPE_UNSIGNED, FALSE ); return;
	case OP_ASH:	decode_diadic_address( op_code, "ASH"    , TYPE_SIGNED,   FALSE ); return;
	case OP_CMPF:	decode_diadic_address( op_code, "CMPF"   , TYPE_FLOATING, FALSE ); return;
	case OP_CMPI:	decode_diadic_address( op_code, "CMPI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_FIX:	decode_diadic_address( op_code, "FIX"    , TYPE_FLOATING, FALSE ); return;
	case OP_FLOAT:	decode_diadic_address( op_code, "FLOAT"  , TYPE_SIGNED,   FALSE ); return;
	case OP_IDLE:	myprint( "IDLE" ); return;
	case OP_LDE:	decode_diadic_address( op_code, "LDE"    , TYPE_FLOATING, FALSE ); return;
	case OP_LDF:	decode_diadic_address( op_code, "LDF"    , TYPE_FLOATING, FALSE ); return;
	case OP_LDFI:	decode_diadic_address( op_code, "LDFI"   , TYPE_FLOATING, FALSE ); return;
	case OP_LDI:	decode_diadic_address( op_code, "LDI"    , TYPE_SIGNED,   FALSE ); return;
	case OP_LDII:	decode_diadic_address( op_code, "LDII"   , TYPE_SIGNED,   FALSE ); return;
	case OP_LDM:	decode_diadic_address( op_code, "LDM"    , TYPE_FLOATING, FALSE ); return;
	case OP_LSH:	decode_diadic_address( op_code, "LSH"    , TYPE_SIGNED,   FALSE ); return;
	case OP_MPYF:	decode_diadic_address( op_code, "MPYF"   , TYPE_FLOATING, FALSE ); return;
	case OP_MPYI:	decode_diadic_address( op_code, "MPYI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_NEGB:	decode_diadic_address( op_code, "NEGB"   , TYPE_SIGNED,   FALSE ); return;
	case OP_NEGF:	decode_diadic_address( op_code, "NEGF"   , TYPE_FLOATING, FALSE ); return;
	case OP_NEGI:	decode_diadic_address( op_code, "NEGI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_NOP:	myprint( "NOP" ); return;	/* XXX - what about indirect addressing modes */
	case OP_NORM:	decode_diadic_address( op_code, "NORM"   , TYPE_FLOATING, FALSE ); return;
	case OP_NOT:	decode_diadic_address( op_code, "NOT"    , TYPE_UNSIGNED, FALSE ); return;
	case OP_POP:	decode_monadic_op(     op_code, "POP"   ); return;
	case OP_POPF:	decode_monadic_op(     op_code, "POPF"  ); return;
	case OP_PUSH:	decode_monadic_op(     op_code, "PUSH"  ); return;
	case OP_PUSHF:	decode_monadic_op(     op_code, "PUSHF" ); return;
	case OP_OR:	decode_diadic_address( op_code, "OR"     , TYPE_UNSIGNED, FALSE ); return;
	case OP_RND:	decode_diadic_address( op_code, "RND"    , TYPE_FLOATING, FALSE ); return;
	case OP_ROL:	decode_monadic_op(     op_code, "ROL"   ); return;
	case OP_ROLC:	decode_monadic_op(     op_code, "ROLC"  ); return;
	case OP_ROR:	decode_monadic_op(     op_code, "ROR"   ); return;
	case OP_RORC:	decode_monadic_op(     op_code, "RORC"  ); return;
	case OP_RPTS:	decode_diadic_address( op_code, "RPTS"   , TYPE_UNSIGNED, FALSE ); return;
	case OP_STF:	decode_diadic_address( op_code, "STF"    , TYPE_FLOATING, TRUE  ); return;
	case OP_STFI:	decode_diadic_address( op_code, "STFI"   , TYPE_FLOATING, TRUE  ); return;
	case OP_STI:	decode_integer_store(  op_code ); return;
	case OP_SIGI:	decode_diadic_address( op_code, "SIGI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_STII:	decode_diadic_address( op_code, "STII"   , TYPE_SIGNED,   TRUE  ); return;
	case OP_SUBB:	decode_diadic_address( op_code, "SUBB"   , TYPE_SIGNED,   FALSE ); return;
	case OP_SUBC:	decode_diadic_address( op_code, "SUBC"   , TYPE_SIGNED,   FALSE ); return;
	case OP_SUBF:	decode_diadic_address( op_code, "SUBF"   , TYPE_FLOATING, FALSE ); return;
	case OP_SUBI:	decode_diadic_address( op_code, "SUBI"   , TYPE_SIGNED,   FALSE ); return;
	case OP_SUBRB:	decode_diadic_address( op_code, "SUBRB"  , TYPE_SIGNED,   FALSE ); return;
	case OP_SUBRF:	decode_diadic_address( op_code, "SUBRF"  , TYPE_FLOATING, FALSE ); return;
	case OP_SUBRI:	decode_diadic_address( op_code, "SUBRI"  , TYPE_SIGNED,   FALSE ); return;
	case OP_TSTB:	decode_diadic_address( op_code, "TSTB"   , TYPE_UNSIGNED, FALSE ); return;
	case OP_XOR:	decode_diadic_address( op_code, "XOR"    , TYPE_UNSIGNED, FALSE ); return;
	case OP_IACK:	decode_diadic_address( op_code, "IACK"   , TYPE_UNSIGNED, FALSE ); return;
	case OP_TOIEEE:	decode_diadic_address( op_code, "TOIEEE" , TYPE_FLOATING, FALSE ); return;
	case OP_FRIEEE:	decode_diadic_address( op_code, "FRIEEE" , TYPE_FLOATING, FALSE ); return;
	case OP_RSQRF:	decode_diadic_address( op_code, "RSQRF"  , TYPE_FLOATING, FALSE ); return;
	case OP_RCPF:	decode_diadic_address( op_code, "RCPF"   , TYPE_FLOATING, FALSE ); return;
	case OP_MPYSHI:	decode_diadic_address( op_code, "MPYSHI" , TYPE_SIGNED,   FALSE ); return;
	case OP_MPYUHI:	decode_diadic_address( op_code, "MPYUHI" , TYPE_UNSIGNED, FALSE ); return;
	case OP_LDA:	decode_diadic_address( op_code, "LDA"    , TYPE_SIGNED,   FALSE ); return;
	case OP_LDPK:	decode_diadic_address( op_code, "LDPK"   , TYPE_SIGNED,   FALSE ); return;
	case OP_LDHI:	decode_diadic_address( op_code, "LDHI"   , TYPE_UNSIGNED, FALSE ); return;
	default:
	  return;
	}
    }
  
  return;
  
} /* decode_sequential_op */

/*}}}*/
/*{{{  decode */

static void
decode( unsigned long op_code )	/* instruction to decode */
{
  /*
   * bits 30 and 31 encode instruction type
   */

  switch ((op_code >> 30) & 0x3)
    {
    default:
    case 0: decode_sequential_op(            op_code ); return;
    case 1: decode_flow_control(             op_code ); return;
    case 2: decode_non_word_load_or_triadic( op_code ); return;
    case 3: decode_parallel_op(              op_code ); return;
    }

} /* decode */

/*}}}*/

/*}}}*/

/*}}}*/
/*{{{  Control Functions */

/*{{{  Variables */

static List branch_trace;		/* linked list of branch_ref structures */
static List func_trace;			/* linked list of function headers      */

/*}}}*/
/*{{{  Types */

typedef struct branch_ref
  {
    Node		node;			/* link into branch trace list       */
    unsigned long int	address_refered_to;	/* address to which a branch will go */
    unsigned long int	address_of_refer;	/* address of branch instruction     */
  }
branch_ref;

typedef struct func_ref
  {
    Node		node;			/* link into function header list         */
    unsigned long int	address_of_name;	/* word address of start of function name */
    unsigned long int	length_of_name;		/* byte length of function name           */
  }
func_ref;

/*}}}*/
/*{{{  Functions */

/*{{{  print_byte */

static void
print_byte( long int value )
{
  if (value < 0)
    value = -value;

  value &= 0xff;

  if (value == '\n')
    {
      myprint( "\\n " );
    }
  else if (value == '\t')
    {
      myprint( "\\t " );
    }
  else if (value == '\v')
    {
      myprint( "\\v " );
    }
  else if (value == '\f')
    {
      myprint( "\\f " );
    }
  else if (value >= ' ' && value <= '~' )
    {
      myprint( " %c ", (char)value );
    }
  else
    {
      myprint( "..." );
    }

  return;
  
} /* print_byte */
  

/*}}}*/
/*{{{  is_branch */

/*
 * returns non-zero if the instruction is a branch instruction, 0 otherwise
 */

static signed long int
is_branch( unsigned long instruction )
{
  if (((instruction >> 24) & 0xffL) == B_01101010)
    {
      if (((instruction >> 21) & 0x7L) == B_000)
	{
	  return 1L + mask_and_sign_extend_word( instruction, 0xffffL );
	}
      else
	{
	  return 3L + mask_and_sign_extend_word( instruction, 0xffffL );
	}
    }

  if (((instruction >> 26) & 0x3fL) == B_011000)
    {
      if (instruction & (0x1 << 24))
	{
	  return 3L + mask_and_sign_extend_word( instruction, 0xffffffL );
	}
      else
	{
	  return 1L + mask_and_sign_extend_word( instruction, 0xffffffL );
	}
    }

  return 0L;
  
} /* is_branch */

/*}}}*/
/*{{{  check_node */

/*
 * returs TRUE if the address refered to in
 * the node is earlier in memory than arg
 */

static bool
check_node(
	   Node *	pnode,
	   int		arg )
{
  return (((branch_ref *)pnode)->address_refered_to > arg);

} /* check_node */
  

/*}}}*/
/*{{{  store_func_ref */

/*
 * add an entry to the function header list
 */

static void
store_func_ref(
	       unsigned long int	address,
	       unsigned long int	length )
{
  func_ref *	pref;


  pref = (func_ref *)malloc( sizeof( *pref ) );

  if (pref == NULL)
    {
      inform( "out of memory allocating function reference" );

      return;
    }

  pref->address_of_name = address;
  pref->length_of_name  = length;

  add_tail( &func_trace, &pref->node );
  
  return;
  
} /* store_func_ref */

/*}}}*/
/*{{{  store_branch */

  
/*
 * add an entry to the branch reference list
 */

static void
store_branch(
	     unsigned long int	address,
	     signed long int	offset )
{
  Node *	pprev;
  branch_ref *	pref;


  pref = (branch_ref *)malloc( sizeof( *pref ) );

  if (pref == NULL)
    {
      inform( "out of memory allocating branch list" );

      return;
    }

  pref->address_of_refer   = word_address;
  pref->address_refered_to = word_address + offset;

  pprev = search_list( &branch_trace, check_node, word_address + offset );

  if (pprev)
    {
      pre_insert( pprev, &pref->node );
    }
  else
    {
      add_tail( &branch_trace, &pref->node );
    }
  
  return;
  
} /* store branch */

/*}}}*/
/*{{{  read_word */

  
static bool
read_word(
	  unsigned int long *	destination,
	  FILE *		input )
{
  unsigned char	val;
  long int	tmp;
  

  if (fread( &val, 1, 1, input ) != 1)
    {
      return FALSE;
    }

  tmp = val;

  if (fread( &val, 1, 1, input ) != 1)
    {
      return FALSE;
    }

  tmp |= (((unsigned long int)val) << 8);
  
  if (fread( &val, 1, 1, input ) != 1)
    {
      return FALSE;
    }

  tmp |= (((unsigned long int)val) << 16);
  
  if (fread( &val, 1, 1, input ) != 1)
    {
      return FALSE;
    }

  *destination = tmp | (((unsigned long int)val) << 24);

  return TRUE;
  
} /* read_word */
  

/*}}}*/
/*{{{  load_trace_data */

  
/*
 * get the information needed by the branch tracing code
 * returns TRUE upon success, FALSE otherwise
 */

static bool
load_trace_data( FILE * input )
{
  unsigned long int	value;

  
  if (fseek( input, 0L, SEEK_SET ) != 0)
    {
      extern int errno;

      
      inform( "failed to rewind input, errno = %d", errno );

      return FALSE;
    }
  
  word_address = 0;

  init_list( &branch_trace );
  init_list( &func_trace   );
  
  while (read_word( &value, input ))
    {
      signed long int	offset;


      if ((value & 0xFFFFFF00U) == 0xFF000000U)
	{
	  /* we have found a start of function marker */
	  
	  offset = value & 0xFF;
	  offset /= sizeof (int);

	  /* function name starts at 'word_address - offset' */

	  store_func_ref( word_address - offset, offset );
	}
      
      if ((offset = is_branch( value )) != 0)
	{
	  store_branch( word_address, offset );
	}

      word_address++;
    }

  return TRUE;
  
} /* load_trace_data */

/*}}}*/
/*{{{  ti_disassemble */

static void
ti_disassemble( FILE * input )	/* file containing binary image */
{
  unsigned long int	value;
  int			i;
  
  
  /* nothing fancy - just turn into .word directives! */

  if (input == NULL)
    return;

  if ( output_file      == NULL  ||
      *output_file      == '\0'  ||
      (output_file[ 0 ] == '-'  &&
       output_file[ 1 ] == '\0' ) )
    {
      output = stdout;
    }
  else
    {
      output = fopen( (char *)output_file, "w" );

      if (output == NULL)
	{
	  inform( "could not open output file '%s' - using stdout instead", output_file );

	  output = stdout;	  
	}      
    }
  
  /* skip image header - we do not need it */
  
  for (i = 0; i < sizeof (ImageHdr) / sizeof (unsigned long); i++)
    read_word( &value, input );

  /* decode rest of file */
  
  while (read_word( &value, input ))
    {
      myprint( " .word 0%lxH", value );
      
      new_line();
    }

  myprint( ".end:" );

  new_line();
  
  return;
  

} /* ti_disassemble */

/*}}}*/
/*{{{  disassemble */

static void
disassemble(
	    FILE *	input,		/* file containing binary op-codes */
	    bool	trace,		/* TRUE if branches are to be traced to their destinations */
	    bool	helios_format )	/* TRUE if the input is in Helios Linker format */
{
  unsigned long int	value;
  branch_ref *		pnext_branch;
  func_ref *		pnext_func;
  bool			show_code;
  long int		name_len      = 0;
  char *		func_name     = NULL;
  

  if (input == NULL)
    return;

  if ( output_file      == NULL  ||
      *output_file      == '\0'  ||
      (output_file[ 0 ] == '-'  &&
       output_file[ 1 ] == '\0' ) )
    {
      output = stdout;
    }
  else
    {
      output = fopen( (char *)output_file, "w" );

      if (output == NULL)
	{
	  inform( "could not open output file '%s' - using stdout instead", output_file );

	  output = stdout;	  
	}      
    }
  
  if (input == stdin)
    trace = FALSE;

  if (helios_format)
    show_code = FALSE;
  else
    show_code = TRUE;
  
  if (trace)
    {
      trace = load_trace_data( input );
    }

  (void) fseek( input, 0L, SEEK_SET );
  
  word_address = 0;

  if (trace)
    {
      pnext_branch = (branch_ref *)remove_head( &branch_trace );
      pnext_func   =   (func_ref *)remove_head( &func_trace   );

      if (pnext_func)
	{
	  name_len = pnext_func->length_of_name;

	  func_name = (char *)malloc( (int)(name_len * sizeof (long) + 5) );

	  if (func_name == NULL)
	    {
	      inform( "out of memory allocating buffer for function name" );

	      name_len = 0;
	    }
	}
    }
  else
    {
      pnext_branch = NULL;
      pnext_func   = NULL;
    }
  
  while (read_word( &value, input ))
    {
      if (value == T_Module)
	{
	  int	i;

	  
	  /* we have the start of a module header */

	  for (i = sizeof (Module) / sizeof (unsigned long); i--; )
	    {
	      myprint( "%8lx", word_address + address_base );
	      
	      pad_to( COL_WORD );
	      
	      myprint( "0x%08.8lx ", value );
	      
	      pad_to( COL_BYTES );
	      
	      print_byte( value );
	      print_byte( value >>  8 );	
	      print_byte( value >> 16 );
	      print_byte( value >> 24 );
	      
	      new_line();
	      
	      word_address++;
	      
	      if (!read_word( &value, input ))
		break;
	    }
	}
      
      myprint( "%8lx", word_address + address_base );

      pad_to( COL_WORD );
      
      myprint( "0x%08.8lx ", value );

      if (helios_format && ((value & 0xFFFFFF00U) == 0xFF000000U))
	{
	  if (func_name)
	    {
	      pad_to( COL_OP_CODE );

	      myprint( "%s():", func_name );

	      free( func_name );

	      func_name = NULL;
	      name_len  = 0;
	    }

	  show_code = TRUE;

	  value = 0;
	}

      if (helios_format && pnext_func && word_address == pnext_func->address_of_name)
	{
	  show_code = FALSE;
	  name_len  = pnext_func->length_of_name;
	  
	  free( pnext_func );

	  pnext_func = (func_ref *)remove_head( &func_trace );
	  
	  func_name  = (char *)malloc( (int)(name_len * sizeof (long) + 5 ) );

	  if (func_name == NULL)
	    {
	      inform( "out of memory allocating buffer for function name" );
	      
	      name_len = 0;
	    }
	  else
	    {
	      func_name[ 0 ] = '\0';
	    }
	}

      if (!helios_format || value > 10)
	{
	  pad_to( COL_BYTES );
      
	  print_byte( value );
	  print_byte( value >>  8 );	
	  print_byte( value >> 16 );
	  print_byte( value >> 24 );

	  pad_to( COL_OP_CODE );
	  
	  if (show_code)
	    {
	      decode( value );
	    }
	}

      if (name_len > 0 && func_name)
	{
	  int 	i = strlen( func_name );

	  
	  func_name[ i++ ] = (char)( value        & 0xff);
	  func_name[ i++ ] = (char)((value >>  8) & 0xff);
	  func_name[ i++ ] = (char)((value >> 16) & 0xff);
	  func_name[ i++ ] = (char)((value >> 24) & 0xff);
	  func_name[ i++ ] = '\0';

	  --name_len;
	}

      if (trace && pnext_branch && word_address == pnext_branch->address_refered_to)
	{
	  pad_to( COL_TRACE );

	  myprint( "branched from: " );

	  while (pnext_branch->address_refered_to == word_address)
	    {
	      myprint( "%lx ", pnext_branch->address_of_refer + address_base );

	      free( pnext_branch );

	      pnext_branch = (branch_ref *)remove_head( &branch_trace );
	    }
	}

      new_line();
      
      fflush( output );

      word_address++;
    }

  return;
  
} /* disassemble */

/*}}}*/
/*{{{  usage */

/*
 * describe the command line options
 */

static void
usage( void )
{
  inform( "valid command line options:" );
  inform( "-b        enable  branch tracing" );
  inform( "-B        disable branch tracing (the default)" );
  inform( "-t        produce output compatible with the TI assembler" );
  inform( "-T        produce verbose output (the default)" );
  inform( "-h        assume input is in Generic Helios Executable Format (the default)" );
  inform( "-H        do not make such an assumption" );
  inform( "-p        display PCS register aliases" );
  inform( "-o <file> send output to the named file" );  
  inform( "-help     this message" );
  inform( "-?        this message" );
  inform( "+<offset> addition to current offset for instruction addresses" );
  inform( "-         disassemble from stdin (default)" );
  inform( "<file>    disassemble <file>" );
  inform( "--        treat all futher command line options as file names to disassemble" );
  
  exit( 0 );
  
} /* usage */

/*}}}*/
/*{{{  main */

/*
 * disassembler entry point
 */
  
int
main(
     int		argc,
     unsigned char **	argv )
{
  bool		helios_format = TRUE;
  bool		trace         = FALSE;
  bool		ti_format     = FALSE;
  FILE *	input	      = NULL;


  /* find name of program */
  
  if ((ProgName = (unsigned char *)strrchr( (const char *)argv[ 0 ], '/' )) != NULL)
    {
      ProgName++;
    }
  else
    {
      ProgName = argv[ 0 ];
    }

  /*
   * parse command line arguments
   *
   * what we want to achieve is this:
   *
   * disas fred			- disassembles file 'fred' in Helios format
   * disas -t fred		- disassembles file 'fred' in TI format
   * disas fred -t		- disassembles file 'fred' in TI format
   * disas fred -t jim		- disassembles file 'fred' in Helios format and file 'jim' in TI format
   * disas fred jim -t		- disassembles files 'fred' and 'jim' in TI format
   * disas -t fred jim		- disassembles files 'fred' and 'jim' in TI format
   * disas -t fred -T jim	- disaeembles file 'fred' in TI format, file 'jim' in Helios format
   * disas -t fred -T jim -t	- illegal
   *
   * yeah!
   *
   */
   
  if (argc > 1)
    {
      int	arg;
      int	found_switch = -1;


      /*
       * pre-scan arguments for the special case where we have
       * one or more files followed by switches but then no more
       * files ...
       */
      

      for (arg = 1; arg < argc; arg++)
	{
	  if (argv[ arg ][ 0 ] == '-'  &&
	      argv[ arg ][ 1 ] != '\0' &&
	      found_switch     == -1    )
	    {
	      found_switch = arg;
	    }
	  else if (found_switch != -1)
	    {
	      if (arg > 1                     &&
		  argv[ arg - 1 ][ 0 ] == '-' &&
		  argv[ arg - 1 ][ 1 ] == 'o' &&
		  argv[ arg - 1 ][ 2 ] == '\0' )
		{
		  /* catch the very special cases of -o <name> */
		  
		  continue;		  
		}
	      
	      if (arg > 1                     &&
		  argv[ arg - 1 ][ 0 ] == '+' &&
		  argv[ arg - 1 ][ 1 ] == '\0' )
		{
		  /* catch the very special cases of + <offset> */
		  
		  continue;		  
		}
	      
	      /* we have a switch followed by a file name - special case does not apply */

	      found_switch = -1;
	      
	      break;
	    }
	}

      if (found_switch != -1)
	{
	  /* yup special case applies */

	  for (arg = found_switch; arg < argc; arg++ )
	    {
	      if (argv[ arg ][ 0 ] == '+')
		{
		  long int	off = 0;
		      

		  if (argv[ arg ][ 1 ] == '\0')
		    {
		      if (++arg >= argc)
			{
			  inform( "warning - no value following '+' option; option has been ignored" );
			}
		      else
			{
			  if (argv[ arg ][ 1 ] == 'x' || argv[ arg ][ 1 ] == 'X')
			    off = strtoul( (char *)argv[ arg ], (char **)(&argv[ arg ]), 16 );
			  else
			    off = atoi( (char *)argv[ arg ] );

			  if (off == 0)
			    {
			      inform( "warning - no value following '+' option; option has been ignored" );
			  
			      --arg;
			    }
			} 
		    }
		  else
		    {
		      if (argv[ arg ][ 2 ] == 'x' || argv[ arg ][ 2 ] == 'X')
			off = strtoul( (char *)argv[ arg ], (char **)(&argv[ arg ]), 16 );
		      else
			off = atoi( (char *)argv[ arg ] );
		      
		      if (off == 0)
			inform( "warning - string following '+' option is not a number; option has been ignored" );		  
		    }
	      
		  address_base += off;		      
		}
	      else
		{
		  switch (argv[ arg ][ 1 ])
		    {
		    case 'o':
		      if (argv[ arg ][ 2 ] == '\0')
			{
			  if (++arg >= argc)
			    {
			      inform( "no name following '-o' option" );
			      
			      return EXIT_FAILURE;
			    }
			  
			  output_file = argv[ arg ];
			}
		      else
			{
			  output_file = argv[ arg ] + 2;		      
			}
		      
		      break;
		      
		    case 'H':
		      helios_format = FALSE;
		      break;
		      
		    case 'h':
		      if (argv[ arg ][ 2 ] == '\0')
			{
			  helios_format = TRUE;
			  break;
			}
		      
		      /* drop through */
		      
		    case '?':
		      break;
		      
		    case 'T':
		      ti_format = FALSE;
		      break;
		      
		    case 't':
		      ti_format = TRUE;
		      break;
		      
		    case 'b':
		      trace = TRUE;
		      break;
		      
		    case 'B':
		      trace = FALSE;
		      break;
		    }
		}	      
	    }
	}
      
      for (arg = 1; arg < argc; arg++)
	{
	  if (argv[ arg ][ 0 ] == '-')
	    {
	      long int	next_arg = TRUE;

	      
	      switch (argv[ arg ][ 1 ])
		{
		case 'o':
		  if (argv[ arg ][ 2 ] == '\0')
		    {
		      if (++arg >= argc)
			{
			  inform( "no name following '-o' option" );

			  return EXIT_FAILURE;
			}		      
		      
		      output_file = argv[ arg ];
		    }
		  else
		    {
		      output_file = argv[ arg ] + 2;		      
		    }
		  break;
		  
		case 'H':
		  helios_format = FALSE;
		  break;
		  
		case 'h':
		  if (argv[ arg ][ 2 ] == '\0')
		    {
		      helios_format = TRUE;
		      break;
		    }
		  
		  /* drop through */
		    
		case '?':
		  usage();
		  break;
		  
		case '\0':
		  input    = stdin;
		  next_arg = FALSE;
		  break;

		case 'T':
		  ti_format = FALSE;
		  break;

		case 't':
		  ti_format = TRUE;
		  break;

		case 'b':
		  trace = TRUE;
		  break;

		case 'B':
		  trace = FALSE;
		  break;

		case 'p':
		  pcsregs = TRUE;
		  break;

		case '-':
		  while (++arg < argc)
		    {
		      input = fopen( (char *)argv[ arg ], "rb" );

		      if (input == NULL)
			{
			  inform( "could not open input file '%s' - skipping", argv[ arg ] );
			}
		      else if (ti_format)
			{
			  ti_disassemble( input );
			}
		      else
			{
			  disassemble( input, trace, helios_format );
			}

		      if (input)
			fclose( input );
		    }
		  
		  break;

		default:
		  inform( "unknown command line option '%c'", argv[ arg ][ 1 ] );
		  usage();
		  break;
		}

	      if (next_arg)
		continue;
	    }
	  else if (argv[ arg ][ 0 ] == '+')
	    {
	      unsigned long int	off = 0;
		      

	      if (argv[ arg ][ 1 ] == '\0')
		{
		  if (++arg >= argc)
		    {
		      inform( "warning - no value following '+' option; option has been ignored" );
		    }
		  else
		    {
		      if (argv[ arg ][ 1 ] == 'x' || argv[ arg ][ 1 ] == 'X')
			off = strtoul( (char *)argv[ arg ], (char **)(&argv[ arg ]), 16 );
		      else
			off = (unsigned long int)atoi( (char *)argv[ arg ] );
		      
		      if (off == 0)
			{
			  inform( "warning - no value following '+' option; option has been ignored" );
			  
			  --arg;
			}
		    } 
		}
	      else
		{
		  if (argv[ arg ][ 2 ] == 'x' || argv[ arg ][ 2 ] == 'X')
		    off = strtoul( (char *)argv[ arg ], (char **)(&argv[ arg ]), 16 );
		  else
		    off = (unsigned long int)atoi( (char *)argv[ arg ] );
		      
		  if (off == 0)
		    inform( "warning - string following '+' option is not a number; option has been ignored" );		  
		}
	      
	      address_base += off;		      
	    }	  
	  else
	    {
	      input = fopen( (char *)argv[ arg ], "rb" );

	      if (input == NULL)
		{
		  inform( "could not open input file %s - using stdin instead", argv[ arg ] );

		  /* possible bug - stdin may have been opened in text mode */
		  
		  input = stdin;
		}
	    }

	  if (ti_format)
	    ti_disassemble( input );
	  else	  
	    disassemble( input, trace, helios_format );

	  if (input != stdin)
	    {
	      fclose( input );

	      input = NULL;
	    }
	}
    }
  else
    { 
      /* possible bug - stdin may have been opened in text mode */

      if (ti_format)
	ti_disassemble( stdin );
      else
	disassemble( stdin, trace, helios_format );
    }

  return EXIT_SUCCESS;
  
} /* main */

/*}}}*/

/*}}}*/

/*}}}*/
/*{{{  SUN4 Routines */

#ifdef SUN4
/*
 * The gcc compiler appears to generate references to the following functions
 * without providing them in a standard library.  Since the code for the
 * linker does not use either of them, they are provided here as stubs
 */

int ___assert( void ) { return 0; }
int ___typeof( void ) { return 0; }  

#endif /* SUN4 */

/*}}}*/

/*}}}*/
@


1.29
log
@added folding
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.28 $
 * Date:	$Date: 1993/08/04 10:41:40 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.28 1993/08/04 10:41:40 nickc Exp nickc $
d26 1
d28 2
d31 2
@


1.28
log
@fixed decoding of conditional LAJ insrtuctions
@
text
@d4 1
a4 1
 * Copyright (c) 1992 Perihelion Software Ltd.
d8 3
a10 3
 * Version:	$Revision: 1.27 $
 * Date:	$Date: 1993/07/12 15:43:51 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.27 1993/07/12 15:43:51 nickc Exp nickc $
d13 2
d31 3
d42 3
d79 3
d91 7
d139 2
d202 2
d232 2
d249 5
a253 1
  
d259 1
d276 2
d279 2
d305 2
d323 2
d344 2
d365 2
d393 6
d404 2
d423 4
d476 2
d502 2
d567 1
a567 1
#ifdef HP
d606 2
d791 2
d892 3
d1302 2
d1416 2
d1571 2
d1595 2
d1658 4
d1729 4
d1913 2
d2091 2
d2109 3
a2111 1
  
d2238 2
d2259 35
d2333 2
d2371 2
a2372 13

static List branch_trace;		/* linked list of branch_ref structures */
static List func_trace;			/* linked list of function headers      */


typedef struct branch_ref
  {
    Node		node;			/* link into branch trace list       */
    unsigned long int	address_refered_to;	/* address to which a branch will go */
    unsigned long int	address_of_refer;	/* address of branch instruction     */
  }
branch_ref;

a2373 9
typedef struct func_ref
  {
    Node		node;			/* link into function header list         */
    unsigned long int	address_of_name;	/* word address of start of function name */
    unsigned long int	length_of_name;		/* byte length of function name           */
  }
func_ref;


d2389 3
d2422 3
d2466 3
d2511 4
d2571 2
d2628 2
d2848 2
d2878 2
d3261 7
d3279 4
@


1.27
log
@fixed compile time warning
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.26 $
 * Date:	$Date: 1993/01/15 14:22:40 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.26 1993/01/15 14:22:40 nick Exp nickc $
d1035 5
a1039 1
		      myprint( "L%ld", word_address + op_code );
@


1.26
log
@Naughty use of absolute path names for include files fixed.
Redefinition of abs() macro remove for RS6000.
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.25 $
 * Date:	$Date: 1992/12/16 19:11:51 $
 * Header:	$Header: /giga/HeliosRoot/Helios/cmds/linker/RCS/c40disas.c,v 1.25 1992/12/16 19:11:51 nickc Exp nick $
d622 1
a622 1
	  !is_extended_precision_register( op_code )))
@


1.25
log
@fixed output speed
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.24 $
 * Date:	$Date: 1992/12/08 09:49:37 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.24 1992/12/08 09:49:37 nickc Exp nickc $
d19 2
a20 2
#include </hsrc/include/helios.h>
#include </hsrc/include/module.h>
d67 1
d69 1
@


1.24
log
@fixed compile time warnings
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.23 $
 * Date:	$Date: 1992/09/14 09:05:01 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.23 1992/09/14 09:05:01 nickc Exp nickc $
d96 1
d100 1
d109 1
d111 1
d141 1
d145 1
d166 1
d168 1
@


1.23
log
@fixed for Sparc compilation
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.22 $
 * Date:	$Date: 1992/09/04 14:35:10 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.22 1992/09/04 14:35:10 paul Exp nickc $
d1046 1
a1046 1
		  long int	offset;
d1095 1
a1095 1
		  long int	offset;
d1153 1
a1153 1
	      long int	offset;
d1377 1
d2753 1
a2753 1
  FILE *	input;
d2843 1
a2843 1
		  int	off = 0;
d3043 1
a3043 1
	      int	off = 0;
d3057 1
a3057 1
			off = atoi( (char *)argv[ arg ] );
d3072 1
a3072 1
		    off = atoi( (char *)argv[ arg ] );
@


1.22
log
@added -p option to display PCS register aliases
@
text
@d9 2
a10 2
 * Date:	$Date: 1992/08/24 17:13:30 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.22 1992/08/24 17:13:30 nickc Exp $
d19 2
a20 2
#include </helios/include/helios.h>
#include </helios/include/module.h>
d22 7
d3119 12
@


1.21
log
@oops, fixed previous delta
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.20 $
 * Date:	$Date: 1992/07/28 09:15:48 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.20 1992/07/28 09:15:48 nickc Exp nickc $
d69 1
d399 1
a399 1
      myprint( "<unknown>" );
d1110 1
a1110 1
		    case B_010: myprint( "<bad op>" ); return;
d1112 1
a1112 1
		    case B_100:	myprint( "<bad op>" ); return;
d1114 2
a1115 2
		    case B_110:	myprint( "<bad op>" ); return;
		    case B_111:	myprint( "<bad op>" ); return;
a1321 1
      myprint( "<bad op>" );
d1496 1
a1496 1
    default:	myprint( "<bad op>" ); break;
a1600 1
      myprint( "<bad op>" );
d1666 1
a1666 1
	  myprint( "<illegal field>" ); return;
d1696 1
a1696 1
	  myprint( "<illegal field>" ); return;
d1726 1
a1726 1
	  myprint( "<illegal field>" ); return;
d1756 1
a1756 1
	  myprint( "<illegal field>" ); return;
a1803 1
      myprint( "<bad op>" );
a1979 1
      myprint( "<bad op>" );
d2044 1
a2044 1
	  myprint( "<unknown>" ); return;
d2122 1
a2122 1
	  myprint( "<bad op>" ); return;
d2719 1
d2994 4
@


1.20
log
@fixed convertion of short floating point values
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.19 $
 * Date:	$Date: 1992/07/16 10:56:52 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.19 1992/07/16 10:56:52 nickc Exp nickc $
d492 1
a492 1
#ifdef __HELIOSC40
a493 6
  /* convert to C40 single precision */
  
  converter.l = (e << 24) | (s << (23 - 11)) | (f << (22 - 10));
  
#else

d513 6
@


1.19
log
@re-enabled automatic decoding of branches
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.18 $
 * Date:	$Date: 1992/07/16 10:52:42 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.18 1992/07/16 10:52:42 nickc Exp nickc $
d492 1
a492 1
#ifdef __C40
@


1.18
log
@removed extraneous debugging messages
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.17 $
 * Date:	$Date: 1992/07/16 09:47:52 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.17 1992/07/16 09:47:52 nickc Exp nickc $
d818 1
a818 3
decode_flow_control(
		    unsigned long	op_code,	/* the instruction to decode */
		    bool		trace )		/* non-zero if tracing information is required */
d1135 1
a1135 2
		      if (trace)
			myprint( "(branch to %lx)", dest + address_base );
d1171 1
a1171 2
	      if (trace)
		myprint( "(branch to %lx)", op_code + offset + word_address + address_base );
d2135 1
a2135 3
decode(
       unsigned long	op_code,	/* instruction to decode */
       bool		trace )		/* non-zero if tracing information isrequired */
d2144 4
a2147 4
    case 0: decode_sequential_op(            op_code        ); return;
    case 1: decode_flow_control(             op_code, trace ); return;
    case 2: decode_non_word_load_or_triadic( op_code        ); return;
    case 3: decode_parallel_op(              op_code        ); return;
d2662 1
a2662 1
	      decode( value, trace );
@


1.17
log
@fixed output spacing and remove spurious trace output
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.16 $
 * Date:	$Date: 1992/07/16 09:19:39 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.16 1992/07/16 09:19:39 nickc Exp nickc $
a2512 2
  inform( "TRACE = %d", trace );
  
a2541 2
      inform ( " trace => %d <=", trace );
      
a2543 1
  else inform (" NO TRACE" );  
a3089 2
	  inform( "trace = %d", trace );
	  
@


1.16
log
@fixed decoding of + option
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.15 $
 * Date:	$Date: 1992/07/16 09:07:49 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.15 1992/07/16 09:07:49 nickc Exp nickc $
d39 1
a39 1
 * AAAA WWWWWWWW BBBB OOOOO PPPPPPPPPPPP DDDDDD TTTTTTT
d53 6
a58 6
#define COL_WORD	5
#define COL_BYTES	17
#define COL_OP_CODE	31
#define COL_OPERAND	37
#define COL_DESTINATION	52
#define COL_TRACE	69
d818 3
a820 1
decode_flow_control( unsigned long op_code )	/* the instruction to decode */
d1137 2
a1138 1
		      myprint( "(branch to %ld)", dest );
d1174 2
a1175 1
	      myprint( "(branch to %ld)", op_code + offset + word_address );
d2139 3
a2141 1
decode( unsigned long	op_code )	/* instruction to decode */
d2150 4
a2153 4
    case 0: decode_sequential_op(            op_code ); return;
    case 1: decode_flow_control(             op_code ); return;
    case 2: decode_non_word_load_or_triadic( op_code ); return;
    case 3: decode_parallel_op(              op_code ); return;
d2512 2
d2544 2
d2548 1
d2673 1
a2673 1
	      decode( value );
d2699 1
a2699 1
	      myprint( "%lx ", pnext_branch->address_of_refer );
d2728 1
a2728 1
  inform( "-B	     disable branch tracing (the default)" );
d3095 2
@


1.15
log
@added + <offset> option
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.14 $
 * Date:	$Date: 1992/07/07 13:47:17 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.14 1992/07/07 13:47:17 nickc Exp nickc $
d2848 4
a2851 1
			  off = atoi( (char *)argv[ arg ] );
d2863 5
a2867 2
		      off = atoi( (char*)(argv[ arg ] + 2) );
		  
d3044 5
a3048 2
		      off = atoi( (char *)argv[ arg ] );

d3059 5
a3063 2
		  off = atoi( (char *)(argv[ arg ] + 2) );
		  
@


1.14
log
@added -o option
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.13 $
 * Date:	$Date: 1992/06/16 08:52:08 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.13 1992/06/16 08:52:08 nickc Exp nickc $
d64 2
d2579 1
a2579 1
	      myprint( "%4ld", word_address );
d2601 1
a2601 1
      myprint( "%4ld", word_address );
d2688 1
a2688 1
	      myprint( "%ld ", pnext_branch->address_of_refer );
d2716 2
a2717 2
  inform( "-b        enable  branch tracing (the default)" );
  inform( "-B	     disable branch tracing" );
d2725 1
d2745 1
a2745 1
  bool		trace         = TRUE;
d2802 3
a2804 2
	      if (arg > 1                      &&
		  argv[ arg - 1 ][ 1 ] == 'o'  &&
d2807 10
a2816 1
		  /* catch the very special case of -o <name> */
d2835 1
a2835 1
	      switch (argv[ arg ][ 1 ])
d2837 4
a2840 2
		case 'o':
		  if (argv[ arg ][ 2 ] == '\0')
d2844 5
a2848 1
			  inform( "no name following '-o' option" );
d2850 7
a2856 4
			  return EXIT_FAILURE;
			}		      
		      
		      output_file = argv[ arg ];
d2860 4
a2863 1
		      output_file = argv[ arg ] + 2;		      
d2865 6
a2870 9

		  break;
		  
		case 'H':
		  helios_format = FALSE;
		  break;
		  
		case 'h':
		  if (argv[ arg ][ 2 ] == '\0')
d2872 49
a2920 1
		      helios_format = TRUE;
d2923 1
a2923 22
		  
		  /* drop through */
		    
		case '?':
		  break;
		  
		case 'T':
		  ti_format = FALSE;
		  break;

		case 't':
		  ti_format = TRUE;
		  break;

		case 'b':
		  trace = TRUE;
		  break;

		case 'B':
		  trace = FALSE;
		  break;
		}
d3025 33
@


1.13
log
@fixed bug in allocating name buffer
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.12 $
 * Date:	$Date: 1992/06/15 12:04:22 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.12 1992/06/15 12:04:22 paul Exp nickc $
d64 2
d122 3
d127 1
a127 1
  fflush( stdout );
d129 1
a129 1
  fseek( stdout, 0L, SEEK_END );
d141 1
a141 1
      fprintf( stdout, start );
d143 1
a143 1
      fprintf( stdout, "%%" );
d148 1
a148 1
  fprintf( stdout, start );
d150 1
a150 1
  fflush( stdout );
d174 1
a174 1
	  fputc( ' ', stdout );
d181 1
a181 1
      fputc( ' ', stdout );
d184 1
a184 1
  fflush( stdout );
d198 1
a198 1
  fputc( '\n', stdout );
d2445 19
d2505 19
d2696 1
a2696 1
      fflush( stdout );
d2714 12
a2725 11
  inform( "-b     enable  branch tracing (default)" );
  inform( "-B	  disable branch tracing" );
  inform( "-t     enable  TI format output" );
  inform( "-T     disable TI format output (default)" );
  inform( "-h     enable  Helios linker format disassembling (default)" );
  inform( "-H     disable Helios linker format disassembling" );
  inform( "-help  this message" );
  inform( "-?     this message" );
  inform( "-      disassemble from stdin (default)" );
  inform( "<file> disassemble <file>" );
  inform( "--     treat all futher command line options as file names to disassemble" );
a2726 1

d2791 3
a2793 1
	  if (argv[ arg ][ 0 ] == '-' && argv[ arg ][ 1 ] != '\0')
d2799 9
d2824 19
d2887 18
d3013 1
a3013 1
  return 0;
a3015 1
  
@


1.12
log
@fixed for std __proc names
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.11 $
 * Date:	$Date: 1992/04/21 10:18:18 $
 * Header:	$Header: /m/giga/HeliosRoot/Helios/cmds/linker/RCS/c40disas.c,v 1.11 1992/04/21 10:18:18 nickc Exp paul $
d2507 1
a2507 1
	  func_name = (char *)malloc( (int)(name_len + 5) );
d2572 2
a2573 1
	      name_len = 0;
d2590 1
a2590 1
	  func_name  = (char *)malloc( (int)(name_len + 5) );
d2603 1
a2603 1
      
d2631 1
a2631 1
	  
d2634 1
a2634 1
      
d2650 1
a2650 1
      
@


1.11
log
@fixed several bugs
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.10 $
 * Date:	$Date: 1992/01/28 15:07:07 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.10 1992/01/28 15:07:07 nickc Exp nickc $
d485 1
a485 1
#ifdef __HELIOSC40
d512 1
a512 1
#endif /* __HELIOSC40 */
@


1.10
log
@changed dependency from __HELIOSC40 (indicates target of output of program) to __C40 (indicates host of program )
@
text
@d2 1
a2 1
 * disas - a stand alone disassembler for the 'C40
d4 1
a4 1
 * Copyright (c) 1991 Perihelion Software Ltd.
d8 3
a10 3
 * Version:	$Revision: 1.9 $
 * Date:	$Date: 1992/01/28 13:06:25 $
 * Header:	$Header: /m/giga/HeliosRoot/Helios/cmds/linker/RCS/c40disas.c,v 1.9 1992/01/28 13:06:25 nickc Exp nickc $
d15 2
d22 8
d60 1
a60 2
static unsigned char * 	ProgName     = (unsigned char *)"disas";	/* the name of the program */
static unsigned int	word_address = 0;				/* address of current instruction */
d62 2
d65 1
d70 4
d153 4
d165 10
a174 1
  while (current_column < goal_column)
a176 2

      ++current_column;
d232 1
a232 1
	    register int 	arg )		/* the argument to the applied function */
d356 3
a358 3
			int	mode,	/* the indirect addressing mode (5 bits wide) */
			int	addr,	/* the address register involved */
			int	disp )	/* the displacement involved */
d364 8
a371 8
    case B_00000:	myprint( "*+AR%ld(%d)",          addr, disp ); break;
    case B_00001:	myprint( "*-AR%ld(%d)",          addr, disp ); break;
    case B_00010:	myprint( "*++AR%ld(%d)",         addr, disp ); break;
    case B_00011:	myprint( "*--AR%ld(%d)",         addr, disp ); break;
    case B_00100:	myprint( "*AR%ld++(%d)",         addr, disp ); break;
    case B_00101:	myprint( "*AR%ld--(%d)",         addr, disp ); break;
    case B_00110:	myprint( "*AR%ld++(%d)%%",       addr, disp ); break;
    case B_00111:	myprint( "*AR%ld--(%d)%%",       addr, disp ); break;
d485 1
a485 1
#ifdef __C40
d512 1
a512 1
#endif /* __C40 */
d532 1
a532 1
		      unsigned long	op_code,	/* instruction */
d534 2
a535 2
		      bool		floating,	/* TRUE if floating point operation */
		      bool		store )		/* TRUE if a store operation */
d538 1
a538 1
  int		dest;
a541 2
   * XXX - NC
   *
d549 4
d554 1
a554 1
  dest = (op_code >> 16) & 0x1f;
d556 7
a562 1
  if (floating)
d564 1
a564 1
      /* the destination (or source) register of a floating point op must be R0 - R11 */
d566 1
a566 1
      if (!is_extended_precision_register( dest ))
d568 9
a576 2
	  return;
	}      
a577 2

  pdest = _regname( dest );
a582 2
       * XXX - NC
       *
d593 5
a597 2

      if (floating && !is_extended_precision_register( op_code & 0xff ))
d599 2
d604 4
a607 5
      myprint( instruction );

      pad_to( COL_OPERAND );

      myprint( "%s, %s", _regname( op_code & 0x1f ), pdest );
a612 2
       * XXX - NC
       *
d622 2
a623 4
      myprint( instruction );

      pad_to( COL_OPERAND );

d625 3
a627 1
	myprint( "%s, @@%#04.4lx", pdest, (op_code & 0xffff) );
d629 2
a630 2
	myprint( "@@%#04.4lx, %s", (op_code & 0xffff), pdest );

a634 2
       * XXX - NC
       *
a645 4
      myprint( instruction );

      pad_to( COL_OPERAND );

d647 2
a648 2
	  int		disp = op_code & 0xff;
	  int		addr = (op_code >> 8) & 0x7;
d660 3
a662 2
	      
	      myprint( ", %s", pdest );
a668 2
       * XXX - NC
       *
d678 2
a679 6
      myprint( instruction );

      pad_to( COL_OPERAND );

      if (floating)
	myprint( "%s, %s", decode_short_float( op_code & 0xffffU ), pdest );
d681 1
a681 3
	myprint( "%d, %s", mask_and_sign_extend_word( op_code, 0xffffU ), pdest );

      break;
d683 18
d706 1
a706 1
  
d715 1
a715 1
  int		dest;
a718 2
   * XXX - NC
   *
a732 2
       * XXX - NC
       *
a747 2
       * XXX - NC
       *
a762 2
       * XXX - NC
       *
d776 1
a776 1
      decode_indirect_address( op_code >> 11 & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );
a781 2
       * XXX - NC
       *
d793 1
a793 1
      myprint( "%d, ", mask_and_sign_extend_word( dest, 0x1f ) );
d795 1
a795 1
      decode_indirect_address( op_code >> 11 & 0x1f, (op_code >> 8) & 0x7, op_code & 0xff );
d811 1
a811 1
decode_flow_control( unsigned long	op_code )	/* the instruction to decode */
a813 2
   * XXX - NC
   *
a835 2
		   * XXX - NC
		   *
a867 2
		       * XXX - NC
		       *
a879 2
		       * XXX - NC
		       *
a909 2
		       * XXX - NC
		       *
d927 2
a928 1
				  _regname( op_code ), "<xxx unknown expansion register xxx>" );
d937 2
a938 1
				  "<xxx unknown expansion register xxx>", _regname( op_code >> 16 ) );
a946 2
		       * XXX - NC
		       *
a980 2
		   * XXX - NC
		   *
d1010 1
a1010 1
		      myprint( "L%d", word_address + op_code );
d1030 2
a1031 2
		  int		addr;
		  int		offset;
a1034 2
		   * XXX - NC
		   *
d1070 1
a1070 1
		      myprint( "AR%1ld, %+d", addr, op_code );
d1079 2
a1080 2
		  char	op[ 10 ];
		  int	offset;
a1083 2
		   * XXX - NC
		   *
d1102 1
a1102 1
		    case B_010: return;
d1104 1
a1104 1
		    case B_100:	return;
d1106 2
a1107 2
		    case B_110:	return;
		    case B_111:	return;
d1116 2
a1117 2
		      signed int	dest;
		      signed int	displacement;
d1124 1
a1124 1
		      myprint( "%+d", displacement );
d1128 1
a1128 1
		      myprint( "(branch to %d)", dest );
d1138 2
a1139 2
	      int	offset;

d1145 6
a1150 6
		case B_000:	myprint( "BR"    ); offset = -1;  break;
		case B_001:	myprint( "BRD"   ); offset = -3;  break;
		case B_010:	myprint( "CALL"  ); offset = -1; break;
		case B_011:	myprint( "LAJ"   ); offset = -3; break;
		case B_100:	myprint( "RPTB"  ); offset = 0;  break;
		case B_101:	myprint( "RPTBD" ); offset = 3;  break;
d1160 1
a1160 1
	      myprint( "%+d", op_code );
d1164 1
a1164 1
	      myprint( "(branch to %d)", op_code + abs( offset ) + word_address );
d1170 2
a1171 2
      char 	op[ 10 ];
      bool	floating;
a1174 2
       * XXX - NC
       *
d1189 1
a1189 1
	  floating = TRUE;
d1195 1
a1195 1
	  floating = FALSE;
d1200 1
a1200 1
      decode_diadic_address( op_code, op, floating, FALSE );
d1218 1
a1218 1
  int	B;
a1221 2
   * XXX - NC
   *
d1232 1
a1232 1
  B = (int)((op_code >> 23) & 0x03);
d1242 1
a1242 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1252 1
a1252 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1262 1
a1262 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1272 1
a1272 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1282 1
a1282 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1291 1
a1291 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1300 1
a1300 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1309 1
a1309 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1314 1
d1332 6
a1337 6
  int		src1;
  int		src2;
  int		src3;
  int		src4;
  int		dst1;
  int		dst2;
a1340 2
   * XXX - NC
   *
d1354 6
a1359 6
  src4 =  op_code        & 0xff;
  src3 = (op_code >>  8) & 0xff;
  src2 = (op_code >> 16) & 0x7;
  src1 = (op_code >> 19) & 0x7;
  dst2 = (op_code >> 22) & 0x1;
  dst1 = (op_code >> 23) & 0x1;
d1403 1
a1403 1
      myprint( ", %s, %s", _regname( src1 ), _regname( dst1 ), op2 );
a1478 2
   * XXX - NC
   *
d1489 1
a1489 1
    default:	return;
a1510 2
   * XXX - NC
   *
a1569 2
   * XXX - NC
   *
d1594 1
a1635 2
   * XXX - NC
   *
d1678 1
a1678 1

d1708 1
a1708 1

a1732 1
      
d1764 1
a1764 1

d1766 1
a1766 1

d1798 1
d1813 1
a1813 1
		       unsigned long	op_code,	/* instruction to decode */
d1815 1
a1815 1
		       bool		floating )	/* TRUE if floating point operation */
d1818 2
a1819 2
  int		dest;
  unsigned long	type;
a1824 2
   * XXX - NC
   *
d1842 1
a1842 1
  if (floating)
d1848 2
a1849 1
	  myprint( "R<illegal>" ); return;
d1857 1
a1857 1
  type = (op_code >> 28) & 0x1;
d1859 1
a1859 1
  type <<= 2;
d1861 1
a1861 1
  type |= ((op_code >> 21) & 0x3);
d1870 1
a1870 1
  switch (type)
d1914 19
a1932 4
      myprint( "%d, %s, %s",
	      mask_and_sign_extend_word( op_code, 0xff ),
	      _regname( src1 & 0x3f ),
	      pdest );
d1938 1
a1938 1
	      src2 & 0x7, (src2 >> 2),
d1945 19
a1963 4
      myprint( "%d, *+AR%.1ld(%.2lu), %s",
	      mask_and_sign_extend_word( op_code, 0xff ),
	      src1 & 0x7, (src1 >> 2),
	      pdest );
d1969 2
a1970 2
	      src2 & 0x7, (src2 >> 2),
	      src1 & 0x7,(src1 >> 2),
d1975 2
a1976 1
      return;
d1985 16
a2003 2
   * XXX - NC
   *
a2010 2
       * XXX - NC
       *
d2020 19
a2038 19
	case OP_ADDC3:	decode_triadic_address( op_code, "ADDC3"   , FALSE ); return;
	case OP_ADDF3:	decode_triadic_address( op_code, "ADDF3"   , TRUE  ); return;
	case OP_ADDI3:	decode_triadic_address( op_code, "ADDI3"   , FALSE ); return;
	case OP_AND3:	decode_triadic_address( op_code, "AND3"    , FALSE ); return;
	case OP_ANDN3:	decode_triadic_address( op_code, "ANDN3"   , FALSE ); return;
	case OP_ASH3:	decode_triadic_address( op_code, "ASH3"    , FALSE ); return;
	case OP_CMPF3:	decode_triadic_address( op_code, "CMPF3"   , TRUE  ); return;
	case OP_CMPI3:	decode_triadic_address( op_code, "CMPI3"   , FALSE ); return;
	case OP_LSH3:	decode_triadic_address( op_code, "LSH3"    , FALSE ); return;
	case OP_MPYF3:	decode_triadic_address( op_code, "MPYF3"   , TRUE  ); return;
	case OP_MPYI3:	decode_triadic_address( op_code, "MPYI3"   , FALSE ); return;
	case OP_OR3:	decode_triadic_address( op_code, "OR3"     , FALSE ); return;
	case OP_SUBB3:	decode_triadic_address( op_code, "SUBB3"   , FALSE ); return;
	case OP_SUBF3:	decode_triadic_address( op_code, "SUBF3"   , TRUE  ); return;
	case OP_SUBI3:	decode_triadic_address( op_code, "SUBI3"   , FALSE ); return;
	case OP_TSTB3:	decode_triadic_address( op_code, "TSTB3"   , FALSE ); return;
	case OP_XOR3:	decode_triadic_address( op_code, "XOR3"    , FALSE ); return;
	case OP_MPYSHI3:decode_triadic_address( op_code, "MPYSHI3" , FALSE ); return;
	case OP_MPYUHI3:decode_triadic_address( op_code, "MPYUHI3" , FALSE ); return;
a2045 2
       * XXX - NC
       *
d2054 12
a2065 12
	case OP_ABSF:	decode_diadic_address( op_code, "ABSF"   , TRUE,  FALSE ); return;
	case OP_ABSI:	decode_diadic_address( op_code, "ABSI"   , FALSE, FALSE ); return;
	case OP_ADDC:	decode_diadic_address( op_code, "ADDC"   , FALSE, FALSE ); return;
	case OP_ADDF:	decode_diadic_address( op_code, "ADDF"   , TRUE,  FALSE ); return;
	case OP_ADDI:	decode_diadic_address( op_code, "ADDI"   , FALSE, FALSE ); return;
	case OP_AND:	decode_diadic_address( op_code, "AND"    , FALSE, FALSE ); return;
	case OP_ANDN:	decode_diadic_address( op_code, "ANDN"   , FALSE, FALSE ); return;
	case OP_ASH:	decode_diadic_address( op_code, "ASH"    , FALSE, FALSE ); return;
	case OP_CMPF:	decode_diadic_address( op_code, "CMPF"   , TRUE,  FALSE ); return;
	case OP_CMPI:	decode_diadic_address( op_code, "CMPI"   , FALSE, FALSE ); return;
	case OP_FIX:	decode_diadic_address( op_code, "FIX"    , TRUE,  FALSE ); return;
	case OP_FLOAT:	decode_diadic_address( op_code, "FLOAT"  , FALSE, FALSE ); return;
d2067 50
a2116 49
	case OP_LDE:	decode_diadic_address( op_code, "LDE"    , TRUE,  FALSE ); return;
	case OP_LDF:	decode_diadic_address( op_code, "LDF"    , TRUE,  FALSE ); return;
	case OP_LDFI:	decode_diadic_address( op_code, "LDFI"   , TRUE,  FALSE ); return;
	case OP_LDI:	decode_diadic_address( op_code, "LDI"    , FALSE, FALSE ); return;
	case OP_LDII:	decode_diadic_address( op_code, "LDII"   , FALSE, FALSE ); return;
	case OP_LDM:	decode_diadic_address( op_code, "LDM"    , TRUE,  FALSE ); return;
	case OP_LSH:	decode_diadic_address( op_code, "LSH"    , FALSE, FALSE ); return;
	case OP_MPYF:	decode_diadic_address( op_code, "MPYF"   , TRUE,  FALSE ); return;
	case OP_MPYI:	decode_diadic_address( op_code, "MPYI"   , FALSE, FALSE ); return;
	case OP_NEGB:	decode_diadic_address( op_code, "NEGB"   , FALSE, FALSE ); return;
	case OP_NEGF:	decode_diadic_address( op_code, "NEGF"   , TRUE,  FALSE ); return;
	case OP_NEGI:	decode_diadic_address( op_code, "NEGI"   , FALSE, FALSE ); return;
	case OP_NOP:	myprint( "NOP" ); return;	/* XXX - not quite true can use indirect addressing to adjust address registers */
	case OP_NORM:	decode_diadic_address( op_code, "NORM"   , TRUE,  FALSE ); return;
	case OP_NOT:	decode_diadic_address( op_code, "NOT"    , FALSE, FALSE ); return;
	case OP_POP:	myprint( "POP" );   pad_to( COL_OPERAND ); myprint( "%s", _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_POPF:	myprint( "POPF" );  pad_to( COL_OPERAND ); myprint( "%s", _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_PUSH:	myprint( "PUSH" );  pad_to( COL_OPERAND ); myprint( "%s", _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_PUSHF:	myprint( "PUSHF" ); pad_to( COL_OPERAND ); myprint( "%s", _regname( (op_code >> 16) & 0x1f ) ); return;
	case OP_OR:	decode_diadic_address( op_code, "OR"     , FALSE, FALSE ); return;
	case OP_RND:	decode_diadic_address( op_code, "RND"    , TRUE,  FALSE ); return;
	case OP_ROL:	decode_diadic_address( op_code, "ROL"    , FALSE, FALSE ); return;
	case OP_ROLC:	decode_diadic_address( op_code, "ROLC"   , FALSE, FALSE ); return;
	case OP_ROR:	decode_diadic_address( op_code, "ROR"    , FALSE, FALSE ); return;
	case OP_RORC:	decode_diadic_address( op_code, "RORC"   , FALSE, FALSE ); return;
	case OP_RPTS:	decode_diadic_address( op_code, "RPTS"   , FALSE, FALSE ); return;
	case OP_STF:	decode_diadic_address( op_code, "STF"    , TRUE,  TRUE  ); return;
	case OP_STFI:	decode_diadic_address( op_code, "STFI"   , TRUE,  TRUE  ); return;
	case OP_STI:	decode_integer_store( op_code ); return;
	case OP_STII:	decode_diadic_address( op_code, "STII"   , FALSE, TRUE  ); return;
	case OP_SIGI:	decode_diadic_address( op_code, "SIGI"   , FALSE, FALSE ); return;
	case OP_SUBB:	decode_diadic_address( op_code, "SUBB"   , FALSE, FALSE ); return;
	case OP_SUBC:	decode_diadic_address( op_code, "SUBC"   , FALSE, FALSE ); return;
	case OP_SUBF:	decode_diadic_address( op_code, "SUBF"   , TRUE,  FALSE ); return;
	case OP_SUBI:	decode_diadic_address( op_code, "SUBI"   , FALSE, FALSE ); return;
	case OP_SUBRB:	decode_diadic_address( op_code, "SUBRB"  , FALSE, FALSE ); return;
	case OP_SUBRF:	decode_diadic_address( op_code, "SUBRF"  , TRUE,  FALSE ); return;
	case OP_SUBRI:	decode_diadic_address( op_code, "SUBRI"  , FALSE, FALSE ); return;
	case OP_TSTB:	decode_diadic_address( op_code, "TSTB"   , FALSE, FALSE ); return;
	case OP_XOR:	decode_diadic_address( op_code, "XOR"    , FALSE, FALSE ); return;
	case OP_IACK:	decode_diadic_address( op_code, "IACK"   , FALSE, FALSE ); return;
	case OP_TOIEEE:	decode_diadic_address( op_code, "TOIEEE" , TRUE,  FALSE ); return;
	case OP_FRIEEE:	decode_diadic_address( op_code, "FRIEEE" , TRUE,  FALSE ); return;
	case OP_RSQRF:	decode_diadic_address( op_code, "RSQRF"  , TRUE,  FALSE ); return;
	case OP_RCPF:	decode_diadic_address( op_code, "RCPF"   , TRUE,  FALSE ); return;
	case OP_MPYSHI:	decode_diadic_address( op_code, "MPYSHI" , FALSE, FALSE ); return;
	case OP_MPYUHI:	decode_diadic_address( op_code, "MPYUHI" , FALSE, FALSE ); return;
	case OP_LDA:	decode_diadic_address( op_code, "LDA"    , FALSE, FALSE ); return;
	case OP_LDHI:	decode_diadic_address( op_code, "LDHI"   , FALSE, FALSE ); return;
d2118 1
a2118 1
	  return;
a2130 2
   * XXX - NC
   *
d2147 1
a2147 1
print_byte( int value )
d2172 1
a2172 1
      myprint( " %c ", value );
d2189 1
a2189 1
static signed int
d2196 1
a2196 1
	  return 1 + mask_and_sign_extend_word( instruction, 0xffffL );
d2200 1
a2200 1
	  return 3 + mask_and_sign_extend_word( instruction, 0xffffL );
d2208 1
a2208 1
	  return 3 + mask_and_sign_extend_word( instruction, 0xffffffL );
d2212 1
a2212 1
	  return 1 + mask_and_sign_extend_word( instruction, 0xffffffL );
d2216 1
a2216 1
  return 0;
d2228 2
a2229 2
    unsigned int	address_refered_to;	/* address to which a branch will go */
    unsigned int	address_of_refer;	/* address of branch instruction     */
d2237 2
a2238 2
    unsigned int	address_of_name;	/* word address of start of function name */
    unsigned int	length_of_name;		/* byte length of function name           */
d2264 2
a2265 2
	       unsigned int	address,
	       unsigned int	length )
d2295 2
a2296 2
	     unsigned int	address,
	     signed int		offset )
d2332 1
a2332 1
	  unsigned int *	destination,
d2336 1
a2336 1
  int		tmp;
d2351 1
a2351 1
  tmp |= (((unsigned int)val) << 8);
d2358 1
a2358 1
  tmp |= (((unsigned int)val) << 16);
d2365 1
a2365 1
  *destination = tmp | (((unsigned int)val) << 24);
d2380 1
a2380 1
  unsigned int	value;
d2400 1
a2400 1
      signed int	offset;
d2431 2
a2432 2
  unsigned int	value;
  int		i;
d2449 1
a2449 1
      myprint( " .word 0%xH", value );
d2470 6
a2475 7
  unsigned int	value;
  branch_ref *	pnext_branch;
  func_ref *	pnext_func;
  bool		show_code;
  bool		suppress_show = FALSE;
  int		name_len      = 0;
  char *	func_name     = NULL;
d2507 1
a2507 1
	  func_name = (char *)malloc( name_len + 5 );
d2534 1
a2534 1
	      myprint( "%4d", word_address );
d2538 1
a2538 1
	      myprint( "0x%08.8x ", value );
d2556 1
a2556 1
      myprint( "%4d", word_address );
d2560 1
a2560 1
      myprint( "0x%08.8x ", value );
d2589 1
a2589 1
	  func_name  = (char *)malloc( name_len + 5 );
d2603 1
a2603 1
      if (!helios_format || value > 10 || value < 0)
d2615 3
a2617 1
	    decode( value );
d2625 4
a2628 4
	  func_name[ i++ ] =  value        & 0xff;
	  func_name[ i++ ] = (value >>  8) & 0xff;
	  func_name[ i++ ] = (value >> 16) & 0xff;
	  func_name[ i++ ] = (value >> 24) & 0xff;	  
d2642 1
a2642 1
	      myprint( "%d ", pnext_branch->address_of_refer );
d2705 1
a2705 1
  if ((ProgName = (unsigned char *)strrchr( argv[ 0 ], '/' )) != NULL)
d2808 1
a2808 1
	      int	next_arg = TRUE;
@


1.9
log
@added function to decode short floats
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.18 $
 * Date:	$Date: 1991/12/11 13:45:32 $
 * Header:	$Header: /users/nickc/ncc/cc350/c40/RCS/disas.c,v 1.18 1991/12/11 13:45:32 nickc Exp nickc $
d458 1
a458 1
#ifdef __HELIOSC40
d485 1
a485 1
#endif /* __HELIOSC40 */
@


1.8
log
@improved TI format output
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.17 $
 * Date:	$Date: 1991/11/05 16:51:06 $
 * Header:	$Header: /users/nickc/ncc/cc350/c40/RCS/disas.c,v 1.17 1991/11/05 16:51:06 nickc Exp $
d397 102
d650 1
a650 1
	myprint( "%#4f, %s", (double)mask_and_sign_extend_word( op_code , 0xffffL ), pdest );
d652 1
a652 1
	myprint( "%d, %s", mask_and_sign_extend_word( op_code, 0xffff ), pdest );
d701 1
a701 1
      myprint( "%s, @@%#04.4lx", mask_and_sign_extend_word( dest, 0x1f ), (op_code & 0xffff) );
@


1.7
log
@added a -l command line option for "raw" mode
@
text
@d8 3
a10 3
 * Version:	$Revision$
 * Date:	$Date$
 * Header:	$Header$
d17 2
d48 1
a48 1
#define COL_TRACE	67
d406 1
a406 2
		      bool		store,		/* TRUE if a store operation */
		      bool		ti_format )	/* TRUE if decoding for TI compatability */
a430 3
	  if (ti_format)
	    myprint( ".word 0%xH", op_code );

a455 3
	  if (ti_format)
	    myprint( ".word 0%xH", op_code );

d674 1
a674 3
decode_flow_control(
		    unsigned long	op_code,	/* the instruction to decode */
		    bool		ti_format )	/* TRUE if decoding for TI compatability */
d885 1
a885 4
		      if (ti_format)
			myprint( "%+d", op_code );
		      else
			myprint( "L%d", word_address + op_code );
d981 1
a981 1
		    case B_010: if (ti_format) myprint( ".word 0%xH", op_code ); return;
d983 1
a983 1
		    case B_100:	if (ti_format) myprint( ".word 0%xH", op_code ); return;
d985 2
a986 2
		    case B_110:	if (ti_format) myprint( ".word 0%xH", op_code ); return;
		    case B_111:	if (ti_format) myprint( ".word 0%xH", op_code ); return;
d995 5
a999 1
		      op_code = mask_and_sign_extend_word( op_code, 0xffffU );
d1001 1
a1001 7
		      if (ti_format)
			{
			  myprint( "L%d", op_code + offset + word_address );
			}
		      else
			{
			  myprint( "%+d", op_code );
d1003 1
a1003 1
			  pad_to( COL_DESTINATION );
d1005 3
a1007 2
			  myprint( "(branch to %d)", op_code + offset + word_address );
			}
d1032 1
a1032 1
		case B_111:	if (ti_format) myprint( ".word 0%xH", op_code ); return;
d1039 1
a1039 7
	      if (ti_format)
		{
		  myprint( "L%d", op_code + abs( offset ) + word_address );
		}
	      else
		{
		  myprint( "%+d", op_code );
d1041 1
a1041 1
		  pad_to( COL_DESTINATION );
d1043 1
a1043 2
		  myprint( "(branch to %d)", op_code + abs( offset ) + word_address );
		}
d1081 1
a1081 1
      decode_diadic_address( op_code, op, floating, FALSE, ti_format );
d1096 1
a1096 3
decode_non_word_load(
		     unsigned long	op_code,	/* instruction */
		     bool		ti_format )	/* TRUE if decoding for TI compatability */
d1125 1
a1125 1
      decode_diadic_address( op_code, op, FALSE, FALSE, ti_format );
d1135 1
a1135 1
      decode_diadic_address( op_code, op, FALSE, FALSE, ti_format );
d1145 1
a1145 1
      decode_diadic_address( op_code, op, FALSE, FALSE, ti_format );
d1155 1
a1155 1
      decode_diadic_address( op_code, op, FALSE, FALSE, ti_format );
d1165 1
a1165 1
      decode_diadic_address( op_code, op, FALSE, FALSE, ti_format );
d1174 1
a1174 1
      decode_diadic_address( op_code, op, FALSE, FALSE, ti_format );
d1183 1
a1183 1
      decode_diadic_address( op_code, op, FALSE, FALSE, ti_format );
d1192 1
a1192 1
      decode_diadic_address( op_code, op, FALSE, FALSE, ti_format );
a1196 2
      if (ti_format)
	myprint( ".word 0%xH", op_code ); return;
d1210 1
a1210 3
decode_special_triadic(
		       unsigned long 	op_code, 	/* instruction to decode */
		       bool		ti_format )	/* TRUE if decoding for TI compatability */
a1269 3
      if (ti_format)
	current_column = COL_OP_CODE - 3;
      
a1290 3
      if (ti_format)
	current_column = COL_OP_CODE - 3;
      
a1311 3
      if (ti_format)
	current_column = COL_OP_CODE - 3;
      
a1338 3
      if (ti_format)
	current_column = COL_OP_CODE - 3;
      
d1349 1
a1349 1
      myprint( ", %s", _regname( dst2 + 2 ) );
d1360 1
a1360 3
decode_non_word_load_or_triadic(
				unsigned long	op_code,	/* instruction to decode */
				bool		ti_format )	/* TRUE if decding for TI compatability */
d1373 3
a1375 4
    case B_00:	decode_special_triadic( op_code, ti_format ); break;
    case B_01:	if (ti_format) myprint( ".word 0%xH", op_code ); return;
    case B_10:	if (ti_format) myprint( ".word 0%xH", op_code ); return;
    case B_11:	decode_non_word_load( op_code, ti_format );   break;
d1387 1
a1387 2
				   char *		second_op,	/* the name of the second op code */
				   bool			ti_format )	/* TRUE if decoding for TI compatability */
a1431 3
  if (ti_format)
    current_column = COL_OP_CODE - 3;
      
d1449 1
a1449 2
				  char *	second_op,	/* string identifying the second op code */
				  bool		ti_format )	/* TRUE if decoding for TI compatability */
a1483 3
      if (ti_format)
	myprint( ".word 0%xH" );

a1498 3
  if (ti_format)
    current_column = COL_OP_CODE - 3;
      
d1515 1
a1515 3
decode_parallel_op(
		   unsigned long 	op_code, 	/* instruction to decode */
		   bool			ti_format )	/* TRUE if decoding for TI compatability */
a1563 3
      if (ti_format)
	current_column = COL_OP_CODE - 3;
      
a1593 3
      if (ti_format)
	current_column = COL_OP_CODE - 3;
      
a1623 2
      if (ti_format)
	current_column = COL_OP_CODE - 3;
a1654 3
      if (ti_format)
	current_column = COL_OP_CODE - 3;
      
d1667 22
a1688 22
    case OP_ABSF_STF:	decode_diadic_parallel_addressing(  op_code, "ABSF",   "STF", ti_format ); break;
    case OP_ABSI_STI:	decode_diadic_parallel_addressing(  op_code, "ABSI",   "STI", ti_format ); break;
    case OP_ADDF3_STF:	decode_triadic_parallel_addressing( op_code, "ADDF3",  "STF", ti_format ); break;
    case OP_ADDI3_STI:	decode_triadic_parallel_addressing( op_code, "ADDI3",  "STI", ti_format ); break;
    case OP_AND3_STI:	decode_triadic_parallel_addressing( op_code, "AND3",   "STI", ti_format ); break;
    case OP_ASH3_STI:	decode_triadic_parallel_addressing( op_code, "ASH3",   "STI", ti_format ); break;
    case OP_FIX_STI:	decode_diadic_parallel_addressing(  op_code, "FIX",    "STI", ti_format ); break;
    case OP_FLOAT_STF:	decode_diadic_parallel_addressing(  op_code, "FLOAT",  "STF", ti_format ); break;
    case OP_LDF_STF:	decode_diadic_parallel_addressing(  op_code, "LDF",    "STF", ti_format ); break;
    case OP_LDI_STI:	decode_diadic_parallel_addressing(  op_code, "LDI",    "STI", ti_format ); break;
    case OP_LSH3_STI:	decode_triadic_parallel_addressing( op_code, "LSH3",   "STI", ti_format ); break;
    case OP_MPYF3_STF:	decode_triadic_parallel_addressing( op_code, "MPYF3",  "STF", ti_format ); break;
    case OP_MPYI3_STI:	decode_triadic_parallel_addressing( op_code, "MPYI3",  "STI", ti_format ); break;
    case OP_NEGF_STF:	decode_diadic_parallel_addressing(  op_code, "NEGF",   "STF", ti_format ); break;
    case OP_NEGI_STI:	decode_diadic_parallel_addressing(  op_code, "NEGI",   "STI", ti_format ); break;
    case OP_NOT_STI:	decode_diadic_parallel_addressing(  op_code, "NOT",    "STI", ti_format ); break;
    case OP_OR3_STI:	decode_triadic_parallel_addressing( op_code, "OR3",    "STI", ti_format ); break;
    case OP_SUBF3_STF:	decode_triadic_parallel_addressing( op_code, "SUBF3",  "STF", ti_format ); break;
    case OP_SUBI3_STI:	decode_triadic_parallel_addressing( op_code, "SUBI3",  "STI", ti_format ); break;
    case OP_XOR3_STI:	decode_triadic_parallel_addressing( op_code, "XOR3",   "STI", ti_format ); break;
    case OP_TOIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "TOIEEE", "STF", ti_format ); break;
    case OP_FRIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "FRIEEE", "STF", ti_format ); break;
a1689 2
      if (ti_format) myprint( ".word 0%xH", op_code );
      return;
d1706 1
a1706 2
		       bool		floating,	/* TRUE if floating point operation */
		       bool		ti_format )	/* TRUE if decoding for TI compatability */
a1836 2
      if (ti_format)
	myprint( ".word 0%xH", op_code );
d1846 1
a1846 3
decode_sequential_op(
		     unsigned long	op_code,	/* instruction to decode */
		     bool		ti_format )	/* TRUE if decoding for TI compatability */
d1869 19
a1887 19
	case OP_ADDC3:	decode_triadic_address( op_code, "ADDC3"   , FALSE, ti_format ); return;
	case OP_ADDF3:	decode_triadic_address( op_code, "ADDF3"   , TRUE , ti_format ); return;
	case OP_ADDI3:	decode_triadic_address( op_code, "ADDI3"   , FALSE, ti_format ); return;
	case OP_AND3:	decode_triadic_address( op_code, "AND3"    , FALSE, ti_format ); return;
	case OP_ANDN3:	decode_triadic_address( op_code, "ANDN3"   , FALSE, ti_format ); return;
	case OP_ASH3:	decode_triadic_address( op_code, "ASH3"    , FALSE, ti_format ); return;
	case OP_CMPF3:	decode_triadic_address( op_code, "CMPF3"   , TRUE , ti_format ); return;
	case OP_CMPI3:	decode_triadic_address( op_code, "CMPI3"   , FALSE, ti_format ); return;
	case OP_LSH3:	decode_triadic_address( op_code, "LSH3"    , FALSE, ti_format ); return;
	case OP_MPYF3:	decode_triadic_address( op_code, "MPYF3"   , TRUE , ti_format ); return;
	case OP_MPYI3:	decode_triadic_address( op_code, "MPYI3"   , FALSE, ti_format ); return;
	case OP_OR3:	decode_triadic_address( op_code, "OR3"     , FALSE, ti_format ); return;
	case OP_SUBB3:	decode_triadic_address( op_code, "SUBB3"   , FALSE, ti_format ); return;
	case OP_SUBF3:	decode_triadic_address( op_code, "SUBF3"   , TRUE , ti_format ); return;
	case OP_SUBI3:	decode_triadic_address( op_code, "SUBI3"   , FALSE, ti_format ); return;
	case OP_TSTB3:	decode_triadic_address( op_code, "TSTB3"   , FALSE, ti_format ); return;
	case OP_XOR3:	decode_triadic_address( op_code, "XOR3"    , FALSE, ti_format ); return;
	case OP_MPYSHI3:decode_triadic_address( op_code, "MPYSHI3" , FALSE, ti_format ); return;
	case OP_MPYUHI3:decode_triadic_address( op_code, "MPYUHI3" , FALSE, ti_format ); return;
d1905 25
a1929 25
	case OP_ABSF:	decode_diadic_address( op_code, "ABSF"   , TRUE,  FALSE, ti_format ); return;
	case OP_ABSI:	decode_diadic_address( op_code, "ABSI"   , FALSE, FALSE, ti_format ); return;
	case OP_ADDC:	decode_diadic_address( op_code, "ADDC"   , FALSE, FALSE, ti_format ); return;
	case OP_ADDF:	decode_diadic_address( op_code, "ADDF"   , TRUE,  FALSE, ti_format ); return;
	case OP_ADDI:	decode_diadic_address( op_code, "ADDI"   , FALSE, FALSE, ti_format ); return;
	case OP_AND:	decode_diadic_address( op_code, "AND"    , FALSE, FALSE, ti_format ); return;
	case OP_ANDN:	decode_diadic_address( op_code, "ANDN"   , FALSE, FALSE, ti_format ); return;
	case OP_ASH:	decode_diadic_address( op_code, "ASH"    , FALSE, FALSE, ti_format ); return;
	case OP_CMPF:	decode_diadic_address( op_code, "CMPF"   , TRUE,  FALSE, ti_format ); return;
	case OP_CMPI:	decode_diadic_address( op_code, "CMPI"   , FALSE, FALSE, ti_format ); return;
	case OP_FIX:	decode_diadic_address( op_code, "FIX"    , TRUE,  FALSE, ti_format ); return;
	case OP_FLOAT:	decode_diadic_address( op_code, "FLOAT"  , FALSE, FALSE, ti_format ); return;
	case OP_IDLE:	decode_diadic_address( op_code, "IDLE"   , FALSE, FALSE, ti_format ); return;
	case OP_LDE:	decode_diadic_address( op_code, "LDE"    , TRUE,  FALSE, ti_format ); return;
	case OP_LDF:	decode_diadic_address( op_code, "LDF"    , TRUE,  FALSE, ti_format ); return;
	case OP_LDFI:	decode_diadic_address( op_code, "LDFI"   , TRUE,  FALSE, ti_format ); return;
	case OP_LDI:	decode_diadic_address( op_code, "LDI"    , FALSE, FALSE, ti_format ); return;
	case OP_LDII:	decode_diadic_address( op_code, "LDII"   , FALSE, FALSE, ti_format ); return;
	case OP_LDM:	decode_diadic_address( op_code, "LDM"    , TRUE,  FALSE, ti_format ); return;
	case OP_LSH:	decode_diadic_address( op_code, "LSH"    , FALSE, FALSE, ti_format ); return;
	case OP_MPYF:	decode_diadic_address( op_code, "MPYF"   , TRUE,  FALSE, ti_format ); return;
	case OP_MPYI:	decode_diadic_address( op_code, "MPYI"   , FALSE, FALSE, ti_format ); return;
	case OP_NEGB:	decode_diadic_address( op_code, "NEGB"   , FALSE, FALSE, ti_format ); return;
	case OP_NEGF:	decode_diadic_address( op_code, "NEGF"   , TRUE,  FALSE, ti_format ); return;
	case OP_NEGI:	decode_diadic_address( op_code, "NEGI"   , FALSE, FALSE, ti_format ); return;
d1931 2
a1932 2
	case OP_NORM:	decode_diadic_address( op_code, "NORM"   , TRUE,  FALSE, ti_format ); return;
	case OP_NOT:	decode_diadic_address( op_code, "NOT"    , FALSE, FALSE, ti_format ); return;
d1937 9
a1945 9
	case OP_OR:	decode_diadic_address( op_code, "OR"     , FALSE, FALSE, ti_format ); return;
	case OP_RND:	decode_diadic_address( op_code, "RND"    , TRUE,  FALSE, ti_format ); return;
	case OP_ROL:	decode_diadic_address( op_code, "ROL"    , FALSE, FALSE, ti_format ); return;
	case OP_ROLC:	decode_diadic_address( op_code, "ROLC"   , FALSE, FALSE, ti_format ); return;
	case OP_ROR:	decode_diadic_address( op_code, "ROR"    , FALSE, FALSE, ti_format ); return;
	case OP_RORC:	decode_diadic_address( op_code, "RORC"   , FALSE, FALSE, ti_format ); return;
	case OP_RPTS:	decode_diadic_address( op_code, "RPTS"   , FALSE, FALSE, ti_format ); return;
	case OP_STF:	decode_diadic_address( op_code, "STF"    , TRUE,  TRUE , ti_format ); return;
	case OP_STFI:	decode_diadic_address( op_code, "STFI"   , TRUE,  TRUE , ti_format ); return;
d1947 20
a1966 20
	case OP_STII:	decode_diadic_address( op_code, "STII"   , FALSE, TRUE , ti_format ); return;
	case OP_SIGI:	decode_diadic_address( op_code, "SIGI"   , FALSE, FALSE, ti_format ); return;
	case OP_SUBB:	decode_diadic_address( op_code, "SUBB"   , FALSE, FALSE, ti_format ); return;
	case OP_SUBC:	decode_diadic_address( op_code, "SUBC"   , FALSE, FALSE, ti_format ); return;
	case OP_SUBF:	decode_diadic_address( op_code, "SUBF"   , TRUE,  FALSE, ti_format ); return;
	case OP_SUBI:	decode_diadic_address( op_code, "SUBI"   , FALSE, FALSE, ti_format ); return;
	case OP_SUBRB:	decode_diadic_address( op_code, "SUBRB"  , FALSE, FALSE, ti_format ); return;
	case OP_SUBRF:	decode_diadic_address( op_code, "SUBRF"  , TRUE,  FALSE, ti_format ); return;
	case OP_SUBRI:	decode_diadic_address( op_code, "SUBRI"  , FALSE, FALSE, ti_format ); return;
	case OP_TSTB:	decode_diadic_address( op_code, "TSTB"   , FALSE, FALSE, ti_format ); return;
	case OP_XOR:	decode_diadic_address( op_code, "XOR"    , FALSE, FALSE, ti_format ); return;
	case OP_IACK:	decode_diadic_address( op_code, "IACK"   , FALSE, FALSE, ti_format ); return;
	case OP_TOIEEE:	decode_diadic_address( op_code, "TOIEEE" , TRUE,  FALSE, ti_format ); return;
	case OP_FRIEEE:	decode_diadic_address( op_code, "FRIEEE" , TRUE,  FALSE, ti_format ); return;
	case OP_RSQRF:	decode_diadic_address( op_code, "RSQRF"  , TRUE,  FALSE, ti_format ); return;
	case OP_RCPF:	decode_diadic_address( op_code, "RCPF"   , TRUE,  FALSE, ti_format ); return;
	case OP_MPYSHI:	decode_diadic_address( op_code, "MPYSHI" , FALSE, FALSE, ti_format ); return;
	case OP_MPYUHI:	decode_diadic_address( op_code, "MPYUHI" , FALSE, FALSE, ti_format ); return;
	case OP_LDA:	decode_diadic_address( op_code, "LDA"    , FALSE, FALSE, ti_format ); return;
	case OP_LDHI:	decode_diadic_address( op_code, "LDHI"   , FALSE, FALSE, ti_format ); return;
a1967 2
	  if (ti_format)
	    myprint( ".word 0%xH", op_code );
d1978 1
a1978 3
decode(
       unsigned long	op_code,	/* instruction to decode */
       bool		ti_format )	/* TRUE if decoding for TI compatability */
d1989 4
a1992 4
    case 0: decode_sequential_op(            op_code, ti_format ); return;
    case 1: decode_flow_control(             op_code, ti_format ); return;
    case 2: decode_non_word_load_or_triadic( op_code, ti_format ); return;
    case 3: decode_parallel_op(              op_code, ti_format ); return;
d2281 36
a2319 1
	    bool	ti_format,	/* TRUE if the output should be compatible with the TI assembler */
d2378 1
a2378 1
      if (!ti_format)
d2380 1
a2380 1
	  myprint( "%4d", word_address );
d2382 26
a2407 1
	  pad_to( COL_WORD );
d2409 1
a2409 2
	  myprint( "0x%08.8x ", value );
	}
d2411 4
d2419 1
a2419 3
	      if (ti_format)
		{
		  myprint( " .word 0%XH", value );
d2421 1
a2421 7
		  new_line();
		  
		  myprint( "_%s:", func_name );
		}
	      else
		{
		  pad_to( COL_OP_CODE );
a2422 3
		  myprint( "%s():", func_name );
		}

a2429 5
	  if (ti_format)
	    {
	      suppress_show = TRUE;
	    }
	  
d2458 1
a2458 21
	  if (ti_format)
	    {
	      if (trace && pnext_branch && word_address >= pnext_branch->address_refered_to)
		{
		  while (pnext_branch && pnext_branch->address_refered_to <= word_address)
		    {
		      free( pnext_branch );

		      pnext_branch = (branch_ref *)remove_head( &branch_trace );
		    }
		  
		  myprint( "L%d:", word_address );
	      
		  new_line();
		}
	      
	      current_column = COL_OP_CODE - 1;
	    }
	  else
	    {
	      pad_to( COL_BYTES );
d2460 4
a2463 5
	      print_byte( value );
	      print_byte( value >>  8 );	
	      print_byte( value >> 16 );
	      print_byte( value >> 24 );
	    }
d2468 1
a2468 3
	    decode( value, ti_format );
	  else if (ti_format)
	    myprint( ".word 0%xH", value );
a2469 7
      else if (ti_format)
	{
	  if (suppress_show)
	    suppress_show = FALSE;
	  else
	    myprint( " .word 0%xH", value );
	}
d2485 1
a2485 1
      if (!ti_format && trace && pnext_branch && word_address == pnext_branch->address_refered_to)
d2489 1
a2489 1
	  myprint( "branched to from: " );
a2507 7
  if (ti_format)
    {
      myprint( ".end:" );

      new_line();
    }

d2521 12
a2532 5
  inform( "-t     toggle branch tracing" );
  inform( "-p     toggle TI format output" );
  inform( "-l     toggle Helios linker format disassembling" );
  inform( "-      read from stdin" );
  inform( "<file> file to disassemble" );
d2554 2
a2555 1

d2564 19
a2582 1
	
d2586 1
d2589 5
d2595 2
a2596 1
      for (arg = 1 ; arg < argc; arg++)
d2598 59
d2664 4
d2669 8
d2682 1
a2682 1
		  input = stdin;
d2686 4
d2691 1
a2691 1
		  trace = !trace;
d2694 2
a2695 2
		case 'p':
		  ti_format = !ti_format;
d2698 2
a2699 2
		case 'l':
		  helios_format = !helios_format;
d2701 22
d2724 2
a2747 2
	  
	  disassemble( input, trace, ti_format, helios_format );
d2749 5
d2766 4
a2769 1
      disassemble( stdin, trace, ti_format, helios_format );
@


1.6
log
@fixed parallel instr. dest regs
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.5 $
 * Date:	$Date: 1991/10/21 15:36:43 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.5 1991/10/21 15:36:43 nickc Exp $
d27 1
a27 1
 * AAAA WWWWWWWW BBBB OOOOO PPPPPPPPPPPP EEEEEE TTTTTTT
d36 1
a36 1
 *   E - destination of branches
d45 1
a45 1
#define COL_EXTRAS	52
d48 2
a49 2
static char * 		ProgName     = "disas";		/* the name of the program */
static unsigned int	word_address = 0;		/* address of current instruction */
d1015 1
a1015 1
			  pad_to( COL_EXTRAS );
d1017 1
a1017 1
			  myprint( "(address %d)", op_code + offset + word_address );
d1058 1
a1058 1
		  pad_to( COL_EXTRAS );
d1060 1
a1060 1
		  myprint( "(address %d)", op_code + abs( offset ) + word_address );
d1266 1
a1267 1
  dst2 = (op_code >> 22) & 0x1;
d2356 4
a2359 3
	    FILE *	input,
	    int		trace,
	    int		ti_format )
d2364 1
a2364 1
  bool		show_code     = FALSE;
d2370 3
d2375 5
d2407 1
a2407 1
	 }
d2426 1
a2426 1
      if ((value & 0xFFFFFF00U) == 0xFF000000U)
d2460 1
a2460 1
      if (pnext_func && word_address == pnext_func->address_of_name)
d2483 1
a2483 1
      if (value > 10 || value < 0)
d2585 5
a2589 3
  inform( "-t   toggle branch tracing" );
  inform( "-p   toggle PC format output" );
  inform( "-    read from stdin" );
d2602 2
a2603 2
     int	argc,
     char **	argv )
d2605 3
a2607 2
  bool		trace     = TRUE;
  bool		ti_format = FALSE;
d2611 10
a2620 4
  
  ProgName = argv[ 0 ];
  
  
d2639 2
a2640 1

d2653 4
d2661 1
d2669 1
a2669 1
	      input = fopen( argv[ arg ], "rb" );
d2681 1
a2681 1
	  disassemble( input, trace, ti_format );
d2692 4
a2695 2
    {
      disassemble( stdin, trace, ti_format );
@


1.5
log
@applied fixes to improve TI comptability mode
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.13 $
 * Date:	$Date: 1991/10/17 16:44:47 $
 * Header:	$Header: /users/nickc/ncc/cc350/c40/RCS/disas.c,v 1.13 1991/10/17 16:44:47 nickc Exp nickc $
d1266 2
a1267 2
  dst1 = (op_code >> 22) & 0x1;
  dst2 = (op_code >> 23) & 0x1;
d1303 1
a1303 1
      myprint( "%s, %s, %s", _regname( src1 ), _regname( src2 ), _regname( dst2 ) );
d1329 1
a1329 1
      myprint( ", %s, %s", _regname( src2 ), _regname( dst2 ) );
d1357 1
a1357 1
      myprint( ", %s", _regname( dst2 ) );
d1385 1
a1385 1
      myprint( ", %s", _regname( dst2 ) );
@


1.4
log
@fixed word reading to be little endian
@
text
@d8 3
a10 3
 * Version:	$Revision$
 * Date:	$Date$
 * Header:	$Header$
d174 1
a174 1
 * list manipulation routines - stolen from elsewhere
d187 3
a189 3
    Node *	head;
    Node *	earth;
    Node *	tail;
d201 3
a203 3
	    register List *	plist,
	    register bool (*	pfunc)(),
	    register int 	arg )
d327 3
a329 3
			int	mode,
			int	addr,
			int	disp )
d404 2
a405 1
		      bool		store )		/* TRUE if a store operation */
a421 4
  myprint( instruction );

  pad_to( COL_OPERAND );

d430 5
a434 2
	  myprint( "R<illegal>" );
	}
d455 13
d485 4
d511 4
d548 4
d680 2
a681 2
		    unsigned long	op_code,
		    bool		pc_format )
d890 1
a890 1
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
d892 1
a892 1
		      if (pc_format)
d955 1
a955 1
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
d991 1
a991 1
		    case B_010: myprint( "<bad>" ); return;
d993 1
a993 1
		    case B_100:	myprint( "<bad>" ); return;
d995 2
a996 2
		    case B_110:	myprint( "<bad>" ); return;
		    case B_111:	myprint( "<bad>" ); return;
d1005 1
a1005 1
		      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffL );
d1007 1
a1007 1
		      if (pc_format)
d1043 1
a1043 1
		case B_111:	myprint( "<bad>" ); return;
d1046 1
a1046 1
	      op_code = mask_and_sign_extend_word( (unsigned long)op_code, 0xffffffL );
d1050 1
a1050 1
	      if (pc_format)
d1099 1
a1099 1
      decode_diadic_address( op_code, op, floating, FALSE );
d1114 3
a1116 1
decode_non_word_load( unsigned long op_code ) /* instruction */
d1145 1
a1145 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1155 1
a1155 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1165 1
a1165 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1175 1
a1175 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1185 1
a1185 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1194 1
a1194 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1203 1
a1203 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1212 1
a1212 1
      decode_diadic_address( op_code, op, FALSE, FALSE );
d1217 2
a1218 1
      myprint( "<bad>" ); return;
d1233 2
a1234 2
		       unsigned long 	op_code, 	/* instruction */
		       bool		pc_format )	/* flag */
d1294 1
a1294 1
      if (pc_format)
d1318 1
a1318 1
      if (pc_format)
d1342 1
a1342 1
      if (pc_format)
d1372 1
a1372 1
      if (pc_format)
d1397 2
a1398 2
				unsigned long	op_code,	/* instruction */
				bool		pc_format )	/* flag */
d1411 4
a1414 4
    case B_00:	decode_special_triadic( op_code, pc_format ); break;
    case B_01:	myprint( "<bad>" ); return;
    case B_10:	myprint( "<bad>" ); return;
    case B_11:	decode_non_word_load( op_code );   break;
d1424 4
a1427 4
				   unsigned long	op_code,
				   char *		first_op,
				   char *		second_op,
				   bool			pc_format )
d1472 1
a1472 1
  if (pc_format)
d1490 4
a1493 4
				  unsigned long	op_code,
				  char *	first_op,
				  char *	second_op,
				  bool		pc_format )
d1528 4
a1531 1
      myprint( "<bad>" ); return;
d1546 1
a1546 1
  if (pc_format)
d1566 2
a1567 2
		   unsigned long 	op_code, 	/* instruction */
		   bool			pc_format )	/* flag */
d1616 1
a1616 1
      if (pc_format)
d1649 1
a1649 1
      if (pc_format)
d1682 1
a1682 1
      if (pc_format)
d1715 1
a1715 1
      if (pc_format)
d1730 22
a1751 22
    case OP_ABSF_STF:	decode_diadic_parallel_addressing(  op_code, "ABSF",   "STF", pc_format ); break;
    case OP_ABSI_STI:	decode_diadic_parallel_addressing(  op_code, "ABSI",   "STI", pc_format ); break;
    case OP_ADDF3_STF:	decode_triadic_parallel_addressing( op_code, "ADDF3",  "STF", pc_format ); break;
    case OP_ADDI3_STI:	decode_triadic_parallel_addressing( op_code, "ADDI3",  "STI", pc_format ); break;
    case OP_AND3_STI:	decode_triadic_parallel_addressing( op_code, "AND3",   "STI", pc_format ); break;
    case OP_ASH3_STI:	decode_triadic_parallel_addressing( op_code, "ASH3",   "STI", pc_format ); break;
    case OP_FIX_STI:	decode_diadic_parallel_addressing(  op_code, "FIX",    "STI", pc_format ); break;
    case OP_FLOAT_STF:	decode_diadic_parallel_addressing(  op_code, "FLOAT",  "STF", pc_format ); break;
    case OP_LDF_STF:	decode_diadic_parallel_addressing(  op_code, "LDF",    "STF", pc_format ); break;
    case OP_LDI_STI:	decode_diadic_parallel_addressing(  op_code, "LDI",    "STI", pc_format ); break;
    case OP_LSH3_STI:	decode_triadic_parallel_addressing( op_code, "LSH3",   "STI", pc_format ); break;
    case OP_MPYF3_STF:	decode_triadic_parallel_addressing( op_code, "MPYF3",  "STF", pc_format ); break;
    case OP_MPYI3_STI:	decode_triadic_parallel_addressing( op_code, "MPYI3",  "STI", pc_format ); break;
    case OP_NEGF_STF:	decode_diadic_parallel_addressing(  op_code, "NEGF",   "STF", pc_format ); break;
    case OP_NEGI_STI:	decode_diadic_parallel_addressing(  op_code, "NEGI",   "STI", pc_format ); break;
    case OP_NOT_STI:	decode_diadic_parallel_addressing(  op_code, "NOT",    "STI", pc_format ); break;
    case OP_OR3_STI:	decode_triadic_parallel_addressing( op_code, "OR3",    "STI", pc_format ); break;
    case OP_SUBF3_STF:	decode_triadic_parallel_addressing( op_code, "SUBF3",  "STF", pc_format ); break;
    case OP_SUBI3_STI:	decode_triadic_parallel_addressing( op_code, "SUBI3",  "STI", pc_format ); break;
    case OP_XOR3_STI:	decode_triadic_parallel_addressing( op_code, "XOR3",   "STI", pc_format ); break;
    case OP_TOIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "TOIEEE", "STF", pc_format ); break;
    case OP_FRIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "FRIEEE", "STF", pc_format ); break;
d1753 2
a1754 1
      myprint( "<bad>" ); return;
d1769 4
a1772 3
		      unsigned long	op_code,	/* instruction */
		      char *		instruction,	/* string identifying the op code */
		      bool		floating )	/* TRUE if floating point operation */
d1903 3
a1905 2
      myprint( "<bad>" ); return;
      break;
d1914 3
a1916 1
decode_sequential_op( unsigned long op_code ) /* instruction */
d1939 19
a1957 19
	case OP_ADDC3:	decode_triadic_address( op_code, "ADDC3"   , FALSE ); return;
	case OP_ADDF3:	decode_triadic_address( op_code, "ADDF3"   , TRUE  ); return;
	case OP_ADDI3:	decode_triadic_address( op_code, "ADDI3"   , FALSE ); return;
	case OP_AND3:	decode_triadic_address( op_code, "AND3"    , FALSE ); return;
	case OP_ANDN3:	decode_triadic_address( op_code, "ANDN3"   , FALSE ); return;
	case OP_ASH3:	decode_triadic_address( op_code, "ASH3"    , FALSE ); return;
	case OP_CMPF3:	decode_triadic_address( op_code, "CMPF3"   , TRUE  ); return;
	case OP_CMPI3:	decode_triadic_address( op_code, "CMPI3"   , FALSE ); return;
	case OP_LSH3:	decode_triadic_address( op_code, "LSH3"    , FALSE ); return;
	case OP_MPYF3:	decode_triadic_address( op_code, "MPYF3"   , TRUE  ); return;
	case OP_MPYI3:	decode_triadic_address( op_code, "MPYI3"   , FALSE ); return;
	case OP_OR3:	decode_triadic_address( op_code, "OR3"     , FALSE ); return;
	case OP_SUBB3:	decode_triadic_address( op_code, "SUBB3"   , FALSE ); return;
	case OP_SUBF3:	decode_triadic_address( op_code, "SUBF3"   , TRUE  ); return;
	case OP_SUBI3:	decode_triadic_address( op_code, "SUBI3"   , FALSE ); return;
	case OP_TSTB3:	decode_triadic_address( op_code, "TSTB3"   , FALSE ); return;
	case OP_XOR3:	decode_triadic_address( op_code, "XOR3"    , FALSE ); return;
	case OP_MPYSHI3:decode_triadic_address( op_code, "MPYSHI3" , FALSE ); return;
	case OP_MPYUHI3:decode_triadic_address( op_code, "MPYUHI3" , FALSE ); return;
d1975 25
a1999 25
	case OP_ABSF:	decode_diadic_address( op_code, "ABSF"   , TRUE,  FALSE ); return;
	case OP_ABSI:	decode_diadic_address( op_code, "ABSI"   , FALSE, FALSE ); return;
	case OP_ADDC:	decode_diadic_address( op_code, "ADDC"   , FALSE, FALSE ); return;
	case OP_ADDF:	decode_diadic_address( op_code, "ADDF"   , TRUE,  FALSE ); return;
	case OP_ADDI:	decode_diadic_address( op_code, "ADDI"   , FALSE, FALSE ); return;
	case OP_AND:	decode_diadic_address( op_code, "AND"    , FALSE, FALSE ); return;
	case OP_ANDN:	decode_diadic_address( op_code, "ANDN"   , FALSE, FALSE ); return;
	case OP_ASH:	decode_diadic_address( op_code, "ASH"    , FALSE, FALSE ); return;
	case OP_CMPF:	decode_diadic_address( op_code, "CMPF"   , TRUE,  FALSE ); return;
	case OP_CMPI:	decode_diadic_address( op_code, "CMPI"   , FALSE, FALSE ); return;
	case OP_FIX:	decode_diadic_address( op_code, "FIX"    , TRUE,  FALSE ); return;
	case OP_FLOAT:	decode_diadic_address( op_code, "FLOAT"  , FALSE, FALSE ); return;
	case OP_IDLE:	decode_diadic_address( op_code, "IDLE"   , FALSE, FALSE ); return;
	case OP_LDE:	decode_diadic_address( op_code, "LDE"    , TRUE,  FALSE ); return;
	case OP_LDF:	decode_diadic_address( op_code, "LDF"    , TRUE,  FALSE ); return;
	case OP_LDFI:	decode_diadic_address( op_code, "LDFI"   , TRUE,  FALSE ); return;
	case OP_LDI:	decode_diadic_address( op_code, "LDI"    , FALSE, FALSE ); return;
	case OP_LDII:	decode_diadic_address( op_code, "LDII"   , FALSE, FALSE ); return;
	case OP_LDM:	decode_diadic_address( op_code, "LDM"    , TRUE,  FALSE ); return;
	case OP_LSH:	decode_diadic_address( op_code, "LSH"    , FALSE, FALSE ); return;
	case OP_MPYF:	decode_diadic_address( op_code, "MPYF"   , TRUE,  FALSE ); return;
	case OP_MPYI:	decode_diadic_address( op_code, "MPYI"   , FALSE, FALSE ); return;
	case OP_NEGB:	decode_diadic_address( op_code, "NEGB"   , FALSE, FALSE ); return;
	case OP_NEGF:	decode_diadic_address( op_code, "NEGF"   , TRUE,  FALSE ); return;
	case OP_NEGI:	decode_diadic_address( op_code, "NEGI"   , FALSE, FALSE ); return;
d2001 2
a2002 2
	case OP_NORM:	decode_diadic_address( op_code, "NORM"   , TRUE,  FALSE ); return;
	case OP_NOT:	decode_diadic_address( op_code, "NOT"    , FALSE, FALSE ); return;
d2007 9
a2015 9
	case OP_OR:	decode_diadic_address( op_code, "OR"     , FALSE, FALSE ); return;
	case OP_RND:	decode_diadic_address( op_code, "RND"    , TRUE,  FALSE ); return;
	case OP_ROL:	decode_diadic_address( op_code, "ROL"    , FALSE, FALSE ); return;
	case OP_ROLC:	decode_diadic_address( op_code, "ROLC"   , FALSE, FALSE ); return;
	case OP_ROR:	decode_diadic_address( op_code, "ROR"    , FALSE, FALSE ); return;
	case OP_RORC:	decode_diadic_address( op_code, "RORC"   , FALSE, FALSE ); return;
	case OP_RPTS:	decode_diadic_address( op_code, "RPTS"   , FALSE, FALSE ); return;
	case OP_STF:	decode_diadic_address( op_code, "STF"    , TRUE,  TRUE  ); return;
	case OP_STFI:	decode_diadic_address( op_code, "STFI"   , TRUE,  TRUE  ); return;
d2017 20
a2036 20
	case OP_STII:	decode_diadic_address( op_code, "STII"   , FALSE, TRUE  ); return;
	case OP_SIGI:	decode_diadic_address( op_code, "SIGI"   , FALSE, FALSE ); return;
	case OP_SUBB:	decode_diadic_address( op_code, "SUBB"   , FALSE, FALSE ); return;
	case OP_SUBC:	decode_diadic_address( op_code, "SUBC"   , FALSE, FALSE ); return;
	case OP_SUBF:	decode_diadic_address( op_code, "SUBF"   , TRUE,  FALSE ); return;
	case OP_SUBI:	decode_diadic_address( op_code, "SUBI"   , FALSE, FALSE ); return;
	case OP_SUBRB:	decode_diadic_address( op_code, "SUBRB"  , FALSE, FALSE ); return;
	case OP_SUBRF:	decode_diadic_address( op_code, "SUBRF"  , TRUE,  FALSE ); return;
	case OP_SUBRI:	decode_diadic_address( op_code, "SUBRI"  , FALSE, FALSE ); return;
	case OP_TSTB:	decode_diadic_address( op_code, "TSTB"   , FALSE, FALSE ); return;
	case OP_XOR:	decode_diadic_address( op_code, "XOR"    , FALSE, FALSE ); return;
	case OP_IACK:	decode_diadic_address( op_code, "IACK"   , FALSE, FALSE ); return;
	case OP_TOIEEE:	decode_diadic_address( op_code, "TOIEEE" , TRUE,  FALSE ); return;
	case OP_FRIEEE:	decode_diadic_address( op_code, "FRIEEE" , TRUE,  FALSE ); return;
	case OP_RSQRF:	decode_diadic_address( op_code, "RSQRF"  , TRUE,  FALSE ); return;
	case OP_RCPF:	decode_diadic_address( op_code, "RCPF"   , TRUE,  FALSE ); return;
	case OP_MPYSHI:	decode_diadic_address( op_code, "MPYSHI" , FALSE, FALSE ); return;
	case OP_MPYUHI:	decode_diadic_address( op_code, "MPYUHI" , FALSE, FALSE ); return;
	case OP_LDA:	decode_diadic_address( op_code, "LDA"    , FALSE, FALSE ); return;
	case OP_LDHI:	decode_diadic_address( op_code, "LDHI"   , FALSE, FALSE ); return;
d2038 3
a2040 1
	  myprint( "<bad>" ); return;
d2051 2
a2052 2
       unsigned long	op_code,
       bool		pc_format )
d2063 4
a2066 4
    case 0: decode_sequential_op(            op_code            ); return;
    case 1: decode_flow_control(             op_code, pc_format ); return;
    case 2: decode_non_word_load_or_triadic( op_code, pc_format ); return;
    case 3: decode_parallel_op(              op_code, pc_format ); return;
d2148 1
a2148 1
static List func_trace;			/* linked list of function headers */
d2153 3
a2155 3
    Node		node;
    unsigned int	address_refered_to;
    unsigned int	address_of_refer;
d2162 3
a2164 3
    Node		node;
    unsigned int	address_of_name;
    unsigned int	length_of_name;
d2329 1
a2329 1
      if ((value & (unsigned long)0xFFFFFF00L) == (unsigned long)0xFF000000L)
d2358 1
a2358 1
	    int		pc_format )
d2408 1
a2408 1
      if (!pc_format)
d2421 1
a2421 1
	      if (pc_format)
d2443 1
a2443 1
	  if (pc_format)
d2454 1
a2454 2

	  name_len = pnext_func->length_of_name;
d2459 2
a2461 2
	  func_name = (char *)malloc( name_len + 5 );

d2476 1
a2476 1
	  if (pc_format)
d2498 3
a2501 3
	      print_byte( value >> 16 );
	      print_byte( value >>  8 );
	      print_byte( value );
d2507 2
a2508 2
	    decode( value, pc_format );
	  else if (pc_format)
d2511 1
a2511 1
      else if (pc_format)
d2521 1
a2521 2
	  char	buf[ 5 ];
	  int *	ptr = (int *)buf;
d2524 5
a2528 2
	  *ptr = value;
	  buf[ 4 ] = '\0';
a2529 2
	  strcat( func_name, buf );

d2533 1
a2533 1
      if (!pc_format && trace && pnext_branch && word_address == pnext_branch->address_refered_to)
d2556 1
a2556 1
  if (pc_format)
d2595 1
a2595 1
  bool		pc_format = FALSE;
d2632 1
a2632 1
		  pc_format = !pc_format;
d2657 1
a2657 3
	  fprintf( stderr, "disassembling\n" );
	  
	  disassemble( input, trace, pc_format );
d2669 1
a2669 1
      disassemble( stdin, trace, pc_format );
@


1.3
log
@changed condition code l to be lt
@
text
@d8 3
a10 3
 * Version:	$Revision: 1.2 $
 * Date:	$Date: 1991/10/09 13:53:14 $
 * Header:	$Header: /hsrc/cmds/linker/RCS/c40disas.c,v 1.2 1991/10/09 13:53:14 nickc Exp nickc $
d27 1
a27 1
 * AAAA WWWWWWWW BBBB OOOOO PPPPPPPPPPPP EEEEEE
d36 2
a37 1
 *   E - extra information
d46 1
a46 1
#define COL_TRACE	65
d377 1
a377 1
signed long
d379 2
a380 2
			  unsigned long	value,
			  unsigned long	mask )
d389 1
a389 1
  return (signed long)value;
d1204 3
a1206 1
decode_special_triadic( unsigned long op_code ) /* instruction */
d1265 3
d1290 3
d1314 3
d1344 3
d1368 3
a1370 1
decode_non_word_load_or_triadic( unsigned long op_code ) /* instruction */
d1383 1
a1383 1
    case B_00:	decode_special_triadic( op_code ); break;
d1398 2
a1399 1
				   char *		second_op )
d1444 3
d1464 2
a1465 1
				  char *	second_op )
d1515 3
d1530 1
a1530 1
} /* decode_triadic_parallel_addressing */
d1534 3
a1536 1
decode_parallel_op( unsigned long op_code ) /* instruction */
d1585 3
d1618 3
d1651 3
d1684 3
d1699 22
a1720 22
    case OP_ABSF_STF:	decode_diadic_parallel_addressing(  op_code, "ABSF",   "STF" ); break;
    case OP_ABSI_STI:	decode_diadic_parallel_addressing(  op_code, "ABSI",   "STI" ); break;
    case OP_ADDF3_STF:	decode_triadic_parallel_addressing( op_code, "ADDF3",  "STF" ); break;
    case OP_ADDI3_STI:	decode_triadic_parallel_addressing( op_code, "ADDI3",  "STI" ); break;
    case OP_AND3_STI:	decode_triadic_parallel_addressing( op_code, "AND3",   "STI" ); break;
    case OP_ASH3_STI:	decode_triadic_parallel_addressing( op_code, "ASH3",   "STI" ); break;
    case OP_FIX_STI:	decode_diadic_parallel_addressing(  op_code, "FIX",    "STI" ); break;
    case OP_FLOAT_STF:	decode_diadic_parallel_addressing(  op_code, "FLOAT",  "STF" ); break;
    case OP_LDF_STF:	decode_diadic_parallel_addressing(  op_code, "LDF",    "STF" ); break;
    case OP_LDI_STI:	decode_diadic_parallel_addressing(  op_code, "LDI",    "STI" ); break;
    case OP_LSH3_STI:	decode_triadic_parallel_addressing( op_code, "LSH3",   "STI" ); break;
    case OP_MPYF3_STF:	decode_triadic_parallel_addressing( op_code, "MPYF3",  "STF" ); break;
    case OP_MPYI3_STI:	decode_triadic_parallel_addressing( op_code, "MPYI3",  "STI" ); break;
    case OP_NEGF_STF:	decode_diadic_parallel_addressing(  op_code, "NEGF",   "STF" ); break;
    case OP_NEGI_STI:	decode_diadic_parallel_addressing(  op_code, "NEGI",   "STI" ); break;
    case OP_NOT_STI:	decode_diadic_parallel_addressing(  op_code, "NOT",    "STI" ); break;
    case OP_OR3_STI:	decode_triadic_parallel_addressing( op_code, "OR3",    "STI" ); break;
    case OP_SUBF3_STF:	decode_triadic_parallel_addressing( op_code, "SUBF3",  "STF" ); break;
    case OP_SUBI3_STI:	decode_triadic_parallel_addressing( op_code, "SUBI3",  "STI" ); break;
    case OP_XOR3_STI:	decode_triadic_parallel_addressing( op_code, "XOR3",   "STI" ); break;
    case OP_TOIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "TOIEEE", "STF" ); break;
    case OP_FRIEEE_STF:	decode_diadic_parallel_addressing(  op_code, "FRIEEE", "STF" ); break;
d2025 4
a2028 4
    case 0: decode_sequential_op( op_code ); return;
    case 1: decode_flow_control( op_code, pc_format ); return;
    case 2: decode_non_word_load_or_triadic( op_code ); return;
    case 3: decode_parallel_op( op_code ); return;
d2218 42
d2268 1
a2268 1
  unsigned long	value;
d2286 1
a2286 1
  while (fread( &value, sizeof( value ), 1, input ) == 1)
d2315 1
a2315 1
  
d2325 4
a2328 3
  bool		show_code = FALSE;
  int		name_len = 0;
  char *	func_name = NULL;
a2360 4
      else
	{
	  func_name[ 0 ] = '\0';
	}
d2368 1
a2368 1
  while (fread( &value, sizeof( value ), 1, input ) == 1)
d2379 1
a2379 1
      if ((value & (unsigned long)0xFFFFFF00L) == (unsigned long)0xFF000000L)
d2385 1
a2385 1
		  myprint( " .word 0" );
d2402 1
a2402 1
 
d2405 5
d2437 1
a2437 1
      if (value)
d2472 1
a2472 1
	    myprint( ".word 0" );
d2474 7
d2487 1
d2519 7
d2619 3
a2621 1

@


1.2
log
@added new command line option '-p' to make output more compatible with TI C40 assembler
@
text
@d8 3
a10 3
 * Version:	$Revision$
 * Date:	$Date$
 * Header:	$Header$
d312 1
a312 1
  "l\0\0\0\0le\0\0\0gt\0\0\0ge\0\0\0<xx>\0nv\0\0\0v\0\0\0\0"
@


1.1
log
@Initial revision
@
text
@d4 3
d8 3
a10 2
 * Version:	1
 * Date:	17/9/91
d21 1
d193 5
d201 1
a201 1
	    register int (*	pfunc)(),
d218 4
d234 4
d253 4
d272 5
d400 4
a403 4
		      int	w,		/* instruction */
		      char *	op_code,	/* string identifying instruction */
		      int	floating,	/* non zero if floating point operation */
		      int	store )		/* non zero if a store operation */
d420 1
a420 1
  myprint( op_code );
d424 1
a424 1
  dest = (w >> 16) & 0x1f;
d438 1
a438 1
  switch ((w >> 21) & 0x3)
d454 1
a454 1
      myprint( "%s, %s", _regname( w & 0x1f ), pdest );
d472 1
a472 1
	myprint( "%s, @@%#04.4lx", pdest, (w & 0xffff) );
d474 1
a474 1
	myprint( "@@%#04.4lx, %s", (w & 0xffff), pdest );
d494 2
a495 2
	  int		disp = w & 0xff;
	  int		addr = (w >> 8) & 0x7;
d502 1
a502 1
	      decode_indirect_address( w >> 11 & 0x1f, addr, disp );
d506 1
a506 1
	      decode_indirect_address( (w >> 11) & 0x1f, addr, disp );
d527 1
a527 1
	myprint( "%#4f, %s", (double)mask_and_sign_extend_word( w , 0xffffL ), pdest );
d529 1
a529 1
	myprint( "%d, %s", mask_and_sign_extend_word( w, 0xffff ), pdest );
d545 1
a545 1
decode_integer_store( int w )
d561 1
a561 1
  dest = (w >> 16) & 0x1f;
d563 1
a563 1
  switch ((w >> 21) & 0x3)
d578 1
a578 1
      myprint( "%s, @@%#04.4lx", mask_and_sign_extend_word( dest, 0x1f ), (w & 0xffff) );
d595 1
a595 1
      myprint( "%s, @@%#04.4lx", _regname( dest ), (w & 0xffff) );
d616 1
a616 1
      decode_indirect_address( w >> 11 & 0x1f, (w >> 8) & 0x7, w & 0xff );
d637 1
a637 1
      decode_indirect_address( w >> 11 & 0x1f, (w >> 8) & 0x7, w & 0xff );
d653 3
a655 1
decode_flow_control( int w )
d667 1
a667 1
  if (w & (1 << 29))
d671 1
a671 1
      if (w & (1 << 28))
d675 1
a675 1
	  if (w & (1 << 27))
d679 1
a679 1
	      if (w & (1 << 24))
d692 1
a692 1
		  if (w & (1 << 23))
d698 1
a698 1
		      myprint( "%s", _regname( w ) );
d706 1
a706 1
		      myprint( "%s", _regname( w ) );
d713 1
a713 1
		  if (w & (1 << 23))
d725 1
a725 1
		      myprint( "RETS%s", _condname( w >> 16 ) );
d740 1
a740 1
		      if (w & (1 << 21))
d742 1
a742 1
			  myprint( "RETI%sD", _condname( w >> 16 ) );
d746 1
a746 1
			  myprint( "RETI%s", _condname( w >> 16 ) );
d755 1
a755 1
	      if (w & (1 << 26))
d759 1
a759 1
		  if (w & (1 << 25))
d774 1
a774 1
		      if (w & (1 << 23))
d781 1
a781 1
				  _regname( w ), "<xxx unknown expansion register xxx>" );
d790 1
a790 1
				  "<xxx unknown expansion register xxx>", _regname( w >> 16 ) );
d811 1
a811 1
		      if (w & (1 << 23))
d820 1
a820 1
		      strcat( op, _condname( (w >> 16) & 0x1f ) );
d826 1
a826 1
		      myprint( "%lu", w & 0x1ff );
d847 1
a847 1
		  if (w & (1 << 21))
d856 1
a856 1
		  strcat( op, _condname( (w >> 16) & 0x1f ) );
d862 1
a862 1
		  if (w & (1 << 25))
d864 6
a869 3
		      w = mask_and_sign_extend_word( (unsigned long)w, 0xffffL );
		      
		      myprint( "%+d", w );		      
d873 1
a873 1
		      myprint( "%s", _regname( w & 0x1f ) );
d882 1
a882 1
	  if (w & (1 << 27))
d886 1
a886 1
	      if (w & (1 << 26))
d908 1
a908 1
		  strcat( op, _condname( (w >> 16) & 0x1f ) );
d910 1
a910 1
		  if (w & (1 << 21))
d921 1
a921 1
		  addr = (w >> 22) & 0x7;
d927 1
a927 1
		  if (w & (1 << 25))
d929 1
a929 1
		      w = mask_and_sign_extend_word( (unsigned long)w, 0xffffL );
d931 1
a931 1
		      myprint( "AR%1ld, %+d", addr, w );
d935 1
a935 1
		      myprint( "AR%1ld, %s", addr, _regname( w & 0x1f ) );
d959 1
a959 1
		  strcat( op, _condname( (w >> 16) & 0x1f ) );
d961 1
a961 1
		  switch ((w >> 21) & 0x7)
d977 1
a977 1
		  if (w & (1 << 25))
d979 1
a979 3
		      w = mask_and_sign_extend_word( (unsigned long)w, 0xffffL );
		      
		      myprint( "%+d", w );
d981 7
a987 1
		      pad_to( COL_EXTRAS );
d989 4
a992 1
		      myprint( "(address %d)", w + offset + word_address );
d996 1
a996 1
		      myprint( "%s", _regname( w & 0x1f ) );
d1007 1
a1007 1
	      switch ((w >> 24) & 0x7)
d1020 1
a1020 1
	      w = mask_and_sign_extend_word( (unsigned long)w, 0xffffffL );
d1024 7
a1030 1
	      myprint( "%+d", w );
d1032 1
a1032 1
	      pad_to( COL_EXTRAS );
d1034 2
a1035 1
	      myprint( "(address %d)", w + abs( offset ) + word_address );
d1042 1
a1042 1
      int	floating;
d1058 1
a1058 1
      if (((w >> 28) & 0x1) == 0)
d1071 1
a1071 1
      strcat( op, _condname( (w >> 23) & 0x1f ) );
d1073 1
a1073 1
      decode_diadic_address( w, op, floating, FALSE );
d1088 1
a1088 1
decode_non_word_load( int w ) /* instruction */
d1107 1
a1107 1
  B = (int)((w >> 23) & 0x03);
d1109 1
a1109 1
  switch ((w >> 24) & 0x0f)
d1117 1
a1117 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1127 1
a1127 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1137 1
a1137 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1147 1
a1147 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1157 1
a1157 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1166 1
a1166 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1175 1
a1175 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1184 1
a1184 1
      decode_diadic_address( w, op, FALSE, FALSE );
d1203 1
a1203 1
decode_special_triadic( int w ) /* instruction */
d1231 6
a1236 6
  src4 =  w        & 0xff;
  src3 = (w >>  8) & 0xff;
  src2 = (w >> 16) & 0x7;
  src1 = (w >> 19) & 0x7;
  dst1 = (w >> 22) & 0x1;
  dst2 = (w >> 23) & 0x1;
d1238 1
a1238 1
  switch ((w >> 26) & 0x3)
d1246 1
a1246 1
  switch ((w >> 24) & 0x3)
d1353 1
a1353 1
decode_non_word_load_or_triadic( int w ) /* instruction */
d1364 1
a1364 1
  switch ((w >> 28) & 0x3)
d1366 1
a1366 1
    case B_00:	decode_special_triadic( w ); break;
d1369 1
a1369 1
    case B_11:	decode_non_word_load( w );   break;
d1379 3
a1381 3
				   int	w,
				   char *	first_op,
				   char *	second_op )
d1408 5
a1412 5
  src2 = (w      ) & 0xff;
  dst2 = (w >>  8) & 0xff;
  src3 = (w >> 16) & 0x07;
  src1 = (w >> 19) & 0x07;
  dst1 = (w >> 22) & 0x07;
d1441 1
a1441 1
				  int	w,
d1469 4
a1472 4
  src2 = (w      ) & 0xff;
  dst2 = (w >>  8) & 0xff;
  src3 = (w >> 16) & 0x07;
  dst1 = (w >> 22) & 0x07;
d1476 1
a1476 1
  if (((w >> 19) & 0x07) != 0)
d1509 1
a1509 1
decode_parallel_op( int w ) /* instruction */
d1532 5
a1536 5
  field1 = (w      ) & 0xff;
  field2 = (w >>  8) & 0xff;
  field3 = (w >> 16) & 0x07;
  field4 = (w >> 19) & 0x07;
  field5 = (w >> 22) & 0x07;
d1538 1
a1538 1
  switch ((w >> 25) & 0x1f)
d1660 22
a1681 22
    case OP_ABSF_STF:	decode_diadic_parallel_addressing(  w, "ABSF",   "STF" ); break;
    case OP_ABSI_STI:	decode_diadic_parallel_addressing(  w, "ABSI",   "STI" ); break;
    case OP_ADDF3_STF:	decode_triadic_parallel_addressing( w, "ADDF3",  "STF" ); break;
    case OP_ADDI3_STI:	decode_triadic_parallel_addressing( w, "ADDI3",  "STI" ); break;
    case OP_AND3_STI:	decode_triadic_parallel_addressing( w, "AND3",   "STI" ); break;
    case OP_ASH3_STI:	decode_triadic_parallel_addressing( w, "ASH3",   "STI" ); break;
    case OP_FIX_STI:	decode_diadic_parallel_addressing(  w, "FIX",    "STI" ); break;
    case OP_FLOAT_STF:	decode_diadic_parallel_addressing(  w, "FLOAT",  "STF" ); break;
    case OP_LDF_STF:	decode_diadic_parallel_addressing(  w, "LDF",    "STF" ); break;
    case OP_LDI_STI:	decode_diadic_parallel_addressing(  w, "LDI",    "STI" ); break;
    case OP_LSH3_STI:	decode_triadic_parallel_addressing( w, "LSH3",   "STI" ); break;
    case OP_MPYF3_STF:	decode_triadic_parallel_addressing( w, "MPYF3",  "STF" ); break;
    case OP_MPYI3_STI:	decode_triadic_parallel_addressing( w, "MPYI3",  "STI" ); break;
    case OP_NEGF_STF:	decode_diadic_parallel_addressing(  w, "NEGF",   "STF" ); break;
    case OP_NEGI_STI:	decode_diadic_parallel_addressing(  w, "NEGI",   "STI" ); break;
    case OP_NOT_STI:	decode_diadic_parallel_addressing(  w, "NOT",    "STI" ); break;
    case OP_OR3_STI:	decode_triadic_parallel_addressing( w, "OR3",    "STI" ); break;
    case OP_SUBF3_STF:	decode_triadic_parallel_addressing( w, "SUBF3",  "STF" ); break;
    case OP_SUBI3_STI:	decode_triadic_parallel_addressing( w, "SUBI3",  "STI" ); break;
    case OP_XOR3_STI:	decode_triadic_parallel_addressing( w, "XOR3",   "STI" ); break;
    case OP_TOIEEE_STF:	decode_diadic_parallel_addressing(  w, "TOIEEE", "STF" ); break;
    case OP_FRIEEE_STF:	decode_diadic_parallel_addressing(  w, "FRIEEE", "STF" ); break;
d1698 3
a1700 3
		      int	w,		/* instruction */
		      char *	op_code,	/* string identifying the op code */
		      int	floating )	/* non zero if floating point operation */
d1723 1
a1723 1
  myprint( op_code );
d1727 1
a1727 1
  dest = (w >> 16) & 0x1f;
d1743 1
a1743 1
  type = (w >> 28) & 0x1;
d1747 1
a1747 1
  type |= ((w >> 21) & 0x3);
d1751 2
a1752 2
  src2 = w & 0xff;
  src1 = (w >> 8) & 0xff;
d1801 1
a1801 1
	      mask_and_sign_extend_word( w, 0xff ),
d1817 1
a1817 1
	      mask_and_sign_extend_word( w, 0xff ),
d1841 1
a1841 1
decode_sequential_op( int w ) /* instruction */
d1850 1
a1850 1
  if (w & 0x20000000L)
d1862 1
a1862 1
      switch ((w >> 23) & 0x1f)
d1864 19
a1882 19
	case OP_ADDC3:	decode_triadic_address( w, "ADDC3"   , FALSE ); return;
	case OP_ADDF3:	decode_triadic_address( w, "ADDF3"   , TRUE  ); return;
	case OP_ADDI3:	decode_triadic_address( w, "ADDI3"   , FALSE ); return;
	case OP_AND3:	decode_triadic_address( w, "AND3"    , FALSE ); return;
	case OP_ANDN3:	decode_triadic_address( w, "ANDN3"   , FALSE ); return;
	case OP_ASH3:	decode_triadic_address( w, "ASH3"    , FALSE ); return;
	case OP_CMPF3:	decode_triadic_address( w, "CMPF3"   , TRUE  ); return;
	case OP_CMPI3:	decode_triadic_address( w, "CMPI3"   , FALSE ); return;
	case OP_LSH3:	decode_triadic_address( w, "LSH3"    , FALSE ); return;
	case OP_MPYF3:	decode_triadic_address( w, "MPYF3"   , TRUE  ); return;
	case OP_MPYI3:	decode_triadic_address( w, "MPYI3"   , FALSE ); return;
	case OP_OR3:	decode_triadic_address( w, "OR3"     , FALSE ); return;
	case OP_SUBB3:	decode_triadic_address( w, "SUBB3"   , FALSE ); return;
	case OP_SUBF3:	decode_triadic_address( w, "SUBF3"   , TRUE  ); return;
	case OP_SUBI3:	decode_triadic_address( w, "SUBI3"   , FALSE ); return;
	case OP_TSTB3:	decode_triadic_address( w, "TSTB3"   , FALSE ); return;
	case OP_XOR3:	decode_triadic_address( w, "XOR3"    , FALSE ); return;
	case OP_MPYSHI3:decode_triadic_address( w, "MPYSHI3" , FALSE ); return;
	case OP_MPYUHI3:decode_triadic_address( w, "MPYUHI3" , FALSE ); return;
d1898 1
a1898 1
      switch (w >> 23)
d1900 25
a1924 25
	case OP_ABSF:	decode_diadic_address( w, "ABSF"   , TRUE,  FALSE ); return;
	case OP_ABSI:	decode_diadic_address( w, "ABSI"   , FALSE, FALSE ); return;
	case OP_ADDC:	decode_diadic_address( w, "ADDC"   , FALSE, FALSE ); return;
	case OP_ADDF:	decode_diadic_address( w, "ADDF"   , TRUE,  FALSE ); return;
	case OP_ADDI:	decode_diadic_address( w, "ADDI"   , FALSE, FALSE ); return;
	case OP_AND:	decode_diadic_address( w, "AND"    , FALSE, FALSE ); return;
	case OP_ANDN:	decode_diadic_address( w, "ANDN"   , FALSE, FALSE ); return;
	case OP_ASH:	decode_diadic_address( w, "ASH"    , FALSE, FALSE ); return;
	case OP_CMPF:	decode_diadic_address( w, "CMPF"   , TRUE,  FALSE ); return;
	case OP_CMPI:	decode_diadic_address( w, "CMPI"   , FALSE, FALSE ); return;
	case OP_FIX:	decode_diadic_address( w, "FIX"    , TRUE,  FALSE ); return;
	case OP_FLOAT:	decode_diadic_address( w, "FLOAT"  , FALSE, FALSE ); return;
	case OP_IDLE:	decode_diadic_address( w, "IDLE"   , FALSE, FALSE ); return;
	case OP_LDE:	decode_diadic_address( w, "LDE"    , TRUE,  FALSE ); return;
	case OP_LDF:	decode_diadic_address( w, "LDF"    , TRUE,  FALSE ); return;
	case OP_LDFI:	decode_diadic_address( w, "LDFI"   , TRUE,  FALSE ); return;
	case OP_LDI:	decode_diadic_address( w, "LDI"    , FALSE, FALSE ); return;
	case OP_LDII:	decode_diadic_address( w, "LDII"   , FALSE, FALSE ); return;
	case OP_LDM:	decode_diadic_address( w, "LDM"    , TRUE,  FALSE ); return;
	case OP_LSH:	decode_diadic_address( w, "LSH"    , FALSE, FALSE ); return;
	case OP_MPYF:	decode_diadic_address( w, "MPYF"   , TRUE,  FALSE ); return;
	case OP_MPYI:	decode_diadic_address( w, "MPYI"   , FALSE, FALSE ); return;
	case OP_NEGB:	decode_diadic_address( w, "NEGB"   , FALSE, FALSE ); return;
	case OP_NEGF:	decode_diadic_address( w, "NEGF"   , TRUE,  FALSE ); return;
	case OP_NEGI:	decode_diadic_address( w, "NEGI"   , FALSE, FALSE ); return;
d1926 36
a1961 36
	case OP_NORM:	decode_diadic_address( w, "NORM"   , TRUE,  FALSE ); return;
	case OP_NOT:	decode_diadic_address( w, "NOT"    , FALSE, FALSE ); return;
	case OP_POP:	myprint( "POP" );   pad_to( COL_OPERAND ); myprint( "%s", _regname( (w >> 16) & 0x1f ) ); return;
	case OP_POPF:	myprint( "POPF" );  pad_to( COL_OPERAND ); myprint( "%s", _regname( (w >> 16) & 0x1f ) ); return;
	case OP_PUSH:	myprint( "PUSH" );  pad_to( COL_OPERAND ); myprint( "%s", _regname( (w >> 16) & 0x1f ) ); return;
	case OP_PUSHF:	myprint( "PUSHF" ); pad_to( COL_OPERAND ); myprint( "%s", _regname( (w >> 16) & 0x1f ) ); return;
	case OP_OR:	decode_diadic_address( w, "OR"     , FALSE, FALSE ); return;
	case OP_RND:	decode_diadic_address( w, "RND"    , TRUE,  FALSE ); return;
	case OP_ROL:	decode_diadic_address( w, "ROL"    , FALSE, FALSE ); return;
	case OP_ROLC:	decode_diadic_address( w, "ROLC"   , FALSE, FALSE ); return;
	case OP_ROR:	decode_diadic_address( w, "ROR"    , FALSE, FALSE ); return;
	case OP_RORC:	decode_diadic_address( w, "RORC"   , FALSE, FALSE ); return;
	case OP_RPTS:	decode_diadic_address( w, "RPTS"   , FALSE, FALSE ); return;
	case OP_STF:	decode_diadic_address( w, "STF"    , TRUE,  TRUE  ); return;
	case OP_STFI:	decode_diadic_address( w, "STFI"   , TRUE,  TRUE  ); return;
	case OP_STI:	decode_integer_store( w ); return;
	case OP_STII:	decode_diadic_address( w, "STII"   , FALSE, TRUE  ); return;
	case OP_SIGI:	decode_diadic_address( w, "SIGI"   , FALSE, FALSE ); return;
	case OP_SUBB:	decode_diadic_address( w, "SUBB"   , FALSE, FALSE ); return;
	case OP_SUBC:	decode_diadic_address( w, "SUBC"   , FALSE, FALSE ); return;
	case OP_SUBF:	decode_diadic_address( w, "SUBF"   , TRUE,  FALSE ); return;
	case OP_SUBI:	decode_diadic_address( w, "SUBI"   , FALSE, FALSE ); return;
	case OP_SUBRB:	decode_diadic_address( w, "SUBRB"  , FALSE, FALSE ); return;
	case OP_SUBRF:	decode_diadic_address( w, "SUBRF"  , TRUE,  FALSE ); return;
	case OP_SUBRI:	decode_diadic_address( w, "SUBRI"  , FALSE, FALSE ); return;
	case OP_TSTB:	decode_diadic_address( w, "TSTB"   , FALSE, FALSE ); return;
	case OP_XOR:	decode_diadic_address( w, "XOR"    , FALSE, FALSE ); return;
	case OP_IACK:	decode_diadic_address( w, "IACK"   , FALSE, FALSE ); return;
	case OP_TOIEEE:	decode_diadic_address( w, "TOIEEE" , TRUE,  FALSE ); return;
	case OP_FRIEEE:	decode_diadic_address( w, "FRIEEE" , TRUE,  FALSE ); return;
	case OP_RSQRF:	decode_diadic_address( w, "RSQRF"  , TRUE,  FALSE ); return;
	case OP_RCPF:	decode_diadic_address( w, "RCPF"   , TRUE,  FALSE ); return;
	case OP_MPYSHI:	decode_diadic_address( w, "MPYSHI" , FALSE, FALSE ); return;
	case OP_MPYUHI:	decode_diadic_address( w, "MPYUHI" , FALSE, FALSE ); return;
	case OP_LDA:	decode_diadic_address( w, "LDA"    , FALSE, FALSE ); return;
	case OP_LDHI:	decode_diadic_address( w, "LDHI"   , FALSE, FALSE ); return;
d1973 3
a1975 1
decode( int w )
d1983 1
a1983 1
  switch ((w >> 30) & 0x3)
d1986 4
a1989 4
    case 0: decode_sequential_op( w ); return;
    case 1: decode_flow_control(  w ); return;
    case 2: decode_non_word_load_or_triadic( w ); return;
    case 3: decode_parallel_op(   w ); return;
d2097 1
a2097 1
static int
d2184 1
a2184 1
static int
d2238 2
a2239 1
	    int		trace )
d2244 1
a2244 1
  int		show_code = FALSE;
d2292 3
a2294 1
      myprint( "%4d", word_address );
d2296 1
a2296 1
      pad_to( COL_WORD );
d2298 2
a2299 1
      myprint( "0x%08.8x ", value );
a2302 2
	  pad_to( COL_OP_CODE );

d2305 3
a2307 1
	      myprint( "%s():", func_name );
d2309 11
d2356 21
a2376 1
	  pad_to( COL_BYTES );
d2378 5
a2382 4
	  print_byte( value >> 24 );
	  print_byte( value >> 16 );
	  print_byte( value >>  8 );
	  print_byte( value );
d2387 3
a2389 1
	    decode( value );
d2405 1
a2405 1
      if (trace && pnext_branch && word_address == pnext_branch->address_refered_to)
d2442 1
d2459 2
a2460 1
  int		trace = TRUE;
d2496 4
d2516 2
d2522 1
a2522 1
	  disassemble( input, trace );
d2534 1
a2534 1
      disassemble( stdin, FALSE );
@
