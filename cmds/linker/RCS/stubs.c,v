head	1.19;
access;
symbols
	Helios_1_3_1:1.16
	Helios_C40_1_3_Official_Release:1.13
	Alenia_release:1.13
	C40_Field_Test_2:1.13;
locks; strict;
comment	@ * @;


1.19
date	94.01.11.16.08.32;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	94.01.11.11.32.57;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	93.11.19.14.33.11;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	93.09.20.15.21.41;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	93.09.13.12.01.11;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	93.08.18.18.27.22;	author paul;	state Exp;
branches;
next	1.13;

1.13
date	92.10.05.10.19.45;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	92.10.05.08.51.39;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	92.10.02.11.57.05;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	92.10.02.08.20.22;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	92.09.21.16.51.24;	author martyn;	state Exp;
branches;
next	1.8;

1.8
date	92.09.16.11.18.44;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	92.09.15.08.37.49;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	92.09.14.08.34.30;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	92.09.14.08.24.09;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	92.09.11.17.07.21;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	92.07.15.09.26.39;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	92.07.14.07.59.17;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	92.07.13.08.52.23;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.19
log
@fixed bug when branch stubs appear before calling stubs
@
text
@/*
 * stubs.c : 	stub generation file for the Helios Linker
 *
 *   Copyright (c) 1992 - 1994 Perihelion Software Ltd.
 *     All rights reserved.
 *
 * Author :	N Clifton
 * Version :	$Revision: 1.18 $
 * Date :	$Date: 1994/01/11 11:32:57 $
 * Id :		$Id: stubs.c,v 1.18 1994/01/11 11:32:57 nickc Exp nickc $
 */

/*{{{  Headers */

#include "link.h" /* needed for definition of NEW_STUBS amoungst other things */

#include <unistd.h>	/* for SEEK_SET */
#include <module.h>	/* for Module structure */

/*}}}*/
#ifdef NEW_STUBS
/*{{{  Macros */

#define trace 	if (traceflags & db_stubs) _trace

/*}}}*/
/*{{{  Types */

typedef enum
  {
    CALLING_STUB,			/* ordinary calling stub */
    LOCAL_ADDR_STUB,			/* address returning stub for symbols in ordinary modules */
    SHARED_ADDR_STUB			/* address returning stub for symbols in shared library modules */
  }
StubType;

typedef struct
  {
    VMRef	next;			/* link into chain of stubs                  */
    VMRef	name_sym;		/* the symbol naming the stub		     */
    VMRef	symbol;			/* the symbol represented by this stub       */
    WORD	id;			/* id of the module containing the symbol    */
    WORD	offset;			/* byte offset of symbol within the module   */
    WORD	position;		/* byte position of the stub within the file */
    StubType	type;			/* the nature of the stub                    */
  }
Stub;

typedef struct
  {
    VMRef	vNext;			/* Link into the chain of branch stubs		*/
    VMRef	vSymbol;		/* The symbol to which this stub branches	*/
    WORD	iOffset;		/* This is the stub's offset into the codetable */
  }
BranchStub;

/*}}}*/
/*{{{  Variables */

extern  word	lastm;		/* Highest assigned module number, defined in module.c */
extern word	nchars;		/* Number of characters written, defined in genimage.c */

PRIVATE word	totalstubsize = 0;		/* Number of bytes of stubs produced */
PRIVATE word	iBranchCount  = 0;		/* Number of byes of branch stubs made */
PRIVATE int	inited        = 0;		/* True if structures are initialised */
PRIVATE VMRef	stub_list;			/* Linked list of stubs */
PRIVATE VMRef	stub_heap;			/* Heap to allocate new stub structures */
PRIVATE VMRef	vStubModule;			/* Fake module used by stub code */
PRIVATE VMRef	vBranchStubList;		/* Linked list of branch stubs */
PRIVATE word	iModuleNchars;			/* Start "address" of fake module */
PRIVATE word	iBranchNchars;			/* Start "address" of branch stubs */
PRIVATE word	iCallingStubStart;		/* where the next calling stub is located */

/*}}}*/
/*{{{  Functions */

#ifdef __C40
/*{{{  C40 Functions */

/*{{{  Macros */

#define fits_in_8_bits( val )		(((val) & 0xffffff80U) == 0 || ((val) & 0xffffff80U) == 0xffffff80U)
#define fits_in_16_bits( val )		(((val) & 0xffff8000U) == 0 || ((val) & 0xffff8000U) == 0xffff8000U)
#define fits_in_24_bits( val )		(((val) & 0xff800000U) == 0 || ((val) & 0xff800000U) == 0xff800000U)
#define LINKER_MODULE_NAME   "Fake Linker Module";

/*}}}*/
/*{{{  stub_size */

/*
 * returns the size (in bytes) that the calling stub will be when it is created
 */

PRIVATE WORD
stub_size( Stub * stub )
{
  WORD	size;


  if (stub->type == LOCAL_ADDR_STUB)
    {
      size = 6;
    }
  else
    {
      size = 3;
  
      if (!fits_in_8_bits( stub->id ))
	size += 2;

      if (!fits_in_8_bits( stub->offset >> 2 ))
	++size;

      if (size == 3 && stub->type == SHARED_ADDR_STUB)
	{
	  size = 4;
	}
    }
  
  return size * sizeof (WORD);
  
} /* stub_size */

/*}}}*/
/*{{{  branch_size */

/*
 * returns the size (in bytes) that the branch stub will be when it is created
 */

PRIVATE WORD
branch_size( BranchStub * stub )
{
  return sizeof (WORD);
  
} /* branch_size */

/*}}}*/
/*{{{  build_stub */

/*
 * create a calling stub
 */

PRIVATE void
build_stub( VMRef s )
{
  Stub *	stub;
  WORD		id;
  WORD		offset;
  char *	name;
  

  /* get hold of the stub */
  
  stub = VMAddr( Stub, s );
  name = VMAddr( Symbol, stub->symbol )->name;
  stub = VMAddr( Stub, s );
  
  trace( "building %s stub for %s at %d",
	stub->type == CALLING_STUB    ? "calling"              :
	stub->type == LOCAL_ADDR_STUB ? "local address "       :
	                                "module table address" ,
	name,
	nchars );

  if (stub->position != nchars)
    {
      warn( "Stub out of position.  Should be at %d (%d), is at %d (%d)",
	   stub->position, stub->position >> 2, nchars, nchars >> 2 );

      return;
    }

  id     = stub->id;
  offset = stub->offset >> 2;
  
  /* now create the calling stub */

  if (stub->type == CALLING_STUB)
    {
      /* create an ordinary stub */
      
      if (fits_in_8_bits( id ))
	{
	  if (fits_in_8_bits( offset ))
	    {
	      outword( 0x1Ecd0400UL + (id     & 0xff) );	/* LDA *+AR4(    id  ), AR5 */
	      outword( 0x1Ecd0500UL + (offset & 0xff) );	/* LDA *+AR5( offset ), AR5 */
	      outword( 0x6800000dUL );				/* Bu    AR5                */
	    }
	  else
	    {
	      /* symbol's offset within the code table is >= 256 */
	      
	      if (!fits_in_16_bits( offset ))
		{
		  warn( "Stub Creation: offset out of range for %s", name );
		  
		  return;	      
		}
	      
	      outword( 0x1Ecd0400UL + (id     & 0xff) );	/* LDA  *+AR4( id ), AR5 */
	      outword( 0x026d0000UL + (offset & 0xffff) );	/* ADDI   offset,    AR5 */
	      outword( 0x1Ecdc500UL );				/* LDA   *AR5,       AR5 */	  
	      outword( 0x6800000dUL );				/* Bu     AR5            */
	    }
	}
      else
	{
	  if (!fits_in_16_bits( id ))
	    {
	      warn( "Stub Creation: module id out of range for %s", name );
	      
	      return;	      
	    }
	  
	  /* symbol's module number is >= 256 */
	  
	  if (fits_in_8_bits( offset ))
	    {
	      outword( 0x1e8d000cUL );				/* LDA	 AR4,           AR5 */
	      outword( 0x026d0000UL + (id & 0xffff) );		/* ADDI  id,            AR5 */
	      outword( 0x1Ecdc500UL );				/* LDA  *AR5,           AR5 */	  
	      outword( 0x1Ecd0500UL + (offset & 0xff) );	/* LDA *+AR5( offset ), AR5 */
	      outword( 0x6800000dUL );				/* Bu    AR5                */	  
	    }
	  else
	    {
	      /* symbol's offset within the code table is >= 256 */
	      
	      if (!fits_in_16_bits( offset ))
		{
		  warn( "Stub Creation: offset out of range for %s", name );
		}
	      
	      outword( 0x1e8d000cUL );				/* LDA	 AR4,    AR5 */
	      outword( 0x026d0000UL + (id & 0xffff) );		/* ADDI  id,     AR5 */
	      outword( 0x1Ecdc500UL );				/* LDA  *AR5,    AR5 */
	      outword( 0x026d0000UL + (offset & 0xffff) );	/* ADDI  offset, AR5 */
	      outword( 0x1Ecdc500UL );				/* LDA  *AR5,    AR5 */	  
	      outword( 0x6800000dUL );				/* Bu    AR5         */
	    }
	}
    }
  else
    {
      /*
       * Create an address stub.
       *
       * An address stub is a stub which returns the
       * address of the function it represents.  These
       * are needed because when C code performs the
       * comparision of two function addresses it MUST
       * use the actual addresses, and not the addresses
       * of any calling stubs.  In particular the signal
       * handling routines in the POSIX library check
       * to see if the signal handler is being reset to
       * SIG_DFL.  Unfortunatly since the code calling
       * signal() is in an ordinary module, the pointer
       * it would normally pass in is the address of the
       * calling stub for SIG_DFL.  In the POSIX library,
       * however, the address of the real SIG_DFL is
       * available, and it is this that is used for
       * performing the comparison.  Hence the need for
       * this sort of stub.  What it does is return the
       * address of the real function.  For a function
       * in an ordinary module this is simply a case of
       * resolving the symbol.  For functions in resident
       * library's the address must be obtained via the
       * module table.
       */

      if (stub->type == LOCAL_ADDR_STUB)
	{
	  VMRef		mod;
	  VMRef		syms_mod;	  
	  Symbol *	sym;
	  char *	name;
	  word		size;
	  word		loc;
	  uword		pos;
	  

	  pos = stub->position;
	  
	  /* locate the symbol's module */

	  mod = module0;

	  sym = VMAddr( Symbol, stub->symbol );

	  syms_mod = sym->module;
	  name     = sym->name;
	  loc      = VMAddr( Code, sym->value.v )->loc;
	  size     = 0;

	  while (!NullRef( mod ) && mod != syms_mod)
	    {
	      asm_Module *	m;

	      
	      m = VMAddr( asm_Module, mod );
	      
	      size += m->length;
	      
	      mod = m->next;
	    }

	  if (NullRef( mod ))
	    {
	      warn( "Could not find local module containing symbol %s", name );

	      return;
	    }

	  trace( "offset of local symbol's module is %d", size );
	  trace( "symbol's offset = %d", loc );

	  pos -= loc + size;

	  pos /= sizeof (word);
	  
	  trace( "distance between stub and symbol = %d", pos );

	  pos += 5;	   /* allow for distance between start of stub and location placed in R11 */
	  
	  outword( 0x0819001fUL );			/* LDI   R11, RS  */
	  outword( 0x63000001UL );			/* LAJ  +1        */
	  outword( 0x1fed0000UL | pos >> 16    );	/* LDHI  0,   AR5 */
	  outword( 0x106d0000UL | pos & 0xffff );	/* OR    0,   AR5 */
	  outword( 0x198d001fUL );			/* SUBRI R11, AR5 */
	  outword( 0x68000019UL );			/* Bu    RS       */
	}
      else
	{
	  /* have to use the module table */
	  
	  if (fits_in_8_bits( id ))
	    {
	      if (fits_in_8_bits( offset ))
		{
		  outword( 0x6820001fUL );			/* BuD   R11                */
		  outword( 0x1Ecd0400UL + (id     & 0xff) );	/* LDA *+AR4(    id  ), AR5 */
		  outword( 0x1Ecd0500UL + (offset & 0xff) );	/* LDA *+AR5( offset ), AR5 */
		  outword( 0x0c800000UL );			/* NOP                      */
		}
	      else
		{
		  /* symbol's offset within the code table is >= 256 */
	      
		  if (!fits_in_16_bits( offset ))
		    {
		      warn( "Stub Creation: offset out of range for %s", name );
		      
		      return;
		    }
		  
		  outword( 0x6820001fUL );			/* BuD   R11                */
		  outword( 0x1Ecd0400UL + (id     & 0xff) );	/* LDA  *+AR4( id ), AR5 */
		  outword( 0x026d0000UL + (offset & 0xffff) );	/* ADDI   offset,    AR5 */
		  outword( 0x1Ecdc500UL );			/* LDA   *AR5,       AR5 */	  
		}
	    }
	  else
	    {
	      if (!fits_in_16_bits( id ))
		{
		  warn( "Stub Creation: module id out of range for %s", name );
		  
		  return;	      
		}
	      
	      /* symbol's module number is >= 256 */
	  
	      if (fits_in_8_bits( offset ))
		{
		  outword( 0x1e8d000cUL );			/* LDA	 AR4,           AR5 */
		  outword( 0x6820001fUL );			/* BuD   R11                */
		  outword( 0x026d0000UL + (id & 0xffff) );	/* ADDI  id,            AR5 */
		  outword( 0x1Ecdc500UL );			/* LDA  *AR5,           AR5 */	  
		  outword( 0x1Ecd0500UL + (offset & 0xff) );	/* LDA *+AR5( offset ), AR5 */
		}
	      else
		{
		  /* symbol's offset within the code table is >= 256 */
	      
		  if (!fits_in_16_bits( offset ))
		    {
		      warn( "Stub Creation: offset out of range for %s", name );
		      
		      return;	      
		    }
	      
		  outword( 0x1e8d000cUL );			/* LDA	 AR4,    AR5 */
		  outword( 0x026d0000UL + (id & 0xffff) );	/* ADDI  id,     AR5 */
		  outword( 0x6820001fUL );			/* BuD   R11         */
		  outword( 0x1Ecdc500UL );			/* LDA  *AR5,    AR5 */
		  outword( 0x026d0000UL + (offset & 0xffff) );	/* ADDI  offset, AR5 */
		  outword( 0x1Ecdc500UL );			/* LDA  *AR5,    AR5 */	  
		}
	    }
	}
    }
  
  return;
  
} /* build_stub */

/*}}}*/
/*{{{  GenerateBranchStub */

PRIVATE void
GenerateBranchStub( VMRef vBranchStub )
{
  VMRef		vSymbol;
  BranchStub *	pBranchStub;
  Symbol *      pSymbol;
  word		iOffset;
  char		name[ 128 ];	/* XXX */
  

  pBranchStub = VMAddr( BranchStub, vBranchStub );
  
  if (NullRef( pBranchStub ))
    {
      trace( "stubs: unable to find next branch stub" );
      return;
    }

  strcpy( name, VMAddr( Symbol, pBranchStub->vSymbol )->name );

  name[ 0 ] = '.';

  vSymbol = lookup( name );

  if (NullRef( vSymbol ))
    trace( "Branch symbol no longer exists" );

  if (!VMAddr( asm_Module, VMAddr( Symbol, vSymbol )->module )->linked)
    trace( "stubs: module containing destination of branch is not linked!" );
  
  iOffset = FindSymbolOffset( vSymbol );
  
  pSymbol = VMAddr( Symbol, vSymbol );

  iOffset -= (nchars - iModuleNchars);

  iOffset >>= 2;	/* convert from bytes to words */
  
  iOffset -= 1;
  
  trace( "generate a branch stub for %s, at offset %d", pSymbol->name, iOffset );
	
  outword( 0x60000000 | (iOffset & 0x00FFFFFF) ); /* BR */
  
  return;
  
} /* GenerateBranchStub */

/*}}}*/
/*{{{  GenerateInitCode */

/*
 * Generate code to initialise the linker's
 * fake module's code table.
 */

PRIVATE void
GenerateInitCode( void )
{
  word	iModId;
  word	iOffset;
  word	iInitNchars = nchars;
  
  
  trace( "Generating module initialisation code" );
  
#ifdef __SMT
  iModId = VMAddr( asm_Module, vStubModule )->id * 2 + 1;
#else
  iModId = VMAddr( asm_Module, vStubModule )->id;
#endif
  
  /* generate initiale sequence */
  
  outword( 0x04e00002 ); 		/* CMPI  2,   R0  */
  outword( 0x6806001f );		/* Bne   R11      */
  outword( 0x1e8a001f );		/* LDA   R11, AR2 */
  outword( 0x63000001 );		/* LAJ   + 1      */
  outword( 0x1e8d000c );		/* LDA   AR4, AR5 */
  outword( 0x026d0000 + iModId );	/* ADDI  mod, AR5 */
  outword( 0x1ecdc500 );		/* LDA  *AR5, AR5 */
  
  /* calculate where the branch stubs start */
  
  iOffset   = nchars;			/* LAJ goes to this "address" */
  iOffset  -= iBranchNchars;		/* calculate distance to start of branches */
  iOffset >>= 2;			/* convert from bytes to words */

  /* generate the code to initialise the branch stub addresses */
  
  while (iBranchCount)
    {
      trace( "Offset is %d", iOffset );
      
      if (fits_in_8_bits( iOffset ))
	{
	  outword( 0x37191f00 | (iOffset & 0xFF) );	/* SUBI3 off, R11, RS  */
	}
      else
	{
	  outword( 0x0819001f );			/* LDI  R11, RS */
	  outword( 0x18790000 | (iOffset & 0xFFFF) );	/* SUBI off, RS */
	}
      
      outword( 0x15592501 );			/* STI   RS, *AR5++(1) */
      
      iOffset      -= 1;
      iBranchCount -= 4;
    }
  
  /* finish the initialisation code */
  
  outword( 0x6800000a );	/* Bu	 AR2           */
  
  /* adjust code size to include init code */
  
  totalcodesize += (nchars - iInitNchars);
  
  return;
  
} /* GenerateInitCode */

/*}}}*/

/*}}}*/
#else /* ! __C40 */
#error Unknown processor type for stub creation
#endif /* __C40 */

/*{{{  Generic Functions */

/*{{{  InitStubs */

PRIVATE void
InitStubs( void )
{
  asm_Module *	pModule;
  word		i;
  

  /* adjust codesize to include the stub module */
  
  totalcodesize += sizeof (Module);

  /* initialise global variables */
  
  stub_list       = NullVMRef;
  vBranchStubList = NullVMRef;
  stub_heap       = VMPage();
  vStubModule     = VMalloc( sizeof (asm_Module), stub_heap );
  
  if (NullRef( vStubModule ))
    {
      trace( "URG - out of memory create StubModule\n" );
    }

  /* fill in the stub module structure */
  
  pModule = VMAddr( asm_Module, vStubModule );
  
  VMDirty( vStubModule );
  
  pModule->next      = NullVMRef;
  pModule->start     = NullVMRef;
  pModule->end	     = NullVMRef;
  pModule->refs      = NullVMRef;
  pModule->id        = ++lastm;
  pModule->linked    = TRUE;
  pModule->length    = 0;
  pModule->file_name = LINKER_MODULE_NAME;
  
   for ( i = 0; i < LOCAL_HASHSIZE ; i++ )
     {
       pModule->symtab[ i ].head    = NullVMRef,
       pModule->symtab[ i ].entries = 0;
     }

  trace( "Linker's fake module number is %d", lastm );
  
  /* note that we have performed the initialisation */
  
  inited = 1;

  trace( "Stubs initialised" );

  flush_output_buffer();

  iCallingStubStart = totalcodesize;
  
  return;
  
} /* InitStubs */

/*}}}*/
/*{{{  new_stub */

/*
 * Add a request for a stub calling 'symbol'.
 * Returns the byte offset from the start of the
 * file of where the calling stub will be located.
 */

WORD
new_stub(
	 VMRef	symbol,
	 bool	addr_stub )	/* true if this is an address stub */
{
  VMRef		name_sym;
  VMRef		module;  
  VMRef		s;
  Stub *	stub;
  Symbol *	sym;
  asm_Module *	mod;
  WORD		offset;
  WORD		id;
  WORD		pos;
  StubType	stub_type;
  char *	sname;
  word		iSize;
  

  if (!inited)
    InitStubs();
  
  sname = VMAddr( Symbol, symbol )->name;
  
  trace( "new %s stub request for %s",
	addr_stub ? "address" : "ordinary",
	sname );
  
  name_sym = symbol;
  
  /* search stub list for an already existing stub */
  
  s = stub_list;
  
  while (!NullRef( s ))
    {
      stub = VMAddr( Stub, s );
      
      if (VMSame( stub->name_sym, name_sym ))
	break;
      
      s = stub->next;
    }
  
  /* check the result of the search */
  
  if (!NullRef( s ))
    {
      stub = VMAddr( Stub, s );
      
      trace( "stub already exists at %d", stub->position );
      
      /* stub has already been allocated, just return its location */
      
      return stub->position;
    }
  
  /* no stub found - create a new one */
  
  if (!NullRef( stub_heap ))
    s = VMalloc( sizeof (Stub), stub_heap );
  
  if (NullRef( s ))
    {
      /* run out of space in current heap - get a new one */
	  
      stub_heap = VMPage();
      s         = VMalloc( sizeof (Stub), stub_heap );	  
    }
  
  if (addr_stub)
    {
      char	name[ 128 ];		/* XXX */
      
      
      /* default type */
      
      stub_type = LOCAL_ADDR_STUB;
      
      /* get hold of the symbol */
      
      sym = VMAddr( Symbol, symbol );
      
      /* duplicate name leaving off the "_addr" bit */
      
      strcpy( name, ((char *)&(sym->name[ 0 ])) + 5 );
      
      /* find the associated shared library symbol */
      
      symbol = lookup( name );
      
      if (symbol == NullVMRef)
	{
	  /* Could not find ".<symbol>" - hence it should be in a resident library */
	  
	  stub_type = SHARED_ADDR_STUB;
	}
      else
	{
	  /* check the type of the symbol */
      
	  sym = VMAddr( Symbol, symbol );

	  if (sym->type != S_CODESYMB)
	    {
	      /* ".<symbol> exists but it is not a code symbol - hence it should be ignored */
	      
	      stub_type = SHARED_ADDR_STUB;
	    }
	}

      if (stub_type == SHARED_ADDR_STUB)
	{
	  name[ 0 ] = '_';

	  trace( "looking up shared symbol %s", name );
	  
	  symbol = lookup( name );

	  if (symbol == NullVMRef)
	    {
	      warn( "Attempting to take address of unknown function %s", name + 1 );

	      return 0;
	    }

	  trace( "stub is in shared library" );
	}
      else
	{
	  trace( "stub is local" );
	}
      
      /* check the type of the symbol */
      
      sym = VMAddr( Symbol, symbol );
      
      if (sym->type == S_UNBOUND)
	{
	  warn( "Address of function \"%s\" is used, but it is not defined", name );
	  
	  return 0;
	}
	
      if (stub_type == LOCAL_ADDR_STUB && sym->type != S_CODESYMB)
	{
	  warn( "Address of function \"%s\" is used, but defined in '%s' as something else (%x)",
	       name + 1, sym->file_name, sym->type );
	  
	  return 0;
	}
      else if (stub_type == SHARED_ADDR_STUB && sym->type != S_FUNCDONE)
	{
	  warn( "Address of function \"%s\" is used, but defined in '%s' as something else (%x)",
	       name + 1, sym->file_name, sym->type );
	  
	  return 0;
	}
      
      sym->referenced = 1;
    }
  else
    {
      stub_type = CALLING_STUB;
      
      /* get hold of the symbol */
      
      sym = VMAddr( Symbol, symbol );

      if (sym->type != S_FUNCDONE)
	{
	  warn( "Function Stub \"%s\" is type %x", sym->name, sym->type );

	  return 0;
	}
    }

  sname = sym->name;
  
  trace( "creating a new %s stub for %s",
	addr_stub ? "address" : "ordinary",
	sname );
  
  /* get hold of the symbol's byte offset within it's module */
  
  offset = sym->value.w;

  trace( "%s's offset is %x", sym->name, offset >> 2 );

  module = sym->module;
  
  if (NullRef( module ))
    {
      trace( "symbol has no module!" );

      return 0;      
    }

  /* get the id of the module containing the symbol */
  
  mod  = VMAddr( asm_Module, module );

  id   = mod->id;

  if (id == -1)
    warn( "Module %s containing function %s is not linked!", mod->file_name, sname );

  if (smtopt)
    id = id * 2 + 1;
  
  trace( "symbol's module id is %d, slot number %d", mod->id, id );
  
  stub = VMAddr( Stub, s );

  VMDirty( s );
  VMlock(  s );
      
  /* fill in stub */

  flush_output_buffer();
  
  pos = iCallingStubStart;

  trace( "stub's position is %d", pos );
  
  stub->symbol   = symbol;
  stub->name_sym = name_sym;
  stub->position = pos;
  stub->id       = id;
  stub->offset   = offset;
  stub->type     = stub_type;
  
  /* add stub to chain */
      
  stub->next   = stub_list;
  stub_list    = s;
  
  /* adjust code size to account for (as yet uncreated) stub */

  iSize = stub_size( stub );
  
  totalcodesize     += iSize;
  totalstubsize     += iSize;
  iCallingStubStart += iSize;
  
  trace( "stub's size is %d", stub_size( stub ) );
  
  /* release lock on stub */
      
  VMunlock( s );

  /* return the location of the stub */
  
  return pos;
  
} /* new_stub */ 

/*}}}*/
/*{{{  RequestBranchStub */

/*
 * Add a request for a stub that branches to 'symbol'
 * and which has an address stored in a module's
 * codetable.  This will allow code that has been
 * moved in memory (because of AccelerateCode()),
 * to call functions outside of itself.  The symbol
 * does not yet have a module associated with it,
 * so fill this in.
 */

void
RequestBranchStub( VMRef vSymbol )
{
  VMRef		vBranchStub;
  Symbol *	pSymbol;
  BranchStub *	pBranchStub;
  Code *	pCode;
  word		iSize;
  
  
  if (!inited)
    InitStubs();

  trace( "Request for a branch stub for %s",
	 VMAddr( Symbol, vSymbol )->name );

  /* create new new Branch stub entry */
  
  if (!NullRef( stub_heap ))
    vBranchStub = VMalloc( sizeof (BranchStub), stub_heap );
  
  if (NullRef( vBranchStub ))
    {
      /* run out of space in current heap - get a new one */
	  
      stub_heap   = VMPage();
      vBranchStub = VMalloc( sizeof (BranchStub), stub_heap );	  
    }
  
  pBranchStub = VMAddr( BranchStub, vBranchStub );

  VMDirty( vBranchStub );
  VMlock(  vBranchStub );
      
  /* fill in branch stub */

  pBranchStub->vSymbol = vSymbol;
  pBranchStub->iOffset = iBranchCount;

  trace( "Branch stub's count is %d", iBranchCount );
  
  /* add stub to chain */
      
  pBranchStub->vNext = vBranchStubList;
  vBranchStubList    = vBranchStub;
  
  /* release lock on stub */
      
  VMunlock( vBranchStub );

  /* now fill in the symbol's information */
     
  pSymbol = VMAddr( Symbol, vSymbol );

  VMDirty( vSymbol );
  VMlock(  vSymbol );
  
  pSymbol->type      = S_FUNCDONE;
  pSymbol->module    = vStubModule;
  pSymbol->file_name = LINKER_MODULE_NAME;
  pSymbol->value.w   = iBranchCount;
  
  pCode = VMAddr( Code, pSymbol->value.v );

  if (NullRef( pCode ))
    {
      warn( "Stubs: cannot find Code structure for branch stub" );
    }
  else
    pCode->loc = iBranchCount;
 
  VMunlock( vSymbol );

  /* increment the branch count */

  pBranchStub = VMAddr( BranchStub, vBranchStub );

  iSize = branch_size( pBranchStub );
  
  iBranchCount += iSize;
  
  /* adjust code size to account for (as yet uncreated) stub */

  totalcodesize += iSize;

  return;
  
} /* RequestBranchStub */ 

/*}}}*/
/*{{{  build_stubs */

/*
 * Called at the end of the linking process.
 * This creates all the necessary calling stubs,
 * and appends them to the end of the code
 */

PUBLIC void
build_stubs( void )
{
#if (defined HOSTISBIGENDIAN && defined __BIGENDIAN) || (!defined HOSTISBIGENDIAN && !defined __BIGENDIAN)
  word *     pModuleName = (word *)"StubModule\0                     ";/* 32 bytes including \0 */
#else
  word *     pModuleName = (word *)"butSudoM \0el                    ";/* 32 bytes including \0 */
#endif
  VMRef		prev;  
  VMRef		s;
  asm_Module *	pModule;
  word	        iModuleSize;
  

  if (!inited)
    return;

  /*{{{  Build Module Header */

  trace( "building module header" );
  
  flush_output_buffer();
  lseek( outf, (off_t)-sizeof (WORD), SEEK_END );	/* over-write trailing zero word */
  nchars -= sizeof (WORD);				/* adjust output count */
  iModuleNchars = nchars;				/* remember start "address" of module */
  
  /* build module structure */

  pModule = VMAddr( asm_Module, vStubModule );
      
  outword( T_Module );
  flush_output_buffer();
  iModuleSize = nchars + 3 * sizeof (WORD);
  outword( 0 );	    		/* size in bytes of module */
  outword( pModuleName[ 0 ] );	/* Name */
  outword( pModuleName[ 1 ] );
  outword( pModuleName[ 2 ] );
  outword( pModuleName[ 3 ] );
  outword( pModuleName[ 4 ] );
  outword( pModuleName[ 5 ] );
  outword( pModuleName[ 6 ] );
  outword( pModuleName[ 7 ] );
  outword( pModule->id );	/* Id */
  outword( 0x1 );		/* Version */
#ifdef __SMT
  outword( 0 );			/* MaxData */
  if (iBranchCount > 0)
    outword( totalstubsize + iBranchCount + 2 * sizeof (WORD) );	/* Root of Init Chain */
  else
    outword( 0 );		/* No Init Chain */
  outword( iBranchCount );	/* MaxCodeP */
#else
  outword( iBranchCount );	/* MaxData */
  if (iBranchCount > 0)
    outword( totalstubsize + iBranchCount + 2 * sizeof (WORD) );	/* Root of Init Chain */
  else
    outword( 0 );		/* No Init Chain */
#endif

  /*}}}*/

  /*{{{  Build Calling Stubs */

  /* scan stub list reversing pointers ! */

  prev = NullVMRef;
  s    = stub_list;
  
  while (!NullRef( s ))
    {
      VMRef	next;      
      Stub *	stub;


      stub = VMAddr( Stub, s );

      next = stub->next;

      stub->next = prev;

      prev = s;

      s = next;      
    }

  trace( "building calling stubs" );
  
  s = stub_list = prev;
  
  /* now scan stub list building stubs */
  
  while (!NullRef( s ))
    {
      build_stub( s );
      
      s = VMAddr( Stub, s )->next;
    }

  trace( "built calling stubs" );

  /*}}}*/

  /*{{{  Build  Branch Stubs */

  /* get hold of the last module known to the linker */
  
  pModule = VMAddr( asm_Module, tailmodule );

  VMDirty( tailmodule );

  /* set the next pointer to point to the stub module */

  tailmodule = pModule->next = vStubModule;

  /* make the stub module be the last module */
  
  flush_output_buffer();
  curmod = tailmodule = vStubModule;
  codepos = 0;
  iBranchNchars = nchars;

  trace( "building branch stubs" );
  
  /* scan branch stub list reversing pointers ! */

  prev = NullVMRef;
  s    = vBranchStubList;
  
  while (!NullRef( s ))
    {
      VMRef		vNext;      
      BranchStub *	pBranchStub;


      pBranchStub = VMAddr( BranchStub, s );

      vNext = pBranchStub->vNext;

      pBranchStub->vNext = prev;

      prev = s;

      s = vNext;      
    }

  /* build the Branch stubs */

  for (s = vBranchStubList = prev;
       !NullRef( s );
       s = VMAddr( BranchStub, s )->vNext)
    {
      GenerateBranchStub( s );
    }

  if (iBranchCount)
    {
      /* Generate Module initialisation code */

      outword( 0 ); /* end of init chain */
      totalcodesize += sizeof (WORD);

      GenerateInitCode();
    }

  trace( "built branch stubs" );

  /*}}}*/

  /*{{{  Tidy Up Loose Ends */

  trace( "finishing up" );

  /* add the final zero word to finish off the module chain */
  
  outword( 0 );

  /* make sure that everything has been written out */
  
  flush_output_buffer();

  /* initialise the module structure's size field */

  if (lseek( outf, (off_t)(iModuleSize), SEEK_SET ) != iModuleSize)
    trace( "OH HELL" );

  outword( nchars - iModuleNchars - sizeof (WORD) );
  flush_output_buffer();

  if (gen_image_header)
    {
      /* confirm value of totalcodesize */
  
      if (lseek( outf, (off_t)0, SEEK_END ) != totalcodesize + 4 * sizeof (WORD))
	warn( "Stubs: end of file = %ld, should be = %ld",
	      lseek( outf, (off_t)0, SEEK_END ),
	      totalcodesize + 4 * sizeof (WORD) );
 
      /* finally update image with correct size */

      trace( "resetting code size to %d", totalcodesize + sizeof (WORD) );
  
      (void) lseek( outf, (off_t) 2 * sizeof (WORD), SEEK_SET );
      
      outword( totalcodesize + 1 * sizeof (WORD) );	/* remember trailing zero */
    }

  flush_output_buffer();

  trace( "stubs module built" );

  /*}}}*/

  return;
  
} /* build_stubs */

/*}}}*/

#ifdef SUN4
/*{{{  SUN4 functions */

/*
 * The gcc compiler appears to generate references to the following functions
 * without providing them in a standard library.  Since the code for the
 * linker does not use either of them, they are provided here as stubs
 */

int ___assert( void ) { return 0; }
int ___typeof( void ) { return 0; }  

/*}}}*/
#endif /* SUN4 */

/*}}}*/

/*}}}*/
#endif /* NEW_STUBS */

/* end of stubs.c */
@


1.18
log
@added tailmodule update
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.17 $
 * Date :	$Date: 1993/11/19 14:33:11 $
 * Id :		$Id: stubs.c,v 1.17 1993/11/19 14:33:11 nickc Exp nickc $
d65 1
a65 1
PRIVATE int	inited        = 0;		/* True if structures are initialised */  
d72 1
d169 1
a169 1
      trace( "Stub out of position.  Should be at %d (%d), is at %d (%d)",
d249 1
a249 1
       * Create a address stub.
d597 4
d631 1
d834 3
a836 1
  pos = totalcodesize;
d854 5
a858 2
  totalcodesize += stub_size( stub );
  totalstubsize += stub_size( stub );
d892 1
d898 2
a899 1
  trace( "Request for a branch stub for %s", VMAddr( Symbol, vSymbol )->name );
a930 4
  /* adjust code size to account for (as yet uncreated) stub */

  totalcodesize += branch_size( pBranchStub );
  
d951 1
a951 1
      trace( "URG IRG" );
d961 2
d964 3
a966 1
  iBranchCount += branch_size( pBranchStub );
d968 2
d1068 1
a1068 1
  trace( "building stubs" );
d1081 2
d1147 2
d1176 1
a1176 1
	trace( "URG ftell = %ld, size = %ld",
d1191 1
a1191 2
  trace( "stubs built" );
  
@


1.17
log
@fixed name of module to be exactly 32 characters long (was only 31)
@
text
@d4 1
a4 1
 *   Copyright (c) 1992 - 1993 Perihelion Software Ltd.
d8 3
a10 3
 * Version :	$Revision: 1.16 $
 * Date :	$Date: 1993/09/20 15:21:41 $
 * Id :		$Id: stubs.c,v 1.16 1993/09/20 15:21:41 nickc Exp nickc $
d168 1
a168 1
      warn( "Stub out of position.  Should be at %d (%d), is at %d (%d)",
d426 1
a426 1
      trace( "URG1" );
d437 4
a440 1
    trace( "UU" );
d1077 2
a1078 2
  
  pModule->next = vStubModule;
@


1.16
log
@fixed bugs for non-branch stub linked programs
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.15 $
 * Date :	$Date: 1993/09/13 12:01:11 $
 * Id :		$Id: stubs.c,v 1.15 1993/09/13 12:01:11 nickc Exp nickc $
d969 1
a969 1
  word *	pModuleName = (word *)"StubModule\0                    ";/* 32 bytes including \0 */
d971 1
a971 1
  word *	pModuleName = (word *)"butSudoM \0el                   ";/* 32 bytes including \0 */
@


1.15
log
@Added code to create Branch Stubs and to encapsulate stubs in a module
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.14 $
 * Date :	$Date: 1993/08/18 18:27:22 $
 * Id :		$Id: stubs.c,v 1.14 1993/08/18 18:27:22 paul Exp nickc $
d1011 4
a1014 1
  outword( totalstubsize + iBranchCount + 2 * sizeof (WORD) );	/* Root of Init Chain */
d1018 4
a1021 1
  outword( totalstubsize + iBranchCount + sizeof (WORD) );	/* Root of Init Chain */
d1117 3
a1119 1
  /* Generate Module initialisation code */
d1121 2
a1122 2
  outword( 0 ); /* end of init chain */
  totalcodesize += sizeof (WORD);
d1124 2
a1125 1
  GenerateInitCode();
@


1.14
log
@Now supports -i option to disable the generation of std image header and
zero byte tail.
(used for ROM bootstrap).
@
text
@d4 1
a4 1
 *   Copyright (c) 1992 Perihelion Software Ltd.
d8 3
a10 3
 * Version :	$Revision: 1.13 $
 * Date :	$Date: 1992/10/05 10:19:45 $
 * Id :		$Id: stubs.c,v 1.13 1992/10/05 10:19:45 nickc Exp $
d13 2
d17 2
d20 1
d22 1
d24 1
a24 1
#include <unistd.h>	/* for SEEK_SET */
d26 2
a27 1
#define trace 	if (traceflags & db_stubs) _trace
d49 13
a61 3
PRIVATE VMRef	stub_list;	/* linked list of stubs */
PRIVATE VMRef	stub_heap;	/* heap to allocate new stub structures */
PRIVATE int	inited = 0;	/* flag to indicate that this package has been used */  
d63 9
d73 2
a74 3
/*
 * These routines are machine specific
 */
d77 1
d79 2
d84 4
d123 16
a149 1
  extern word	nchars;
d409 125
d538 53
d592 9
d602 2
a603 2
 * add a request for a stub calling 'symbol'
 * returns the byte offset from the start of the
d626 1
a626 5
    {
      stub_list = NullVMRef;
      stub_heap = NullVMRef;
      inited    = 1;
    }
d825 1
a825 1
  pos = totalcodesize + sizeof (WORD);	/* last null at end of program */
d844 2
a845 1

d858 89
d948 11
d960 2
a961 2
 * called at the end of the linking process
 * this creates all the necessary calling stubs,
d968 10
a977 3
  VMRef	prev;  
  VMRef	s;

d982 8
a989 1
  trace(  "building stubs" );
d991 28
a1018 1
  lseek( outf, (off_t)0, SEEK_END );
d1020 2
d1044 2
d1048 33
a1080 1
  /* now scan stub list building stubs ! */
d1082 3
d1087 11
a1097 1
      Stub *	stub;
d1099 2
d1102 1
a1102 3
      build_stub( s );
      
      stub = VMAddr( Stub, s );
d1104 5
a1108 1
      s = stub->next;      
d1111 27
d1140 3
a1142 2
  if (gen_image_header) {
	  /* confirm value of totalcodesize */
d1144 4
a1147 4
	if (lseek( outf, (off_t)0, SEEK_CUR ) != totalcodesize + 4 * sizeof (WORD))
		trace( "URG ftell = %ld, size = %ld",
	      		lseek( outf, (off_t)0, SEEK_CUR ),
			totalcodesize + 4 * sizeof (WORD) );
d1149 1
a1149 1
	/* finally update image will correct size */
d1151 1
a1151 1
	trace( "resetting code size to %d", totalcodesize + sizeof (WORD) );
d1153 4
a1156 4
	lseek( outf, (off_t) 2 * sizeof (WORD), SEEK_SET );

	outword( totalcodesize + 1 * sizeof (WORD) );	/* remember trailing zero */
  }
d1162 3
d1169 1
a1169 1
#endif /* NEW_STUBS */
d1171 2
a1173 1
#ifdef SUN4
d1183 1
d1186 4
a1191 8

/* @@@@ emacs customization */

/* Local Variables: */
/* mode: c */
/* outline-regexp: "^[a-zA-Z_]*(" */
/* eval: (outline-minor-mode 1) */
/* End: */
@


1.13
log
@improved error messages
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.12 $
 * Date :	$Date: 1992/10/05 08:51:39 $
 * Id :		$Id: stubs.c,v 1.12 1992/10/05 08:51:39 nickc Exp nickc $
d644 1
a644 1
  trace( "building stubs" );
d688 2
a689 1
  /* confirm value of totalcodesize */
d691 4
a694 3
  if (lseek( outf, (off_t)0, SEEK_CUR ) != totalcodesize + 4 * sizeof (WORD))
	trace( "URG ftell = %ld, size = %ld",
	      lseek( outf, (off_t)0, SEEK_CUR ), totalcodesize + 4 * sizeof (WORD) );
d696 1
a696 1
  /* finally update image will correct size */
d698 1
a698 1
  trace( "resetting code size to %d", totalcodesize + sizeof (WORD) );
d700 1
a700 1
  lseek( outf, (off_t) 2 * sizeof (WORD), SEEK_SET );
d702 2
a703 1
  outword( totalcodesize + 1 * sizeof (WORD) );	/* remember trailing zero */
@


1.12
log
@fixed creation of address stubs
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.11 $
 * Date :	$Date: 1992/10/02 11:57:05 $
 * Id :		$Id: stubs.c,v 1.11 1992/10/02 11:57:05 nickc Exp nickc $
d388 1
d397 3
a399 1

d402 2
a403 2
	VMAddr( Symbol, symbol )->name );

d407 1
a407 1

d409 1
a409 1

d416 1
a416 1

d419 1
a419 1

a424 1

d429 1
a429 1

d434 1
a434 1

d437 1
a437 1

d445 1
a445 1

d450 1
a450 1

d462 1
a462 1

d464 1
a464 1
	      
d466 1
a466 1

d512 1
a512 1

d540 1
a540 1

d552 2
d557 1
a557 1
	sym->name );
d579 3
@


1.11
log
@fixed bug in local address stubs
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.10 $
 * Date :	$Date: 1992/10/02 08:20:22 $
 * Id :		$Id: stubs.c,v 1.10 1992/10/02 08:20:22 nickc Exp nickc $
d33 1
d103 1
d109 3
a111 1

d116 2
a117 3
	VMAddr( Symbol, stub->symbol )->name,
	nchars ),
	  stub = VMAddr( Stub, s );
d142 1
a142 1
	      outword( 0x6800000dUL );			/* Bu    AR5                */
d150 1
a150 4
		  Symbol *	sym;
		  
		  
		  sym = VMAddr( Symbol, stub->symbol );
a151 2
		  warn( "Stub Creation: offset out of range for %s", sym->name );
		  
d157 2
a158 2
	      outword( 0x1Ecdc500UL );			/* LDA   *AR5,       AR5 */	  
	      outword( 0x6800000dUL );			/* Bu     AR5            */
d165 1
a165 6
	      Symbol *	sym;
	      
	      
	      sym = VMAddr( Symbol, stub->symbol );
	      
	      warn( "Stub Creation: module id out of range for %s", sym->name );
d174 3
a176 3
	      outword( 0x1e8d000cUL );			/* LDA	 AR4,           AR5 */
	      outword( 0x026d0000UL + (id & 0xffff) );	/* ADDI  id,            AR5 */
	      outword( 0x1Ecdc500UL );			/* LDA  *AR5,           AR5 */	  
d178 1
a178 1
	      outword( 0x6800000dUL );			/* Bu    AR5                */	  
d186 1
a186 8
		  Symbol *	sym;
		  
		  
		  sym = VMAddr( Symbol, stub->symbol );
		  
		  warn( "Stub Creation: offset out of range for %s", sym->name );
		  
		  return;	      
d189 3
a191 3
	      outword( 0x1e8d000cUL );			/* LDA	 AR4,    AR5 */
	      outword( 0x026d0000UL + (id & 0xffff) );	/* ADDI  id,     AR5 */
	      outword( 0x1Ecdc500UL );			/* LDA  *AR5,    AR5 */
d193 2
a194 2
	      outword( 0x1Ecdc500UL );			/* LDA  *AR5,    AR5 */	  
	      outword( 0x6800000dUL );			/* Bu    AR5         */
d248 1
a248 2
	  
	  size = 0;
d264 1
a264 1
	      warn( "Could not find local module containing symbol %s", sym->name );
d306 4
a309 4
		      Symbol *	sym;
		  
		  
		      sym = VMAddr( Symbol, stub->symbol );
a310 5
		      warn( "Stub Creation: offset out of range for %s", sym->name );
		  
		      return;	      
		    }
	      
d321 2
a322 7
		  Symbol *	sym;
	      
	      
		  sym = VMAddr( Symbol, stub->symbol );
	      
		  warn( "Stub Creation: module id out of range for %s", sym->name );
	      
d325 1
a325 1
	  
d342 2
a343 7
		      Symbol *	sym;
		  
		  
		      sym = VMAddr( Symbol, stub->symbol );
		  
		      warn( "Stub Creation: offset out of range for %s", sym->name );
		  
d357 1
a357 1
    
d378 1
d400 3
a402 1
 
d411 1
a411 1
      if (VMSame( stub->symbol, symbol ))
d428 1
a428 1
      return stub->position;      
d489 1
a489 1
	  trace( "lookiing up shared symbol %s", name );
d593 1
@


1.10
log
@updated to generate address returning stubs as well as function calling stubs
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.9 $
 * Date :	$Date: 1992/09/21 16:51:24 $
 * Id :		$Id: stubs.c,v 1.9 1992/09/21 16:51:24 martyn Exp nickc $
d299 1
a299 1
	  outword( 0x181f000dUL );			/* SUBI  AR5, R11 */
@


1.9
log
@added code to buffer image file writes to 4K.
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.8 $
 * Date :	$Date: 1992/09/16 11:18:44 $
 * Id :		$Id: stubs.c,v 1.8 1992/09/16 11:18:44 paul Exp $
d13 1
a13 1
#include "link.h"
d15 3
a19 1
#ifdef NEW_STUBS
d22 8
d32 6
a37 5
    VMRef	next;			/* link into chain of stubs */
    VMRef	symbol;			/* the symbol represented by this stub */
    WORD	id;			/* id of the module containing the symbol */
    WORD	offset;			/* byte offset of symbol within the module */
    WORD	position;		/* byte position of the stub within the file */    
d66 7
a72 1
  size = 3;
d74 2
a75 2
  if (!fits_in_8_bits( stub->id ))
    size += 2;
d77 2
a78 2
  if (!fits_in_8_bits( stub->offset >> 2 ))
    ++size;
d80 6
d108 7
a114 2
  trace( "building stub for %s at %d",
	VMAddr( Symbol, stub->symbol )->name, nchars ), stub = VMAddr( Stub, s );
d129 1
a129 1
  if (fits_in_8_bits( id ))
d131 3
a133 1
      if (fits_in_8_bits( offset ))
d135 27
a161 3
	  outword( 0x1Ecd0400UL + (id     & 0xff) );	/* LDA *+AR4(    id  ), AR5 */
	  outword( 0x1Ecd0500UL + (offset & 0xff) );	/* LDA *+AR5( offset ), AR5 */
	  outword( 0x6800000dUL );			/* Bu    AR5                */
d165 1
a165 3
	  /* symbol's offset within the code table is >= 256 */

	  if (!fits_in_16_bits( offset ))
d168 1
a168 1

d172 2
a173 2
	      warn( "Stub Creation: offset out of range for %s", sym->name );

d177 33
a209 4
	  outword( 0x1Ecd0400UL + (id     & 0xff) );	/* LDA  *+AR4( id ), AR5 */
	  outword( 0x026d0000UL + (offset & 0xffff) );	/* ADDI   offset,    AR5 */
	  outword( 0x1Ecdc500UL );			/* LDA   *AR5,       AR5 */	  
	  outword( 0x6800000dUL );			/* Bu     AR5            */
d214 27
a240 1
      if (!fits_in_16_bits( id ))
d242 2
d245 5
d251 1
d253 4
d258 4
d263 27
a289 1
	  warn( "Stub Creation: module id out of range for %s", sym->name );
d291 3
a293 2
	  return;	      
	}
d295 6
a300 9
      /* symbol's module number is >= 256 */
      
      if (fits_in_8_bits( offset ))
	{
	  outword( 0x1e8d000cUL );			/* LDA	 AR4,           AR5 */
	  outword( 0x026d0000UL + (id & 0xffff) );	/* ADDI  id,            AR5 */
	  outword( 0x1Ecdc500UL );			/* LDA  *AR5,           AR5 */	  
	  outword( 0x1Ecd0500UL + (offset & 0xff) );	/* LDA *+AR5( offset ), AR5 */
	  outword( 0x6800000dUL );			/* Bu    AR5                */	  
d304 1
a304 1
	  /* symbol's offset within the code table is >= 256 */
d306 1
a306 1
	  if (!fits_in_16_bits( offset ))
d308 10
a317 2
	      Symbol *	sym;

d319 11
a329 1
	      sym = VMAddr( Symbol, stub->symbol );
d331 5
a335 3
	      warn( "Stub Creation: offset out of range for %s", sym->name );

	      return;	      
d337 13
d351 34
a384 6
	  outword( 0x1e8d000cUL );			/* LDA	 AR4,    AR5 */
	  outword( 0x026d0000UL + (id & 0xffff) );	/* ADDI  id,     AR5 */
	  outword( 0x1Ecdc500UL );			/* LDA  *AR5,    AR5 */
	  outword( 0x026d0000UL + (offset & 0xffff) );	/* ADDI  offset, AR5 */
	  outword( 0x1Ecdc500UL );			/* LDA  *AR5,    AR5 */	  
	  outword( 0x6800000dUL );			/* Bu    AR5         */
d387 1
a387 1

d404 3
a406 1
new_stub( VMRef	symbol )
d408 1
d416 1
d426 3
a428 1
  trace( "new stub request for %s", VMAddr( Symbol, symbol )->name );
d444 2
d471 66
a536 3
  /* get hold of the symbol */
  
  sym = VMAddr( Symbol, symbol );
d538 25
a562 3
  trace( "creating new stub for %s", sym->name );
  
  if (sym->type != S_FUNCDONE)
d564 9
a572 1
      warn( "Function Stub \"%s\" is type %x", sym->name, sym->type );
d574 2
a575 1
      return 0;
d577 5
a581 1

d586 3
a588 1
  trace( "symbol's offset is %x", offset >> 2 );
d590 1
a590 1
  if (NullRef( sym->module ))
d596 1
a596 1
  
d599 1
a599 1
  mod  = VMAddr( asm_Module, sym->module );
d606 1
a606 1
  trace( "symbol's module id is %x", id );
d620 1
a620 1
  stub->position = pos;  
d622 2
a623 1
  stub->offset   = offset;  
d640 2
d707 5
a711 2
  if (lseek( outf, (off_t)0, SEEK_CUR ) != totalcodesize + 4 * sizeof( WORD ))
	trace( "URG ftell = %ld, size = %ld", lseek( outf, (off_t)0, SEEK_CUR ), totalcodesize + 4 * sizeof(WORD) );
@


1.8
log
@fixed tell to lseek to give file position and removed warnings
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.7 $
 * Date :	$Date: 1992/09/15 08:37:49 $
 * Id :		$Id: stubs.c,v 1.7 1992/09/15 08:37:49 nickc Exp paul $
d386 2
d398 2
@


1.7
log
@changed output file descriptor to file handle
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.6 $
 * Date :	$Date: 1992/09/14 08:34:30 $
 * Id :		$Id: stubs.c,v 1.6 1992/09/14 08:34:30 nickc Exp nickc $
d346 1
a346 1
  lseek( outf, 0L, SEEK_END );
d386 2
a387 2
  if (tell( outf ) != totalcodesize + 4 * sizeof( WORD ))
	trace( "URG ftell = %ld, size = %ld", tell( outf ), totalcodesize + 4 * sizeof(WORD) );
d393 1
a393 1
  lseek( outf, 2L * sizeof (WORD), SEEK_SET );
@


1.6
log
@fixed definitions of Sparc stub functions
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.5 $
 * Date :	$Date: 1992/09/14 08:24:09 $
 * Id :		$Id: stubs.c,v 1.5 1992/09/14 08:24:09 nickc Exp nickc $
d346 1
a346 1
  fseek( outfd, 0L, SEEK_END );
d386 2
a387 4
  fflush( outfd );

  if (ftell( outfd ) != totalcodesize + 4 * sizeof( WORD ))
	trace( "URG ftell = %ld, size = %ld", ftell( outfd ), totalcodesize + 4 * sizeof(WORD) );
d393 1
a393 1
  fseek( outfd, 2L * sizeof (WORD), SEEK_SET );
@


1.5
log
@fixed for compilation on Sparc
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.4 $
 * Date :	$Date: 1992/09/11 17:07:21 $
 * Id :		$Id: stubs.c,v 1.4 1992/09/11 17:07:21 nickc Exp nickc $
d415 2
a416 2
void ___assert( void ) {}
void ___typeof( void ) {}  
@


1.4
log
@fixed for compilation on Sparc
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.3 $
 * Date :	$Date: 1992/07/15 09:26:39 $
 * Id :		$Id: stubs.c,v 1.3 1992/07/15 09:26:39 paul Exp nickc $
d406 15
a420 1
  
@


1.3
log
@stopped file size error and file corruption when objed() is used in
conjunction with stub generation
@
text
@d8 3
a10 3
 * Version :	$Revision: 1.2 $
 * Date :	$Date: 1992/07/14 07:59:17 $
 * Id :		$Id: stubs.c,v 1.2 1992/07/14 07:59:17 nickc Exp $
d14 2
@


1.2
log
@fixed minor bugette
@
text
@d2 1
a2 1
 * stubs.c : 	stub generation fiel for the Helios Linker
d8 3
a10 3
 * Version :	$Revision: 1.1 $
 * Date :	$Date: 1992/07/13 08:52:23 $
 * Id :		$Id: stubs.c,v 1.1 1992/07/13 08:52:23 nickc Exp nickc $
d344 2
d384 5
@


1.1
log
@new file to create stubs with new CODESTUB patch
@
text
@d8 3
a10 3
 * Version :	$Revision$
 * Date :	$Date$
 * Id :		$Id$
d271 7
@
