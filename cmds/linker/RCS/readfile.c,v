head	1.32;
access;
symbols
	Helios_1_3_1:1.22
	Helios_C40_1_3_Official_Release:1.20
	Alenia_release:1.20
	C40_Field_Test_2:1.20
	C40_Field_Test_R1:1.11;
locks; strict;
comment	@ * @;


1.32
date	94.05.04.14.46.41;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	94.01.21.12.58.54;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	94.01.20.16.57.30;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	94.01.14.13.06.56;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	94.01.14.12.15.31;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	94.01.07.14.20.47;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	94.01.05.16.29.31;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	94.01.05.14.43.52;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	94.01.05.10.50.20;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	93.12.17.17.09.42;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	93.09.13.12.03.49;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	93.08.16.08.16.54;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	92.10.02.14.55.27;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	92.10.01.10.04.03;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	92.09.03.17.43.39;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	92.08.11.10.31.35;	author paul;	state Exp;
branches;
next	1.16;

1.16
date	92.07.17.11.56.07;	author paul;	state Exp;
branches;
next	1.15;

1.15
date	92.07.15.15.24.39;	author paul;	state Exp;
branches;
next	1.14;

1.14
date	92.07.15.08.26.32;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	92.07.13.08.58.56;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	92.07.02.13.37.50;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	92.06.25.14.36.16;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	92.06.22.13.55.26;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	92.04.27.12.38.38;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	92.04.16.17.07.23;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	91.11.06.15.03.36;	author paul;	state Exp;
branches;
next	1.6;

1.6
date	91.10.09.08.47.51;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	91.05.09.11.38.51;	author ben;	state Exp;
branches;
next	1.4;

1.4
date	91.04.18.10.10.42;	author ben;	state Exp;
branches;
next	1.3;

1.3
date	91.04.11.19.17.05;	author ben;	state Exp;
branches;
next	1.2;

1.2
date	91.04.11.14.31.25;	author ben;	state Exp;
branches;
next	1.1;

1.1
date	90.10.22.15.47.08;	author paul;	state Exp;
branches;
next	;


desc
@@


1.32
log
@added file_tracing option
@
text
@/*{{{  Comment */

/****************************************************************/
/* Helios Linker					     	*/
/*								*/
/* File: readfile.c                                             */
/*                                                              */
/* Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994 to	*/
/*               Perihelion Software Ltd.			*/
/*                                                              */
/* Author:  NHG 17-Feb-87                                       */
/* Updates: PAB June 89						*/
/*		cleaned up from final CS code			*/
/*		latest refsym code from asm			*/
/*		recursive patches				*/
/*		fixed COMMON directive				*/
/*		implicit GLOBAL for DATAMODULE directives	*/
/*              MODSIZE directive                               */
/*          NC  December 93                                     */
/*	        Integrated Jamie's AOF -> GHOF converter        */
/*                                                              */
/****************************************************************/
/* RcsId: $Id: readfile.c,v 1.31 1994/01/21 12:58:54 nickc Exp nickc $ */

/*}}}*/
/*{{{  #includes */

#include "link.h"

#ifdef __ARM
#include "convert.h"
#endif

/*}}}*/
/*{{{  #defines */

#define trace if (traceflags & db_gencode) _trace
#define file_trace if (traceflags & db_files) _trace
#define aof_trace if (traceflags & db_aof) _trace

/*}}}*/
/*{{{  Variables */

VMRef lastinit;
PUBLIC WORD totalcodesize;
PUBLIC UBYTE *codevec;
PUBLIC WORD curloc;
PUBLIC word bytesex = -1;

static eof = 0;

/*}}}*/
/*{{{  Prototypes */

#ifdef __STDC__
void patchpatch(VMRef pv, int ptype);
word rdint(void);
word rdch(void);
word rdword(void);
VMRef rdsymb(void);
void genpatch(word);
void geninit(void);
void genmodule(word);
void genend(void);
void genbyte(UWORD);
void copycode(void);
# if 0
void gencode(UBYTE *, word size);
VMRef deflabel(void);
# endif
#else /* !__STDC__ */
void patchpatch();
word rdint();
word rdch();
word rdword();
VMRef rdsymb();
void genpatch();
void geninit();
void genmodule();
void genend();
void genbyte();
void copycode();
# if 0
VMRef deflabel();
void gencode();
# endif
#endif /* __STDC__ */

/*}}}*/
/*{{{  Functions */

/*{{{  initcode() */

void
initcode( void )
{
  codevec  = (UBYTE *)alloc(256L);
  codepos  = 0;
  lastinit = NullVMRef;
  curloc   = 0;
}

/*}}}*/
#if defined __ARM && (defined RS6000 || defined __SUN4)
/*{{{  check_symbol() */

/* returns TRUE if pSymbolName is a code symbol */

int
check_symbol( char *	pSymbolName )
{
  char		aTmpName[ 128 ];	/* XXX */
  Symbol *	pSymbol;
  VMRef		vRef;


  if (pSymbolName == NULL)
    {
      error( "check_symbol: passed a NULL symbol name" );

      return FALSE;
    }

  if (bDeviceDriver || bSharedLib)
    aTmpName[ 0 ] = '.';
  else
    aTmpName[ 0 ] = '_';

  strcpy( aTmpName + 1, pSymbolName );
  
  /* find the named symbol */
  
  vRef = lookup( aTmpName );

  /* if the search failed the symbol does not exist */
  
  if (vRef == NullVMRef)
    {
      aof_trace( "%s does not exist", aTmpName );
      
      /* create a symbol of the given name and say that it is undefined data */

      vRef = insert( aTmpName, TRUE );
      
      pSymbol = VMAddr( Symbol, vRef );
      
      pSymbol->type           = S_UNBOUND;
      pSymbol->AOFassumedData = TRUE;
      pSymbol->file_name      = infile_duplicate;
      
      refsymbol_nondef( vRef );
      
      VMDirty( vRef );
      
      /* tell the world that the symbol is DATA */
      
      return FALSE;
    }

  /* get the symbol structure */

  pSymbol = VMAddr( Symbol, vRef );

  /* paranoia */
  
  if (pSymbol == NULL)
    {
      error( "check_symbol: symbol's structure is NULL" );
      
      return FALSE;
    }

  /* check the symbol's type */
  
  if (pSymbol->type == S_CODESYMB || /* Label in code     */
      pSymbol->type == S_FUNCSYMB || /* Unlinked function */
      pSymbol->type == S_FUNCDONE )  /* Linked function   */
    {
      aof_trace( "%s is a function", aTmpName );
      
      return TRUE;
    }

  aof_trace( "%s is data", aTmpName );
  
  return FALSE;
    
} /* check_symbol */

/*}}}*/
#endif /* __ARM and (RS6000 or __SUN4) */
/*{{{  readfile() */

void
readfile( void )
{
  VMRef 	v;
  Symbol *	s;
  word		op = 0;
  

  /*
   * Quick Test.
   * Determine if the first byte in the input file is a GHOF
   * directive.  If not then do not bother to parse the rest
   * of the file.
   */

  op = getc( infd );

  if (op >= 0x40)
    {
#if defined __ARM && (defined RS6000 || defined __SUN4)
      
      /* only support AOF -> GHOF conversion when cross linking */
      
      if (op == 0xC3 || op == 0xC5)
	{
	  s_aof *	pAOF;
	  uword		iCodeSize;
	  char *	pTempFileName;
	  
	  
	  trace( "Assuming file is in AOF format" );

	  pTempFileName = malloc( strlen( infile_duplicate ) + 5 /* strlen( ".ghof" ) */ + 1 );

	  if (pTempFileName == NULL)
	    {
	      error( "Out of memory allocating temporary file name" );

	      return;
	    }
	  
	  strcpy( pTempFileName, infile_duplicate );
	  strcat( pTempFileName, ".ghof" );

	  file_trace( "creating GHOF copy of AOF file '%s'", infile_duplicate );
	  
	  pAOF = open_aof( infile_duplicate );

	  if (pAOF == NULL)
	    {
	      error( "Failed to reopen file in AOF mode" );
	      return;
	    }

	  (void)convert_aof( pAOF, pTempFileName, bSharedLib, bTinyModel, bDeviceDriver );

	  /* Open the temporary file again */

	  file_trace( "opening GHOF copy '%s'", pTempFileName );

	  infd = freopen( pTempFileName, "rb", infd );

	  if (infd == NULL)
	    {
	      error( "Unable to reopen temporary file %s", pTempFileName );

	      return;
	    }
	  else
	    file_trace( "copy opened" );

	  free( pTempFileName );

	  /* drop throiugh into normal readfile() code */
	}
      else
#endif /* __ARM and (RS6000 or __SUN4) */
	{
	  error( "Input file is not in GHOF format" );

	  return;
	}
    }
  else
    {
      ungetc( (char)op, infd );
    }
      
  do
    {
      op = rdint();
      
      trace("OP = %x, curloc = %x, codepos = %x",op,curloc, codepos);
      
      switch( op )
	{
	default:
	  error( "Illegal linker directive '%x'", op );
	  break;
	  
	case EOF: return;
	  
	case OBJCODE:
	    {
	      word size = rdint();
	      
	      
	      if (size < 0)
         	error( "Negative sized code directive encountered (%x)", size );
	      
	      trace("CODE %d",size);
	      
	      while( size-- ) genbyte(rdch());
	      
	      break;
	    }
	  
	case OBJBSS:
	    {
	      word size = rdint();
	      
	      
	      if (size < 0)
		error("Negative sized bss defined");
	      
	      trace("BSS %d",size);
	      
	      while( size-- ) genbyte(0L);
	      
	      break;
	    }
	  
	case OBJWORD: 
	  genpatch( OBJWORD );
	  break;
	  
	case OBJSHORT: 
	  genpatch( OBJSHORT );
	  break;
	  
	case OBJBYTE:
	  genpatch( OBJBYTE );
	  break;
	  
	case OBJINIT:
	  geninit();
	  break;
	  
	case OBJMODULE:
	  genmodule(rdint());
	  break;
	  
	case OBJBYTESEX:
	  if( bytesex != 0 ) error("bytesex already set");
	  bytesex = rdint();
	  trace("BYTESEX %d",bytesex);
	  break;
	  
	case OBJREF:
	  v = rdsymb();
	  movesym(v);		/* XXX - all REF symbols are implicitly global */	 
	  refsymbol_nondef(v);
	  break;
	  
	case OBJGLOBAL:
	  v = rdsymb();
	  s = VMAddr(Symbol,v);
	  movesym(v);
	  if (s->referenced)
	    {
	      refsymbol_def(v);
	    }
	  break;
	  
	case OBJLABEL:
	  v = rdsymb();
	  s = VMAddr(Symbol,v);
	  trace("LABEL %s",s->name);
	  if( s->type != S_UNBOUND )
	    {
	      if (!inlib)
		warn( "Duplicate definition of symbol '%s' defined in file '%s'", s->name, s->file_name );
	    }
	  else
	    {
	      if (s->AOFassumedData)
		{
		  error( "(AOF) Symbol '%s' has been assumed to be data in file '%s'",
		       s->name, s->file_name );
		  
		  s->AOFassumedData = FALSE;
		}
	      
	      copycode();
	      
	      s->type      = S_CODESYMB;
	      s->value.v   = codeptr();
	      s->module    = curmod;
	      s->file_name = infile_duplicate;
	      
	      if (s->referenced)
		refsymbol_def(v);
	      
		{
		  int len = strlen( s->name );
		  
		  /* hack to insert correct name for resident libraries */
		  VMlock( v );
		  if (len > 8 &&
		      strcmp( s->name + len - 8, ".library" ) == 0 &&
		      VMAddr( asm_Module, curmod )->id     != -1 )
		    {
		      VMAddr( asm_Module, curmod )->file_name = s->name;
		    }
		  VMunlock( v );
		}
	    }
	  break;
	  
	case OBJDATA:
	case OBJCOMMON:
	    {
	      word size = rdint();
	      
	      
	      if (size < 0)
		error("Negative sized data/common directive encountered");
	      
	      v = rdsymb();
	      
	      s = VMAddr(Symbol,v);
	      
	      trace("%s %d %s",op== OBJDATA ? "DATA" : "COMMON",size,s->name);
	      
	      if( s->type != S_UNBOUND ) 
		{
		  if( s->type != S_COMMSYMB)
		    {
		      if (!inlib)
			warn("Duplicate data definition of symbol '%s' defined in file '%s'",s->name, s->file_name);
		    }
		  else {
		      if( s->value.w < size ) 
			s->value.w = size;
		    }
		}
	      else {
		  s->type = op== OBJDATA ? S_DATASYMB : S_COMMSYMB;
		  s->value.w = size;
		  s->module = curmod;
		  s->file_name = infile_duplicate;
		  if(s->referenced)
		    refsymbol_def(v);
		}
	      (void)newcode(op,0,0,curloc,v);
	      break;
	    }
	  
	case OBJCODETABLE:
	    {
	      if (!smtopt)
		error("CODETABLE directive encountered without split module table mode set");
	      
	      v = rdsymb();
	      s = VMAddr(Symbol,v);
	      
#if 0 /* problems for .MaxCodeP */
	      movesym(v);	/* implicit global directive */
#endif
	      trace("%s %s","CODETABLE",s->name);
	      if ( s->type != S_UNBOUND ) 
		{
		  if (!inlib)
		    warn("Duplicate definition of symbol '%s' defined in file '%s'",
			 s->name, s->file_name);
		}
	      else
		{ 
		  if (s->AOFassumedData)
		    {
		      error( "(AOF) Symbol '%s' has been assumed to be data in file '%s'",
			   s->name, s->file_name );
		      
		      s->AOFassumedData = FALSE;
		    }
		  
		  s->type = S_FUNCSYMB;
		  s->value.w = 4;
		  s->module = curmod;
		  s->file_name = infile_duplicate;
		  
		  if(s->referenced)
		    refsymbol_def(v);
		}
	      (void)newcode(op,0,0,curloc,v);
	      break;
	    }
	  
	}
      
    }
  while( op != EOF );
  
  return;
}

/*}}}*/
/*{{{  genbyte() */

PUBLIC void
genbyte( UWORD value )
{
  trace("genbyte %2x",value);

  if ( codepos >= 255 )
    {
      copycode();
    }
  
  codevec[codepos] = (UBYTE)value;  
  codepos++;

  return;  
}

/*}}}*/
/*{{{  copycode() */

PUBLIC void
copycode( void )
{

        if( codepos == 0 ) return;
        if( codepos <= 4 ) 
      (void)newcode((WORD) OBJLITERAL, codepos,0l,curloc,*((INT *)codevec));
        else {
                VMRef vmr = VMNew((int)codepos);
                UBYTE *v = VMAddr(UBYTE,vmr);

                codesize += codepos;

	        memcpy((char *)v, (char *)codevec, (int)codepos);

                (void)newcode((WORD) OBJCODE, codepos,0l,curloc,vmr);
        }
        curloc += codepos;
        codepos = 0;
}

/*}}}*/
/*{{{  genpatch() */

void
genpatch( word op )
{
  word type = rdint();
  int size = (int)op & 0x7;

  copycode();
  trace("Read PATCH");

  switch( type )
    {
    default:
      error("genpatch: Illegal patch type: %x",type);
      return;
      
    case OBJMODSIZE:
      trace("MODSIZE");
      (void)newcode(op,size,type,curloc,0L);
      break;

    case OBJMODNUM:
      trace("MODNUM");
      (void)newcode(op,size,type,curloc,0L);
      break;

    case OBJCODESYMB:
      if (!smtopt)
      	error("CODESYMB directive encountered without split module table mode set");
    case OBJLABELREF:
    case OBJDATASYMB:
    case OBJDATAMODULE:
#ifdef NEW_STUBS 
    case OBJCODESTUB:
    case OBJADDRSTUB:
#endif
	{
	  VMRef 	v = rdsymb();
	  Symbol *	s;

	  
	  if (type == OBJDATAMODULE)
	    {
	      movesym( v );		/* implicit GLOBAL declaration */
	    }
	  s = VMAddr( Symbol, v );
	  
	  trace( "Single level %s %s %#x",
#ifdef NEW_STUBS
		type == OBJCODESTUB   ? "CODESTUB"   :
		type == OBJADDRSTUB   ? "ADDRSTUB"   :
#endif
		type == OBJDATASYMB   ? "DATASYMB"   :
		type == OBJDATAMODULE ? "DATAMODULE" :
		type == OBJCODESYMB   ? "CODESYMB"   :
		                        "LABELREF"   ,
		s->name, v );
	  
	  refsymbol_nondef( v );
	  
	  (void)newcode( op, size, type, curloc, v );
	  
	  break;
	}
      
    case OBJPATCH:      case OBJPATCH + 1:  case OBJPATCH + 2:
    case OBJPATCH + 3:  case OBJPATCH + 4:  case OBJPATCH + 5:
    case OBJPATCH + 6:  case OBJPATCH + 7:  case OBJPATCH + 8:
    case OBJPATCH + 9:  case OBJPATCH + 10: case OBJPATCH + 11:
    case OBJPATCH + 12:
	{
	  Patch *p;
	  word pword = 0;		/* patch data */
	  int ptype;		/* patch type */
	  VMRef pv = VMNew(sizeof(Patch));
	  
	  if (type != PATCHSWAP)	/* no patch data for swap patch */
	    pword = rdint();	/* patch data */
	  
	  p = VMAddr(Patch,pv);
	  p->word = pword;
	  p->type = ptype = (int)rdint();	/* patch type */
	  
	  patchpatch(pv, ptype);	/* patch in value of type, or another patch */
	  
	  (void)newcode(op,size,type,curloc,pv);
	  break;
	}
      
    }
  
  curloc += size;

  return;

} /* genpatch */

/*}}}*/
/*{{{  patchpatch() */

void
patchpatch(
	   VMRef 	pv,
	   int		ptype )
{
  Patch	*	p;
  
  switch( ptype )
    {
    default:
      error("patchpatch: Illegal patch subtype: %x",ptype);
      break;
      
    case OBJMODSIZE:
      trace("PATCH MODSIZE");
      break;
      
    case OBJMODNUM:
      trace("PATCH MODNUM");
      break;
      
    case OBJCODESYMB:
      if (!smtopt)
	error("CODESYMB directive encountered without split module table mode set");
    case OBJDATASYMB:
    case OBJDATAMODULE:
    case OBJLABELREF:
#ifdef NEW_STUBS 
    case OBJCODESTUB:
    case OBJADDRSTUB:
#endif
	{
	  VMRef 	v = rdsymb();
	  Symbol *	s;
	  
	  
	  s = VMAddr( Symbol, v );
	  
	  if  (ptype == OBJDATAMODULE)
	    {
	      movesym( v );		/* implicit GLOBAL declaration */
	      
	      if (s->referenced)
		refsymbol_def( v );
	    }
	  else
	    {
	      refsymbol_nondef( v );
	    }
	  
	  trace("PatchPatch %s %s %#x",
		ptype == OBJDATASYMB   ? "DATASYMB"   :
		ptype == OBJDATAMODULE ? "DATAMODULE" :
		ptype == OBJCODESYMB   ? "CODESYMB"   :
#ifdef NEW_STUBS
		ptype == OBJCODESTUB   ? "CODESTUB"   :
		ptype == OBJADDRSTUB   ? "ADDRSTUB"   :
#endif
		                         "LABELREF"   ,
		s->name, v );
	  
	  p = VMAddr( Patch, pv );
	  
	  p->value.v = v;
	  
	  VMDirty( pv );
	  
	  break;
	}
      
    case OBJPATCH:      case OBJPATCH + 1:   case OBJPATCH + 2:
    case OBJPATCH + 3:  case OBJPATCH + 4:   case OBJPATCH + 5:
    case OBJPATCH + 6:  case OBJPATCH + 7:   case OBJPATCH + 8:
    case OBJPATCH + 9:  case OBJPATCH + 10:  case OBJPATCH + 11:
    case OBJPATCH + 12:
      /* recursive patch */
	{
	  Patch *p2;
	  word pword = 0; 	/* patch data */
	  int type;		/* patch type */
	  VMRef pv2 = VMNew(sizeof(Patch));
	  
	  if (ptype != PATCHSWAP)	/* no patch data for swap patch */
	    pword = rdint();	/* patch data */
	  
	  type = (int)rdint();		/* patch type */
	  
	  p = VMAddr(Patch,pv);
	  p->value.v = pv2;			/* chain patches */
          
	  p2 = VMAddr(Patch,pv2);
	  p2->word = pword;
	  p2->type = type;
	  VMDirty(pv2);
	  VMDirty(pv);
	  patchpatch(pv2, type);	/* set value of ptype, or another patch */
	}
      
    }
  
  return;
  
} /* patchpatch */

/*}}}*/
/*{{{  geninit() */

void
geninit( void )
{
  VMRef c1;


  copycode();

  c1 = newcode(OBJINIT,4l,0l,curloc,NullVMRef);

  curloc += 4;

  if ( !NullRef(lastinit) )
    {
      Code *c = VMAddr(Code,lastinit);


      c->value.v = c1;

      VMDirty(lastinit);   
    }

  lastinit = c1;

  return;
   
} /* geninit */

/*}}}*/
/*{{{  genmodule() */

PUBLIC void
genmodule( WORD mod )
{
   VMRef 	v = VMNew( sizeof (asm_Module) );
   asm_Module *	m = VMAddr( asm_Module, v );
   int 		i;

   
   VMlock(v);
   
   trace("MODULE %d",mod);

   genend();   /* finish off last module */

   m->next 	= NullVMRef;
   m->start 	= codeptr();
   m->refs   	= NullVMRef;        
   m->id 	= mod;
   m->linked 	= FALSE;
   m->file_name = infile_duplicate;
   
   for ( i = 0; i < LOCAL_HASHSIZE ; i++ )
     {
       m->symtab[ i ].head    = NullVMRef,
       m->symtab[ i ].entries = 0;
     }

   /* if this is a library module, we do not link it by default but */
   /* only if it is referenced.               */
   
   if (!inlib)
   {
      asm_Module *	tm = VMAddr( asm_Module, tailmodule );

      
      tailmodule = tm->next = v;
      m->linked  = TRUE;

      if ( NullRef( firstmodule ) )
	firstmodule = v;
   }
   
   VMunlock(curmod);        

   curmod = v;

   /* leave new curmod locked */

   (void)newcode( (WORD)OBJMODULE, 0L, 0L, curloc,v );
   
   curloc   = 0;
   lastinit = NullVMRef;
   
   return;
   
} /* genmodule */

/*}}}*/
/*{{{  genend() */

PUBLIC void
genend()
{
   asm_Module *m;


   copycode();

   m = VMAddr( asm_Module, curmod );
   
   m->length = curloc;
   
   m->end = newcode((WORD)OBJEND,0l,0l,curloc,0l);
   
   endmodule();

   return;
   
} /* genend */

/*}}}*/
/*{{{  digit() */

word
digit( void )
{
  int c;

  
  if ( eof ) return 0;
   
  c = getc(infd);
   
  while ( c == ' ' || c == '\n' || c == '\r' ) c = getc(infd);

  if ( c == EOF )
    {
      eof  = 1;
      return 0;
    }

  if( '0' <= c && c <= '9' ) return (word)c - '0';
  elif ( 'a' <= c && c <= 'z' ) return 10 + (word)c - 'a';
  else return 10 + (word)c - 'A';

} /* digit */
     

/*}}}*/
/*{{{  rdch() */

word
rdch( void )
{
#if 1
/*  
  int a;

  a = getc(infd);
  if (infd == stdin)
    IOdebug( "%x %", a );
  return a;
*/
  return getc(infd);
  
#else
   int v = digit()<<4;
   v |= digit();
   return eof?EOF:v;
#endif
}

/*}}}*/
/*{{{  rdint() */

word
rdint( void )
{
#if 0   
   int v = 0;
   int c;

   do {
      c = rdch();
      if( c == EOF ) return EOF;
      v = (v<<7) | (c&0x7f);
   } while( (c & 0x80) != 0 );
   return v;
#else
   int v;
   int c;
   int sign;
   
   c = (int)rdch();
   if ( c == EOF )
     return EOF;
   v    = c & 0x3f;
   sign = c & 0x40;
   while( (c & 0x80) != 0 )
   {
      c = (int)rdch();
      if( c == EOF ) return EOF;
      v = (v << 7) | (c & 0x7f);
   }
   return sign ? -(word)v : (word)v;
#endif   
}

/*}}}*/
#if 0
/*{{{  rdword() */

word
rdword()
{
   int v = 0;

   if( bytesex <= 0 )
   {
      v |= rdch();
      v |= rdch()<<8;
      v |= rdch()<<16;
      v |= rdch()<<24;
   }
   else {
      v |= rdch()<<24;
      v |= rdch()<<16;
      v |= rdch()<<8;
      v |= rdch();
   }
   return v;
}

/*}}}*/
#endif
/*{{{  rdsymb() */

VMRef
rdsymb( void )
{
  VMRef v;
  char buf[128];
  word pos = 0;
  word c;
   
  do
    {
      c = rdch();
      buf[pos++] = (char)c;
    }
  while ( c != 0 );
   
  v = lookup(buf);
   
  if ( NullRef(v) ) 
    {
      Symbol *	s;

      
      v = insert(buf,TRUE);
      s = VMAddr(Symbol,v);
      s->type = S_UNBOUND;
      s->AOFassumedData = FALSE;
    }
   
  return v;
}

/*}}}*/

/*}}}*/

/* readfile.c */
@


1.31
log
@added fix from Jamie
@
text
@d23 1
a23 1
/* RcsId: $Id: readfile.c,v 1.30 1994/01/20 16:57:30 nickc Exp nickc $ */
d38 1
d237 2
d251 3
a253 1
	  
d262 2
d266 1
a266 1
	  
d898 1
a898 1
  /*
d905 3
a907 2
  */
  return getc(infd); 
@


1.30
log
@improved trace messages
@
text
@d23 1
a23 1
/* RcsId: $Id: readfile.c,v 1.29 1994/01/14 13:06:56 nickc Exp nickc $ */
d123 1
a123 1
  if (bDeviceDriver)
d1006 2
@


1.29
log
@fixed so that unique temporary files are created for AOF conversion
@
text
@d23 1
a23 1
/* RcsId: $Id: readfile.c,v 1.28 1994/01/14 12:15:31 nickc Exp nickc $ */
a129 2
  aof_trace( "checking symbol %s", aTmpName );
  
d138 1
a138 1
      aof_trace( "... symbol does not exist" );
a173 2
  aof_trace( "... symbol's type is %d", pSymbol->type );
  
d178 2
d182 2
@


1.28
log
@fixed naming of symbols when building kernel
@
text
@d23 1
a23 1
/* RcsId: $Id: readfile.c,v 1.27 1994/01/07 14:20:47 nickc Exp nickc $ */
d220 1
a220 1
	  char *	pTempFileName = "tmpAOF.o";
d224 9
d234 3
d258 2
@


1.27
log
@fixed data relocation and BSS handling
@
text
@d23 1
a23 1
/* RcsId: $Id: readfile.c,v 1.26 1994/01/05 16:29:31 nickc Exp nickc $ */
d123 4
a126 1
  aTmpName[ 0 ] = '_';
@


1.26
log
@fixed check_symbol() to detect incorrect assumptions of symbols being data - this could be fixed by making the linker a two pass progra,m
@
text
@d23 1
a23 1
/* RcsId: $Id: readfile.c,v 1.25 1994/01/05 14:43:52 nickc Exp nickc $ */
a142 4
      movesym( vRef );
      
      refsymbol_nondef( vRef );
      
d149 2
d230 1
a230 9
	  /* First pass - reads in AOF to memory buffer */
	  
	  iCodeSize = First_convert_aof( pAOF, bSharedLib, bTinyModel, bDeviceDriver );
	  
	  /* Second pass - writes GHOF to temporary file */

	  pAOF->codesize = iCodeSize;
	  
	  Second_convert_aof( pAOF, pTempFileName, bSharedLib, bTinyModel, bDeviceDriver );
@


1.25
log
@changed 'sparc' to '__SUN4' in #if defined
@
text
@d23 1
a23 1
/* RcsId: $Id: readfile.c,v 1.24 1994/01/05 10:50:20 nickc Exp nickc $ */
d139 18
d177 8
a184 3
  return (pSymbol->type == S_CODESYMB || /* Label in code     */
	  pSymbol->type == S_FUNCSYMB || /* Unlinked function */
	  pSymbol->type == S_FUNCDONE ); /* Linked function   */
d222 1
a222 1
	  inform( "Assuming file is in AOF format" );
d365 8
d458 8
d990 1
@


1.24
log
@added AOF support - not yet fully tested
@
text
@d23 1
a23 1
/* RcsId: $Id: readfile.c,v 1.23 1993/12/17 17:09:42 nickc Exp nickc $ */
d103 1
a103 1
#if defined __ARM && (defined RS6000 || defined sparc)
d166 1
a166 1
#endif /* __ARM and (RS6000 or sparc) */
d188 1
a188 1
#if defined __ARM && (defined RS6000 || defined sparc)
d233 1
a233 1
#endif /* __ARM and (RS6000 or sparc) */
@


1.23
log
@stage 1 on integration of Jamies AOF converter
@
text
@d1 2
d8 1
a8 1
/* Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993 to		*/
d19 2
a20 2
/*          NC  August 91                                       */
/*	        cosmetic changes only - ha!                     */
d23 4
a26 1
/* RcsId: $Id: readfile.c,v 1.22 1993/09/13 12:03:49 nickc Exp nickc $ */
d34 3
d38 1
d40 2
a41 2
/****************************************************************/
/* Globals */
d49 4
a52 2
/****************************************************************/
/* prototypes */
d88 4
a91 2
/****************************************************************/
/* Code */
d102 3
a104 1
#ifdef __ARM
d111 1
d116 13
d131 1
a131 1
  vRef = lookup( pSymbolName );
d136 5
a140 1
    return FALSE;
d149 5
a153 1
    return FALSE;
d157 2
a163 2
  
#endif /* __ARM */
d165 3
d188 4
a191 3
      inform( "Input file is not in GHOF format" );

#ifdef __ARM
d195 1
a195 1
	  int		iCodeSize;
d199 1
a199 1
	  inform( "Input file might be AOF format" );
d211 1
a211 1
	  iCodeSize = convert_aof( pAOF, NULL, FALSE, FALSE, FALSE );
a212 2
	  inform( "AOF codes size is %d", iCodeSize );

d217 1
a217 1
	  iCodeSize -= convert_aof( pAOF, pTempFileName, FALSE, FALSE, FALSE );
a218 3
	  if (iCodeSize)
	    error( "Loss in AOF code size = %d", iCodeSize );

d233 6
a238 2
#endif
	return;
d447 3
d466 3
d490 3
d589 3
d696 3
d727 2
d787 2
d810 2
a811 2

static eof = 0;
d838 3
d861 3
d897 1
d899 2
d921 2
d924 1
d955 4
@


1.22
log
@added hack to get correct name of resident libraries into module structure
@
text
@d21 1
a21 1
/* RcsId: $Id: readfile.c,v 1.21 1993/08/16 08:16:54 nickc Exp nickc $ */
d25 4
d89 40
d132 35
a166 3
   VMRef 	v;
   Symbol *	s;
   word		op = 0;
d168 18
d187 20
a206 2
   do
     {
d212 13
a224 13
      {
      default:
         error( "Illegal linker directive '%x'", op );
         break;

      case EOF: return;
      
      case OBJCODE:
      {
         word size = rdint();
	 

         if (size < 0)
d226 144
a369 144
	 
         trace("CODE %d",size);
	 
         while( size-- ) genbyte(rdch());
	 
         break;
      }

      case OBJBSS:
      {
         word size = rdint();
	 
	 
         if (size < 0)
	   error("Negative sized bss defined");
	 
         trace("BSS %d",size);
	 
         while( size-- ) genbyte(0L);

         break;
      }
      
      case OBJWORD: 
         genpatch( OBJWORD );
         break;
         
      case OBJSHORT: 
         genpatch( OBJSHORT );
         break;
         
      case OBJBYTE:
         genpatch( OBJBYTE );
         break;
         
      case OBJINIT:
         geninit();
         break;

      case OBJMODULE:
         genmodule(rdint());
         break;
         
      case OBJBYTESEX:
         if( bytesex != 0 ) error("bytesex already set");
         bytesex = rdint();
         trace("BYTESEX %d",bytesex);
         break;
         
      case OBJREF:
	 v = rdsymb();
	 movesym(v);		/* XXX - all REF symbols are implicitly global */	 
	 refsymbol_nondef(v);
	 break;

      case OBJGLOBAL:
         v = rdsymb();
         s = VMAddr(Symbol,v);
         movesym(v);
         if (s->referenced)
	   {
	     refsymbol_def(v);
	   }
         break;
      
      case OBJLABEL:
         v = rdsymb();
         s = VMAddr(Symbol,v);
         trace("LABEL %s",s->name);
         if( s->type != S_UNBOUND )
	   {
	     if (!inlib)
	       warn( "Duplicate definition of symbol '%s' defined in file '%s'", s->name, s->file_name );
	   }
         else
	   {
	     copycode();
	     
	     s->type      = S_CODESYMB;
	     s->value.v   = codeptr();
	     s->module    = curmod;
	     s->file_name = infile_duplicate;
	     
	     if (s->referenced)
	       refsymbol_def(v);

	       {
		 int len = strlen( s->name );

		 /* hack to insert correct name for resident libraries */
		 VMlock( v );
		 if (len > 8 &&
		     strcmp( s->name + len - 8, ".library" ) == 0 &&
		     VMAddr( asm_Module, curmod )->id     != -1 )
		   {
		     VMAddr( asm_Module, curmod )->file_name = s->name;
		   }
		 VMunlock( v );
	       }
	   }
         break;
            
      case OBJDATA:
      case OBJCOMMON:
       {
         word size = rdint();

	 
	 if (size < 0)
	   error("Negative sized data/common directive encountered");
	 
         v = rdsymb();
	 
         s = VMAddr(Symbol,v);
	 
         trace("%s %d %s",op== OBJDATA ? "DATA" : "COMMON",size,s->name);
	 
         if( s->type != S_UNBOUND ) 
         {
            if( s->type != S_COMMSYMB)
            {
               if (!inlib)
                 warn("Duplicate data definition of symbol '%s' defined in file '%s'",s->name, s->file_name);
            }
            else {
               if( s->value.w < size ) 
                  s->value.w = size;
            }
         }
         else {
            s->type = op== OBJDATA ? S_DATASYMB : S_COMMSYMB;
            s->value.w = size;
            s->module = curmod;
	    s->file_name = infile_duplicate;
            if(s->referenced)
            	refsymbol_def(v);
         }
         (void)newcode(op,0,0,curloc,v);
         break;
       }

      case OBJCODETABLE:
       {
         if (!smtopt)
d371 4
a374 4

         v = rdsymb();
         s = VMAddr(Symbol,v);

d376 1
a376 1
         movesym(v);	/* implicit global directive */
d378 27
a404 25
         trace("%s %s","CODETABLE",s->name);
         if( s->type != S_UNBOUND ) 
         {
               if (!inlib)
                 warn("Duplicate definition of symbol '%s' defined in file '%s'",
		      s->name, s->file_name);
         }
         else { 
            s->type = S_FUNCSYMB;
            s->value.w = 4;
            s->module = curmod;
	    s->file_name = infile_duplicate;

            if(s->referenced)
            	refsymbol_def(v);
         }
         (void)newcode(op,0,0,curloc,v);
         break;
       }

      }
   
   } while( op != EOF );

   return;
d818 3
a820 2
   if( c == EOF ) return EOF;
   v = c&0x3f;
d826 1
a826 1
      v = (v<<7) | (c&0x7f);
@


1.21
log
@improved error message
@
text
@d6 2
d18 1
a18 1
/*	        cosmetic changes only                           */
d21 1
a21 1
/* RcsId: $Id: readfile.c,v 1.20 1992/10/02 14:55:27 nickc Exp nickc $ */
a171 1
         trace("GLOBAL %s", s->name);
d199 14
@


1.20
log
@minor cosmetic changes
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.19 1992/10/01 10:04:03 nickc Exp nickc $ */
d100 1
a100 1
         error("Illegal op: %x",op);
@


1.19
log
@fixed compile time warnings and added support for address stubs
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.18 1992/09/03 17:43:39 nickc Exp nickc $ */
d183 16
a198 14
         {
            if (!inlib)
	       warn("Duplicate definition of symbol '%s' defined in file '%s'",s->name,s->file_name);
	 }
         else {
            copycode();
            s->type = S_CODESYMB;
            s->value.v = codeptr();
            s->module = curmod;
	    s->file_name = infile_duplicate;
            if (s->referenced)
            	refsymbol_def(v);
	      
         }
d221 1
a221 1
                 warn("Duplicate definition of symbol '%s' defined in file '%s'",s->name, s->file_name);
@


1.18
log
@removed automatic promotion of CODESTUB symbols to gloabl - now performed by compiler generated directives
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.17 1992/08/11 10:31:35 paul Exp nickc $ */
d74 2
a75 1
void initcode()
d77 4
a80 4
   codevec = (UBYTE *)alloc(256L);
   codepos = 0;
   lastinit = NullVMRef;
   curloc = 0;
d83 2
a84 1
void readfile()
d276 2
a277 4
#if 0
PUBLIC void gencode(code,size)
UBYTE *code;
WORD size;
d279 1
a279 4
   int i;
   for( i = 0 ; i < size; i++ ) genbyte((WORD)code[i]);
}
#endif
a280 4
PUBLIC void genbyte(value)
UWORD value;
{
  trace("genbyte %2x",value);
d288 2
d292 2
a293 1
PUBLIC void copycode()
d313 2
a314 2
void genpatch(op)
word op;
d346 1
d359 9
a367 5
	  trace("Single level %s %s %#x",
		type == OBJDATASYMB   ? "DATASYMB":
		type == OBJDATAMODULE ? "DATAMODULE":
		type == OBJCODESYMB   ? "CODESYMB":
		                        "LABELREF",
d370 1
a370 1
	  refsymbol_nondef(v);
d372 1
a372 1
	  (void)newcode(op,size,type,curloc,v);
d406 2
a407 1
}
d409 4
a412 3
void patchpatch(pv, ptype)
VMRef 	pv;
int	ptype;
d414 22
a435 22
      Patch	*p;

      switch( ptype )
      {
      default:
         error("patchpatch: Illegal patch subtype: %x",ptype);
         break;

      case OBJMODSIZE:
         trace("PATCH MODSIZE");
         break;

      case OBJMODNUM:
         trace("PATCH MODNUM");
         break;

      case OBJCODESYMB:
         if (!smtopt)
             error("CODESYMB directive encountered without split module table mode set");
      case OBJDATASYMB:
      case OBJDATAMODULE:
      case OBJLABELREF:
d437 2
a438 1
       case OBJCODESTUB:
d440 23
a462 23
	   {
	     VMRef 	v = rdsymb();
	     Symbol *	s;

	     
	     s = VMAddr( Symbol, v );

	     if  (ptype == OBJDATAMODULE)
	       {
		 movesym( v );		/* implicit GLOBAL declaration */

		 if (s->referenced)
		   refsymbol_def( v );
	       }
	     else
	       {
		 refsymbol_nondef( v );
	       }

	     trace("PatchPatch %s %s %#x",
		   ptype == OBJDATASYMB   ? "DATASYMB":
		   ptype == OBJDATAMODULE ? "DATAMODULE":
		   ptype == OBJCODESYMB   ? "CODESYMB":
d464 2
a465 1
		   ptype == OBJCODESTUB   ? "CODESTUB":
d467 17
a483 17
		                            "LABELREF",
		   s->name, v );
	     
	     p = VMAddr(Patch,pv);
	     
	     p->value.v = v;
	     
	     VMDirty(pv);
	     
	     break;
	   }
     
      case OBJPATCH:      case OBJPATCH + 1:   case OBJPATCH + 2:
      case OBJPATCH + 3:  case OBJPATCH + 4:   case OBJPATCH + 5:
      case OBJPATCH + 6:  case OBJPATCH + 7:   case OBJPATCH + 8:
      case OBJPATCH + 9:  case OBJPATCH + 10:  case OBJPATCH + 11:
      case OBJPATCH + 12:
d485 32
a516 5
      {
         Patch *p2;
         word pword = 0; 	/* patch data */
         int type;		/* patch type */
         VMRef pv2 = VMNew(sizeof(Patch));
a517 2
         if (ptype != PATCHSWAP)	/* no patch data for swap patch */
         	pword = rdint();	/* patch data */
d519 1
a519 1
         type = (int)rdint();		/* patch type */
d521 1
a521 10
         p = VMAddr(Patch,pv);
         p->value.v = pv2;			/* chain patches */
          
         p2 = VMAddr(Patch,pv2);
         p2->word = pword;
         p2->type = type;
	 VMDirty(pv2);
         VMDirty(pv);
         patchpatch(pv2, type);	/* set value of ptype, or another patch */
      }
d523 1
a523 2
      }
}
d525 2
a526 8
void geninit()
{
   VMRef c1;
   copycode();
   c1 = newcode(OBJINIT,4l,0l,curloc,NullVMRef);
   curloc += 4;
   if( !NullRef(lastinit) )
   {
d528 2
d531 1
d533 8
a540 3
   }
   lastinit = c1;
}
d542 2
a543 2
PUBLIC void genmodule(mod)
WORD mod;
d595 3
a597 2
   return;   
}
d616 4
a619 2
   return;   
}
d623 2
a624 1
word digit()
d626 4
a629 1
   int c;
d631 1
a631 1
   if( eof ) return 0;
d633 7
a639 3
   c = getc(infd);
   
   while( c == ' ' || c == '\n' || c == '\r' ) c = getc(infd);
d641 3
a643 1
   if( c == EOF ) { eof = 1 ; return 0; }
d645 2
a646 4
   if( '0' <= c && c <= '9' ) return (word)c - '0';
   elif ( 'a' <= c && c <= 'z' ) return 10 + (word)c - 'a';
   else return 10 + (word)c - 'A';
}
d648 2
a649 1
word rdch()
d668 2
a669 1
word rdint()
d701 2
a702 1
word rdword()
d724 1
a724 1
rdsymb()
@


1.17
log
@remove implicit global for codetable
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.16 1992/07/17 11:56:07 paul Exp paul $ */
d109 1
a109 1
         	error("Negative sized code directive encountered");
a449 33
#ifdef NEW_STUBS
	     else if (ptype == OBJCODESTUB)
	       {
		 movesym( v );		/* implicit GLOBAL declaration */

                 refsymbol_nondef( v );

		 if (*s->name == '.')
		   {
		     VMRef	ref;		  
		     char	buf[ 128 ];	/* XXX */
		     
		     
		     strcpy( buf, s->name );
		     
		     *buf = '_';
		     
		     ref = lookup( buf );
		     
		     if (NullRef( ref ))
		       {
			 ref = insert( buf, FALSE );
			 s   = VMAddr( Symbol, ref );
			 
			 /* XXX - should we dirty ref ??? */
			 
			 s->type = S_UNBOUND;		      
		       }
		     
		     refsymbol_nondef( ref );		  
		   }
	       }	  
#endif /* NEW_STUBS */
@


1.16
log
@implicit export of any codetable directives symbols
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.15 1992/07/15 15:24:39 paul Exp $ */
d244 1
d246 1
a246 1

@


1.15
log
@fixed library access to codstub directives
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.14 1992/07/15 08:26:32 nickc Exp $ */
d240 1
d243 3
@


1.14
log
@fixed yucky bug in globalizing code stubs
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.13 1992/07/13 08:58:56 nickc Exp nickc $ */
d343 3
d449 3
a451 12
#if 1
		 s = VMAddr( Symbol, v );
		 VMlock( v );
		 
		 s->referenced = TRUE;

		 VMDirty( v );
		 VMunlock( v );		 
#else
		 if (s->referenced)
		   refsymbol_def( v );
#endif		 
@


1.13
log
@fixed to support new patch CODESTUB
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.12 1992/07/02 13:37:50 nickc Exp nickc $ */
d446 3
d450 5
d457 1
a457 1
		 
@


1.12
log
@fixed bug whereby REFs were not automatically promoted to global
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.11 1992/06/25 14:36:16 nickc Exp $ */
d23 1
a23 1
#define trace if(traceflags&db_gencode) _trace
d84 3
a86 3
   VMRef v;
   Symbol *s;
   word op = 0;
d315 2
a316 2
   word type = rdint();
   int size = (int)op & 0x7;
d318 6
a323 5
   copycode();
   trace("Read PATCH");
   switch( type )
   {
   default:
d327 1
a327 1
   case OBJMODSIZE:
d332 1
a332 1
   case OBJMODNUM:
d337 1
a337 1
   case OBJCODESYMB:
d340 6
a345 6
   case OBJLABELREF:
   case OBJDATASYMB:
   case OBJDATAMODULE:
   {
      VMRef v = rdsymb();
      Symbol *s;
d347 26
a372 1
      if (type == OBJDATAMODULE)
d374 16
a389 1
	  movesym(v);		/* implicit GLOBAL declaration */
a390 25

      s = VMAddr(Symbol,v);

      trace("Single level %s %s %#x",
                    type == OBJDATASYMB   ? "DATASYMB":
                    type == OBJDATAMODULE ? "DATAMODULE":
                    type == OBJCODESYMB   ? "CODESYMB": "LABELREF",s->name,v);

      refsymbol_nondef(v);

      (void)newcode(op,size,type,curloc,v);

      break;
   }

   case OBJPATCH:      case OBJPATCH + 1:  case OBJPATCH + 2:
   case OBJPATCH + 3:  case OBJPATCH + 4:  case OBJPATCH + 5:
   case OBJPATCH + 6:  case OBJPATCH + 7:  case OBJPATCH + 8:
   case OBJPATCH + 9:  case OBJPATCH + 10: case OBJPATCH + 11:
   case OBJPATCH + 12:
   {
        Patch *p;
        word pword = 0;		/* patch data */
        int ptype;		/* patch type */
        VMRef pv = VMNew(sizeof(Patch));
d392 3
a394 2
        if (type != PATCHSWAP)	/* no patch data for swap patch */
         	pword = rdint();	/* patch data */
d396 1
a396 12
        p = VMAddr(Patch,pv);
        p->word = pword;
        p->type = ptype = (int)rdint();	/* patch type */
       
        patchpatch(pv, ptype);	/* patch in value of type, or another patch */
      
        (void)newcode(op,size,type,curloc,pv);
        break;
     }
   
   }
   curloc += size;
d425 3
d442 34
d485 5
a489 1
		                            "LABELREF", s->name, v );
d549 2
a550 2
   VMRef 	v = VMNew( sizeof (Module) );
   Module *	m = VMAddr(Module,v);
d557 1
a557 1
   
d567 5
a571 5
   for ( i = 0; i < HASHSIZE ; i++ )
   {
	m->symtab[i].head = NullVMRef,
      	m->symtab[i].entries = 0;
   }
d576 1
a576 1
   if( !inlib )
d578 1
a578 1
      Module *		tm = VMAddr(Module,tailmodule);
d584 1
a584 1
      if ( NullRef(firstmodule) )
d594 1
a594 1
   (void)newcode((WORD)OBJMODULE,0l,0l,curloc,v);
d596 1
a596 1
   curloc = 0;
d602 1
d606 1
a606 1
   Module *m;
d611 1
a611 1
   m = VMAddr(Module,curmod);
d616 1
a616 1

@


1.11
log
@added stdin debugging
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.10 1992/06/22 13:55:26 nickc Exp nickc $ */
d160 3
a162 1
	 refsymbol_nondef(rdsymb());
d168 1
a168 2

         trace("GLOBAL %s",s->name);
d193 1
d684 1
a684 1
      Symbol *s;
d686 1
a686 1

@


1.10
log
@added code to store module's file name when a module structure is created
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.9 1992/04/27 12:38:38 nickc Exp nickc $ */
d594 9
a602 1
   return getc(infd);
@


1.9
log
@minor cosmetic changes
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.8 1992/04/16 17:07:23 nickc Exp nickc $ */
d516 3
a518 2

   for( i = 0; i < HASHSIZE ; i++ )
@


1.8
log
@added code to support filenames for symbols
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.7 1991/11/06 15:03:36 paul Exp nickc $ */
d166 1
d170 3
a172 1
         	refsymbol_def(v);
d344 4
a347 2
      if(type == OBJDATAMODULE)
         movesym(v);		/* implicit GLOBAL declaration */
d417 33
a449 25
      {
         VMRef v = rdsymb();
         Symbol *s;

         s = VMAddr(Symbol,v);

	 if(ptype == OBJDATAMODULE)
	 {
	 	movesym(v);		/* implicit GLOBAL declaration */

		if (s->referenced)
			refsymbol_def(v);
	 }
	 else
	         refsymbol_nondef(v);

         trace("PatchPatch %s %s %#x",
         		ptype == OBJDATASYMB   ? "DATASYMB":
         		ptype == OBJDATAMODULE ? "DATAMODULE":
         		ptype == OBJCODESYMB   ? "CODESYMB": "LABELREF",s->name,v);
         p = VMAddr(Patch,pv);
         p->value.v = v;
         VMDirty(pv);
         break;
      }
@


1.7
log
@changed name of IMAGESIZE directive to MODSIZE (as thats what it is!)
@
text
@d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.6 1991/10/09 08:47:51 paul Exp paul $ */
a20 1

d87 4
a90 2
      
   do {
d106 2
d110 1
d112 1
d114 1
d121 2
d124 2
a125 1
         	error("Negative sized bss defined");
d127 1
d129 1
d179 1
a179 1
	       warn("Duplicate definition of '%s'",s->name);
d186 1
d196 5
a200 2
         if (size < 0)
         	error("Negative sized data/common directive encountered");
d202 1
d204 1
d206 1
d212 1
a212 1
                 warn("Duplicate definition of '%s'",s->name);
d223 1
d241 2
a242 1
                 warn("Duplicate definition of '%s'",s->name);
d248 2
d260 2
d491 1
d510 1
a510 1
   /* if this is a library module, we do not link it by default but*/
d512 1
d517 1
d532 1
d535 2
d539 2
a540 1
PUBLIC void genend()
d543 2
d555 1
d641 2
a642 1
VMRef rdsymb()
d644 4
a647 4
   VMRef v;
   char buf[128];
   word pos = 0;
   word c;
d649 2
a650 1
   do {
d653 2
a654 1
   } while( c != 0 );
d656 1
a656 1
   v = lookup(buf);
d658 2
a659 2
   if( NullRef(v) ) 
   {
d661 2
d666 1
a666 1
   }
d668 1
a668 1
   return v;
@


1.6
log
@NickC's changes for the 'C40 + some bug fixes
@
text
@d14 1
a14 1
/*              IMAGESIZE directive                             */
d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.3 1991/10/08 13:01:47 nickc Exp $ */
d297 2
a298 2
   case OBJIMAGESIZE:
      trace("IMAGESIZE");
d374 2
a375 2
      case OBJIMAGESIZE:
         trace("PATCH IMAGESIZE");
@


1.5
log
@Fixed unitialised Symbol * s causing core dump
@
text
@d15 2
d19 1
a19 1
/* RcsId: $Id: readfile.c,v 1.4 1991/04/18 10:10:42 ben Exp $ */
d102 1
a102 1
      case t_code:
d112 1
a112 1
      case t_bss:
d122 2
a123 2
      case t_word: 
         genpatch(t_word);
d126 2
a127 2
      case t_short: 
         genpatch(t_short);
d130 2
a131 2
      case t_byte:
         genpatch(t_byte);
d134 1
a134 1
      case t_init:
d138 1
a138 1
      case t_module:
d142 1
a142 1
      case t_bytesex:
d148 5
a152 1
      case t_global:
d158 1
a158 1
         	refsymbol(v,1);
d161 1
a161 1
      case t_label:
d165 1
a165 1
         if( s->type != s_unbound ) 
a168 1

d172 1
a172 1
            s->type = s_codesymb;
d176 1
a176 1
            	refsymbol(v,1);
d180 2
a181 2
      case t_data:
      case t_common:
d188 2
a189 2
         trace("%s %d %s",op==t_data?"DATA":"COMMON",size,s->name);
         if( s->type != s_unbound ) 
d191 1
a191 1
            if( s->type != s_commsymb)
d202 1
a202 1
            s->type = op==t_data?s_datasymb:s_commsymb;
d206 1
a206 1
            	refsymbol(v,1);
d212 1
a212 1
      case t_func:
d219 1
a219 1
         if( s->type != s_unbound ) 
d225 1
a225 1
            s->type = s_funcsymb;
d229 1
a229 1
            	refsymbol(v,1);
d253 8
a260 4
        trace("genbyte %2x",value);
        if ( codepos >= 255 ) copycode();
        codevec[codepos] = (UBYTE)value;
   codepos++;
d268 1
a268 1
      (void)newcode((WORD)t_literal,codepos,0l,curloc,*((INT *)codevec));
d276 2
a277 2
      
                (void)newcode((WORD)t_code,codepos,0l,curloc,vmr);
d297 1
a297 1
   case t_imagesize:
d302 1
a302 1
   case t_modnum:
d307 1
a307 1
   case t_funcref:
d310 3
a312 3
   case t_labelref:
   case t_dataref:
   case t_datamod:
d317 1
a317 1
      if(type == t_datamod)
d321 1
d323 6
a328 4
                    type==t_dataref?"DATAREF":
                    type==t_datamod?"DATAMOD":
                    type==t_funcref?"FUNCREF": "LABELREF",s->name,v);
      refsymbol(v,0);
d330 1
d334 5
a338 5
   case t_patch:     case t_patch+1:   case t_patch+2:
   case t_patch+3:   case t_patch+4:   case t_patch+5:
   case t_patch+6:   case t_patch+7:   case t_patch+8:
   case t_patch+9:   case t_patch+10:  case t_patch+11:
   case t_patch+12:
d345 1
a345 1
        if (type != t_patch_swap)	/* no patch data for swap patch */
d374 1
a374 1
      case t_imagesize:
d378 1
a378 1
      case t_modnum:
d382 1
a382 1
      case t_funcref:
d385 3
a387 3
      case t_dataref:
      case t_datamod:
      case t_labelref:
d394 1
a394 1
	 if(ptype == t_datamod)
d399 1
a399 1
			refsymbol(v,1);
d402 1
a402 1
	         refsymbol(v,0);
d405 3
a407 3
         		ptype==t_dataref?"DATAREF":
         		ptype==t_datamod?"DATAMOD":
         		ptype==t_funcref?"FUNCREF": "LABELREF",s->name,v);
d414 5
a418 5
      case t_patch:     case t_patch+1:   case t_patch+2:
      case t_patch+3:   case t_patch+4:   case t_patch+5:
      case t_patch+6:   case t_patch+7:   case t_patch+8:
      case t_patch+9:   case t_patch+10:  case t_patch+11:
      case t_patch+12:
d426 1
a426 1
         if (ptype != t_patch_swap)	/* no patch data for swap patch */
d449 1
a449 1
   c1 = newcode(t_init,4l,0l,curloc,NullVMRef);
d463 3
a465 3
   int i;
   VMRef v = VMNew(sizeof(Module));
   Module *m;
a470 2
   m = VMAddr(Module,v);
   
d473 5
a477 1
   curloc = 0;
d479 5
a483 6
   m->next = NullVMRef;
   m->start = codeptr();
   m->id = mod;
   m->linked = FALSE;
   for( i = 0; i < HASHSIZE ; i++ ) m->symtab[i].head = NullVMRef,
      m->symtab[i].entries = 0;
a484 2
   (void)newcode((WORD)t_module,0l,0l,curloc,v);

d489 2
a490 1
      Module *tm = VMAddr(Module,tailmodule);
d492 4
a495 2
         m->linked = TRUE;
         if( NullRef(firstmodule) ) firstmodule = v;
d499 1
d501 5
a506 3
   trace("curmod = %x",curmod);
        
   /* leave new curmod locked */
d515 6
a521 2
   m->length = curloc;
   m->end = newcode((WORD)t_end,0l,0l,curloc,0l);
d626 1
a626 1
      s->type = s_unbound;
@


1.4
log
@Cured potential GLOBAL bug (now does refsymbol(v,1) after declaration)
@
text
@d17 1
a17 1
/* RcsId: $Id: readfile.c,v 1.3 1991/04/11 19:17:05 ben Exp $ */
d379 2
a389 2

         s = VMAddr(Symbol,v);
@


1.3
log
@Fixed scanned libs bug
@
text
@d17 1
a17 1
/* RcsId: $Id: readfile.c,v 1.2 1991/04/11 14:31:25 ben Exp $ */
a37 1
void dorefs(bool);
a53 1
void dorefs();
d151 2
d163 1
d219 1
a219 1
         else {
d380 1
d383 6
a388 1
         refsymbol(v,0);
d390 1
a499 1
   dorefs(m->linked); /* Nick REFLIST code */
@


1.2
log
@Fixed code length bug with scanned libraries
@
text
@d17 1
a17 1
/* RcsId: $Id: readfile.c,v 1.1 90/10/22 15:47:08 paul Exp $ */
d490 1
a490 3
   if (m->linked)
	  totalcodesize += curloc;

@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
/* RcsId: $Id$ */
d255 1
d487 1
a487 2
   totalcodesize += curloc;
   trace("Last module size = %d, total code size = %d",curloc,totalcodesize);
d489 4
@
