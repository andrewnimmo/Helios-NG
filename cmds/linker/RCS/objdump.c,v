head	1.33;
access;
symbols
	Helios_1_3_1:1.27
	Helios_C40_1_3_Official_Release:1.27
	Alenia_release:1.27
	C40_Field_Test_2:1.25
	C40_Field_Test_R1:1.15;
locks; strict;
comment	@ * @;


1.33
date	94.02.08.11.23.14;	author vlsi;	state Exp;
branches;
next	1.32;

1.32
date	94.01.26.15.02.13;	author vlsi;	state Exp;
branches;
next	1.31;

1.31
date	94.01.07.14.24.06;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	94.01.05.14.56.51;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	93.12.17.15.43.32;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	93.12.17.15.14.33;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	92.12.16.19.11.43;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	92.11.10.14.46.39;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	92.10.01.10.23.43;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	92.09.14.08.34.57;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	92.09.14.08.31.53;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	92.09.04.14.35.10;	author paul;	state Exp;
branches;
next	1.21;

1.21
date	92.09.03.16.15.27;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	92.08.17.16.18.03;	author paul;	state Exp;
branches;
next	1.19;

1.19
date	92.07.15.15.58.30;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	92.07.15.15.55.08;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	92.07.15.15.46.58;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	92.07.13.09.01.12;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	92.06.15.12.02.29;	author paul;	state Exp;
branches;
next	1.14;

1.14
date	92.05.13.10.50.32;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	92.04.21.14.18.59;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	92.04.16.15.57.07;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	92.02.05.11.55.49;	author paul;	state Exp;
branches;
next	1.10;

1.10
date	91.11.06.15.03.36;	author paul;	state Exp;
branches;
next	1.9;

1.9
date	91.10.29.13.21.26;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	91.10.23.13.37.36;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	91.10.21.15.35.06;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	91.10.18.15.31.32;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	91.10.09.11.12.56;	author paul;	state Exp;
branches;
next	1.4;

1.4
date	91.10.08.17.29.57;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	91.10.08.17.08.33;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	91.10.08.15.51.33;	author ben;	state Exp;
branches;
next	1.1;

1.1
date	90.10.22.15.46.58;	author paul;	state Exp;
branches;
next	;


desc
@@


1.33
log
@The fp and sl register names were swapped.
@
text
@/*
 * Dump the contents of an Helios object file
 *
 * objdump.c
 *
 * Authors:
 *   Criss Selwyn 	December '88
 *   Paul Beskeen 	March    '89 ...
 *   Tony Cruickshank 	June     '89
 *   James G Smith 	May     1990	Added ARM disassembler (and other tweaks)
 *   Nick Clifton	August  1991	Added C40 tweaks
 *   James G Smith  January 1994    Use new "ARM Ltd clx" disassembler
 *
 * RCS:
 *  $Header: /src/RTNucleus/cmds/linker/RCS/objdump.c,v 1.33 1994/02/07 11:38:34 jsmith Exp $
 *
 * @@@@@@ Note that this command assumes that the input is in little endian format
 */


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

#if defined(SUN4) || defined(__unix)
#include <unistd.h>	/* for SEEK_SET */
#endif

#ifdef __ARM
#if defined(SUN4) || defined(RS6000) /* FIXME: we need a native Helios-ARM version of clxlib.a */
#include "disass.h" /* currently held in "armltd.binaries/include" */
#else
#include "ARMshape.h"
#endif
#endif

#include "link.h"	/* for OBJCODE etc */

#ifndef FALSE
#define TRUE	~0
#define FALSE	0
#endif

#define MORE		0x80
#define NFLAG		0x40

char *	ProgName     = NULL;
FILE *	f            = NULL;
FILE *	outfd        = stdout;
int 	pc           = 0;
int 	dataoff      = 0;
int 	codetableoff = 0; 	/* split mod tab support */
int 	ch;
int 	ShortOutput  = 1;
int 	sizeinfo     = 0;	/* provide image and static data area information */
int 	nameinfo     = 0;	/* provide symbol definition information */

#if defined __ARM || defined __C40
int 	dodisass     = 0;	/* No disassembly by default */
int	pcsregs	     = FALSE;	/* default to std machine register names */

#if defined(__ARM) && (defined(SUN4) || defined(RS6000))
static char *local_decode(dis_cb_type type,int32 offset,unsigned32 address,int width,void *arg,char *buffer)
{
 /* We provide no more decoding at the moment */
 return(buffer) ;
}

static void disassemble(unsigned long instruction,unsigned long pc,int flag)
{
 static char buffer[256] ; /* disassembly line */

 disass_32or26((unsigned32)instruction,(unsigned32)pc,buffer,NULL,local_decode,TRUE) ;
 printf(buffer) ;
 return ;
}
#else
extern void	disassemble( unsigned long instruction, unsigned long pc, int flag );
#endif
#endif


/*-------------------------start of code---------------------------------------------*/

/*
 * display an error or information message
 */

void
inform(
       char *	message,
       ...		)
{
  va_list	args;


  va_start( args, message );

#if 0
  fflush( stderr );

  fseek( stderr, 0L, SEEK_END );
#endif
  
  if (ProgName)
    fprintf( stderr, "%s: ", ProgName );

  vfprintf( stderr, message, args );

  fprintf( stderr, "\n" );

#if 0
  fflush( stderr );
#endif
  
  va_end( args );

  return;
  
} /* inform */


void
tidyup( int n )
{
  if (f)
    fclose( f );
  
  exit( n );

} /* tidyup */


int
readobjnum( void )
{
  int 	ch     = getc( f );
  int 	nflag  = (ch & NFLAG) != 0;
  int 	r      = ch & 0x3f;

  
  if (ch == EOF)
    {
      inform( "Error - Unexpected EOF" );

      tidyup( 1 );
    }
  
   while ((ch & MORE) != 0)
     {
       if ((ch = getc( f )) == EOF)
	 {
	   inform( "Error - Unexpected EOF" );
	   
	   tidyup( 1 );
	 }

       r  = (r << 7) + (ch & 0x7f);
     }

  return nflag ? -r : r;

} /* readobjnum */


void
show_string( void )
{
  char	ch;
  

  while ((ch = getc( f )) != 0)
    {
      if (!sizeinfo)
	fputc( ch, outfd );
    }

  return;
  
} /* show_string */


void
show_label_string( void )
{
  char	ch;

  
  while ((ch = getc( f )) != 0)
    {
      if (!sizeinfo || nameinfo)
	fputc( ch, outfd );
    }

  fputc( ':', outfd ); 

  return;
  
} /* show_label_string */


void
show_code( int n )
{
#define CODEMAX 16
  int 		i;
#if defined __ARM || defined __C40
  unsigned int 	instruction;
  int          	localpc = pc;
  int		doprint = 1;

  
  if (dodisass)
    {
      /*
       * Provide disassembled code sections in the C40/ARM versions.
       * Note: This cannot synchronise on the instructions if the CODE is
       *	    actually non-word-aligned data.
       *
       * We are called with the text "PC = 0xZZZZ " already displayed.
       */
      
      if (!sizeinfo)
	fprintf( outfd, "CODE %#x\n", n );
     
      i = 0;
      
      while ((n - i) >= 4)		/* enough for an C40/ARM instruction */
	{
	  int	j;

	  
	  instruction = 0x00000000;

#ifdef __BIGENDIAN
	  for (j = 0; (j < 4); j++)
	    instruction = (instruction << 8) | (getc( f ) & 0xFF);
#else
	  for (j = 0; (j < 4); j++)
	    instruction |= (getc( f ) << (j * 8));
#endif

	  if (!sizeinfo) 
	    {
#ifdef __C40
	      fprintf( outfd, "PC = %#010x ", localpc / 4 );
	      fprintf( outfd, "     %#010x ", instruction );
#else
	      fprintf( outfd, "PC = %08X ", localpc );
	      fprintf( outfd, "     %08X ", instruction );
#endif
	      
	      for (j = 0; (j < 4); j++)
		{
#ifdef __BIGENDIAN
		  char	dc = (instruction >> ((3 - j) * 8)) & 0xFF;
#else
		  char  dc = (instruction >> (j * 8)) & 0xff;
#endif		  
		  fputc( ((dc < ' ') || (dc > 0x7E)) ? '.' : dc, outfd );
		}
	      
	      fprintf( outfd, "     " );
	      
	      disassemble( instruction, localpc, FALSE );
	      
	      fputc( '\n', outfd );
	    }
	  
	  localpc += 4;		/* nice byte addressed machine */
	  i       += 4;
	}

      /* deal with any non-word aligned data at the end */
      
      if (i < n)
	{
	  int j;

	  if (!sizeinfo)
	    {
#ifdef __C40
	      fprintf( outfd, "PC = %#010x        ", localpc / 4 );
#else
	      fprintf( outfd, "PC = %08X      ", localpc );
#endif
	      
	      for (j = 0; (j < (4 - (n - i))); j++)
		fprintf( outfd, "  " );
	    }

	  instruction = 0x00000000;
	  
#ifdef __BIGENDIAN
	  for (j = 0; (j < n - i); j++)
	    instruction = (instruction << 8) | (getc( f ) & 0xFF);
#else
	  for (j = 0; (j < (n - i)); j++)
	    instruction |= (getc( f ) & 0xff) << (j * 8);
#endif

	  if (!sizeinfo)
	    {
	      for (j = (n - i); (j > 0);)
		{
		  j--;
		  
		  fprintf( outfd, "%02x",(instruction & (0xFF << (j * 8))) >> (j * 8));
		}

	      fputc( ' ', outfd );

	      for (j = 0; (j < (4 - (n - i))); j++)
		fputc( ' ', outfd );

	      for (j = 0; (j < (n - i)); j++)
		{
#ifdef __BIGENDIAN
		  char	dc = (instruction >> ((3 - j) * 8)) & 0xFF;
#else
		  char	dc = (instruction >> (j * 8)) & 0xFF;
#endif
		  
		  fputc( ((dc < ' ') | (dc > 0x7E)) ? '.' : dc, outfd );
		}

#ifdef __C40
	      fprintf( outfd, " :\n" );
#else
          fprintf( outfd, "\n" );
#endif
	    }
	}
    }
  else
    {
      if (!sizeinfo)
	fprintf( outfd, "CODE %#x :", n );
      else
	doprint = 0;

      for (i = 1; (i <= n); i++)
	{
	  if ((i % CODEMAX) == 0)
	    {
	      if (!sizeinfo)
		{
		  if (ShortOutput)
		    doprint = 0 ;
		  else
		    fprintf( outfd, "\n\t" );
		}
	    }

	  if (doprint)
	    fprintf( outfd, " %02X", getc( f ) );
	  else
	    fseek( f, SEEK_CUR, 1 );
	}

      if (!sizeinfo)
	fputc( '\n', outfd );
    }
#else /* neither __ARM nor __C40 */
  int	doprint = 2;


  fprintf( outfd, "CODE %#x :", n );

  for (i = 0; i < n; i++)
    {
      if (i % CODEMAX == 0)
	{
	  if (ShortOutput)
	    --doprint;
	  else
	    fprintf( outfd, "\n\t" );
	}

      if (doprint > 0)
	fprintf( outfd, " %02X", getc( f ) );
      else
	fseek( f, SEEK_CUR, 1 );
    }

  fputc( '\n', outfd );
  
#endif /* __ARM || __C40 */

  return;
  
} /* show_code */


void
show_patch( char * s )
{
  int	ch = getc( f );


  if (ch == EOF)
    {
      inform( "\nError: unexpected end of file in image, pos = %ld", ftell( f ) );

      return;
    }
  
  if (!sizeinfo)
    fprintf( outfd, "%s ", s );

  if (OBJPATCH <= ch && ch <= OBJPATCHMAX)
    {
      int n = 0;

      
      if (ch != PATCHSWAP)
	n = readobjnum();

      if (!sizeinfo)
	{
	  switch (ch)
	    {
	    case PATCHADD:  
	      fprintf( outfd, "PATCH ADD: %#x ", n );
	      break;
	      
	    case PATCHSHIFT:
	      fprintf( outfd, "PATCH SHIFT by: %d ", n );
	      break;

#ifdef __ARM
	    case PATCHARMDT:
	      fprintf( outfd, "PATCH ARM DT    : ");
	      
	      if (dodisass)
		disassemble( n, pc, FALSE );
              else
		fprintf( outfd, "0x%08X", n );
	      
	      fprintf( outfd, " :" );
	      break;
	      
	    case PATCHARMDP:
	      fprintf( outfd, "PATCH ARM DP    : " );
	      
	      if (dodisass)
		disassemble( n, pc, FALSE );
              else
		fprintf( outfd, "0x%08X", n );
	      
	      fprintf( outfd, " :" );
	      break;
	      
	    case PATCHARMDPLSB:
	      fprintf( outfd, "PATCH ARM DPLSB : " );

	      if (dodisass)
		disassemble( n, pc, FALSE );
              else
		fprintf( outfd, "0x%08X", n );
	      
	      fprintf( outfd, " :" );
	      break;
	      
	    case PATCHARMDPREST:
	      fprintf( outfd, "PATCH ARM DPREST: " );
	      
	      if (dodisass)
		disassemble( n, pc, FALSE );
              else
		fprintf( outfd, "0x%08X", n );
	      
	      fprintf( outfd, " :" );
	      break;
	      
	    case PATCHARMDPMID:
	      fprintf( outfd, "PATCH ARM DPMID : " );
	      
	      if (dodisass)
		disassemble( n, pc, FALSE );
              else
		fprintf( outfd, "0x%08X", n );

	      fprintf( outfd, " :" );
	      break;
	      
	    case PATCHARMJP:
	      fprintf( outfd, "PATCH ARM JP    : " );

	      if (dodisass)
		disassemble( n, -8, FALSE );
              else
		fprintf( outfd, "0x%08X", n );
	      
	      fprintf( outfd, " :" );
	      break;


	    case PATCHARMAOFLSB:
	      fprintf( outfd, "PATCH ARM AOF LSB : r%d :", n );
	      break;
	      
	    case PATCHARMAOFREST:
	      fprintf( outfd, "PATCH ARM AOF REST: r%d :", n );
	      break;
	      
	    case PATCHARMAOFMID:
	      fprintf( outfd, "PATCH ARM AOF MID : r%d :", n );
	      break;
#endif /* __ARM */
	      
#ifdef __C40
	    case PATCHC40DATAMODULE1:
	      fprintf( outfd, "M/C PATCH C40 DATAMODULE1: " );

	      if (dodisass)
		disassemble( n, pc, TRUE );
	      else
		fprintf( outfd, "%#010x ", n );
	      break;

	    case PATCHC40DATAMODULE2:
	      fprintf( outfd, "M/C PATCH C40 DATAMODULE2: " );

	      if (dodisass)
		disassemble( n, pc, TRUE );
	      else
		fprintf( outfd, "%#010x ", n );
	      break;

	    case PATCHC40DATAMODULE3:
	      fprintf( outfd, "M/C PATCH C40 DATAMODULE3: " );

	      if (dodisass)
		disassemble( n, pc, TRUE );
	      else
		fprintf( outfd, "%#010x ", n );
	      break;

	    case PATCHC40DATAMODULE4:
	      fprintf( outfd, "M/C PATCH C40 DATAMODULE4: " );

	      if (dodisass)
		disassemble( n, pc, TRUE );
	      else
		fprintf( outfd, "%#010x ", n );
	      break;

	    case PATCHC40DATAMODULE5:
	      fprintf( outfd, "M/C PATCH C40 DATAMODULE5: " );

	      if (dodisass)
		disassemble( n, pc, TRUE );
	      else
		fprintf( outfd, "%#010x ", n );
	      break;

	    case PATCHC40MASK24ADD:
	      fprintf( outfd, "M/C PATCH C40 MASK 24 ADD: " );

	      if (dodisass)
		disassemble( n, pc, TRUE );
	      else
		fprintf( outfd, "%#010x ", n );
	      
	      break;

	    case PATCHC40MASK16ADD:
	      fprintf( outfd, "M/C PATCH C40 MASK 16 ADD: " );

	      if (dodisass)
		disassemble( n, pc, TRUE );
	      else
		fprintf( outfd, "%#010x ", n );
	      
	      break;

	    case PATCHC40MASK8ADD:
	      fprintf( outfd, "M/C PATCH C40 MASK 8 ADD: " );

	      if (dodisass)
		disassemble( n, pc, TRUE );
	      else
		fprintf( outfd, "%#010x ", n );

	      break;

#endif /* __C40 */

	    case PATCHSWAP:
	      fprintf( outfd, "PATCH SWAP: " );
	      break;
	      
	    case PATCHOR:
	      fprintf( outfd, "PATCH OR: %#x ", n );
	      break;
	      
	    default:
	      inform( "Warning - unknown M/C Patch %#x : %#x\n", ch, n );
	      
	      fprintf( outfd, "Unknown M/C Patch %#x\n", ch );
	    }
	} /* if (!sizeinfo) */

      show_patch( "" );
    }
  else
    {
      switch( ch )
	{
	case OBJDATASYMB:
	  if (!sizeinfo)
	    fprintf( outfd, "DATASYMB " );
	  
	  show_string();
	  break;
	  
	case OBJCODESYMB:
	  if (!sizeinfo)
	    fprintf( outfd, "CODESYMB " );
	  
	  show_string();
	  break;
	  
	case OBJDATAMODULE:
	  if (!sizeinfo)
	    fprintf( outfd, "DATAMODULE " );
	  
	  show_string();
	  break;
	  
	case OBJMODSIZE:
	  if (!sizeinfo)
	    fprintf( outfd, "MODSIZE" );
	  
	  break;
	  
	case OBJMODNUM:
	  if (!sizeinfo)
	    fprintf( outfd, "MODNUM" );
	  
         break;
	  
	case OBJLABELREF:
	  if (!sizeinfo)
	    fprintf( outfd, "LABELREF " );
	  
	  show_string();
	  break;

#ifdef __C40
	case OBJCODESTUB:
	  if (!sizeinfo)
	    fprintf( outfd, "CODESTUB " );
	      
	  show_string();
	      
	  break;	

	case OBJADDRSTUB:
	  if (!sizeinfo)
	    fprintf( outfd, "ADDRSTUB " );
	      
	  show_string();
	      
	  break;	
#endif /* __C40 */
	  
	default:
	  inform( "Warning - bad patch object format: %#x at offset 0x%08X", ch, (ftell( f ) - 1 ) );
	  
	  fprintf( outfd, "Bad patch object format: %#x\n", ch );
#if 0
	  tidyup( 1 );
#endif
	}
    }

  return;
  
} /* show_patch */


void
usage( void )
{
#if defined __ARM || defined __C40
  inform( "Usage: [-h] [-l] [-d] [-p] [-i] [-n] [+pcinc] [-o output-file] input-files" );
#else
  inform( "Usage: [-h] [-l] [-i] [-n] [+pcinc] [-o output-file] input-files" );
#endif
  
  inform( "-h :         Provide this help information" );
  inform( "-l :         Give full information (long)"  );
  
#if defined __ARM || defined __C40
  inform( "-d :         Provide disassembly" );
  inform( "-p :         Use PCS register names in disassembly" );
#endif

  inform( "-i :         Provide image size and static allocation info only" );
  inform( "-n :         Provide symbol definition information only" );
  inform( "+pcinc:      Allows you to add an address offset. This can" );
  inform( "             be used between the input files." );
  inform( "-o <file> :  Specifies the name of a file to contain the program's output" );
  
  tidyup( 1 );

  return;
  
} /* usage */

#if defined(__ARM) && (defined(SUN4) || defined(RS6000))
char *ARM_regnames[] = {"a1","a2","a3","a4","v1","v2","v3","v4","v5","dp","sl","fp","ip","sp","lr","pc"} ;
#endif

int
main(
     int 	argc,
     char **	argv )
{
  char *	s;
  int 		i;
  int 		file = 0;

#if defined(__ARM) && (defined(SUN4) || defined(RS6000))
  disass_setregnames(ARM_regnames,NULL) ;
#endif

  if ((s = (char *)strrchr( argv[ 0 ], '/' )) != NULL)
    {
      ProgName = s + 1;
    }
  else
    {
      ProgName = argv[ 0 ];
    }
  
  if (argc < 2)
    usage();

  /* Parse Arguments */
  
  for (i = 1; i < argc; ++i)
    {
      s = argv[ i ];
      
      if (*s != '-' && *s != '+')
	{
	  file++;
	  
	  if ((f = fopen( argv[ i ], "rb" )) == 0)
	    {
	      inform( "Error - Unable to open input file: %s\n", argv[ i ] );
	      
	      tidyup( 1 );
	    }

	  fprintf( outfd, "OBJECTFILE: %s\n", argv[ i ] );
	}
      else
	{
	  if (*s++ == '-')
	    {
	      switch (*s++)
		{
		case 'l' :
		  ShortOutput = 0;
		  break;

		case 'h' :
		  usage();
		  break;		/* should never get here */

		case 'i' :
		  sizeinfo = -1;
		  break;

		case 'n' :
		  sizeinfo = -1;	/* stop full object dump */
		  nameinfo = -1;	/* but provide name information */
		  break;
#if defined __ARM || defined __C40
		case 'd' :
		  dodisass = -1;
		  break;
		case 'p':
		  pcsregs = TRUE;
		  break;		  
#endif
		case 'o':
		  if (*s == '\0')
		    s = argv[ ++i ];		  

		  outfd = fopen( s, "w" );

		  if (outfd == NULL)
		    {
		      inform( "Warning - unable to open output file %s", s );

		      outfd = stdout;
		    }
		  
		  break;

		default:
		  inform( "Warning - Unknown switch %c", *s );
		  usage();
		  break;
		}
	    }
	  else /* must be + */
	    {       
	      if (*s != '\0')
		pc += atoi( s );
	      else
		pc += atoi( argv[ ++i ] );
	    }
	  
	  continue;
	}

      /* Quick check.
       * If the first byte of the file is not a GHOF directive
       * then we are not parsing a GHOF file and we can abort.
       */

      ch = getc( f );

      if (ch == EOF)
	{
	  inform( "Empty input file!" ); 
	}
      else if (ch >= NFLAG)
	{
	  inform( "Input file is not in GHOF format" );

	  if (ch == 0xc5) inform( "Input file might be in ARM Object Format" );
	  else if (ch == 0xc3) inform( "Input file might be in byte swapped ARM Object Format" );
	}
      else
	{
	  do
	    {
	      int	n;
	      
	      
	      if (!sizeinfo)
#ifdef __C40
		fprintf( outfd, "PC = %#010x ", pc / 4 );
#else
	      fprintf( outfd, "PC = %08X ", pc );
#endif
	      
	      switch (ch)
		{
		case OBJCODE:
		  n = readobjnum();
		  
		  if (n < 0)
		    inform( "CODE directive encountered with negative size (%x)", n );
		  else
		    show_code( n );
		  
		  pc += n;
		  
		  break;
		  
		case OBJBSS:
		  n = readobjnum();
		  
		  if (!sizeinfo)
		    fprintf( outfd, "BSS: %#x\n", n );
		  
		  pc += n;
		  
		  break;
		  
		case OBJINIT:
		  if (!sizeinfo)
		    fprintf( outfd, "INIT\n" );
		  
		  pc += 4;
		  
		  break;
		  
		case OBJBYTE:
		  show_patch( "BYTE" );
		  
		  if (!sizeinfo)
		    fputc( '\n', outfd );
		  
		  pc += 1;
		  
		  break;
		  
		case OBJSHORT:
		  show_patch( "SHORT" );
		  
		  if (!sizeinfo)
		    fputc( '\n', outfd );
		  
		  pc += 2;
		  
		  break;
		  
		case OBJWORD:
		  show_patch( "WORD" );
		  
		  if (!sizeinfo)
		    fputc( '\n', outfd );
		  
		  pc += 4;
		  
		  break;
		  
		case OBJMODULE:
		  n = readobjnum();
		  
		  if (!sizeinfo)
		    fprintf( outfd, "MODULE %d\n", n );
		  
		  break;
		  
		case OBJGLOBAL:
		  if (!sizeinfo)
		    fprintf( outfd, "GLOBAL " );
		  
		  show_string();
		  
		  if (!sizeinfo)
		    fputc( '\n', outfd );
		  
		  break;
		  
		case OBJLABEL:
		  if (nameinfo)
#ifdef __C40
		    fprintf( outfd, "PC = %#010x ", pc / 4 );
#else
		  fprintf( outfd, "PC = %08X ", pc );
#endif		    
		  if (!sizeinfo || nameinfo)
		    fprintf( outfd, "LABEL " );
		  
		  show_label_string();
		  
		  if (!sizeinfo || nameinfo)
		    fputc( '\n', outfd );
		  
		  break;
		  
		case OBJDATA:
		  n = readobjnum();
		  
		  if (!sizeinfo)
		    {
		      fprintf( outfd, "DATA %#5x ", n );
		      
		      fprintf( outfd, "STATIC OFFSET = %#5x ", dataoff );
		    }
		  
		  show_string();
		  
		  if (!sizeinfo)
		    fputc( '\n', outfd );
		  
		  dataoff += n;
		  
		  break;
		  
		case OBJCOMMON:
		  n = readobjnum();
		  
		  if (!sizeinfo)
		    {
		      fprintf( outfd, "COMMON %#x ", n );
		      
		      fprintf( outfd, "STATIC OFFSET = %#x (may now be erroneous) ", dataoff );
		    }
		  
		  show_string();
		  
		  if (!sizeinfo)
		    fputc( '\n', outfd );
		  
		  dataoff += n;
		  
		  break;
		  
		case OBJCODETABLE: /* split module table support */
		  if (!sizeinfo)
		    fprintf( outfd, "CODETABLE " );
		  
		  show_string();
		  
		  if (!sizeinfo)
		    fputc( '\n', outfd );
		  
		  codetableoff += 4;	/* uses 4 bytes for address in static data */
		  
		  break;
		  
		case OBJREF:
		  if (!sizeinfo)
		    {
		      fprintf( outfd, "REF " );
		      
		      show_string();
		      
		      fputc( '\n', outfd );
		    }
		  break;	
		  
		default:
		  inform( "Warning - bad object format %#x at offset 0x%08X", ch, (ftell( f ) - 1) );
		  
		  fprintf( outfd, "Bad object format %#x\n (skipping entire word)", ch );
		  
		  (void) getc( f );
		  (void) getc( f );
		  (void) getc( f );
		  
#if 0
		  tidyup( 1 );
#endif
		}
	    }
	  while ((ch = getc( f )) != EOF);
	}
      
      fclose( f );

      if (sizeinfo && !nameinfo)
	{
	  fprintf( outfd, "Image size       = 0x%08X\n", pc );
	  fprintf( outfd, "Static data size = 0x%08X\n", dataoff );	  
	  fprintf( outfd, "Code table size  = 0x%08X\n", codetableoff );
	  
	  pc           = 0;
	  dataoff      = 0;
	  codetableoff = 0;
	  
	  fputc( '\n', outfd );
	}
    }
  
  if (!sizeinfo)
    {
      fprintf( outfd, "\nTotal image size       = %#x\n", pc );
      fprintf( outfd, "Total static data size = %#x\n", dataoff );
      fprintf( outfd, "Total code table size  = %#x\n", codetableoff );
    }

  return( 0 );

} /* main */


#ifdef SUN4
/*
 * The gcc compiler appears to generate references to the following functions
 * without providing them in a standard library.  Since the code for the
 * linker does not use either of them, they are provided here as stubs
 */

int ___assert( void ) { return 0; }
int ___typeof( void ) { return 0; }  

#endif /* SUN4 */
@


1.32
log
@Changed to use ARM Ltd clx disassembler for host versions.
Tidied up the output formatting for ARM version.
@
text
@d15 1
a15 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.31 1994/01/07 14:24:06 nickc Exp $
d715 1
a715 1
char *ARM_regnames[] = {"a1","a2","a3","a4","v1","v2","v3","v4","v5","dp","fp","sl","ip","sp","lr","pc"} ;
@


1.31
log
@added support for new ARM AOF patches
@
text
@d12 1
d15 1
a15 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.30 1994/01/05 14:56:51 nickc Exp nickc $
d26 1
a26 1
#ifdef SUN4
d31 3
d36 1
a39 1

d63 16
d81 1
d248 1
d250 2
a251 1
	      fprintf( outfd, "PC = %#010x ", localpc );
a252 1
	      fprintf( outfd, "     %#010x ", instruction );
d264 1
a264 1
	      fprintf( outfd, "   " );
d286 1
a286 1
	      fprintf( outfd, "PC = %#010x        ", localpc );
d328 1
d330 3
d441 1
a441 1
	      fprintf( outfd, "       :" );
d496 1
a496 1
	      fprintf( outfd, "        :" );
d714 3
d727 3
a729 1

d853 1
a853 1
	      fprintf( outfd, "PC = %#010x ", pc );
d942 1
a942 1
		  fprintf( outfd, "PC = %#010x ", pc );
@


1.30
log
@added return type for inform()
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.29 1993/12/17 15:43:32 nickc Exp nickc $
d471 13
@


1.29
log
@reordered includes
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.28 1993/12/17 15:14:33 nickc Exp nickc $
d69 1
a69 1
static void
@


1.28
log
@improved to detect non-GHOF files and AOF files
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.27 1992/12/16 19:11:43 nickc Exp nickc $
d19 1
a19 1
  
d33 3
a39 2

#include "link.h"	/* for OBJCODE etc */
@


1.27
log
@fixed output speed
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.26 1992/11/10 14:46:39 nickc Exp nickc $
d38 1
a38 27
#define OBJCODE      	0x01
#define OBJSPACE       	0x02		/* aka OBJBSS */
#define OBJINIT       	0x03

#define OBJBYTE       	0x09	   	/* ls 3 bits = size      */
#define OBJSHORT      	0x0a
#define OBJWORD       	0x0c

#define OBJCODESYMB   	0x0d		/* split module table support */
#define OBJMODSIZE  	0x0e
#define OBJLABELREF   	0x0f
#define OBJDATASYMB   	0x10		
#define OBJDATAMODULE 	0x11
#define OBJMODNUM     	0x12

#define OBJPATCHMIN    	0x13   		/* PATCHES are 0x13 - 0x1f */
#define OBJPATCHMAX   	0x1f		

#define OBJMODULE     	0x20
#define OBJBYTESEX	0x21

#define OBJGLOBAL     	0x22
#define OBJLABEL      	0x23
#define OBJDATA       	0x24
#define OBJCOMMON     	0x25
#define OBJCODETABLE  	0x26		/* split module table support */
#define OBJREF        	0x27		/* force reference to another library */
a39 34
#ifdef __C40
#define OBJCODESTUB	0x28		/* addr of fn or stub */
#define OBJADDRSTUB	0x29		/* addr of stub returning addr of function */
#endif

#define OBJNEWSEG	0x30
#define OBJEND		0x31
#define OBJLITERAL	0x32	   	/* OBJCODE of <= 4 bytes */

#define PATCH_ADD  	0x13 		
#define PATCH_SHIFT	0x14 		
#define PATCH_SWAP	0x1E		 
#define PATCH_OR	0x1f		

#ifdef __ARM
#define PATCH_ARM_DT     0x15
#define PATCH_ARM_DP     0x16
#define PATCH_ARM_JP     0x17
#define PATCH_ARM_DPLSB  0x18
#define PATCH_ARM_DPREST 0x19
#define PATCH_ARM_DPMID  0x1a
#endif

#ifdef __C40
#define PATCH_C40_DATAMODULE1	0x15
#define PATCH_C40_DATAMODULE2	0x16
#define PATCH_C40_DATAMODULE3	0x17
#define PATCH_C40_DATAMODULE4	0x18
#define PATCH_C40_DATAMODULE5	0x19
#define PATCH_C40_MASK24ADD	0x1a
#define PATCH_C40_MASK16ADD	0x1b
#define PATCH_C40_MASK8ADD	0x1c
#endif

d385 1
a385 1
  if (OBJPATCHMIN <= ch && ch <= OBJPATCHMAX)
d390 1
a390 1
      if (ch != PATCH_SWAP)
d397 1
a397 1
	    case PATCH_ADD:  
d401 1
a401 1
	    case PATCH_SHIFT:
d406 1
a406 1
	    case PATCH_ARM_DT:
d417 1
a417 1
	    case PATCH_ARM_DP:
d428 1
a428 1
	    case PATCH_ARM_DPLSB:
d439 1
a439 1
	    case PATCH_ARM_DPREST:
d450 1
a450 1
	    case PATCH_ARM_DPMID:
d461 1
a461 1
	    case PATCH_ARM_JP:
d474 1
a474 1
	    case PATCH_C40_DATAMODULE1:
d483 1
a483 1
	    case PATCH_C40_DATAMODULE2:
d492 1
a492 1
	    case PATCH_C40_DATAMODULE3:
d501 1
a501 1
	    case PATCH_C40_DATAMODULE4:
d510 1
a510 1
	    case PATCH_C40_DATAMODULE5:
d519 1
a519 1
	    case PATCH_C40_MASK24ADD:
d529 1
a529 1
	    case PATCH_C40_MASK16ADD:
d539 1
a539 1
	    case PATCH_C40_MASK8ADD:
d551 1
a551 1
	    case PATCH_SWAP:
d555 1
a555 1
	    case PATCH_OR:
d698 2
d779 8
a786 1
      while ((ch = getc( f )) != EOF)
d788 5
a792 1
	  int	n;
d794 6
a799 9
	  
	  if (!sizeinfo)
#ifdef __C40
	    fprintf( outfd, "PC = %#010x ", pc / 4 );
#else
	    fprintf( outfd, "PC = %#010x ", pc );
#endif

	  switch (ch)
d801 1
a801 19
	    case OBJCODE:
	      n = readobjnum();

	      if (n < 0)
		inform( "CODE directive encountered with negative size (%x)", n );
	      else
		show_code( n );

	      pc += n;

	      break;

	    case OBJSPACE:
	      n = readobjnum();

	      if (!sizeinfo)
		fprintf( outfd, "SPACE: %#x\n", n );

	      pc += n;
a802 15
	      break;

	    case OBJINIT:
	      if (!sizeinfo)
		fprintf( outfd, "INIT\n" );
		
	      pc += 4;
		
	      break;

	    case OBJBYTE:
	      show_patch( "BYTE" );
		    
	      if (!sizeinfo)
		fputc( '\n', outfd );
a803 33
	      pc += 1;
		    
	      break;
		
	    case OBJSHORT:
	      show_patch( "SHORT" );
		    
	      if (!sizeinfo)
		fputc( '\n', outfd );
		    
	      pc += 2;
		    
	      break;

	    case OBJWORD:
	      show_patch( "WORD" );
		    
	      if (!sizeinfo)
		fputc( '\n', outfd );
		    
	      pc += 4;

	      break;

	    case OBJMODULE:
	      n = readobjnum();

	      if (!sizeinfo)
		fprintf( outfd, "MODULE %d\n", n );

	      break;

	    case OBJGLOBAL:
a804 11
		fprintf( outfd, "GLOBAL " );

	      show_string();

	      if (!sizeinfo)
		fputc( '\n', outfd );

	      break;

	    case OBJLABEL:
	      if (nameinfo)
d808 2
a809 14
		fprintf( outfd, "PC = %#010x ", pc );
#endif		    
	      if (!sizeinfo || nameinfo)
		fprintf( outfd, "LABEL " );
		    
	      show_label_string();
		    
	      if (!sizeinfo || nameinfo)
		fputc( '\n', outfd );
		    
	      break;

	    case OBJDATA:
	      n = readobjnum();
d811 1
a811 1
	      if (!sizeinfo)
d813 45
a857 1
		  fprintf( outfd, "DATA %#5x ", n );
d859 87
a945 18
		  fprintf( outfd, "STATIC OFFSET = %#5x ", dataoff );
		}
	      
	      show_string();
		    
	      if (!sizeinfo)
		fputc( '\n', outfd );
	      
	      dataoff += n;
	      
	      break;

	    case OBJCOMMON:
	      n = readobjnum();

	      if (!sizeinfo)
		{
		  fprintf( outfd, "COMMON %#x ", n );
d947 3
a949 29
		  fprintf( outfd, "STATIC OFFSET = %#x (may now be erroneous) ", dataoff );
		}
		    
	      show_string();
		    
	      if (!sizeinfo)
		fputc( '\n', outfd );
		    
	      dataoff += n;
	      
	      break;

	    case OBJCODETABLE: /* split module table support */
	      if (!sizeinfo)
		fprintf( outfd, "CODETABLE " );
		    
	      show_string();
		    
	      if (!sizeinfo)
		fputc( '\n', outfd );
		    
	      codetableoff += 4;	/* uses 4 bytes for address in static data */
		    
	      break;

	    case OBJREF:
	      if (!sizeinfo)
		{
		  fprintf( outfd, "REF " );
d953 27
a979 13
		  fputc( '\n', outfd );
		}
	      break;	

	    default:
	      inform( "Warning - bad object format %#x at offset 0x%08X", ch, (ftell( f ) - 1) );
		
	      fprintf( outfd, "Bad object format %#x\n (skipping entire word)", ch );

	      (void) getc( f );
	      (void) getc( f );
	      (void) getc( f );

d981 1
a981 1
	      tidyup( 1 );
d983 1
d985 1
d987 1
a987 1

@


1.26
log
@added break after parsing -p option
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.25 1992/10/01 10:23:43 nickc Exp nickc $
d138 1
d142 1
d151 1
d153 1
@


1.25
log
@fixed compile time warnings
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.24 1992/09/14 08:34:57 nickc Exp nickc $
d799 1
@


1.24
log
@fixed for compilation on Sparc
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.23 1992/09/14 08:31:53 nickc Exp nickc $
d65 2
d68 2
d443 1
a443 1
      int n;
d445 1
d667 2
a668 1
	  
d677 9
@


1.23
log
@fixed for compilation on Sparc
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.22 1992/09/04 14:35:10 paul Exp nickc $
d1030 13
@


1.22
log
@added -p option to display PCS register aliases
@
text
@d14 1
a14 1
 *  $Header: /m/giga/HeliosRoot/Helios/cmds/linker/RCS/objdump.c,v 1.21 1992/09/03 16:15:27 nickc Exp paul $
d24 4
@


1.21
log
@added error message if a negative sized CODE directive is encountered.
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.20 1992/08/17 16:18:03 paul Exp nickc $
d108 1
d686 1
a686 1
  inform( "Usage: [-h] [-l] [-d] [-i] [-n] [+pcinc] [-o output-file] input-files" );
d696 1
d698 1
a698 1
  
d778 2
@


1.20
log
@fixed typo in ARM's patch numbers
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.19 1992/07/15 15:58:30 nickc Exp $
d825 5
a829 2
		  
	      show_code( n );
@


1.19
log
@oops, fixed bug in previous delta
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.18 1992/07/15 15:55:08 nickc Exp nickc $
d76 1
a76 1
#define PATCH_ARM_DPLSB  0x81
@


1.18
log
@fixed output to go to output file
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.17 1992/07/15 15:46:58 nickc Exp nickc $
d779 1
a779 1
		    s = argv[ i++ ];		  
@


1.17
log
@added -o option
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.16 1992/07/13 09:01:12 nickc Exp nickc $
d201 1
a201 1
	putchar( ch );
d218 1
a218 1
	putchar( ch );
d221 1
a221 1
  putchar(':'); 
d285 1
a285 1
		  putchar( ((dc < ' ') || (dc > 0x7E)) ? '.' : dc );
d292 1
a292 1
	      putchar( '\n' );
d336 1
a336 1
	      putchar( ' ' );
d339 1
a339 1
		putchar( ' ' );
d348 2
a349 2

		  putchar( ((dc < ' ') | (dc > 0x7E)) ? '.' : dc );
d383 1
a383 1
	putchar( '\n' );
d407 1
a407 1
  putchar( '\n' );
d854 1
a854 1
		putchar( '\n' );
d864 1
a864 1
		putchar( '\n' );
d874 1
a874 1
		putchar( '\n' );
d895 1
a895 1
		putchar( '\n' );
d912 1
a912 1
		putchar( '\n' );
d929 1
a929 1
		putchar( '\n' );
d948 1
a948 1
		putchar( '\n' );
d961 1
a961 1
		putchar( '\n' );
d974 1
a974 1
		  putchar( '\n' );
d1005 1
a1005 1
	  putchar( '\n' );
@


1.16
log
@fixed to support new patch CODESTUB
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.15 1992/06/15 12:02:29 paul Exp nickc $
d97 1
d250 1
a250 1
	printf( "CODE %#x\n", n );
d272 1
a272 1
	      printf( "PC = %#010x ", localpc / 4 );
d274 1
a274 1
	      printf( "PC = %#010x ", localpc );
d276 1
a276 1
	      printf( "     %#010x ", instruction );
d288 1
a288 1
	      printf( "   " );
d308 1
a308 1
	      printf( "PC = %#010x        ", localpc / 4 );
d310 1
a310 1
	      printf( "PC = %#010x        ", localpc );
d314 1
a314 1
		printf( "  " );
d333 1
a333 1
		  printf( "%02x",(instruction & (0xFF << (j * 8))) >> (j * 8));
d352 1
a352 1
	      printf( " :\n" );
d359 1
a359 1
	printf( "CODE %#x :", n );
d372 1
a372 1
		    printf( "\n\t" );
d377 1
a377 1
	    printf( " %02X", getc( f ) );
d389 1
a389 1
  printf( "CODE %#x :", n );
d398 1
a398 1
	    printf( "\n\t" );
d402 1
a402 1
	printf( " %02X", getc( f ) );
d430 1
a430 1
    printf( "%s ", s );
d444 1
a444 1
	      printf( "PATCH ADD: %#x ", n );
d448 1
a448 1
	      printf( "PATCH SHIFT by: %d ", n );
d453 1
a453 1
	      printf( "PATCH ARM DT    : ");
d458 1
a458 1
		printf( "0x%08X", n );
d460 1
a460 1
	      printf( "       :" );
d464 1
a464 1
	      printf( "PATCH ARM DP    : " );
d469 1
a469 1
		printf( "0x%08X", n );
d471 1
a471 1
	      printf( " :" );
d475 1
a475 1
	      printf( "PATCH ARM DPLSB : " );
d480 1
a480 1
		printf( "0x%08X", n );
d482 1
a482 1
	      printf( " :" );
d486 1
a486 1
	      printf( "PATCH ARM DPREST: " );
d491 1
a491 1
		printf( "0x%08X", n );
d493 1
a493 1
	      printf( " :" );
d497 1
a497 1
	      printf( "PATCH ARM DPMID : " );
d502 1
a502 1
		printf( "0x%08X", n );
d504 1
a504 1
	      printf( " :" );
d508 1
a508 1
	      printf( "PATCH ARM JP    : " );
d513 1
a513 1
		printf( "0x%08X", n );
d515 1
a515 1
	      printf( "        :" );
d521 1
a521 1
	      printf( "M/C PATCH C40 DATAMODULE1: " );
d526 1
a526 1
		printf( "%#010x ", n );
d530 1
a530 1
	      printf( "M/C PATCH C40 DATAMODULE2: " );
d535 1
a535 1
		printf( "%#010x ", n );
d539 1
a539 1
	      printf( "M/C PATCH C40 DATAMODULE3: " );
d544 1
a544 1
		printf( "%#010x ", n );
d548 1
a548 1
	      printf( "M/C PATCH C40 DATAMODULE4: " );
d553 1
a553 1
		printf( "%#010x ", n );
d557 1
a557 1
	      printf( "M/C PATCH C40 DATAMODULE5: " );
d562 1
a562 1
		printf( "%#010x ", n );
d566 1
a566 1
	      printf( "M/C PATCH C40 MASK 24 ADD: " );
d571 1
a571 1
		printf( "%#010x ", n );
d576 1
a576 1
	      printf( "M/C PATCH C40 MASK 16 ADD: " );
d581 1
a581 1
		printf( "%#010x ", n );
d586 1
a586 1
	      printf( "M/C PATCH C40 MASK 8 ADD: " );
d591 1
a591 1
		printf( "%#010x ", n );
d598 1
a598 1
	      printf( "PATCH SWAP: " );
d602 1
a602 1
	      printf( "PATCH OR: %#x ", n );
d608 1
a608 1
	      printf( "Unknown M/C Patch %#x\n", ch );
d620 1
a620 1
	    printf( "DATASYMB " );
d627 1
a627 1
	    printf( "CODESYMB " );
d634 1
a634 1
	    printf( "DATAMODULE " );
d641 1
a641 1
	    printf( "MODSIZE" );
d647 1
a647 1
	    printf( "MODNUM" );
d653 1
a653 1
	    printf( "LABELREF " );
d660 1
a660 1
	    printf( "CODESTUB " );
d669 1
a669 1
	  printf( "Bad patch object format: %#x\n", ch );
d685 1
a685 1
  inform( "Usage: [-h] [-l] [-d] [-i] [-n] [+pcinc] input-files" );
d687 1
a687 1
  inform( "Usage: [-h] [-l] [-i] [-n] [+pcinc] input-files" );
d690 2
a691 2
  inform( "-h :    Provide this help information" );
  inform( "-l :    Give full information (long)"  );
d694 1
a694 1
  inform( "-d :    Provide disassembly" );
d697 6
a702 5
  inform( "-i :    Provide image size and static allocation info only" );
  inform( "-n :    Provide symbol definition information only" );
  inform( "+pcinc: Allows you to add an address offset. This can" );
  inform( "        be used between the input files." );

d748 1
a748 1
	  printf( "OBJECTFILE: %s\n", argv[ i ] );
a776 1
#if 0 /* use initial +n */
d778 8
a785 4
		  if (*s != '\0')
		    pc = atoi( s );
		  else
		    pc = atoi( argv[ ++i ] );
d787 3
d791 1
a791 1
#endif
d816 1
a816 1
	    printf( "PC = %#010x ", pc / 4 );
d818 1
a818 1
	    printf( "PC = %#010x ", pc );
d836 1
a836 1
		printf( "SPACE: %#x\n", n );
d844 1
a844 1
		printf( "INIT\n" );
d884 1
a884 1
		printf( "MODULE %d\n", n );
d890 1
a890 1
		printf( "GLOBAL " );
d902 1
a902 1
		printf( "PC = %#010x ", pc / 4 );
d904 1
a904 1
		printf( "PC = %#010x ", pc );
d907 1
a907 1
		printf( "LABEL " );
d921 1
a921 1
		  printf( "DATA %#5x ", n );
d923 1
a923 1
		  printf( "STATIC OFFSET = %#5x ", dataoff );
d940 1
a940 1
		  printf( "COMMON %#x ", n );
d942 1
a942 1
		  printf( "STATIC OFFSET = %#x (may now be erroneous) ", dataoff );
d956 1
a956 1
		printf( "CODETABLE " );
d970 1
a970 1
		  printf( "REF " );
d981 1
a981 1
	      printf( "Bad object format %#x\n (skipping entire word)", ch );
d997 3
a999 3
	  printf( "Image size       = 0x%08X\n", pc );
	  printf( "Static data size = 0x%08X\n", dataoff );	  
	  printf( "Code table size  = 0x%08X\n", codetableoff );
d1011 3
a1013 3
      printf( "\nTotal image size       = %#x\n", pc );
      printf( "Total static data size = %#x\n", dataoff );
      printf( "Total code table size  = %#x\n", codetableoff );
@


1.15
log
@fixed to use std __proc names
@
text
@d14 1
a14 1
 *  $Header: /m/giga/HeliosRoot/Helios/cmds/linker/RCS/objdump.c,v 1.14 1992/05/13 10:50:32 nickc Exp paul $
d61 1
d657 8
@


1.14
log
@improved format of output slightly
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.13 1992/04/21 14:18:59 nickc Exp nickc $
d25 1
a25 1
#ifdef __HELIOSARM
d71 1
a71 1
#ifdef __HELIOSARM
d80 1
a80 1
#ifdef __HELIOSC40
d104 1
a104 1
#if defined __HELIOSARM || defined __HELIOSC40
d231 1
a231 1
#if defined __HELIOSARM || defined __HELIOSC40
d269 1
a269 1
#ifdef __HELIOSC40
d305 1
a305 1
#ifdef __HELIOSC40
d383 1
a383 1
#else /* neither __HELIOSARM nor __HELIOSC40 */
d407 1
a407 1
#endif /* __HELIOSARM || __HELIOSC40 */
d449 1
a449 1
#ifdef __HELIOSARM
d515 1
a515 1
#endif /* __HELIOSARM */
d517 1
a517 1
#ifdef __HELIOSC40
d593 1
a593 1
#endif /* __HELIOSC40 */
d674 1
a674 1
#if defined __HELIOSARM || defined __HELIOSC40
d683 1
a683 1
#if defined __HELIOSARM || defined __HELIOSC40
d761 1
a761 1
#if defined __HELIOSARM || defined __HELIOSC40
d798 1
a798 1
#ifdef __HELIOSC40
d884 1
a884 1
#ifdef __HELIOSC40
@


1.13
log
@minor cosmetic changes
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.12 1992/04/16 15:57:07 nickc Exp nickc $
d904 1
a904 1
		  printf( "DATA %#x ", n );
d906 1
a906 1
		  printf( "STATIC OFFSET = %#x ", dataoff );
@


1.12
log
@fixed bug in call to fopen(), (not opening in binary mode)
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.11 1992/02/05 11:55:49 paul Exp nickc $
d965 5
a969 2
		
	      getc( f ); getc( f ); getc( f );
@


1.11
log
@added mask8add c40 patch
@
text
@d14 1
a14 1
 *  $Header: /giga/HeliosRoot/Helios/cmds/linker/RCS/objdump.c,v 1.10 1991/11/06 15:03:36 paul Exp $
d420 7
d730 1
a730 1
	  if ((f = fopen( argv[ i ], "r" )) == 0)
@


1.10
log
@changed name of IMAGESIZE directive to MODSIZE (as thats what it is!)
@
text
@d14 1
a14 1
 *  $Header: /hsrc/cmds/linker/RCS/objdump.c,v 1.9 1991/10/29 13:21:26 nickc Exp paul $
d88 1
d574 10
@


1.9
log
@fixed calculation of pc
@
text
@d14 1
a14 1
 *  $Header: /users/nickc/ncc/cc350/ccc40/src/RCS/objdump.c,v 1.5 1991/10/29 13:18:21 nickc Exp $
d43 1
a43 1
#define OBJIMAGESIZE  	0x0e
d619 1
a619 1
	case OBJIMAGESIZE:
d621 1
a621 1
	    printf( "IMAGESIZE" );
@


1.8
log
@tidies
@
text
@d8 4
a11 4
 *   Paul Beskeen 	March '89...
 *   Tony Cruickshank 	June '89
 *   James G Smith 	May 1990	Added ARM disassembler (and other tweaks)
 *   Nick Clifton	August 1991	Added C40 tweaks
d14 1
a14 1
 *  $Header: /giga/HeliosRoot/Helios/cmds/linker/RCS/objdump.c,v 1.7 1991/10/21 15:35:06 nickc Exp paul $
d16 1
a16 1
 * @@@@@@ Note that this command will only work for little endian processors
d19 1
a216 1
  putchar(':');
d218 2
a231 3
#ifdef __HELIOSC40
  int          	localpc = pc / 4;
#else
a232 1
#endif
d263 1
a263 1
	    instruction |= getc( f ) << (j * 8);
d268 3
d272 1
a279 3
# if 0 /* naff way to do it! */
		  char	dc = ((instruction & (0xFF << (j * 8))) >> (j * 8));
# else
a280 1
# endif
d285 1
a285 1
	      printf( " : " );
a291 3
#ifdef __HELIOSC40
	  localpc += 1;		/* naff word address machine - pc equivalent to a word pointer */
#else
a292 1
#endif
d304 3
d308 1
d333 1
a333 1
	      putchar(' ');
d336 1
a336 1
		putchar(' ');
d654 1
a654 1
usage()
@


1.7
log
@applied fixes profduced by NC
@
text
@d8 1
a8 1
 *   Paul Beskeen 	March '89
d14 1
a14 1
 *  $Header: /users/nickc/ncc/cc350/ccc40/src/RCS/objdump.c,v 1.4 1991/10/21 15:33:27 nickc Exp $
a18 1
  
d216 1
d230 3
d234 1
d260 1
a260 1
#ifdef _BIGENDIAN
d265 1
a265 1
	    instruction = instruction | (getc( f ) << (j * 8));
d270 2
a271 2
	      printf( "PC = 0x%08X ", localpc );
	      printf( "     0x%08X ", instruction );
d278 1
d280 3
d310 1
a310 1
	      printf( "PC = 0x%08X        ", localpc );
d332 1
a332 1
		  printf( "%02X",(instruction & (0xFF << (j * 8))) >> (j * 8));
d335 2
d338 1
a338 1
		printf( "  " );
a347 1

d518 1
a518 1
		printf( "%#08x ", n );
d527 1
a527 1
		printf( "%#08x ", n );
d536 1
a536 1
		printf( "%#08x ", n );
d545 1
a545 1
		printf( "%#08x ", n );
d554 1
a554 1
		printf( "%#08x ", n );
d563 1
a563 1
		printf( "%#08x ", n );
d573 1
a573 1
		printf( "%#08x ", n );
d783 1
a783 1
	    printf( "PC = %#08x ", pc / 4 );
d785 1
a785 1
	    printf( "PC = %#08x ", pc );
d869 1
a869 1
		printf( "PC = %#08x ", pc / 4 );
d871 1
a871 1
		printf( "PC = %#08x ", pc );
@


1.6
log
@fixed for c40 word addressing, and bigendian targets + cleaned up a little
@
text
@d14 1
a14 1
 *  $Header: /giga/HeliosRoot/Helios/cmds/linker/RCS/objdump.c,v 1.5 1991/10/09 11:12:56 paul Exp paul $
d35 1
a35 1
#define OBJSPACE       	0x02
d230 1
d232 1
a232 6
#ifdef __HELIOSC40
	/* word address machine so PC is a word pointer equivalent */
  int          	localpc = pc / 4;
#else
  int          	localpc = pc;
#endif
d253 1
d256 1
a256 1
#ifdef __BIGENDIAN
d261 1
a261 1
	    instruction |= (getc( f ) & 0xff) << (j * 8);
d266 3
a268 3
	      printf( "PC = %#08x ", localpc);
	      printf( "       %08x ", instruction );

d274 2
a275 2
		  char	dc = (instruction >> (j * 8)) & 0xFF;
#endif
d280 1
a280 1

d282 1
a282 1

d285 1
a285 1

d287 1
a287 2
	      /* naff word address machine - pc equivalent to a word pointer */
	  localpc += 1;
d289 1
a289 2
		/* nice byte addressed machine */
	  localpc += 4;
d302 2
a303 2
	      printf( "PC = %#08x        ", localpc );

d309 1
a309 1

a313 1
	  /* read in in little endian format */	  
d337 2
d778 1
d787 1
@


1.5
log
@fixed bad #if and made it work for the ARM again
@
text
@d14 3
a16 1
 *  $Header: /giga/HeliosRoot/Helios/cmds/linker/RCS/objdump.c,v 1.4 1991/10/08 17:29:57 paul Exp paul $
d35 1
a35 1
#define OBJBSS        	0x02
d230 5
d236 1
a236 2
  int		doprint = 1;

d241 1
a241 1
       * Provide disassembled code sections in the ARM version.
d249 1
a249 1
	printf( "CODE %d\n", n );
d253 1
a253 1
      while ((n - i) >= 4)		/* enough for an ARM instruction */
a256 1
	  
d259 1
a259 1
#ifdef __HELIOSARM
d261 1
a261 1
	    instruction = instruction | (getc( f ) << (j * 8));
d264 1
a264 1
	    instruction = (instruction << 8) | (getc( f ) & 0xFF);
d269 3
a271 3
	      printf( "PC = 0x%04X ", localpc );
	      printf( "       %08X ", instruction );
	      
d274 2
a275 2
#ifdef __HELIOSARM
		  char	dc = ((instruction & (0xFF << (j * 8))) >> (j * 8));
d277 1
a277 1
		  char	dc = (instruction >> ((3 - j) * 8)) & 0xFF;
a278 2

		  
d283 1
a283 1
	      
d285 1
a285 1
	      
d288 6
a293 1
	  
d295 1
d307 2
a308 2
	      printf( "PC = 0x%04X        ", localpc );
	      
d314 6
a319 1
	  
d321 2
a322 1
	    instruction = instruction | (getc( f ) << (j * 8));
d338 5
a342 3
		  char	dc = ((instruction & (0xFF << (j * 8))) >> (j * 8));


d353 1
a353 1
	printf( "CODE %d :", n );
d383 1
a383 1
  printf( "CODE %d :", n );
d777 5
a781 2
	    printf( "PC = 0x%04X ", pc );

a789 1

d792 1
a792 1
	    case OBJBSS:
d796 1
a796 1
		printf( "BSS: %#x\n", n );
d861 5
a865 2
		printf( "PC = 0x%08X ", pc );
		    
@


1.4
log
@fixed bad #ifdef __HELIOSARM
@
text
@d14 1
a14 1
 *  $Header: /giga/HeliosRoot/Helios/cmds/linker/RCS/objdump.c,v 1.3 1991/10/08 17:08:33 paul Exp paul $
d21 1
d70 1
a70 1
#define PATHC_ARM_DT     0x15
d645 1
a645 1
#if defined __HELIOSARM || __defined __HELIOSC40
@


1.3
log
@nickc's new code for the c40
@
text
@d14 1
a14 1
 *  $Header: /users/nickc/ncc/cc350/ccc40/src/RCS/objdump.c,v 1.3 1991/10/08 13:40:51 nickc Exp $
d253 1
a253 1
#ifdef _HELIOSARM
@


1.2
log
@Added objref
@
text
@d4 1
a4 1
 * OBJDUMP.C
d6 9
a14 4
 * Criss Selwyn December '88
 * Paul Beskeen March '89
 * Tony Cruickshank June '89
 * James G Smith (May 1990)	Added ARM disassembler (and other tweaks)
d17 1
a17 2
static char *RcsId = "$Id: objdump.c,v 1.1 90/10/22 15:46:58 paul Exp $ Copyright (C) Perihelion Software Ltd.";

a18 1
#ifdef __STDC__
d20 1
a20 4
#else
/*#define void char*/
#define SEEK_SET 0
#endif
d26 50
a75 31
#define OBJCODE		0x01
#define OBJBSS		0x02
#define OBJINIT		0x03
#define OBJBYTE		0x09
#define OBJSHORT	0x0a
#define OBJWORD		0x0c
#define OBJCODESYMB	0x0d	/* split module table support */
#define OBJLABELREF	0x0f
#define OBJMODULE	0x20
#define OBJGLOBAL	0x22
#define OBJLABEL	0x23
#define OBJDATA		0x24
#define OBJCOMMON	0x25
#define OBJCODETABLE	0x26	/* split module table support */
#define OBJREF		0x27	/* ref directive for ARM */
#define OBJDATASYMB	0x10
#define OBJDATAMODULE	0x11
#define OBJIMAGESIZE	0x0e
#define OBJMODNUM	0x12
#define PATCHMIN	0x13
#define PATCHMAX	0x1f

#define PATCH_M68KADD	0x013
#define PATCH_M68KSHFT	0x014

#define	PATCH_ARM_DT	0x015  /* Data transfer instruction patch (bits 0-11) */
#define	PATCH_ARM_DP	0x016  /* Data processing instruction patch (bits 0-8) */
#define	PATCH_ARM_JP	0x017  /* Branch instruction patch (bits 0-23 rshift 2) */
#define	PATCH_ARM_DPLSB  0x018  /* Data processing instruction patch lsbyte */
#define	PATCH_ARM_DPREST 0x019  /* Data processing instruction patch residue from above */
#define	PATCH_ARM_DPMID	0x01A  /* Data processing instruction patch lsb+1 byte */
d77 9
a85 2
#define PATCH_PGC1	0x01f
#define PATCH_SWAP	0x01e
d90 12
a101 8
FILE *f = NULL;
int pc = 0;
int dataoff = 0;
int codetableoff = 0; /* split mod tab support */
int ch;
int ShortOutput = 1 ;
int sizeinfo = 0 ;	/* provide image and static data area information */
int nameinfo = 0 ;	/* provide symbol definition information */
d103 1
a103 2
#ifdef __HELIOSARM
int dodisass = 0 ;	/* No disassembly by default */
d107 24
a130 1
/*---------------------------------------------------------------------------*/
d132 13
a144 2
void tidyup(n)
int n;
d146 4
a149 4
 if(f)
  fclose(f) ;
 exit(n);
}
d151 5
a155 1
int readobjnum()
d157 25
a181 18
   int ch = getc(f);
   int nflag  = (ch & NFLAG) != 0;
   int r = ch & 0x3f;

   if (ch == EOF) {
   	fprintf(stderr,"objdump: Error - Unexpected EOF\n");
   	tidyup(1);
   }
   while( (ch & MORE) != 0 )
   {
      if ((ch = getc(f)) == EOF) {
         fprintf(stderr,"objdump: Error - Unexpected EOF\n");
   	 tidyup(1);
      }
      r  = (r<<7) + (ch&0x7f);
   }
   return nflag? -r: r;
}
d183 5
a187 1
void show_string()
d189 12
a200 7
 char ch ;
 while ((ch = getc(f)) != 0)
  {
   if (!sizeinfo)
    putchar(ch) ;
  }
}
d202 3
a204 1
void show_label_string()
d206 8
a213 7
 char ch ;
 while ((ch = getc(f)) != 0)
  {
   if (!sizeinfo || nameinfo)
    putchar(ch) ;
  }
}
d215 7
a221 2
void show_code(n)
int n;
d224 44
a267 1
   int i;
d269 21
a289 12
   unsigned int instruction ;
   int          localpc = pc ;
   int		doprint = 1 ;

   if (dodisass)
    {
     /* Provide disassembled code sections in the ARM version.
      * Note: This cannot synchronise on the instructions if the CODE is
      *	    actually non-word-aligned data.
      *
      * We are called with the text "PC = 0xZZZZ " already displayed.
      */
d291 47
a337 43
     if (!sizeinfo)
      printf("CODE %d\n",n) ;
     
     i = 0 ;
     while ((n - i) >= 4)		/* enough for an ARM instruction */
      {
       int j ;
       instruction = 0x00000000 ;
       for (j = 0; (j < 4); j++)
        instruction = instruction | (getc(f) << (j * 8)) ;

       if (!sizeinfo) 
        {
         printf("PC = 0x%04X ",localpc) ;
         printf("       %08X ",instruction) ;
         for (j = 0; (j < 4); j++)
          {
           char dc = ((instruction & (0xFF << (j * 8))) >> (j * 8)) ;
           putchar(((dc < ' ') || (dc > 0x7E)) ? '.' : dc) ;
          }
         printf(" : ") ;
         disassemble(instruction,localpc,FALSE) ;
         putchar('\n') ;
        }
       localpc += 4 ;
       i += 4 ;
      }

     /* deal with any non-word aligned data at the end */
     if (i < n)
      {
       int j ;

       if (!sizeinfo)
        {
         printf("PC = 0x%04X        ",localpc) ;
         for (j = 0; (j < (4 - (n - i))); j++)
          printf("  ") ;
        }

       instruction = 0x00000000 ;
       for (j = 0; (j < (n - i)); j++)
        instruction = instruction | (getc(f) << (j * 8)) ;
d339 1
a339 1
       if (!sizeinfo)
d341 19
a359 46
         for (j = (n - i); (j > 0);)
          {
           j-- ;
           printf("%02X",(instruction & (0xFF << (j * 8))) >> (j * 8)) ;
          }

         for (j = 0; (j < (4 - (n - i))); j++)
          printf("  ") ;

         for (j = 0; (j < (n - i)); j++)
          {
           char dc = ((instruction & (0xFF << (j * 8))) >> (j * 8)) ;
           putchar(((dc < ' ') | (dc > 0x7E)) ? '.' : dc) ;
          }

         printf(" :\n") ;
        }
      }
    }
   else
    {
     if (!sizeinfo)
      printf("CODE %d :",n) ;
     else
      doprint = 0 ;

     for(i = 1; (i <= n); i++)
      {
       if ((i % CODEMAX) == 0)
        {
	 if (!sizeinfo)
	  {
	   if (ShortOutput)
	    doprint = 0 ;
 	   else
	    printf("\n\t") ;
	  }
        }

       if (doprint)
	printf(" %02X",getc(f)) ;
       else
	fseek(f,1,1) ;
      }
     if (!sizeinfo)
      putchar('\n') ;
d361 5
a365 2
#else
   int doprint = 1;
d367 9
a375 1
   printf("CODE %d :",n);
d377 2
a378 9
   for( i = 1; i <= n; i++) {
      if (i % CODEMAX == 0) {
	if (ShortOutput)
	  doprint = 0;
	else
	  printf ("\n\t");
      }
      if (doprint)
	printf(" %02X",getc(f));
d380 11
a390 5
	fseek (f,1,1);
   }
   putchar('\n');
#endif
}
d392 2
a393 2
void show_patch(s)
char *s;
d395 2
a396 1
   int ch = getc(f);
d398 2
a399 2
   if (!sizeinfo)
    printf("%s ",s);
d401 2
a402 2
   if( PATCHMIN <= ch && ch <= PATCHMAX )
   {
d405 2
a406 2
      if(ch != PATCH_SWAP)
 	 n = readobjnum();
d409 9
a417 8
       {
        switch (ch)
        {
        case PATCH_M68KADD:  
	      printf("M/C PATCH M68K ADD: %#x ",n);
	      break;
      case PATCH_M68KSHFT:
	      printf("M/C PATCH SHIFT by: %d ",n);
d421 3
a423 2
      case PATCH_ARM_DT:
	      printf("PATCH ARM DT    : ") ;
d425 1
a425 1
               disassemble(n,pc,FALSE) ;
d427 8
a434 5
               printf("0x%08X",n) ;
	      printf("       :") ;
	      break;
      case PATCH_ARM_DP:
	      printf("PATCH ARM DP    : ") ;
d436 1
a436 1
               disassemble(n,pc,FALSE) ;
d438 8
a445 5
               printf("0x%08X",n) ;
	      printf(" :") ;
	      break;
      case PATCH_ARM_DPLSB:
	      printf("PATCH ARM DPLSB : ") ;
d447 1
a447 1
               disassemble(n,pc,FALSE) ;
d449 8
a456 5
               printf("0x%08X",n) ;
	      printf(" :") ;
	      break;
      case PATCH_ARM_DPREST:
	      printf("PATCH ARM DPREST: ") ;
d458 1
a458 1
               disassemble(n,pc,FALSE) ;
d460 8
a467 5
               printf("0x%08X",n) ;
	      printf(" :") ;
	      break;
      case PATCH_ARM_DPMID:
	      printf("PATCH ARM DPMID : ") ;
d469 1
a469 1
               disassemble(n,pc,FALSE) ;
d471 3
a473 2
               printf("0x%08X",n) ;
	      printf(" :") ;
d475 4
a478 2
      case PATCH_ARM_JP:
	      printf("PATCH ARM JP    : ") ;
d480 1
a480 1
               disassemble(n,-8,FALSE) ;
d482 14
a495 2
               printf("0x%08X",n) ;
	      printf("        :") ;
d497 8
a504 3
#else
      case PATCH_ARM_DT:
	      printf("M/C PATCH ARM DT: %#x ",n);
d506 8
a513 2
      case PATCH_ARM_DP:
	      printf("M/C PATCH ARM DP: %#x ",n);
d515 8
a522 2
      case PATCH_ARM_DPLSB:
	      printf("M/C PATCH ARM DP LSBYTE: %#x ",n);
d524 8
a531 2
      case PATCH_ARM_DPREST:
	      printf("M/C PATCH ARM DP RESIDUE: %#x ",n);
d533 9
a541 2
      case PATCH_ARM_DPMID:
	      printf("M/C PATCH ARM DP MID: %#x ",n);
d543 27
a569 4
      case PATCH_ARM_JP:
	      printf("M/C PATCH ARM JP: %#x ",n);
	      break;
#endif
d571 4
a574 15
      case PATCH_PGC1:
	      printf("M/C PATCH PGC1 OR: %#x ",n);
	      break;
      case PATCH_SWAP:
	      printf("M/C PATCH SWAP: ");
	      break;
      default:
	      fprintf(stderr,"objdump: Warning, unknown M/C Patch %#x : %#x\n",ch,n);
	      printf("Unknown M/C Patch %#x\n",ch);
      }
     } /* if (!sizeinfo) */
    show_patch("");
   }
   else
   {
d576 32
a607 5
      {
      case OBJDATASYMB:
	 if (!sizeinfo)
          printf("DATASYMB ");
         show_string();
d609 12
a620 26
      case OBJCODESYMB:
	 if (!sizeinfo)
          printf("CODESYMB ");
         show_string();
         break;
      case OBJDATAMODULE:
	 if (!sizeinfo)
          printf("DATAMODULE ");
         show_string();
         break;
      case OBJIMAGESIZE:
	 if (!sizeinfo)
          printf("IMAGESIZE");
         break;
      case OBJMODNUM:
	 if (!sizeinfo)
          printf("MODNUM");
         break;
      case OBJLABELREF:
	 if (!sizeinfo)
          printf("LABELREF ");
         show_string();
         break;
      default:
	 fprintf(stderr,"objdump: Warning, bad patch object format: %#x at offset 0x%08X\n",ch,(ftell(f) - 1)) ;
	 printf("Bad patch object format: %#x\n",ch) ;
d622 1
a622 1
         tidyup(1);
d624 6
a629 3
      }
   }
}
d631 3
a633 1
void usage(char *name)
d635 2
a636 2
#ifdef __HELIOSARM
 fprintf(stderr,"Usage: %s [-h] [-l] [-d] [-i] [-n] [+pcinc] input-files\n",name) ;
d638 1
a638 1
 fprintf(stderr,"Usage: %s [-h] [-l] [-i] [-n] [+pcinc] input-files\n",name) ;
d640 6
a645 4
 fprintf(stderr,"-h :    Provide this help information\n") ;
 fprintf(stderr,"-l :    Give full information (long)\n") ;
#ifdef __HELIOSARM
 fprintf(stderr,"-d :    Provide disassembly\n") ;
d647 17
a663 10
 fprintf(stderr,"-i :    Provide image size and static allocation info only\n") ;
 fprintf(stderr,"-n :    Provide symbol definition information only\n") ;
 fprintf(stderr,"+pcinc: Allows you to add an address offset. This can\n") ;
 fprintf(stderr,"        be used between the input files.\n") ;
 tidyup(1) ;
}

int main(argc, argv)
int argc;
char **argv;
d665 17
a681 38
 char *s ;
 int i ;
 int file = 0 ;

 if (argc < 2)
  usage(argv[0]) ;

   for (i = 1; i < argc; ++i)
   {
     s = argv[i];
     if (*s != '-' && *s != '+')
     {
       file++;
       if( (f = fopen(argv[i],"r")) == 0)
       {
	  fprintf(stderr,"objdump: Unable to open input file: %s\n", argv[i]);
	  tidyup(1);
       }
       printf("OBJECTFILE: %s\n",argv[i]);
     }
     else
     {
       if (*s++ == '-')
       {
        switch (*s++)
          {
           case 'l' : ShortOutput = 0 ;
                      break ;

	   case 'h' : usage(argv[0]) ;
	   	      break ;		/* should never get here */

	   case 'i' : sizeinfo = -1 ;
	              break ;

	   case 'n' : sizeinfo = -1 ;	/* stop full object dump */
	   	      nameinfo = -1 ;	/* but provide name information */
		      break ;
d683 14
a696 2
	   case 'd' : dodisass = -1 ;
	   	      break ;
d698 29
d728 162
a889 21
           case 'o':
             if (*s != '\0')
             	pc = atoi(s);
             else
             	pc = atoi(argv[++i]);
             break;
#endif
           default:
  	     fprintf (stderr, "objdump: Unknown switch %c\n", *s);
             break;
         }
       }
       else /* must be + */
       {       
         if (*s != '\0')
	   pc += atoi(s);
         else
           pc += atoi(argv[++i]);
       }
       continue;
     }
d891 12
a902 4
     while( (ch = getc(f)) != EOF )
     {
      if (!sizeinfo)
       printf("PC = 0x%04X ",pc) ;
d904 8
a911 123
      switch( ch )
        {
        case OBJCODE:
           {  int n = readobjnum();
              show_code(n);
              pc += n;
              break;
           }

        case OBJBSS:
           {  int n = readobjnum();
	      if (!sizeinfo)
               printf("BSS: %#x\n",n);
              pc += n;
              break;
           }

        case OBJINIT:
	      if (!sizeinfo)
               printf("INIT\n");
              pc += 4;
              break;

        case OBJBYTE:
           {
            show_patch("BYTE");
	    if (!sizeinfo)
             putchar('\n');
            pc += 1;
            break;
           }

        case OBJSHORT:
           {
            show_patch("SHORT");
	    if (!sizeinfo)
             putchar('\n');
            pc += 2;
            break;
           }

        case OBJWORD:
           {
            show_patch("WORD");
	    if (!sizeinfo)
             putchar('\n');
            pc += 4;
            break;
           }

        case OBJMODULE:
           {  int n = readobjnum();
	      if (!sizeinfo)
               printf("MODULE %d\n",n);
              break;
           }

        case OBJGLOBAL:
           {
            if (!sizeinfo)
             printf("GLOBAL ");
            show_string();
	    if (!sizeinfo)
             putchar('\n');
            break;
           }

        case OBJLABEL:
           {
	    if (nameinfo)
	     printf("PC = 0x%08X ",pc) ;
            if (!sizeinfo || nameinfo)
             printf("LABEL ");
            show_label_string();
	    if (!sizeinfo || nameinfo)
             putchar('\n');
            break;
           }

        case OBJDATA:
           {  int n = readobjnum();
     	      if (!sizeinfo)
     	       {
                printf("DATA %#x ",n);
                printf("STATIC OFFSET = %#x ",dataoff);
               }
              show_string();
	      if (!sizeinfo)
               putchar('\n');
              dataoff += n;
              break;
           }

        case OBJCOMMON:
           {  int n = readobjnum();
      	      if (!sizeinfo)
      	       {
                printf("COMMON %#x ",n);
                printf("STATIC OFFSET = %#x (may now be erroneous) ",dataoff);
               }
              show_string();
	      if (!sizeinfo)
               putchar('\n');
              dataoff += n;
              break;
           }

        case OBJCODETABLE: /* split module table support */
           {
      	      if (!sizeinfo)
               printf("CODETABLE ");
              show_string();
	      if (!sizeinfo)
               putchar('\n');
              codetableoff += 4;	/* uses 4 bytes for address in static data */
              break;
           }

        case OBJREF:
		if (!sizeinfo) {
			printf("REF ");
			show_string();
			putchar('\n');
d913 1
a913 1
		break;	
d915 6
a920 4
        default:
           fprintf(stderr,"objdump: Warning, bad object format %#x at offset 0x%08X\n",ch,(ftell(f) - 1)) ;
           printf("Bad object format %#x\n (skipping entire word)",ch) ;
       	   getc(f); getc(f); getc(f);
d922 1
a922 1
           tidyup(1);
d924 4
a927 3
        }
     }
     fclose(f);
d929 15
a943 1
   if (sizeinfo && !nameinfo)
d945 8
a952 20
     printf("Image size = 0x%08X\n",pc) ;
     printf("Static data size = 0x%08X\n",dataoff) ;
     printf("Code table size = 0x%08X\n",codetableoff) ;
     pc = 0 ;
     dataoff = 0 ;
     codetableoff = 0 ;
     putchar('\n') ;
    }
  }

 if (!sizeinfo)
  {
   printf("\nTotal image size = %#x\n",pc) ;
   printf("Total static data size = %#x\n",dataoff) ;
   printf("Total code table size = %#x\n",codetableoff) ;
  }

  return(0) ;
  RcsId = RcsId ;
}
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char *RcsId = "$Id$ Copyright (C) Perihelion Software Ltd.";
d40 1
d623 8
@
