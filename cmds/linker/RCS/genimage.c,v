head	1.53;
access;
symbols
	Helios_1_3_1:1.44
	Helios_C40_1_3_Official_Release:1.36
	Alenia_release:1.34
	C40_Field_Test_2:1.32
	C40_Field_Test_R1:1.26;
locks; strict;
comment	@ * @;


1.53
date	94.04.07.10.56.11;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	94.01.20.16.57.06;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	94.01.14.12.19.53;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	94.01.13.17.17.53;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	94.01.13.17.16.38;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	94.01.11.11.33.12;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	94.01.07.14.28.20;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	94.01.07.09.10.23;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	93.12.10.09.09.29;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	93.09.14.09.27.24;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	93.09.13.12.01.32;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	93.08.18.18.27.22;	author paul;	state Exp;
branches;
next	1.41;

1.41
date	93.08.16.08.17.12;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	93.08.06.14.56.28;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	93.08.06.11.02.58;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	93.08.06.10.58.48;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	93.08.04.15.38.32;	author bart;	state Exp;
branches;
next	1.36;

1.36
date	93.03.24.16.08.12;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	93.03.22.10.44.10;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	92.12.03.09.15.57;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	92.10.25.15.14.07;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	92.10.02.08.20.43;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	92.09.21.16.51.24;	author martyn;	state Exp;
branches;
next	1.30;

1.30
date	92.09.15.08.38.57;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	92.07.15.07.38.51;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	92.07.13.08.50.20;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	92.07.06.17.15.29;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	92.06.23.10.25.47;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	92.06.22.13.54.38;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	92.06.15.12.03.12;	author paul;	state Exp;
branches;
next	1.23;

1.23
date	92.06.15.12.01.14;	author paul;	state Exp;
branches;
next	1.22;

1.22
date	92.06.09.09.08.06;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	92.03.30.13.35.48;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	92.03.30.13.32.40;	author paul;	state Exp;
branches;
next	1.19;

1.19
date	92.02.05.11.57.19;	author paul;	state Exp;
branches;
next	1.18;

1.18
date	92.01.13.09.40.20;	author paul;	state Exp;
branches;
next	1.17;

1.17
date	92.01.13.09.37.18;	author paul;	state Exp;
branches;
next	1.16;

1.16
date	91.12.16.17.34.13;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	91.12.12.10.57.04;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	91.12.12.09.17.51;	author paul;	state Exp;
branches;
next	1.13;

1.13
date	91.12.12.09.01.30;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	91.12.11.11.21.31;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	91.12.04.16.30.06;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	91.11.22.16.38.13;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	91.11.22.16.05.14;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	91.11.06.15.03.36;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	91.10.29.13.27.43;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	91.10.21.15.49.52;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	91.10.11.16.05.44;	author paul;	state Exp;
branches;
next	1.4;

1.4
date	91.10.09.10.53.36;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	91.10.09.08.47.51;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	91.10.08.15.47.46;	author ben;	state Exp;
branches;
next	1.1;

1.1
date	90.10.22.15.46.36;	author paul;	state Exp;
branches;
next	;


desc
@@


1.53
log
@fixed core dump
@
text
@/*{{{  Comments */

/****************************************************************/
/* Helios Linker					     	*/
/*								*/
/* File: genimage.c 						*/
/*                                                              */
/* Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994 to	*/
/*               Perihelion Software Ltd.			*/
/*                                                              */
/* Author: NHG 26/9/88                                          */
/*                                                              */
/* Updates: CS/PAB                                              */
/*      Shift patch						*/
/*	SWAP patch                                              */
/*	ARM patches						*/
/*	Recursive patches					*/
/*         NC                                                   */
/*      'C40 patches                                            */
/*                                                              */
/****************************************************************/
/* RcsId: $Id: genimage.c,v 1.52 1994/01/20 16:57:06 nickc Exp nickc $ */

/*}}}*/
/*{{{  #includes */

#include <module.h>
#include <unistd.h>	/* for write() */
#include "link.h"

/*}}}*/
/*{{{  #defines */

#define trace if (traceflags & db_genimage) _trace

#define fits_in_16_bits( val )		(((val) & 0xffff8000U) == 0 || ((val) & 0xffff8000U) == 0xffff8000U)
#define fits_in_16_bits_unsigned( val )	(((val) & 0xffff0000U) == 0 )

#ifdef __C40
#define fits_in_8_bits( val )		(((val) & 0xffffff80U) == 0 || ((val) & 0xffffff80U) == 0xffffff80U)
#define fits_in_24_bits( val )		(((val) & 0xff800000U) == 0 || ((val) & 0xff800000U) == 0xff800000U)
#endif

/*}}}*/
/*{{{  Forward references */

#ifdef __STDC__
word 		patchit( word vtype, long value, word size );
void 		putpatch( Code * c );
word 		mcpatch( word type, VMRef v, word size );
word 		stdpatch( word type, long value );
static void 	outbyte( UBYTE );
static void 	outbyte1( WORD );
static void 	imageheader( WORD );
long 		swapw( long x );
unsigned 	swaps( unsigned x );
void 		flush_output_buffer(void);
#else
word 		patchit();
void 		putpatch();
word 		mcpatch();
word 		stdpatch();
static void 	outbyte();
static void 	outbyte1();
static void 	imageheader();
long 		swapw();
unsigned	swaps();
void 		flush_output_buffer();
#endif

/*}}}*/
/*{{{  Variables */

word 		codepos;

extern FILE *	verfd;

word		nchars;

#ifdef __ARM
static word 	restofdppatch;		/* rest of value to be pathed by armdprest */
static word 	patchNeg;		/* if patch value need a sub rather than an add instr. */
static bool	AOFSymbolIsData;
#endif

#define		BUFFER_SIZE	4096

UBYTE		output_buffer[BUFFER_SIZE];	/* buffered output */
int		output_buffer_pointer = 0;	/* and pointer */

/*}}}*/
/*{{{  Functions */

/*{{{  genimage() */

void
#ifdef __STDC__
genimage( void )
#else
genimage()
#endif
{
  Code *	c;
  asm_Module *	m;
  VMRef		curblock;


  curmod   = module0;
  m        = VMAddr( asm_Module, curmod );
  curblock = m->start;
  
  VMlock( curblock );
   
  c = VMAddr( Code, curblock );
  
  VMDirty( curblock );
   
  codepos = 0;

  imageheader( totalcodesize + sizeof (int) );
      
  for (;;)
    {
      word	tag = c->type;

      
      /* trace( "image op %#x", tag ); */
      
      switch (tag)
	{
	case OBJNEWSEG:	/* go to new code page            */
	  
	  trace( "NEWSEG %#x", c->value.v );
	  
	  VMunlock( curblock );
	  
	  curblock = c->value.v;
	  
	  VMlock( curblock );
	  
	  c = VMAddr( Code, curblock );
	  
	  VMDirty( curblock );
	  
	  continue;
         
	  
      case OBJEND: 	/* start new module            */
	  
         VMunlock( curblock );
	  
         m = VMAddr( asm_Module, curmod );
	  
         curmod = m->next;
	  
         if (NullRef( curmod ))
	   {
	     if (gen_image_header)
		/* only generate tailer if we gen header */
		outword( 0L );

	     flush_output_buffer();

	     return;
	   }

	  m = VMAddr( asm_Module, curmod );

	  curblock = m->start;
	  
	  VMlock( curblock );
	  
	  c = VMAddr( Code, curblock );
	  
	  VMDirty( curblock );
	  
	  codepos = 0;

	  continue;

	case OBJMODULE:
	case OBJDATA:
	case OBJCOMMON:
	case OBJCODETABLE:
	  break;
      
	case OBJCODE:
	    {
	      int	i;
	      int	size = c->size;
	      UBYTE *	v    = VMAddr( UBYTE, c->value.v );
	
	      
	      for (i = 0; i < size ; outbyte( v[ i++ ] ))
		;
	      
	      codepos += size;

	      break;
	    }
            
	case OBJBSS:
	    {
	      int	i;
	      int	size = c->size;

	      
	      for (i = 0; i < size ; outbyte( 0 ))
		;
	      
	      codepos += size;

	      break;
	    }
      
	case OBJLITERAL:
	    {
	      int	i;
	      int	size = c->size;
	      UBYTE *	v    = (UBYTE *)&c->value.w;

	      
	      for (i = 0; i < size ; outbyte( v[ i++ ]))
		;
	      
	      codepos += size;
	      
	      break;
	    }

	case OBJWORD:
	case OBJSHORT:
	case OBJBYTE:
	  putpatch( c );
	  
	  codepos += tag & 0x07;
	  
	  break;
         
	case OBJINIT:
	  if (NullRef( c->value.v ))
	    {
	      outword( 0L );
	    }
	  else 
	    {
	      word	next = VMAddr( Code, c->value.v )->loc;

	      
	      outword( (WORD)(next - c->loc) );
	    }
	  
	  codepos += 4;

	  break;
                  
	default:
	  error( "Unknown tag %#x (@@%#x)", tag, codepos );
	  break;
	}
      
      c++;
    }

  flush_output_buffer();

  return;
  
} /* genimage */

/*}}}*/
/*{{{  putpatch() */

void
#ifdef __STDC__
putpatch( Code * c )
#else
putpatch( c )
  Code *	c;
#endif
{
  word	value = patchit( c->vtype, c->value.fill, c->type );
   
  trace( "Final patch value = %#x", value );
  
  switch (c->type)
    {
    case OBJWORD:
      outword( value );
      break;
      
    case OBJSHORT:
      if (!fits_in_16_bits( value ))
	warn( "Patch value %#x too large for short", value );      

#ifdef __BIGENDIAN
      outbyte1( value >> 8 );
      outbyte1( value );
#else
      outbyte1( value );
      outbyte1( value >> 8 );
#endif
      
      break;
      
    case OBJBYTE:
      if (value < -128 || value > 255)
	warn( "Patch value %#x too large for byte (@@%#x)", value, codepos );
      
      outbyte1( value );
      
      break;

    default:
      warn( "unknown patch result %d\n", c->type );
      break;
   }

  return;
  
} /* putpatch */

/*}}}*/
/*{{{  patchit() */

word
#ifdef __STDC__
patchit(
	word 	vtype,	/* patch type */
	long 	value, 	/* ptr to another patch, or patch symbol */
	word 	size )   /* patch size */
#else
patchit( vtype, value, size )
  word 	vtype;	/* patch type */
  long 	value; 	/* ptr to another patch, or patch symbol */
  word 	size;   /* patch size */
#endif
{
  if (OBJPATCH <= vtype && vtype <= OBJPATCHMAX )
   {
     Value	val;

     
     val.fill = value;

     return (mcpatch( vtype, val.v, size ));
   }

   return (stdpatch( vtype, value ));

} /* patchit */

/*}}}*/
/*{{{  FindSymbolOffset() */

/*
 * Calculate the offset from the start of the current
 * module of the indicated symbol.
 */

WORD
FindSymbolOffset( VMRef vSymbol )
{
  Symbol *	pSymbol;

  
  pSymbol = VMAddr( Symbol, vSymbol );

  if (NullRef( pSymbol ))
    return 0;
  
  if (pSymbol->module != curmod)
    {
      WORD	iSize;
      VMRef 	vMod;
      VMRef	vOurMod = pSymbol->module;
      

      /* The symbol is not in the current module */
      
      vMod = module0;

      /* discover which comes first 'curmod' or 'vOurMod' */

      while (!NullRef( vMod ) &&
	     vMod != vOurMod  &&
	     vMod != curmod    )
	{
	  vMod = VMAddr( asm_Module, vMod )->next;
	}
      
      if (NullRef( vMod ))
	{
	  pSymbol = VMAddr( Symbol, vSymbol );
	  
	  warn( "Stub Generation: could not find module containing symbol '%s'!",
	       pSymbol->name );
	  
	  return codepos;
	}
      
      iSize = 0;
      
      if (vMod == curmod)
	{
	  /* search for forwards reference */

	  while (!NullRef( vMod ) &&
		 vMod != vOurMod   )
	    {
	      asm_Module * 	pModule = VMAddr( asm_Module, vMod );
	      
	      iSize += pModule->length;
	      vMod   = pModule->next;
	    }
	  
	  pSymbol = VMAddr( Symbol, vSymbol );
	  
	  if (NullRef( vMod ))
	    {
	      warn( "Stubs: unable to locate module %s containing symbol '%s'",
		   VMAddr( asm_Module, vOurMod )->file_name,
		   pSymbol->name );
	      
	      return codepos;
	    }
	  
	  return VMAddr( Code, pSymbol->value.v )->loc + iSize;
	}
      else
	{
	  /* search for backwards reference */
	  
	  while (!NullRef( vMod ) &&
		 vMod != curmod    )
	    {
	      asm_Module *	pModule = VMAddr( asm_Module, vMod );
	      
	      
	      iSize += pModule->length;
	      vMod   = pModule->next;
	    }
	  
	  pSymbol = VMAddr( Symbol, vSymbol );
	  
	  if (NullRef( vMod ))
	    {
	      warn( "Stub Generation: unable to locate module refering to symbol '%s'",
		   pSymbol->name );
	      
	      return codepos;
	    }
	  
	  return VMAddr( Code, pSymbol->value.v )->loc - iSize;
	}
    }

  /* symbol is inside the current module - just return the offset */
  
  return VMAddr( Code, pSymbol->value.v )->loc;
  
} /* FindSymbolOffset */

/*}}}*/
/*{{{  stdpatch() */

word
#ifdef __STDC__
stdpatch(
	 word 	vtype,
	 long	xvalue )
#else
stdpatch( vtype, xvalue )
  word 	vtype;
  long	xvalue;
#endif
{
  Value 	value;
  asm_Module *	m;
  Symbol *	s;


  value.fill = xvalue;

  m = VMAddr( asm_Module, curmod );
      
  switch (vtype)
    {
    default:
      error( "Unknown standard patch type in stdpatch: %#x (@@%#x)", vtype, codepos );
      
      return 0;
      
    case OBJMODSIZE:
      return m->length;
      
    case OBJMODNUM:
      trace( "Stdpatch: returning module %08x, number %d", curmod, m->id );

      return m->id;

#ifdef NEW_STUBS
    case OBJCODESTUB:
    case OBJADDRSTUB:
	{
	  WORD	r;

	  
	  s = VMAddr( Symbol, value.v );

	  if (s->type != S_CODESYMB)
	    {
	      VMRef	ref;
	      VMRef	mod;
	      

	      if (vtype == OBJCODESTUB)
		{
		  char	name[ 128 ];		/* XXX */
		  
		  /* catch unlikely case of a CODESTUB for something other than .<name> */
		  
		  if (*s->name != '.')
		    {
		      warn( "Function \"%s\" used in module '%s', but not defined",
			   s->name + 1, m->file_name );

		      /* prevent future warnings */
		      
		      s->type   = S_CODESYMB;
		      s->module = curmod;
	  
		      return 0;
		    }

		  /* duplicate name */
	      
		  strcpy( name, s->name );

		  /* change first character */
	      
		  name[ 0 ] = '_';

		  /* find the associated shared library symbol */
	      
		  ref = lookup( name );

		  if (ref == NullVMRef)
		    {
		      warn( "Function \"%s\" is called from module '%s', but it is not defined",
			   name + 1, m->file_name );
		      
		      /* prevent future warnings */
		  
		      s->type   = S_CODESYMB;
		      s->module = curmod;
		  
		      return 0;		  
		    }
		  
		  /* check the type of the symbol */
	      
		  s = VMAddr( Symbol, ref );

		  if (s->type == S_UNBOUND)
		    {
		      warn( "Function \"%s\" is called in '%s', but it is not defined",
			   name + 1, m->file_name );
		      
		      /* prevent futher warnings */
		  
		      s->type   = S_FUNCDONE;
		      s->module = curmod;

		      return 0;
		    }
	
		  if (s->type != S_FUNCDONE)
		    {
		      if (s->type == S_FUNCSYMB)
			{
			  warn( "Function \"%s\" is called in '%s', but it has not been linked",
			       name + 1, m->file_name );
			}
		      else
			{
			  warn( "Function \"%s\" is called in '%s', but defined in '%s' as something else.",
			       name + 1, m->file_name, s->file_name );
			}

		      /* prevent futher warnings */
		  
		      s->type   = S_FUNCDONE;
		      s->module = curmod;

		      return 0;
		    }
	
		  s->referenced = 1;
		}
	      else
		{
		  ref = value.v;
		}
	      
	      /* request a new stub */
	      
	      r = new_stub( ref, vtype == OBJADDRSTUB );
	      
	      /* adjust 'r' to be relative to current module */
	      
	      mod = module0;
	      
	      while (!NullRef( mod ) &&
		     mod != curmod)
		{
		  asm_Module *	module;
		  
		  
		  module = VMAddr( asm_Module, mod );
		  
		  r -= module->length;
		  
		  mod = module->next;
		}
	    }
	  else
	    {
	      r = FindSymbolOffset( value.v );
	    }
	  
	  trace( "Stdpatch: returning label offset of %s = %d", s->name, r - codepos );
	  
	  return r - codepos;
	}
#endif /* NEW_STUBS */
      
    case OBJLABELREF:
	{
	  word	r;

	  
	  s = VMAddr( Symbol, value.v );
	  
	  if (s->type != S_CODESYMB)
	    {
	      warn( "Label \"%s\" used in module '%s', but not defined", s->name, m->file_name );
	      
	      s->type   = S_CODESYMB;
	      s->module = curmod;
	  
	      return 0;
	    }
	  
	  r = FindSymbolOffset( value.v );
	  
	  trace( "Stdpatch: returning label offset of %s = %d", s->name, r - codepos );

	  return r - codepos;
	}

    case OBJDATASYMB:
      s = VMAddr( Symbol, value.v );
      
      trace( "Stdpatch: datasymb of symbol %s", s->name );
      
      if (s->type != S_DATADONE)
	{
	  if (s->type == S_FUNCDONE)
	    warn( "Alas, function %s was assumed to be data, please link %s before %s",
		 s->name + 1, VMAddr( asm_Module, s->module)->file_name, m->file_name );
	  else
	    warn( "Data Symbol \"%s\" used in module '%s', but not defined",
		 s->name + 1, m->file_name );

	  s->type   = S_DATADONE;
	  s->module = curmod;
	  
	  return 0;
	}

      return s->value.w;
      
    case OBJCODESYMB:
      s = VMAddr( Symbol, value.v );
      
      trace( "Stdpatch: codesymb of symbol %s", s->name );
      
      if (s->type != S_FUNCDONE)
	{
	  warn( "Function Symbol \"%s\" used in module '%s', but not defined", s->name + 1, m->file_name );
	  
	  s->type   = S_FUNCDONE;
	  s->module = curmod;
	  
	  return 0;
	}

      return s->value.w;
      
    case OBJDATAMODULE:
      s = VMAddr( Symbol, value.v );
      
      trace( "Stdpatch: datamodule of symb %s", s->name );
      
      if (s->type != S_DATADONE && s->type != S_FUNCDONE)
	{
#ifdef NEW_STUBS
	  char	name[ 128 ];	/* XXX */
	  VMRef	ref;
	  
	  /* catch unlikely case of a DATAMODULE for something other than _<name> */
	  
	  if (*s->name != '_')
	    {
	      warn( "Function \"%s\" called in module '%s', but not defined",
		   s->name + 1, m->file_name );
	      
	      /* prevent future warnings */
		      
	      s->type   = S_FUNCDONE;
	      s->module = curmod;
	  
	      return 0;
	    }
	  
	  /* duplicate name */
	  
	  strcpy( name, s->name );
	  
	  /* change first character */
	      
	  name[ 0 ] = '.';
	  
	  /* find the associated shared library symbol */
	      
	  ref = lookup( name );

	  if (ref == NullVMRef)
	    {
	      warn( "Function \"%s\" was called from module '%s', but it is not defined",
		   name + 1, m->file_name );
	      
	      /* prevent future warnings */
	      
	      s->type   = S_FUNCDONE;
	      s->module = curmod;
	      
	      return 0;		  
	    }
	  
	  /* check the type of the symbol */
	  
	  s = VMAddr( Symbol, ref );
	  
	  if (s->type == S_UNBOUND)
	    {
	      warn( "Function \"%s\" was called in '%s', but it is not defined",
		   name + 1, m->file_name );
	      
	      /* prevent futher warnings */
	      
	      s->type   = S_FUNCDONE;
	      s->module = curmod;
	      
	      return 0;
	    }
	  
	  if (s->type != S_CODESYMB)
	    {
	      if (s->type == S_FUNCSYMB)
		{
		  warn( "Function \"%s\" was called in '%s', but it has not been linked",
		       name + 1, m->file_name );
		}
	      else
		{
		  warn( "Function \"%s\" was called in '%s', but defined in '%s' as type %x.",
		       name + 1, m->file_name, s->file_name, s->type );
		}
	      
	      /* prevent further warnings */
	      
	      s->type   = S_CODESYMB;
	      s->module = curmod;
	      
	      return 0;
	    }
	  
	  /* indicate that the .<name> is being used */
	  
	  s->referenced = 1;

	  trace( "branch ref to %s in %s", s->name, VMAddr( asm_Module, s->module )->file_name );
	  
	  /* generate a branch stub called _<name> */
	  
	  RequestBranchStub( value.v );

	  /* locate this branch stub */
	  
	  s = VMAddr( Symbol, value.v );
	  
#else /* not NEW_STUBS */

	  if (s->AOFassumedData)
	    {
	      if (!NullRef( s->module ))
		{ 
		  asm_Module *	pDef; 

	      
		  pDef = VMAddr( asm_Module, s->module );	  

		  if (m->file_name == pDef->file_name)
		    warn( "Alas, function '%s' was assumed to be data, please link %s before %s",
			 s->name + 1, s->file_name, m->file_name );
		  else
		    warn( "Alas, function '%s' was assumed to be data, please link %s before %s",
			 s->name + 1, pDef->file_name, m->file_name );
		}
	      else
		warn( "Beware, function '%s' was assumed to be data", s->name + 1 );
	      
	      s->type   = S_DATADONE;
	      s->module = curmod;
	    }
	  else
	    {
	      warn( "Symbol \"%s\" used in module '%s', but not defined",
		   s->name + 1, m->file_name );
	  
	      s->type = S_FUNCDONE;
	      s->module = curmod;
	    }
	  
	  return 0;
#endif /* NEW_STUBS */
	}

      m = VMAddr( asm_Module, s->module );
      
      trace( "DATAMODULE returns module id %d for symbol %s", m->id, s->name /* XXX */ );
      
      if (smtopt)
	return (m->id * 8 + (s->type == S_FUNCDONE ? 4 : 0));
      else
	return (m->id * 4);
    }
  
  return 0;
  
} /* stdpatch */

/*}}}*/
/*{{{  imageheader() */

/****************************************************************/
/* imageheader                                                  */
/*                                                              */
/* Generate image file header                                   */
/*                                                              */
/****************************************************************/

PRIVATE void
#ifdef __STDC__
imageheader( WORD imagesize )
#else
imageheader( imagesize )
  WORD	imagesize;
#endif
{
	if (gen_image_header) {
		outword( Image_Magic );
		outword( 0L );			/* Flags */
		outword( imagesize );
	}

	nchars = 0;

	return;

} /* imageheader */

/*}}}*/
/*{{{  outword() */

/****************************************************************/
/* outword                                                      */
/*                                                              */
/* output a word to image file                                  */
/*                                                              */
/****************************************************************/

PUBLIC void
#ifdef __STDC__
outword( WORD val )
#else
outword( val )
  WORD	val;
#endif
{
  int i;


#ifdef __BIGENDIAN /* 68k etc */
  
  for (i = 24 ; i >= 0 ; i -= 8)
    outbyte( (UBYTE)(val >> i) );
  
#else

  for (i = 0 ; i < 32 ; i += 8)
    outbyte( (UBYTE)(val >> i) );
  
#endif

  return;
  
} /* outword */

/*}}}*/
/*{{{  outbyte1() */

/****************************************************************/
/* Procedure: outbyte1                                           */
/*                                                              */
/*      output a byte to image file                             */
/*                                                              */
/****************************************************************/

PRIVATE void
#ifdef __STDC__
outbyte1( WORD b )
#else
outbyte1( b )
  WORD	b;
#endif
{
  outbyte( (UBYTE)b );

  return;
  
} /* outbyte1 */

/*}}}*/
/*{{{  outbyte() */

PRIVATE void
#ifdef __STDC__
outbyte( UBYTE b )
#else
outbyte( b )
  UBYTE	b;
#endif
{
  output_buffer[output_buffer_pointer++] = b;

  if (output_buffer_pointer == BUFFER_SIZE)
    flush_output_buffer();

  nchars++;

  return;
  
} /* outbyte */

/*}}}*/
/*{{{  flush_output_buffer() */

PUBLIC void
#ifdef __STDC__
flush_output_buffer( void )
#else
flush_output_buffer( )
#endif
{
  int size = 0;
  int size1;

  while (size != output_buffer_pointer)
    {
      size1 = write(outf, (char *)(output_buffer + size),
		    output_buffer_pointer - size);

      if (size1 < 0)
	error( "image file write error");
      
      size += size1;
    }

  output_buffer_pointer = 0;
}

/*}}}*/
/*{{{  swapw() */

/* swap words */

long
#ifdef __STDC__
swapw( long x )
#else
swapw( x )
  long	x;
#endif
{

  return ((x >> 24) & 0x000000ffU) |
         ((x >>  8) & 0x0000ff00U) |
         ((x <<  8) & 0x00ff0000U) |
	 ((x << 24) & 0xff000000U) ;

} /* swapw */

/*}}}*/
/*{{{  swaps() */

/* swap shorts */

unsigned int
#ifdef __STDC__
swaps( unsigned int x )
#else
swaps( x )
  unsigned int x;
#endif
{

  return ((x >> 8) & 0xff) | ((x << 8) & 0xff00);
  
} /* swaps */

/*}}}*/

#if defined __C40
/*{{{  mask_and_sign_extend() */

/*
 * extracts the bits specified by 'mask' from the word 'value'
 * if necessary the resulting word is sign extended.
 * 'mask' must be a contigous set of bits starting from
 * the least significant bit
 */

static signed long
mask_and_sign_extend_word(
			  unsigned long	value,
			  unsigned long	mask )
{
  value &= mask;

  if (value & ((mask + 1) >> 1))
    {
      value |= ~mask;
    }

  return (signed long)value;
  
} /* mask_and_sign_extend_word */

/*}}}*/
#endif /* __C40 */

/*{{{  mcpatch() */

/* Machine specific patches defined for ARM, M68K and PGC1 */

word
#ifdef __STDC__
mcpatch(
	word 	type,
	VMRef	v,
	word 	size )
#else
mcpatch( type, v, size )
  word 		type;
  VMRef	 	v;
  word 		size;
#endif
{
#ifdef __ARM
  long 		data;
#endif
  Patch *	p     = VMAddr( Patch, v );
  long		value; 
#ifdef __C40
  static word	saved_modnum = 0;
  static word	saved_offset = 0;
#endif

#ifdef __ARM
  if (size != OBJWORD && (type == PATCHARMDT ||
			  type == PATCHARMDP ||
			  type == PATCHARMJP ) )
    error( "ARM specific patch used to patch a short or byte value (@@%#x)", codepos );

  if (type < PATCHARMAOFLSB || type > PATCHARMAOFREST)
#endif /* __ARM */

    value = patchit( p->type, p->value.fill, size );
  
  switch (type)
    {
    case PATCHADD:
      return p->word + value;

   case PATCHSHIFT:
      if (p->word < 0)
	{
	  return ((signed long) value) >> (- p->word);
	}
      else
	{
	  return value << p->word;
	}

    case PATCHSWAP:
      if (size == OBJWORD)
	return swapw( value ); /* swap word */
      else
	return swaps( (unsigned) value ); /* swap short */

    case PATCHOR:
      return p->word | value;

#ifdef __C40
      /*
       * XXX - NC - 2/10/91
       *
       * WARNING: These patches a highly dependent upon the
       * register scheme defined in c40/target.h and the
       * code in load_address_constant() in c40/gen.c
       *
       * There are four cases:
       *
       *       modnum < 256               modnum < 256                 modnum > 255             modnum > 255
       *       offset < 256               offset > 255                 offset < 256             offset > 255
       *
       *  LDI *+AR4( modnum ), AR5    LDI  *+AR4( modnum ), AR5    LDI  AR4, AR5                LDI  AR4, AR5
       *  LDI *+AR5( offset ), AR5    ADDI offset, AR5             ADDI modnum, AR5             ADDI modnum, AR5
       *  Bu  AR5                     LDI  *AR5, AR5               LDI  *AR5, AR5               LDI  *AR5, AR5
       *  -                           Bu   AR5                     LDI  *+AR5( offset ), AR5    ADDI offset, AR5
       *  -                           -                            Bu   AR5                     LDI  *AR5, AR5
       *  -                           -                            -                            Bu   AR5
       */
      
    case PATCHC40DATAMODULE1:					/* value is DataModule */
      if (fits_in_8_bits( value ))
	{
	  saved_modnum = -2;
	  
	  return 0x084d0400U + (value & 0xff);			/* LDI *+AR4( modnum ), AR5 */
	}
      else if (!fits_in_16_bits( value ))
	{
	  error( "linker: module number does not fit in 16 bits - code will not link" );
	}
      else
	{
	  saved_modnum = value;

	  return 0x080d000cU;					/* LDI AR4, AR5 */
	}
      
    case PATCHC40DATAMODULE2:					/* value is DataSymb */
      if (saved_modnum == -2)
	{
	  saved_offset = -2;
	  
	  if (fits_in_8_bits( value ))
	    {
	      return 0x084d0500U + (value & 0xff);		/* LDI *+AR5( offset ), AR5 */
	    }
	  else if (!fits_in_16_bits( value ))
	    {
	      error( "linker: function offset in module table does not fit in 16 bits - code will not link" );
	    }
	  else
	    {
	      saved_offset = -1;				/* trigger LDI *AR5, AR5 */
	      
	      return 0x026d0000U + (value & 0xffff);		/* ADDI offset, AR5 */
	    }	  
	}
      else
	{
	  saved_offset = value;
      
	  return 0x026d0000U + saved_modnum;			/* ADDI modnum, AR5 */
	}	      
      
    case PATCHC40DATAMODULE3:
      if (saved_modnum == -2 && saved_offset == -2)
	{
	  return 0x6800000dU;					/* Bu Ar5 */
	}
      else
	{
	  return 0x084dc500U;					/* LDI *AR5, AR5 */
	}

    case PATCHC40DATAMODULE4:
      if (saved_modnum == -2 && saved_offset != -2)
	{
	  return 0x6800000dU;					/* Bu AR5 */
	}
      else if (saved_modnum != -2)
	{
	  if (fits_in_8_bits( saved_offset ))
	    {
	      saved_modnum = -2;				/* special case, picked up DataModule5 */
	      
	      return 0x084d0500U + (saved_offset & 0xff);	/* LDI *+AR5( offset ), AR5 */
	    }
	  else
	    {
	      return 0x026d0000U + (saved_offset & 0xffff);	/* ADDI offset, AR5 */
	    }
	}

    case PATCHC40DATAMODULE5:
      if (saved_modnum == -2)
	{
	  return 0x6800000dU;					/* Bu Ar5 */
	}
      else
	{
	  return 0x084dc500U;					/* LDI *AR5, AR5 */
	}

      /*
       * special addition routines that take a mask as well
       */
      
    case PATCHC40MASK24ADD:
	{
	  word	mask = 0x00FFFFFFU;
	  
	  
	  value += mask_and_sign_extend_word( p->word, mask );

	  if (!fits_in_24_bits( value ))
	    {
	      warn( "calculated offset (%08x) too big to fit in 24 bit instruction field (%08x)!",
		   value, p->word );
	    }
	  
	  return (p->word & (~mask)) | (value & mask);
	}      
      
    case PATCHC40MASK16ADD:
	{
	  word	mask = 0x0000FFFFU;

	  
	  value += mask_and_sign_extend_word( p->word, mask );

	  if (!fits_in_16_bits( value ))
	    {
	      warn( "calculated offset (%08x) too big to fit in 16 bit instruction field (%08x)!",
		   value, p->word );
	      warn( "This is probably because the source file was compiled with the -Zpl1 option" );	      
	    }
	  
	  return (p->word & (~mask)) | (value & mask);
	}      
      
    case PATCHC40MASK8ADD:
	{
	  word		mask = 0x000000FFU;
	  

	  /* NB/ use unsigned values as this patch is altering indirect displacements */
	  
	  value += (p->word & mask);

	  if (value & ~mask)
	    {
	      asm_Module *	m;

	      
	      m = VMAddr( asm_Module, curmod );
	      
	      warn( "calculated offset (%08x) too big to fit in 8 bits, op code in module %s!",
		   value, m->file_name );
	      warn( "This is probably because the source file was compiled with the -Zpl1 option" );	      
	    }
	  
	  return (p->word & (~mask)) | (value & mask);
	}      
      
#endif /* __C40 */
      
#ifdef __ARM
    case PATCHARMDT:			/* ARM data transfer instr. patch */
      
      value += (p->word & 0xfff); 	/* patch value includes existing immediate offset */

      data = p->word & 0xfffff000U;

      if (p->type == OBJLABELREF)
	value -= 8;			/* adjust pc rel labelref for ARM pipelining */

      if (value < -2048 || value > 4096)
	error( "ARM data transfer patch value (%#x) too large (@@%#x)", value, codepos );

      /* set direction bit (23) in ARM instruction - 1 = up 0 = down */

      if (value < 0)
	{
	  value = -value;		/* offsets are unsigned */
	  data &= ~(1 << 23);		/* down = backwards jump = bit 23=0 */
	}
      else
	{
	  data |= 1 << 23;
	}

      return (data | value);

    case PATCHARMDP:			/* ARM data processing instr. patch */
	{
	  word	ror = 0;
	  word	savval;


	  value += (p->word & 0xff); 	/* add existing contents to patch value */

	  if (p->type == OBJLABELREF)
	    value -= 8;			/* adjust pc rel labelref for ARM pipelining */

	  savval = value;
	
	  if (value < 0)
	    error( "ARM data processing patch value should not be negative (@@%#x)", codepos );

	  if (value > 255)
	    {
	      ror = 0x10;

	      while (!(value & 3)) 	/* word aligned immediate data? */
		{
		  /* see ARM assembly lang prg. pg 40 */
		  /* ARM data man pg 21/25 */

		  value >>= 2;		/* shift immediate value left by  two */

		  if (--ror <= 4) 	/* and alter rotate by factor of two */
		    break;  		/* ARM immediate rotates are multiplied by 2 */
		}

	      if (ror == 0x10)
		ror = 0; 		/* if no rotates used */
	    }
	  
	  if (value > 255)
	    {
#if 1
	      error( "Patch value of %#x is too large for ARM DP patch.(origval = %#x) data=%#x (@@%#x)",
		    value, savval, p->word, codepos );
#else
	      warn( "Patch value of %#x is too large for ARM DP patch.(origval = %#x) data=%#x (@@%#x)",
		   value, savval, p->word, codepos );
#endif
	    }
	  
	  value |= ror << 8; /* 4 bits of ror preceed 8 bit immediate */

	  return (value | (p->word & (unsigned long) 0xfffff000U));
	}

    case PATCHARMDPLSB:			/* ARM data processing instr. patch least sig byte */
	{
	  patchNeg = FALSE; 		/* default to use an add instr. for labelrefs */

	  if (p->type == OBJLABELREF)
	    {
	      value -= 8;		/* adjust pc rel labelref for ARM pipelining */

	      if (value < 0)
		{			/* backwards label ref */
		  patchNeg = TRUE; 	/* use a sub instr. */
		  value    = -value;
		}
	    }
	  else if (value < 0)
	    {
	      error( "Negative patch value passed to armdplsb" );
	    }
	  
	  if (p->type != OBJLABELREF)
	    {
	      word	imm;


	      /* get instr. existing immediate const and add to patch value */

	      imm = (p->word & 0xfff); 	/* bodged 12 bit immediate */

	      value += imm;
	    }
	
	  restofdppatch = value;

	  value &= 0xff; 		/* only ls byte for this patch  - not optimal as rot cannot be used */

	  restofdppatch -= value; 	/* remember rest of patch */

	  if (patchNeg)
	    {
	      int	instr = (int)(p->word & 0xfffff000U);
		

	      if ((instr & 0x01e00000U) == 0x00800000U)
		{
		  instr &= ~0x01e00000U;	/* convert to a sub instruct */
		  instr |= 0x00400000U;
		}
	      else
		{
		  error( "armdplsb: Trying to change add to sub when instr not an add" );
		}
	      
	      return (value | instr);
	    }
	  else
	    {
	      return (value | (p->word & 0xfffff000U));
	    }
	}

    case PATCHARMDPMID:			/* ARM data processing instr. patch second least sig byte */
	{
	  /* dummy to clean up any unrequired patch info */
	  
	  value = restofdppatch;

	  value         &=  0xFF00;	/* use second ls byte for this patch */
	  restofdppatch -=  value;	/* work out remainder still to patch */
	  value         >>= 8;		/* move into instructions immediate field */
	  value         |=  0x0C00;	/* merge in immediate data's rotate field */
	  				/* 0x0C00 = left shift by eight bits */
	  if (patchNeg)
	    {
	      int	instr = (int)(p->word & 0xfffff000U);

	      
	      if ((instr & 0x01e00000U) == 0x00800000U)
		{
		  instr &= ~0x01e00000U;	/* convert to a sub instruct */
		  instr |= 0x00400000U;
		}
	      else
		{
		  error( "armdpmid: Trying to change add to sub when instr not an add" );
		}
	      
	      return (value | instr);
	    }
	  else
	    {
	      return (value | (p->word & 0xfffff000U));
	    }
	}

    case PATCHARMDPREST:		/* ARM data processing instr. patch - rest of last lsb patch */
	{
	  word	ror = 0;		/* dummy to clean up any unrequired patch info */

	  
	  value = restofdppatch; 	/* use residue from last armdplsb/mid patch */

	  if (value > 255)
	    {
	      ror = 0x10;

	      while (!(value & 3)) 	/* word aligned immediate data? */
		{
		  /* see ARM assembly lang prg. pg 40 */
		  /* ARM data man pg 21/25 */

		  value >>= 2;		/* shift immediate value left by  two */

		  if (--ror <= 4) 	/* and alter rotate by factor of two */
		    break;  		/* ARM immediate rotates are multiplied by 2 */
		}

	      if (ror == 0x10)
		ror = 0; 		/* if no rotates used */
	    }

	  if (value > 255 )
	    error( "Patch value of %#x is too large for ARM DP residue patch (@@%#x)", value, codepos );
	  
	  value |= ror << 8; 		/* 4 bits of ror preceed 8 bit immediate */

	  if (patchNeg)
	    {
	      int	instr = (int)(p->word & 0xfffff000U);


	      if ((instr & 0x01e00000U) == 0x00800000U)
		{
		  instr &= ~0x01e00000U;	/* convert to a sub instruct */
		  instr |= 0x00400000U;
		}
	      else
		{
		  error( "armdprest: Trying to change add to sub when instr not an add" );
		}
	      
	      return (value | instr);
	    }
	  else
	    {
	      return (value | (p->word & 0xfffff000U));
	    }
	}

    case PATCHARMJP:			/* ARM branch instr. patch */
      if (p->type != OBJLABELREF)
	error( "ARM jp patch should only be used with a label ref (@@%#x)", codepos );
      
      return (p->word & 0xff000000U) | (((value - 8) >> 2) & 0x00ffffffU);
      
    case PATCHARMAOFLSB:
      {
	Symbol *	s;


	s = VMAddr( Symbol, p->value.v );
      
	trace( "ARM patch: data/code symb of symbol %s", s->name );
      
	if (s->type != S_DATADONE && s->type != S_FUNCDONE)
	  {
	    asm_Module *	m;

	    m = VMAddr( asm_Module, curmod );
	    
	    warn( "Symbol \"%s\" used in module '%s', but not defined", s->name + 1, m->file_name );

	    s->type   = S_DATADONE;
	    s->module = curmod;
	  
	    return 0;
	  }

	/* symbol's offest into data or code table is s->value.w */

	value = s->value.w;
	
	restofdppatch = value;

	value &= 0xff;	/* only ls byte for this patch  - not optimal as rot cannot be used */

	restofdppatch -= value; 	/* remember rest of patch */

	if (s->type == S_DATADONE)
	  {
	    AOFSymbolIsData = TRUE;
	    
	    return 0xe2800000UL | ((p->word & 0xF) << 12) | ((p->word & 0xF) << 16) | value;
	  }
	else
	  {
	    AOFSymbolIsData = FALSE;
	    
	    return 0xe5900000UL | ((p->word & 0xF) << 12) | ((p->word & 0xF) << 16) | value;
	  }
      }
      
    case PATCHARMAOFMID:
      value = restofdppatch;

      value         &=  0xFF00;	/* use second ls byte for this patch */
      restofdppatch -=  value;	/* work out remainder still to patch */
      value         >>= 8;	/* move into instructions immediate field */
      value         |=  0x0C00;	/* merge in immediate data's rotate field */
	  			/* 0x0C00 = left shift by eight bits */

      if (AOFSymbolIsData)
	return 0xe2800000UL | ((p->word & 0xF) << 12) | ((p->word & 0xF) << 16) | value;
      else
	return 0xe1a00000UL;

    case PATCHARMAOFREST:
	{
	  word	ror = 0;		/* dummy to clean up any unrequired patch info */

	  
	  value = restofdppatch; 	/* use residue from last armdplsb/mid patch */

	  if (value > 255)
	    {
	      ror = 0x10;

	      while (!(value & 3)) 	/* word aligned immediate data? */
		{
		  /* see ARM assembly lang prg. pg 40 */
		  /* ARM data man pg 21/25 */

		  value >>= 2;		/* shift immediate value left by  two */

		  if (--ror <= 4) 	/* and alter rotate by factor of two */
		    break;  		/* ARM immediate rotates are multiplied by 2 */
		}

	      if (ror == 0x10)
		ror = 0; 		/* if no rotates used */
	    }

	  if (value > 255 )
	    error( "Patch value of %#x is too large for ARM DP residue patch (@@%#x)", value, codepos );
	  
	  value |= ror << 8; 		/* 4 bits of ror preceed 8 bit immediate */

	  if (AOFSymbolIsData)
	    return 0xe2800000UL | ((p->word & 0xF) << 12) | ((p->word & 0xF) << 16) | value;
	  else
	    return 0xe1a00000UL;
	}
#endif /* __ARM */

    default:
      error( "Unknown machine dependent patch type in mcpatch: %#x (@@%#x)", type, codepos );
   }
 
  return 0;

} /* mcpatch */

/*}}}*/

/*}}}*/
@


1.52
log
@improved warning message
@
text
@d22 1
a22 1
/* RcsId: $Id: genimage.c,v 1.51 1994/01/14 12:19:53 nickc Exp nickc $ */
d808 4
a811 1
	      asm_Module *	pDef = VMAddr( asm_Module, s->module );
d813 9
a821 4

	      if (m->file_name == pDef->file_name)
		warn( "Alas, function '%s' was assumed to be data, please link %s before %s",
		     s->name + 1, s->file_name, m->file_name );
d823 2
a824 3
		warn( "Alas, function '%s' was assumed to be data, please link %s before %s",
		     s->name + 1, pDef->file_name, m->file_name );
	  
d830 2
a831 1
	      warn( "Symbol \"%s\" used in module '%s', but not defined", s->name + 1, m->file_name );
d843 1
a843 2
      trace( "DATAMODULE returns module id %d for symbol %s\n",
	    m->id, s->name /* XXX */ );
@


1.51
log
@added new warning message
@
text
@d22 1
a22 1
/* RcsId: $Id: genimage.c,v 1.50 1994/01/13 17:17:53 nickc Exp nickc $ */
d808 9
a816 2
	      warn( "Alas, function '%s' was assumed to be data, please link %s before %s",
		   s->name + 1, VMAddr( asm_Module, s->module )->file_name, m->file_name );
@


1.50
log
@oops: removed debugging left in by previous delta
@
text
@d22 1
a22 1
/* RcsId: $Id: genimage.c,v 1.49 1994/01/13 17:16:38 nickc Exp nickc $ */
d805 5
d811 6
a816 1
	  warn( "Symbol \"%s\" used in module '%s', but not defined", s->name + 1, m->file_name );
d818 3
a820 2
	  s->type = S_FUNCDONE;
	  s->module = curmod;
@


1.49
log
@fixed warning message
@
text
@d22 1
a22 1
/* RcsId: $Id: genimage.c,v 1.48 1994/01/11 11:33:12 nickc Exp nickc $ */
d671 1
a671 1
		 s->name +1, VMAddr( asm_Module, s->module)->file_name, m->file_name );
d673 2
a674 2
	    warn( "Data Symbol \"%s\" used in module '%s', but not defined (%x)",
		 s->name , m->file_name, s->type );
@


1.48
log
@added folding
@
text
@d22 1
a22 1
/* RcsId: $Id: genimage.c,v 1.47 1994/01/07 14:28:20 nickc Exp nickc $ */
d669 6
a674 1
	  warn( "Data Symbol \"%s\" used in module '%s', but not defined", s->name + 1, m->file_name );
@


1.47
log
@added code to support new AOF patches for ARM world
@
text
@d1 2
d8 1
a8 1
/* Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993 to		*/
d22 4
a25 1
/* RcsId: $Id: genimage.c,v 1.46 1994/01/07 09:10:23 nickc Exp nickc $ */
d31 3
d44 2
a46 3
/****************************************************************/
/* Prototypes */

d71 2
a72 3

/****************************************************************/
/* Globals */
d91 4
a94 2
/****************************************************************/
/* Code */
d271 2
d323 2
d353 2
d382 3
a384 1
      
d388 3
a390 1
	vMod = VMAddr( asm_Module, vMod )->next;
d407 1
a407 1
	  
a412 1
	      
d421 2
a422 1
	      warn( "Stub Generation: unable to locate module containing symbol '%s'",
d464 2
d788 2
d825 2
d855 2
d892 2
d896 1
a896 1
/* Procedure: outbyte                                           */
d916 2
d938 3
d965 3
d986 2
d1004 1
d1007 2
d1032 1
d1035 1
d1603 4
@


1.46
log
@fixed core dump produced by attempts to suppress unnecessary warnings
@
text
@d20 1
a20 1
/* RcsId: $Id: genimage.c,v 1.45 1993/12/10 09:09:29 nickc Exp nickc $ */
d77 1
d1013 1
a1013 1
  long		value = patchit( p->type, p->value.fill, size );
a1018 1
  
d1024 2
d1028 2
d1453 98
@


1.45
log
@fixed compile time warning
@
text
@d20 1
a20 1
/* RcsId: $Id: genimage.c,v 1.44 1993/09/14 09:27:24 nickc Exp nickc $ */
d509 2
a510 1
		      s->type = S_CODESYMB;
d534 2
a535 1
		      s->type = S_CODESYMB;
d551 2
a552 1
		      s->type = S_FUNCDONE;
d572 2
a573 1
		      s->type = S_FUNCDONE;
d628 2
a629 1
	      s->type = S_CODESYMB;
d650 2
a651 1
	  s->type = S_DATADONE;
d667 2
a668 1
	  s->type = S_FUNCDONE;
d695 2
a696 1
	      s->type = S_FUNCDONE;
d720 2
a721 1
	      s->type = S_FUNCDONE;
d732 1
a732 1
	      warn( "Function \"%s\" wass called in '%s', but it is not defined",
d737 2
a738 1
	      s->type = S_FUNCDONE;
d758 2
a759 1
	      s->type = S_CODESYMB;
d781 1
d786 1
a786 1
      
@


1.44
log
@removed hexopt option
@
text
@d20 1
a20 1
/* RcsId: $Id: genimage.c,v 1.43 1993/09/13 12:01:32 nickc Exp nickc $ */
d1323 1
a1323 1
	      int	instr = (p->word & 0xfffff000U);
d1357 1
a1357 1
	      int	instr = (p->word & 0xfffff000U);
d1411 1
a1411 1
	      int	instr = (p->word & 0xfffff000U);
@


1.43
log
@added code to use Branch Stubs
@
text
@d20 1
a20 1
/* RcsId: $Id: genimage.c,v 1.42 1993/08/18 18:27:22 paul Exp nickc $ */
d884 1
a884 9
  if (hexopt)
    {
      char	buff[ 10 ];

      
      if ((nchars % 16) == 0)
	write( outf, "\n", 1 );

      sprintf( buff, "%02x ", (UBYTE)b );
d886 2
a887 8
      write( outf, buff, strlen( buff ) );
    }
  else
    {
      output_buffer[output_buffer_pointer++] = b;
      if(output_buffer_pointer == BUFFER_SIZE)
	flush_output_buffer();
    }
@


1.42
log
@Now supports -i option to disable the generation of std image header and
zero byte tail.
(used for ROM bootstrap).
@
text
@d6 2
d20 1
a20 1
/* RcsId: $Id: genimage.c,v 1.41 1993/08/16 08:17:12 nickc Exp paul $ */
d341 105
d582 1
a582 1

d584 1
a584 1

d588 1
a588 1

d594 1
a594 1

d598 1
a598 1

a601 72
	  else if (s->module != curmod)
	    {
	      WORD	size;
	      VMRef 	mod;
	      VMRef	our_mod = s->module;
	      
	      
	      mod = module0;

	      while (!NullRef( mod ) &&
		     mod != our_mod  &&
		     mod != curmod    )
		mod = VMAddr( asm_Module, mod )->next;
	      
	      if (NullRef( mod ))
		{
		  s = VMAddr( Symbol, value.v );
		  
		  warn( "CODESTUB: could not find module containing symbol '%s'!", s->name );
		  
		  return 0;
		}
	      
	      size = 0;

	      if (mod == curmod)
		{
		  /* search for forwards reference */

		  while (!NullRef( mod ) &&
			 mod != our_mod   )
		    {
		      size += VMAddr( asm_Module, mod )->length;

		      mod = VMAddr( asm_Module, mod )->next;
		    }

		  s = VMAddr( Symbol, value.v );

		  if (NullRef( mod ))
		    {
		      warn( "CODESTUB: unable to locate module containing symbol '%s'", s->name );

		      return 0;
		    }

		  r = VMAddr( Code, s->value.v )->loc + size;
		}
	      else
		{
		  /* search for backwards reference */

		  while (!NullRef( mod ) &&
			 mod != curmod    )
		    {
		      size += VMAddr( asm_Module, mod )->length;

		      mod = VMAddr( asm_Module, mod )->next;
		    }

		  s = VMAddr( Symbol, value.v );

		  if (NullRef( mod ))
		    {
		      warn( "CODESTUB: unable to locate module refering to symbol '%s'", s->name );

		      return 0;
		    }

		  r = VMAddr( Code, s->value.v )->loc - size;
		}
	    }
d604 1
a604 1
	      r = VMAddr( Code, s->value.v )->loc;
d606 1
a606 1
	  	  
d629 1
a629 76
	  if (s->module != curmod)
	    {
	      WORD	size;
	      VMRef 	mod;
	      VMRef	our_mod = s->module;
	      

	      mod = module0;

	      while (!NullRef( mod ) &&
		     mod != our_mod  &&
		     mod != curmod    )
		mod = VMAddr( asm_Module, mod )->next;

	      if (NullRef( mod ))
		{
		  s = VMAddr( Symbol, value.v );
		  
		  warn( "LABELREF: could not find module containing symbol '%s'", s->name );		  

		  return 0;
		}

	      size = 0;

	      if (mod == curmod)
		{
		  /* search for forwards reference */

		  while (!NullRef( mod ) &&
			 mod != our_mod   )
		    {
		      size += VMAddr( asm_Module, mod )->length;

		      mod = VMAddr( asm_Module, mod )->next;		      
		    }

		  s = VMAddr( Symbol, value.v );
		  		  
		  if (NullRef( mod ))
		    {
		      warn( "LABELREF: unable to locate module containing symbol '%s'", s->name );

		      return 0;
		    }

		  r = VMAddr( Code, s->value.v )->loc + size;
		}
	      else
		{
		  /* search for backwards reference */

		  while (!NullRef( mod ) &&
			 mod != curmod)
		    {
		      size += VMAddr( asm_Module, mod )->length;

		      mod = VMAddr( asm_Module, mod )->next;		      
		    }

		  s = VMAddr( Symbol, value.v );
		  		  
		  if (NullRef( mod ))
		    {
		      warn( "LABELREF: unable to locate module refering to symbol '%s'", s->name );

		      return 0;
		    }

		  r = VMAddr( Code, s->value.v )->loc - size;
		}
	    }
	  else
	    {
	      r = VMAddr( Code, s->value.v )->loc;	  
	    }	  
d675 92
d768 1
a768 1

d772 1
d774 1
a774 1

d777 3
d785 1
a785 1

@


1.41
log
@improved warning message
@
text
@d18 1
a18 1
/* RcsId: $Id: genimage.c,v 1.40 1993/08/06 14:56:28 nickc Exp nickc $ */
d147 3
a149 1
	     outword( 0L );
d157 1
a157 1
	  
d750 10
a759 10
  outword( Image_Magic );
  
  outword( 0L );
  
  outword( imagesize );
  
  nchars = 0;
  
  return;
  
@


1.40
log
@improved format slightly
@
text
@d18 1
a18 1
/* RcsId: $Id: genimage.c,v 1.39 1993/08/06 11:02:58 nickc Exp nickc $ */
d1130 1
d1154 1
@


1.39
log
@fixed buglet in SHORT patches
@
text
@d18 1
a18 1
/* RcsId: $Id: genimage.c,v 1.38 1993/08/06 10:58:48 nickc Exp nickc $ */
d245 1
a245 1
	  error( "Unknown tag %#x (@@%#X)", tag, codepos );
d278 2
a279 8
      if (!fits_in_16_bits_unsigned( value ))
	{
	  asm_Module * m;
	  m = VMAddr( asm_Module, curmod );
	  
	  warn( "Patch value %#x too large for short (%#x) (in module %s)",
	       value, codepos, m->file_name );
	}      
d670 1
a670 1
	  
d910 1
a910 1
#ifdef __C40
d967 1
a967 1
    error( "ARM specific patch used to patch a short or byte value (@@%#X)", codepos );
d1171 1
a1171 1
	error( "ARM data transfer patch value (%#x) too large (@@%#X)", value, codepos );
d1201 1
a1201 1
	    error( "ARM data processing patch value should not be negative (@@%#X)", codepos );
d1225 1
a1225 1
	      error( "Patch value of %#x is too large for ARM DP patch.(origval = %#x) data=%#x (@@%#X)",
d1228 1
a1228 1
	      warn( "Patch value of %#x is too large for ARM DP patch.(origval = %#x) data=%#x (@@%#X)",
d1359 1
a1359 1
	    error( "Patch value of %#x is too large for ARM DP residue patch (@@%#X)", value, codepos );
d1388 1
a1388 1
	error( "ARM jp patch should only be used with a label ref (@@%#X)", codepos );
d1394 1
a1394 1
      error( "Unknown machine dependent patch type in mcpatch: %#x (@@%#X)", type, codepos );
@


1.38
log
@slightly improved error message
@
text
@d18 1
a18 1
/* RcsId: $Id: genimage.c,v 1.37 1993/08/04 15:38:32 bart Exp nickc $ */
d27 1
d278 1
a278 1
      if (!fits_in_16_bits( value ))
@


1.37
log
@changed RcsId from a string to a comment
@
text
@d18 1
a18 1
/* RcsId: $Id: genimage.c,v 1.36 1993/03/24 16:08:12 nickc Exp $ */
d278 7
a284 1
         warn( "Patch value %#x too large for short (%#X)", value, codepos );
d298 1
a298 1
	warn( "Patch value %#x too large for byte (@@%#X)", value, codepos );
d365 1
a365 1
      error( "Unknown standard patch type in stdpatch: %#x (@@%#X)", vtype, codepos );
@


1.36
log
@fixed bug in OBJSHORT processing
@
text
@d18 1
a19 2
static char *	RcsId = "$Id: genimage.c,v 1.35 1993/03/22 10:44:10 nickc Exp nickc $";

a754 2
  use( RcsId );

@


1.35
log
@slightly improved minor warning message
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.34 1992/12/03 09:15:57 nickc Exp nickc $";
d27 2
a30 1
#define fits_in_16_bits( val )		(((val) & 0xffff8000U) == 0 || ((val) & 0xffff8000U) == 0xffff8000U)
d278 2
a279 2
      if (value < 0xffff8000U || value > 0x0000ffffU )
         warn( "Patch value %#x too large for short (@@%#X)", value, codepos );
@


1.34
log
@improved error message
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.33 1992/10/25 15:14:07 nickc Exp nickc $";
d1107 1
a1107 1

d1113 2
a1114 1
	      warn( "calculated offset (%x) too big to fit in 24 bit instruction field (%x)!", value, p->word );
d1129 2
a1130 1
	      warn( "calculated offset (%x) too big to fit in 16 bit instruction field (%x)!", value, p->word );
a1138 1
	  asm_Module *	m;
d1147 3
d1152 1
a1152 1
	      warn( "calculated offset (%x) too big to fit in 8 bits, op code in module %s!",
@


1.33
log
@fixed error message to include module name
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.32 1992/10/02 08:20:43 nickc Exp nickc $";
d446 10
a455 2
		      warn( "Function \"%s\" is called in '%s', but defined in '%s' as something else",
			   name + 1, m->file_name, s->file_name );
@


1.32
log
@updated to work with OBJADDRSTUB requests
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.31 1992/09/21 16:51:24 martyn Exp nickc $";
d1128 3
a1130 2
	  word	mask = 0x000000FFU;

d1138 4
a1141 1
	      warn( "calculated offset (%x) too big to fit in 8 bit instruction field (%x)!", value, p->word );
@


1.31
log
@added code to buffer image file writes to 4K.
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.30 1992/09/15 08:38:57 nickc Exp $";
d21 2
a22 1
#include <module.h>  
d372 2
a373 1
    case OBJCODESTUB:      
a381 1
	      char	name[ 128 ];		/* XXX */
d386 1
a386 3
	      /* catch unlikely case of a CODESTUB for something other than .<name> */
	      
	      if (*s->name != '.')
d388 8
a395 2
		  warn( "Function \"%s\" used in module '%s', but not defined",
		       s->name + 1, m->file_name );
d397 3
a399 3
		  /* prevent future warnings */
		  
		  s->type = S_CODESYMB;
d401 2
a402 2
		  return 0;
		}
d404 1
a404 1
	      /* duplicate name */
d406 1
a406 1
	      strcpy( name, s->name );
d408 1
a408 1
	      /* change first character */
d410 1
a410 1
	      name[ 0 ] = '_';
d412 1
a412 1
	      /* find the associated shared library symbol */
d414 1
a414 1
	      ref = lookup( name );
d416 8
a423 6
	      if (ref == NullVMRef)
		{
		  warn( "Function \"%s\" is called from module '%s', but it is not defined",
		       name + 1, m->file_name );

		  /* prevent future warnings */
d425 2
a426 1
		  s->type = S_CODESYMB;
d428 1
a428 2
		  return 0;		  
		}
d430 1
a430 1
	      s = VMAddr( Symbol, ref );
d432 6
a437 6
	      if (s->type == S_UNBOUND)
		{
		  warn( "Function \"%s\" is called in '%s', but it is not defined",
		       name + 1, m->file_name );

		  /* prevent futher warnings */
d439 1
a439 1
		  s->type = S_FUNCDONE;
d441 2
a442 2
		  return 0;		  
		}
d444 4
a447 4
	      if (s->type != S_FUNCDONE)
		{
		  warn( "Function \"%s\" is called in '%s', but defined in '%s' as something else",
		       name + 1, m->file_name, s->file_name );
d449 1
a449 1
		  /* prevent futher warnings */
d451 1
a451 1
		  s->type = S_FUNCDONE;
d453 4
a456 1
		  return 0;		  
d458 6
a463 2
	
	      s->referenced = 1;
d465 1
a465 3
	      /* request a new stub */
	      
	      r = new_stub( ref );
d481 2
a482 2
		  mod = module->next;		  
		}	      
d490 1
a490 1

d497 1
a497 1

d501 1
a501 1

d503 1
a503 1

d506 1
a506 1

d518 1
a518 1
		      mod = VMAddr( asm_Module, mod )->next;		      
d541 1
a541 1
		      mod = VMAddr( asm_Module, mod )->next;		      
d851 13
a863 2
	int size = 0;
	int size1;
d865 1
a865 9
	while(size != output_buffer_pointer)
	  {
	  size1 = write(outf, output_buffer + size,
	        output_buffer_pointer - size);
	  if(size1 < 0)
		error( "image file write error");
	  size += size1;
	  }
	output_buffer_pointer = 0;
@


1.30
log
@changed output file descriptor to file handle
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.29 1992/07/15 07:38:51 nickc Exp nickc $";
d46 1
d57 1
d75 1
d77 3
d147 2
d250 2
d821 3
a823 1
      write( outf, &b, 1 );
d832 20
@


1.29
log
@improved error messages
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.28 1992/07/13 08:50:20 nickc Exp nickc $";
d799 3
d803 5
a807 3
	putc( '\n', outfd );
      
      fprintf( outfd, "%02x ", (UBYTE)b );
d811 1
a811 1
      putc( b, outfd );
@


1.28
log
@added support for new patch (CODESTUB)
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.27 1992/07/06 17:15:29 nickc Exp nickc $";
d466 2
a467 1

d471 2
a472 2
	      while (!NullRef( mod )  &&
		     mod != s->module &&
d478 1
a478 1
		  warn( "CODESTUB: failed to find either module!" );
d480 2
d492 1
a492 1
			 mod != s->module)
d499 2
d503 1
a503 1
		      warn( "CODESTUB: unable to locate forward module reference" );
d515 1
a515 1
			 mod != curmod)
d522 2
d526 1
a526 1
		      warn( "CODESTUB: unable to locate backward module reference" );
d565 2
a566 1

d570 2
a571 2
	      while (!NullRef( mod )  &&
		     mod != s->module &&
d577 3
a579 1
		  warn( "LABELREF: failed to find either module!" );
d591 1
a591 1
			 mod != s->module)
d598 2
d602 1
a602 1
		      warn( "LABELREF: unable to locate forward module reference" );
d621 2
d625 1
a625 1
		      warn( "LABELREF: unable to locate backward module reference" );
@


1.27
log
@fixed amazing bug in PATCHC40DATAMODULE2
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.26 1992/06/23 10:25:47 nickc Exp nickc $";
d21 1
a21 1
  
a40 1
static void 	outword( WORD );
a50 1
static void 	outword();
d66 2
a67 1
static word 	nchars;
d85 1
a85 1
  Module *	m;
d90 1
a90 1
  m        = VMAddr( Module, curmod );
d108 1
a108 1
      trace( "image op %#x", tag );
d133 1
a133 1
         m = VMAddr( Module, curmod );
d144 1
a144 1
	  m = VMAddr( Module, curmod );
d337 1
a337 1
  Module *	m;
d343 1
a343 1
  m = VMAddr( Module, curmod );
d360 178
d554 69
a622 1
	  r = VMAddr( Code, s->value.v )->loc;
d675 1
a675 1
      m = VMAddr( Module, s->module );
d703 1
a703 1
  outword( 0x12345678U );
d725 1
a725 1
PRIVATE void
@


1.26
log
@ahem - fixed bug introduced by previous delta - sorry
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.25 1992/06/22 13:54:38 nickc Exp nickc $";
d732 1
a732 1
	      return 0x026d0000U + (value & 0xff);		/* ADDI offset, AR5 */
@


1.25
log
@improved warning messages
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.24 1992/06/15 12:03:12 paul Exp nickc $";
d69 1
d72 1
d430 2
d634 1
d636 1
d640 2
a641 2
  static int	saved_modnum = 0;
  static int	saved_offset = 0;
d787 1
a787 1
	  int	mask = 0x00FFFFFFU;
d802 1
a802 1
	  int	mask = 0x0000FFFFU;
d817 1
a817 1
	  int	mask = 0x000000FFU;
@


1.24
log
@fixed to use std __proc names
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.23 1992/06/15 12:01:14 paul Exp paul $";
d342 2
a351 2
      m = VMAddr( Module, curmod );
      
a354 2
      m = VMAddr( Module, curmod );
      
d368 1
a368 1
	      warn( "Label \"%s\" not defined: assuming offset 0 (@@%#X)", s->name, codepos );
d389 1
a389 1
	  warn( "Data Symbol \"%s\" not defined: assuming offset 0", s->name + 1 );
d405 1
a405 1
	  warn( "Function Symbol \"%s\" not defined: assuming offset 0", s->name + 1 );
d421 1
a421 1
	  warn( "Symbol \"%s\" not defined: assuming module 0", s->name + 1 );
a426 2

      m = VMAddr( Module, s->module );
@


1.23
log
@fixed for std __proc names
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.22 1992/06/09 09:08:06 nickc Exp paul $";
d643 1
a643 1
#ifdef __HELIOSARM
d648 1
a648 1
#endif /* __HELIOSARM */
d832 1
a832 1
#ifdef __HELIOSARM
d1063 1
a1063 1
#endif /* __HELIOSARM */
@


1.22
log
@improved error output
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.21 1992/03/30 13:35:48 nickc Exp $";
d26 1
a26 1
#ifdef __HELIOSC40
d592 1
a592 1
#ifdef __HELIOSC40
d616 1
a616 1
#endif /* __HELIOSC40 */
d637 1
a637 1
#ifdef __HELIOSC40
d674 1
a674 1
#ifdef __HELIOSC40
d830 1
a830 1
#endif /* __HELIOSC40 */
@


1.21
log
@added fixes to reduce number of warning messages
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.15 1992/02/20 17:51:08 nickc Exp nickc $";
d391 1
a391 1
	  warn( "Data Symbol \"%s\" not defined: assuming offset 0 (@@%#X)", s->name, codepos );
d407 1
a407 1
	  warn( "Function Symbol \"%s\" not defined: assuming offset 0 (@@%#X)", s->name, codepos );
d423 1
a423 1
	  warn( "Symbol \"%s\" not defined: assuming module 0 (@@%#X)", s->name, codepos );
@


1.20
log
@fix patchc40datamodule3 to generate ldi *ar5, ar5 correctly
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.19 1992/02/05 11:57:19 paul Exp $";
d372 2
d380 1
d392 2
d409 2
d425 2
d728 2
a729 1
              saved_offset = -1;				/* trigger LDI *AR5, AR5 */
d817 2
d820 1
a820 1
	  value += mask_and_sign_extend_word( p->word, mask );
d822 1
a822 1
	  if (value < -128 || value > 255)  /* signed test == !fits_in_8_bits( value )) */
@


1.19
log
@labelrefs reverted to giving byte offsets for C40
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.18 1992/01/13 09:40:20 paul Exp $";
d719 1
@


1.18
log
@just made genimage's use of __C40 consistent with other files (__HELIOSC40)
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.17 1992/01/13 09:37:18 paul Exp paul $";
a376 4
#ifdef __HELIOSC40
	  trace( "Stdpatch: returning label offset of %s = %d", s->name, (r - codepos)/4 );
	  return (r - codepos)/4;
#else
a378 1
#endif
@


1.17
log
@laberefs return word offset, PATCHC40ADD8MASK is now unsigned
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.16 1991/12/16 17:34:13 nickc Exp paul $";
d377 1
a377 1
#ifdef __C40
@


1.16
log
@improved warning messages
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.12 1991/12/12 10:58:07 nickc Exp nickc $";
d377 4
a381 1
	  
d383 1
d814 1
a814 1
	  if (!fits_in_8_bits( value ))
@


1.15
log
@fixed the mask and add patches to perform a signed check on their result
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.11 1991/12/12 09:00:07 nickc Exp nickc $";
d782 1
a782 1
	      warn( "calculated offset (%x) too big to fit in instruction (%x)!", value, p->word );
d797 1
a797 1
	      warn( "calculated offset (%x) too big to fit in instruction (%x)!", value, p->word );
d812 1
a812 1
	      warn( "calculated offset (%x) too big to fit in instruction (%x)!", value, p->word );
@


1.14
log
@added PATCHC40MASK8ADD c40 patch
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.13 1991/12/12 09:01:30 nickc Exp paul $";
d29 1
d780 1
a780 1
	  if (value & (~mask) != (~mask))
d795 1
a795 1
	  if (value & (~mask) != (~mask))
d801 2
a802 2
	}

d810 1
a810 1
	  if (value & (~mask) != (~mask))
d817 1
a817 1

@


1.13
log
@fixed DATAMODULE to always return bytes not words
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.11 1991/12/12 09:00:07 nickc Exp $";
d769 1
a769 1
       * special addition routines that take a mask aswell
d800 15
d816 1
a816 1
      
@


1.12
log
@fixed shift to perform arithmetic shifts
fixed C40 mask and add patches to prevent unnecessary complaints about negative numbers
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.9 1991/12/04 16:31:30 nickc Exp nickc $";
a422 10
#ifdef __HELIOSC40
      if (smtopt)
	{
	  return (m->id * 2 + (s->type == S_FUNCDONE ? 1 : 0));
	}
      else
	{
	  return (m->id);
	}
#else
a426 1
#endif
@


1.11
log
@changed DATASYMB patch to return BYTE offset not WORD offset
(I hope that this does not break too many things)
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.8 1991/11/01 15:40:47 nickc Exp nickc $";
d64 3
d660 1
a660 1
	  return ((unsigned long) value) >> (- p->word);
d790 1
a790 1
	  if (value & (~mask))
d805 1
a805 1
	  if (value & (~mask))
@


1.10
log
@oops, forget to change over OBJIMAGESIZE to OBJMODSIZE
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.9 1991/11/22 16:05:14 nickc Exp nickc $";
d381 1
a381 1
      trace( "Stdpatch: dataref of symb vmadd %#x", value.v );
a389 3
#ifdef __HELIOSC40
      return s->value.w / sizeof (int);
#else
a390 1
#endif
d395 1
a395 1
      trace( "Stdpatch: funcref of symb vmadd %#x", value.v );
d409 1
a409 1
      trace( "Stdpatch: datamod of symb vmadd %#x", value.v );
@


1.9
log
@changed LDA into LDI, as LDA does NOT WORK
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.8 1991/11/01 15:40:47 nickc Exp nickc $";
d345 1
a345 7
      /*
       * this is a bodge - IMAGESIZE is not really what is needed for single module
       * resident libraries - what is meant is .modend - .modstart as in the
       * ASM version. As a temporary fudge, this is implemented here
       */  
      
    case OBJIMAGESIZE:
@


1.8
log
@changed name of IMAGESIZE directive to MODSIZE (as thats what it is!)
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.7 1991/10/29 13:27:43 nickc Exp paul $";
d345 7
a351 1
    case OBJMODSIZE:	/* as in .modend - .modstart */
d379 1
a379 1
	  trace( "Stdpatch: returning label offset of %s = %d", s->name, r );
d696 5
a700 5
       *  LDA *+AR4( modnum ), AR5    LDA  *+AR4( modnum ), AR5    LDA  AR4, AR5                LDA  AR4, AR5
       *  LDA *+AR5( offset ), AR5    ADDI offset, AR5             ADDI modnum, AR5             ADDI modnum, AR5
       *  Bu  AR5                     LDA  *AR5, AR5               LDA  *AR5, AR5               LDA  *AR5, AR5
       *  -                           Bu   AR5                     LDA  *+AR5( offset ), AR5    ADDI offset, AR5
       *  -                           -                            Bu   AR5                     LDA  *AR5, AR5
d709 1
a709 1
	  return 0x1ecd0400L + (value & 0xff);			/* LDA *+AR4( modnum ), AR5 */
d719 1
a719 1
	  return 0x1e8d000cL;					/* LDA AR4, AR5 */
d729 1
a729 1
	      return 0x1ecd0500L + (value & 0xff);		/* LDA *+AR5( offset ), AR5 */
d737 1
a737 1
	      return 0x026d0000L + (value & 0xff);		/* ADDI offset, AR5 */
d744 1
a744 1
	  return 0x026d0000L + saved_modnum;			/* ADDI modnum, AR5 */
d750 1
a750 1
	  return 0x6800000dL;					/* Bu Ar5 */
d754 1
a754 1
	  return 0x1ecdc500L;					/* LDA *AR5, AR5 */
d760 1
a760 1
	  return 0x6800000dL;					/* Bu AR5 */
d768 1
a768 1
	      return 0x1ecd0500 + (saved_offset & 0xff);	/* LDA *+AR5( offset ), AR5 */
d772 1
a772 1
	      return 0x026d0000 + (saved_offset & 0xffff);	/* ADDI offset, AR5 */
d779 1
a779 1
	  return 0x6800000dL;					/* Bu Ar5 */
d783 1
a783 1
	  return 0x1ecdc500L;					/* LDA *AR5, AR5 */
d792 1
a792 1
	  int	mask = 0x00FFFFFFL;
d807 1
a807 1
	  int	mask = 0x0000FFFFL;
@


1.7
log
@changed LDI to LDA
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.6 1991/10/29 13:23:06 nickc Exp $";
d345 1
a345 7
      /*
       * this is a bodge - IMAGESIZE is not really what is needed for single module
       * resident libraries - what is meant is .modend - .modstart as in the
       * ASM version. As a temporary fudge, this is implemented here
       */  
      
    case OBJIMAGESIZE:
@


1.6
log
@merged in NC patches
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.5 1991/10/21 15:48:30 nickc Exp $";
d696 5
a700 5
       *  LDI *+AR4( modnum ), AR5    LDI  *+AR4( modnum ), AR5    LDI  AR4, AR5                LDI  AR4, AR5
       *  LDI *+AR5( offset ), AR5    ADDI offset, AR5             ADDI modnum, AR5             ADDI modnum, AR5
       *  Bu  AR5                     LDI  *AR5, AR5               LDI  *AR5, AR5               LDI  *AR5, AR5
       *  -                           Bu   AR5                     LDI  *+AR5( offset ), AR5    ADDI offset, AR5
       *  -                           -                            Bu   AR5                     LDI  *AR5, AR5
d709 1
a709 1
	  return 0x084d0400L + (value & 0xff);			/* LDI *+AR4( modnum ), AR5 */
d719 1
a719 1
	  return 0x080d000cL;					/* LDI AR4, AR5 */
d729 1
a729 1
	      return 0x084d0500L + (value & 0xff);		/* LDI *+AR5( offset ), AR5 */
d754 1
a754 1
	  return 0x084dc500L;					/* LDI *AR5, AR5 */
d760 1
a760 1
	  return 0x6800000dL;					/* Bu Ar5 */
d768 1
a768 1
	      return 0x084d0500 + (saved_offset & 0xff);	/* LDI *+AR5( offset ), AR5 */
d783 1
a783 1
	  return 0x084dc500L;					/* LDI *AR5, AR5 */
@


1.5
log
@updated bytesex_odd flag to __BIGENDIAN which should automatically be defined
by the compiler if the target architecture is bigendian
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.4 1991/10/09 10:53:36 paul Exp $";
d27 2
a28 4
#define fits_in_8_bits( val )		(((val) & (unsigned long) 0xffffff80L) == 0 || \
					 ((val) & (unsigned long) 0xffffff80L) == (unsigned long) 0xffffff80L)
#define fits_in_16_bits( val )		(((val) & (unsigned long) 0xffff8000L) == 0 || \
					 ((val) & (unsigned long) 0xffff8000L) == (unsigned long) 0xffff8000L)
a29 1
  
d31 1
d261 1
a261 1
      if (value < (long)0xffff8000 || value > (long)0xffff )
d401 1
a401 1

d467 1
a467 1
  outword( 0x12345678L );
d499 1
d501 2
a502 1
  for (i = 24 ; i >= 0 ; i-= 8)
d504 1
d506 1
d509 1
d577 4
a580 4
  return ((x >> 24) &                0x000000ffL) |
         ((x >>  8) &                0x0000ff00L) |
         ((x <<  8) &                0x00ff0000L) |
	 ((x << 24) & (unsigned long)0xff000000L) ;
d624 1
d645 1
a645 1
  word		value = patchit( p->type, p->value.fill, size );
d654 2
a655 2
			 type == PATCHARMDP ||
			 type == PATCHARMJP ) )
d667 1
a667 1
	  return ((unsigned long) value) >> (-p->word);
d827 1
a827 1
      data = p->word & 0xfffff000;
d897 1
a897 1
	  return (value | (p->word & (unsigned long) 0xfffff000));
d923 1
d925 1
d927 1
d939 1
a939 1
	      word	instr = (p->word & 0xfffff000);
d942 1
a942 1
	      if ((instr & 0x01e00000) == 0x00800000)
d944 2
a945 2
		  instr &= ~0x01e00000;	/* convert to a sub instruct */
		  instr |= 0x00400000;
d956 1
a956 1
	      return (value | (p->word & 0xfffff000));
d973 1
a973 1
	      word	instr = (p->word & 0xfffff000);
d976 1
a976 1
	      if ((instr & 0x01e00000) == 0x00800000)
d978 3
a980 3
		  instr &= ~0x01e00000;	/* convert to a sub instruct */
		  instr |= 0x00400000;
		}	
d990 1
a990 1
	      return (value | (p->word & 0xfffff000));
d1027 1
a1027 1
	      word	instr = (p->word & 0xfffff000);
d1030 1
a1030 1
	      if ((instr & 0x01e00000) == 0x00800000)
d1032 2
a1033 2
		  instr &= ~0x01e00000;	/* convert to a sub instruct */
		  instr |= 0x00400000;
d1044 1
a1044 1
	      return (value | (p->word & 0xfffff000));
d1052 1
a1052 1
      return (p->word & 0xff000000) | (((value - 8) >> 2) & 0x00ffffff);
@


1.4
log
@Fixed to work with the ARM again after NickC's C40 changes
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.3 1991/10/09 08:47:51 paul Exp paul $";
d266 1
a266 1
#ifdef BYTESEX_ODD
d501 1
a501 3

#ifdef BYTESEX_ODD /* 68k etc */
  
a503 1
  
a504 1
  
a506 1
  
@


1.3
log
@NickC's changes for the 'C40 + some bug fixes
@
text
@d19 1
a19 1
static char *	RcsId = "$Id: genimage.c,v 1.4 1991/10/08 13:00:51 nickc Exp $";
d403 1
a403 1
      
d449 1
a449 1
  return;
d603 1
d626 1
d646 1
a646 1
  long		value = patchit( p->type, p->value.fill, size );
d654 1
a654 1
  if (size != t_word && (type == PATCHARMDT ||
d824 1
a824 1
    case PATCHARMLDR:			/* ARM data transfer instr. patch */
d850 1
a850 1
    case PATCHARMADD:			/* ARM data processing instr. patch */
d901 1
a901 1
    case PATCHARMADDLO:			/* ARM data processing instr. patch least sig byte */
a921 1
	      word	rot;
a924 3
#if 0
	      imm = (p->word & 0xff); 	/* 8 bit immediate */
#else
a925 13
#endif
#if 0
	      /* get rotate from instr and fix immediate value with it */

	      if ((rot = (p->word & 0xf00)) != 0)
		{
		  rot >>= 8;

		  /* Jamie's snazzy rotate equivalent code */

		  imm = ((imm >> (rot * 2)) | (imm << (32 - (rot * 2))));
		}
#endif
d937 1
a937 1
	      int	instr = (p->word & 0xfffff000);
d958 1
a958 1
    case PATCHARMADDMID:		/* ARM data processing instr. patch second least sig byte */
d971 1
a971 1
	      int	instr = (p->word & 0xfffff000);
d992 1
a992 1
    case PATCHARMADDHI:			/* ARM data processing instr. patch - rest of last lsb patch */
d1025 1
a1025 1
	      int	instr = (p->word & 0xfffff000);
d1046 1
a1046 1
    case PATCHARMBL:			/* ARM branch instr. patch */
@


1.2
log
@Fixed imagesize bug
@
text
@d14 2
a17 1
static char *RcsId = "$Id: genimage.c,v 1.1 1990/10/22 15:46:36 paul Exp $ Copyright (C) Perihelion Software Ltd.";
d19 3
d24 1
a24 1
#define trace if(traceflags&db_genimage) _trace
d26 7
d38 21
a58 21
word patchit(word vtype, long value, word size);
void putpatch(Code *c);
word mcpatch(word type, VMRef v, word size);
word stdpatch(word type,long value);
static void outword(WORD);
static void outbyte(UBYTE);
static void outbyte1(WORD);
static void imageheader(WORD);
long swapw(long x);
unsigned swaps(unsigned x);
#else
word patchit();
void putpatch();
word mcpatch();
word stdpatch();
static void outword();
static void outbyte();
static void outbyte1();
static void imageheader();
long swapw();
unsigned swaps();
d65 4
a68 4
word codepos;
static word nchars;
static word restofdppatch; /* rest of value to be pathed by armdprest */
static word patchNeg;	  /* if patch value need a sub rather than an add instr. */
d74 6
a79 1
void genimage()
d81 10
a90 10
/*   word datapos;*/
   Code *c;
   Module *m;
      
   VMRef curblock;

   curmod = module0;
   m = VMAddr(Module,curmod);
   curblock = m->start;
   VMlock(curblock);
d92 3
a94 2
   c = VMAddr(Code,curblock);
   VMDirty(curblock);
d96 1
a96 2
/*   datapos = 0;*/
   codepos = 0;
d98 1
a98 1
   imageheader(totalcodesize+4);
d100 4
a103 3
   for(;;)
   {
      word tag = c->type;
d105 1
a105 1
      trace("image op %#x",tag);
d107 17
a123 12
      switch( tag )
      {
         
      /* go to new code page            */
      case t_newseg:
         trace("NEWSEG %#x",c->value.v);
         VMunlock(curblock);
         curblock = c->value.v;
         VMlock(curblock);
         c = VMAddr(Code,curblock);
         VMDirty(curblock);
         continue;
d125 7
a131 4
      /* start new module            */
      case t_end:
         VMunlock(curblock);
         m = VMAddr(Module,curmod);
d133 42
a174 27
         if( NullRef(curmod) )
         {  outword(0L);
            return;
         }
         m = VMAddr(Module,curmod);
         curblock = m->start;
         VMlock(curblock);
         c = VMAddr(Code,curblock);
         VMDirty(curblock);
/*         datapos = 0;*/
         codepos = 0;
         continue;

      case t_module:
      case t_data:
      case t_common:
      case t_func:
         break;
      
      case t_code:
      {
         int i, size = c->size;
         UBYTE *v = VMAddr(UBYTE,c->value.v);
         for( i = 0; i < size ; outbyte(v[i++]) );
         codepos += size;
         break;
      }
d176 37
a212 23
      case t_bss:
      {
         int i, size = c->size;
         for( i = 0; i < size ; outbyte(0) );
         codepos += size;
         break;
      }
      
      case t_literal:
      {
         int i, size = c->size;
         UBYTE *v = (UBYTE *)&c->value.w;
         for( i = 0; i < size ; outbyte(v[i++]) );
         codepos += size;
         break;
      }

      case t_word:
      case t_short:
      case t_byte:
         putpatch(c);
         codepos += tag & 0x07;
         break;
d214 16
a229 9
      case t_init:
         if( NullRef(c->value.v) ) outword(0L);
         else 
         {
            word next = VMAddr(Code,c->value.v)->loc;
            outword((WORD)(next-c->loc));
         }
         codepos += 4;
         break;
d231 4
a234 4
      default:
         error("Unknown tag %#x (@@%#X)",tag,codepos);
         break;
      }
d237 6
a242 2
   }
}
d244 7
a250 2
void putpatch(c)
Code *c;
d252 1
a252 1
   word value = patchit(c->vtype, c->value.fill, c->type);
d254 6
a259 5
   trace( "Final patch value = %#x", value);
   switch( c->type )
   {
   case t_word:
      outword(value);
d262 4
a265 3
   case t_short:
      if( value < (long)0xffff8000 || value > (long)0xffff )
         warn("Patch value %#x too large for short (@@%#X)",value,codepos);
d267 2
a268 2
      outbyte1(value>>8);
      outbyte1(value);
d270 2
a271 2
      outbyte1(value);
      outbyte1(value>>8);
d273 1
d276 10
a285 4
   case t_byte:
      if( value < -128 || value > 255 )
         warn("Patch value %#x too large for byte (@@%#X)",value,codepos);
      outbyte1(value);
d288 4
a291 1
}
d293 13
a305 4
word patchit(vtype, value, size)
word vtype;  /* patch type */
long value; /* ptr to another patch, or patch symbol */
word size;   /* patch size */
d307 1
a307 1
   if( t_patch <= vtype && vtype <= t_maxpatch )
d309 6
a314 4
	Value val;
	
	val.fill = value;
      return(mcpatch(vtype, val.v, size));
d317 3
a319 2
   return(stdpatch(vtype, value));
}
d321 11
a331 3
word stdpatch(vtype, xvalue)
word vtype;
long xvalue;
d333 3
a335 3
   Value value;
   Module *m;
   Symbol *s;
a336 1
   value.fill = xvalue;
d338 7
a344 4
   switch( vtype )
   {
   default:
      error("Unknown standard patch type in stdpatch: %#x (@@%#X)",vtype,codepos);
d347 9
a355 6
/* this is a bodge - IMAGESIZE is not really what is needed for single module
   resident libraries - what is meant is .modend - .modstart as in the
   ASM version. As a temporary fudge, this is implemented here */  
 
   case t_imagesize:
      m = VMAddr(Module,curmod);
d357 5
a361 4
#ifdef NEVER
      trace("Stdpatch: returning total image size %d",totalcodesize);
      return totalcodesize;
#endif
a362 3
   case t_modnum:
      m = VMAddr(Module,curmod);
      trace("Stdpatch: returning module %08x, number %d",curmod, m->id);
d365 36
a400 18
   case t_labelref:
      {  word r;
         s = VMAddr(Symbol, value.v);
         if( s->type != s_codesymb )
         {  warn("Label \"%s\" not defined: assuming offset 0 (@@%#X)",s->name,codepos);
            return 0;
         }
         r = VMAddr(Code,s->value.v)->loc;
         trace("Stdpatch: returning label offset of %s = %d",s->name, r);
         return r - codepos;
      }
   case t_dataref:
      s = VMAddr(Symbol,value.v);
      trace("Stdpatch: dataref of symb vmadd %#x", value.v);
      if( s->type != s_datadone )
      {  warn("Data Symbol \"%s\" not defined: assuming offset 0 (@@%#X)",s->name,codepos);
         return 0;
      }
d402 4
d407 9
a415 7
   case t_funcref:
      s = VMAddr(Symbol,value.v);
      trace("Stdpatch: funcref of symb vmadd %#x", value.v);
      if( s->type != s_funcdone )
      {  warn("Function Symbol \"%s\" not defined: assuming offset 0 (@@%#X)",s->name,codepos);
         return 0;
      }
d418 24
a441 8
   case t_datamod:
      s = VMAddr(Symbol,value.v);
      trace("Stdpatch: datamod of symb vmadd %#x", value.v);
      if( s->type != s_datadone && s->type != s_funcdone)
      {  warn("Symbol \"%s\" not defined: assuming module 0 (@@%#X)",s->name,codepos);
         return 0;
      }
      m = VMAddr(Module,s->module);
d443 1
a443 1
	      return (m->id * 8 + (s->type == s_funcdone? 4 : 0));
d445 8
a452 3
	      return (m->id*4);
   }
}
d461 7
a467 2
PRIVATE void imageheader(imagesize)
WORD imagesize;
d469 14
a482 6
        outword(0x12345678L);
        outword(0L);
        outword(imagesize);
        nchars = 0;
	use(RcsId);
}
d491 7
a497 2
PRIVATE void outword(val)
WORD val;
d499 3
a501 1
        int i;
d503 4
a506 1
	for( i = 24 ; i >= 0 ; i-=8 ) outbyte((UBYTE)(val>>i));
d508 4
a511 1
        for( i = 0 ; i < 32 ; i+=8 ) outbyte((UBYTE)(val>>i));
a512 1
}
d514 5
d526 51
a576 2
PRIVATE void outbyte1(b)
WORD b;
d578 10
a587 2
   outbyte((UBYTE)b);
}
d589 1
d591 1
a591 1
PRIVATE void outbyte(UBYTE b)
d593 2
a594 2
PRIVATE void outbyte(b)
UBYTE b;
a596 10
        if( hexopt )
        {
                if( (nchars % 16) == 0 ) putc('\n',outfd);
                fprintf(outfd,"%02x ",(UBYTE)b);
        }
        else {
                putc(b,outfd);
        }
        nchars++;
}
d598 27
d626 1
d628 127
a754 12
word mcpatch(type, v, size)
word type;
VMRef v;
word size;
{
   long	value;
   long data;
   Patch *p = VMAddr(Patch,v);

   if  (size != t_word && ( type == t_patch_armdt || type == t_patch_armdp
                            || type == t_patch_armjp ) )
       error("ARM specific patch used to patch a short or byte value (@@%#X)",codepos);
d756 18
a773 4
   switch (type)
   {
   case t_patch_m68kadd:
      return p->word + patchit(p->type, p->value.fill, size);
d775 5
a779 3
   case t_patch_m68kshift:
      if ( p->word < 0)
         return patchit(p->type, p->value.fill, size) >> (-p->word);
d781 44
a824 1
         return patchit(p->type, p->value.fill, size) << p->word;
d826 1
a826 2
   case t_patch_armdt:		/* ARM data transfer instr. patch */
	   value = patchit(p->type, p->value.fill, size);
d828 2
a829 1
	   value += (p->word & 0xfff); /* patch value includes existing immediate offset */
d831 2
a832 1
	   data = p->word & 0xfffff000;
d834 1
a834 2
   	   if (p->type == t_labelref)
   	   	value -= 8;	/* adjust pc rel labelref for ARM pipelining */
d836 9
a844 2
   	   if (value < -2048 || value > 4096 )
               error("ARM data transfer patch value (%#x) too large (@@%#X)",value,codepos);
d846 1
a846 8
	   /* set direction bit (23) in ARM instruction - 1 = up 0 = down */
   	   if (value < 0)
   	   	{
   	   	value = -value;		/* offsets are unsigned */
	   	data &= ~(1 << 23);	/* down = backwards jump = bit 23=0 */
   	   	}
	   else
   	   	data |= 1 << 23;
d848 4
a851 2
           return(data | value);
	   /*break;*/
a852 4
   case t_patch_armdp:		/* ARM data processing instr. patch */
   {
   	word ror = 0, savval;
	value = patchit(p->type, p->value.fill, size);
d854 1
a854 1
	value += (p->word & 0xff); /* add existing contents to patch value */
d856 2
a857 2
	if (p->type == t_labelref)
		value -= 8;	/* adjust pc rel labelref for ARM pipelining */
d859 1
a859 1
	savval = value;
d861 2
a862 2
	if (value < 0)
		error("ARM data processing patch value should not be negative (@@%#X)",codepos);
d864 5
a868 4
	if (value > 255)
	{
		ror = 0x10;
		while(!(value & 3)) /* word aligned immediate data? */
d870 7
a876 5
			/* see ARM assembly lang prg. pg 40 */
			/* ARM data man pg 21/25 */
			value >>= 2;	/* shift immediate value left by  two */
			if (--ror <= 4) /* and alter rotate by factor of two */
				break;  /* ARM immediate rotates are multiplied by 2 */
d878 7
a884 3
		if (ror == 0x10) ror = 0; /* if no rotates used */
	}
   	if (value > 255 )
d886 2
a887 1
		error("Patch value of %#x is too large for ARM DP patch.(origval = %#x) data=%#x (@@%#X)",value,savval,p->word, codepos);
d889 2
a890 1
		warn("Patch value of %#x is too large for ARM DP patch.(origval = %#x) data=%#x (@@%#X)",value,savval,p->word, codepos);
d892 3
a894 4
	value |= ror << 8; /* 4 bits of ror preceed 8 bit immediate */
        return (value | (p->word & 0xfffff000));
	/*break;*/
   }
d896 2
a897 5
   case t_patch_armdplsb:	/* ARM data processing instr. patch least sig byte */
   {
	patchNeg = FALSE; /* default to use an add instr. for labelrefs */

	value = patchit(p->type, p->value.fill, size);
d899 1
a899 1
	if (p->type == t_labelref)
d901 1
a901 9
		value -= 8;	/* adjust pc rel labelref for ARM pipelining */
		if (value < 0)
			{	/* backwards label ref */
				patchNeg = TRUE; /* use a sub instr. */
				value = -value;
			}
	}
	else if (value <0)
		error("Negative patch value passed to armdplsb");
d903 19
a921 3
	if (p->type != t_labelref)
	{
	   	word rot, imm;
d923 1
a923 1
		/* get instr. existing immediate const and add to patch value */
d925 1
a925 1
		imm = (p->word & 0xff); /* 8 bit immediate */
d927 1
a927 1
		imm = (p->word & 0xfff); /* bodged 12 bit immediate */
d930 3
a932 2
		/* get rotate from instr and fix immediate value with it */
		if( (rot = (p->word & 0xf00)) != 0)
d934 5
a938 3
			rot >>= 8;
			/* Jamies snazzy rotate equivalent code */
			imm = ((imm >> (rot*2)) | (imm << (32 - (rot*2))));
d941 2
a942 2
		value += imm;
	}
d944 1
a944 1
	restofdppatch = value;
d946 1
a946 1
	value &= 0xff; /* only ls byte for this patch  - not optimal as rot cannot be used */
d948 1
a948 1
	restofdppatch -= value; /* remember rest of patch */
d950 3
a952 3
	if(patchNeg)
	{
		int instr = (p->word & 0xfffff000);
d954 7
a960 1
		if ((instr & 0x01e00000) == 0x00800000)
d962 1
a962 2
			instr &= ~0x01e00000;	/* convert to a sub instruct */
			instr |= 0x00400000;
d964 8
a971 8
		else
			error("armdplsb: Trying to change add to sub when instr not an add");
	        return (value | instr);
	}
	else
	        return (value | (p->word & 0xfffff000));
	/*break;*/
   }
d973 14
a986 4
   case t_patch_armdpmid:	/* ARM data processing instr. patch second least sig byte */
   {
	/* dummy to clean up any unrequired patch info */
	value = patchit(p->type, p->value.fill, size);
d988 18
a1005 1
	value = restofdppatch;
d1007 1
a1007 6
	value &= 0xFF00;	/* use second ls byte for this patch */
	restofdppatch -= value;	/* work out remainder still to patch */
	value >>= 8;		/* move into instructions immediate field */
	value |= 0x0C00;	/* merge in immediate data's rotate field */
				/* 0x0C00 = left shift by eight bits */
	if(patchNeg)
d1009 10
a1018 3
		int instr = (p->word & 0xfffff000);
		
		if ((instr & 0x01e00000) == 0x00800000)
d1020 7
a1026 2
			instr &= ~0x01e00000;	/* convert to a sub instruct */
			instr |= 0x00400000;
d1028 4
a1031 8
		else
			error("armdpmid: Trying to change add to sub when instr not an add");
	        return (value | instr);
	}
	else
	        return (value | (p->word & 0xfffff000));
	/*break;*/
   }
d1033 4
a1036 3
   case t_patch_armdprest:	/* ARM data processing instr. patch - rest of last lsb patch */
   {
   	word ror = 0;
d1038 3
a1040 2
	/* dummy to clean up any unrequired patch info */
	value = patchit(p->type, p->value.fill, size); /* only ls byte */
a1041 1
	value = restofdppatch; /* use residue from last armdplsb/mid patch */
d1043 1
a1043 4
	if (value > 255)
	{
		ror = 0x10;
		while(!(value & 3)) /* word aligned immediate data? */
d1045 2
a1046 5
			/* see ARM assembly lang prg. pg 40 */
			/* ARM data man pg 21/25 */
			value >>= 2;	/* shift immediate value left by  two */
			if (--ror <= 4) /* and alter rotate by factor of two */
				break;  /* ARM immediate rotates are multiplied by 2 */
d1048 1
a1048 11
		if (ror == 0x10) ror = 0; /* if no rotates used */
	}
   	if (value > 255 )
		error("Patch value of %#x is too large for ARM DP residue patch (@@%#X)",value,codepos);
	value |= ror << 8; /* 4 bits of ror preceed 8 bit immediate */

	if(patchNeg)
	{
		int instr = (p->word & 0xfffff000);

		if ((instr & 0x01e00000) == 0x00800000)
d1050 1
a1050 2
			instr &= ~0x01e00000;	/* convert to a sub instruct */
			instr |= 0x00400000;
d1052 8
a1059 8
		else
			error("armdprest: Trying to change add to sub when instr not an add");
	        return (value | instr);
	}
	else
	        return (value | (p->word & 0xfffff000));
	/*break;*/
   }
d1061 6
a1066 16
   case t_patch_armjp:		/* ARM branch instr. patch */
   	   if (p->type != t_labelref)
   	       error("ARM jp patch should only be used with a label ref (@@%#X)",codepos);
	   return (p->word & 0xff000000) | (((patchit(p->type, p->value.fill, size) - 8) >> 2) & 0x00ffffff);
	   /*break;*/

   case t_patch_swap:
   	if (size == t_word)
           return swapw((long)patchit(p->type, p->value.fill, size)); /* swap word */
	else
           return swaps((unsigned)patchit(p->type, p->value.fill, size)); /* swap short */
	   /*break;*/

   case t_patch_pgc1:
           return p->word | patchit(p->type, p->value.fill, size);
	   /*break;*/
d1068 2
a1069 2
   default:
      error("Unknown machine dependent patch type in mcpatch: %#x (@@%#X)", type,codepos);
a1072 30
}

/* swap words */
long swapw(x)
long x;
{
   long r;
   char *a = (char *)&x;
   char *b = (char *)&r;

   b[0] = a[3];
   b[1] = a[2];
   b[2] = a[1];
   b[3] = a[0];

   return r;
}

/* swap shorts */
unsigned swaps(x)
unsigned x;
{
   unsigned r;
   char *a = (char *)&x;
   char *b = (char *)&r;

   b[0] = a[1];
   b[1] = a[0];
   return r;
}
d1074 1
@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
static char *RcsId = "$Id$ Copyright (C) Perihelion Software Ltd.";
a112 1
         trace("NEW MODULE %#x %d",curmod,m->id);
d243 4
d248 3
d253 1
@
