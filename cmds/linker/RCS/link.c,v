head	1.44;
access;
symbols
	Helios_1_3_1:1.33
	Helios_C40_1_3_Official_Release:1.28
	Alenia_release:1.27
	C40_Field_Test_2:1.27
	C40_Field_Test_R1:1.16;
locks; strict;
comment	@ * @;


1.44
date	94.05.04.14.47.29;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	94.01.20.16.56.39;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	94.01.20.14.31.22;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	94.01.20.14.17.47;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	94.01.11.11.51.57;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	94.01.10.12.28.06;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	94.01.05.14.43.11;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	94.01.05.10.50.33;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	93.12.20.19.21.39;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	93.12.20.13.22.09;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	93.12.17.17.10.12;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	93.09.14.09.27.34;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	93.08.18.18.27.22;	author paul;	state Exp;
branches;
next	1.31;

1.31
date	93.08.06.10.58.22;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	93.08.04.15.39.13;	author bart;	state Exp;
branches;
next	1.29;

1.29
date	93.07.12.15.44.10;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	93.01.15.14.23.48;	author nick;	state Exp;
branches;
next	1.27;

1.27
date	92.10.12.09.43.09;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	92.10.08.15.25.33;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	92.10.08.15.24.44;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	92.10.02.14.55.56;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	92.10.01.10.03.39;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	92.09.15.08.35.55;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	92.09.14.15.17.28;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	92.09.11.17.04.51;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	92.08.04.16.25.10;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	92.07.31.09.43.51;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	92.07.13.08.52.39;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	92.06.25.14.36.29;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	92.06.25.08.31.52;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	92.06.25.08.29.16;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	92.06.22.13.55.48;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	92.06.09.09.07.13;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	92.06.08.11.08.14;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	92.05.02.09.33.09;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	92.04.21.14.33.41;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	92.04.16.17.03.22;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	92.04.16.16.41.50;	author paul;	state Exp;
branches;
next	1.6;

1.6
date	91.12.04.14.53.12;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	91.11.22.16.06.03;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	91.10.18.14.08.26;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	91.10.09.09.13.25;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	91.10.09.08.47.51;	author paul;	state Exp;
branches;
next	1.1;

1.1
date	90.10.22.15.46.48;	author paul;	state Exp;
branches;
next	;


desc
@@


1.44
log
@added file tracing
@
text
@/*{{{  Comment */

/****************************************************************/
/* Helios Linker						*/
/*								*/
/* Copyright (c) 1989 - 1993 Perihelion Software Ltd.           */
/*  All Rights Reserved                                         */
/*                                                              */
/* File: link.c                                                 */
/*                                                              */
/*                                                              */
/* Author: NHG 26/9/88                                          */
/*                                                              */
/* Updates: CS/PAB/NC                                           */
/*                                                              */
/****************************************************************/
/* RcsId: $Id: link.c,v 1.43 1994/01/20 16:56:39 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */

/*}}}*/
/*{{{  Includes */

#include "link.h"
#include <ctype.h>
#include <time.h>
#include <stdarg.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
  
#ifdef __HELIOS
/*
 * XXX - the following is an amazing hack to get
 * the definition of Heliosno() without including
 * module.h
 */
  
typedef int Program;
#define __module_h
#include <nonansi.h>
#endif


#include "hash.c"

/*}}}*/
/*{{{  Constanst */

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0	/* sparc stdlib.h fails to define this! */
#define EXIT_FAILURE -1
#endif
#ifndef CLK_TCK
#define CLK_TCK 1000000	 /* and this! */
#endif

#define STDOUT	1
#define STDERR	2

/*}}}*/
/*{{{  Macros */

#define trace if (traceflags & db_files) _trace

/*}}}*/
/*{{{  Variables */

PUBLIC  FILE *		infd;
PUBLIC  int		outf;
PUBLIC  FILE *		verfd;
PRIVATE jmp_buf		error_level;
PUBLIC  WORD 		errors;
PRIVATE WORD 		phase      = 0;
PRIVATE WORD 		readfiles  = FALSE;
PUBLIC  WORD 		traceflags;
PRIVATE WORD 		maxerr     = 0;
PUBLIC  WORD 		verbose    = FALSE;
PUBLIC  WORD 		inlib      = FALSE;
#ifdef __SMT
PUBLIC	WORD 		smtopt     = TRUE; /* default to split module table operation */
#else
PUBLIC	WORD 		smtopt     = FALSE; /* default to original module table operation */
#endif
#if defined __ARM && (defined RS6000 || defined __SUN4)
PUBLIC WORD		bSharedLib    = FALSE;
PUBLIC WORD		bDeviceDriver = FALSE;
PUBLIC WORD		bTinyModel    = FALSE;
#endif
PUBLIC  WORD 		vmpagesize = 8 * 1024;
PUBLIC	WORD		gen_image_header = TRUE;

PRIVATE WORD		silent_running = FALSE;
PRIVATE WORD 		needobjed  = FALSE;
PRIVATE char *		progname   = NULL;	/* name of program we are linking */
PRIVATE char *		ProgName   = NULL;	/* name we are running under */
PRIVATE WORD 		stack_size = -1;
PRIVATE WORD 		heap_size  = -1;


PUBLIC  BYTE 		infile[  128 ];
PUBLIC	BYTE *		infile_duplicate = NULL;	/* malloced copy of the infile array */
PRIVATE BYTE 		outfile[ 128 ];

PUBLIC WORD uch = 0;
PUBLIC WORD unreadready = FALSE;

/*}}}*/
/*{{{  Forward declarations */

#if __STDC__
/* void 		unload( void ); */
PRIVATE WORD 		parsearg( char *** );
WORD 			max( word, word );
PRIVATE void 		tidy1(  void );
PRIVATE void 		tidyup( void );
#else
/* void 		unload(void); */
PRIVATE WORD 		parsearg();
WORD 			max();
PRIVATE void 		tidy1();
PRIVATE void 		tidyup();
PRIVATE void 		_fprintf();
#endif

/*}}}*/

/*{{{  Functions */

/*{{{  Housekeeping functions */

#ifndef __STDC__
# ifdef NOMEMCPY
/*{{{  memcpy() */

void
memcpy( to, from, count )
char *to, *from;
int count;
{
while(count--)
	*to++ = *from++;
}

/*}}}*/
# endif /* NOMEMCPY */

/* ANSI compatible clock() fn */
# ifdef NOCLOCKFN
/*{{{  clock() */

# include <sys/time.h>

# define CLK_TCK 1000000	 /* Usecs */
typedef unsigned int clock_t;

clock_t
clock()
{
  struct timeval t;
  struct timezone tz;

  
  gettimeofday( &t, &tz );
  
  return (t.tv_sec * 1000000 + t.tv_usec);
}

/*}}}*/
# endif /* no NOCLOCKFN */
#endif  /* no __STDC__ */

/*{{{  _strdup() */

PRIVATE BYTE *
_strdup( BYTE * str )
{
  BYTE *	copy;
  
  
  if (str == NULL)
    return NULL;

  copy = (BYTE *) malloc( strlen( str ) + 1 );

  if (copy == NULL)
    return NULL;
  
  return strcpy( copy, str );
  
} /* _strdup */

/*}}}*/

/*{{{  min() */

PUBLIC WORD
min(
    WORD a,
    WORD b )
{
  return a < b ? a : b;
}

/*}}}*/
/*{{{  max() */

PUBLIC WORD
max(
    WORD a,
    WORD b )
{
  return a > b ? a : b;
}

/*}}}*/

/*}}}*/
/*{{{  Message reporting functions */

#ifdef __STDC__
/*{{{  error() */

PUBLIC void error(BYTE *str,...)
{
	va_list ap;

	errors++;
	va_start(ap,str);
        if (readfiles) putc('\n',verfd);
#ifdef LINENO
        fprintf(verfd,"%s: Fatal Error: %s %ld : ",ProgName, infile, lineno );
#else
	if (infile && *infile != '\0')
	        fprintf(verfd,"%s: Fatal Error: %s : ", ProgName, infile );
       else
      	        fprintf(verfd,"%s: Fatal Error: ", ProgName);
#endif

	vfprintf(verfd,str,ap);
        putc('\n',verfd);
	va_end(ap);
        maxerr = max(maxerr,20);

	tidyup();
	exit((int)maxerr);
}

/*}}}*/
/*{{{  inform() */

PUBLIC void
inform( BYTE * str, ... )
{
  va_list ap;


  if (silent_running)
    return;
  
  va_start( ap, str );

  if (readfiles && verbose)
    putc( '\n', verfd );

#ifdef LINENO
  fprintf( verfd,",%s: Warning: %s %ld : ", ProgName, infile, lineno );
#else

  if (infile && *infile != '\0')
    fprintf( verfd,"%s: Warning: %s: ", ProgName, infile );
  else
    fprintf( verfd,"%s: Warning: ", ProgName );
#endif

  vfprintf( verfd, str, ap );

  putc( '\n', verfd );

  va_end( ap );

  return;	

} /* inform */

/*}}}*/
/*{{{  warn() */

PUBLIC void warn(BYTE *str, ...)
{
  va_list ap;


  va_start(ap,str);

  if (readfiles && verbose)
    putc('\n',verfd);
  
#ifdef LINENO
  fprintf(verfd,",%s: Warning: %s %ld : ",ProgName, infile,lineno);
#else
  if (infile && *infile != '\0')
    fprintf(verfd,"%s: Warning: %s : ", ProgName, infile);
  else
    fprintf(verfd,"%s: Warning: ", ProgName );
#endif
  vfprintf(verfd,str,ap);
  putc('\n',verfd);
  va_end(ap);
  errors++;
  maxerr = max(maxerr,10);
}

/*}}}*/
/*{{{  report() */

PUBLIC void
report( BYTE * str, ... )
{
   va_list ap;


   if (!verbose)
     return;

   va_start( ap, str );
   
   if (readfiles)
     putc( '\n', verfd );

   vfprintf( verfd, str, ap );

   putc( '\n', verfd );
   
   va_end( ap );

   return;
   
} /* report */

/*}}}*/
/*{{{  _trace() */

PUBLIC void _trace(BYTE *str,...)
{
   va_list ap;

   va_start(ap,str);
/*   if (readfiles) putc('\n',verfd); */
   fprintf(verfd,"%s: Trace: ", ProgName );
   vfprintf(verfd,str,ap);
   putc('\n',verfd);
   va_end(ap);
}

/*}}}*/
/*{{{  recover() */

PUBLIC void recover(BYTE *str,...)
{
	va_list ap;

        if (readfiles) putc('\n',verfd);
	va_start(ap,str);
#ifdef LINENO
        fprintf(verfd,"%s: Warning: %s %ld : ", ProgName, infile,lineno);
#else
	if (infile && *infile != '\0')
	        fprintf(verfd,"%s: Warning: %s : ", ProgName, infile);
	else
	        fprintf(verfd,"%s: Warning: ", ProgName );
#endif
        vfprintf(verfd,str,ap);
        va_end(ap);
        putc('\n',verfd);
        errors++;
        maxerr = max(maxerr,10);
        longjmp(error_level,1);
}

/*}}}*/

#else /* !__STDC__ */
/*{{{  error() */

PUBLIC void error(str,a,b,c,d,e,f)
BYTE *str;
INT a,b,c,d,e,f;
{
	errors++;
        if (readfiles) putc('\n',verfd);
#ifdef LINENO
        _fprintf(verfd,"Fatal Error: %s %ld : ",infile,lineno);
#else
	if(strlen(infile))
	        _fprintf(verfd,"Fatal Error: %s : ",infile);
       else
      	        _fprintf(verfd,"Fatal Error: ");
#endif
        _fprintf(verfd,str,a,b,c,d,e,f);
        putc('\n',verfd);
        maxerr = max(maxerr,20);

	tidyup();
	exit((int)maxerr);
}

/*}}}*/
/*{{{  warn() */

PUBLIC void warn(str,a,b,c,d,e,f)
BYTE *str;
INT a,b,c,d,e,f;
{
        if (readfiles) putc('\n',verfd);
#ifdef LINENO
        _fprintf(verfd,"Warning: %s %ld : ",infile,lineno);
#else
	if(strlen(infile))
	        _fprintf(verfd,"Warning: %s : ",infile);
	else
	        _fprintf(verfd,"Warning: ");
#endif
        _fprintf(verfd,str,a,b,c,d,e,f);
        putc('\n',verfd);
        errors++;
        maxerr = max(maxerr,10);
}

/*}}}*/
/*{{{  report() */

PUBLIC void report(str,a,b,c,d,e,f)
BYTE *str;
INT a,b,c,d,e,f;
{
	if( !verbose ) return;

        if (readfiles) putc('\n',verfd);
        _fprintf(verfd,str,a,b,c,d,e,f);
        putc('\n',verfd);
}

/*}}}*/
/*{{{  _trace() */

PUBLIC void _trace(str,a,b,c,d,e,f)
BYTE *str;
INT a,b,c,d,e,f;
{
       if (readfiles) putc('\n',verfd);
       _fprintf(verfd,"Trace: ");
       _fprintf(verfd,str,a,b,c,d,e,f);
       putc('\n',verfd);
}

/*}}}*/
/*{{{  recover() */

PUBLIC void recover(str,a,b,c,d,e,f)
BYTE *str;
INT a,b,c,d,e,f;
{
        warn(str,a,b,c,d,e,f);
        longjmp(error_level,1);
}

/*}}}*/
/*{{{  _fprintf() */

PRIVATE void _fprintf(fd,str,a,b,c,d,e,f)
FILE *fd;
BYTE *str;
INT a,b,c,d,e,f;
{
   static BYTE fbuf[128];
   BYTE *t = fbuf;
   BYTE *s = str;
   while( *s != '\0' )
   {
      if ( *s == '%' ) 
      {
         *t = *s;
         t++;
         s++;
         while( '0' <= *s && *s <= '9' ) 
         {
             *t = *s;
             t++;
             s++;
         }
         switch( *s ) 
         {
         case 'x': 
         case 'X': *t = 'l'; 
            t++;
            *t = 'x'; 
            t++;
            break;

         case 'd': 
         case 'D': *t = 'l'; 
            t++;
            *t = 'd'; 
            t++;
            break;

         default: *t = *s; 
            t++;
            break;
         }
         s++;
      }
      *t = *s;
      t++;
      s++;
   }
   *t = '\0';
   fprintf(fd,fbuf,a,b,c,d,e,f);
}

/*}}}*/
#endif /* __STDC__ */

/*}}}*/

/*{{{  tidyup() */

PRIVATE void
tidyup()
{
  tidy1();

  if (outf > STDERR)
    {
      close( outf );
      
      if (errors)
	{
#ifdef __STDC__
	  remove( outfile );
#else
	  unlink( outfile );
#endif
	  /* puts( "Image file removed\n" ); */
	}

      outf = STDOUT;
    }

  if (verfd != stderr &&
      verfd != NULL)
    {
      fclose( verfd );

      verfd = stderr;
    }
  
  VMTidy();

  return;
 
} /* tidyup */

/*}}}*/
/*{{{  tidy() */

PRIVATE void
tidy1()
{
  if (infd != stdin &&
      infd != NULL)
    {
      fclose( infd );
      
      infd = stdin;
    }

  return;
}

/*}}}*/
/*{{{  usage() */

PRIVATE void
usage( void )
{
  fprintf( stderr, "%s: $Revision: 1.43 $ command line arguments:\n", ProgName );
  fputs("\
<filename>\tinput\t\t- <filename> is a object file to be linked\n\
-\t\tstdin\t\t- link file read from stdin\n\
-l <filename>\tlibrary\t\t- <filename> is a library to be linked\n\
-o <filename>\toutput\t\t- specify the name for the output file\n\
-n <name>\tname\t\t- provide a name for the linked program\n\
-s <value>\tstack size\t- specify program's minimum stack size\n\
-h <value>\theap size\t- specify program's minimum heap size\n",
	stderr );
#ifdef __SMT
  fputs( "-SMTN\t\tdisable\t\t- disable split module table support\n", stderr );
#else
  fputs( "-SMTY\t\tenable\t\t- enable split module table support\n", stderr );
#endif
#ifdef VM
  fputs( "\
-m <filename>\tVM file\t\t- specify the name of the virtual memory file\n\
-z <value>\tVM size\t\t- specify the size of the virtual memory pages\n", stderr);
#endif
#ifdef __ARM
  fputs( "-A[lrt]\t\tARM Options\t- specify how to convert AOF files\n\
\t\t l\t\t-  build code for use in a shared library\n\
\t\t r\t\t-  build code for use in a device driver\n\
\t\t t\t\t-  build code using the tiny model\n", stderr );
#endif
  fputs( "\
-v [<file>]\tverbose\t\t- talk about what is going on [to <file>]\n\
-q\t\tquiet\t\t- suppress some warning messages\n\
-i\t\tno image header\t- suppress generation of image header for ROMming\n\
-?\t\thelp\t\t- display this information\n\
-t <letter(s)>\ttrace\t\t- enable tracing of link stage(s)\n\
\t\t c\t\t-  Code generation\n\
\t\t o\t\t-  image generation\n", stderr );
  fputs( "\
\t\t f\t\t-  File operations\n\
\t\t m\t\t-  Memory system\n\
\t\t y\t\t-  sYmbol manipulation\n\
\t\t d\t\t-  moDule generation\n\
\t\t s\t\t-  code Scanning\n", stderr );
#ifdef NEW_STUBS
fputs( "\t\t t\t\t-  sTub generation\n", stderr );
#endif
#if defined __ARM && (defined RS6000 || defined __SUN4)
fputs( "\t\t a\t\t-  AOF conversion\n", stderr );
#endif 
 
  return;
  
} /* usage */

/*}}}*/
/*{{{  parsearg() */

PRIVATE WORD
parsearg( char *** aargv )
{
  char **	argv = *aargv;
  char *	arg  = *argv;

  
#  define _ARG_ if (*++arg == '\0') { if ((arg = *(++argv)) == NULL) { usage(); exit( EXIT_FAILURE ); } }

  if ( *arg == '-' )
    {
      arg++;

      switch ( *arg )
	{
	case 'v':
	  verbose = !verbose;

	  if (*++arg != '\0')
	    {
	      FILE *	vfd;

	      trace( "opening verbose output file '%s'", arg );
	      
	      vfd = fopen( arg, "w" );

	      if (vfd == NULL)
		error( "Cannot open %s for output", arg );
	      else
		trace( "file opened" );
	      
	      verfd = vfd;
	    }
	  break;
	      
	case 't':
	  arg++;
	      
	  while (*arg != '\0')
	    {
	      switch ((int)locase( *arg ))
		{
		case 'c': traceflags ^= db_gencode;  break;
		case 'o': traceflags ^= db_genimage; break;
		case 'f': traceflags ^= db_files;    break;
		case 'm': traceflags ^= db_mem;      break;
		case 'y': traceflags ^= db_sym;      break;
		case 'd': traceflags ^= db_modules;  break;
		case 's': traceflags ^= db_scancode; break;
#ifdef NEW_STUBS
		case 't': traceflags ^= db_stubs;    break;
#endif
#if defined __ARM && (defined RS6000 || defined __SUN4)
		case 'a': traceflags ^= db_aof;  break;
#endif
		default:
		  report( "unknwon trace option '%c'", *arg );
		  break;
		}
	      arg++;
	    }
	  break;
	  
#ifdef __SMT
	case 'S':
	  /* disable split module table: option '-SMTN' */
	  
	  if (*(arg + 1) == 'M' &&
	      *(arg + 2) == 'T' &&
	      *(arg + 3) == 'N' &&
	      *(arg + 4) == '\0')
	    smtopt = FALSE;
	  else
	    error( "Unknown option -%s",arg );
	  break;
#else
	case 'S':
	  /* enable split module table: option '-SMTY' */
	  
	  if (*(arg + 1) == 'M' &&
	      *(arg + 2) == 'T' &&
	      *(arg + 3) == 'Y' &&
	      *(arg + 4) == '\0')
	    smtopt = TRUE;
	  else
	    error( "Unknown option -%s", arg );
	  break;
#endif
	case 'n':
	  /* objed module name setting option */
	  
	  _ARG_;
	    
	  needobjed = 1;
	  progname  = arg;
	  break;
	      
	case 's':
	  /* objed stack setting option */
	  
	  _ARG_;
	  
	  needobjed  = 1;
	  stack_size = (long)atol( arg );

	  break;

	default:
	  report( "unknown command line argument -%s", arg );
	  /* fall through */
	  
	case '?':
	  usage();
	  exit( EXIT_FAILURE );
	  
	case 'q':
	  silent_running = TRUE;
	  break;	  
	  
	case 'i':
	  /* disable the generation of a std Helios image header and the */
	  /* trailing zero word. */
	  gen_image_header = FALSE;
	  break;

	case 'h':
	  if (arg[ 1 ] == 'e' &&
	      arg[ 2 ] == 'l' &&
	      arg[ 3 ] == 'p' &&
	      arg[ 4 ] == '\0' )
	    {
	      usage();
	      exit( EXIT_SUCCESS );
	    }
	  
	  _ARG_;
	  
	  needobjed = 1;
	  heap_size = (long)atol(arg);
	  break;         
	      
#ifdef VM
	case 'm':
	  _ARG_;
	  VMfilename = arg;
	  break;
	      
	case 'z':
	  _ARG_;
	  vmpagesize = (long)atol( arg );
	  break;
#endif

#if defined __ARM && ( defined RS6000 || defined __SUN4 )
	case 'A':
	  arg++;

	  while (*arg != '\0')
	    {
	      switch ((int)locase( *arg ))
		{
		case 'l': bSharedLib    = TRUE; break;
		case 'r': bDeviceDriver = TRUE; break;
		case 't': bTinyModel    = TRUE; break;
		default:  report( "unknown ARM linker option '%c'", *arg ); break;
		}
	      arg ++;
	    }
	  break;
#endif
	  
	case 'o':
	  _ARG_;
	  
	  (void)strcpy( outfile, arg );

#ifdef __STDC__
	  remove( outfile );
#else
	  unlink( outfile );
#endif
	  /*
	   * BEWARE
	   *
	   * Under SunOS, opening a file with the truncate bit set,
	   * (for example by using fopen( ,"w+" )), will cause the
	   * file to be truncated every time the file pointer is
	   * moved backwards.  So, for example seeking to the beginning
	   * of the file will truncate the file to 0 length!  The objed()
	   * code does just this, so we cannot use fopen() to get hold
	   * of a file descriptor.  Hence the use of POSIX level I/O
	   * for the output file, and C level I/O for everything else.
	   */

	  errno = 0;
	  
	  trace( "opening output file '%s'", outfile );
	  
	  outf = open( outfile, O_CREAT | O_RDWR, 0666 );
	  
	  if (outf == -1)
	    error( "Cannot open %s for output, errno = %d", outfile, errno );
	  else
	    trace( "output file opened" );
	  
	  break;
	      
	case 'l':
	  _ARG_;
	  
	  inlib = TRUE;

	  trace( "opening library file '%s'", arg );
	  
	  goto inputfile;

	case '\0':
	  arg = "<stdin>";

#if defined __HELIOS /* && defined NEVER */
	  trace( "reopening stdin" );
	  
	  if ((fseek( stdin, 0L, SEEK_SET ) == 0) &&	/* only re-open ordinary files */
	      (fprintf( stderr, "reopening stdin\n" ),
	       infd = freopen( Heliosno( stdin )->Name, "rb", stdin )) == NULL)
	    {
	      error( "Failed to reopen stdin" );
	    }
#else
	  infd = stdin;
#endif
#if 0
	    {
	      int	c;

	      
	      c = getc( stdin );
	      
	      while (feof( stdin ) || ferror( stdin ))
		{
		  fprintf( stderr, "reset stdin\n" );
		  
		  clearerr( stdin );
		  
		  c = getc( stdin );
		}
	      
	      ungetc( c, stdin );

	      fprintf( stderr, "first char of stdin = %x\n", c );	      
	    }
#endif
	  trace( "opening stdin" );
	  
	  strcpy( infile, arg );
	  
	  goto readfile;	  
	}
	  
      *aargv = ++argv;
      
      return FALSE;
    }
  else
    {
      trace( "opening file '%s' for input", arg );
      
    inputfile:
      (void)strcpy( infile, arg );
      
#ifdef __STDC__
# ifdef TRIPOS
      infd = fopen( infile, "r" );
# else
      infd = fopen( infile, "rb" );
# endif
#else
      infd = fopen( infile, "r" );
#endif
      if (infd == NULL)
	{
	  error( "Cannot open %s for input", infile );
	}
      else
	trace( "opened input file" );
      
    readfile:      
      infile_duplicate = _strdup( arg );
      
      if (verbose) 
	{
	  int i = 80 - strlen( infile ) - sizeof "Reading ";

	  
	  fprintf( verfd, "Reading %*s\r", -i, infile );

	  fflush( verfd );
	}

      *aargv = ++argv;

      return TRUE;
    }
  
} /* parsearg */

/*}}}*/
/*{{{  main() */

/********************************************************/
/* main                                                 */
/*                                                      */
/* Initialise everything and call the linker            */
/*                                                      */
/********************************************************/

PUBLIC int
main(
     int     argc,
     BYTE ** argv )
{
  WORD 		infiles = 0;
  clock_t	start=0, inend=0, end=0;
  
  
  /* IOdebug( "Linker: starting" ); */
  
  infd  = stdin;
  outf  = STDOUT;
  verfd = stderr;
  
  infile[ 0 ] = 0;
  errors      = 0;
  
  ProgName = *argv++;
  argc--;
  
  if (strrchr( ProgName, '/' ))
    ProgName = strrchr( ProgName, '/' ) + 1;
  
  /* IOdebug( "Linker: progname = %s", ProgName ); */
  
  start = clock();

  /* IOdebug( "Linker: start = %ld", start ); */
  
  if (setjmp( error_level ) == 0)
    {
      /* IOdebug( "Linker: setjmp completed, initialising" ); */
      
      initmem();
      initcode();
      initmodules();
      initsym();

      /* IOdebug( "Linker: saying hello to world" ); */
      
      report( "Helios Linker V1.4" );
      report( "Copyright (C) 1989 - 1993, Perihelion Software Ltd." );

      phase     = 1;
      readfiles = TRUE;
      
      while (*argv != NULL)
	{
	  /* IOdebug( "Linker: parsing arg %s", *argv ); */
	  
	  if (parsearg( &argv ) == TRUE )
	    {
	      /* IOdebug( "Linker: processing arg" ); */
	      
	      infiles++;
	      
	      readfile();
	      
	      tidy1();
	      
	      inlib = FALSE;
	    }

	  /* IOdebug( "Linker: arg parsed" ); */
	}

      /* IOdebug( "Linker: args parsed" ); */
      
      strcpy( infile, "" );   /*  no longer know what input file to blame errors on */
      
      infile_duplicate = NULL;
      
      if (infiles == 0)   /* if no command line files, use stdin */
	{
	  /* IOdebug( "Linker: processing stdin" ); */
	  
	  readfile();
	}
      
      readfiles = FALSE; 

      /* IOdebug( "Linker: finished last module" ); */
      
      genend();   /* finish off last module */
      
      inend = clock();
      
      setmodules();

      if (errors == 0)
	{
	  phase = 2;
	  
	  scancode();
	}   

      if (errors == 0)
	{
	  phase = 3;
	  
	  genimage();
	  
	  report( "Image file generated                                     " );
	  
	  if (needobjed)
	    {
	      if (outf == STDOUT)
		{
		  error( "Cannot set stack size/heap size when writing to stdout" );
		}
	      else
		{
		  objed( outf, progname, stack_size, heap_size );
		}
	    }
	}

#ifdef NEW_STUBS
      build_stubs();
#endif
      
    }
  
  end = clock();

  /* IOdebug( "Linker: finished processing" ); */
  
  report( "Times (secs): Total %d Input %d Output %d",
	 (end   - start) / CLK_TCK,
	 (inend - start) / CLK_TCK,
	 (end   - inend) / CLK_TCK );
  
  report( "Memory used:   Code     %8ld Local Heap  %8ld", codesize, heapsize );
  report( "               Symbols  %8ld\n", symsize );
  
  VMStats();
  
  tidyup();
  
  exit( (int)maxerr );
  
  return EXIT_SUCCESS;
  
  use( phase );
} /* main */

/*}}}*/

/*}}}*/

/* link.c */
@


1.43
log
@added folding
@
text
@d17 1
a17 1
/* RcsId: $Id: link.c,v 1.42 1994/01/20 14:31:22 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d61 5
d587 1
a587 1
  fprintf( stderr, "%s: $Revision: 1.42 $ command line arguments:\n", ProgName );
d661 1
a661 1
	      FILE *	vfd = fopen( arg, "w" );
d663 3
d669 3
a671 1

d837 2
d843 2
d852 2
d861 2
d892 3
a894 1
#endif	  
d906 2
d924 2
d930 1
a930 1
      if (verbose)
@


1.42
log
@fixed handling of erroneous command line arguments
@
text
@d1 2
d17 4
a20 1
/* RcsId: $Id: link.c,v 1.41 1994/01/20 14:17:47 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d46 2
a47 32
#ifndef __STDC__
# ifdef NOMEMCPY
void
memcpy( to, from, count )
char *to, *from;
int count;
{
while(count--)
	*to++ = *from++;
}
# endif /* NOMEMCPY */

/* ANSI compatible clock() fn */
# ifdef NOCLOCKFN
# include <sys/time.h>

# define CLK_TCK 1000000	 /* Usecs */
typedef unsigned int clock_t;

clock_t
clock()
{
  struct timeval t;
  struct timezone tz;

  
  gettimeofday( &t, &tz );
  
  return (t.tv_sec * 1000000 + t.tv_usec);
}
# endif /* no NOCLOCKFN */
#endif  /* no __STDC__ */
d60 3
d99 6
d120 46
d167 1
d187 27
d216 2
d243 3
d280 2
d308 3
d335 2
d350 2
d375 2
d378 1
d402 3
d424 3
d438 2
d451 2
d462 2
d515 2
d519 4
d559 2
d576 2
a577 18
PUBLIC WORD uch = 0;
PUBLIC WORD unreadready = FALSE;

PUBLIC WORD
min(
    WORD a,
    WORD b )
{
  return a < b ? a : b;
}

PUBLIC WORD
max(
    WORD a,
    WORD b )
{
  return a > b ? a : b;
}
d582 1
a582 1
  fprintf( stderr, "%s: $Revision: 1.41 $ command line arguments:\n", ProgName );
d633 2
d923 2
d1079 4
@


1.41
log
@fixed bug in decoding of -A command line option
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.40 1994/01/11 11:51:57 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d503 1
a503 1
  fprintf( stderr, "%s: $Revision: 1.40 $ command line arguments:\n", ProgName );
d562 1
a562 1
#  define _ARG_ if (*++arg == '\0') arg = *(++argv);   
@


1.40
log
@fixed formatting is usage string
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.39 1994/01/10 12:28:06 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d503 1
a503 1
  fprintf( stderr, "%s: $Revision: 1.39 $ command line arguments:\n", ProgName );
d707 1
a707 1
	  while (*arg != '0')
d714 1
a714 1
		default:  report( "unknwon ARM linker option '%c'", *arg ); break;
@


1.39
log
@added RCS revision number to help string
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.38 1994/01/05 14:43:11 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d503 1
a503 1
  fprintf( stderr, "%s: $Revision$ command line arguments:\n", ProgName );
d532 1
a532 1
-i\t\tno image header\t\t- suppress generation of image header for ROMming\n\
@


1.38
log
@changed 'sparc' to '__SUN4' in #if defined
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.37 1994/01/05 10:50:33 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d503 1
a503 1
  fprintf( stderr, "%s: command line arguments:\n", ProgName );
@


1.37
log
@minor cosmetic change in inform() output
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.36 1993/12/20 19:21:39 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d101 1
a101 1
#if defined __ARM && (defined RS6000 || defined sparc)
d546 1
a546 1
#if defined __ARM && (defined RS6000 || defined sparc)
d602 1
a602 1
#if defined __ARM && (defined RS6000 || defined sparc)
d703 1
a703 1
#if defined __ARM && ( defined RS6000 || defined sparc )
@


1.36
log
@added support for tracing ARM AOF conversion
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.35 1993/12/20 13:22:09 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d202 1
a202 1
    fprintf( verfd,"%s: Warning: %s : ", ProgName, infile );
@


1.35
log
@added command line options for AOF support
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.34 1993/12/17 17:10:12 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d544 1
a544 1
  fputs( "\t\t t\t\t-  sTub generation\n", stderr );
d546 4
a549 1
  
d601 3
@


1.34
log
@minor cosmetic changes
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.33 1993/09/14 09:27:34 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d101 5
d523 6
d565 1
a565 1
      switch ((int)locase( *arg ))
d599 3
d648 1
a648 1
	  
d694 18
@


1.33
log
@removed hexopt option
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.32 1993/08/18 18:27:22 paul Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d703 1
a703 1
	   * for the output file, and C lebvel I/O for everything else.
d814 2
a815 2
  int    argc,
  BYTE **argv )
d853 2
a854 2
      report( "Helios Linker V1.3" );
      report( "Copyright (C) 1989 - 1992, Perihelion Software Ltd." );
@


1.32
log
@Now supports -i option to disable the generation of std image header and
zero byte tail.
(used for ROM bootstrap).
@
text
@d4 1
a4 1
/* Copyright (c) 1989 - 1992 Perihelion Software Ltd.           */
d15 1
a15 1
/* RcsId: $Id: link.c,v 1.31 1993/08/06 10:58:22 nickc Exp $ Copyright (C) Perihelion Software Ltd. */
a93 1
PUBLIC  WORD 		hexopt     = FALSE;
a521 1
-x\t\thex output\t- output in ASCII hex codes, not binary\n\
a592 4
	case 'x':
	  hexopt = TRUE;
	  break;

@


1.31
log
@added -q option to supress (some) warning messages
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.30 1993/08/04 15:39:13 bart Exp nickc $ Copyright (C) Perihelion Software Ltd. */
d103 1
d522 1
d598 1
a598 1
	      
d655 6
@


1.30
log
@Cleaned up the -help text to reduce code and data requirements.
@
text
@d15 1
a15 1
/* RcsId: $Id: link.c,v 1.29 1993/07/12 15:44:10 nickc Exp $ Copyright (C) Perihelion Software Ltd. */
d104 1
d111 1
d184 3
d520 1
d648 4
@


1.29
log
@fixed compile time warnings
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.28 1993/01/15 14:23:48 nick Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d494 9
a502 7
  fprintf( stderr, "<filename>      input      - <filename> is a object file to be linked\n" );
  fprintf( stderr, "-               stdin      - link file read from stdin\n" );  
  fprintf( stderr, "-l <filename>   library    - <filename> is a library to be linked\n" );  
  fprintf( stderr, "-o <filename>   output     - specify the name for the output file\n" );
  fprintf( stderr, "-n <name>       name       - provide a name for the linked program\n" );
  fprintf( stderr, "-s <value>      stack size - specify program's minimum stack size\n" );
  fprintf( stderr, "-h <value>      heap size  - specify program's minimum heap size\n" );
d504 1
a504 1
  fprintf( stderr, "-SMTN           disable    - disable split module table support\n" );
d506 1
a506 1
  fprintf( stderr, "-SMTY           enable     - enable split module table support\n" );
d509 3
a511 2
  fprintf( stderr, "-m <filename>   VM file    - specify the name of the virtual memory file\n" );
  fprintf( stderr, "-z <value>      VM size    - specify the size of the virtual memory pages\n" );
d513 13
a525 11
  fprintf( stderr, "-v [<file>]     verbose    - talk about what is going on [to <file>]\n" );
  fprintf( stderr, "-x              hex output - output in ASCII hex codes, not binary\n" );
  fprintf( stderr, "-?              help       - display this information\n" );
  fprintf( stderr, "-t <letter(s)>  trace      - enable tracing of link stage(s)\n" );
  fprintf( stderr, "                 c         -  Code generation\n" );
  fprintf( stderr, "                 o         -  image generation\n" );
  fprintf( stderr, "                 f         -  File operations\n" );
  fprintf( stderr, "                 m         -  Memory system\n" );
  fprintf( stderr, "                 y         -  sYmbol manipulation\n" );
  fprintf( stderr, "                 d         -  moDule generation\n" );
  fprintf( stderr, "                 s         -  code Scanning\n" );
d527 1
a527 1
  fprintf( stderr, "                 t         -  sTub generation\n" );
a944 2
  use( RcsId );
  
@


1.28
log
@Included <errno.h> to supply a declaration of errno.
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.27 1992/10/12 09:43:09 nickc Exp nick $ Copyright (C) Perihelion Software Ltd.";
d140 1
a140 1
  copy = malloc( strlen( str ) + 1 );
@


1.27
log
@changed mode of opened output file to remove execute permission
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.26 1992/10/08 15:25:33 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d24 1
@


1.26
log
@oops, fixed typo in previous delta
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.25 1992/10/08 15:24:44 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d690 1
a690 1
	  outf = open( outfile, O_CREAT | O_RDWR, 0777 );
@


1.25
log
@fixed test for return value of OPen()
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.24 1992/10/02 14:55:56 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d671 1
a671 1
	  remove( outfile )
@


1.24
log
@improved line spacing of output
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.23 1992/10/01 10:03:39 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d669 1
a669 1
	  
d671 1
a671 1
	  remove( outfile );
d687 2
d692 2
a693 2
	  if (outf == 0)
	    error( "Cannot open %s for output", outfile );
@


1.23
log
@fixed compile time warnings
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.22 1992/09/15 08:35:55 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d183 1
a183 1
  if (readfiles)
d209 4
a212 1
	va_list ap;
d214 3
a216 2
	va_start(ap,str);
        if (readfiles) putc('\n',verfd);
d218 1
a218 1
        fprintf(verfd,",%s: Warning: %s %ld : ",ProgName, infile,lineno);
d220 4
a223 4
	if (infile && *infile != '\0')
	        fprintf(verfd,"%s: Warning: %s : ", ProgName, infile);
	else
	        fprintf(verfd,"%s: Warning: ", ProgName );
d225 5
a229 5
        vfprintf(verfd,str,ap);
        putc('\n',verfd);
        va_end(ap);
        errors++;
        maxerr = max(maxerr,10);
@


1.22
log
@changed output file to use POSIX level IO to avoid "feature" in SunOS
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.21 1992/09/14 15:17:28 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
a18 1
#ifdef __STDC__
a21 1
#endif
d23 1
@


1.21
log
@fixed typo
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.20 1992/09/11 17:04:51 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d24 2
a25 1

d82 3
d86 1
a86 1
PUBLIC  FILE *		outfd;
d421 1
a421 2
  if (outfd != stdout &&
      outfd != NULL)
d423 1
a423 1
      fclose( outfd );
d435 1
a435 1
      outfd = stdout;
a668 5
# ifdef TRIPOS
	  outfd = fopen( outfile, "w+" );
# else	  
	  outfd = fopen( outfile, hexopt ? "w+" : "wb+" );
# endif
d671 13
d685 3
a687 3
	  outfd = fopen( outfile, "w+" );
#endif
	  if (outfd == NULL)
d801 1
a801 1
  outfd = stdout;
a891 2
	  fflush( outfd );
	  
d895 10
a904 1
            objed( outfd, progname, stack_size, heap_size );
@


1.20
log
@fixed for compilation on Sparc
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.19 1992/08/04 16:25:10 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d489 1
a489 1
  fprintf( stderr, "-l <filename>   library    - <filename> is a libray to be linked\n" );  
@


1.19
log
@added inform() function (like warn(0 but does not increment error count)
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.18 1992/07/31 09:43:51 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d50 1
a50 1
# endif
d70 9
a78 1
# endif
@


1.18
log
@removed compiler warnings
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.17 1992/07/13 08:52:39 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d163 32
@


1.17
log
@fixed to support new CODESTUB patch
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.16 1992/06/25 14:36:29 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d428 3
a430 2
min( a, b )
  WORD a, b;
d436 3
a438 2
max( a, b )
  WORD a, b;
d484 1
a484 2
parsearg( aargv )
  char ***	aargv;
d651 4
a654 2
#if defined __HELIOS && defined NEVER
	  if ((infd = freopen( Heliosno( stdin )->Name, "rb", stdin )) == NULL)
d678 2
d739 3
a741 3
main( argc, argv )
  int    argc;
  BYTE **argv;
@


1.16
log
@improved stdin reading
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.15 1992/06/25 08:31:52 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d465 1
a465 1
  fprintf( stderr, "                 c         -  code generation\n" );
d467 8
a474 5
  fprintf( stderr, "                 f         -  file operations\n" );
  fprintf( stderr, "                 m         -  memory system\n" );
  fprintf( stderr, "                 y         -  symbol manipulation\n" );
  fprintf( stderr, "                 d         -  module generation\n" );
  fprintf( stderr, "                 s         -  code scanning\n" );
d526 3
d822 1
a822 1
      
d829 1
a829 1
      
d843 5
@


1.15
log
@oops, fixed bug in previous delta
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.14 1992/06/25 08:29:16 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d644 1
a644 1
#ifdef __HELIOS
d652 19
a670 1
	  
@


1.14
log
@added '-' option to force read from stdin.  This was needed by c in NONSTANDARD mode
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.13 1992/06/22 13:55:48 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d649 2
@


1.13
log
@improved trace output, and made -help terminate command
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.12 1992/06/09 09:07:13 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d25 13
d446 2
a447 1
  fprintf( stderr, "-l <filename>   library    - <filename> is a resident libray to be linked\n" );  
d453 1
a453 1
  fprintf( stderr, "-SMTN           disable    - shared module table output\n" );
d455 1
a455 1
  fprintf( stderr, "-SMTY           enable     - shared module table output\n" );
d640 14
a664 2
      infile_duplicate = _strdup( arg );
      
d679 3
d748 1
a748 1
      report( "Helios Linker V1.1" );
@


1.12
log
@removed IOdebugs introduced by previous delta
,
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.11 1992/06/08 11:08:14 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d202 1
a202 1
   if (readfiles) putc('\n',verfd);
d568 1
a568 1
	  break;
d577 1
a577 1
	      break;
@


1.11
log
@added more debugging
@
text
@d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.10 1992/05/02 09:33:09 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
a185 2
   IOdebug( "Linker: reporting %s", str );
   
a187 2
   IOdebug( "linker: reported" );
   
@


1.10
log
@added a few (commented out) debugging messages
@
text
@d4 3
d12 1
a12 1
/* Updates: CS/PAB                                              */
d15 1
a15 1
static char *RcsId = "$Id: link.c,v 1.9 1992/04/21 14:33:41 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d46 2
a47 1
clock_t clock()
d49 2
a50 2
	struct timeval t;
	struct timezone tz;
d52 4
a55 3
	gettimeofday(&t, &tz);

	return(t.tv_sec * 1000000 + t.tv_usec);
a69 1
PUBLIC  WORD 		defopt     = FALSE;
a76 1
PUBLIC  FILE *		deffd;
a104 109
/********************************************************/
/* main                                                 */
/*                                                      */
/* Initialise everything and call the linker            */
/*                                                      */
/********************************************************/

PUBLIC int main(argc,argv)
int    argc;
BYTE **argv;
{
   WORD 	infiles = 0;
   clock_t	start=0, inend=0, end=0;


   /* IOdebug( "Linker: starting" ); */
   
   infd  = stdin;
   outfd = stdout;
   verfd = stderr;
   deffd = (FILE *) NULL;
   
   infile[ 0 ] = 0;
   errors      = 0;

   ProgName = *argv++;
   argc--;

   if (strrchr( ProgName, '/' ))
     ProgName = strrchr( ProgName, '/' ) + 1;
   
   /* IOdebug( "Linker: progname = %s", ProgName ); */
   
   start = clock();
   
   if ( setjmp(error_level) == 0 )
     {
      initmem();
      initcode();
      initmodules();
      initsym();

      report("Helios Linker V1.1");
      report("Copyright (C) 1989 - 1991, Perihelion Software Ltd.");

      phase = 1; readfiles = TRUE;
      while( *argv != NULL ) 
      {
         if ( parsearg(&argv) == TRUE )
         {
             infiles++;
             readfile();
             tidy1();
             inlib = FALSE;
         }
      }
      
      strcpy(infile,"");   /*  no longer know what input file to blame errors on */

      infile_duplicate = NULL;
      
      if( infiles == 0 )   /* if no command line files, use stdin */
      {
         readfile();
      }

      readfiles = FALSE; 
#if 0
      putc('\n',verfd);
#endif

      genend();   /* finish off last module */

      inend = clock();
      
      setmodules();

      if( errors == 0 )
      {
         phase = 2;
         scancode();
      }   
         
      if( errors == 0 )
      {
         phase = 3;

         genimage();

         fflush(outfd);
         
         report("Image file generated                                     ");
        
         if( needobjed )
            objed(outfd,progname,stack_size,heap_size);
      }

   }

   end = clock();
   
   report("Times (secs): Total %d Input %d Output %d",
   (end-start)/CLK_TCK,(inend-start)/CLK_TCK,(end-inend)/CLK_TCK);
   report("Memory used:   Code     %8ld Local Heap  %8ld",codesize,heapsize);
   report("               Symbols  %8ld\n",symsize);

   VMStats();
      
   tidyup();
a105 7
   exit((int)maxerr);

   use(phase);
   use(RcsId);
   return 0;
}

a124 161
PRIVATE WORD parsearg(aargv)
char ***aargv;
{
   char **argv = *aargv;
   char *arg = *argv;

#  define _ARG_ if( *++arg == '\0' ) arg = *(++argv);   

        if( *arg == '-' )
        {
             arg++;
             switch( (int)locase(*arg) )
             {
             case 'v':
                 verbose = !verbose;
                 if( *++arg != '\0' )
                 {
                     FILE *vfd = fopen(arg,"w");
                     if( vfd == 0 ) error("Cannot open %s for output",arg+2);
                     verfd = vfd;
                 }
                 break;

             case 't':
                 arg++;

                 while( *arg != '\0' )
                 {
                     switch( (int)locase(*arg) )
                     {
                         case 'c': traceflags ^= db_gencode;  break;
                         case 'o': traceflags ^= db_genimage; break;
                         case 'f': traceflags ^= db_files;    break;
                         case 'm': traceflags ^= db_mem;      break;
                         case 'y': traceflags ^= db_sym;      break;
                         case 'd': traceflags ^= db_modules;  break;
                         case 's': traceflags ^= db_scancode;  break;
                     }
                     arg++;
                 }
                 break;

             case 'x':
                 hexopt = TRUE;
                 break;

             case 'd':
                 defopt = TRUE;
                 _ARG_;
                 deffd = fopen(arg,"w");
                 if(deffd == NULL ) error("Cannot open %s for output",arg+2);
                 break;
#ifdef __SMT
             case 'S':
                 /* disable split module table: option '-SMTN' */
                 if (*(arg+1) == 'M' && *(arg+2) == 'T' && *(arg+3) == 'N' && *(arg+4) == '\0')
                     smtopt = FALSE;
		 else
		     error("Unknown option -%s",arg);
		 break;
#else
             case 'S':
                 /* enable split module table: option '-SMTY' */
                 if (*(arg+1) == 'M' && *(arg+2) == 'T' && *(arg+3) == 'Y' && *(arg+4) == '\0')
                     smtopt = TRUE;
		 else
		     error("Unknown option -%s",arg);
                 break;
#endif
             case 'n':
		 /* objed module name setting option */
		 _ARG_
		 needobjed = 1;
		 progname = arg;
                 break;

             case 's':
                 /* objed stack setting option */
                 _ARG_
                 needobjed = 1;
                 stack_size = (long)atol(arg);
                 break;

             case 'h':
                 _ARG_;
                 needobjed = 1;
                 heap_size = (long)atol(arg);
                 break;         

#ifdef VM
             case 'm':
                 _ARG_;
                 VMfilename = arg;
                 break;
         
             case 'z':
                 _ARG_;
                 vmpagesize = (long)atol(arg);
                 break;
#endif      
             case 'o':
                 _ARG_;
                (void)strcpy(outfile,arg);
#ifdef __STDC__
                remove(outfile);
# ifdef TRIPOS
               	outfd = fopen(outfile,"w+");
# else
                outfd = fopen(outfile,hexopt?"w+":"wb+");
# endif
#else
                unlink(outfile);
                outfd = fopen(outfile,"w+");
#endif
                if( outfd == 0 ) error("Cannot open %s for output",outfile);
                    break;

             case 'l':
                 _ARG_;
                 inlib = TRUE;
                 goto inputfile;
         
             }

                *aargv = ++argv;
                return FALSE;
        }
        else
        {
inputfile:
            (void)strcpy(infile,arg);

	    infile_duplicate = _strdup( arg );
	    
#ifdef __STDC__
# ifdef TRIPOS
            infd = fopen(infile,"r");
# else
            infd = fopen(infile,"rb");
# endif
#else
            infd = fopen(infile,"r");
#endif
            if( infd == 0 ) {
                error("Cannot open %s for input",infile);
            }

            if( verbose ) {
		int i = 80 - strlen(infile) - sizeof"Reading ";

                fprintf(verfd,"Reading %s",infile);
		while (i-- > 0)
                    putc(' ',verfd);
                putc('\r',verfd);
                fflush(verfd);
            }
            *aargv = ++argv;
            return TRUE;
        }
}

d172 2
a173 1
PUBLIC void report(BYTE *str,...)
d177 18
a194 1
   if( !verbose ) return;
d196 3
a198 6
   va_start(ap,str);
   if (readfiles) putc('\n',verfd);
   vfprintf(verfd,str,ap);
   putc('\n',verfd);
   va_end(ap);
}
d363 2
a364 1
PRIVATE void tidyup()
d366 9
a374 5
        tidy1();
        if(outfd != stdout && outfd != NULL) {
        	fclose(outfd);
        	if(errors)
        	{
d376 1
a376 1
        		remove(outfile);
d378 1
a378 1
		        unlink(outfile);
d380 20
a399 8
/*			puts("Image file removed\n");*/
		}
        	outfd = stdout;
        }
        if(verfd != stderr && verfd != NULL) { fclose(verfd); verfd = stderr; }
        if(deffd != NULL) { fclose(deffd); deffd =  NULL; }
        VMTidy();
}
d401 2
a402 1
PRIVATE void tidy1()
d404 9
a412 1
        if(infd != stdin && infd != NULL) { fclose(infd); infd = stdin; }
d418 3
a420 2
PUBLIC WORD min(a,b)
WORD a,b;
d422 1
a422 1
        return a<b ? a : b;
d425 3
a427 2
PUBLIC WORD max(a,b)
WORD a,b;
d429 1
a429 1
        return a>b ? a : b;
d432 386
@


1.9
log
@changed strdup() to be _strdup()
@
text
@d12 1
a12 1
static char *RcsId = "$Id: link.c,v 1.8 1992/04/16 17:03:22 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d110 1
a110 1
int argc;
d113 2
a114 2
   WORD infiles = 0;
   clock_t start=0, inend=0, end=0;
d116 4
a119 1
   infd = stdin;
a121 1

d123 3
a125 2
   infile[0] = 0;
   errors = 0;
d133 2
d137 2
a138 2
   if( setjmp(error_level) == 0 )
   {
@


1.8
log
@added code to report file names where objects are not defined
@
text
@d12 1
a12 1
static char *RcsId = "$Id: link.c,v 1.7 1992/04/16 16:41:50 paul Exp nickc $ Copyright (C) Perihelion Software Ltd.";
d215 1
a215 1
strdup( BYTE * str )
d230 1
a230 1
} /* strdup */
d365 1
a365 1
	    infile_duplicate = strdup( arg );
@


1.7
log
@changed command line options
@
text
@d12 1
a12 1
static char *RcsId = "$Id: link.c,v 1.6 1991/12/04 14:53:12 nickc Exp $ Copyright (C) Perihelion Software Ltd.";
d83 1
d153 1
d156 2
d214 19
d365 2
@


1.6
log
@fixed determination of program name
@
text
@d12 1
a12 1
static char *RcsId = "$Id: link.c,v 1.4 1991/11/06 13:48:36 nickc Exp nickc $ Copyright (C) Perihelion Software Ltd.";
a63 1
/*PRIVATE WORD 		image      = i_helios;*/
d160 1
d162 1
a254 5
#if 0
             case 'i':
                 image = *arg;
                 break;
#endif
d263 16
d280 4
a283 3
                 /* *NOT* split module table option '-nsmt' */
                 if (*(arg+1) == 's' && *(arg+2) == 'm' && *(arg+3) == 't' && *(arg+4) == '\0')
                     smtopt = FALSE;
a291 14
#else
             case 's':
                 /* split module table option '-smt' */
                 if (*(arg+1) == 'm' && *(arg+2) == 't' && *(arg+3) == '\0')
                 {
                     smtopt = TRUE;
                     break;
                 }
                 /* default to objed stack setting option */
                 _ARG_
                 needobjed = 1;
                 progname = arg;
                 break;
#endif
@


1.5
log
@fixed error messages to report program name
@
text
@d12 1
a12 1
static char *RcsId = "$Id: link.c,v 1.4 1991/11/06 13:48:36 nickc Exp $ Copyright (C) Perihelion Software Ltd.";
d78 2
a79 1
PRIVATE char *		progname   = NULL;
d124 1
a124 1
   argv++;
d127 3
d379 1
a379 1
        fprintf(verfd,"linker: Fatal Error: %s %ld : ",infile,lineno);
d382 1
a382 1
	        fprintf(verfd,"linker: Fatal Error: %s : ",infile);
d384 1
a384 1
      	        fprintf(verfd,"linker: Fatal Error: ");
d403 1
a403 1
        fprintf(verfd,",linker: Warning: %s %ld : ",infile,lineno);
d406 1
a406 1
	        fprintf(verfd,"linker: Warning: %s : ",infile);
d408 1
a408 1
	        fprintf(verfd,"linker: Warning: ");
d437 1
a437 1
   fprintf(verfd,"linker: Trace: ");
d451 1
a451 1
        fprintf(verfd,"linker: Warning: %s %ld : ",infile,lineno);
d454 1
a454 1
	        fprintf(verfd,"linker: Warning: %s : ",infile);
d456 1
a456 1
	        fprintf(verfd,"linker: Warning: ");
@


1.4
log
@simplified (no pc/mwc #ifdefs) added support for __SMT automatic split module
table use
@
text
@d12 1
a12 1
static char *RcsId = "$Id: link.c,v 1.3 1991/10/09 09:13:25 paul Exp $ Copyright (C) Perihelion Software Ltd.";
d375 1
a375 1
        fprintf(verfd,"Fatal Error: %s %ld : ",infile,lineno);
d377 2
a378 2
	if(strlen(infile))
	        fprintf(verfd,"Fatal Error: %s : ",infile);
d380 1
a380 1
      	        fprintf(verfd,"Fatal Error: ");
d399 1
a399 1
        fprintf(verfd,"Warning: %s %ld : ",infile,lineno);
d401 2
a402 2
	if(strlen(infile))
	        fprintf(verfd,"Warning: %s : ",infile);
d404 1
a404 1
	        fprintf(verfd,"Warning: ");
d433 1
a433 1
   fprintf(verfd,"Trace: ");
d447 1
a447 1
        fprintf(verfd,"Warning: %s %ld : ",infile,lineno);
d449 2
a450 2
	if(strlen(infile))
	        fprintf(verfd,"Warning: %s : ",infile);
d452 1
a452 1
	        fprintf(verfd,"Warning: ");
@


1.3
log
@tidy up setjmp mess
@
text
@d12 1
a12 1
static char *RcsId = "$Id: link.c,v 1.2 1991/10/09 08:47:51 paul Exp paul $ Copyright (C) Perihelion Software Ltd.";
a21 4
#ifdef LATTICE
#include <fcntl.h>
#endif

d25 1
a25 2

#ifdef ORION
d34 1
a34 1
#endif
d37 2
a38 2
#ifdef UNIX
#include <sys/time.h>
d40 1
a40 1
#define CLK_TCK 1000000	 /* Usecs */
d52 1
a52 1
#endif
d69 1
d71 3
a99 6
#ifdef MWC
long 			_stksize = 20000;
#endif
#ifdef IBMPC
int 			_stack = 4096;
#endif
a116 3
#ifdef LATTICE
   verfd = stdout;
#else
a117 1
#endif
d262 1
a262 1

d264 2
a265 3
                 /* *NOT* split module table option - 'nsmt' */
                 if (*(arg+1) == 's' && *(arg+2) == 'm' && *(arg+3) == 't' && *(arg+3) == '\0')
                 {
d267 4
a270 2
                     break;
                 }
d273 1
a273 1
                 progname = arg;
d275 1
a275 1
         
d277 7
a283 1
                 /* objed stack setting option */
d286 1
a286 1
                 stack_size = (long)atol(arg);
d288 1
d312 5
a318 13
#endif
#ifdef LATTICE
                if( !hexopt ) 
                {
                    _iomode ^= O_RAW;
                    outfd = fopen(outfile,"w");
                    _iomode ^= O_RAW;
                }
#endif
#ifdef MWC
                outfd = fopen(outfile,hexopt?"w+":"wb+");
#endif
#ifdef UNIX
a320 10
#ifdef IBMPC
               	outfd = fopen(outfile,"w+");
#endif
#ifdef __STDC__
#ifdef TRIPOS
               	outfd = fopen(outfile,"w+");
#else
                outfd = fopen(outfile,hexopt?"w+":"wb+");
#endif
#endif
d338 1
a338 16
#ifdef LATTICE
            if( !preasm ) {
                _iomode ^= O_RAW;
                infd = fopen(infile,"r");
                _iomode ^= O_RAW;
            }
#endif
#ifdef MWC
            infd = fopen(infile,preasm?"r":"rb");
#endif
#ifdef UNIX
            infd = fopen(infile,"r");
#endif
#ifdef IBMPC
            infd = fopen(infile,"r");
#endif
d340 1
a340 1
#ifdef TRIPOS
d342 3
d346 1
a346 1
            infd = fopen(infile,"rb");
a347 1
#endif
a617 34
#ifdef MWC

/* The following function was formerly called rdch()- but this clashes
 * with the system function of the same name, causing the compiler to moan.
 * Cannot use system definition of rdch() because it is not same- so I have
 * renamed this function so that I can use it.
 * AEv AEv */
PUBLIC WORD asm_rdch()
{
   WORD c = uch;

   if( c == -2 ){
#ifdef MWC
   c = bingetc(infd);
   if( c == 0xffffL ) c = EOF;
#else
        c = getc(infd);
#endif
        return c;
   }
   uch = -2;
   return c;
}


PUBLIC WORD unrdch(c)
WORD c;
{
   uch = c;
}
#endif


#ifndef LATTICE
d629 3
a631 1
#endif
@


1.2
log
@NickC's changes for the 'C40 + some bug fixes
@
text
@d12 1
a12 1
static char *RcsId = "$Id: link.c,v 1.2 1991/10/08 13:01:10 nickc Exp $ Copyright (C) Perihelion Software Ltd.";
d63 1
a63 2
PUBLIC  int *		error_level;
PRIVATE jmp_buf 	default_level;
a131 1
   error_level = default_level;
a421 2
/*        longjmp(&default_level,1);*/

a514 1
/*        longjmp(&default_level,1);*/
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
static char *RcsId = "$Id$ Copyright (C) Perihelion Software Ltd.";
d31 2
a32 1
void memcpy(to,from,count)
d60 23
a82 23
PUBLIC  FILE *infd;
PUBLIC  FILE *outfd;
PUBLIC  FILE *verfd;
PUBLIC  int *error_level;
PRIVATE jmp_buf default_level;
PUBLIC  WORD errors;
PRIVATE WORD phase = 0;
PRIVATE WORD readfiles = FALSE;
PUBLIC  WORD traceflags;
PRIVATE WORD maxerr = 0;
/*PRIVATE WORD image = i_helios;*/
PUBLIC  WORD hexopt = FALSE;
PUBLIC  WORD defopt = FALSE;
PUBLIC  WORD verbose = FALSE;
PUBLIC  WORD inlib = FALSE;
PUBLIC	WORD smtopt = TRUE; /* default to split module table operation */
PUBLIC  FILE *deffd;
PUBLIC  WORD vmpagesize = 8*1024;

PRIVATE WORD needobjed = FALSE;
PRIVATE char *progname = NULL;
PRIVATE WORD stack_size = -1;
PRIVATE WORD heap_size = -1;
d84 2
a85 2
PUBLIC  BYTE infile[128];
PRIVATE BYTE outfile[128];
d88 5
a92 5
/* void unload(void); */
PRIVATE WORD parsearg(char ***);
WORD max(word, word);
PRIVATE void tidy1(void);
PRIVATE void tidyup(void);
d94 6
a99 6
/* void unload(void); */
PRIVATE WORD parsearg();
WORD max();
PRIVATE void tidy1();
PRIVATE void tidyup();
PRIVATE void _fprintf();
d103 1
a103 1
long _stksize = 20000;
d106 1
a106 1
int _stack = 4096;
d149 1
a149 1
      report("Copyright (C) 1989, Perihelion Software Ltd.");
d169 2
a170 1
      readfiles = FALSE; putc('\n',verfd);
@
