head	1.30;
access;
symbols
	Helios_1_3_1:1.29
	Helios_C40_1_3_Official_Release:1.27
	Alenia_release:1.26
	Helios1_3:1.26
	C40_Field_Test_2:1.26
	C40_Field_Test_R1:1.23
	Helios13_beta:1.23
	Helios1_2_2:1.21
	Helios1_2_2Beta:1.21
	Helios1_2_1:1.16
	Helios1_2:1.8;
locks; strict;
comment	@ * @;


1.30
date	94.06.07.12.32.43;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	93.08.12.15.15.15;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	93.08.04.14.51.10;	author bart;	state Exp;
branches;
next	1.27;

1.27
date	93.04.20.13.37.06;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	92.09.17.16.07.36;	author martyn;	state Exp;
branches;
next	1.25;

1.25
date	92.09.17.13.07.46;	author martyn;	state Exp;
branches;
next	1.24;

1.24
date	92.08.19.20.08.59;	author paul;	state Exp;
branches;
next	1.23;

1.23
date	92.04.09.14.10.50;	author martyn;	state Exp;
branches;
next	1.22;

1.22
date	92.01.22.17.18.52;	author martyn;	state Exp;
branches;
next	1.21;

1.21
date	91.06.04.11.51.43;	author martyn;	state Exp;
branches;
next	1.20;

1.20
date	91.04.10.18.43.32;	author martyn;	state Exp;
branches;
next	1.19;

1.19
date	91.04.10.18.38.29;	author martyn;	state Exp;
branches;
next	1.18;

1.18
date	91.04.10.16.19.05;	author martyn;	state Exp;
branches;
next	1.17;

1.17
date	91.04.10.15.55.03;	author martyn;	state Exp;
branches;
next	1.16;

1.16
date	91.03.26.17.53.50;	author martyn;	state Exp;
branches;
next	1.15;

1.15
date	91.03.26.13.18.58;	author martyn;	state Exp;
branches;
next	1.14;

1.14
date	91.02.14.11.51.26;	author paul;	state Exp;
branches;
next	1.13;

1.13
date	91.01.23.18.08.53;	author martyn;	state Exp;
branches;
next	1.12;

1.12
date	91.01.23.17.23.11;	author martyn;	state Exp;
branches;
next	1.11;

1.11
date	90.12.19.16.08.18;	author martyn;	state Exp;
branches;
next	1.10;

1.10
date	90.12.11.12.05.13;	author martyn;	state Exp;
branches;
next	1.9;

1.9
date	90.12.11.11.47.11;	author martyn;	state Exp;
branches;
next	1.8;

1.8
date	90.11.23.18.03.59;	author martyn;	state Exp;
branches;
next	1.7;

1.7
date	90.11.22.12.38.15;	author martyn;	state Exp;
branches;
next	1.6;

1.6
date	90.11.22.12.33.04;	author martyn;	state Exp;
branches;
next	1.5;

1.5
date	90.11.13.12.54.56;	author martyn;	state Exp;
branches;
next	1.4;

1.4
date	90.09.25.12.46.26;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	90.09.12.16.10.14;	author jon;	state Exp;
branches;
next	1.2;

1.2
date	90.09.12.15.51.57;	author jon;	state Exp;
branches;
next	1.1;

1.1
date	90.08.23.15.48.30;	author james;	state Exp;
branches;
next	;


desc
@@


1.30
log
@improved error messages
@
text
@/**
*Title:  Helios Shell - Built-in Command Support.
*
* Author: Andy England
*
* Date:   May 1988
*
*         (c) Copyright 1988, Perihelion Software Ltd.
*
*         All Rights Reserved.
*
**/
#include "shell.h"
#include <termios.h>

#ifdef __TRAN
char *sccsid = "@@(#)builtin.c	1.18\t12/4/89 Copyright (C) 1988, Perihelion Software Ltd.";
#endif
  
#ifdef		DEBUGGING
char *version = "1.24\t02/08/93.\tDebug Version    Copyright (C) 1987 - 1993, Perihelion Software Ltd.";
#else
char *version = "1.24\t02/08/93.\t    Copyright (C) 1987 - 1993, Perihelion Software Ltd.";
#endif


static int determine_signal(char *str);
static int mystrcmp(char *ms1, char *ms2);
static void show_signals(void);

BUILTIN  builtins[MAX_BUILT] =
{
  "alias", b_alias,
  "alloc", b_alloc,
  "bg", b_bg,
  "break", b_break,
  "breaksw", b_breaksw,
  "case", b_case,
  "cd", b_cd,
  "chdir", b_cd,
  "continue", b_continue,
  "default", b_default,
  "dirs", b_dirs,
  "echo", b_echo,
  "else", b_else,
  "end", b_end,
  "endif", b_endif,
  "endsw", b_endsw,
  "eval", b_eval,
  "exec", b_exec,
  "exit", b_exit,
#ifdef HELIOS
  "fault", b_fault,
#endif
  "fg", b_fg,
  "foreach", b_foreach,
  "glob", b_glob,
  "goto", b_goto,
  "hashstat", b_hashstat,
  "history", b_history,
  "if", b_if,
  "jobs", b_jobs,
  "kill", b_kill,
  "limit", b_limit,
/*  "login", b_login, - BLV 1.2 changes */
  "logout", b_logout,
  "nice", b_nice,
  "nohup", b_nohup,
  "notify", b_notify,
  "onintr", b_onintr,
  "popd", b_popd,
#ifdef HELIOS
  "printenv", b_printenv,
#endif
  "pushd", b_pushd,
#ifdef HELIOS
  "pwd", b_pwd,
#endif
  "rehash", b_rehash,
  "repeat", b_repeat,
  "set", b_set,
  "setenv", b_setenv,
  "shift", b_shift,
  "source", b_source,
  "stop", b_stop,
  "suspend", b_suspend,
  "switch", b_switch,
  "time", b_time,
  "umask", b_umask,
  "unalias", b_unalias,
  "unhash", b_unhash,
  "unlimit", b_unlimit,
  "unset", b_unset,
  "unsetenv", b_unsetenv,
  "version", b_version,
  "wait", b_wait,
  "which", b_which,
  "while", b_while,
  "@@", b_at,
  0, 0
};

BUILTIN extrabuiltins[2] =
{
  ":", b_label,
  "%", b_job
};

int mode;
SUBSTATE wordstate;

char *getword(char *line )
{
  int c;

#ifdef	DEBUGGING
  DEBUG("getword()");
#endif
  wordstate = NEUTRAL;
  forever
  {
    c = *line++;
    switch (wordstate)
    {
      case NEUTRAL:
      switch (c)
      {
        case ';':
        strcpy(wordbuffer, ";");
#ifdef	DEBUGGING
        DEBUG("='%s' (%S)",wordbuffer,line);
#endif
        return line;

        case '&':
        if (*line == '&')
        {
          line++;
          strcpy(wordbuffer, "&&");
          return line;
        }
        strcpy(wordbuffer, "&");
        return line;
       
        case '|':
        if (*line == '|')
        {
          line++;
#ifdef CDL
          if (usingcdl AND *line == '|')
          {
            line++;
            strcpy(wordbuffer, "|||");
            return line;
          }
#endif
          strcpy(wordbuffer, "||");
          return line;
        }
#ifdef CDL
        if (usingcdl)
        {
          if (*line == '<')
          {
            line++;
            strcpy(wordbuffer, "|<");
            return line;
          }
          if (*line == '>')
          {
            line++;
            strcpy(wordbuffer, "|>");
            return line;
          }
        }
#endif
        strcpy(wordbuffer, "|");
        return line;

        case '<':
        if (*line == '<')
        {
          line++;
          strcpy(wordbuffer, "<<");
          return line;
        }
#ifdef CDL
        if (usingcdl)
        {
          if (*line == '>')
          {
            line++;
            strcpy(wordbuffer, "<>");
            return line;
          }
          if (*line == '|')
          {
            line++;
            strcpy(wordbuffer, "<|");
            return line;
          }
        }
#endif
        strcpy(wordbuffer, "<");
        return line;
       
        case '>':
                       	
        if (*line == '>')
        {
          line++;
          if (*line == '2')
          {
            line++;
            strcpy(wordbuffer, ">>2");
#ifdef	DEBUGGING
  	    DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
            return line;
          }
          strcpy(wordbuffer, ">>");
          return line;
        }
        if (*line == '2')
        {
          line++;
          strcpy(wordbuffer, ">2");
#ifdef	DEBUGGING
  	  DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
          return line;
        }
#ifdef CDL
        if (usingcdl AND *line == '|')
        {
          line++;
          strcpy(wordbuffer, ">|");
          return line;
        }
#endif
        strcpy(wordbuffer, ">");
        return line;

#ifdef CDL
        case '^':
        if (usingcdl AND *line == '^')
        {
          line++;
          strcpy(wordbuffer, "^^");
          return line;
        }
        line--;
        wordstate = INWORD;
        continue;
#endif

        case '(':
        strcpy(wordbuffer, "(");
        parencount++;
        return line;

        case ')':
        strcpy(wordbuffer, ")");
        parencount--;
        return line;

	case '@@':			/* the @@ symbol might refer to	*/
					/* the at shell function or is	*/
					/* part of an encoded capability*/
	{
  	  int i;
	  for (i = 0; i < 16; i++)
	    if (line[i] < 'a' || line[i] > 'p') break;

	  if (i == 16 && line[i] == '/')
	  {
	    line--;			/* seems to be a capability...	*/
	    wordstate = INWORD;		/* read it as a word.		*/
	    continue;
	  }
          strcpy(wordbuffer, "@@");
#ifdef	DEBUGGING
  	  DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
          return line;
        }

        case '\n':
        case '\0':
        return NULL;

        case ' ':
        case '\t':
        continue;

        default:
        line--;
        wordstate = INWORD;
        continue;
      }

      case INWORD:
      switch (c)
      {
        case ';':
        case '&':
        case '|':
        case '<':
        case '>':
        case '(':
        case ')':
        case '\n':
        case '\0':
        case ' ':
        case '\t':
        ignore endword();
        wordstate = NEUTRAL;
        return line - 1;

#ifdef CDL
        case '^':
        if (usingcdl AND *line == '^')
        {
          ignore endword();
          wordstate = NEUTRAL;
          return line - 1;
        }
        addchar('^');
        continue;
#endif

        case '\\':
        if (*line == '\n')
        {
          line++;
          if (wordindex > 0) addchar(' ');
          else wordstate = NEUTRAL;
          continue;
        }
        addchar('\\');
        addchar(*line++);
        continue;

        case '$':
        addchar('$');
        if (*line == '\n') continue;
        if (*line == '{')
        {
          line++;
          addchar('{');
          if (*line == '\n') continue;
        }
	if(*line != ' ')
        addchar(*line++);
        continue;

        case '\'':
        addchar('\'');
        wordstate = INSQUOTE;
        continue;
        
        case '`':
        addchar('`');
        wordstate = INBQUOTE;
        continue;

        case '\"':
        addchar('"');
        wordstate = INDQUOTE;
        continue;

        case '#':
        unless (interactive)
        {
          do c = *line++; until (c == '\0' OR c == '\n');
          return NULL;
        }
        default:
        addchar(c);
        continue;
      }

      case INSQUOTE:
      case INBQUOTE:
      case INDQUOTE:
      switch (c)
      {
        case '\n':
        case '\0':
        ignore endword();
        return line - 1;

#if 0
        case '\\':
        addchar('\\');
        addchar(*line++);
        continue;
#endif

        case '\'':
        addchar('\'');
        if (wordstate == INSQUOTE) wordstate = INWORD;
        continue;

        case '`':
        addchar('`');
        if (wordstate == INBQUOTE) wordstate = INWORD;
        continue;

        case '"':
        addchar('"');
        if (wordstate == INDQUOTE) wordstate = INWORD;
        continue;

        default:
        addchar(c);
        continue;
      }
    }
  }
}

void getlastword(char *line )
{
  until ((line = getword(line)) == NULL);
}

BOOL isspecial(char *name)
{
  BUILTIN *builtin;

  unless ((builtin = findbuiltin(name)) == NULL)
  {
    int (*func)() = builtin->func;

    return (BOOL)
           (func == b_else  OR func == b_exit OR func == b_foreach OR
           func == b_if    OR func == b_set  OR func == b_switch  OR
           func == b_while OR func == b_at);
  }
  return FALSE;
}

BOOL needsfullsubs(int (*func)() )
{
  return (BOOL)
         (func == b_cd      OR func == b_echo   OR func == b_eval   OR
          func == b_foreach OR func == b_glob   OR func == b_pushd  OR
          func == b_repeat  OR func == b_source OR func == b_switch OR
          func == b_time    OR func == b_set );
}

BUILTIN *findbuiltin(char *name )
{
  BUILTIN *builtin;

  if (name[strlen(name) - 1] == ':') return &extrabuiltins[0];
  if (name[0] == '%') return &extrabuiltins[1];
  for (builtin = builtins; builtin->name; builtin++)
  {
    if (strequ(name, builtin->name)) return builtin;
  }
  return NULL;
}

int b_alias(
	    int argc,
	    char *argv[] )
{
  if (argc < 2) putalias();
  else
  {
    char *name = argv[1];

    if (argc == 2)
    {
      unless ((argv = findalias(name)) == NULL) putargv(argv, TRUE);
    }
    else
    {
      if (strequ(name, "alias") OR strequ(name, "unalias"))
        return error(ERR_DANGEROUS, name);
      alias(name, dupargv(argv + 2));
    }
  }
  return OK;
}

int b_alloc(
	    int argc,
	    char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  putmem();
  return OK;
}

int b_bg(
	 int argc,
	 char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_break(
	    int argc,
	    char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_BREAK);
  setmode(MODE_END);
  return OK;
}

int b_breaksw(
	      int argc,
	      char *argv[] )
{
  char line[LINE_MAX + 1];
  int nestcount = 1;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  do
  {
    unless (getline(line, TRUE)) return error(ERR_NOENDSW, argv[0]);
    unless (getword(line) == NULL)
    {
      if (strequ("switch", wordbuffer)) nestcount++;
      if (strequ("endsw", wordbuffer)) nestcount--;
    }
  } while (nestcount > 0);
  return OK;
}

int b_case(
	   int argc,
	   char *argv[] )
{
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_cd(
	 int argc,
	 char *argv[] )
{
  char *name;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((name = getvar("home")) == NULL) return error(ERR_NOHOME, NULL);
  }
  else name = argv[1];
  unless (changedir(name)) return syserr(name);
  return OK;
}

int b_continue(
	       int argc,
	       char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_END);
  return OK;
}

int b_default(
	      int argc,
	      char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_dirs(
	   int argc,
	   char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (dirs()) return syserr(argv[0]);
  return OK;
}

int b_echo(
	   int argc,
	   char *argv[] )
{
  if (argc >= 1)
  {
    BOOL newline = TRUE;

    if (strequ(*++argv, "-n")) 
    {
      argv++;
      newline = FALSE;
    }
    putargv(argv, newline);
  }
  return OK;
}

int b_else(
	   int argc,
	   char *argv[] )
{
  int nestcount = 1;
  char line[LINE_MAX + 1];

  do
  {
    char *lineptr;

    unless (getline(line, TRUE)) return error(ERR_NOENDIF, argv[0]);
    unless ((lineptr = getword(line)) == NULL)
    {
      if (strequ("endif", wordbuffer)) nestcount--;
      if (strequ("if", wordbuffer))
      {
        getlastword(lineptr);
        if (strequ("then", wordbuffer)) nestcount++;
      }
    }
  } while (nestcount > 0);
  return OK;
  argc = argc;				/* keep the compiler happy...	*/
}

int b_end(
	  int argc,
	  char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_END);
  return OK;
}

int b_endif(
	    int argc,
	    char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_endsw(
	    int argc,
	    char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_eval(
	   int argc,
	   char *argv[] )
{
  char line[LINE_MAX + 1];

  sputargv(line, argv + 1, ' ');
  return runcmdline(line);
  argc = argc;				/* keep the compiler happy...	*/
}

int b_exec(
	   int argc,
	   char *argv[] )
{
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  executecmd(argv[1], argv+1);
  return error(ERR_NOTFOUND, argv[1]);	/* CFL	Fix to bug #261		*/
  return OK;
}

int b_exit(
	   int argc,
	   char *argv[] )
{
  int code;

  if (argc > 1)
  {
    EXPR *expr;

    initexprparse(argv + 1);
    code = evaluate(expr = readexpr(0));
    freeexpr(expr);
  }
  else
  {
    char *status;

    if ((status = getvar("status")) == NULL) code = OK;
    else code = atoi(status);
  }
  freeargv(argv);
  logout(code);
  return OK;
}

#ifdef HELIOS
int b_fault(
	    int argc,
	    char *argv[] )
{
  int code;

  if (argc > 1)
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv++) == NULL)
    {
      if (strlen(arg) < 8) arg = readdecimal(arg, &code);
      else arg = readhex(arg, &code);
      unless (*arg == '\0') return error(ERR_BADNUMBER, cmd);
      fault(code);
    }
  }
  else
  {
    char *error;

    if ((error = getvar("error")) == NULL) code = OK;
    else code = atoi(error);
    fault(code);
  }
  return OK;
}
#endif

int b_fg(
	 int argc,
	 char *argv[] )
{
  JOB *job;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else
  {
    char *arg = argv[1];

    unless (*arg++ == '%') return error(ERR_NOSUCHJOB, argv[0]);
    if (arg[0] == '\0' OR
        ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
    {
      if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
    }
    else if (arg[0] == '-' AND arg[1] == '\0')
    {
      if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
    }
    else
    {
      int number = JOBS_MAX + 1;		/* illegal value */

      ignore readdecimal(arg, &number);
      if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
    }
  }
  putcmd(job->cmd);
  printf("\n");
  ignore setpgid(job->pid, tcgetpgrp(0));
  waitforcmd(job->pid);
  return OK;
}

int b_foreach(
	      int argc,
	      char *argv[] )
{
  char name[VARNAME_MAX + 1];
  int savemode = mode;
  int retval = OK;
  char *arg;
  int i;
  long start, end;

  if (argc < 4) return error(ERR_TOOFEWARGS, argv[0]);
  arg = readname(argv[1], name);
  unless (*arg == '\0') return error(ERR_INVALIDVAR, argv[0]);
  unless (strequ(argv[2], "(") AND strequ(argv[argc - 1], ")"))
    return error(ERR_WORDLIST, argv[0]);
  start = note();
  {
    int nestcount = 1;
    char line[LINE_MAX + 1];

    do
    {
      unless (getline(line, TRUE)) return error(ERR_NOEND, argv[0]);
      unless (getword(line) == NULL)
      {
        if (strequ("while", wordbuffer) OR
            strequ("foreach", wordbuffer)) nestcount++;
        if (strequ("end", wordbuffer)) nestcount--;
      }
    } while (nestcount > 0);
  }
  end = note();
  if (argc > 4)
  {
    newloop();
    unsetmode(MODE_HISTORY);

    for (i = 3; i < argc - 1; i++)
    {
      point(start);
      set(name, makeargv(argv[i]));
      do
      {
        unless (docmdline())
        {
          error(ERR_NOEND, argv[0]);
          retval = !OK;			
        }
      } until ((mode & MODE_END) || retval != OK);    
      unsetmode(MODE_END);
      if ((mode & MODE_BREAK) || retval != OK)		
      {
        unsetmode(MODE_BREAK);
        point(end);
        break;
      }
    }
    mode = savemode;
    oldloop();
    point(end);				/* CFL	Fix to bug #130		*/
  }
  return retval;			
}

int b_glob(
	   int argc,
	   char *argv[] )
{
  while (--argc)
  {
    printf("%s", *++argv);
    if (argc > 1) putchar('\0');
    fflush(stdout);
  }
  return OK;
}

int b_goto(
	   int argc,
	   char *argv[] )
{
  char line[WORD_MAX + 1];
  char label[WORD_MAX + 1];

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  rewindinput();
  strcpy(label, argv[1]);
  strcat(label, ":");
  forever
  {
    unless (getline(line, TRUE)) return error(ERR_NOLABEL, argv[1]);
    unless (getword(line) == NULL)
    {
      if (strequ(label, wordbuffer)) break;
    }
  }
  return OK;
}

int b_hashstat(
	       int argc,
	       char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_history(
	      int argc,
	      char *argv[] )
{
  char *history;
  char *cmd = *argv++;
  BOOL reverse = FALSE;
  BOOL nonames = FALSE;
  int number = 0;
  char *arg;

#ifdef	DEBUGGING
  DEBUG("b_history (%V)", argv);
#endif
  unless ((history = getvar("history")) == NULL)
    number = atoi(history);

  while ((arg = *argv) != NULL AND *arg++ == '-')
  {
    argv++;
    while (*arg != '\0')
      switch (*arg++)
      {
        case 'h' : nonames = TRUE; break;
        case 'r' : reverse = TRUE; break;
        default  : return error(ERR_BADOPTION, cmd);
      }
  }

  if ((arg = *argv) != NULL)
  {
    arg = readdecimal(arg, &number);
    if (*arg != '\0') return error(ERR_BADNUMBER, cmd);
  }
  putsublist(&historylist, number, nonames, TRUE, reverse);

  return OK;
  argc = argc;				/* keep the compiler happy...	*/
}

int b_if(
	 int argc,
	 char *argv[] )
{
  EXPR *expr;
  int value;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  initexprparse(argv + 1);
  value = evaluate(expr = readexpr(0));
  freeexpr(expr);
  if (token == T_NEWLINE) return error(ERR_EMPTYIF, argv[0]);
  if (strequ(currentword, "then"))
  {
    readexprtoken();
    unless (token == T_NEWLINE) return error(ERR_THEN, argv[0]);
    unless (value)
    {
      int nestcount = 1;
      char line[LINE_MAX + 1];

      do
      {
        char *lineptr;

        unless (getline(line, TRUE)) return error(ERR_NOELSE, "then");
        unless ((lineptr = getword(line)) == NULL)
        {
          if (nestcount == 1 AND strequ("else", wordbuffer))
          {
            char **newargv = nullargv();

            until ((lineptr = getword(lineptr)) == NULL)
              newargv = addword(newargv, wordbuffer);
            ignore waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE, CHECKBUILTIN));
            break;
          }
          if (strequ("endif", wordbuffer)) nestcount--;
          if (strequ("if", wordbuffer))
          {
            getlastword(lineptr);
            if (strequ("then", wordbuffer)) nestcount++;
          }
        }
      } while (nestcount > 0);
    }
  }
  else if (value)
    ignore waitforcmd(runsimplecmd(dupargv(wordlist), NULL, READ, WRITE, CHECKBUILTIN));
  return OK;
}

int b_job(
	  int argc,
	  char *argv[] )
{
  JOB *job;
  char *arg = argv[0] + 1;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (arg[0] == '\0' OR
      ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else if (arg[0] == '-' AND arg[1] == '\0')
  {
    if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
  }
  else
  {
    int number = JOBS_MAX + 1;		/* illegal value */

    ignore readdecimal(arg, &number);
    if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
  }
  putcmd(job->cmd);
  printf("\n");
  waitforcmd(job->pid);
  return OK;
}

int b_jobs(
	   int argc,
	   char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  putjobtable();
  return OK;
}

int b_kill(
	   int argc,
	   char *argv[] )
{
  char *arg, *name = argv[0];
  int sig = SIGTERM;
  BOOL rungeneralkill = FALSE;
  char **newargv = nullargv();

  newargv = addword(newargv, argv[0]);

  if (argc < 2) 
	{
	  freeargv(newargv);
	  return error(ERR_TOOFEWARGS, name);
	}
  until ((arg = *++argv) == NULL)
  {
    int pid;

    if (arg[0] == '-')
	{
	if (arg[1] == 'l' || arg[1] == 'L')
		{
		if(argc != 2)
		  {
		  freeargv(newargv);
	      	  return error(ERR_TOOMANYARGS, name);
		  }
		show_signals();
		freeargv(newargv);
	  	return OK;
		}

	if (arg[1] == 'a' || arg[1] == 'A')
		{
			/* execute general kill command */
                newargv = addword(newargv, arg);
		rungeneralkill = TRUE;
		continue;
		}

        if (argc < 3) 
	  {
	  freeargv(newargv);
	  return error(ERR_TOOFEWARGS, name);
	  }

	if(argv[1][0] == '-')
		{
		freeargv(newargv);
		return error(ERR_SYNTAX, name);
		}

	if((sig = determine_signal( &arg[1] )) < 0)
		{	
	 	freeargv(newargv);
	  	return error(ERR_BADSIGNAL, name);
		}

	newargv = addword(newargv, arg);

	continue;
	}

    if (arg[0] == '%')
    {
      JOB *job;

      if (arg[1] == '\0' OR
          ((arg[1] == '%' OR arg[1] == '+') AND arg[2] == '\0'))
      {
        if ((job = currentjob()) == NULL) 
	  {
	  freeargv(newargv);
	  return error(ERR_NOCURJOB, *argv);
	  }
      }
      else if (arg[1] == '-' AND arg[2] == '\0')
      {
        if ((job = previousjob()) == NULL) 
	  {
	  freeargv(newargv);
	  return error(ERR_NOPREVJOB, *argv);
	  }
      }
      else
      {
        int number = JOBS_MAX + 1;		/* illegal value */

        ignore readdecimal(&arg[1], &number);
        if ((job = getjob(number)) == NULL) 
	  {
	  freeargv(newargv);
	  return error(ERR_NOSUCHJOB, *argv);
	  }
      }
      pid = job->pid;
    }
    else
    {
      arg = readdecimal(arg, &pid);
      unless (*arg == '\0')
		{
			/* execute general kill command */
                newargv = addword(newargv, arg);
		rungeneralkill = TRUE;
                continue;
		}
    }
    if (kill(pid, sig) == -1)
	{
	freeargv(newargv);
	return syserr(NULL);
	}
  }
  if(rungeneralkill)
     return(waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE, NOBUILTIN)));
  freeargv(newargv);
  return OK;
}

int b_label(
	    int argc,
	    char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_limit(
	    int argc,
	    char *argv[] )
{
#ifdef UNIX
  int i;

  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    for (i = 1; i < RESOURCE_MAX; i++) putlimit(i);
  }
  else
  {
    if ((i  = findresource(argv[1])) == -1) return error(ERR_LIMIT, argv[0]);
    if (argc == 2) putlimit(i);
    else
    {
      int limit = JOBS_MAX + 1;		/* illegal value */
      char *arg = readdecimal(argv[2], &limit);

      unless (*arg == '\0') return error(ERR_SCALEFACTOR, argv[0]);
      setlimit(i, limit);
    }
  }
  return OK;
#else
  if (argc > 1) error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_logout(
	     int argc,
	     char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (login)
  {
    freeargv(argv);
    logout(OK);
  }
  return error(ERR_NOTLOGIN, NULL);
}

int b_nice(
	   int argc,
	   char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_nohup(
	    int argc,
	    char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_notify(
	     int argc,
	     char *argv[] )
{
  JOB *job;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else
  {
    char *arg = argv[1];

    unless (*arg++ == '%') return error(ERR_NOSUCHJOB, argv[0]);
    if (arg[0] == '\0' OR
        ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
    {
      if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
    }
    else if (arg[0] == '-' AND arg[1] == '\0')
    {
      if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
    }
    else
    {
      int number = JOBS_MAX + 1;		/* illegal value */

      ignore readdecimal(arg, &number);
      if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
    }
  }
  job->notify = TRUE;
  return OK;
}

int b_onintr(
	     int argc,
	     char *argv[] )
{
  if (interactive) return error(ERR_TERMINAL, argv[0]);
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_popd(
	   int argc,
	   char *argv[] )
{
  char path[PATH_MAX + 1];

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    unless (popdir(path)) return error(ERR_STACKEMPTY, argv[0]);
    unless (changedir(path)) return syserr(path);
    dirs();
    return OK;
  }
  else if (argv[1][0] == '+')
  {
    int number = JOBS_MAX + 1;		/* illegal value */

    char *arg = readdecimal(argv[1] + 1, &number);

    if (*arg == '\0')
    {
      if(!number)
	{
        unless (popdir(path)) return error(ERR_STACKEMPTY, argv[0]);
	}
      else
	{
        unless (getdir(number-1, path)) return error(ERR_NOTTHATDEEP, argv[0]);
	}
      unless (changedir(path)) return syserr(path);
      return OK;
    }
  }
  return error(ERR_BADDIR, argv[0]);
}

#ifdef HELIOS
int b_printenv(
	       int argc,
	       char *argv[] )
{
  char **envp = environ;
  char *env;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  until ((env = *envp++) == NULL) printf("%s\n", env);
  return OK;
}
#endif

int b_pushd(
	    int argc,
	    char *argv[] )
{
  char path[PATH_MAX + 1];

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    unless (popdir(path)) return error(ERR_NOOTHERDIR, argv[0]);
    unless (pushdir(path)) return syserr(path);
    return OK;
  }
  else if (argv[1][0] == '+')
  {
    int number = JOBS_MAX + 1;		/* illegal value */
    char *arg = readdecimal(argv[1] + 1, &number);

    if (*arg == '\0')
    {
      if(!number)
	 {
         unless (popdir(path)) return error(ERR_NOOTHERDIR, argv[0]);
	 }
      else
	 {
         unless (getdir(number-1, path)) return error(ERR_NOTTHATDEEP, argv[0]);
	 }
      unless (pushdir(path)) return syserr(path);
      return OK;
    }
  }
  unless (pushdir(argv[1])) return syserr(argv[1]);
  return OK;
}

#ifdef HELIOS
int b_pwd(
	  int argc,
	  char *argv[] )
{
  char path[PATH_MAX + 1];

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (getcwd(path, PATH_MAX) == NULL) return syserr(argv[0]);
  printf("%s\n", path);
  return OK;
}
#endif

int b_rehash(
	     int argc,
	     char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  hash();
  return OK;
}

int b_repeat(
	     int argc,
	     char *argv[] )
{
  int count;
  char *arg;

  if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]);
  arg = readdecimal(argv[1], &count);
  unless (*arg == '\0') return error(ERR_BADNUMBER, argv[0]);
  while (count--)
  {
    if (testbreak()) return !OK;			
    ignore waitforcmd(runsimplecmd(dupargv(argv + 2), NULL, READ, WRITE, CHECKBUILTIN));
  }
  return OK;
}

int b_set(
	  int argc,
	  char *argv[] )
{
#ifdef	DEBUGGING
  DEBUG("bset(%s)",argv[1]);
#endif

  if (argc < 2) putvars();
  else
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv++) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char *text;
      char **newargv;
      int index;

      arg = readname(arg, name);
      
      if (name[0] == '\0')
	{
	  fprintf( stderr, "set: unable to read name of variable to set\n" );
	  
	  return error(ERR_SYNTAX, cmd);
	}
      
      switch (*arg++)
      {
        case '\0':
        if (strequ(*argv, "="))
        {
          argv++;
          if (strequ(*argv, "("))
          {
            newargv = nullargv();

            argv++;
            until (strequ(arg = *argv++, ")")) newargv = addword(newargv, arg);
             set(name, newargv); 
          }
          else set(name, makeargv(*argv++));
        }
        else set(name, makeargv(""));
        break;
 
        case '[':
        arg = readdecimal(arg, &index);
        unless (*arg++ == ']')
	  {
	    fprintf( stderr, "set: no closing ']' to match '['\n" );
	    return error(ERR_SYNTAX, cmd);
	  }
	
        if (*arg == '\0')
        {
          if (strequ(*argv, "="))
          {
            argv++;
            text = *argv++;
          }
          else text = "";
        }
        else
        {
          unless (*arg++ == '=')
	    {
	      fprintf( stderr, "no '=' following '[...]'\n" );
	      
	      return error(ERR_SYNTAX, cmd);
	    }
          text = arg;
        }
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
        break;

        case '=':
        unless (*arg == '\0') set(name, makeargv(arg));
        else
        {
          if (strequ(*argv, "("))
          {
            newargv = nullargv();

            argv++;
            until (strequ(arg = *argv++, ")")) newargv = addword(newargv, arg);
            set(name, newargv); 
          }
          else set(name, makeargv(""));
        }
        break;

        default:
	fprintf( stderr, "unknown character in set string: '%c'\n", *(arg - 1) );
        return error(ERR_SYNTAX, cmd);
      }
    } 
  }
  return OK;
}

int b_setenv(
	     int argc,
	     char *argv[] )
{
  if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  setenv(argv[1], argv[2]);
  return OK;
}

int b_shift(
	    int argc,
	    char *argv[] )
{
  char *name;
  char **oldargv;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc == 1) name = "argv";
  else name = argv[1];
  unless ((oldargv = findvar(name)) == NULL)
  {
    unless (lenargv(oldargv)) return error(ERR_NOMOREWORDS, argv[0]);
    set(name, dupargv(oldargv + 1));
    return OK;
  }
  return error(ERR_VARIABLE, name);
}

int b_source(
	     int argc,
	     char *argv[] )
{
  int savemode = mode;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  if (strequ("-h", argv[1]))
  {
  	if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]); /*jd*/
    if (record(argv[2])) return OK;
    return syserr(argv[2]);
  }
  setmode(MODE_EXECUTE);
  unsetmode(MODE_HISTORY);

  if (source(argv[1]))
  {
    mode = savemode;
    return OK;
  }
  mode = savemode;
  return syserr(argv[1]);
}

int b_stop(
	   int argc,
	   char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_suspend(
	      int argc,
	      char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_switch(
	     int argc,
	     char *argv[] )
{
  char line[LINE_MAX + 1];
  char *str;
  int nestcount = 1;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc < 4) return error(ERR_SYNTAX, argv[0]);
  if (argc > 4) return error(ERR_SYNTAX, argv[0]);
  initexprparse(argv + 1);
  unless (token == T_LPAREN) return error(ERR_SYNTAX, argv[0]);
  readexprtoken();
  str = currentword;
  readexprtoken();
  unless (token == T_RPAREN) return error(ERR_SYNTAX, argv[0]);
  do
  {
    char *lineptr;

    unless (getline(line, TRUE)) break;
    unless ((lineptr = getword(line)) == NULL)
    {
      if (strequ("switch", wordbuffer)) nestcount++;
      if (strequ("endsw", wordbuffer)) nestcount--;
      if (nestcount == 1)
      {
        if (strequ("default", wordbuffer)) break;
        if (strequ("default:", wordbuffer)) break;
        if (strequ("case", wordbuffer))
        {
          int length;

          unless (getword(lineptr) == NULL)
          {
            if (((length = strlen(wordbuffer)) > 0) AND
                (wordbuffer[length - 1] == ':')) wordbuffer[length - 1] = '\0';
            if (match(str, wordbuffer)) break;
          }
        }
      }
    }
  } while (nestcount > 0);
  return OK;
}

int b_time(
	   int argc,
	   char *argv[] )
{
#ifdef NEWCODE
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {

  }
  else
  {
    waitforcmd(runsimplecmd(dupargv(argv + 1), NULL, READ, WRITE, CHECKBUILTIN));
  }
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_umask(
	    int argc,
	    char *argv[] )
{
#ifdef UNIX
  char *arg;
  int mask;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    mask = umask(0);
    umask(mask);
    printf("%o\n", mask);
    return OK;
  }
  arg = readoctal(argv[1], &mask);
  unless (*arg == '\0') return error(ERR_MASK, argv[0]);
  umask(mask);
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_unalias(
	      int argc,
	      char *argv[] )
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *argv++) == NULL) unalias(arg);
  return OK;
}

int b_unhash(
	     int argc,
	     char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unhash();
  return OK;
}

int b_unlimit(
	      int argc,
	      char *argv[] )
{
#ifdef UNIX
  int i;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    for (i = 0; i < RESOURCE_MAX; i++) setlimit(i, -1);
  }
  else
  {
    if ((i = findresource(argv[1])) == -1) return error(ERR_LIMIT, argv[0]);
    setlimit(i, -1);
  }
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_unset(
	    int argc,
	    char *argv[] )
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *argv++) == NULL) unset(arg);
  return OK;
}

int b_unsetenv(
	       int argc,
	       char *argv[] )
{
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  delenv(argv[1]);
  return OK;
}

int b_version(
	      int argc,
	      char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  printf("%s\n", version);
  return OK;
}

int b_wait(
	   int argc,
	   char *argv[] )
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  waitforcmd(-1);
  return OK;
}

int b_while(
	    int argc,
	    char *argv[] )
{
  int savemode = mode;
  int retval = OK;
  EXPR *expr;
  int value;
  long position;
  long start, end;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  initexprparse(argv + 1);
  value = evaluate(expr = readexpr(0));
  freeexpr(expr);
  unless (token == T_NEWLINE) return error(ERR_EXPSYNTAX, argv[0]);
  position = lineposition;
  start = note();
  {
    int nestcount = 1;
    char line[LINE_MAX + 1];

    do
    {
      unless (getline(line, TRUE)) return error(ERR_NOEND, argv[0]);
      unless (getword(line) == NULL)
      {
        if (strequ("while", wordbuffer) OR
            strequ("foreach", wordbuffer)) nestcount++;
        if (strequ("end", wordbuffer)) nestcount--;
      }
    } while (nestcount > 0);
  }
  end = note();

  if (value)
  {
    newloop();
    unsetmode(MODE_HISTORY);

    point(start);
    do
    {
      unless (docmdline())
      {
        error(ERR_NOEND, argv[0]);
        retval = !OK;			
      }
    } until ((mode & MODE_END) || retval != OK);    
    unsetmode(MODE_END);
    if ((mode & MODE_BREAK) || retval != OK) {
#if 0
      unsetmode(MODE_BREAK); /* unneeded due to savemode */
#endif
      point(end);
      mode = savemode;
      oldloop();
      if (!inloop())
	setmode(MODE_HISTORY);
    }
    else {
      point(position);
      mode = savemode;
      unsetmode(MODE_HISTORY);
      oldloop();
    }
  }
  else if (!inloop())
	setmode(MODE_HISTORY);

  return retval;
}

int b_at(
	 int argc,
	 char *argv[] )
{
  if (argc == 1) putvars();
  else
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char buffer[NUMSTR_MAX + 1];
      EXPR *expr;
      char **newargv;
      char *text;
      int index = -1;

      arg = readname(arg, name);	/* read var name		*/
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);

      if (*arg == '[')			/* read index			*/
      {
        arg = readdecimal(arg + 1, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
      }

      if (*arg == '\0' && *++argv != NULL)	/* skip argument end	*/
        arg = *argv;

      if (*arg == '=')			/* '=' found, evaluate expr.	*/
      {
        if (*++arg == '\0')		/* end of argv element:		*/
        {
          if (*++argv != NULL)		/* take next element		*/
            arg = *argv;
          else 				/* or report error		*/
            return error(ERR_SYNTAX, cmd);
        }
        else    			/* expr starts in this element	*/
        {
          text = *argv;			/* copy it to the start		*/
          while ((*text++ = *arg++) != '\0');
        }
        initexprparse(argv);
        text = streval(buffer, expr = readexpr(0));
        freeexpr(expr);
        argv = wordlist;
      }
      else				/* no expression found		*/
      {
      	if (*arg == '\0')		/* nothing left in the element	*/
      	  argv++;
      	else				/* something more to process	*/
      	{
          text = *argv;			/* copy it to the start		*/
          while ((*text++ = *arg++) != '\0');
        }
      	text = "";			/* set empty value		*/
      }
      if (index < 0)
        set(name, makeargv(text));
      else
      {
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
      }
    }
  }
  return OK;
}

/**
*** A table of the known signals. This is used when examining the argument
*** specifying the signal number, and for the -l option.
**/
typedef struct signal_definition {
	char	*name;
	int	number;
} signal_definition;

static	signal_definition known_signals[] =
{	{ "ZERO",	 0	},
	{ "ABRT",	 1	},
	{ "FPE",	 2	},
	{ "ILL",	 3  	},
	{ "INT",	 4	},
	{ "SEGV",	 5	},
	{ "TERM",	 6	},
	{ "STAK",	 7	},
	{ "ALRM",	 8	},
	{ "HUP",	 9	},
	{ "PIPE",	10	},
	{ "QUIT",	11	},
	{ "TRAP",	12	},
	{ "USR1",	13	},
	{ "USR2",	14	},
	{ "CHLD",	15	},
	{ "URG",	16	},
	{ "CONT",	17	},
	{ "STOP",	18	},
	{ "TSTP",	19	},
	{ "TTIN",	20	},
	{ "TTOU",	21	},
	{ "WINCH",	22	},
	{ "SIB",	23	},
	{ "KILL",	31	},
	{ Null(char),	-1	}
};

/**
*** Work out the signal from the given argument. This signal may be:
***     1) a number between 0 and 31
***	2) a string corresponding to one of the known signals
**/
static	int	determine_signal(char *str)
{ int	result = 0;
  int	i;
  
  if (isdigit(*str))
   { char	*temp = str;
     while (isdigit(*temp))
      { result = (10 * result) + (*temp - '0');
        temp++;
      }
     if (*temp == '\0')
      { if ((result < 0) || (result > 31))
       	  return(-1);
      	return(result);
      }
   }

	/* The string is not a simple number */
  for (i = 0; known_signals[i].name != Null(char); i++)
   if (!mystrcmp(known_signals[i].name, str))
    return(known_signals[i].number);

  return(-1);    
}


/**
*** String comparison routine which is not case sensitive. It returns the
*** same result as strcmp, i.e. 0 for identical strings
**/
static int mystrcmp(char *ms1, char *ms2)
{ char *s1 = ms1;
  char *s2 = ms2; 
#define ToUpper(x) (islower(x) ? toupper(x) : x)
  
  for (;;)
   { if (*s1 == '\0')
       return((*s2 == '\0') ? 0 : -1);
     elif (*s2 == '\0')
       return(1);
     elif(ToUpper(*s1) < ToUpper(*s2))
       return(-1);
     elif(ToUpper(*s1) > ToUpper(*s2))
       return(1);
     else
       { s1++; s2++; }
   }
}


/**
*** This routine shows the signals known to the kill command. To produce
*** a reasonable format it assumes 80 columns and four characters per
*** signal.
**/
static	void	show_signals(void)
{ int	i, j;

  for (i = 0, j = 0; known_signals[i].name != Null(char); i++)
   { fputs(known_signals[i].name, stderr);
     fputc(' ', stderr);
     if (++j == 16)
      { fputc('\n', stderr);
        j = 0;
      }
   }
  unless (j == 0) fputc('\n', stderr);
}

/* internal which command (looks at alias list) */

int b_which(
	    int argc,
	    char *argv[] )
{
  char *arg, *name = argv[0];
  BOOL rungeneralwhich = FALSE;
  char **newargv = nullargv();
  char **aliasargv;

  newargv = addword(newargv, argv[0]);

  if (argc < 2) 
	{
	  freeargv(newargv);
	  return error(ERR_TOOFEWARGS, name);
	}
  until ((arg = *++argv) == NULL)
  {
	if((aliasargv = findalias(arg)) != NULL)
		{
		fprintf(stdout,"%s:	 aliased to ", arg);
		putargv(aliasargv, TRUE);
		}
	else
		{	
		newargv = addword(newargv, arg);
		rungeneralwhich = TRUE;
		}
  }
  if(rungeneralwhich)
     return(waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE, NOBUILTIN)));
  freeargv(newargv);
  return OK;
}
@


1.29
log
@fixed compile time warnings
@
text
@d1404 8
a1411 1
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);
d1433 6
a1438 1
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
d1450 6
a1455 1
          unless (*arg++ == '=') return error(ERR_SYNTAX, cmd);
d1481 1
@


1.28
log
@New version numbers
@
text
@a25 5
#ifdef HELIOS
#define MAX_BUILT 61
#else
#define MAX_BUILT 58
#endif
d436 2
a437 1
    return func == b_else  OR func == b_exit OR func == b_foreach OR
d439 1
a439 1
           func == b_while OR func == b_at;
d446 5
a450 4
  return func == b_cd      OR func == b_echo   OR func == b_eval   OR
         func == b_foreach OR func == b_glob   OR func == b_pushd  OR
         func == b_repeat  OR func == b_source OR func == b_switch OR
         func == b_time	   OR func == b_set;
d1816 1
a1816 1
        arg = readdecimal(++arg, &index);
@


1.27
log
@fixed compile time warnings
@
text
@d21 1
a21 1
char *version = "1.23\t10/04/92.\tDebug Version    Copyright (C) 1987 - 1992, Perihelion Software Ltd.";
d23 1
a23 1
char *version = "1.23\t10/04/92.\t    Copyright (C) 1987 - 1992, Perihelion Software Ltd.";
@


1.26
log
@added -a (all) option to kill
@
text
@d14 1
d16 1
d18 2
d117 1
a117 2
char *getword(line)
char *line;
d428 1
a428 2
void getlastword(line)
char *line;
d433 1
a433 2
BOOL isspecial(name)
char *name;
d448 1
a448 2
BOOL needsfullsubs(func)
int (*func)();
d456 1
a456 2
BUILTIN *findbuiltin(name)
char *name;
d469 3
a471 3
int b_alias(argc, argv)
int argc;
char *argv[];
d492 3
a494 3
int b_alloc(argc, argv)
int argc;
char *argv[];
d501 3
a503 3
int b_bg(argc, argv)
int argc;
char *argv[];
d509 3
a511 3
int b_break(argc, argv)
int argc;
char *argv[];
d520 3
a522 3
int b_breaksw(argc, argv)
int argc;
char *argv[];
d540 3
a542 3
int b_case(argc, argv)
int argc;
char *argv[];
d548 3
a550 3
int b_cd(argc, argv)
int argc;
char *argv[];
d564 3
a566 3
int b_continue(argc, argv)
int argc;
char *argv[];
d574 3
a576 3
int b_default(argc, argv)
int argc;
char *argv[];
d582 3
a584 3
int b_dirs(argc, argv)
int argc;
char *argv[];
d591 3
a593 3
int b_echo(argc, argv)
int argc;
char *argv[];
d609 3
a611 3
int b_else(argc, argv)
int argc;
char *argv[];
d635 3
a637 3
int b_end(argc, argv)
int argc;
char *argv[];
d645 3
a647 3
int b_endif(argc, argv)
int argc;
char *argv[];
d653 3
a655 3
int b_endsw(argc, argv)
int argc;
char *argv[];
d661 3
a663 3
int b_eval(argc, argv)
int argc;
char *argv[];
d672 3
a674 3
int b_exec(argc, argv)
int argc;
char *argv[];
d682 3
a684 3
int b_exit(argc, argv)
int argc;
char *argv[];
d709 3
a711 3
int b_fault(argc, argv)
int argc;
char *argv[];
d740 3
a742 3
int b_fg(argc, argv)
int argc;
char *argv[];
d780 3
a782 3
int b_foreach(argc, argv)
int argc;
char *argv[];
d845 3
a847 3
int b_glob(argc, argv)
int argc;
char *argv[];
d858 3
a860 3
int b_goto(argc, argv)
int argc;
char *argv[];
d881 3
a883 3
int b_hashstat(argc, argv)
int argc;
char *argv[];
d889 3
a891 3
int b_history(argc, argv)
int argc;
char *argv[];
d929 3
a931 3
int b_if(argc, argv)
int argc;
char *argv[];
d981 3
a983 3
int b_job(argc, argv)
int argc;
char *argv[];
d1011 3
a1013 3
int b_jobs(argc, argv)
int argc;
char *argv[];
d1020 3
a1022 3
int b_kill(argc, argv)
int argc;
char *argv[];
d1142 3
a1144 3
int b_label(argc, argv)
int argc;
char *argv[];
d1150 3
a1152 3
int b_limit(argc, argv)
int argc;
char *argv[];
d1182 3
a1184 3
int b_logout(argc, argv)
int argc;
char *argv[];
d1195 3
a1197 3
int b_nice(argc, argv)
int argc;
char *argv[];
d1203 3
a1205 3
int b_nohup(argc, argv)
int argc;
char *argv[];
d1211 3
a1213 3
int b_notify(argc, argv)
int argc;
char *argv[];
d1248 3
a1250 3
int b_onintr(argc, argv)
int argc;
char *argv[];
d1257 3
a1259 3
int b_popd(argc, argv)
int argc;
char *argv[];
d1295 3
a1297 3
int b_printenv(argc, argv)
int argc;
char *argv[];
d1308 3
a1310 3
int b_pushd(argc, argv)
int argc;
char *argv[];
d1345 3
a1347 3
int b_pwd(argc, argv)
int argc;
char *argv[];
d1358 3
a1360 3
int b_rehash(argc, argv)
int argc;
char *argv[];
d1367 3
a1369 3
int b_repeat(argc, argv)
int argc;
char *argv[];
d1385 3
a1387 3
int b_set(argc, argv)
int argc;
char *argv[];
d1474 3
a1476 3
int b_setenv(argc, argv)
int argc;
char *argv[];
d1484 3
a1486 3
int b_shift(argc, argv)
int argc;
char *argv[];
d1503 3
a1505 3
int b_source(argc, argv)
int argc;
char *argv[];
d1529 3
a1531 3
int b_stop(argc, argv)
int argc;
char *argv[];
d1537 3
a1539 3
int b_suspend(argc, argv)
int argc;
char *argv[];
d1545 3
a1547 3
int b_switch(argc, argv)
int argc;
char *argv[];
d1592 3
a1594 3
int b_time(argc, argv)
int argc;
char *argv[];
d1613 3
a1615 3
int b_umask(argc, argv)
int argc;
char *argv[];
d1639 3
a1641 3
int b_unalias(argc, argv)
int argc;
char *argv[];
d1650 3
a1652 3
int b_unhash(argc, argv)
int argc;
char *argv[];
d1659 3
a1661 3
int b_unlimit(argc, argv)
int argc;
char *argv[];
d1683 3
a1685 3
int b_unset(argc, argv)
int argc;
char *argv[];
d1694 3
a1696 3
int b_unsetenv(argc, argv)
int argc;
char *argv[];
d1704 3
a1706 3
int b_version(argc, argv)
int argc;
char *argv[];
d1713 3
a1715 3
int b_wait(argc, argv)
int argc;
char *argv[];
d1722 3
a1724 3
int b_while(argc, argv)
int argc;
char *argv[];
d1795 3
a1797 3
int b_at(argc, argv)
int argc;
char *argv[];
d1950 1
a1950 1
       return((*s2 == '\0') ? 0L : -1L);
d1952 1
a1952 1
       return(1L);
d1954 1
a1954 1
       return(-1L);
d1956 1
a1956 1
       return(1L);
d1984 3
a1986 3
int b_which(argc, argv)
int argc;
char *argv[];
@


1.25
log
@added filename substitution to builtin set command (Bug 831, 1000, 1009)
@
text
@d1055 8
@


1.24
log
@fixed history being permanently turned off by while loops
@
text
@d453 1
a453 1
         func == b_time;
@


1.23
log
@changed version number.
@
text
@d1749 1
d1765 4
a1768 3
    if ((mode & MODE_BREAK) || retval != OK)
    {
      unsetmode(MODE_BREAK);
d1770 10
a1780 4
    else point(position);
    mode = savemode;
    unsetmode(MODE_HISTORY);
    oldloop();
d1782 3
a1784 1
  
@


1.22
log
@initialised argument to readdecimal in case readdecimal did not return any
value in this parameter. Caused %blow bug.
@
text
@d17 1
a17 1
char *version = "1.22\t10/04/91.\tDebug Version    Copyright (C) 1987 - 1991, Perihelion Software Ltd.";
d19 1
a19 1
char *version = "1.22\t10/04/91.\t    Copyright (C) 1987 - 1991, Perihelion Software Ltd.";
@


1.21
log
@fixed popd and pushd +<n> processing
@
text
@d768 1
a768 1
      int number;
d1001 1
a1001 1
    int number;
d1101 1
a1101 1
        int number;
d1161 1
a1161 1
      int limit;
d1231 1
a1231 1
      int number;
d1266 2
a1267 1
    int number;
d1316 1
a1316 1
    int number;
@


1.20
log
@changed version number
@
text
@d1271 9
a1279 1
      unless (getdir(number, path)) return error(ERR_NOTTHATDEEP, argv[0]);
d1320 8
a1327 1
      unless (getdir(number, path)) return error(ERR_NOTTHATDEEP, argv[0]);
@


1.19
log
@mod to getword to fix bug #537
@
text
@d17 1
a17 1
char *version = "1.21\t26/03/91.\tDebug Version    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
d19 1
a19 1
char *version = "1.21\t26/03/91.\t    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
@


1.18
log
@changed runsimplecmd to allow for ignoring of builtin commands
@
text
@d355 1
@


1.17
log
@added internal which command to detect aliases
@
text
@d963 1
a963 1
            ignore waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE));
d977 1
a977 1
    ignore waitforcmd(runsimplecmd(dupargv(wordlist), NULL, READ, WRITE));
d1029 1
a1029 1
  newargv = addword(newargv, "/helios/bin/kill");
d1129 1
a1129 1
     return(waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE)));
d1356 1
a1356 1
    ignore waitforcmd(runsimplecmd(dupargv(argv + 2), NULL, READ, WRITE));
d1580 1
a1580 1
    waitforcmd(runsimplecmd(dupargv(argv + 1), NULL, READ, WRITE));
d1959 1
a1959 1
  newargv = addword(newargv, "/helios/bin/which");
d1980 1
a1980 1
     return(waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE)));
@


1.16
log
@fixed bug #569 - backslash has no special significance
within quotes
@
text
@d23 1
a23 1
#define MAX_BUILT 60
d25 1
a25 1
#define MAX_BUILT 57
d98 1
d1948 36
@


1.15
log
@changed version number
@
text
@d393 1
d398 1
@


1.14
log
@extra debugging
@
text
@d17 1
a17 1
char *version = "1.20\t22/11/90.\tDebug Version    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
d19 1
a19 1
char *version = "1.20\t22/11/90.\t    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
@


1.13
log
@allow for different signals to be send to different tasks
@
text
@d1362 4
@


1.12
log
@added -[signame|signum] to kill. If task name is specified,
the Helios kill command is invoked.
@
text
@d1021 1
a1021 1
  char *arg;
d1031 1
a1031 1
	  return error(ERR_TOOFEWARGS, argv[0]);
d1044 1
a1044 1
	      	  return error(ERR_TOOMANYARGS, argv[-1]);
d1054 1
a1054 1
	  return error(ERR_TOOFEWARGS, argv[-1]);
d1057 6
d1066 1
a1066 1
	  	return error(ERR_BADSIGNAL, argv[-1]);
@


1.11
log
@fix for bug #496 (while history)
@
text
@d28 4
d1022 3
d1026 7
a1032 1
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
d1037 31
d1075 5
a1079 1
        if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, *argv);
d1083 5
a1087 1
        if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, *argv);
d1094 5
a1098 1
        if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, *argv);
d1105 7
a1111 1
      unless (*arg == '\0') return error(ERR_BADNUMBER, NULL);
d1113 5
a1117 1
    if (kill(pid, SIGTERM) == -1) return syserr(NULL);
d1119 3
d1822 113
@


1.10
log
@ignore last log message - this is the real thing
@
text
@a1416 1
    setmode(MODE_HISTORY);
a1419 1
  setmode(MODE_HISTORY);
a1666 1
      setmode(MODE_HISTORY);
d1672 1
@


1.9
log
@fixes to fix shell background signal handling
@
text
@d1 1754
a1754 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                @


1.8
log
@more changes to fix CTRL-C and error recovery longjmp bugs
@
text
@d1 1
a1 1753
/**
*Title:  Helios Shell - Built-in Command Support.
*
* Author: Andy England
*
* Date:   May 1988
*
*         (c) Copyright 1988, Perihelion Software Ltd.
*
*         All Rights Reserved.
*
**/
#include "shell.h"

char *sccsid = "@@(#)builtin.c	1.18\t12/4/89 Copyright (C) 1988, Perihelion Software Ltd.";
#ifdef		DEBUGGING
char *version = "1.20\t22/11/90.\tDebug Version    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
#else
char *version = "1.20\t22/11/90.\t    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
#endif

#ifdef HELIOS
#define MAX_BUILT 60
#else
#define MAX_BUILT 57
#endif

BUILTIN  builtins[MAX_BUILT] =
{
  "alias", b_alias,
  "alloc", b_alloc,
  "bg", b_bg,
  "break", b_break,
  "breaksw", b_breaksw,
  "case", b_case,
  "cd", b_cd,
  "chdir", b_cd,
  "continue", b_continue,
  "default", b_default,
  "dirs", b_dirs,
  "echo", b_echo,
  "else", b_else,
  "end", b_end,
  "endif", b_endif,
  "endsw", b_endsw,
  "eval", b_eval,
  "exec", b_exec,
  "exit", b_exit,
#ifdef HELIOS
  "fault", b_fault,
#endif
  "fg", b_fg,
  "foreach", b_foreach,
  "glob", b_glob,
  "goto", b_goto,
  "hashstat", b_hashstat,
  "history", b_history,
  "if", b_if,
  "jobs", b_jobs,
  "kill", b_kill,
  "limit", b_limit,
/*  "login", b_login, - BLV 1.2 changes */
  "logout", b_logout,
  "nice", b_nice,
  "nohup", b_nohup,
  "notify", b_notify,
  "onintr", b_onintr,
  "popd", b_popd,
#ifdef HELIOS
  "printenv", b_printenv,
#endif
  "pushd", b_pushd,
#ifdef HELIOS
  "pwd", b_pwd,
#endif
  "rehash", b_rehash,
  "repeat", b_repeat,
  "set", b_set,
  "setenv", b_setenv,
  "shift", b_shift,
  "source", b_source,
  "stop", b_stop,
  "suspend", b_suspend,
  "switch", b_switch,
  "time", b_time,
  "umask", b_umask,
  "unalias", b_unalias,
  "unhash", b_unhash,
  "unlimit", b_unlimit,
  "unset", b_unset,
  "unsetenv", b_unsetenv,
  "version", b_version,
  "wait", b_wait,
  "while", b_while,
  "@@", b_at,
  0, 0
};

BUILTIN extrabuiltins[2] =
{
  ":", b_label,
  "%", b_job
};

int mode;
SUBSTATE wordstate;

char *getword(line)
char *line;
{
  int c;

#ifdef	DEBUGGING
  DEBUG("getword()");
#endif
  wordstate = NEUTRAL;
  forever
  {
    c = *line++;
    switch (wordstate)
    {
      case NEUTRAL:
      switch (c)
      {
        case ';':
        strcpy(wordbuffer, ";");
#ifdef	DEBUGGING
        DEBUG("='%s' (%S)",wordbuffer,line);
#endif
        return line;

        case '&':
        if (*line == '&')
        {
          line++;
          strcpy(wordbuffer, "&&");
          return line;
        }
        strcpy(wordbuffer, "&");
        return line;
       
        case '|':
        if (*line == '|')
        {
          line++;
#ifdef CDL
          if (usingcdl AND *line == '|')
          {
            line++;
            strcpy(wordbuffer, "|||");
            return line;
          }
#endif
          strcpy(wordbuffer, "||");
          return line;
        }
#ifdef CDL
        if (usingcdl)
        {
          if (*line == '<')
          {
            line++;
            strcpy(wordbuffer, "|<");
            return line;
          }
          if (*line == '>')
          {
            line++;
            strcpy(wordbuffer, "|>");
            return line;
          }
        }
#endif
        strcpy(wordbuffer, "|");
        return line;

        case '<':
        if (*line == '<')
        {
          line++;
          strcpy(wordbuffer, "<<");
          return line;
        }
#ifdef CDL
        if (usingcdl)
        {
          if (*line == '>')
          {
            line++;
            strcpy(wordbuffer, "<>");
            return line;
          }
          if (*line == '|')
          {
            line++;
            strcpy(wordbuffer, "<|");
            return line;
          }
        }
#endif
        strcpy(wordbuffer, "<");
        return line;
       
        case '>':
                       	
        if (*line == '>')
        {
          line++;
          if (*line == '2')
          {
            line++;
            strcpy(wordbuffer, ">>2");
#ifdef	DEBUGGING
  	    DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
            return line;
          }
          strcpy(wordbuffer, ">>");
          return line;
        }
        if (*line == '2')
        {
          line++;
          strcpy(wordbuffer, ">2");
#ifdef	DEBUGGING
  	  DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
          return line;
        }
#ifdef CDL
        if (usingcdl AND *line == '|')
        {
          line++;
          strcpy(wordbuffer, ">|");
          return line;
        }
#endif
        strcpy(wordbuffer, ">");
        return line;

#ifdef CDL
        case '^':
        if (usingcdl AND *line == '^')
        {
          line++;
          strcpy(wordbuffer, "^^");
          return line;
        }
        line--;
        wordstate = INWORD;
        continue;
#endif

        case '(':
        strcpy(wordbuffer, "(");
        parencount++;
        return line;

        case ')':
        strcpy(wordbuffer, ")");
        parencount--;
        return line;

	case '@@':			/* the @@ symbol might refer to	*/
					/* the at shell function or is	*/
					/* part of an encoded capability*/
	{
  	  int i;
	  for (i = 0; i < 16; i++)
	    if (line[i] < 'a' || line[i] > 'p') break;

	  if (i == 16 && line[i] == '/')
	  {
	    line--;			/* seems to be a capability...	*/
	    wordstate = INWORD;		/* read it as a word.		*/
	    continue;
	  }
          strcpy(wordbuffer, "@@");
#ifdef	DEBUGGING
  	  DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
          return line;
        }

        case '\n':
        case '\0':
        return NULL;

        case ' ':
        case '\t':
        continue;

        default:
        line--;
        wordstate = INWORD;
        continue;
      }

      case INWORD:
      switch (c)
      {
        case ';':
        case '&':
        case '|':
        case '<':
        case '>':
        case '(':
        case ')':
        case '\n':
        case '\0':
        case ' ':
        case '\t':
        ignore endword();
        wordstate = NEUTRAL;
        return line - 1;

#ifdef CDL
        case '^':
        if (usingcdl AND *line == '^')
        {
          ignore endword();
          wordstate = NEUTRAL;
          return line - 1;
        }
        addchar('^');
        continue;
#endif

        case '\\':
        if (*line == '\n')
        {
          line++;
          if (wordindex > 0) addchar(' ');
          else wordstate = NEUTRAL;
          continue;
        }
        addchar('\\');
        addchar(*line++);
        continue;

        case '$':
        addchar('$');
        if (*line == '\n') continue;
        if (*line == '{')
        {
          line++;
          addchar('{');
          if (*line == '\n') continue;
        }
        addchar(*line++);
        continue;

        case '\'':
        addchar('\'');
        wordstate = INSQUOTE;
        continue;
        
        case '`':
        addchar('`');
        wordstate = INBQUOTE;
        continue;

        case '\"':
        addchar('"');
        wordstate = INDQUOTE;
        continue;

        case '#':
        unless (interactive)
        {
          do c = *line++; until (c == '\0' OR c == '\n');
          return NULL;
        }
        default:
        addchar(c);
        continue;
      }

      case INSQUOTE:
      case INBQUOTE:
      case INDQUOTE:
      switch (c)
      {
        case '\n':
        case '\0':
        ignore endword();
        return line - 1;

        case '\\':
        addchar('\\');
        addchar(*line++);
        continue;

        case '\'':
        addchar('\'');
        if (wordstate == INSQUOTE) wordstate = INWORD;
        continue;

        case '`':
        addchar('`');
        if (wordstate == INBQUOTE) wordstate = INWORD;
        continue;

        case '"':
        addchar('"');
        if (wordstate == INDQUOTE) wordstate = INWORD;
        continue;

        default:
        addchar(c);
        continue;
      }
    }
  }
}

void getlastword(line)
char *line;
{
  until ((line = getword(line)) == NULL);
}

BOOL isspecial(name)
char *name;
{
  BUILTIN *builtin;

  unless ((builtin = findbuiltin(name)) == NULL)
  {
    int (*func)() = builtin->func;

    return func == b_else  OR func == b_exit OR func == b_foreach OR
           func == b_if    OR func == b_set  OR func == b_switch  OR
           func == b_while OR func == b_at;
  }
  return FALSE;
}

BOOL needsfullsubs(func)
int (*func)();
{
  return func == b_cd      OR func == b_echo   OR func == b_eval   OR
         func == b_foreach OR func == b_glob   OR func == b_pushd  OR
         func == b_repeat  OR func == b_source OR func == b_switch OR
         func == b_time;
}

BUILTIN *findbuiltin(name)
char *name;
{
  BUILTIN *builtin;

  if (name[strlen(name) - 1] == ':') return &extrabuiltins[0];
  if (name[0] == '%') return &extrabuiltins[1];
  for (builtin = builtins; builtin->name; builtin++)
  {
    if (strequ(name, builtin->name)) return builtin;
  }
  return NULL;
}

int b_alias(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) putalias();
  else
  {
    char *name = argv[1];

    if (argc == 2)
    {
      unless ((argv = findalias(name)) == NULL) putargv(argv, TRUE);
    }
    else
    {
      if (strequ(name, "alias") OR strequ(name, "unalias"))
        return error(ERR_DANGEROUS, name);
      alias(name, dupargv(argv + 2));
    }
  }
  return OK;
}

int b_alloc(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  putmem();
  return OK;
}

int b_bg(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_break(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_BREAK);
  setmode(MODE_END);
  return OK;
}

int b_breaksw(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];
  int nestcount = 1;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  do
  {
    unless (getline(line, TRUE)) return error(ERR_NOENDSW, argv[0]);
    unless (getword(line) == NULL)
    {
      if (strequ("switch", wordbuffer)) nestcount++;
      if (strequ("endsw", wordbuffer)) nestcount--;
    }
  } while (nestcount > 0);
  return OK;
}

int b_case(argc, argv)
int argc;
char *argv[];
{
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_cd(argc, argv)
int argc;
char *argv[];
{
  char *name;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((name = getvar("home")) == NULL) return error(ERR_NOHOME, NULL);
  }
  else name = argv[1];
  unless (changedir(name)) return syserr(name);
  return OK;
}

int b_continue(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_END);
  return OK;
}

int b_default(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_dirs(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (dirs()) return syserr(argv[0]);
  return OK;
}

int b_echo(argc, argv)
int argc;
char *argv[];
{
  if (argc >= 1)
  {
    BOOL newline = TRUE;

    if (strequ(*++argv, "-n")) 
    {
      argv++;
      newline = FALSE;
    }
    putargv(argv, newline);
  }
  return OK;
}

int b_else(argc, argv)
int argc;
char *argv[];
{
  int nestcount = 1;
  char line[LINE_MAX + 1];

  do
  {
    char *lineptr;

    unless (getline(line, TRUE)) return error(ERR_NOENDIF, argv[0]);
    unless ((lineptr = getword(line)) == NULL)
    {
      if (strequ("endif", wordbuffer)) nestcount--;
      if (strequ("if", wordbuffer))
      {
        getlastword(lineptr);
        if (strequ("then", wordbuffer)) nestcount++;
      }
    }
  } while (nestcount > 0);
  return OK;
  argc = argc;				/* keep the compiler happy...	*/
}

int b_end(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_END);
  return OK;
}

int b_endif(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_endsw(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_eval(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];

  sputargv(line, argv + 1, ' ');
  return runcmdline(line);
  argc = argc;				/* keep the compiler happy...	*/
}

int b_exec(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  executecmd(argv[1], argv+1);
  return error(ERR_NOTFOUND, argv[1]);	/* CFL	Fix to bug #261		*/
  return OK;
}

int b_exit(argc, argv)
int argc;
char *argv[];
{
  int code;

  if (argc > 1)
  {
    EXPR *expr;

    initexprparse(argv + 1);
    code = evaluate(expr = readexpr(0));
    freeexpr(expr);
  }
  else
  {
    char *status;

    if ((status = getvar("status")) == NULL) code = OK;
    else code = atoi(status);
  }
  freeargv(argv);
  logout(code);
  return OK;
}

#ifdef HELIOS
int b_fault(argc, argv)
int argc;
char *argv[];
{
  int code;

  if (argc > 1)
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv++) == NULL)
    {
      if (strlen(arg) < 8) arg = readdecimal(arg, &code);
      else arg = readhex(arg, &code);
      unless (*arg == '\0') return error(ERR_BADNUMBER, cmd);
      fault(code);
    }
  }
  else
  {
    char *error;

    if ((error = getvar("error")) == NULL) code = OK;
    else code = atoi(error);
    fault(code);
  }
  return OK;
}
#endif

int b_fg(argc, argv)
int argc;
char *argv[];
{
  JOB *job;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else
  {
    char *arg = argv[1];

    unless (*arg++ == '%') return error(ERR_NOSUCHJOB, argv[0]);
    if (arg[0] == '\0' OR
        ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
    {
      if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
    }
    else if (arg[0] == '-' AND arg[1] == '\0')
    {
      if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
    }
    else
    {
      int number;

      ignore readdecimal(arg, &number);
      if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
    }
  }
  putcmd(job->cmd);
  printf("\n");
  waitforcmd(job->pid);
  return OK;
}

int b_foreach(argc, argv)
int argc;
char *argv[];
{
  char name[VARNAME_MAX + 1];
  int savemode = mode;
  int retval = OK;
  char *arg;
  int i;
  long start, end;

  if (argc < 4) return error(ERR_TOOFEWARGS, argv[0]);
  arg = readname(argv[1], name);
  unless (*arg == '\0') return error(ERR_INVALIDVAR, argv[0]);
  unless (strequ(argv[2], "(") AND strequ(argv[argc - 1], ")"))
    return error(ERR_WORDLIST, argv[0]);
  start = note();
  {
    int nestcount = 1;
    char line[LINE_MAX + 1];

    do
    {
      unless (getline(line, TRUE)) return error(ERR_NOEND, argv[0]);
      unless (getword(line) == NULL)
      {
        if (strequ("while", wordbuffer) OR
            strequ("foreach", wordbuffer)) nestcount++;
        if (strequ("end", wordbuffer)) nestcount--;
      }
    } while (nestcount > 0);
  }
  end = note();
  if (argc > 4)
  {
    newloop();
    unsetmode(MODE_HISTORY);

    for (i = 3; i < argc - 1; i++)
    {
      point(start);
      set(name, makeargv(argv[i]));
      do
      {
        unless (docmdline())
        {
          error(ERR_NOEND, argv[0]);
          retval = !OK;			
        }
      } until ((mode & MODE_END) || retval != OK);    
      unsetmode(MODE_END);
      if ((mode & MODE_BREAK) || retval != OK)		
      {
        unsetmode(MODE_BREAK);
        point(end);
        break;
      }
    }
    mode = savemode;
    oldloop();
    point(end);				/* CFL	Fix to bug #130		*/
  }
  return retval;			
}

int b_glob(argc, argv)
int argc;
char *argv[];
{
  while (--argc)
  {
    printf("%s", *++argv);
    if (argc > 1) putchar('\0');
    fflush(stdout);
  }
  return OK;
}

int b_goto(argc, argv)
int argc;
char *argv[];
{
  char line[WORD_MAX + 1];
  char label[WORD_MAX + 1];

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  rewindinput();
  strcpy(label, argv[1]);
  strcat(label, ":");
  forever
  {
    unless (getline(line, TRUE)) return error(ERR_NOLABEL, argv[1]);
    unless (getword(line) == NULL)
    {
      if (strequ(label, wordbuffer)) break;
    }
  }
  return OK;
}

int b_hashstat(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_history(argc, argv)
int argc;
char *argv[];
{
  char *history;
  char *cmd = *argv++;
  BOOL reverse = FALSE;
  BOOL nonames = FALSE;
  int number = 0;
  char *arg;

#ifdef	DEBUGGING
  DEBUG("b_history (%V)", argv);
#endif
  unless ((history = getvar("history")) == NULL)
    number = atoi(history);

  while ((arg = *argv) != NULL AND *arg++ == '-')
  {
    argv++;
    while (*arg != '\0')
      switch (*arg++)
      {
        case 'h' : nonames = TRUE; break;
        case 'r' : reverse = TRUE; break;
        default  : return error(ERR_BADOPTION, cmd);
      }
  }

  if ((arg = *argv) != NULL)
  {
    arg = readdecimal(arg, &number);
    if (*arg != '\0') return error(ERR_BADNUMBER, cmd);
  }
  putsublist(&historylist, number, nonames, TRUE, reverse);

  return OK;
  argc = argc;				/* keep the compiler happy...	*/
}

int b_if(argc, argv)
int argc;
char *argv[];
{
  EXPR *expr;
  int value;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  initexprparse(argv + 1);
  value = evaluate(expr = readexpr(0));
  freeexpr(expr);
  if (token == T_NEWLINE) return error(ERR_EMPTYIF, argv[0]);
  if (strequ(currentword, "then"))
  {
    readexprtoken();
    unless (token == T_NEWLINE) return error(ERR_THEN, argv[0]);
    unless (value)
    {
      int nestcount = 1;
      char line[LINE_MAX + 1];

      do
      {
        char *lineptr;

        unless (getline(line, TRUE)) return error(ERR_NOELSE, "then");
        unless ((lineptr = getword(line)) == NULL)
        {
          if (nestcount == 1 AND strequ("else", wordbuffer))
          {
            char **newargv = nullargv();

            until ((lineptr = getword(lineptr)) == NULL)
              newargv = addword(newargv, wordbuffer);
            ignore waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE));
            break;
          }
          if (strequ("endif", wordbuffer)) nestcount--;
          if (strequ("if", wordbuffer))
          {
            getlastword(lineptr);
            if (strequ("then", wordbuffer)) nestcount++;
          }
        }
      } while (nestcount > 0);
    }
  }
  else if (value)
    ignore waitforcmd(runsimplecmd(dupargv(wordlist), NULL, READ, WRITE));
  return OK;
}

int b_job(argc, argv)
int argc;
char *argv[];
{
  JOB *job;
  char *arg = argv[0] + 1;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (arg[0] == '\0' OR
      ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else if (arg[0] == '-' AND arg[1] == '\0')
  {
    if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
  }
  else
  {
    int number;

    ignore readdecimal(arg, &number);
    if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
  }
  putcmd(job->cmd);
  printf("\n");
  waitforcmd(job->pid);
  return OK;
}

int b_jobs(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  putjobtable();
  return OK;
}

int b_kill(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *++argv) == NULL)
  {
    int pid;

    if (arg[0] == '%')
    {
      JOB *job;

      if (arg[1] == '\0' OR
          ((arg[1] == '%' OR arg[1] == '+') AND arg[2] == '\0'))
      {
        if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, *argv);
      }
      else if (arg[1] == '-' AND arg[2] == '\0')
      {
        if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, *argv);
      }
      else
      {
        int number;

        ignore readdecimal(&arg[1], &number);
        if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, *argv);
      }
      pid = job->pid;
    }
    else
    {
      arg = readdecimal(arg, &pid);
      unless (*arg == '\0') return error(ERR_BADNUMBER, NULL);
    }
    if (kill(pid, SIGTERM) == -1) return syserr(NULL);
  }
  return OK;
}

int b_label(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_limit(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  int i;

  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    for (i = 1; i < RESOURCE_MAX; i++) putlimit(i);
  }
  else
  {
    if ((i  = findresource(argv[1])) == -1) return error(ERR_LIMIT, argv[0]);
    if (argc == 2) putlimit(i);
    else
    {
      int limit;
      char *arg = readdecimal(argv[2], &limit);

      unless (*arg == '\0') return error(ERR_SCALEFACTOR, argv[0]);
      setlimit(i, limit);
    }
  }
  return OK;
#else
  if (argc > 1) error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_logout(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (login)
  {
    freeargv(argv);
    logout(OK);
  }
  return error(ERR_NOTLOGIN, NULL);
}

int b_nice(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_nohup(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_notify(argc, argv)
int argc;
char *argv[];
{
  JOB *job;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else
  {
    char *arg = argv[1];

    unless (*arg++ == '%') return error(ERR_NOSUCHJOB, argv[0]);
    if (arg[0] == '\0' OR
        ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
    {
      if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
    }
    else if (arg[0] == '-' AND arg[1] == '\0')
    {
      if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
    }
    else
    {
      int number;

      ignore readdecimal(arg, &number);
      if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
    }
  }
  job->notify = TRUE;
  return OK;
}

int b_onintr(argc, argv)
int argc;
char *argv[];
{
  if (interactive) return error(ERR_TERMINAL, argv[0]);
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_popd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    unless (popdir(path)) return error(ERR_STACKEMPTY, argv[0]);
    unless (changedir(path)) return syserr(path);
    dirs();
    return OK;
  }
  else if (argv[1][0] == '+')
  {
    int number;
    char *arg = readdecimal(argv[1] + 1, &number);

    if (*arg == '\0')
    {
      unless (getdir(number, path)) return error(ERR_NOTTHATDEEP, argv[0]);
      return OK;
    }
  }
  return error(ERR_BADDIR, argv[0]);
}

#ifdef HELIOS
int b_printenv(argc, argv)
int argc;
char *argv[];
{
  char **envp = environ;
  char *env;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  until ((env = *envp++) == NULL) printf("%s\n", env);
  return OK;
}
#endif

int b_pushd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    unless (popdir(path)) return error(ERR_NOOTHERDIR, argv[0]);
    unless (pushdir(path)) return syserr(path);
    return OK;
  }
  else if (argv[1][0] == '+')
  {
    int number;
    char *arg = readdecimal(argv[1] + 1, &number);

    if (*arg == '\0')
    {
      unless (getdir(number, path)) return error(ERR_NOTTHATDEEP, argv[0]);
      unless (pushdir(path)) return syserr(path);
      return OK;
    }
  }
  unless (pushdir(argv[1])) return syserr(argv[1]);
  return OK;
}

#ifdef HELIOS
int b_pwd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (getcwd(path, PATH_MAX) == NULL) return syserr(argv[0]);
  printf("%s\n", path);
  return OK;
}
#endif

int b_rehash(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  hash();
  return OK;
}

int b_repeat(argc, argv)
int argc;
char *argv[];
{
  int count;
  char *arg;

  if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]);
  arg = readdecimal(argv[1], &count);
  unless (*arg == '\0') return error(ERR_BADNUMBER, argv[0]);
  while (count--)
  {
    if (testbreak()) return !OK;			
    ignore waitforcmd(runsimplecmd(dupargv(argv + 2), NULL, READ, WRITE));
  }
  return OK;
}

int b_set(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) putvars();
  else
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv++) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char *text;
      char **newargv;
      int index;

      arg = readname(arg, name);
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);
      switch (*arg++)
      {
        case '\0':
        if (strequ(*argv, "="))
        {
          argv++;
          if (strequ(*argv, "("))
          {
            newargv = nullargv();

            argv++;
            until (strequ(arg = *argv++, ")")) newargv = addword(newargv, arg);
             set(name, newargv); 
          }
          else set(name, makeargv(*argv++));
        }
        else set(name, makeargv(""));
        break;
 
        case '[':
        arg = readdecimal(arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
        if (*arg == '\0')
        {
          if (strequ(*argv, "="))
          {
            argv++;
            text = *argv++;
          }
          else text = "";
        }
        else
        {
          unless (*arg++ == '=') return error(ERR_SYNTAX, cmd);
          text = arg;
        }
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
        break;

        case '=':
        unless (*arg == '\0') set(name, makeargv(arg));
        else
        {
          if (strequ(*argv, "("))
          {
            newargv = nullargv();

            argv++;
            until (strequ(arg = *argv++, ")")) newargv = addword(newargv, arg);
            set(name, newargv); 
          }
          else set(name, makeargv(""));
        }
        break;

        default:
        return error(ERR_SYNTAX, cmd);
      }
    } 
  }
  return OK;
}

int b_setenv(argc, argv)
int argc;
char *argv[];
{
  if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  setenv(argv[1], argv[2]);
  return OK;
}

int b_shift(argc, argv)
int argc;
char *argv[];
{
  char *name;
  char **oldargv;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc == 1) name = "argv";
  else name = argv[1];
  unless ((oldargv = findvar(name)) == NULL)
  {
    unless (lenargv(oldargv)) return error(ERR_NOMOREWORDS, argv[0]);
    set(name, dupargv(oldargv + 1));
    return OK;
  }
  return error(ERR_VARIABLE, name);
}

int b_source(argc, argv)
int argc;
char *argv[];
{
  int savemode = mode;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  if (strequ("-h", argv[1]))
  {
  	if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]); /*jd*/
    if (record(argv[2])) return OK;
    return syserr(argv[2]);
  }
  setmode(MODE_EXECUTE);
  unsetmode(MODE_HISTORY);

  if (source(argv[1]))
  {
    mode = savemode;
    setmode(MODE_HISTORY);
    return OK;
  }
  mode = savemode;
  setmode(MODE_HISTORY);
  return syserr(argv[1]);
}

int b_stop(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_suspend(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_switch(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];
  char *str;
  int nestcount = 1;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc < 4) return error(ERR_SYNTAX, argv[0]);
  if (argc > 4) return error(ERR_SYNTAX, argv[0]);
  initexprparse(argv + 1);
  unless (token == T_LPAREN) return error(ERR_SYNTAX, argv[0]);
  readexprtoken();
  str = currentword;
  readexprtoken();
  unless (token == T_RPAREN) return error(ERR_SYNTAX, argv[0]);
  do
  {
    char *lineptr;

    unless (getline(line, TRUE)) break;
    unless ((lineptr = getword(line)) == NULL)
    {
      if (strequ("switch", wordbuffer)) nestcount++;
      if (strequ("endsw", wordbuffer)) nestcount--;
      if (nestcount == 1)
      {
        if (strequ("default", wordbuffer)) break;
        if (strequ("default:", wordbuffer)) break;
        if (strequ("case", wordbuffer))
        {
          int length;

          unless (getword(lineptr) == NULL)
          {
            if (((length = strlen(wordbuffer)) > 0) AND
                (wordbuffer[length - 1] == ':')) wordbuffer[length - 1] = '\0';
            if (match(str, wordbuffer)) break;
          }
        }
      }
    }
  } while (nestcount > 0);
  return OK;
}

int b_time(argc, argv)
int argc;
char *argv[];
{
#ifdef NEWCODE
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {

  }
  else
  {
    waitforcmd(runsimplecmd(dupargv(argv + 1), NULL, READ, WRITE));
  }
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_umask(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  char *arg;
  int mask;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    mask = umask(0);
    umask(mask);
    printf("%o\n", mask);
    return OK;
  }
  arg = readoctal(argv[1], &mask);
  unless (*arg == '\0') return error(ERR_MASK, argv[0]);
  umask(mask);
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_unalias(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *argv++) == NULL) unalias(arg);
  return OK;
}

int b_unhash(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unhash();
  return OK;
}

int b_unlimit(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  int i;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    for (i = 0; i < RESOURCE_MAX; i++) setlimit(i, -1);
  }
  else
  {
    if ((i = findresource(argv[1])) == -1) return error(ERR_LIMIT, argv[0]);
    setlimit(i, -1);
  }
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_unset(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *argv++) == NULL) unset(arg);
  return OK;
}

int b_unsetenv(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  delenv(argv[1]);
  return OK;
}

int b_version(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  printf("%s\n", version);
  return OK;
}

int b_wait(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  waitforcmd(-1);
  return OK;
}

int b_while(argc, argv)
int argc;
char *argv[];
{
  int savemode = mode;
  int retval = OK;
  EXPR *expr;
  int value;
  long position;
  long start, end;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  initexprparse(argv + 1);
  value = evaluate(expr = readexpr(0));
  freeexpr(expr);
  unless (token == T_NEWLINE) return error(ERR_EXPSYNTAX, argv[0]);
  position = lineposition;
  start = note();
  {
    int nestcount = 1;
    char line[LINE_MAX + 1];

    do
    {
      unless (getline(line, TRUE)) return error(ERR_NOEND, argv[0]);
      unless (getword(line) == NULL)
      {
        if (strequ("while", wordbuffer) OR
            strequ("foreach", wordbuffer)) nestcount++;
        if (strequ("end", wordbuffer)) nestcount--;
      }
    } while (nestcount > 0);
  }
  end = note();
  if (value)
  {
    newloop();
    unsetmode(MODE_HISTORY);

    point(start);
    do
    {
      unless (docmdline())
      {
        error(ERR_NOEND, argv[0]);
        retval = !OK;			
      }
    } until ((mode & MODE_END) || retval != OK);    
    unsetmode(MODE_END);
    if ((mode & MODE_BREAK) || retval != OK)
    {
      setmode(MODE_HISTORY);
      unsetmode(MODE_BREAK);
      point(end);
    }
    else point(position);
    mode = savemode;
    oldloop();
  }
  
  return retval;
}

int b_at(argc, argv)
int argc;
char *argv[];
{
  if (argc == 1) putvars();
  else
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char buffer[NUMSTR_MAX + 1];
      EXPR *expr;
      char **newargv;
      char *text;
      int index = -1;

      arg = readname(arg, name);	/* read var name		*/
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);

      if (*arg == '[')			/* read index			*/
      {
        arg = readdecimal(++arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
      }

      if (*arg == '\0' && *++argv != NULL)	/* skip argument end	*/
        arg = *argv;

      if (*arg == '=')			/* '=' found, evaluate expr.	*/
      {
        if (*++arg == '\0')		/* end of argv element:		*/
        {
          if (*++argv != NULL)		/* take next element		*/
            arg = *argv;
          else 				/* or report error		*/
            return error(ERR_SYNTAX, cmd);
        }
        else    			/* expr starts in this element	*/
        {
          text = *argv;			/* copy it to the start		*/
          while ((*text++ = *arg++) != '\0');
        }
        initexprparse(argv);
        text = streval(buffer, expr = readexpr(0));
        freeexpr(expr);
        argv = wordlist;
      }
      else				/* no expression found		*/
      {
      	if (*arg == '\0')		/* nothing left in the element	*/
      	  argv++;
      	else				/* something more to process	*/
      	{
          text = *argv;			/* copy it to the start		*/
          while ((*text++ = *arg++) != '\0');
        }
      	text = "";			/* set empty value		*/
      }
      if (index < 0)
        set(name, makeargv(text));
      else
      {
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
      }
    }
  }
  return OK;
}
@


1.7
log
@version number change
@
text
@d15 1
a15 1
char *sccsid = "@@(#)builtin.c	1.20\t22/11/90 Copyright (C) 1988, Perihelion Software Ltd.";
d22 7
a28 1
BUILTIN  builtins[] =
a776 2
  jmp_buf savehome;			/* CFL	foreach should switch	*/
  int result;				/*	history recording off	*/
d778 1
d809 1
a809 7
    memcpy (savehome, home, sizeof (jmp_buf));	/* set up safety net	*/
    if ((result = catch ()) != 0)		/* and catch error exit	*/
    {
      mode = savemode;
      memcpy (home, savehome, sizeof (jmp_buf));
      throw (result);
    }
a817 2
          mode = savemode;
          memcpy (home, savehome, sizeof (jmp_buf));
d819 1
a819 1
          recover();
d821 1
a821 1
      } until (mode & MODE_END);
d823 1
a823 1
      if (mode & MODE_BREAK)
a830 1
    memcpy (home, savehome, sizeof (jmp_buf));
d834 1
a834 1
  return OK;
a884 1
#if	1
a916 34
#else
  if (argc < 2)
  {
    char *history;

    unless ((history = getvar("history")) == NULL)
      putsublist(&historylist, atoi(history), FALSE, TRUE, FALSE);
  }
  else
  {
    char *cmd = *argv++;
    BOOL reverse = FALSE;
    BOOL nonames = FALSE;
    int number = 100;
    char *arg;

    if (strequ(*argv, "-h"))
    {
      argv++;
      nonames = TRUE;
    }
    if ((arg = *argv) != NULL AND strequ(arg, "-r"))
    {
      argv++;
      reverse = TRUE;
    }
    unless ((arg = *argv) == NULL)
    {
      arg = readdecimal(arg, &number);
      unless (*arg == '\0') return error(ERR_BADNUMBER, cmd);
    }
    putsublist(&historylist, number, nonames, TRUE, reverse);
  }
#endif
a1094 15
#if 0 /* BLV 1.2 changes */
int b_login(argc, argv)
int argc;
char *argv[];
{
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (login)
  {
    execv(LOGIN_CMD, argv);
    return syserr(LOGIN_CMD);
  }
  return error(ERR_NOTLOGIN, NULL);
}
#endif

d1276 1
a1276 1
    if (testbreak()) recover();
a1399 2
  jmp_buf savehome;			/* CFL	Fix to bug #182		*/
  int result;				/*				*/
d1412 1
a1412 7
  memcpy (savehome, home, sizeof (jmp_buf));	/* set up private net	*/
  if ((result = catch ()) != 0)		/* and catch the error exit	*/
  {
    mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
    throw (result);
  }
a1415 1
    memcpy (home, savehome, sizeof (jmp_buf));
d1420 1
a1420 2
    memcpy (home, savehome, sizeof (jmp_buf));
    setmode(MODE_HISTORY);
a1620 2
  jmp_buf savehome;			/* CFL	while should not record	*/
  int result;				/*	history			*/
d1622 1
d1655 2
a1656 8
    memcpy (savehome, home, sizeof (jmp_buf));	/* set up safety net	*/
    if ((result = catch ()) != 0)		/* and catch error exit	*/
    {
      mode = savemode;
      memcpy (home, savehome, sizeof (jmp_buf));
      throw (result);
    }
   point(start);
d1661 2
a1662 4
           mode = savemode;
        memcpy (home, savehome, sizeof (jmp_buf));
      	error(ERR_NOEND, argv[0]);
      	recover();
d1664 1
a1664 1
    } until (mode & MODE_END);
d1666 1
a1666 1
    if (mode & MODE_BREAK)
d1668 1
d1673 2
a1674 3
     mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
   oldloop();
a1675 2
  if (value == 1) unsetmode(MODE_HISTORY);   /* JD BUG FIX No - 384*/
  else if (value == 0) setmode(MODE_HISTORY);
d1677 1
a1677 1
  return OK;
a1689 1
#if 1
a1750 90
#else
    until ((arg = *argv++) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char buffer[NUMSTR_MAX + 1];
      EXPR *expr;
      char **newargv;
      char *text;
      int index;

      arg = readname(arg, name);
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);
      switch (*arg++)
      {
        case '\0':
        if (strequ(*argv, "="))
        {
          argv++;
#ifdef JON
	  if (*argv == NULL)
	    set(name, makeargv(""));
	  else
	  {
#endif
          initexprparse(argv);
          set(name, makeargv(streval(buffer, expr = readexpr(0))));
          freeexpr(expr);
          argv = wordlist;
#ifdef JON
	  }
#endif	  
        }
        else set(name, makeargv(""));
        break;

        case '[':
        arg = readdecimal(arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
        if (*arg == '\0')
        {
          if (strequ(*argv, "="))
          {
            argv++;
            initexprparse(argv);
            text = streval(buffer, expr = readexpr(0));
            freeexpr(expr);
            argv = wordlist;
          }
          else text = "";
        }
        else
        {
          unless (*arg++ == '=') return error(ERR_SYNTAX, cmd);
          text = arg;
        }
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
        break;

        case '=':
        unless (*arg == '\0')
        {
          argv--;
#if 1
	/* debug by PAB 11/1/90 */
	/* avoids corrupting the pointers used later to free argv arrays */
      	{
      		char *targ = *argv;
      		
      	while ((*targ++ = *arg++) != '\0')
      	;/*null stat*/
      	*targ = '\0';
	}
#else   
      *argv = arg;			/* !!! Corrupts argv entry !!!	*/
#endif 
       }
        initexprparse(argv);
        set(name, makeargv(streval(buffer, expr = readexpr(0))));
        freeexpr(expr);
        argv = wordlist;
        break;

        default:
        return error(ERR_SYNTAX, cmd);
      }
    } 
#endif        
@


1.6
log
@changes to try and fix CTRL-C processing
@
text
@d15 1
a15 1
char *sccsid = "@@(#)builtin.c	1.18\t12/4/89 Copyright (C) 1988, Perihelion Software Ltd.";
d17 1
a17 1
char *version = "1.18\t24/7/90.\tDebug Version    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
d19 1
a19 1
char *version = "1.18\t24/7/90.\t    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
@


1.5
log
@make default history count 0 not 100
@
text
@d1479 1
d1484 1
@


1.4
log
@barts 1.2 changes
@
text
@d894 1
a894 1
  int number = 100;
@


1.3
log
@*** empty log message ***
@
text
@d56 1
a56 1
  "login", b_login,
d1134 1
d1147 1
@


1.2
log
@mods by james dowdells for beta release
@
text
@d1 1915
a1915 1915
/**
*Title:  Helios Shell - Built-in Command Support.
*
* Author: Andy England
*
* Date:   May 1988
*
*         (c) Copyright 1988, Perihelion Software Ltd.
*
*         All Rights Reserved.
*
**/
#include "shell.h"

char *sccsid = "@@(#)builtin.c	1.18\t12/4/89 Copyright (C) 1988, Perihelion Software Ltd.";
#ifdef		DEBUGGING
char *version = "1.18\t24/7/90.\tDebug Version    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
#else
char *version = "1.18\t24/7/90.\t    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
#endif

BUILTIN  builtins[] =
{
  "alias", b_alias,
  "alloc", b_alloc,
  "bg", b_bg,
  "break", b_break,
  "breaksw", b_breaksw,
  "case", b_case,
  "cd", b_cd,
  "chdir", b_cd,
  "continue", b_continue,
  "default", b_default,
  "dirs", b_dirs,
  "echo", b_echo,
  "else", b_else,
  "end", b_end,
  "endif", b_endif,
  "endsw", b_endsw,
  "eval", b_eval,
  "exec", b_exec,
  "exit", b_exit,
#ifdef HELIOS
  "fault", b_fault,
#endif
  "fg", b_fg,
  "foreach", b_foreach,
  "glob", b_glob,
  "goto", b_goto,
  "hashstat", b_hashstat,
  "history", b_history,
  "if", b_if,
  "jobs", b_jobs,
  "kill", b_kill,
  "limit", b_limit,
  "login", b_login,
  "logout", b_logout,
  "nice", b_nice,
  "nohup", b_nohup,
  "notify", b_notify,
  "onintr", b_onintr,
  "popd", b_popd,
#ifdef HELIOS
  "printenv", b_printenv,
#endif
  "pushd", b_pushd,
#ifdef HELIOS
  "pwd", b_pwd,
#endif
  "rehash", b_rehash,
  "repeat", b_repeat,
  "set", b_set,
  "setenv", b_setenv,
  "shift", b_shift,
  "source", b_source,
  "stop", b_stop,
  "suspend", b_suspend,
  "switch", b_switch,
  "time", b_time,
  "umask", b_umask,
  "unalias", b_unalias,
  "unhash", b_unhash,
  "unlimit", b_unlimit,
  "unset", b_unset,
  "unsetenv", b_unsetenv,
  "version", b_version,
  "wait", b_wait,
  "while", b_while,
  "@@", b_at,
  0, 0
};

BUILTIN extrabuiltins[2] =
{
  ":", b_label,
  "%", b_job
};

int mode;
SUBSTATE wordstate;

char *getword(line)
char *line;
{
  int c;

#ifdef	DEBUGGING
  DEBUG("getword()");
#endif
  wordstate = NEUTRAL;
  forever
  {
    c = *line++;
    switch (wordstate)
    {
      case NEUTRAL:
      switch (c)
      {
        case ';':
        strcpy(wordbuffer, ";");
#ifdef	DEBUGGING
        DEBUG("='%s' (%S)",wordbuffer,line);
#endif
        return line;

        case '&':
        if (*line == '&')
        {
          line++;
          strcpy(wordbuffer, "&&");
          return line;
        }
        strcpy(wordbuffer, "&");
        return line;
       
        case '|':
        if (*line == '|')
        {
          line++;
#ifdef CDL
          if (usingcdl AND *line == '|')
          {
            line++;
            strcpy(wordbuffer, "|||");
            return line;
          }
#endif
          strcpy(wordbuffer, "||");
          return line;
        }
#ifdef CDL
        if (usingcdl)
        {
          if (*line == '<')
          {
            line++;
            strcpy(wordbuffer, "|<");
            return line;
          }
          if (*line == '>')
          {
            line++;
            strcpy(wordbuffer, "|>");
            return line;
          }
        }
#endif
        strcpy(wordbuffer, "|");
        return line;

        case '<':
        if (*line == '<')
        {
          line++;
          strcpy(wordbuffer, "<<");
          return line;
        }
#ifdef CDL
        if (usingcdl)
        {
          if (*line == '>')
          {
            line++;
            strcpy(wordbuffer, "<>");
            return line;
          }
          if (*line == '|')
          {
            line++;
            strcpy(wordbuffer, "<|");
            return line;
          }
        }
#endif
        strcpy(wordbuffer, "<");
        return line;
       
        case '>':
                       	
        if (*line == '>')
        {
          line++;
          if (*line == '2')
          {
            line++;
            strcpy(wordbuffer, ">>2");
#ifdef	DEBUGGING
  	    DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
            return line;
          }
          strcpy(wordbuffer, ">>");
          return line;
        }
        if (*line == '2')
        {
          line++;
          strcpy(wordbuffer, ">2");
#ifdef	DEBUGGING
  	  DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
          return line;
        }
#ifdef CDL
        if (usingcdl AND *line == '|')
        {
          line++;
          strcpy(wordbuffer, ">|");
          return line;
        }
#endif
        strcpy(wordbuffer, ">");
        return line;

#ifdef CDL
        case '^':
        if (usingcdl AND *line == '^')
        {
          line++;
          strcpy(wordbuffer, "^^");
          return line;
        }
        line--;
        wordstate = INWORD;
        continue;
#endif

        case '(':
        strcpy(wordbuffer, "(");
        parencount++;
        return line;

        case ')':
        strcpy(wordbuffer, ")");
        parencount--;
        return line;

	case '@@':			/* the @@ symbol might refer to	*/
					/* the at shell function or is	*/
					/* part of an encoded capability*/
	{
  	  int i;
	  for (i = 0; i < 16; i++)
	    if (line[i] < 'a' || line[i] > 'p') break;

	  if (i == 16 && line[i] == '/')
	  {
	    line--;			/* seems to be a capability...	*/
	    wordstate = INWORD;		/* read it as a word.		*/
	    continue;
	  }
          strcpy(wordbuffer, "@@");
#ifdef	DEBUGGING
  	  DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
          return line;
        }

        case '\n':
        case '\0':
        return NULL;

        case ' ':
        case '\t':
        continue;

        default:
        line--;
        wordstate = INWORD;
        continue;
      }

      case INWORD:
      switch (c)
      {
        case ';':
        case '&':
        case '|':
        case '<':
        case '>':
        case '(':
        case ')':
        case '\n':
        case '\0':
        case ' ':
        case '\t':
        ignore endword();
        wordstate = NEUTRAL;
        return line - 1;

#ifdef CDL
        case '^':
        if (usingcdl AND *line == '^')
        {
          ignore endword();
          wordstate = NEUTRAL;
          return line - 1;
        }
        addchar('^');
        continue;
#endif

        case '\\':
        if (*line == '\n')
        {
          line++;
          if (wordindex > 0) addchar(' ');
          else wordstate = NEUTRAL;
          continue;
        }
        addchar('\\');
        addchar(*line++);
        continue;

        case '$':
        addchar('$');
        if (*line == '\n') continue;
        if (*line == '{')
        {
          line++;
          addchar('{');
          if (*line == '\n') continue;
        }
        addchar(*line++);
        continue;

        case '\'':
        addchar('\'');
        wordstate = INSQUOTE;
        continue;
        
        case '`':
        addchar('`');
        wordstate = INBQUOTE;
        continue;

        case '\"':
        addchar('"');
        wordstate = INDQUOTE;
        continue;

        case '#':
        unless (interactive)
        {
          do c = *line++; until (c == '\0' OR c == '\n');
          return NULL;
        }
        default:
        addchar(c);
        continue;
      }

      case INSQUOTE:
      case INBQUOTE:
      case INDQUOTE:
      switch (c)
      {
        case '\n':
        case '\0':
        ignore endword();
        return line - 1;

        case '\\':
        addchar('\\');
        addchar(*line++);
        continue;

        case '\'':
        addchar('\'');
        if (wordstate == INSQUOTE) wordstate = INWORD;
        continue;

        case '`':
        addchar('`');
        if (wordstate == INBQUOTE) wordstate = INWORD;
        continue;

        case '"':
        addchar('"');
        if (wordstate == INDQUOTE) wordstate = INWORD;
        continue;

        default:
        addchar(c);
        continue;
      }
    }
  }
}

void getlastword(line)
char *line;
{
  until ((line = getword(line)) == NULL);
}

BOOL isspecial(name)
char *name;
{
  BUILTIN *builtin;

  unless ((builtin = findbuiltin(name)) == NULL)
  {
    int (*func)() = builtin->func;

    return func == b_else  OR func == b_exit OR func == b_foreach OR
           func == b_if    OR func == b_set  OR func == b_switch  OR
           func == b_while OR func == b_at;
  }
  return FALSE;
}

BOOL needsfullsubs(func)
int (*func)();
{
  return func == b_cd      OR func == b_echo   OR func == b_eval   OR
         func == b_foreach OR func == b_glob   OR func == b_pushd  OR
         func == b_repeat  OR func == b_source OR func == b_switch OR
         func == b_time;
}

BUILTIN *findbuiltin(name)
char *name;
{
  BUILTIN *builtin;

  if (name[strlen(name) - 1] == ':') return &extrabuiltins[0];
  if (name[0] == '%') return &extrabuiltins[1];
  for (builtin = builtins; builtin->name; builtin++)
  {
    if (strequ(name, builtin->name)) return builtin;
  }
  return NULL;
}

int b_alias(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) putalias();
  else
  {
    char *name = argv[1];

    if (argc == 2)
    {
      unless ((argv = findalias(name)) == NULL) putargv(argv, TRUE);
    }
    else
    {
      if (strequ(name, "alias") OR strequ(name, "unalias"))
        return error(ERR_DANGEROUS, name);
      alias(name, dupargv(argv + 2));
    }
  }
  return OK;
}

int b_alloc(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  putmem();
  return OK;
}

int b_bg(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_break(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_BREAK);
  setmode(MODE_END);
  return OK;
}

int b_breaksw(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];
  int nestcount = 1;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  do
  {
    unless (getline(line, TRUE)) return error(ERR_NOENDSW, argv[0]);
    unless (getword(line) == NULL)
    {
      if (strequ("switch", wordbuffer)) nestcount++;
      if (strequ("endsw", wordbuffer)) nestcount--;
    }
  } while (nestcount > 0);
  return OK;
}

int b_case(argc, argv)
int argc;
char *argv[];
{
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_cd(argc, argv)
int argc;
char *argv[];
{
  char *name;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((name = getvar("home")) == NULL) return error(ERR_NOHOME, NULL);
  }
  else name = argv[1];
  unless (changedir(name)) return syserr(name);
  return OK;
}

int b_continue(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_END);
  return OK;
}

int b_default(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_dirs(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (dirs()) return syserr(argv[0]);
  return OK;
}

int b_echo(argc, argv)
int argc;
char *argv[];
{
  if (argc >= 1)
  {
    BOOL newline = TRUE;

    if (strequ(*++argv, "-n")) 
    {
      argv++;
      newline = FALSE;
    }
    putargv(argv, newline);
  }
  return OK;
}

int b_else(argc, argv)
int argc;
char *argv[];
{
  int nestcount = 1;
  char line[LINE_MAX + 1];

  do
  {
    char *lineptr;

    unless (getline(line, TRUE)) return error(ERR_NOENDIF, argv[0]);
    unless ((lineptr = getword(line)) == NULL)
    {
      if (strequ("endif", wordbuffer)) nestcount--;
      if (strequ("if", wordbuffer))
      {
        getlastword(lineptr);
        if (strequ("then", wordbuffer)) nestcount++;
      }
    }
  } while (nestcount > 0);
  return OK;
  argc = argc;				/* keep the compiler happy...	*/
}

int b_end(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_END);
  return OK;
}

int b_endif(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_endsw(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_eval(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];

  sputargv(line, argv + 1, ' ');
  return runcmdline(line);
  argc = argc;				/* keep the compiler happy...	*/
}

int b_exec(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  executecmd(argv[1], argv+1);
  return error(ERR_NOTFOUND, argv[1]);	/* CFL	Fix to bug #261		*/
  return OK;
}

int b_exit(argc, argv)
int argc;
char *argv[];
{
  int code;

  if (argc > 1)
  {
    EXPR *expr;

    initexprparse(argv + 1);
    code = evaluate(expr = readexpr(0));
    freeexpr(expr);
  }
  else
  {
    char *status;

    if ((status = getvar("status")) == NULL) code = OK;
    else code = atoi(status);
  }
  freeargv(argv);
  logout(code);
  return OK;
}

#ifdef HELIOS
int b_fault(argc, argv)
int argc;
char *argv[];
{
  int code;

  if (argc > 1)
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv++) == NULL)
    {
      if (strlen(arg) < 8) arg = readdecimal(arg, &code);
      else arg = readhex(arg, &code);
      unless (*arg == '\0') return error(ERR_BADNUMBER, cmd);
      fault(code);
    }
  }
  else
  {
    char *error;

    if ((error = getvar("error")) == NULL) code = OK;
    else code = atoi(error);
    fault(code);
  }
  return OK;
}
#endif

int b_fg(argc, argv)
int argc;
char *argv[];
{
  JOB *job;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else
  {
    char *arg = argv[1];

    unless (*arg++ == '%') return error(ERR_NOSUCHJOB, argv[0]);
    if (arg[0] == '\0' OR
        ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
    {
      if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
    }
    else if (arg[0] == '-' AND arg[1] == '\0')
    {
      if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
    }
    else
    {
      int number;

      ignore readdecimal(arg, &number);
      if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
    }
  }
  putcmd(job->cmd);
  printf("\n");
  waitforcmd(job->pid);
  return OK;
}

int b_foreach(argc, argv)
int argc;
char *argv[];
{
  char name[VARNAME_MAX + 1];
  jmp_buf savehome;			/* CFL	foreach should switch	*/
  int result;				/*	history recording off	*/
  int savemode = mode;
  char *arg;
  int i;
  long start, end;

  if (argc < 4) return error(ERR_TOOFEWARGS, argv[0]);
  arg = readname(argv[1], name);
  unless (*arg == '\0') return error(ERR_INVALIDVAR, argv[0]);
  unless (strequ(argv[2], "(") AND strequ(argv[argc - 1], ")"))
    return error(ERR_WORDLIST, argv[0]);
  start = note();
  {
    int nestcount = 1;
    char line[LINE_MAX + 1];

    do
    {
      unless (getline(line, TRUE)) return error(ERR_NOEND, argv[0]);
      unless (getword(line) == NULL)
      {
        if (strequ("while", wordbuffer) OR
            strequ("foreach", wordbuffer)) nestcount++;
        if (strequ("end", wordbuffer)) nestcount--;
      }
    } while (nestcount > 0);
  }
  end = note();
  if (argc > 4)
  {
    newloop();
    unsetmode(MODE_HISTORY);
    memcpy (savehome, home, sizeof (jmp_buf));	/* set up safety net	*/
    if ((result = catch ()) != 0)		/* and catch error exit	*/
    {
      mode = savemode;
      memcpy (home, savehome, sizeof (jmp_buf));
      throw (result);
    }
    for (i = 3; i < argc - 1; i++)
    {
      point(start);
      set(name, makeargv(argv[i]));
      do
      {
        unless (docmdline())
        {
          mode = savemode;
          memcpy (home, savehome, sizeof (jmp_buf));
          error(ERR_NOEND, argv[0]);
          recover();
        }
      } until (mode & MODE_END);
      unsetmode(MODE_END);
      if (mode & MODE_BREAK)
      {
        unsetmode(MODE_BREAK);
        point(end);
        break;
      }
    }
    mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
    oldloop();
    point(end);				/* CFL	Fix to bug #130		*/
  }
  return OK;
}

int b_glob(argc, argv)
int argc;
char *argv[];
{
  while (--argc)
  {
    printf("%s", *++argv);
    if (argc > 1) putchar('\0');
    fflush(stdout);
  }
  return OK;
}

int b_goto(argc, argv)
int argc;
char *argv[];
{
  char line[WORD_MAX + 1];
  char label[WORD_MAX + 1];

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  rewindinput();
  strcpy(label, argv[1]);
  strcat(label, ":");
  forever
  {
    unless (getline(line, TRUE)) return error(ERR_NOLABEL, argv[1]);
    unless (getword(line) == NULL)
    {
      if (strequ(label, wordbuffer)) break;
    }
  }
  return OK;
}

int b_hashstat(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_history(argc, argv)
int argc;
char *argv[];
{
#if	1
  char *history;
  char *cmd = *argv++;
  BOOL reverse = FALSE;
  BOOL nonames = FALSE;
  int number = 100;
  char *arg;

#ifdef	DEBUGGING
  DEBUG("b_history (%V)", argv);
#endif
  unless ((history = getvar("history")) == NULL)
    number = atoi(history);

  while ((arg = *argv) != NULL AND *arg++ == '-')
  {
    argv++;
    while (*arg != '\0')
      switch (*arg++)
      {
        case 'h' : nonames = TRUE; break;
        case 'r' : reverse = TRUE; break;
        default  : return error(ERR_BADOPTION, cmd);
      }
  }

  if ((arg = *argv) != NULL)
  {
    arg = readdecimal(arg, &number);
    if (*arg != '\0') return error(ERR_BADNUMBER, cmd);
  }
  putsublist(&historylist, number, nonames, TRUE, reverse);

#else
  if (argc < 2)
  {
    char *history;

    unless ((history = getvar("history")) == NULL)
      putsublist(&historylist, atoi(history), FALSE, TRUE, FALSE);
  }
  else
  {
    char *cmd = *argv++;
    BOOL reverse = FALSE;
    BOOL nonames = FALSE;
    int number = 100;
    char *arg;

    if (strequ(*argv, "-h"))
    {
      argv++;
      nonames = TRUE;
    }
    if ((arg = *argv) != NULL AND strequ(arg, "-r"))
    {
      argv++;
      reverse = TRUE;
    }
    unless ((arg = *argv) == NULL)
    {
      arg = readdecimal(arg, &number);
      unless (*arg == '\0') return error(ERR_BADNUMBER, cmd);
    }
    putsublist(&historylist, number, nonames, TRUE, reverse);
  }
#endif
  return OK;
  argc = argc;				/* keep the compiler happy...	*/
}

int b_if(argc, argv)
int argc;
char *argv[];
{
  EXPR *expr;
  int value;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  initexprparse(argv + 1);
  value = evaluate(expr = readexpr(0));
  freeexpr(expr);
  if (token == T_NEWLINE) return error(ERR_EMPTYIF, argv[0]);
  if (strequ(currentword, "then"))
  {
    readexprtoken();
    unless (token == T_NEWLINE) return error(ERR_THEN, argv[0]);
    unless (value)
    {
      int nestcount = 1;
      char line[LINE_MAX + 1];

      do
      {
        char *lineptr;

        unless (getline(line, TRUE)) return error(ERR_NOELSE, "then");
        unless ((lineptr = getword(line)) == NULL)
        {
          if (nestcount == 1 AND strequ("else", wordbuffer))
          {
            char **newargv = nullargv();

            until ((lineptr = getword(lineptr)) == NULL)
              newargv = addword(newargv, wordbuffer);
            ignore waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE));
            break;
          }
          if (strequ("endif", wordbuffer)) nestcount--;
          if (strequ("if", wordbuffer))
          {
            getlastword(lineptr);
            if (strequ("then", wordbuffer)) nestcount++;
          }
        }
      } while (nestcount > 0);
    }
  }
  else if (value)
    ignore waitforcmd(runsimplecmd(dupargv(wordlist), NULL, READ, WRITE));
  return OK;
}

int b_job(argc, argv)
int argc;
char *argv[];
{
  JOB *job;
  char *arg = argv[0] + 1;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (arg[0] == '\0' OR
      ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else if (arg[0] == '-' AND arg[1] == '\0')
  {
    if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
  }
  else
  {
    int number;

    ignore readdecimal(arg, &number);
    if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
  }
  putcmd(job->cmd);
  printf("\n");
  waitforcmd(job->pid);
  return OK;
}

int b_jobs(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  putjobtable();
  return OK;
}

int b_kill(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *++argv) == NULL)
  {
    int pid;

    if (arg[0] == '%')
    {
      JOB *job;

      if (arg[1] == '\0' OR
          ((arg[1] == '%' OR arg[1] == '+') AND arg[2] == '\0'))
      {
        if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, *argv);
      }
      else if (arg[1] == '-' AND arg[2] == '\0')
      {
        if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, *argv);
      }
      else
      {
        int number;

        ignore readdecimal(&arg[1], &number);
        if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, *argv);
      }
      pid = job->pid;
    }
    else
    {
      arg = readdecimal(arg, &pid);
      unless (*arg == '\0') return error(ERR_BADNUMBER, NULL);
    }
    if (kill(pid, SIGTERM) == -1) return syserr(NULL);
  }
  return OK;
}

int b_label(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_limit(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  int i;

  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    for (i = 1; i < RESOURCE_MAX; i++) putlimit(i);
  }
  else
  {
    if ((i  = findresource(argv[1])) == -1) return error(ERR_LIMIT, argv[0]);
    if (argc == 2) putlimit(i);
    else
    {
      int limit;
      char *arg = readdecimal(argv[2], &limit);

      unless (*arg == '\0') return error(ERR_SCALEFACTOR, argv[0]);
      setlimit(i, limit);
    }
  }
  return OK;
#else
  if (argc > 1) error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_login(argc, argv)
int argc;
char *argv[];
{
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (login)
  {
    execv(LOGIN_CMD, argv);
    return syserr(LOGIN_CMD);
  }
  return error(ERR_NOTLOGIN, NULL);
}

int b_logout(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (login)
  {
    freeargv(argv);
    logout(OK);
  }
  return error(ERR_NOTLOGIN, NULL);
}

int b_nice(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_nohup(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_notify(argc, argv)
int argc;
char *argv[];
{
  JOB *job;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else
  {
    char *arg = argv[1];

    unless (*arg++ == '%') return error(ERR_NOSUCHJOB, argv[0]);
    if (arg[0] == '\0' OR
        ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
    {
      if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
    }
    else if (arg[0] == '-' AND arg[1] == '\0')
    {
      if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
    }
    else
    {
      int number;

      ignore readdecimal(arg, &number);
      if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
    }
  }
  job->notify = TRUE;
  return OK;
}

int b_onintr(argc, argv)
int argc;
char *argv[];
{
  if (interactive) return error(ERR_TERMINAL, argv[0]);
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_popd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    unless (popdir(path)) return error(ERR_STACKEMPTY, argv[0]);
    unless (changedir(path)) return syserr(path);
    dirs();
    return OK;
  }
  else if (argv[1][0] == '+')
  {
    int number;
    char *arg = readdecimal(argv[1] + 1, &number);

    if (*arg == '\0')
    {
      unless (getdir(number, path)) return error(ERR_NOTTHATDEEP, argv[0]);
      return OK;
    }
  }
  return error(ERR_BADDIR, argv[0]);
}

#ifdef HELIOS
int b_printenv(argc, argv)
int argc;
char *argv[];
{
  char **envp = environ;
  char *env;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  until ((env = *envp++) == NULL) printf("%s\n", env);
  return OK;
}
#endif

int b_pushd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    unless (popdir(path)) return error(ERR_NOOTHERDIR, argv[0]);
    unless (pushdir(path)) return syserr(path);
    return OK;
  }
  else if (argv[1][0] == '+')
  {
    int number;
    char *arg = readdecimal(argv[1] + 1, &number);

    if (*arg == '\0')
    {
      unless (getdir(number, path)) return error(ERR_NOTTHATDEEP, argv[0]);
      unless (pushdir(path)) return syserr(path);
      return OK;
    }
  }
  unless (pushdir(argv[1])) return syserr(argv[1]);
  return OK;
}

#ifdef HELIOS
int b_pwd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (getcwd(path, PATH_MAX) == NULL) return syserr(argv[0]);
  printf("%s\n", path);
  return OK;
}
#endif

int b_rehash(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  hash();
  return OK;
}

int b_repeat(argc, argv)
int argc;
char *argv[];
{
  int count;
  char *arg;

  if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]);
  arg = readdecimal(argv[1], &count);
  unless (*arg == '\0') return error(ERR_BADNUMBER, argv[0]);
  while (count--)
  {
    if (testbreak()) recover();
    ignore waitforcmd(runsimplecmd(dupargv(argv + 2), NULL, READ, WRITE));
  }
  return OK;
}

int b_set(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) putvars();
  else
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv++) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char *text;
      char **newargv;
      int index;

      arg = readname(arg, name);
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);
      switch (*arg++)
      {
        case '\0':
        if (strequ(*argv, "="))
        {
          argv++;
          if (strequ(*argv, "("))
          {
            newargv = nullargv();

            argv++;
            until (strequ(arg = *argv++, ")")) newargv = addword(newargv, arg);
             set(name, newargv); 
          }
          else set(name, makeargv(*argv++));
        }
        else set(name, makeargv(""));
        break;
 
        case '[':
        arg = readdecimal(arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
        if (*arg == '\0')
        {
          if (strequ(*argv, "="))
          {
            argv++;
            text = *argv++;
          }
          else text = "";
        }
        else
        {
          unless (*arg++ == '=') return error(ERR_SYNTAX, cmd);
          text = arg;
        }
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
        break;

        case '=':
        unless (*arg == '\0') set(name, makeargv(arg));
        else
        {
          if (strequ(*argv, "("))
          {
            newargv = nullargv();

            argv++;
            until (strequ(arg = *argv++, ")")) newargv = addword(newargv, arg);
            set(name, newargv); 
          }
          else set(name, makeargv(""));
        }
        break;

        default:
        return error(ERR_SYNTAX, cmd);
      }
    } 
  }
  return OK;
}

int b_setenv(argc, argv)
int argc;
char *argv[];
{
  if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  setenv(argv[1], argv[2]);
  return OK;
}

int b_shift(argc, argv)
int argc;
char *argv[];
{
  char *name;
  char **oldargv;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc == 1) name = "argv";
  else name = argv[1];
  unless ((oldargv = findvar(name)) == NULL)
  {
    unless (lenargv(oldargv)) return error(ERR_NOMOREWORDS, argv[0]);
    set(name, dupargv(oldargv + 1));
    return OK;
  }
  return error(ERR_VARIABLE, name);
}

int b_source(argc, argv)
int argc;
char *argv[];
{
  jmp_buf savehome;			/* CFL	Fix to bug #182		*/
  int result;				/*				*/
  int savemode = mode;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  if (strequ("-h", argv[1]))
  {
  	if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]); /*jd*/
    if (record(argv[2])) return OK;
    return syserr(argv[2]);
  }
  setmode(MODE_EXECUTE);
  unsetmode(MODE_HISTORY);
  memcpy (savehome, home, sizeof (jmp_buf));	/* set up private net	*/
  if ((result = catch ()) != 0)		/* and catch the error exit	*/
  {
    mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
    throw (result);
  }
  if (source(argv[1]))
  {
    mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
    return OK;
  }
  mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
  return syserr(argv[1]);
}

int b_stop(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_suspend(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_switch(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];
  char *str;
  int nestcount = 1;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc < 4) return error(ERR_SYNTAX, argv[0]);
  if (argc > 4) return error(ERR_SYNTAX, argv[0]);
  initexprparse(argv + 1);
  unless (token == T_LPAREN) return error(ERR_SYNTAX, argv[0]);
  readexprtoken();
  str = currentword;
  readexprtoken();
  unless (token == T_RPAREN) return error(ERR_SYNTAX, argv[0]);
  do
  {
    char *lineptr;

    unless (getline(line, TRUE)) break;
    unless ((lineptr = getword(line)) == NULL)
    {
      if (strequ("switch", wordbuffer)) nestcount++;
      if (strequ("endsw", wordbuffer)) nestcount--;
      if (nestcount == 1)
      {
        if (strequ("default", wordbuffer)) break;
        if (strequ("default:", wordbuffer)) break;
        if (strequ("case", wordbuffer))
        {
          int length;

          unless (getword(lineptr) == NULL)
          {
            if (((length = strlen(wordbuffer)) > 0) AND
                (wordbuffer[length - 1] == ':')) wordbuffer[length - 1] = '\0';
            if (match(str, wordbuffer)) break;
          }
        }
      }
    }
  } while (nestcount > 0);
  return OK;
}

int b_time(argc, argv)
int argc;
char *argv[];
{
#ifdef NEWCODE
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {

  }
  else
  {
    waitforcmd(runsimplecmd(dupargv(argv + 1), NULL, READ, WRITE));
  }
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_umask(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  char *arg;
  int mask;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    mask = umask(0);
    umask(mask);
    printf("%o\n", mask);
    return OK;
  }
  arg = readoctal(argv[1], &mask);
  unless (*arg == '\0') return error(ERR_MASK, argv[0]);
  umask(mask);
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_unalias(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *argv++) == NULL) unalias(arg);
  return OK;
}

int b_unhash(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unhash();
  return OK;
}

int b_unlimit(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  int i;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    for (i = 0; i < RESOURCE_MAX; i++) setlimit(i, -1);
  }
  else
  {
    if ((i = findresource(argv[1])) == -1) return error(ERR_LIMIT, argv[0]);
    setlimit(i, -1);
  }
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_unset(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *argv++) == NULL) unset(arg);
  return OK;
}

int b_unsetenv(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  delenv(argv[1]);
  return OK;
}

int b_version(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  printf("%s\n", version);
  return OK;
}

int b_wait(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  waitforcmd(-1);
  return OK;
}

int b_while(argc, argv)
int argc;
char *argv[];
{
  jmp_buf savehome;			/* CFL	while should not record	*/
  int result;				/*	history			*/
  int savemode = mode;
  EXPR *expr;
  int value;
  long position;
  long start, end;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  initexprparse(argv + 1);
  value = evaluate(expr = readexpr(0));
  freeexpr(expr);
  unless (token == T_NEWLINE) return error(ERR_EXPSYNTAX, argv[0]);
  position = lineposition;
  start = note();
  {
    int nestcount = 1;
    char line[LINE_MAX + 1];

    do
    {
      unless (getline(line, TRUE)) return error(ERR_NOEND, argv[0]);
      unless (getword(line) == NULL)
      {
        if (strequ("while", wordbuffer) OR
            strequ("foreach", wordbuffer)) nestcount++;
        if (strequ("end", wordbuffer)) nestcount--;
      }
    } while (nestcount > 0);
  }
  end = note();
  if (value)
  {
    newloop();
    unsetmode(MODE_HISTORY);
    memcpy (savehome, home, sizeof (jmp_buf));	/* set up safety net	*/
    if ((result = catch ()) != 0)		/* and catch error exit	*/
    {
      mode = savemode;
      memcpy (home, savehome, sizeof (jmp_buf));
      throw (result);
    }
   point(start);
    do
    {
      unless (docmdline())
      {
           mode = savemode;
        memcpy (home, savehome, sizeof (jmp_buf));
      	error(ERR_NOEND, argv[0]);
      	recover();
      }
    } until (mode & MODE_END);
    unsetmode(MODE_END);
    if (mode & MODE_BREAK)
    {
      unsetmode(MODE_BREAK);
      point(end);
    }
    else point(position);
     mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
   oldloop();
  }
  if (value == 1) unsetmode(MODE_HISTORY);   /* JD BUG FIX No - 384*/
  else if (value == 0) setmode(MODE_HISTORY);
  
  return OK;
}

int b_at(argc, argv)
int argc;
char *argv[];
{
  if (argc == 1) putvars();
  else
  {
    char *cmd = *argv++;
    char *arg;

#if 1
    until ((arg = *argv) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char buffer[NUMSTR_MAX + 1];
      EXPR *expr;
      char **newargv;
      char *text;
      int index = -1;

      arg = readname(arg, name);	/* read var name		*/
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);

      if (*arg == '[')			/* read index			*/
      {
        arg = readdecimal(++arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
      }

      if (*arg == '\0' && *++argv != NULL)	/* skip argument end	*/
        arg = *argv;

      if (*arg == '=')			/* '=' found, evaluate expr.	*/
      {
        if (*++arg == '\0')		/* end of argv element:		*/
        {
          if (*++argv != NULL)		/* take next element		*/
            arg = *argv;
          else 				/* or report error		*/
            return error(ERR_SYNTAX, cmd);
        }
        else    			/* expr starts in this element	*/
        {
          text = *argv;			/* copy it to the start		*/
          while ((*text++ = *arg++) != '\0');
        }
        initexprparse(argv);
        text = streval(buffer, expr = readexpr(0));
        freeexpr(expr);
        argv = wordlist;
      }
      else				/* no expression found		*/
      {
      	if (*arg == '\0')		/* nothing left in the element	*/
      	  argv++;
      	else				/* something more to process	*/
      	{
          text = *argv;			/* copy it to the start		*/
          while ((*text++ = *arg++) != '\0');
        }
      	text = "";			/* set empty value		*/
      }
      if (index < 0)
        set(name, makeargv(text));
      else
      {
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
      }
    }
#else
    until ((arg = *argv++) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char buffer[NUMSTR_MAX + 1];
      EXPR *expr;
      char **newargv;
      char *text;
      int index;

      arg = readname(arg, name);
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);
      switch (*arg++)
      {
        case '\0':
        if (strequ(*argv, "="))
        {
          argv++;
#ifdef JON
	  if (*argv == NULL)
	    set(name, makeargv(""));
	  else
	  {
#endif
          initexprparse(argv);
          set(name, makeargv(streval(buffer, expr = readexpr(0))));
          freeexpr(expr);
          argv = wordlist;
#ifdef JON
	  }
#endif	  
        }
        else set(name, makeargv(""));
        break;

        case '[':
        arg = readdecimal(arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
        if (*arg == '\0')
        {
          if (strequ(*argv, "="))
          {
            argv++;
            initexprparse(argv);
            text = streval(buffer, expr = readexpr(0));
            freeexpr(expr);
            argv = wordlist;
          }
          else text = "";
        }
        else
        {
          unless (*arg++ == '=') return error(ERR_SYNTAX, cmd);
          text = arg;
        }
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
        break;

        case '=':
        unless (*arg == '\0')
        {
          argv--;
#if 1
	/* debug by PAB 11/1/90 */
	/* avoids corrupting the pointers used later to free argv arrays */
      	{
      		char *targ = *argv;
      		
      	while ((*targ++ = *arg++) != '\0')
      	;/*null stat*/
      	*targ = '\0';
	}
#else   
      *argv = arg;			/* !!! Corrupts argv entry !!!	*/
#endif 
       }
        initexprparse(argv);
        set(name, makeargv(streval(buffer, expr = readexpr(0))));
        freeexpr(expr);
        argv = wordlist;
        break;

        default:
        return error(ERR_SYNTAX, cmd);
      }
    } 
#endif        
  }
  return OK;
}
@


1.1
log
@Initial revision
@
text
@d1 1915
a1915 1914
/**
*Title:  Helios Shell - Built-in Command Support.
*
* Author: Andy England
*
* Date:   May 1988
*
*         (c) Copyright 1988, Perihelion Software Ltd.
*
*         All Rights Reserved.
*
* $Header$
*
**/
#include "shell.h"

char *sccsid = "@@(#)builtin.c	1.18\t12/4/89 Copyright (C) 1988, Perihelion Software Ltd.";
#ifdef		DEBUGGING
char *version = "1.18\t24/7/90.\tDebug Version    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
#else
char *version = "1.18\t24/7/90.\t    Copyright (C) 1987 - 1990, Perihelion Software Ltd.";
#endif

BUILTIN  builtins[] =
{
  "alias", b_alias,
  "alloc", b_alloc,
  "bg", b_bg,
  "break", b_break,
  "breaksw", b_breaksw,
  "case", b_case,
  "cd", b_cd,
  "chdir", b_cd,
  "continue", b_continue,
  "default", b_default,
  "dirs", b_dirs,
  "echo", b_echo,
  "else", b_else,
  "end", b_end,
  "endif", b_endif,
  "endsw", b_endsw,
  "eval", b_eval,
  "exec", b_exec,
  "exit", b_exit,
#ifdef HELIOS
  "fault", b_fault,
#endif
  "fg", b_fg,
  "foreach", b_foreach,
  "glob", b_glob,
  "goto", b_goto,
  "hashstat", b_hashstat,
  "history", b_history,
  "if", b_if,
  "jobs", b_jobs,
  "kill", b_kill,
  "limit", b_limit,
  "login", b_login,
  "logout", b_logout,
  "nice", b_nice,
  "nohup", b_nohup,
  "notify", b_notify,
  "onintr", b_onintr,
  "popd", b_popd,
#ifdef HELIOS
  "printenv", b_printenv,
#endif
  "pushd", b_pushd,
#ifdef HELIOS
  "pwd", b_pwd,
#endif
  "rehash", b_rehash,
  "repeat", b_repeat,
  "set", b_set,
  "setenv", b_setenv,
  "shift", b_shift,
  "source", b_source,
  "stop", b_stop,
  "suspend", b_suspend,
  "switch", b_switch,
  "time", b_time,
  "umask", b_umask,
  "unalias", b_unalias,
  "unhash", b_unhash,
  "unlimit", b_unlimit,
  "unset", b_unset,
  "unsetenv", b_unsetenv,
  "version", b_version,
  "wait", b_wait,
  "while", b_while,
  "@@", b_at,
  0, 0
};

BUILTIN extrabuiltins[2] =
{
  ":", b_label,
  "%", b_job
};

int mode;
SUBSTATE wordstate;

char *getword(line)
char *line;
{
  int c;

#ifdef	DEBUGGING
  DEBUG("getword()");
#endif
  wordstate = NEUTRAL;
  forever
  {
    c = *line++;
    switch (wordstate)
    {
      case NEUTRAL:
      switch (c)
      {
        case ';':
        strcpy(wordbuffer, ";");
#ifdef	DEBUGGING
        DEBUG("='%s' (%S)",wordbuffer,line);
#endif
        return line;

        case '&':
        if (*line == '&')
        {
          line++;
          strcpy(wordbuffer, "&&");
          return line;
        }
        strcpy(wordbuffer, "&");
        return line;
       
        case '|':
        if (*line == '|')
        {
          line++;
#ifdef CDL
          if (usingcdl AND *line == '|')
          {
            line++;
            strcpy(wordbuffer, "|||");
            return line;
          }
#endif
          strcpy(wordbuffer, "||");
          return line;
        }
#ifdef CDL
        if (usingcdl)
        {
          if (*line == '<')
          {
            line++;
            strcpy(wordbuffer, "|<");
            return line;
          }
          if (*line == '>')
          {
            line++;
            strcpy(wordbuffer, "|>");
            return line;
          }
        }
#endif
        strcpy(wordbuffer, "|");
        return line;

        case '<':
        if (*line == '<')
        {
          line++;
          strcpy(wordbuffer, "<<");
          return line;
        }
#ifdef CDL
        if (usingcdl)
        {
          if (*line == '>')
          {
            line++;
            strcpy(wordbuffer, "<>");
            return line;
          }
          if (*line == '|')
          {
            line++;
            strcpy(wordbuffer, "<|");
            return line;
          }
        }
#endif
        strcpy(wordbuffer, "<");
        return line;
       
        case '>':
                       	
        if (*line == '>')
        {
          line++;
          if (*line == '2')
          {
            line++;
            strcpy(wordbuffer, ">>2");
#ifdef	DEBUGGING
  	    DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
            return line;
          }
          strcpy(wordbuffer, ">>");
          return line;
        }
        if (*line == '2')
        {
          line++;
          strcpy(wordbuffer, ">2");
#ifdef	DEBUGGING
  	  DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
          return line;
        }
#ifdef CDL
        if (usingcdl AND *line == '|')
        {
          line++;
          strcpy(wordbuffer, ">|");
          return line;
        }
#endif
        strcpy(wordbuffer, ">");
        return line;

#ifdef CDL
        case '^':
        if (usingcdl AND *line == '^')
        {
          line++;
          strcpy(wordbuffer, "^^");
          return line;
        }
        line--;
        wordstate = INWORD;
        continue;
#endif

        case '(':
        strcpy(wordbuffer, "(");
        parencount++;
        return line;

        case ')':
        strcpy(wordbuffer, ")");
        parencount--;
        return line;

	case '@@':			/* the @@ symbol might refer to	*/
					/* the at shell function or is	*/
					/* part of an encoded capability*/
	{
  	  int i;
	  for (i = 0; i < 16; i++)
	    if (line[i] < 'a' || line[i] > 'p') break;

	  if (i == 16 && line[i] == '/')
	  {
	    line--;			/* seems to be a capability...	*/
	    wordstate = INWORD;		/* read it as a word.		*/
	    continue;
	  }
          strcpy(wordbuffer, "@@");
#ifdef	DEBUGGING
  	  DEBUG(" = '%s' (%s)",wordbuffer,line);
#endif
          return line;
        }

        case '\n':
        case '\0':
        return NULL;

        case ' ':
        case '\t':
        continue;

        default:
        line--;
        wordstate = INWORD;
        continue;
      }

      case INWORD:
      switch (c)
      {
        case ';':
        case '&':
        case '|':
        case '<':
        case '>':
        case '(':
        case ')':
        case '\n':
        case '\0':
        case ' ':
        case '\t':
        ignore endword();
        wordstate = NEUTRAL;
        return line - 1;

#ifdef CDL
        case '^':
        if (usingcdl AND *line == '^')
        {
          ignore endword();
          wordstate = NEUTRAL;
          return line - 1;
        }
        addchar('^');
        continue;
#endif

        case '\\':
        if (*line == '\n')
        {
          line++;
          if (wordindex > 0) addchar(' ');
          else wordstate = NEUTRAL;
          continue;
        }
        addchar('\\');
        addchar(*line++);
        continue;

        case '$':
        addchar('$');
        if (*line == '\n') continue;
        if (*line == '{')
        {
          line++;
          addchar('{');
          if (*line == '\n') continue;
        }
        addchar(*line++);
        continue;

        case '\'':
        addchar('\'');
        wordstate = INSQUOTE;
        continue;
        
        case '`':
        addchar('`');
        wordstate = INBQUOTE;
        continue;

        case '\"':
        addchar('"');
        wordstate = INDQUOTE;
        continue;

        case '#':
        unless (interactive)
        {
          do c = *line++; until (c == '\0' OR c == '\n');
          return NULL;
        }
        default:
        addchar(c);
        continue;
      }

      case INSQUOTE:
      case INBQUOTE:
      case INDQUOTE:
      switch (c)
      {
        case '\n':
        case '\0':
        ignore endword();
        return line - 1;

        case '\\':
        addchar('\\');
        addchar(*line++);
        continue;

        case '\'':
        addchar('\'');
        if (wordstate == INSQUOTE) wordstate = INWORD;
        continue;

        case '`':
        addchar('`');
        if (wordstate == INBQUOTE) wordstate = INWORD;
        continue;

        case '"':
        addchar('"');
        if (wordstate == INDQUOTE) wordstate = INWORD;
        continue;

        default:
        addchar(c);
        continue;
      }
    }
  }
}

void getlastword(line)
char *line;
{
  until ((line = getword(line)) == NULL);
}

BOOL isspecial(name)
char *name;
{
  BUILTIN *builtin;

  unless ((builtin = findbuiltin(name)) == NULL)
  {
    int (*func)() = builtin->func;

    return func == b_else  OR func == b_exit OR func == b_foreach OR
           func == b_if    OR func == b_set  OR func == b_switch  OR
           func == b_while OR func == b_at;
  }
  return FALSE;
}

BOOL needsfullsubs(func)
int (*func)();
{
  return func == b_cd      OR func == b_echo   OR func == b_eval   OR
         func == b_foreach OR func == b_glob   OR func == b_pushd  OR
         func == b_repeat  OR func == b_source OR func == b_switch OR
         func == b_time;
}

BUILTIN *findbuiltin(name)
char *name;
{
  BUILTIN *builtin;

  if (name[strlen(name) - 1] == ':') return &extrabuiltins[0];
  if (name[0] == '%') return &extrabuiltins[1];
  for (builtin = builtins; builtin->name; builtin++)
  {
    if (strequ(name, builtin->name)) return builtin;
  }
  return NULL;
}

int b_alias(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) putalias();
  else
  {
    char *name = argv[1];

    if (argc == 2)
    {
      unless ((argv = findalias(name)) == NULL) putargv(argv, TRUE);
    }
    else
    {
      if (strequ(name, "alias") OR strequ(name, "unalias"))
        return error(ERR_DANGEROUS, name);
      alias(name, dupargv(argv + 2));
    }
  }
  return OK;
}

int b_alloc(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  putmem();
  return OK;
}

int b_bg(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_break(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_BREAK);
  setmode(MODE_END);
  return OK;
}

int b_breaksw(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];
  int nestcount = 1;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  do
  {
    unless (getline(line, TRUE)) return error(ERR_NOENDSW, argv[0]);
    unless (getword(line) == NULL)
    {
      if (strequ("switch", wordbuffer)) nestcount++;
      if (strequ("endsw", wordbuffer)) nestcount--;
    }
  } while (nestcount > 0);
  return OK;
}

int b_case(argc, argv)
int argc;
char *argv[];
{
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_cd(argc, argv)
int argc;
char *argv[];
{
  char *name;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((name = getvar("home")) == NULL) return error(ERR_NOHOME, NULL);
  }
  else name = argv[1];
  unless (changedir(name)) return syserr(name);
  return OK;
}

int b_continue(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_END);
  return OK;
}

int b_default(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_dirs(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (dirs()) return syserr(argv[0]);
  return OK;
}

int b_echo(argc, argv)
int argc;
char *argv[];
{
  if (argc >= 1)
  {
    BOOL newline = TRUE;

    if (strequ(*++argv, "-n")) 
    {
      argv++;
      newline = FALSE;
    }
    putargv(argv, newline);
  }
  return OK;
}

int b_else(argc, argv)
int argc;
char *argv[];
{
  int nestcount = 1;
  char line[LINE_MAX + 1];

  do
  {
    char *lineptr;

    unless (getline(line, TRUE)) return error(ERR_NOENDIF, argv[0]);
    unless ((lineptr = getword(line)) == NULL)
    {
      if (strequ("endif", wordbuffer)) nestcount--;
      if (strequ("if", wordbuffer))
      {
        getlastword(lineptr);
        if (strequ("then", wordbuffer)) nestcount++;
      }
    }
  } while (nestcount > 0);
  return OK;
  argc = argc;				/* keep the compiler happy...	*/
}

int b_end(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unless (inloop()) return error(ERR_NOTINLOOP, argv[0]);
  setmode(MODE_END);
  return OK;
}

int b_endif(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_endsw(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_eval(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];

  sputargv(line, argv + 1, ' ');
  return runcmdline(line);
  argc = argc;				/* keep the compiler happy...	*/
}

int b_exec(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  executecmd(argv[1], argv+1);
  return error(ERR_NOTFOUND, argv[1]);	/* CFL	Fix to bug #261		*/
  return OK;
}

int b_exit(argc, argv)
int argc;
char *argv[];
{
  int code;

  if (argc > 1)
  {
    EXPR *expr;

    initexprparse(argv + 1);
    code = evaluate(expr = readexpr(0));
    freeexpr(expr);
  }
  else
  {
    char *status;

    if ((status = getvar("status")) == NULL) code = OK;
    else code = atoi(status);
  }
  freeargv(argv);
  logout(code);
  return OK;
}

#ifdef HELIOS
int b_fault(argc, argv)
int argc;
char *argv[];
{
  int code;

  if (argc > 1)
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv++) == NULL)
    {
      if (strlen(arg) < 8) arg = readdecimal(arg, &code);
      else arg = readhex(arg, &code);
      unless (*arg == '\0') return error(ERR_BADNUMBER, cmd);
      fault(code);
    }
  }
  else
  {
    char *error;

    if ((error = getvar("error")) == NULL) code = OK;
    else code = atoi(error);
    fault(code);
  }
  return OK;
}
#endif

int b_fg(argc, argv)
int argc;
char *argv[];
{
  JOB *job;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else
  {
    char *arg = argv[1];

    unless (*arg++ == '%') return error(ERR_NOSUCHJOB, argv[0]);
    if (arg[0] == '\0' OR
        ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
    {
      if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
    }
    else if (arg[0] == '-' AND arg[1] == '\0')
    {
      if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
    }
    else
    {
      int number;

      ignore readdecimal(arg, &number);
      if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
    }
  }
  putcmd(job->cmd);
  printf("\n");
  waitforcmd(job->pid);
  return OK;
}

int b_foreach(argc, argv)
int argc;
char *argv[];
{
  char name[VARNAME_MAX + 1];
  jmp_buf savehome;			/* CFL	foreach should switch	*/
  int result;				/*	history recording off	*/
  int savemode = mode;
  char *arg;
  int i;
  long start, end;

  if (argc < 4) return error(ERR_TOOFEWARGS, argv[0]);
  arg = readname(argv[1], name);
  unless (*arg == '\0') return error(ERR_INVALIDVAR, argv[0]);
  unless (strequ(argv[2], "(") AND strequ(argv[argc - 1], ")"))
    return error(ERR_WORDLIST, argv[0]);
  start = note();
  {
    int nestcount = 1;
    char line[LINE_MAX + 1];

    do
    {
      unless (getline(line, TRUE)) return error(ERR_NOEND, argv[0]);
      unless (getword(line) == NULL)
      {
        if (strequ("while", wordbuffer) OR
            strequ("foreach", wordbuffer)) nestcount++;
        if (strequ("end", wordbuffer)) nestcount--;
      }
    } while (nestcount > 0);
  }
  end = note();
  if (argc > 4)
  {
    newloop();
    unsetmode(MODE_HISTORY);
    memcpy (savehome, home, sizeof (jmp_buf));	/* set up safety net	*/
    if ((result = catch ()) != 0)		/* and catch error exit	*/
    {
      mode = savemode;
      memcpy (home, savehome, sizeof (jmp_buf));
      throw (result);
    }
    for (i = 3; i < argc - 1; i++)
    {
      point(start);
      set(name, makeargv(argv[i]));
      do
      {
        unless (docmdline())
        {
          mode = savemode;
          memcpy (home, savehome, sizeof (jmp_buf));
          error(ERR_NOEND, argv[0]);
          recover();
        }
      } until (mode & MODE_END);
      unsetmode(MODE_END);
      if (mode & MODE_BREAK)
      {
        unsetmode(MODE_BREAK);
        point(end);
        break;
      }
    }
    mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
    oldloop();
    point(end);				/* CFL	Fix to bug #130		*/
  }
  return OK;
}

int b_glob(argc, argv)
int argc;
char *argv[];
{
  while (--argc)
  {
    printf("%s", *++argv);
    if (argc > 1) putchar('\0');
    fflush(stdout);
  }
  return OK;
}

int b_goto(argc, argv)
int argc;
char *argv[];
{
  char line[WORD_MAX + 1];
  char label[WORD_MAX + 1];

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  rewindinput();
  strcpy(label, argv[1]);
  strcat(label, ":");
  forever
  {
    unless (getline(line, TRUE)) return error(ERR_NOLABEL, argv[1]);
    unless (getword(line) == NULL)
    {
      if (strequ(label, wordbuffer)) break;
    }
  }
  return OK;
}

int b_hashstat(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_history(argc, argv)
int argc;
char *argv[];
{
#if	1
  char *history;
  char *cmd = *argv++;
  BOOL reverse = FALSE;
  BOOL nonames = FALSE;
  int number = 100;
  char *arg;

#ifdef	DEBUGGING
  DEBUG("b_history (%V)", argv);
#endif
  unless ((history = getvar("history")) == NULL)
    number = atoi(history);

  while ((arg = *argv) != NULL AND *arg++ == '-')
  {
    argv++;
    while (*arg != '\0')
      switch (*arg++)
      {
        case 'h' : nonames = TRUE; break;
        case 'r' : reverse = TRUE; break;
        default  : return error(ERR_BADOPTION, cmd);
      }
  }

  if ((arg = *argv) != NULL)
  {
    arg = readdecimal(arg, &number);
    if (*arg != '\0') return error(ERR_BADNUMBER, cmd);
  }
  putsublist(&historylist, number, nonames, TRUE, reverse);

#else
  if (argc < 2)
  {
    char *history;

    unless ((history = getvar("history")) == NULL)
      putsublist(&historylist, atoi(history), FALSE, TRUE, FALSE);
  }
  else
  {
    char *cmd = *argv++;
    BOOL reverse = FALSE;
    BOOL nonames = FALSE;
    int number = 100;
    char *arg;

    if (strequ(*argv, "-h"))
    {
      argv++;
      nonames = TRUE;
    }
    if ((arg = *argv) != NULL AND strequ(arg, "-r"))
    {
      argv++;
      reverse = TRUE;
    }
    unless ((arg = *argv) == NULL)
    {
      arg = readdecimal(arg, &number);
      unless (*arg == '\0') return error(ERR_BADNUMBER, cmd);
    }
    putsublist(&historylist, number, nonames, TRUE, reverse);
  }
#endif
  return OK;
  argc = argc;				/* keep the compiler happy...	*/
}

int b_if(argc, argv)
int argc;
char *argv[];
{
  EXPR *expr;
  int value;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  initexprparse(argv + 1);
  value = evaluate(expr = readexpr(0));
  freeexpr(expr);
  if (token == T_NEWLINE) return error(ERR_EMPTYIF, argv[0]);
  if (strequ(currentword, "then"))
  {
    readexprtoken();
    unless (token == T_NEWLINE) return error(ERR_THEN, argv[0]);
    unless (value)
    {
      int nestcount = 1;
      char line[LINE_MAX + 1];

      do
      {
        char *lineptr;

        unless (getline(line, TRUE)) return error(ERR_NOELSE, "then");
        unless ((lineptr = getword(line)) == NULL)
        {
          if (nestcount == 1 AND strequ("else", wordbuffer))
          {
            char **newargv = nullargv();

            until ((lineptr = getword(lineptr)) == NULL)
              newargv = addword(newargv, wordbuffer);
            ignore waitforcmd(runsimplecmd(newargv, NULL, READ, WRITE));
            break;
          }
          if (strequ("endif", wordbuffer)) nestcount--;
          if (strequ("if", wordbuffer))
          {
            getlastword(lineptr);
            if (strequ("then", wordbuffer)) nestcount++;
          }
        }
      } while (nestcount > 0);
    }
  }
  else if (value)
    ignore waitforcmd(runsimplecmd(dupargv(wordlist), NULL, READ, WRITE));
  return OK;
}

int b_job(argc, argv)
int argc;
char *argv[];
{
  JOB *job;
  char *arg = argv[0] + 1;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (arg[0] == '\0' OR
      ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else if (arg[0] == '-' AND arg[1] == '\0')
  {
    if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
  }
  else
  {
    int number;

    ignore readdecimal(arg, &number);
    if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
  }
  putcmd(job->cmd);
  printf("\n");
  waitforcmd(job->pid);
  return OK;
}

int b_jobs(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  putjobtable();
  return OK;
}

int b_kill(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *++argv) == NULL)
  {
    int pid;

    if (arg[0] == '%')
    {
      JOB *job;

      if (arg[1] == '\0' OR
          ((arg[1] == '%' OR arg[1] == '+') AND arg[2] == '\0'))
      {
        if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, *argv);
      }
      else if (arg[1] == '-' AND arg[2] == '\0')
      {
        if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, *argv);
      }
      else
      {
        int number;

        ignore readdecimal(&arg[1], &number);
        if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, *argv);
      }
      pid = job->pid;
    }
    else
    {
      arg = readdecimal(arg, &pid);
      unless (*arg == '\0') return error(ERR_BADNUMBER, NULL);
    }
    if (kill(pid, SIGTERM) == -1) return syserr(NULL);
  }
  return OK;
}

int b_label(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return OK;
}

int b_limit(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  int i;

  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    for (i = 1; i < RESOURCE_MAX; i++) putlimit(i);
  }
  else
  {
    if ((i  = findresource(argv[1])) == -1) return error(ERR_LIMIT, argv[0]);
    if (argc == 2) putlimit(i);
    else
    {
      int limit;
      char *arg = readdecimal(argv[2], &limit);

      unless (*arg == '\0') return error(ERR_SCALEFACTOR, argv[0]);
      setlimit(i, limit);
    }
  }
  return OK;
#else
  if (argc > 1) error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_login(argc, argv)
int argc;
char *argv[];
{
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (login)
  {
    execv(LOGIN_CMD, argv);
    return syserr(LOGIN_CMD);
  }
  return error(ERR_NOTLOGIN, NULL);
}

int b_logout(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (login)
  {
    freeargv(argv);
    logout(OK);
  }
  return error(ERR_NOTLOGIN, NULL);
}

int b_nice(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_nohup(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_notify(argc, argv)
int argc;
char *argv[];
{
  JOB *job;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
  }
  else
  {
    char *arg = argv[1];

    unless (*arg++ == '%') return error(ERR_NOSUCHJOB, argv[0]);
    if (arg[0] == '\0' OR
        ((arg[0] == '%' OR arg[0] == '+') AND arg[1] == '\0'))
    {
      if ((job = currentjob()) == NULL) return error(ERR_NOCURJOB, argv[0]);
    }
    else if (arg[0] == '-' AND arg[1] == '\0')
    {
      if ((job = previousjob()) == NULL) return error(ERR_NOPREVJOB, argv[0]);
    }
    else
    {
      int number;

      ignore readdecimal(arg, &number);
      if ((job = getjob(number)) == NULL) return error(ERR_NOSUCHJOB, argv[0]);
    }
  }
  job->notify = TRUE;
  return OK;
}

int b_onintr(argc, argv)
int argc;
char *argv[];
{
  if (interactive) return error(ERR_TERMINAL, argv[0]);
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_popd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    unless (popdir(path)) return error(ERR_STACKEMPTY, argv[0]);
    unless (changedir(path)) return syserr(path);
    dirs();
    return OK;
  }
  else if (argv[1][0] == '+')
  {
    int number;
    char *arg = readdecimal(argv[1] + 1, &number);

    if (*arg == '\0')
    {
      unless (getdir(number, path)) return error(ERR_NOTTHATDEEP, argv[0]);
      return OK;
    }
  }
  return error(ERR_BADDIR, argv[0]);
}

#ifdef HELIOS
int b_printenv(argc, argv)
int argc;
char *argv[];
{
  char **envp = environ;
  char *env;

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  until ((env = *envp++) == NULL) printf("%s\n", env);
  return OK;
}
#endif

int b_pushd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    unless (popdir(path)) return error(ERR_NOOTHERDIR, argv[0]);
    unless (pushdir(path)) return syserr(path);
    return OK;
  }
  else if (argv[1][0] == '+')
  {
    int number;
    char *arg = readdecimal(argv[1] + 1, &number);

    if (*arg == '\0')
    {
      unless (getdir(number, path)) return error(ERR_NOTTHATDEEP, argv[0]);
      unless (pushdir(path)) return syserr(path);
      return OK;
    }
  }
  unless (pushdir(argv[1])) return syserr(argv[1]);
  return OK;
}

#ifdef HELIOS
int b_pwd(argc, argv)
int argc;
char *argv[];
{
  char path[PATH_MAX + 1];

  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  if (getcwd(path, PATH_MAX) == NULL) return syserr(argv[0]);
  printf("%s\n", path);
  return OK;
}
#endif

int b_rehash(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  hash();
  return OK;
}

int b_repeat(argc, argv)
int argc;
char *argv[];
{
  int count;
  char *arg;

  if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]);
  arg = readdecimal(argv[1], &count);
  unless (*arg == '\0') return error(ERR_BADNUMBER, argv[0]);
  while (count--)
  {
    if (testbreak()) recover();
    ignore waitforcmd(runsimplecmd(dupargv(argv + 2), NULL, READ, WRITE));
  }
  return OK;
}

int b_set(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) putvars();
  else
  {
    char *cmd = *argv++;
    char *arg;

    until ((arg = *argv++) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char *text;
      char **newargv;
      int index;

      arg = readname(arg, name);
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);
      switch (*arg++)
      {
        case '\0':
        if (strequ(*argv, "="))
        {
          argv++;
          if (strequ(*argv, "("))
          {
            newargv = nullargv();

            argv++;
            until (strequ(arg = *argv++, ")")) newargv = addword(newargv, arg);
             set(name, newargv); 
          }
          else set(name, makeargv(*argv++));
        }
        else set(name, makeargv(""));
        break;
 
        case '[':
        arg = readdecimal(arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
        if (*arg == '\0')
        {
          if (strequ(*argv, "="))
          {
            argv++;
            text = *argv++;
          }
          else text = "";
        }
        else
        {
          unless (*arg++ == '=') return error(ERR_SYNTAX, cmd);
          text = arg;
        }
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
        break;

        case '=':
        unless (*arg == '\0') set(name, makeargv(arg));
        else
        {
          if (strequ(*argv, "("))
          {
            newargv = nullargv();

            argv++;
            until (strequ(arg = *argv++, ")")) newargv = addword(newargv, arg);
            set(name, newargv); 
          }
          else set(name, makeargv(""));
        }
        break;

        default:
        return error(ERR_SYNTAX, cmd);
      }
    } 
  }
  return OK;
}

int b_setenv(argc, argv)
int argc;
char *argv[];
{
  if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  setenv(argv[1], argv[2]);
  return OK;
}

int b_shift(argc, argv)
int argc;
char *argv[];
{
  char *name;
  char **oldargv;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc == 1) name = "argv";
  else name = argv[1];
  unless ((oldargv = findvar(name)) == NULL)
  {
    unless (lenargv(oldargv)) return error(ERR_NOMOREWORDS, argv[0]);
    set(name, dupargv(oldargv + 1));
    return OK;
  }
  return error(ERR_VARIABLE, name);
}

int b_source(argc, argv)
int argc;
char *argv[];
{
  jmp_buf savehome;			/* CFL	Fix to bug #182		*/
  int result;				/*				*/
  int savemode = mode;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 3) return error(ERR_TOOMANYARGS, argv[0]);
  if (strequ("-h", argv[1]))
  {
  	if (argc < 3) return error(ERR_TOOFEWARGS, argv[0]); /*jd*/
    if (record(argv[2])) return OK;
    return syserr(argv[2]);
  }
  setmode(MODE_EXECUTE);
  unsetmode(MODE_HISTORY);
  memcpy (savehome, home, sizeof (jmp_buf));	/* set up private net	*/
  if ((result = catch ()) != 0)		/* and catch the error exit	*/
  {
    mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
    throw (result);
  }
  if (source(argv[1]))
  {
    mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
    return OK;
  }
  mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
  return syserr(argv[1]);
}

int b_stop(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_suspend(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
}

int b_switch(argc, argv)
int argc;
char *argv[];
{
  char line[LINE_MAX + 1];
  char *str;
  int nestcount = 1;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc < 4) return error(ERR_SYNTAX, argv[0]);
  if (argc > 4) return error(ERR_SYNTAX, argv[0]);
  initexprparse(argv + 1);
  unless (token == T_LPAREN) return error(ERR_SYNTAX, argv[0]);
  readexprtoken();
  str = currentword;
  readexprtoken();
  unless (token == T_RPAREN) return error(ERR_SYNTAX, argv[0]);
  do
  {
    char *lineptr;

    unless (getline(line, TRUE)) break;
    unless ((lineptr = getword(line)) == NULL)
    {
      if (strequ("switch", wordbuffer)) nestcount++;
      if (strequ("endsw", wordbuffer)) nestcount--;
      if (nestcount == 1)
      {
        if (strequ("default", wordbuffer)) break;
        if (strequ("default:", wordbuffer)) break;
        if (strequ("case", wordbuffer))
        {
          int length;

          unless (getword(lineptr) == NULL)
          {
            if (((length = strlen(wordbuffer)) > 0) AND
                (wordbuffer[length - 1] == ':')) wordbuffer[length - 1] = '\0';
            if (match(str, wordbuffer)) break;
          }
        }
      }
    }
  } while (nestcount > 0);
  return OK;
}

int b_time(argc, argv)
int argc;
char *argv[];
{
#ifdef NEWCODE
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {

  }
  else
  {
    waitforcmd(runsimplecmd(dupargv(argv + 1), NULL, READ, WRITE));
  }
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_umask(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  char *arg;
  int mask;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    mask = umask(0);
    umask(mask);
    printf("%o\n", mask);
    return OK;
  }
  arg = readoctal(argv[1], &mask);
  unless (*arg == '\0') return error(ERR_MASK, argv[0]);
  umask(mask);
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_unalias(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *argv++) == NULL) unalias(arg);
  return OK;
}

int b_unhash(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  unhash();
  return OK;
}

int b_unlimit(argc, argv)
int argc;
char *argv[];
{
#ifdef UNIX
  int i;

  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  if (argc < 2)
  {
    for (i = 0; i < RESOURCE_MAX; i++) setlimit(i, -1);
  }
  else
  {
    if ((i = findresource(argv[1])) == -1) return error(ERR_LIMIT, argv[0]);
    setlimit(i, -1);
  }
  return OK;
#else
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  return error(ERR_NOTINCLUDED, argv[0]);
#endif
}

int b_unset(argc, argv)
int argc;
char *argv[];
{
  char *arg;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  until ((arg = *argv++) == NULL) unset(arg);
  return OK;
}

int b_unsetenv(argc, argv)
int argc;
char *argv[];
{
  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  if (argc > 2) return error(ERR_TOOMANYARGS, argv[0]);
  delenv(argv[1]);
  return OK;
}

int b_version(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  printf("%s\n", version);
  return OK;
}

int b_wait(argc, argv)
int argc;
char *argv[];
{
  if (argc > 1) return error(ERR_TOOMANYARGS, argv[0]);
  waitforcmd(-1);
  return OK;
}

int b_while(argc, argv)
int argc;
char *argv[];
{
  jmp_buf savehome;			/* CFL	while should not record	*/
  int result;				/*	history			*/
  int savemode = mode;
  EXPR *expr;
  int value;
  long position;
  long start, end;

  if (argc < 2) return error(ERR_TOOFEWARGS, argv[0]);
  initexprparse(argv + 1);
  value = evaluate(expr = readexpr(0));
  freeexpr(expr);
  unless (token == T_NEWLINE) return error(ERR_EXPSYNTAX, argv[0]);
  position = lineposition;
  start = note();
  {
    int nestcount = 1;
    char line[LINE_MAX + 1];

    do
    {
      unless (getline(line, TRUE)) return error(ERR_NOEND, argv[0]);
      unless (getword(line) == NULL)
      {
        if (strequ("while", wordbuffer) OR
            strequ("foreach", wordbuffer)) nestcount++;
        if (strequ("end", wordbuffer)) nestcount--;
      }
    } while (nestcount > 0);
  }
  end = note();
  if (value)
  {
    newloop();
    unsetmode(MODE_HISTORY);
    memcpy (savehome, home, sizeof (jmp_buf));	/* set up safety net	*/
    if ((result = catch ()) != 0)		/* and catch error exit	*/
    {
      mode = savemode;
      memcpy (home, savehome, sizeof (jmp_buf));
      throw (result);
    }
   point(start);
    do
    {
      unless (docmdline())
      {
           mode = savemode;
        memcpy (home, savehome, sizeof (jmp_buf));
      	error(ERR_NOEND, argv[0]);
      	recover();
      }
    } until (mode & MODE_END);
    unsetmode(MODE_END);
    if (mode & MODE_BREAK)
    {
      unsetmode(MODE_BREAK);
      point(end);
    }
    else point(position);
     mode = savemode;
    memcpy (home, savehome, sizeof (jmp_buf));
   oldloop();
  }
  return OK;
}

int b_at(argc, argv)
int argc;
char *argv[];
{
  if (argc == 1) putvars();
  else
  {
    char *cmd = *argv++;
    char *arg;

#if 1
    until ((arg = *argv) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char buffer[NUMSTR_MAX + 1];
      EXPR *expr;
      char **newargv;
      char *text;
      int index = -1;

      arg = readname(arg, name);	/* read var name		*/
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);

      if (*arg == '[')			/* read index			*/
      {
        arg = readdecimal(++arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
      }

      if (*arg == '\0' && *++argv != NULL)	/* skip argument end	*/
        arg = *argv;

      if (*arg == '=')			/* '=' found, evaluate expr.	*/
      {
        if (*++arg == '\0')		/* end of argv element:		*/
        {
          if (*++argv != NULL)		/* take next element		*/
            arg = *argv;
          else 				/* or report error		*/
            return error(ERR_SYNTAX, cmd);
        }
        else    			/* expr starts in this element	*/
        {
          text = *argv;			/* copy it to the start		*/
          while ((*text++ = *arg++) != '\0');
        }
        initexprparse(argv);
        text = streval(buffer, expr = readexpr(0));
        freeexpr(expr);
        argv = wordlist;
      }
      else				/* no expression found		*/
      {
      	if (*arg == '\0')		/* nothing left in the element	*/
      	  argv++;
      	else				/* something more to process	*/
      	{
          text = *argv;			/* copy it to the start		*/
          while ((*text++ = *arg++) != '\0');
        }
      	text = "";			/* set empty value		*/
      }
      if (index < 0)
        set(name, makeargv(text));
      else
      {
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
      }
    }
#else
    until ((arg = *argv++) == NULL)
    {
      char name[VARNAME_MAX + 1];
      char buffer[NUMSTR_MAX + 1];
      EXPR *expr;
      char **newargv;
      char *text;
      int index;

      arg = readname(arg, name);
      if (name[0] == '\0') return error(ERR_SYNTAX, cmd);
      switch (*arg++)
      {
        case '\0':
        if (strequ(*argv, "="))
        {
          argv++;
#ifdef JON
	  if (*argv == NULL)
	    set(name, makeargv(""));
	  else
	  {
#endif
          initexprparse(argv);
          set(name, makeargv(streval(buffer, expr = readexpr(0))));
          freeexpr(expr);
          argv = wordlist;
#ifdef JON
	  }
#endif	  
        }
        else set(name, makeargv(""));
        break;

        case '[':
        arg = readdecimal(arg, &index);
        unless (*arg++ == ']') return error(ERR_SYNTAX, cmd);
        if (*arg == '\0')
        {
          if (strequ(*argv, "="))
          {
            argv++;
            initexprparse(argv);
            text = streval(buffer, expr = readexpr(0));
            freeexpr(expr);
            argv = wordlist;
          }
          else text = "";
        }
        else
        {
          unless (*arg++ == '=') return error(ERR_SYNTAX, cmd);
          text = arg;
        }
        if ((newargv = findvar(name)) == NULL)
          return error(ERR_VARIABLE, name);
        unless (setword(name, newargv, index, text))
          return error(ERR_SUBSCRIPT, cmd);
        break;

        case '=':
        unless (*arg == '\0')
        {
          argv--;
#if 1
	/* debug by PAB 11/1/90 */
	/* avoids corrupting the pointers used later to free argv arrays */
      	{
      		char *targ = *argv;
      		
      	while ((*targ++ = *arg++) != '\0')
      	;/*null stat*/
      	*targ = '\0';
	}
#else   
      *argv = arg;			/* !!! Corrupts argv entry !!!	*/
#endif 
       }
        initexprparse(argv);
        set(name, makeargv(streval(buffer, expr = readexpr(0))));
        freeexpr(expr);
        argv = wordlist;
        break;

        default:
        return error(ERR_SYNTAX, cmd);
      }
    } 
#endif        
  }
  return OK;
}
@
