head	1.24;
access;
symbols
	Helios_1_3_1:1.24
	Helios_C40_1_3_Official_Release:1.22
	Alenia_release:1.21
	Helios1_3:1.21
	C40_Field_Test_2:1.21
	C40_Field_Test_R1:1.19
	Helios13_beta:1.19
	Helios1_2_2:1.18
	Helios1_2_2Beta:1.16
	Helios1_2_1:1.14
	Helios1_2:1.8;
locks; strict;
comment	@ * @;


1.24
date	93.08.12.15.19.45;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	93.08.04.14.49.16;	author bart;	state Exp;
branches;
next	1.22;

1.22
date	93.04.20.13.13.40;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	92.09.18.12.31.08;	author martyn;	state Exp;
branches;
next	1.20;

1.20
date	92.08.17.13.35.14;	author paul;	state Exp;
branches;
next	1.19;

1.19
date	92.04.09.14.10.50;	author martyn;	state Exp;
branches;
next	1.18;

1.18
date	91.10.31.16.49.03;	author martyn;	state Exp;
branches;
next	1.17;

1.17
date	91.10.31.14.57.32;	author martyn;	state Exp;
branches;
next	1.16;

1.16
date	91.07.03.10.14.31;	author martyn;	state Exp;
branches;
next	1.15;

1.15
date	91.04.10.16.19.05;	author martyn;	state Exp;
branches;
next	1.14;

1.14
date	91.03.14.18.01.38;	author nick;	state Exp;
branches;
next	1.13;

1.13
date	91.02.14.11.52.38;	author paul;	state Exp;
branches;
next	1.12;

1.12
date	91.01.17.18.52.09;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	90.12.11.12.05.31;	author martyn;	state Exp;
branches;
next	1.10;

1.10
date	90.12.11.11.48.02;	author martyn;	state Exp;
branches;
next	1.9;

1.9
date	90.12.06.11.42.17;	author martyn;	state Exp;
branches;
next	1.8;

1.8
date	90.11.23.18.07.16;	author martyn;	state Exp;
branches;
next	1.7;

1.7
date	90.11.22.12.34.42;	author martyn;	state Exp;
branches;
next	1.6;

1.6
date	90.11.16.11.23.22;	author nick;	state Exp;
branches;
next	1.5;

1.5
date	90.11.13.10.48.58;	author martyn;	state Exp;
branches;
next	1.4;

1.4
date	90.11.12.17.16.31;	author martyn;	state Exp;
branches;
next	1.3;

1.3
date	90.10.09.10.52.23;	author martyn;	state Exp;
branches;
next	1.2;

1.2
date	90.09.25.12.47.52;	author paul;	state Exp;
branches;
next	1.1;

1.1
date	90.08.23.16.06.31;	author james;	state Exp;
branches;
next	;


desc
@@


1.24
log
@fixed compile time warnings
@
text
@/**
*
* Title:  Helios Shell - Administration.
*
* Author: Andy England
*
* Date:   May 1988
*
*         (c) Copyright 1988, Perihelion Software Ltd.
*
*         All Rights Reserved.
*
**/
#ifdef __TRAN
static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.23 1993/08/04 14:49:16 bart Exp nickc $";
#endif

#include "shell.h"
#ifndef __TRAN
#include <process.h>
#endif
#include <sys/wait.h>


int main(
	 int argc,
	 char *argv[] )
{
#ifdef DEBUGGING
  DebugInit();
  DEBUG("main(%V)",argv);
  DEBUG("stdin = %S", Heliosno (stdin));
  DEBUG("stdout= %S", Heliosno (stdout));
  DEBUG("stderr= %S", Heliosno (stderr));
  debugging = 1;
#endif

#ifndef __TRAN
  /* get better keyboard response on heavily loaded system */
  SetPriority(ServerPri);
#endif

  signal(SIGINT, SIG_IGN);
  if(!catch())				/* catch errors in rc files */
       initialise(argc, argv);
  shell();
  logout(OK);
  return OK;
}

void shell()
{
#ifdef DEBUGGING
  DEBUG("shell()");
#endif
  if (catch() AND (singleline OR exitonerror)) return;
  if (singleline) ignore docmdline();
  else while (docmdline());
}

BOOL docmdline()
{
  char line[LINE_MAX + 1];

#ifdef DEBUGGING
  DEBUG("docmdline()");
#endif
  lineposition = note();
  pendingjobs();
  if (getline(line, FALSE) == NULL)
  {
    unless (interactive AND findvar("ignoreeof")) return FALSE;
    printf("^D\n");
    if (login) error(ERR_USELOGOUT, NULL);
    else error(ERR_USEEXIT, NULL);
    recover();
  }
  ignore runcmdline(line);
  return TRUE;
}

int runcmdline(char *line )
{
  ARGV argv;
  int code = 0;

#ifdef DEBUGGING
  DEBUG("runcmdline('%s')", line);
#endif

  usingcdl = (getvar("cdl") == NULL) ? FALSE : TRUE;
#ifdef HELIOS
  _posixflags((usingcdl ? PE_BLOCK : PE_UNBLOCK), PE_RemExecute);
#endif
  argv = historysub(buildargv(makeargv(line)));
  if (initparse(argv))
  {
    globcmd = readcmdlist(0);
    if (parsingerror) recover();
    unless (globcmd == NULL)
    {
      tidyupparse();
      if (mode & MODE_EXECUTE)
      {
        code = runcmdlist(globcmd);
        if (exitonerror AND code) logout(code);
      }
      freecmd(globcmd);
      globcmd = NULL;
    }
  }
  return code;
}

void initialise(
		int argc,
		char **argv )
{
  char path[PATH_MAX + 1];
  char *cmdline = NULL;
  BOOL cdl = FALSE;
  BOOL echo = FALSE;
  BOOL verbose = FALSE;
  BOOL standard = FALSE;
  BOOL parseonly = FALSE;

  login = (BOOL)(*argv++[0] == '-'); argc--;
  shellpid = getpid();
  sysinit();
  InitList(&aliaslist);
  InitList(&historylist);
  InitList(&varlist);
  InitList(&dirlist);
  InitList(&joblist);
  InitList(&filelist);
  InitList(&looplist);

  while (argc > 0 AND **argv == '-')
  {
    char c;
    char *arg = *argv++; argc--;

    arg++;
    until ((c = *arg++) == '\0')
    {
      switch (c)
      {
        case 'c':
        if (*arg == '\0')
        {
          if (argc == 0) exit(1);
          cmdline = *argv++; argc--;
        }
        else cmdline = arg;
        break;

        case 'd':
        debugging = TRUE;
        continue;

        case 'e':
        exitonerror = TRUE;
        continue;

        case 'f':
        fast = TRUE;
        continue;

        case 'i':
        interactive = TRUE;
        continue;

        case 'n':
        parseonly = TRUE;
        continue;

        case 's':
        standard = TRUE;
        continue;

        case 't':
        singleline = TRUE;
        continue;

        case 'v':
        verbose = TRUE;
        continue;

        case 'x':
        echo = TRUE;
        continue;

        case 'z':
        cdl = TRUE;
        continue;

        case 'V':
        set("verbose", makeargv(""));
        continue;

        case 'X':
        set("echo", makeargv(""));
        continue;

        case 'Z':
        set("cdl", makeargv(""));
        continue;
      }
      break;
    }
  }
  if (argc == 0 OR cmdline OR interactive OR standard OR singleline)
  {
    filename = NULL;
    inputfile = stdin;
  }
  else
  {
    argc--;
    filename = *argv++;
    if ((inputfile = fopen(filename, "r")) == NULL)
    {
      syserr(filename);
      exit(1);
    }
    fcntl(fileno(inputfile), F_SETFD, FD_CLOEXEC);
  }
  if (argc > 0) set("argv", dupargv(argv));
  else set("argv", nullargv());
  set("autologout", nummakeargv(10));
  unless (getenv("CDL") == NULL) set("cdl", makeargv(""));
#ifdef HELIOS
  set("console", envmakeargv("CONSOLE"));
#endif
  set("cwd", makeargv(getcwd(path, PATH_MAX)));
  set("home", envmakeargv("HOME"));
#ifdef HELIOS
  MachineName(path);
  set("machine", makeargv(path));
#endif
  set("path", envmakeargv("PATH"));
  set("prompt", makeargv(PROMPT));
  set("shell", makeargv(SHELL_CMD));
  set("status", nummakeargv(OK));
  set("term", envmakeargv("TERM"));
  set("user", envmakeargv("USER"));

#ifdef DEBUGGING
  DEBUG("environment set");
#endif
  unless (interactive) interactive = (BOOL) isatty(fileno(inputfile));
  unless (parseonly) setmode(MODE_EXECUTE);
  unless (fast)
  {
    unsetmode(MODE_HISTORY);
    if(!source(homename(path, CSHRC_FILE)))
	ignore source(homename(path,CSHRC_FILE_V11));
    if (login) 
	if (!source(homename(path, LOGIN_FILE)))
		ignore source(homename(path, LOGIN_FILE_V11));
    if(!record(homename(path, HISTORY_FILE)))
    	ignore record(homename(path, HISTORY_FILE_V11));
#if 0
    /* experimental: PAB doesn't think this time consuming hash is required */
    hash();
#endif
  }
  setmode(MODE_HISTORY);
  if (verbose) set("verbose", makeargv(""));
  if (echo) set("echo", makeargv(""));
  if (cdl) set("cdl", makeargv(""));
  siginit();
  unless (cmdline == NULL)
  {
    int code;

    if ((code = catch()) == 0) code = runcmdline(cmdline);
    logout(code);
  }
}

void logout(int code)
{
#ifdef DEBUGGING
  DEBUG("logout(%d)", code);
#endif

  unless (fast)
  {
    char path[PATH_MAX + 1];
    char *savehist;

    unless ((savehist = getvar("savehist")) == NULL)
    {
      int count;

      if ((count = atoi(savehist)) > 0)
      {
        FILE *file;
	file = fopen(homename(path, HISTORY_FILE), "w");
	if ( file == NULL )
          file = fopen(homename(path, HISTORY_FILE_V11), "w");
        unless (file == NULL)
        {
          fputsublist(file, &historylist, count, TRUE, TRUE, FALSE);
          fclose(file);
        }
      }
    }
    if (login)
      if (!source(homename(path, LOGOUT_FILE)))
	ignore source(homename(path, LOGOUT_FILE_V11));
  }
  freecmd(globcmd);
  freeargv(globargv);

  WalkList(&aliaslist, (WordFnPtr)freesubnode);
  WalkList(&historylist, (WordFnPtr)freesubnode);
  WalkList(&varlist, (WordFnPtr)freesubnode);
  WalkList(&dirlist, (WordFnPtr)freedirnode);
  if (login) WalkList(&joblist, (WordFnPtr)killjob);
  WalkList(&joblist, (WordFnPtr)freejob);
  freelinevector();
  unhash();
  systidy();
  exit(code);
}

char *homename(
	       char *path,
	       char *name )
{
  char *home;

  unless ((home = getvar("home")) == NULL) formfilename(path, home, name);
  else strcpy(path, name);
  return path;
}

BOOL source(char *name )
{
  FILE *file;

#ifdef DEBUGGING
  DEBUG("source('%s')", name);
#endif
  if ((file = fopen(name, "r")) == NULL) return FALSE;
  newfile(file);
  while (docmdline()) {
	if(testbreak())
		{
		innewfile = FALSE;
		recover();
		}
  }

  oldfile();
  return TRUE;
}

BOOL record(char *name)
{
  char line[LINE_MAX + 1];
  FILE *file;

#ifdef DEBUGGING
  DEBUG("record(%s)",name);
#endif
  if ((file = fopen(name, "r")) == NULL) return FALSE;
  until (fgets(line, LINE_MAX, file) == NULL)
  /* ACE: buildargv can error on unmatched ' ! */
    addevent(buildargv(makeargv(line)));
  fclose(file);
  return TRUE;
}

BOOL getinterpreter(
		    char * interp,
		    char * name )
{
  int fd, length, i;
  int index = 0;
  char *shell;

#ifdef DEBUGGING
  DEBUG("getinterpreter = %");
#endif
  if ((fd = open(name, O_RDONLY)) == -1) return FALSE;
  if ((length = read(fd, interp, LINE_MAX)) < 0) return FALSE;
  close(fd);
  for (i = 0; i < length; i++)
  {
    unless (isprint(interp[i]) OR isspace(interp[i])) return FALSE;
  }
  interp[length] = '\0';
  if (interp[0] == '#' AND interp[1] == '!')
  {
    i = 2;
    while (isspace(interp[i]) AND isprint(interp[i])) i++;
    until (isspace(interp[i]) OR interp[i] == '\0')
      interp[index++] = interp[i++];
  }
  if (index > 0)
  {
    interp[index] = '\0';
#ifdef DEBUGGING
    DEBUG ("%s", interp);
#endif
    return TRUE;
  }
  if ((shell = getvar("shell")) == NULL) shell = SHELL_CMD;
  strcpy(interp, shell);
#ifdef DEBUGGING
  DEBUG ("%s", interp);
#endif
  return TRUE;
}

void executecmd(
		char *name,
		ARGV argv )
{
#ifdef DEBUGGING
  DEBUG("executecmd(%s (%s %s %s) %V)", name,
     fdstream(0)->Name, fdstream(1)->Name, fdstream(2)->Name, argv);
#endif
  execvp(name, argv);                        /*JD:change to execvp fromexecv*/
  if (errno == 0)
    errno = ENOMEM;		/* added by NC to cope with bug in kernel */
#ifdef DEBUGGING
  DEBUG("execvp failed, errno = %d", errno);
#endif
  if (errno == ENOEXEC)
  {
    char interp[PATH_MAX + 1];

    if (getinterpreter(interp, name))
    {
      char *newargv[100];
      int i;

      newargv[0] = interp;
      newargv[1] = name;
      for (i = 2; i < 100; i++)
      {
      	if ((newargv[i] = argv[i - 1]) == NULL) break;
      }
      newargv[i] = NULL;
      execvp(interp, newargv);
      if (errno == 0)
        errno = ENOMEM;		/* added by NC to cope with bug in kernel */
#ifdef DEBUGGING
      DEBUG("execvp failed, errno = %d", errno);
#endif
      syserr(interp);
      _exit(1);
    }
    errno = ENOEXEC;
  }
  unless (errno == ENOENT)
  {
    syserr(name);
    _exit(1);
  }
}

int waitforcmd(int pid )
{
  int wpid, status, code;

#ifdef DEBUGGING
  DEBUG("waitforcmd(%d)", pid);
#endif
  if (pid == -1)
	{
	if(testbreak())
	      recover();
	return(-1);
	}
  waitwrpid = pid;
  until ((wpid = wait2(&status, WUNTRACED)) == pid OR (wpid == -1 && errno != EINTR)) 
    if( wpid != -1 ) notifyjob(wpid, status);
  unless (wpid == -1) notifyjob(pid, status);
  waitwrpid = 0;
  set("status", nummakeargv(code = highbyte(status)));
  if(testbreak())
	recover();
#ifdef HELIOS
  ctrlcbegin();
#endif
  return code;
}

int runcmdlist(CMD *cmd)
{
  int code = 0;
  int pid;

#ifdef DEBUGGING
 DEBUG("runcmdlist()");
#endif
  for (; cmd; cmd = cmd->next)
  {
    switch (cmd->op)
    {
      case T_SEMICOLON:
      code = waitforcmd(runpipeline(cmd->This));
      break;

      case T_AMPERSAND:
      backgroundtask = TRUE;
      if (isdelimitor(cmd->This->op)) pid = runlist(cmd->This, NULL, READ, WRITE);
      else pid = runpipeline(cmd->This);
      unless (pid == -1) newjob(cmd->This, pid);
      backgroundtask = FALSE;
      break;

      case T_AND:
      unless ((code = waitforcmd(runpipeline(cmd->This))) == 0) return code;
      break;

      case T_OR:
      if ((code = waitforcmd(runpipeline(cmd->This))) == 0) return code;
      break;

      default:
      return waitforcmd(runpipeline(cmd));
    }
  }
  return code;
}

int runpipeline(CMD *cmd)
{
  int fd = READ;
  int fds[2];
  int pid = -1;

#ifdef DEBUGGING
  DEBUG("runpipeline()");
#endif
  for (; cmd; cmd = cmd->next)
  {
    switch (cmd->op)
    {
#ifdef CDL
      case T_PAR:
      case T_FARM:
      case T_SUBORDINATE:
      case T_REVPIPE:
#endif
      case T_PIPE:
#ifdef DEBUGGING
      DEBUG("PIPE");
#endif
#ifdef CDL
      if (usingcdl) return runtaskforce(cmd);
#endif
#ifdef HELIOS
      if (cmd->This->op == T_SIMPLE AND ((ARGV)cmd->This->This)[0] != NULL AND
          findbuiltin(((ARGV)cmd->This->This)[0]) != NULL)
      {
      	if (fifo(fds) == -1)
      	{
          int save_err = errno;
          unless (fd == READ) close(fd);
	  errno = save_err;
          syserr(NULL);
          recover();
        }
      }
      else
#endif
      if (pipe(fds) == -1)
      {
        int	save_err = errno;
        unless (fd == READ) close(fd);
	errno = save_err;
        syserr(NULL);
        recover();
      }
      fcntl(fds[READ], F_SETFD, FD_CLOEXEC);
      ignore runcmd(cmd->This, fd, fds[WRITE]);
      close(fds[WRITE]);
      unless (fd == READ) close(fd);
      fd = fds[READ];
#ifdef DEBUGGING
      DEBUG("talk to cmd on %d", fd);
#endif
      break;

      default:
      pid = runcmd(cmd, fd, WRITE);
      unless (fd == READ) close(fd);
      return pid;
    }
  }
  return pid;
}

int runcmd(
	   CMD *cmd,
	   int  ifd,
	   int  ofd )
{
#ifdef DEBUGGING
  DEBUG("runcmd()");
#endif
  if (cmd->op == T_LIST) return runlist(cmd->This, cmd->ioinfo, ifd, ofd);
#ifdef CDL
  if (usingcdl AND cmd->next != NULL) return runtaskforce(cmd);
#endif
  return runsimplecmd(dupargv((ARGV)cmd->This), cmd->ioinfo, ifd, ofd, CHECKBUILTIN);
}

int runlist(
	    CMD *cmd,
	    IOINFO *ioinfo,
	    int ifd,
	    int ofd )
{
  int pid;

#ifdef DEBUGGING
  DEBUG("runlist()");
#endif
#ifdef UNIX
  if ((pid = fork()) == 0)
  {
    unless (redirect(ioinfo, ifd, ofd)) _exit(1);
    shellpid = getpid(); /* ACE: Is this necessary ? */
    _exit(runcmdlist(cmd));
  }
#else
  if ((pid = vfork()) == 0)
  {
    char buffer[WORD_MAX + 1];

    unless (redirect(ioinfo, ifd, ofd)) _exit(1);
    buffer[0] = '\0';
    sputcmd(buffer, cmd);
    execl(SHELL_CMD, "shell", "-fc", buffer, NULL);
    syserr(NULL);
    _exit(1);
  }
#endif
  if(backgroundtask)
	ignore setpgid(pid, pid);
  if (pid == -1)
  {
    syserr(NULL);
    recover();
  }
  return pid;
}

void savefds(int *fds)
{
  int i;

  for (i = 0; i < 3; i++) fds[i] = dup(i);
  if(!fdssaved)
	for(i = 0 ; i < 3 ; i++)
		sfds[i] = fds[i];
  fdssaved++;
}

void restorefds(int *fds)
{
  int i;

  for (i = 0; i < 3; i++)
  {
    close(i);
    dup(fds[i]);
    close(fds[i]);
  }
  fdssaved--;
}

int runbuiltin(
	       int (*func)(),
	       ARGV argv,
	       IOINFO *ioinfo,
	       int ifd,
	       int ofd )
{
  int code, pid;
  int fds[3];

#ifdef DEBUGGING
  DEBUG("runbuiltin(fn,%s)",argv[0]);
#endif

  if (needsfullsubs(func)) argv = fullsub(argv);
  else argv = smallsub(argv);
  savefds(fds);
  unless (redirect(ioinfo, ifd, ofd))
  {
    restorefds(fds);
    freeargv(argv);
    recover();
  }
  if (findvar("echo")) fputargv(stderr, argv, TRUE);
  code = (*func)(lenargv(argv), argv);
  freeargv(argv);     /* are these freed if (*func() longjmps ?? */
  restorefds(fds);
  if ((pid = vfork()) == 0) _exit(code);
  if (pid == -1)
  {
    syserr(NULL);
    recover();
  }
  return pid;
}

int runsimplecmd(
		 ARGV argv,
		 IOINFO *ioinfo,
		 int ifd,
		 int ofd,
		 int bcmdcheck )
{
  BUILTIN *builtin;
  int pid = -1;

/* move 'name' declaration to here from inner 'until' loop */
/* to resolve memory leakage problem B433                  */
/* MJT 08/10/90                                            */

  char name[PATH_MAX + 1];

  
#ifdef DEBUGGING
  DEBUG("runsimplecmd(%s)",argv[0]);
#endif
  if (argv[0] == NULL)
  {
    freeargv(argv);
    return -1;
  }
  if(testbreak())
	recover();

  if(bcmdcheck)		/* if asked to check for builtin commands */
  unless ((builtin = findbuiltin(argv[0])) == NULL) {
    return runbuiltin(builtin->func, argv, ioinfo, ifd, ofd);
  }
  argv = fullsub(argv);
#if 0
  if(lenargv(argv) + lenargv(environ) > MAX_ARGV)
	{	
	fprintf(stderr, "Arg list too long\n");
	fflush(stderr);
	freeargv(argv);
	return pid;
	}
#endif
  if ((pid = vfork()) == 0)
  {
    unless (redirect(ioinfo, ifd, ofd)) _exit(1);
    if (findvar("echo")) fputargv(stderr, argv, TRUE);
    if (isabspath(argv[0]))
    {
#ifdef HELIOS
      if (lookforcmd(".", argv[0]))
#endif
      executecmd(argv[0], argv);
    }
    else
    {
      ARGV pathargv;
      char *path;

      unless ((pathargv = findvar("path")) == NULL)
      {
        until ((path = *pathargv++) == NULL)
        {
          if (lookforcmd(path, argv[0]))
          {
            formfilename(name, path, argv[0]);
            executecmd(name, argv);
          }
        }
      }
    }
    error(ERR_NOTFOUND, argv[0]);
    _exit(1);
  }
  if(backgroundtask)
	ignore setpgid(pid, pid);
  freeargv(argv);
  if (pid == -1)
  {
    syserr(NULL);
    recover();
  }
  return pid;
}

BOOL redirect(
	      IOINFO *ioinfo,
	      int ifd,
	      int ofd )
{
  OPENINFO *inputinfo = (ioinfo == NULL) ? NULL : ioinfo->input;
  OPENINFO *outputinfo = (ioinfo == NULL) ? NULL : ioinfo->output;
  OPENINFO *diaginfo = (ioinfo == NULL) ? NULL : ioinfo->diag;
  char *name;

#ifdef DEBUGGING
 DEBUG("redirect(%d,%d) (%x %x %x)", ifd, ofd, inputinfo, outputinfo, diaginfo);
#endif
  unless (ifd == READ)
  {
    unless (inputinfo == NULL)
    {
      error(ERR_INPUT, NULL);
      return FALSE;
    }
    close(READ);
    dup(ifd);
    close(ifd);
  }
  unless (ofd == WRITE)
  {
    unless (outputinfo == NULL)
    {
      error(ERR_OUTPUT, NULL);
      return FALSE;
    }
    close(WRITE);
    dup(ofd);
    close(ofd);
  }
  if (diaginfo != NULL AND outputinfo != NULL AND outputinfo->flags & FLAG_STDERR)
  {
    error(ERR_DIAGNOSTIC, NULL);
    return FALSE;
  }
  unless (diaginfo == NULL)
  {
    int flags = O_WRONLY | O_CREAT;
    ARGV argv = fullsub(makeargv(diaginfo->name));

    freememory((int *)diaginfo->name);
    diaginfo->name = name = strdup(argv[0]);
    freeargv(argv);
    if (diaginfo->op == T_APPENDDIAG) flags |= O_APPEND;
    else flags |= O_TRUNC;
    if (findvar("noclobber") AND (diaginfo->flags & FLAG_CLOBBER) == 0)
      flags |= O_EXCL;
    close(DIAGNOSTIC);
    if (open(name, flags, 0666) == -1)
    {
      syserr(name);
      return FALSE;
    }
  }
  unless (outputinfo == NULL)
  {
    int flags = O_WRONLY | O_CREAT;
    ARGV argv = fullsub(makeargv(outputinfo->name));

    freememory((int *)outputinfo->name);
    outputinfo->name = name = strdup(argv[0]);
    freeargv(argv);
    if (outputinfo->op == T_APPEND) flags |= O_APPEND;
    else flags |= O_TRUNC;
    if (findvar("noclobber") AND (outputinfo->flags & FLAG_CLOBBER) == 0)
      flags |= O_EXCL;
    close(WRITE);
    if (open(name, flags, 0666) == -1)
    {
      syserr(name);
      return FALSE;
    }
    if (outputinfo->flags & FLAG_STDERR)
    {
      close(DIAGNOSTIC);
      dup(WRITE);
    }
  }
  unless (inputinfo == NULL)
  {
    if (inputinfo->op == T_READ)
    {
      ARGV argv = fullsub(makeargv(inputinfo->name));

      freememory((int *)inputinfo->name);
      inputinfo->name = name = strdup(argv[0]);
      freeargv(argv);
      close(READ);
      if (open(name, O_RDONLY, 0) == -1)
      {
      	syserr(name);
      	return FALSE;
      }
    }
    else
    {
      FILE *file;
      char *terminator = inputinfo->name;
      char line[LINE_MAX + 1];
      int length = strlen(terminator);

      if ((file = fopen(TEMP_FILE, "w")) == NULL)
      {
      	syserr(TEMP_FILE);
      	return FALSE;
      }
      forever
      {
        unless (getline(line, TRUE))
        {
          error(ERR_TERMINATOR, terminator);
          fclose(file);
          return FALSE;
        }
        if (strnequ(terminator, line, length) AND line[length] == '\n') break;
        fputs(line, file);
      } 
      fclose(file);
      close(READ);
      if (open(TEMP_FILE, O_RDONLY, 0) == -1)
      {
      	syserr(TEMP_FILE);
      	return FALSE;
      }
    }
  }
  return TRUE;
}

#ifdef TEST_FDS
#undef open
#undef close
#undef dup
#undef pipe

int myopen(char *name, int mode, int pmode)
{
  int fd = open(name, mode, pmode);

  DEBUG("open('%s') -> %d", name, fd);
  return fd;
}

int myclose(int fd)
{
  int err = close(fd);

  DEBUG("close(%d) -> %d", fd, err);
  return err;
}

int mydup(int fd)
{
  int newfd = dup(fd);

  DEBUG("dup(%d) -> %d", fd, newfd);
  return newfd;
}

int mypipe(int fd[2])
{
  int err = pipe(fd);

  DEBUG("pipe() -> %d (%d, %d)", err, fd[0], fd[1]);
  return err;
}
#endif

#ifdef DEBUGGING
#include "dodebug.c"
#endif

#ifdef CDL
#include "cdl.c"
#endif

@


1.23
log
@1) clean-up so that the shell can be compiled without -DCDL
2) This module now includes dodebug.c and cdl.c, if appropriate, to
   avoid problems with compilers that reject empty translation units.
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.22 1993/04/20 13:13:40 nickc Exp $";
d127 1
a127 1
  login = (*argv++[0] == '-'); argc--;
d251 1
a251 1
  unless (interactive) interactive = isatty(fileno(inputfile));
d507 1
a507 1
      code = waitforcmd(runpipeline(cmd->this));
d512 3
a514 3
      if (isdelimitor(cmd->this->op)) pid = runlist(cmd->this, NULL, READ, WRITE);
      else pid = runpipeline(cmd->this);
      unless (pid == -1) newjob(cmd->this, pid);
d519 1
a519 1
      unless ((code = waitforcmd(runpipeline(cmd->this))) == 0) return code;
d523 1
a523 1
      if ((code = waitforcmd(runpipeline(cmd->this))) == 0) return code;
d560 2
a561 2
      if (cmd->this->op == T_SIMPLE AND ((ARGV)cmd->this->this)[0] != NULL AND
          findbuiltin(((ARGV)cmd->this->this)[0]) != NULL)
d583 1
a583 1
      ignore runcmd(cmd->this, fd, fds[WRITE]);
d609 1
a609 1
  if (cmd->op == T_LIST) return runlist(cmd->this, cmd->ioinfo, ifd, ofd);
d613 1
a613 1
  return runsimplecmd(dupargv((ARGV)cmd->this), cmd->ioinfo, ifd, ofd, CHECKBUILTIN);
@


1.22
log
@fixed compile time warnings
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.21 1992/09/18 12:31:08 martyn Exp nickc $";
d90 1
a90 1
#ifdef CDL
a94 1
#endif
a120 1
#ifdef CDL
a121 1
#endif
a192 1
#ifdef CDL
a195 1
#endif
a204 1
#ifdef CDL
a207 1
#endif
a230 1
#ifdef CDL
a231 1
#endif
a270 1
#ifdef CDL
a271 1
#endif
d287 1
d972 8
@


1.21
log
@minor changes to debugging output
@
text
@d14 3
a16 2

static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.20 1992/08/17 13:35:14 paul Exp $";
d24 4
a27 3
int main(argc, argv)
int argc;
char *argv[];
d82 1
a82 2
int runcmdline(line)
char *line;
d116 3
a118 3
void initialise(argc, argv)
int argc;
char **argv;
d293 1
a293 2
void logout(code)
int code;
d339 3
a341 2
char *homename(path, name)
char *path, *name;
d350 1
a350 2
BOOL source(name)
char *name;
d371 1
a371 2
BOOL record(name)
char *name;
d387 3
a389 2
BOOL getinterpreter(interp, name)
char *interp, *name;
d429 3
a431 3
void executecmd(name, argv)
char *name;
ARGV argv;
d477 1
a477 2
int waitforcmd(pid)
int pid;
d504 1
a504 2
int runcmdlist(cmd)
CMD *cmd;
d543 1
a543 2
int runpipeline(cmd)
CMD *cmd;
d611 4
a614 3
int runcmd(cmd, ifd, ofd)
CMD *cmd;
int ifd, ofd;
d626 5
a630 4
int runlist(cmd, ioinfo, ifd, ofd)
CMD *cmd;
IOINFO *ioinfo;
int ifd, ofd;
d691 6
a696 5
int runbuiltin(func, argv, ioinfo, ifd, ofd)
int (*func)();
ARGV argv;
IOINFO *ioinfo;
int ifd, ofd;
d727 6
a732 4
int runsimplecmd(argv, ioinfo, ifd, ofd, bcmdcheck)
ARGV argv;
IOINFO *ioinfo;
int ifd, ofd, bcmdcheck;
d811 4
a814 3
BOOL redirect(ioinfo, ifd, ofd)
IOINFO *ioinfo;
int ifd, ofd;
@


1.20
log
@get better response from shell by raising its priority
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.19 1992/04/09 14:10:50 martyn Exp $";
d434 2
a435 1
  DEBUG("executecmd(%s %V)", name, argv);
d819 1
a819 1
  DEBUG("redirect(%d,%d)", ifd, ofd);
d952 1
a952 1
  IOdebug("open('%s') -> %d", name, fd);
d960 1
a960 1
  IOdebug("close(%d) -> %d", fd, err);
d968 1
a968 1
  IOdebug("dup(%d) -> %d", fd, newfd);
d976 1
a976 1
  IOdebug("pipe() -> %d (%d, %d)", err, fd[0], fd[1]);
@


1.19
log
@added a setjmp before reading the cshrc and loginrc files. Otherwise,
any error in these files would cause a longjmp into thin air.
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/cmds/shell/RCS/shell.c,v 1.18 1991/10/31 16:49:03 martyn Exp $";
d18 1
a18 1
#ifndef __HELIOSTRAN
d35 6
@


1.18
log
@fixed waitforcmd to return error if pid is invalid
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.17 1991/10/31 14:57:32 martyn Exp martyn $";
d36 2
a37 1
  initialise(argc, argv);
@


1.17
log
@changed signal handling
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.16 1991/07/03 10:14:31 martyn Exp martyn $";
d481 1
@


1.16
log
@added more debugging
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.15 1991/04/10 16:19:05 martyn Exp $";
d35 1
a124 1
  siginit();
d264 1
a264 1
#ifndef __ARM
d275 1
@


1.15
log
@changed runsimplecmd to allow for ignoring of builtin commands
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /hsrc/cmds/shell/RCS/shell.c,v 1.14 1991/03/14 18:01:38 nick Exp martyn $";
d249 3
@


1.14
log
@limit on size of argv removed
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /giga/HeliosRoot/Helios/cmds/shell/RCS/shell.c,v 1.13 91/02/14 11:52:38 paul Exp Locker: nick $";
d612 1
a612 1
  return runsimplecmd(dupargv((ARGV)cmd->this), cmd->ioinfo, ifd, ofd);
d714 1
a714 1
int runsimplecmd(argv, ioinfo, ifd, ofd)
d717 1
a717 1
int ifd, ofd;
d739 2
@


1.13
log
@extra debugging and cut out extraneous hash() for ARM version - seems ok tho
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /giga/Helios/cmds/shell/RCS/shell.c,v 1.12 91/01/17 18:52:09 nickc Exp $";
d743 1
d751 1
@


1.12
log
@added catches to execvp() returning without setting errno
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /giga/Helios/cmds/shell/RCS/shell.c,v 1.11 90/12/11 12:05:31 martyn Exp Locker: nickc $";
d261 2
d264 1
d348 1
a348 1
  while (docmdline())
d354 2
d498 1
a498 1
 #ifdef DEBUGGING
d688 4
d730 1
a730 1
  DEBUG("runsimplecmd(%V)",argv);
d739 1
a739 1
  unless ((builtin = findbuiltin(argv[0])) == NULL)
d741 1
@


1.11
log
@ignore last log message - this is the real thing
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /usr/perihelion/Helios/cmds/shell/RCS/shell.c,v 1.6 90/11/16 11:23:22 nick Exp $";
d421 2
d424 1
a424 1
  DEBUG("execv failed, errno = %d", errno);
d443 2
d560 1
d562 1
d571 1
d573 1
@


1.10
log
@fixes to fix shell background signal handling
@
text
@d1 945
a945 1
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                @


1.9
log
@new fixes to clean up after a stream write error
@
text
@d1 1
a1 939
/**
*
* Title:  Helios Shell - Administration.
*
* Author: Andy England
*
* Date:   May 1988
*
*         (c) Copyright 1988, Perihelion Software Ltd.
*
*         All Rights Reserved.
*
**/

static char *rcsid = "$Header: /usr/perihelion/Helios/cmds/shell/RCS/shell.c,v 1.6 90/11/16 11:23:22 nick Exp $";

#include "shell.h"
#ifndef __HELIOSTRAN
#include <process.h>
#endif
#include <sys/wait.h>

int main(argc, argv)
int argc;
char *argv[];
{
#ifdef DEBUGGING
  DebugInit();
  DEBUG("main(%V)",argv);
  DEBUG("stdin = %S", Heliosno (stdin));
  DEBUG("stdout= %S", Heliosno (stdout));
  DEBUG("stderr= %S", Heliosno (stderr));
  debugging = 1;
#endif
  initialise(argc, argv);
  shell();
  logout(OK);
  return OK;
}

void shell()
{
#ifdef DEBUGGING
  DEBUG("shell()");
#endif
  if (catch() AND (singleline OR exitonerror)) return;
  if (singleline) ignore docmdline();
  else while (docmdline());
}

BOOL docmdline()
{
  char line[LINE_MAX + 1];

#ifdef DEBUGGING
  DEBUG("docmdline()");
#endif
  lineposition = note();
  pendingjobs();
  if (getline(line, FALSE) == NULL)
  {
    unless (interactive AND findvar("ignoreeof")) return FALSE;
    printf("^D\n");
    if (login) error(ERR_USELOGOUT, NULL);
    else error(ERR_USEEXIT, NULL);
    recover();
  }
  ignore runcmdline(line);
  return TRUE;
}

int runcmdline(line)
char *line;
{
  ARGV argv;
  int code = 0;

#ifdef DEBUGGING
  DEBUG("runcmdline('%s')", line);
#endif
#ifdef CDL
  usingcdl = (getvar("cdl") == NULL) ? FALSE : TRUE;
#ifdef HELIOS
  _posixflags((usingcdl ? PE_BLOCK : PE_UNBLOCK), PE_RemExecute);
#endif
#endif
  argv = historysub(buildargv(makeargv(line)));
  if (initparse(argv))
  {
    globcmd = readcmdlist(0);
    if (parsingerror) recover();
    unless (globcmd == NULL)
    {
      tidyupparse();
      if (mode & MODE_EXECUTE)
      {
        code = runcmdlist(globcmd);
        if (exitonerror AND code) logout(code);
      }
      freecmd(globcmd);
      globcmd = NULL;
    }
  }
  return code;
}

void initialise(argc, argv)
int argc;
char **argv;
{
  char path[PATH_MAX + 1];
  char *cmdline = NULL;
#ifdef CDL
  BOOL cdl = FALSE;
#endif
  BOOL echo = FALSE;
  BOOL verbose = FALSE;
  BOOL standard = FALSE;
  BOOL parseonly = FALSE;

  login = (*argv++[0] == '-'); argc--;
  shellpid = getpid();
  sysinit();
  siginit();
  InitList(&aliaslist);
  InitList(&historylist);
  InitList(&varlist);
  InitList(&dirlist);
  InitList(&joblist);
  InitList(&filelist);
  InitList(&looplist);

  while (argc > 0 AND **argv == '-')
  {
    char c;
    char *arg = *argv++; argc--;

    arg++;
    until ((c = *arg++) == '\0')
    {
      switch (c)
      {
        case 'c':
        if (*arg == '\0')
        {
          if (argc == 0) exit(1);
          cmdline = *argv++; argc--;
        }
        else cmdline = arg;
        break;

        case 'd':
        debugging = TRUE;
        continue;

        case 'e':
        exitonerror = TRUE;
        continue;

        case 'f':
        fast = TRUE;
        continue;

        case 'i':
        interactive = TRUE;
        continue;

        case 'n':
        parseonly = TRUE;
        continue;

        case 's':
        standard = TRUE;
        continue;

        case 't':
        singleline = TRUE;
        continue;

        case 'v':
        verbose = TRUE;
        continue;

        case 'x':
        echo = TRUE;
        continue;

#ifdef CDL
        case 'z':
        cdl = TRUE;
        continue;
#endif

        case 'V':
        set("verbose", makeargv(""));
        continue;

        case 'X':
        set("echo", makeargv(""));
        continue;

#ifdef CDL
        case 'Z':
        set("cdl", makeargv(""));
        continue;
#endif
      }
      break;
    }
  }
  if (argc == 0 OR cmdline OR interactive OR standard OR singleline)
  {
    filename = NULL;
    inputfile = stdin;
  }
  else
  {
    argc--;
    filename = *argv++;
    if ((inputfile = fopen(filename, "r")) == NULL)
    {
      syserr(filename);
      exit(1);
    }
    fcntl(fileno(inputfile), F_SETFD, FD_CLOEXEC);
  }
  if (argc > 0) set("argv", dupargv(argv));
  else set("argv", nullargv());
  set("autologout", nummakeargv(10));
#ifdef CDL
  unless (getenv("CDL") == NULL) set("cdl", makeargv(""));
#endif
#ifdef HELIOS
  set("console", envmakeargv("CONSOLE"));
#endif
  set("cwd", makeargv(getcwd(path, PATH_MAX)));
  set("home", envmakeargv("HOME"));
#ifdef HELIOS
  MachineName(path);
  set("machine", makeargv(path));
#endif
  set("path", envmakeargv("PATH"));
  set("prompt", makeargv(PROMPT));
  set("shell", makeargv(SHELL_CMD));
  set("status", nummakeargv(OK));
  set("term", envmakeargv("TERM"));
  set("user", envmakeargv("USER"));

  unless (interactive) interactive = isatty(fileno(inputfile));
  unless (parseonly) setmode(MODE_EXECUTE);
  unless (fast)
  {
    unsetmode(MODE_HISTORY);
    if(!source(homename(path, CSHRC_FILE)))
	ignore source(homename(path,CSHRC_FILE_V11));
    if (login) 
	if (!source(homename(path, LOGIN_FILE)))
		ignore source(homename(path, LOGIN_FILE_V11));
    if(!record(homename(path, HISTORY_FILE)))
    	ignore record(homename(path, HISTORY_FILE_V11));
    hash();
  }
  setmode(MODE_HISTORY);
  if (verbose) set("verbose", makeargv(""));
  if (echo) set("echo", makeargv(""));
#ifdef CDL
  if (cdl) set("cdl", makeargv(""));
#endif
  unless (cmdline == NULL)
  {
    int code;

    if ((code = catch()) == 0) code = runcmdline(cmdline);
    logout(code);
  }
}

void logout(code)
int code;
{
#ifdef DEBUGGING
  DEBUG("logout(%d)", code);
#endif
  unless (fast)
  {
    char path[PATH_MAX + 1];
    char *savehist;

    unless ((savehist = getvar("savehist")) == NULL)
    {
      int count;

      if ((count = atoi(savehist)) > 0)
      {
        FILE *file;
	file = fopen(homename(path, HISTORY_FILE), "w");
	if ( file == NULL )
          file = fopen(homename(path, HISTORY_FILE_V11), "w");
        unless (file == NULL)
        {
          fputsublist(file, &historylist, count, TRUE, TRUE, FALSE);
          fclose(file);
        }
      }
    }
    if (login)
      if (!source(homename(path, LOGOUT_FILE)))
	ignore source(homename(path, LOGOUT_FILE_V11));
  }
  freecmd(globcmd);
  freeargv(globargv);

  WalkList(&aliaslist, (WordFnPtr)freesubnode);
  WalkList(&historylist, (WordFnPtr)freesubnode);
  WalkList(&varlist, (WordFnPtr)freesubnode);
  WalkList(&dirlist, (WordFnPtr)freedirnode);
  if (login) WalkList(&joblist, (WordFnPtr)killjob);
  WalkList(&joblist, (WordFnPtr)freejob);
  freelinevector();
  unhash();
  systidy();
  exit(code);
}

char *homename(path, name)
char *path, *name;
{
  char *home;

  unless ((home = getvar("home")) == NULL) formfilename(path, home, name);
  else strcpy(path, name);
  return path;
}

BOOL source(name)
char *name;
{
  FILE *file;

#ifdef DEBUGGING
  DEBUG("source('%s')", name);
#endif
  if ((file = fopen(name, "r")) == NULL) return FALSE;
  newfile(file);
  while (docmdline())
	if(testbreak())
		{
		innewfile = FALSE;
		recover();
		}
  oldfile();
  return TRUE;
}

BOOL record(name)
char *name;
{
  char line[LINE_MAX + 1];
  FILE *file;

#ifdef DEBUGGING
  DEBUG("record(%s)",name);
#endif
  if ((file = fopen(name, "r")) == NULL) return FALSE;
  until (fgets(line, LINE_MAX, file) == NULL)
  /* ACE: buildargv can error on unmatched ' ! */
    addevent(buildargv(makeargv(line)));
  fclose(file);
  return TRUE;
}

BOOL getinterpreter(interp, name)
char *interp, *name;
{
  int fd, length, i;
  int index = 0;
  char *shell;

#ifdef DEBUGGING
  DEBUG("getinterpreter = %");
#endif
  if ((fd = open(name, O_RDONLY)) == -1) return FALSE;
  if ((length = read(fd, interp, LINE_MAX)) < 0) return FALSE;
  close(fd);
  for (i = 0; i < length; i++)
  {
    unless (isprint(interp[i]) OR isspace(interp[i])) return FALSE;
  }
  interp[length] = '\0';
  if (interp[0] == '#' AND interp[1] == '!')
  {
    i = 2;
    while (isspace(interp[i]) AND isprint(interp[i])) i++;
    until (isspace(interp[i]) OR interp[i] == '\0')
      interp[index++] = interp[i++];
  }
  if (index > 0)
  {
    interp[index] = '\0';
#ifdef DEBUGGING
    DEBUG ("%s", interp);
#endif
    return TRUE;
  }
  if ((shell = getvar("shell")) == NULL) shell = SHELL_CMD;
  strcpy(interp, shell);
#ifdef DEBUGGING
  DEBUG ("%s", interp);
#endif
  return TRUE;
}

void executecmd(name, argv)
char *name;
ARGV argv;
{
#ifdef DEBUGGING
  DEBUG("executecmd(%s %V)", name, argv);
#endif
  execvp(name, argv);                        /*JD:change to execvp fromexecv*/
#ifdef DEBUGGING
  DEBUG("execv failed, errno = %d", errno);
#endif
  if (errno == ENOEXEC)
  {
    char interp[PATH_MAX + 1];

    if (getinterpreter(interp, name))
    {
      char *newargv[100];
      int i;

      newargv[0] = interp;
      newargv[1] = name;
      for (i = 2; i < 100; i++)
      {
      	if ((newargv[i] = argv[i - 1]) == NULL) break;
      }
      newargv[i] = NULL;
      execvp(interp, newargv);
#ifdef DEBUGGING
      DEBUG("execvp failed, errno = %d", errno);
#endif
      syserr(interp);
      _exit(1);
    }
    errno = ENOEXEC;
  }
  unless (errno == ENOENT)
  {
    syserr(name);
    _exit(1);
  }
}

int waitforcmd(pid)
int pid;
{
  int wpid, status, code;

#ifdef DEBUGGING
  DEBUG("waitforcmd(%d)", pid);
#endif
  if (pid == -1)
	{
	if(testbreak())
	      recover();
	}
  waitwrpid = pid;
  until ((wpid = wait2(&status, WUNTRACED)) == pid OR (wpid == -1 && errno != EINTR)) 
    if( wpid != -1 ) notifyjob(wpid, status);
  unless (wpid == -1) notifyjob(pid, status);
  waitwrpid = 0;
  set("status", nummakeargv(code = highbyte(status)));
  if(testbreak())
	recover();
#ifdef HELIOS
  ctrlcbegin();
#endif
  return code;
}

int runcmdlist(cmd)
CMD *cmd;
{
  int code = 0;
  int pid;

 #ifdef DEBUGGING
 DEBUG("runcmdlist()");
#endif
  for (; cmd; cmd = cmd->next)
  {
    switch (cmd->op)
    {
      case T_SEMICOLON:
      code = waitforcmd(runpipeline(cmd->this));
      break;

      case T_AMPERSAND:
      if (isdelimitor(cmd->this->op)) pid = runlist(cmd->this, NULL, READ, WRITE);
      else pid = runpipeline(cmd->this);
      unless (pid == -1) newjob(cmd->this, pid);
      break;

      case T_AND:
      unless ((code = waitforcmd(runpipeline(cmd->this))) == 0) return code;
      break;

      case T_OR:
      if ((code = waitforcmd(runpipeline(cmd->this))) == 0) return code;
      break;

      default:
      return waitforcmd(runpipeline(cmd));
    }
  }
  return code;
}

int runpipeline(cmd)
CMD *cmd;
{
  int fd = READ;
  int fds[2];
  int pid = -1;

#ifdef DEBUGGING
  DEBUG("runpipeline()");
#endif
  for (; cmd; cmd = cmd->next)
  {
    switch (cmd->op)
    {
#ifdef CDL
      case T_PAR:
      case T_FARM:
      case T_SUBORDINATE:
      case T_REVPIPE:
#endif
      case T_PIPE:
#ifdef DEBUGGING
      DEBUG("PIPE");
#endif
#ifdef CDL
      if (usingcdl) return runtaskforce(cmd);
#endif
#ifdef HELIOS
      if (cmd->this->op == T_SIMPLE AND ((ARGV)cmd->this->this)[0] != NULL AND
          findbuiltin(((ARGV)cmd->this->this)[0]) != NULL)
      {
      	if (fifo(fds) == -1)
      	{
          unless (fd == READ) close(fd);
          syserr(NULL);
          recover();
        }
      }
      else
#endif
      if (pipe(fds) == -1)
      {
        unless (fd == READ) close(fd);
        syserr(NULL);
        recover();
      }
      fcntl(fds[READ], F_SETFD, FD_CLOEXEC);
      ignore runcmd(cmd->this, fd, fds[WRITE]);
      close(fds[WRITE]);
      unless (fd == READ) close(fd);
      fd = fds[READ];
#ifdef DEBUGGING
      DEBUG("talk to cmd on %d", fd);
#endif
      break;

      default:
      pid = runcmd(cmd, fd, WRITE);
      unless (fd == READ) close(fd);
      return pid;
    }
  }
  return pid;
}

int runcmd(cmd, ifd, ofd)
CMD *cmd;
int ifd, ofd;
{
#ifdef DEBUGGING
  DEBUG("runcmd()");
#endif
  if (cmd->op == T_LIST) return runlist(cmd->this, cmd->ioinfo, ifd, ofd);
#ifdef CDL
  if (usingcdl AND cmd->next != NULL) return runtaskforce(cmd);
#endif
  return runsimplecmd(dupargv((ARGV)cmd->this), cmd->ioinfo, ifd, ofd);
}

int runlist(cmd, ioinfo, ifd, ofd)
CMD *cmd;
IOINFO *ioinfo;
int ifd, ofd;
{
  int pid;

#ifdef DEBUGGING
  DEBUG("runlist()");
#endif
#ifdef UNIX
  if ((pid = fork()) == 0)
  {
    unless (redirect(ioinfo, ifd, ofd)) _exit(1);
    shellpid = getpid(); /* ACE: Is this necessary ? */
    _exit(runcmdlist(cmd));
  }
#else
  if ((pid = vfork()) == 0)
  {
    char buffer[WORD_MAX + 1];

    unless (redirect(ioinfo, ifd, ofd)) _exit(1);
    buffer[0] = '\0';
    sputcmd(buffer, cmd);
    execl(SHELL_CMD, "shell", "-fc", buffer, NULL);
    syserr(NULL);
    _exit(1);
  }
#endif
  if (pid == -1)
  {
    syserr(NULL);
    recover();
  }
  return pid;
}

void savefds(int *fds)
{
  int i;

  for (i = 0; i < 3; i++) fds[i] = dup(i);
  if(!fdssaved)
	for(i = 0 ; i < 3 ; i++)
		sfds[i] = fds[i];
  fdssaved++;
}

void restorefds(int *fds)
{
  int i;

  for (i = 0; i < 3; i++)
  {
    close(i);
    dup(fds[i]);
    close(fds[i]);
  }
  fdssaved--;
}

int runbuiltin(func, argv, ioinfo, ifd, ofd)
int (*func)();
ARGV argv;
IOINFO *ioinfo;
int ifd, ofd;
{
  int code, pid;
  int fds[3];

  if (needsfullsubs(func)) argv = fullsub(argv);
  else argv = smallsub(argv);
  savefds(fds);
  unless (redirect(ioinfo, ifd, ofd))
  {
    restorefds(fds);
    freeargv(argv);
    recover();
  }
  if (findvar("echo")) fputargv(stderr, argv, TRUE);
  code = (*func)(lenargv(argv), argv);
  freeargv(argv);     /* are these freed if (*func() longjmps ?? */
  restorefds(fds);
  if ((pid = vfork()) == 0) _exit(code);
  if (pid == -1)
  {
    syserr(NULL);
    recover();
  }
  return pid;
}

int runsimplecmd(argv, ioinfo, ifd, ofd)
ARGV argv;
IOINFO *ioinfo;
int ifd, ofd;
{
  BUILTIN *builtin;
  int pid = -1;

/* move 'name' declaration to here from inner 'until' loop */
/* to resolve memory leakage problem B433                  */
/* MJT 08/10/90                                            */

  char name[PATH_MAX + 1];

  
#ifdef DEBUGGING
  DEBUG("runsimplecmd(%V)",argv);
#endif
  if (argv[0] == NULL)
  {
    freeargv(argv);
    return -1;
  }
  if(testbreak())
	recover();
  unless ((builtin = findbuiltin(argv[0])) == NULL)
    return runbuiltin(builtin->func, argv, ioinfo, ifd, ofd);
  argv = fullsub(argv);
  if(lenargv(argv) + lenargv(environ) > MAX_ARGV)
	{	
	fprintf(stderr, "Arg list too long\n");
	fflush(stderr);
	freeargv(argv);
	return pid;
	}
  if ((pid = vfork()) == 0)
  {
    unless (redirect(ioinfo, ifd, ofd)) _exit(1);
    if (findvar("echo")) fputargv(stderr, argv, TRUE);
    if (isabspath(argv[0]))
    {
#ifdef HELIOS
      if (lookforcmd(".", argv[0]))
#endif
      executecmd(argv[0], argv);
    }
    else
    {
      ARGV pathargv;
      char *path;

      unless ((pathargv = findvar("path")) == NULL)
      {
        until ((path = *pathargv++) == NULL)
        {
          if (lookforcmd(path, argv[0]))
          {
            formfilename(name, path, argv[0]);
            executecmd(name, argv);
          }
        }
      }
    }
    error(ERR_NOTFOUND, argv[0]);
    _exit(1);
  }
  freeargv(argv);
  if (pid == -1)
  {
    syserr(NULL);
    recover();
  }
  return pid;
}

BOOL redirect(ioinfo, ifd, ofd)
IOINFO *ioinfo;
int ifd, ofd;
{
  OPENINFO *inputinfo = (ioinfo == NULL) ? NULL : ioinfo->input;
  OPENINFO *outputinfo = (ioinfo == NULL) ? NULL : ioinfo->output;
  OPENINFO *diaginfo = (ioinfo == NULL) ? NULL : ioinfo->diag;
  char *name;

#ifdef DEBUGGING
  DEBUG("redirect(%d,%d)", ifd, ofd);
#endif
  unless (ifd == READ)
  {
    unless (inputinfo == NULL)
    {
      error(ERR_INPUT, NULL);
      return FALSE;
    }
    close(READ);
    dup(ifd);
    close(ifd);
  }
  unless (ofd == WRITE)
  {
    unless (outputinfo == NULL)
    {
      error(ERR_OUTPUT, NULL);
      return FALSE;
    }
    close(WRITE);
    dup(ofd);
    close(ofd);
  }
  if (diaginfo != NULL AND outputinfo != NULL AND outputinfo->flags & FLAG_STDERR)
  {
    error(ERR_DIAGNOSTIC, NULL);
    return FALSE;
  }
  unless (diaginfo == NULL)
  {
    int flags = O_WRONLY | O_CREAT;
    ARGV argv = fullsub(makeargv(diaginfo->name));

    freememory((int *)diaginfo->name);
    diaginfo->name = name = strdup(argv[0]);
    freeargv(argv);
    if (diaginfo->op == T_APPENDDIAG) flags |= O_APPEND;
    else flags |= O_TRUNC;
    if (findvar("noclobber") AND (diaginfo->flags & FLAG_CLOBBER) == 0)
      flags |= O_EXCL;
    close(DIAGNOSTIC);
    if (open(name, flags, 0666) == -1)
    {
      syserr(name);
      return FALSE;
    }
  }
  unless (outputinfo == NULL)
  {
    int flags = O_WRONLY | O_CREAT;
    ARGV argv = fullsub(makeargv(outputinfo->name));

    freememory((int *)outputinfo->name);
    outputinfo->name = name = strdup(argv[0]);
    freeargv(argv);
    if (outputinfo->op == T_APPEND) flags |= O_APPEND;
    else flags |= O_TRUNC;
    if (findvar("noclobber") AND (outputinfo->flags & FLAG_CLOBBER) == 0)
      flags |= O_EXCL;
    close(WRITE);
    if (open(name, flags, 0666) == -1)
    {
      syserr(name);
      return FALSE;
    }
    if (outputinfo->flags & FLAG_STDERR)
    {
      close(DIAGNOSTIC);
      dup(WRITE);
    }
  }
  unless (inputinfo == NULL)
  {
    if (inputinfo->op == T_READ)
    {
      ARGV argv = fullsub(makeargv(inputinfo->name));

      freememory((int *)inputinfo->name);
      inputinfo->name = name = strdup(argv[0]);
      freeargv(argv);
      close(READ);
      if (open(name, O_RDONLY, 0) == -1)
      {
      	syserr(name);
      	return FALSE;
      }
    }
    else
    {
      FILE *file;
      char *terminator = inputinfo->name;
      char line[LINE_MAX + 1];
      int length = strlen(terminator);

      if ((file = fopen(TEMP_FILE, "w")) == NULL)
      {
      	syserr(TEMP_FILE);
      	return FALSE;
      }
      forever
      {
        unless (getline(line, TRUE))
        {
          error(ERR_TERMINATOR, terminator);
          fclose(file);
          return FALSE;
        }
        if (strnequ(terminator, line, length) AND line[length] == '\n') break;
        fputs(line, file);
      } 
      fclose(file);
      close(READ);
      if (open(TEMP_FILE, O_RDONLY, 0) == -1)
      {
      	syserr(TEMP_FILE);
      	return FALSE;
      }
    }
  }
  return TRUE;
}

#ifdef TEST_FDS
#undef open
#undef close
#undef dup
#undef pipe

int myopen(char *name, int mode, int pmode)
{
  int fd = open(name, mode, pmode);

  IOdebug("open('%s') -> %d", name, fd);
  return fd;
}

int myclose(int fd)
{
  int err = close(fd);

  IOdebug("close(%d) -> %d", fd, err);
  return err;
}

int mydup(int fd)
{
  int newfd = dup(fd);

  IOdebug("dup(%d) -> %d", fd, newfd);
  return newfd;
}

int mypipe(int fd[2])
{
  int err = pipe(fd);

  IOdebug("pipe() -> %d (%d, %d)", err, fd[0], fd[1]);
  return err;
}
#endif

@


1.8
log
@more changes to fix CTRL-C and error recovery longjmp bugs
@
text
@a57 2
  if (testbreak())	/* CFL let scripts be aborted	*/
	recover();
d346 1
a346 1
	if(breakflag)
d348 2
a349 2
		breakflag = FALSE;
		break;
a465 1
	raw();
a474 1
  raw();
d716 2
a717 1
  cooked();
@


1.7
log
@changes to try and fix CTRL-C processing
@
text
@a122 6
  unless (catch() == 0)
  {
    setmode(MODE_HISTORY);
    setmode(MODE_EXECUTE);
    return;
  }
a245 3
#ifdef OLDCODE
  set("shell", envmakeargv("SHELL")); /* Not convinced about this */
#else
a246 1
#endif
a275 7
#if 0 /* This seems to cause two ^C reports */
    if (testbreak())
    {
      ignore signal(SIGINT, SIG_DFL);
      sighandler(SIGINT);
    }
#endif
a277 4
#if 0
   /* Could ensure quick response on heavily loaded systems with this fn */
   SetPriority(ServerPri);
#endif
a323 12
#ifdef OLDCODE
  unless (totalmemory == 0) putmem();
#endif
#if 0 /* BLV - 1.2 changes */
  if (login)
  {
    Object *sm;

    if ((sm = Locate(NULL, "/sm")) == NULL) quit(code);
    Close(sm);
  }
#endif
d469 2
a470 3
  	if(testbreak())
		recover();
	return OK;
a497 1
    if (testbreak()) recover();
d642 1
a642 2
void savefds(fds)
int fds[3];
d647 4
d653 1
a653 2
void restorefds(fds)
int fds[3];
d663 1
d672 1
a673 1
  int code, pid;
d686 1
a686 1
  freeargv(argv);
@


1.6
log
@modified to cope with new posix library signal handling
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /usr/perihelion/Helios/cmds/shell/RCS/shell.c,v 1.3 90/10/09 10:52:23 martyn Exp $";
d27 1
a27 1
  #ifdef DEBUGGING
d58 2
a59 1
  if (interactive) ignore testbreak();	/* CFL let scripts be aborted	*/
d380 6
a385 1
  while (docmdline());
d499 7
a505 1
  if (pid == -1) return OK;
d510 5
a517 2
  waitwrpid = 0;
  set("status", nummakeargv(code = highbyte(status)));
d752 1
@


1.5
log
@fixes in runsimplecmd to abort command if arglist is too long
@
text
@d285 1
d291 1
d495 2
a496 2
  until ((wpid = wait2(&status, WUNTRACED)) == pid OR wpid == -1)
    notifyjob(wpid, status);
@


1.4
log
@added code for maximum no of command args
@
text
@d738 1
a738 1
  if(lenargv(argv) > MAX_ARGV)
@


1.3
log
@Fixed memory leakage problem MJT 09/10/90
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /usr/perihelion/Helios/cmds/shell/RCS/shell.c,v 1.2 90/09/25 12:47:52 paul Exp Locker: martyn $";
d718 1
a718 1
  int pid;
d738 7
@


1.2
log
@arm changes
@
text
@d15 1
a15 1
static char *rcsid = "$Header: /usr/perihelion/Helios/cmds/shell/RCS/shell.c,v 1.1 90/08/23 16:06:31 james Exp $";
d719 7
a757 2
          char name[PATH_MAX + 1];

@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
static char *rcsid = "$Header$";
d18 1
a18 2
/*
#ifdef HELIOS
d21 2
a22 1
*/
d292 3
a294 3
#ifdef 0
#ifdef HELIOS
   SetPriority(StandardPri); /* ensure quick response on heavily loaded sys */
a295 1
#endif
d345 1
a345 1
#ifdef HELIOS
@
