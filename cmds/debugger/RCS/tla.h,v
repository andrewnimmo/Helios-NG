head	1.11;
access;
symbols
	Helios_1_3_1:1.11
	Helios_C40_1_3_Official_Release:1.10
	Alenia_release:1.5
	Helios13_beta:1.3
	Helios1_2_2:1.3
	Helios1_2_2Beta:1.2;
locks; strict;
comment	@ * @;


1.11
date	93.07.06.14.09.34;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	93.04.26.13.28.45;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	93.03.19.16.51.37;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	93.03.17.17.41.54;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	93.03.11.16.43.05;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	93.03.10.16.16.04;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	92.11.04.14.53.45;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	92.10.27.13.48.29;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	91.10.01.13.41.27;	author craig;	state Exp;
branches;
next	1.2;

1.2
date	91.08.19.10.13.07;	author craig;	state Exp;
branches;
next	1.1;

1.1
date	91.08.19.09.44.04;	author craig;	state Exp;
branches;
next	;


desc
@concatenation of previous (V1.1) header files.
@


1.11
log
@fixed to compile with new compiler
@
text
@/**
*
* Title:  Helios Debugger Header File
*
* Author: Andy England (original header files)
* Date:   March 1989
*
* Author: Carsten Rietbrock (integration of header files)
* Date:   Dezember 1990
*
* -- crf : August 1991 - some modifications
*
* Author: Nick Clifton (ported to C40)
* Date:   October 1992
*
*         (c) Copyright 1988 - 1993, Perihelion Software Ltd.
*
*         All Rights Reserved.
*
* included headers: debug.h module.h monitor.h display.h key.h line.h
*		    source.h thread.h interp.h system.h table.h symbol.h
*		    expr.h eval.h cmd.h util.h info.h
*
* $Header: /hsrc/cmds/debugger/RCS/tla.h,v 1.10 1993/04/26 13:28:45 nickc Exp nickc $
*
**/

#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>
#include <signal.h>
#include <posix.h>
#include <helios.h>
#include <syslib.h>
#include <codes.h>

#include <errno.h> /* -- crf : 16/07/91 - Bug 706 */

#include <gsp.h>
#include <ioevents.h>
#include <attrib.h>
#include <fcntl.h>
#include <fault.h>
#include <stdlib.h>
#include <module.h>
#include <servlib.h>
#include <task.h>
#ifdef OLDCODE
#include <stdlib.h>
#endif
#include <string.h>
#include <nonansi.h>
#include <queue.h>
#include <setjmp.h>
#include <stddef.h>
#include "./lib/dmsg.h"
#undef print
#undef STRING


/*debug.h************************************************/


typedef long 			LONG;
typedef unsigned long		ULONG;
typedef int			BOOL;
typedef Node			NODE;
typedef List			LIST;

#define AND			&&
#define OR			||

#define strequ(  s, t )		(strcmp(  s, t )    == 0)
#define strnequ( s, t, n )	(strncmp( s, t, n ) == 0)
#define NEW( t )		(t *)newmem( sizeof (t) )

#define PathMax			512

typedef enum
  {
    Default, Ascii, Binary, Decimal, Error, Float, Hexadecimal, Octal, Unsigned, STring /* String is already defined */
  }
FORMAT;

typedef struct
  {
    struct module *	module;
    int			line;
  }
LOCATION;

#define HASH_MAX 	211  /* CR: guess this def is better here */

typedef struct chain
  {
    struct link *	head;
  }
CHAIN;

typedef struct link
  {
    struct link *	next;
  }
LINK;

typedef struct symbol
  {
    LINK 		link;
    CHAIN		entrylist;
    char		name[ 1 ];
  }
SYMBOL;

typedef CHAIN 		TABLE[ HASH_MAX ]; /* CR: was in table.h */

typedef struct debug
  {
    char 		name[ 256 ];
    LIST		modulelist;
    LIST		breakpointlist;
    LIST		watchlist;
    LIST		watchpointlist;
    LIST		threadlist;
    Port		port;
    Port		reply;
    struct thread *	thread;
    struct display *	display;
    struct interp *	interp;
    Environ		env;
    struct line *	line;
    struct eval *	eval;
    struct chain *	table; 		/* CR: was 'struct table' but there is no struct table */
    int			ifwatchpoint;	/* CR: im sorry for this doggy solution of the varwindow */
    void *		tempwatchpoint;	/*   refreshing problem */
  }
DEBUG;

PUBLIC void *		newmem(		int );
PUBLIC void		freemem(	void * );
PUBLIC void		putmem(		void );

PUBLIC void		initdebug(	int, char *[] );
PUBLIC void		debugf(		char *, ... );
PUBLIC DEBUG *		newdebug(	char * );
PUBLIC void		startdebug(	DEBUG *, Port, Port );
PUBLIC void		remdebug(	DEBUG * );

#ifdef V1_1
#define _MYSYS_OPEN	64

extern Semaphore	loadlock;
extern FILE		my_iob[ _MYSYS_OPEN ];
#endif


/*module.h*******************************************/


typedef struct module
  {
    NODE 		node;
    char *		name;
    int			modnum;
    DEBUG *		debug;
    struct source *	source;
    struct block *	outerblock;
  }
MODULE;

PUBLIC BOOL 		addmodule(	DEBUG *, char * name, int modnum );
PUBLIC void		remmodule(	MODULE * );
PUBLIC MODULE *		getmodule(	DEBUG *, int modnum );
PUBLIC MODULE *		findmodule(	DEBUG *, char * name );
PUBLIC struct source *	getsource(	MODULE * );


/*monitor.h***************************************************/


typedef struct breakpoint
  {
    NODE 		node;
    LOCATION		loc;
    int			count;
    char *		docmd;
  }
BREAKPOINT;

#ifdef OLDCODE
typedef struct watch
  {
    NODE 		node;
    union expr *	expr;
  }
WATCH;

typedef struct watchpoint
  {
    NODE 		node;
    union expr *	expr;
    LIST		watchelementlist;
    BOOL		recalc;
  }
WATCHPOINT;

typedef struct watchelement
  {
    NODE 		node;
    void *		addr;
    int			size;
  }
WATCHELEMENT;

#else /* not OLDCODE */

typedef enum
{
  C_Auto, C_Common, C_Display, C_Enum, C_Extern, C_Member, C_Param, C_Register,
  C_Static, C_Tag, C_Typedef
} CLASS;

typedef struct block *	blockptr;
typedef struct thread *	threadptr;
typedef struct eval *	evalptr;

typedef struct watchpoint
  {
    NODE 		node;
    char *		expr;
    void *		addr;
    int			size;
    char *		docmd;
    FORMAT		format;
    BOOL		silent;
    int			scope; 		/* CR: I need this to indicate the level of def */
    blockptr		block;		/* CR: Saved context for evaluation */
    threadptr		thread;		/* CR: Saved thread for evaluation */
    evalptr		eval;

/*
-- crf : 14/08/91 - related to Bug 708
-- The creation of watch windows must take into account the number of elements
-- in a watchpointed structure. 
*/
    int 		num_elements;

    /* XXX - NC - 26/4/93 - we need to save the class of variable neing watched */
    
    CLASS		Class;
  }
WATCHPOINT;

#endif /* not OLDCODE */


typedef struct
  {
    void *		addr;
    int			size;
  }
MEM_LOCATION;

PUBLIC void 		stopped(	 DEBUG *, int, int, int );
PUBLIC void		traced(		 DEBUG *, int, int, int );
PUBLIC void		entered(	 DEBUG *, int, int, int );
PUBLIC void		returned(	 DEBUG *, int, int, int );
PUBLIC void		endthread(	 DEBUG *, int );
PUBLIC void		addbreakpoint(	 DEBUG *, LOCATION, int, char * );
PUBLIC void		rembreakpoint(	 DEBUG *, LOCATION );
PUBLIC void		freebreakpoint(	 BREAKPOINT * );
PUBLIC BREAKPOINT *	findbreakpoint(	 DEBUG *, LOCATION );
PUBLIC void		listbreakpoints( DEBUG * );
PUBLIC void		remwatchpoint(	 DEBUG *, WATCHPOINT * );
PUBLIC void		freewatchpoint(	 WATCHPOINT * );
PUBLIC void		listwatchpoints( DEBUG * );


/* display.h *******************************************************/


#define DisplayBorder	6

typedef struct
  {
    int row;
    int col;
    int size;
  }
CURSOR;

typedef struct window
  {
    NODE 		node;
    struct display *	display;
    int			pos;
    int			size;
    LOCATION		loc;
    LOCATION		progloc;
    CURSOR		cur;
    FILE *		traceout;
  }
WINDOW;

typedef struct display
  {
    DEBUG *		 debug;
    FILE *		 filein;
    FILE *		 fileout;
    LIST		 windowlist;
    WINDOW *		 topwin;
    Semaphore		 lock;
    int			 height;
    int			 width;
    int			 row;
    int			 col;
    int			 varsize;

    /*
     * -- crf : 14/08/91 - related to Bug 708
     * -- Keep track of last line of watch window
     */
    int 		 varline;

    struct watchpoint ** varvec;
    Port		 breakport;
    BOOL		 breakflag;
    BOOL		 stop_display;
  }
DISPLAY;

PUBLIC DISPLAY *	dopen(		DEBUG *, char *, char * );
PUBLIC BOOL		testbreak(	DISPLAY * );
PUBLIC void		dclose(		DISPLAY * );
PUBLIC void		drefresh(	DISPLAY * );
PUBLIC void		dcursor(	DISPLAY *, int, int );
PUBLIC void		dstart(		DISPLAY * );
PUBLIC void		dend(		DISPLAY *, BOOL );
PUBLIC void		dclear(		DISPLAY * );
PUBLIC void		dinverse(	DISPLAY * );
PUBLIC void		dnormal(	DISPLAY * );
PUBLIC void		deol(		DISPLAY * );
PUBLIC void		dlock(		DISPLAY * );
PUBLIC void		dunlock(	DISPLAY * );
PUBLIC void		dprintf(	DISPLAY *, char *, ... );
PUBLIC void		xdputc(		DISPLAY *, int );
PUBLIC void		dputc(		DISPLAY *, int );
PUBLIC int		dgetc(		DISPLAY * );
PUBLIC void		raw(		DISPLAY * );
PUBLIC void		cooked(		DISPLAY * );

#ifdef OLDCODE
PUBLIC void 		vgrow(		DISPLAY * );
PUBLIC void		vshrink(	DISPLAY * );
#else
/* -- crf : 24/07/91 - Bug 708 */
PUBLIC void		vgrow( 		DISPLAY *, int );
PUBLIC void		vshrink(	DISPLAY *, int );
#endif

PUBLIC void 		vinsert(	DISPLAY *, struct watchpoint * );
PUBLIC void		vdelete(	DISPLAY *, int );
PUBLIC void		vupdate(	DISPLAY *, struct watchpoint * );
PUBLIC WINDOW *		wopen(		DISPLAY * );
PUBLIC void		wclose(		WINDOW * );
PUBLIC void		wclear(		WINDOW * );
PUBLIC void		wselect(	WINDOW * );
PUBLIC void		wgrow(		WINDOW * );
PUBLIC void		wshrink(	WINDOW * );
PUBLIC void		lowlight(	WINDOW * );
PUBLIC void		wgoto(		WINDOW *, LOCATION );
PUBLIC void		view(		WINDOW *, LOCATION );
PUBLIC void		scrollup(	WINDOW *, int );
PUBLIC void		scrolldown(	WINDOW *, int );
PUBLIC void		pageup(		WINDOW * );
PUBLIC void		pagedown(	WINDOW * );
PUBLIC void		pagefirst(	WINDOW * );
PUBLIC void		pagelast(	WINDOW * );
PUBLIC void		cursorup(	WINDOW * );
PUBLIC void		cursordown(	WINDOW * );
PUBLIC void		cursorleft(	WINDOW * );
PUBLIC void		cursorright(	WINDOW * );
PUBLIC void		cursorgrow(	WINDOW * );
PUBLIC void		cursorshrink(	WINDOW * );
PUBLIC char *		getcurtext(	WINDOW *, char * );

/*key.h******************************************/


#define MAX_KEY 	255

typedef char *		KEYMAP[ MAX_KEY + 1 ];

PUBLIC void		initkeymap(	KEYMAP );
PUBLIC void		freekeymap(	KEYMAP );
PUBLIC void		addkey(		KEYMAP, int, char * );
PUBLIC void		remkey(		KEYMAP, int );
PUBLIC char *		getkey(		KEYMAP, int );
PUBLIC void		listkeys(	KEYMAP, struct display * );

/*line.h*********************************************/


#define Shift		0xdf
#define VControl	0x9f
#define CtrlD		0x04
#define Bell		0x07
#define Backspace	0x08
#define Tab		0x09
#define Return		0x0d
#define Escape		0x1b
#define Space		0x20
#define VDelete		0x7f
#define FunctionKeys	0x80
#define PageKeys	0xc0
#define Undo		(PageKeys + 1)
#define End		(PageKeys + 2)
#define PageUp		(PageKeys + 3)
#define PageDown	(PageKeys + 4)
#define UpArrow		0xd0
#define DownArrow	0xd1
#define LeftArrow	0xd2
#define RightArrow	0xd3
#ifdef NO_LONGER_WORKS
#define ShiftUpArrow	0xd4
#define ShiftDownArrow	0xd5
#define ShiftLeftArrow	0xd6
#define ShiftRightArrow	0xd7
#endif
#define Help		0xd8
#define Home		0xd9
#define VInsert		0xda

#define CSI		0x9b

#define LineMax		255
#define SaveMax		20
#define prevslot( s )	if (--(s) < 0) (s) = SaveMax - 1
#define nextslot( s )	if (++(s) == SaveMax) (s) = 0

#define iscst( c )	((c) >= 0x20 AND (c) <= 0x7f)

typedef struct line
  {
    int 		index;
    int			length;
    BOOL		update;
    struct display *	display;
    char		buffer[ LineMax + 1 ];
    char		savebuffer[ LineMax + 1 ];
    int			firstslot;
    int			lastslot;
    int			currentslot;
    char *		vec[ SaveMax ];
    KEYMAP		keymap;
  }
LINE;

PUBLIC LINE *		newline(	struct display * );
PUBLIC void		remline(	LINE * );
PUBLIC char *		getinput(	LINE *, char *, char * );
PUBLIC char *		getline(	LINE * );
PUBLIC int		dgetkey(	DISPLAY * display );


/*source.h************************************/


#define MAX_LINEVEC 	100

typedef struct source
  {
    NODE 		node;
    char *		name;
    char **		linevec;
    int			lastline;
    int			usage;
  }
SOURCE;

PUBLIC void 		initsource(	void );
PUBLIC SOURCE *		loadsource(	DEBUG *, char * );
PUBLIC void		unloadsource(	SOURCE * );
PUBLIC SOURCE *		findsource(	char * );
PUBLIC void		list(		struct display *, SOURCE *, int, int );
PUBLIC int		search(		SOURCE *, char *, int, BOOL, BOOL );
PUBLIC char *		getword(	char *, SOURCE *, int, int, int );
PUBLIC char *		gettext(	char *, SOURCE *, int, int, int );


/*thread.h***********************************************/


typedef struct thread
  {
    NODE 		node;
    int			id;
    LOCATION		loc;
    struct block *	block;
    struct entry *	function;
    struct window *	window;
    Semaphore		sync;
  }
THREAD;

PUBLIC THREAD *		newthread(	DEBUG *, int );
PUBLIC void		remthread(	THREAD * );
PUBLIC THREAD *		findthread(	DEBUG *, int );
PUBLIC void		nextthread(	DEBUG * );
PUBLIC void		prevthread(	DEBUG * );
PUBLIC void		resume(		THREAD * );


/*interp.h****************************************************/


#define EOL      	'\0'
#define StackMax	1024

typedef struct interp
  {
    LIST 		aliaslist;
    LIST		definelist;
    int			charindex;
    char		charstack[ StackMax ];
    jmp_buf		home;
    DEBUG *		debug;
    Semaphore		lock;
  }
INTERP;

typedef struct
  {
    NODE 		node;
    char *		name;
    char *		text;
  }
MACRO;

PUBLIC INTERP *		newinterp(		DEBUG * );
PUBLIC void		reminterp(		INTERP * );
PUBLIC void		lockinterp(		INTERP * );
PUBLIC void		unlockinterp(		INTERP * );
PUBLIC void		alias(			INTERP *, char *, char * );
PUBLIC void		define(			INTERP *, char *, char * );
PUBLIC char *		getalias(		INTERP *, char * );
PUBLIC char *		getdefine(		INTERP *, char * );
PUBLIC void		unalias(		INTERP *, char * );
PUBLIC void		undefine(		INTERP *, char * );
PUBLIC void		listaliases(		INTERP *, DISPLAY * );
PUBLIC void		listdefines(		INTERP *, DISPLAY * );
PUBLIC void		pushchar(		INTERP *, char );
PUBLIC void		pushword(		INTERP *, char * );
PUBLIC void		pushcmd(		INTERP *, char * );
PUBLIC int		popchar(		INTERP * );
PUBLIC char *		popword(		INTERP *, char *, uword );


/*system.h**************************************************/

#define DebugTimeout OneSec

PUBLIC void receiver(	      DEBUG *);
PUBLIC void syscall(	      DEBUG *, void *, int, void *, int, void *);
PUBLIC void sysfree(	      DEBUG *, int);
PUBLIC void sysfreeall(	      DEBUG *);
PUBLIC void sysgo(	      DEBUG *, int);
PUBLIC void sysgoall(	      DEBUG *);
PUBLIC void sysgoto(	      DEBUG *, int, int, int);
PUBLIC void sysgotoall(	      DEBUG *, int, int);
PUBLIC void sysgotoframe(     DEBUG *, int, int);
PUBLIC void sysgotoframeall(  DEBUG *, int);
PUBLIC void syskill(	      DEBUG *, int);
PUBLIC void syskillall(	      DEBUG *);
PUBLIC void sysprofile(	      DEBUG *, int, int, int, int);
PUBLIC void sysstep(	      DEBUG *, int);
PUBLIC void sysstepall(	      DEBUG *);
PUBLIC void sysstop(	      DEBUG *, int);
PUBLIC void sysstopall(	      DEBUG *);
PUBLIC void systrace(	      DEBUG *, int, int, int, int);
PUBLIC void systraceall(      DEBUG *);
PUBLIC void sysaddbreak(      DEBUG *, int, int, int);
PUBLIC void sysrembreak(      DEBUG *, int, int);
PUBLIC void peekmem(	      DEBUG *, void *, void *, int);
PUBLIC void peekdata(	      DEBUG *, void *, int, int, int);
PUBLIC void peekstack(	      DEBUG *, void *, int, int, int, int);
PUBLIC void pokemem(	      DEBUG *, void *, void *, int);
PUBLIC void *locatedata(      DEBUG *, int, int);
PUBLIC void *locatestack(     DEBUG *, int, int, int);
#ifdef __C40
PUBLIC void *locateframe(     DEBUG *, int, int, int);
PUBLIC void *locateregister(  DEBUG *, int, int, int);
#endif
PUBLIC void sysaddwatch(      DEBUG *, void *, int);
PUBLIC void sysremwatch(      DEBUG *, void *, int);
PUBLIC int syswhere(	      DEBUG *, int, int, LOCATION *);
PUBLIC void systimeout(	      DEBUG *, int);
PUBLIC void systimeoutall(    DEBUG *);

PUBLIC UBYTE peekbyte(	      DEBUG *, void *);
PUBLIC USHORT peekshort(      DEBUG *, void *);
PUBLIC UWORD peekword(	      DEBUG *, void *);


/*table.h***********************************************/


PUBLIC void initchain(CHAIN *);
PUBLIC void addlink(CHAIN *, LINK *);
PUBLIC void addtail(CHAIN *, LINK *);
PUBLIC void walkchain(CHAIN *, void (*)(), long);
PUBLIC LINK *searchchain(CHAIN *, int (*)(), long);
PUBLIC void inittable(TABLE );
PUBLIC SYMBOL *addsymbol(TABLE, char *);
PUBLIC SYMBOL *findsymbol(TABLE, char *);
PUBLIC void walktable(TABLE , void (*)(), long);
PUBLIC SYMBOL *searchtable(TABLE, int (*)(), long);


/*symbol.h**********************************************/


#define NAME_MAX 256

#define GetTypeEntry(t) ((ENTRY *)((word *)(t) - 2))

typedef USHORT LINENO;

typedef enum
{
  TI_Array, TI_Enum, TI_Float, TI_Function, TI_Integral, TI_Pointer, TI_ReUse,
  TI_Struct, TI_Ace, TI_Tag, TI_Typedef
} TYPEID;

typedef struct block
  {
    LINK 		link;
    struct block *	parent;
    CHAIN		blocklist;
    struct entry *	entry;
    struct module *	module;
    int			lines;
    LINENO *		linevec;
  }
BLOCK;

typedef union type *typeptr;

typedef struct reuse
  {
    TYPEID 	id;
    typeptr	type;
  }
REUSE;

typedef struct typename
  {
    TYPEID 	id;
    typeptr	type;
  }
TYPENAME;

typedef struct pointer
  {
    TYPEID 	id;
    typeptr	host;
  }
POINTER;

typedef struct array
  {
    TYPEID 	id;
    typeptr	host;
    int		size;
    int		first;
  }
ARRAY;

typedef struct structure
  {
    TYPEID 		id;
    struct entry *	tag;
    CHAIN		memberlist;
  }
STRUCTURE;

typedef struct function
  {
    TYPEID 	id;
    typeptr	host;
    CHAIN	paramlist;
  }
FUNCTION;

typedef struct enumeration
  {
    TYPEID 	id;
    CHAIN	constlist;
  }
ENUMERATION;

typedef struct basetype
  {
    TYPEID 	id;
    short	size;
    short	issigned;
  }
BASETYPE;

typedef union type
  {
    struct
      {
	TYPEID 	id;
	typeptr host;
      }
    generic;

    REUSE 	reuse;
    TYPENAME	typename;
    POINTER	pointer;
    ARRAY	array;
    STRUCTURE	structure;
    FUNCTION	function;
    ENUMERATION enumeration;
    BASETYPE	basetype;
  }
TYPE;

typedef struct 
  {
    LINK 	link;
    char *	name;
    CLASS	Class;
    TYPE *	type;
    BLOCK *	block;  /*** war als ifdef OLDCODE ***/
  }
TYPEDEF;

typedef struct
  {
    LINK 	link;
    char *	name;
    CLASS	Class;
    TYPE *	type;
    int		offset;
  }
MEMBER;

typedef struct
  {
    LINK 	link;
    char *	name;
    CLASS	Class;
    TYPE *	type;
    int		offset;
  }
ENUMCONST;

typedef struct
  {
    LINK 	link;
    char *	name;
    CLASS	Class;
    TYPE *	type;
    int		offset;
  }
PARAM;

typedef struct
  {
    LINK 	link;
    char *	name;
    CLASS	Class;
    TYPE *	type;
    int		offset;
    BLOCK *	block;
  }
LOCAL;

typedef struct entry
  {
    LINK 	link;
    char *	name;
    CLASS	Class;
    TYPE *	type;
    int		offset;
    BLOCK *	block;
  }
ENTRY;

PUBLIC void	add_params( 		TABLE, BLOCK *, TYPE * );
PUBLIC ENTRY *	declarevar(		TABLE, BLOCK *, char *, CLASS, TYPE *, int);
PUBLIC ENTRY *	declarelocal(		TABLE, BLOCK *, char *, TYPE *, int);
PUBLIC ENTRY *	declaretype(		TABLE, BLOCK *, char *, TYPE *);
PUBLIC ENTRY *	declaretag(		TABLE, BLOCK *, char *, TYPE *);
PUBLIC ENTRY *	declareparam(		TABLE, TYPE  *, char *, TYPE *, int);
PUBLIC ENTRY *	declareenum(		TABLE, TYPE  *, char *, TYPE *, int);
PUBLIC ENTRY *	declaremember(		TABLE, TYPE  *, char *, TYPE *, int);
PUBLIC ENTRY *	findvar(		TABLE, BLOCK *, char *);
PUBLIC ENTRY *	findtype(		TABLE, char *);
PUBLIC ENTRY *	findtypeid(		TABLE, BLOCK *, int, char *);
PUBLIC ENTRY *	findtag(		TABLE, char *);
PUBLIC ENTRY *	findmember(		TYPE *, char *);
PUBLIC ENTRY *	findenumconst(		TYPE *, int);
PUBLIC ENTRY *	whichentry(		BLOCK *, void *, char *);
PUBLIC ENTRY *	whichmember(		TYPE *, int);
PUBLIC TYPE *	newpointer(		TYPE *);
PUBLIC TYPE *	newarray(		TYPE *, int, int);
PUBLIC TYPE *	newstruct(		void);
PUBLIC TYPE *	newfunction(		TYPE *);
PUBLIC TYPE *	newenumeration(		void);
PUBLIC TYPE *	newtag(			ENTRY *);
PUBLIC TYPE *	newtypedef(		ENTRY *);
PUBLIC TYPE *	newbasetype(		TYPEID, int, BOOL);
PUBLIC TYPE *	newintegraltype(	int, BOOL);
PUBLIC TYPE *	newfloatingtype(	int);
PUBLIC TYPE *	reusetype(		TYPE *);
PUBLIC TYPE *	skipreuse(		TYPE *);
PUBLIC TYPE *	skiptypedef(		TYPE *);
PUBLIC TYPE *	hosttype(		TYPE *);
PUBLIC BLOCK *	newblock(		BLOCK *);
PUBLIC void	addline(		BLOCK *, int);
PUBLIC void	walkblock(		BLOCK *, void (*)(), long);
PUBLIC BLOCK *	searchblock(		BLOCK *, BOOL (*)(), long);
PUBLIC BLOCK *	findblock(		LOCATION);
PUBLIC ENTRY *	findfunction(		struct module *, int);
PUBLIC BOOL	validline(		LOCATION);
PUBLIC void	freetype(		TYPE *);
PUBLIC void	freeblock(		BLOCK *);
PUBLIC void	freesymbol(		SYMBOL *);
PUBLIC void	freeentry(		ENTRY *);
PUBLIC void	putblock(		BLOCK *, FILE *);
PUBLIC void	putentry(		ENTRY *, FILE *);
PUBLIC void	putsymbol(		SYMBOL *, FILE *);


/*expr.h***********************************************/

#define OCTAL   8
#define DECIMAL 10
#define HEX     16

#define UPTOCOMMA 3
#define PASTCOMMA 2

typedef enum
{
  T_Auto,       T_Break,     T_Case,       T_Char,        T_Const,    T_Continue, T_Default,  T_Do,
  T_Double,     T_Else,      T_Enum,       T_Extern,      T_Float,    T_For,      T_Goto,     T_If,
  T_Int,	T_Long,      T_Register,   T_Return,      T_Short,    T_Signed,   T_Sizeof,   T_STATIC,
  T_Struct,     T_Switch,    T_Typedef,    T_Union,       T_Unsigned, T_Void,     T_Volatile, T_While,
  T_Identifier, T_Constant,  T_String,     T_LBracket,    T_RBracket, T_LParen,   T_RParen,   T_Dot,
  T_Arrow,      T_PlusPlus,  T_MinusMinus, T_BitAnd,      T_Times,    T_Plus,     T_Minus,    T_BitNot,
  T_LogNot,     T_Divide,    T_Remainder,  T_LShift,      T_RShift,   T_LT,       T_GT,       T_LE,
  T_GE,		T_EQ,	     T_NE,	   T_BitXOr,	  T_BitOr,    T_LogAnd,   T_LogOr,    T_Conditional,
  T_Assign,	T_TimesEq,   T_DivideEq,   T_RemainderEq, T_PlusEq,   T_MinusEq,  T_LShiftEq, T_RShiftEq,
  T_BitAndEq,   T_BitXOrEq,  T_BitOrEq,    T_Comma,	  T_LBrace,   T_RBrace,   T_Colon,    T_Semicolon,
  T_Ellipsis,   T_Subscript, T_Call,       T_Function,    T_Pointer,  T_Array,    T_UPlus,    T_UMinus,
  T_Address,    T_Indirect,  T_PostInc,    T_PostDec,     T_Convert,  T_Cast,     T_Error,    T_Member,
  T_Parameter,  T_Tag,       T_End,        T_List
} TOKEN;

typedef union
  {
    int 	integral;
    float	floating4;
    double	floating8;
  }
VALUE;

typedef union expr * exprptr;

typedef union expr
  {
    struct
      {
	TOKEN 		op;
	typeptr		type;
	exprptr		expr1;
	exprptr		expr2;
	exprptr		expr3;
      }
    generic;

    struct
      {
	TOKEN 		token;
	typeptr		type;
	struct entry *	entry;
      }
    identifier;
    
    struct
      {
	TOKEN 		token;
	typeptr		type;
	VALUE		value;
      }
    constant;
    
    struct
      {
	TOKEN 		token;
	typeptr		type;
	char *		value;
      }
    string;
    
    struct
      {
	TOKEN 		op;
	typeptr		type;
	exprptr		expr;
      }
    cast;
  }
EXPR;

typedef union
  {
    long 	number;
    EXPR *	expr;
    ENTRY *	entry;
  }
VAL;

typedef struct
  {
    TOKEN 	token;
    VAL		value;
  }
LEXICON;

extern char *	tokennames[];

PUBLIC BOOL	evalcond(	struct eval *, char *, BLOCK * );
PUBLIC EXPR *	parseexpr(	struct eval *, char *, BLOCK * );
PUBLIC void *	evaladdr(	struct eval *, EXPR * );
PUBLIC void	putexpr(	EXPR *, FILE * );


/*eval.h*******************************************************/

#define STACK_SIZE 1000
#define ALIGN(l) ((l + 3) & ~3)

typedef struct eval
  {
    int 		ch;
    char *		chptr;
    TOKEN		token;
    VAL			tokenvalue;
    int			tokenindex;
    char		tokenbuffer[ NAME_MAX + 1 ];
    BOOL		backtracked;		  	/* ACE: must initialise to FALSE */
    LEXICON		nextlexicon;
    LEXICON		prevlexicon;
    byte		stack[ STACK_SIZE ];
    byte *		stackptr;
    DEBUG *		debug;
    struct block *	block;
  }
EVAL;

PUBLIC void 	genexpr(	EVAL *, EXPR * );
PUBLIC void	genvoidexpr(	EVAL *, EXPR * );
PUBLIC void	genaddr(	EVAL *, EXPR * );
PUBLIC void	genparam(	EVAL *, PARAM *, int );
PUBLIC void	lvalue(		EVAL *, ENTRY * );
PUBLIC void	rvalue(		EVAL *, ENTRY * );


/*cmd.h*******************************************/


#define WordMax		511
#define ArgMax		80


#define CommandLevel	1
#define LoopLevel	2
#define BreakLevel	3
#define ErrorLevel	4
#define FileLevel	5
#define TopLevel	6

PUBLIC void	_do(		DEBUG *, char * );
PUBLIC void	interp(		DEBUG * );
PUBLIC int	cmdexec(	DEBUG *, char * );
PUBLIC void	cmderr(		DEBUG *, char *, ... );
PUBLIC void	cmdmsg(		DEBUG *, char *, ... );
PUBLIC void	cmdjmp(		DEBUG *, int );


/*util.h*************************************************/


#define TabSize 	8

PUBLIC char *	strdup(		char * );
PUBLIC void	tabexp(		char *, char *, int );
PUBLIC BOOL	optequ(		char *, char * );
PUBLIC char *	getvar(		char **, char * );
PUBLIC LOCATION getloc(		DEBUG *, char * );
PUBLIC char *	formloc(	char *, LOCATION );
PUBLIC char *	basename(	char * );
PUBLIC int	getkeyname(	char * );
PUBLIC void	formkeyname(	char *, int );
PUBLIC void	formvarloc(	char *, struct entry * );
PUBLIC char *	formword(	char ** );
PUBLIC void	bigbuf(		FILE * );
PUBLIC FILE *	my_fopen(	const char *, const char * );
PUBLIC FILE *	my_fdopen(	int, char * );


/*info.h**************************************************/


PUBLIC BLOCK *	loadinfo(	DEBUG *, struct module * );


/*added definitions and declarations ***********************/


PUBLIC int	sopen(		Stream * stream);
PUBLIC void	_cd(		DEBUG *  debug, char *path);
#ifdef OLDCODE
PUBLIC void 	_dump(		DEBUG * );
#else
PUBLIC void 	_dump(		DEBUG * debug, char *exprstr);
#endif
PUBLIC void 	_edit(		DEBUG * debug, LOCATION loc);
PUBLIC void	_help(		DEBUG * debug, char *topic);
PUBLIC void	_make(		DEBUG * debug);
PUBLIC void	_menu(		DEBUG * debug, char *title, int cmd, char *cmdv[], char *labv[]);
PUBLIC void	_print(		DEBUG * debug, char *exprstr, FORMAT format, int chase);
PUBLIC void	_pwd(		DEBUG * debug);
PUBLIC void	_shell(		DEBUG * debug, char *cmdline);
PUBLIC void	_watchpoint(	DEBUG * debug, char *eprstr, char *docmd, FORMAT format, BOOL silent);
PUBLIC void	_whatis(	DEBUG * debug, char *exprstr);

/* -- crf : 07/08/91 - "all" not used */
PUBLIC void	_where(		DEBUG * debug) ; /* , BOOL all); */

PUBLIC void	_whereis(	DEBUG * debug, char *name);
PUBLIC void	_which(		DEBUG * debug, char *name);
PUBLIC void	putvalue(	DEBUG * debug, TYPE *type, FORMAT format, int inden, int chase);
PUBLIC TYPE *	typeofexpr(	EXPR *  expr);
PUBLIC void	checkstack(	EVAL *  eval);
PUBLIC void	freeexpr(	EXPR *  expr);
PUBLIC int	sizeofexpr(	EXPR *  expr);
PUBLIC void	puttype(	TYPE *  type, FILE *file);
PUBLIC void	notifywatchpoints(DEBUG * debug, void *addr, int size, word scope);
PUBLIC int	pop(		EVAL * eval);
PUBLIC byte *	ppop(		EVAL * eval);
PUBLIC BOOL	isintegral(	TYPE * type);
PUBLIC BOOL	isfloat(	TYPE * type);
PUBLIC int	sizeoftype(	TYPE * type);
PUBLIC EXPR *	mkintconst(	EVAL * eval, int value);
PUBLIC EXPR *	mkstring(	EVAL * eval, char *value);
PUBLIC EXPR *	mkfloatconst(	EVAL * eval, double value);
PUBLIC void	recover(	EVAL * eval);
PUBLIC EXPR *	mkcond(		EVAL * eval, EXPR *expr1, EXPR *expr2, EXPR *expr3);
PUBLIC EXPR *	mkbinary(	EVAL * eval, TOKEN op, EXPR *expr1, EXPR *expr2);
PUBLIC EXPR *	mkunary(	EVAL * eval, TOKEN op, EXPR *expr);

#ifdef OLDCODE
PUBLIC EXPR *	mkexprlist(	EVAL * eval, EXPR *expr1, EXPR *expr2);
#endif
/*
-- crf : 18/08/91 - "eval" declared, not used ...
*/
PUBLIC EXPR *	mkexprlist(	EXPR * expr1, EXPR *expr2);

PUBLIC EXPR *	mkfieldref(	EVAL * eval, TOKEN op, EXPR *expr, char *name);
PUBLIC EXPR *	mkidentifier(	ENTRY * entry);
PUBLIC EXPR *	mkcast(		EVAL * eval, TYPE *type, EXPR *expr);
PUBLIC int	strideofexpr(	EXPR * expr);
PUBLIC BOOL	isfunction(	TYPE * type);
PUBLIC void	semerr(		EVAL * eval, char *format, ...);
PUBLIC BOOL	isunsigned(	TYPE * type);
PUBLIC BOOL	isstring(	TYPE * type);
PUBLIC BOOL	isShortArray(	TYPE * type );
PUBLIC BOOL	isaggregate(	TYPE * type);
PUBLIC char *	expandcmd(	INTERP * interp, char *buf, char *cmd, uword bufsiz);
PUBLIC void	tidyup(		void );
PUBLIC void	initmem(	BOOL memchecking);
PUBLIC EVAL *	neweval(	DEBUG * debug);
PUBLIC TABLE *	newtable(	void );
PUBLIC BOOL	readcode(	DEBUG * debug);
PUBLIC void	remeval(	EVAL * eval);
PUBLIC void	putwatchpoint(	WATCHPOINT * watchpoint, DEBUG *debug);

/**** new funktions *******/
PUBLIC void	tagerr(		EVAL *eval, char *format, ...);/* CR: nearly the same as semerr */

#ifdef PARSYTEC
PUBLIC int 	actualisewatchpoints(DEBUG *, word , int , word );/* CR: for notifywp */
#endif

/* -- crf : 05/08/91 - additional parameter "del_watch_id" */
PUBLIC int	actualisewatchpoints(DEBUG *, word , int , word , UWORD *);

PUBLIC WATCHPOINT *	addwatchpoint(DEBUG *, char *, void *, int, char *, FORMAT, BOOL, BLOCK *);

/* -- crf : 24/07/91 - Bug 708 */
PUBLIC int	num_watch_elements (WATCHPOINT *, DEBUG *) ;

/********** new defines **************************/
#define NEW_Watchpoint		2
#define OLD_Watchpoint		3


/********* new variables ************************/

/*
-- crf : 26/09/91 - Bug 677 
-- concerning running client programs from a directory other than that where
-- the sources are located - changes made to :
--   1. loadsource() (source.c) - loads source files
--   2. loadinfo() (info.c) - loads .dbg files
--   3. wrefill() (display.c) - tells the user if sources can't be located
-- (if the required files cannot be located in the current directory, these
-- routines look in the directory indicated by the environment variable
-- defined below).
*/
#define DBGSRC_VARNAME "DBGSRC"
@


1.10
log
@added class field to watchpoint structure, in order to allow proper scoping
@
text
@d24 1
a24 1
* $Header: /hsrc/cmds/debugger/RCS/tla.h,v 1.9 1993/03/19 16:51:37 nickc Exp nickc $
d249 1
a249 1
    CLASS		class;
d733 1
a733 1
    CLASS	class;
d743 1
a743 1
    CLASS	class;
d753 1
a753 1
    CLASS	class;
d763 1
a763 1
    CLASS	class;
d773 1
a773 1
    CLASS	class;
d784 1
a784 1
    CLASS	class;
@


1.9
log
@removed shifted cursor keys - no longer supported by Helios
@
text
@d24 1
a24 1
* $Header: /hsrc/cmds/debugger/RCS/tla.h,v 1.8 1993/03/17 17:41:54 nickc Exp nickc $
d216 6
d246 4
a249 1
  
a626 6

typedef enum
{
  C_Auto, C_Common, C_Display, C_Enum, C_Extern, C_Member, C_Param, C_Register,
  C_Static, C_Tag, C_Typedef
} CLASS;
@


1.8
log
@minor cosmetic changes
@
text
@d24 1
a24 1
* $Header: /hsrc/cmds/debugger/RCS/tla.h,v 1.7 1993/03/11 16:43:05 nickc Exp nickc $
d414 1
d419 1
d453 1
d1022 2
a1023 2
PUBLIC int	sopen(		Stream *stream);
PUBLIC void	_cd(		DEBUG *debug, char *path);
d1025 1
a1025 1
PUBLIC void 	_dump(		DEBUG *);
d1027 1
a1027 1
PUBLIC void 	_dump(		DEBUG *debug, char *exprstr);
d1029 9
a1037 9
PUBLIC void 	_edit(		DEBUG *debug, LOCATION loc);
PUBLIC void	_help(		DEBUG *debug, char *topic);
PUBLIC void	_make(		DEBUG *debug);
PUBLIC void	_menu(		DEBUG *debug, char *title, int cmd, char *cmdv[], char *labv[]);
PUBLIC void	_print(		DEBUG *debug, char *exprstr, FORMAT format, int chase);
PUBLIC void	_pwd(		DEBUG *debug);
PUBLIC void	_shell(		DEBUG *debug, char *cmdline);
PUBLIC void	_watchpoint(	DEBUG *debug, char *eprstr, char *docmd, FORMAT format, BOOL silent);
PUBLIC void	_whatis(	DEBUG *debug, char *exprstr);
d1040 1
a1040 1
PUBLIC void	_where(		DEBUG *debug) ; /* , BOOL all); */
d1042 21
a1062 21
PUBLIC void	_whereis(	DEBUG *debug, char *name);
PUBLIC void	_which(		DEBUG *debug, char *name);
PUBLIC void	putvalue(	DEBUG *debug, TYPE *type, FORMAT format, int inden, int chase);
PUBLIC TYPE *	typeofexpr(	EXPR *expr);
PUBLIC void	checkstack(	EVAL *eval);
PUBLIC void	freeexpr(	EXPR *expr);
PUBLIC int	sizeofexpr(	EXPR *expr);
PUBLIC void	puttype(	TYPE *type, FILE *file);
PUBLIC void	notifywatchpoints(DEBUG *debug, void *addr, int size, word scope);
PUBLIC int	pop(		EVAL *eval);
PUBLIC byte *	ppop(		EVAL *eval);
PUBLIC BOOL	isintegral(	TYPE *type);
PUBLIC BOOL	isfloat(	TYPE *type);
PUBLIC int	sizeoftype(	TYPE *type);
PUBLIC EXPR *	mkintconst(	EVAL *eval, int value);
PUBLIC EXPR *	mkstring(	EVAL *eval, char *value);
PUBLIC EXPR *	mkfloatconst(	EVAL *eval, double value);
PUBLIC void	recover(	EVAL *eval);
PUBLIC EXPR *	mkcond(		EVAL *eval, EXPR *expr1, EXPR *expr2, EXPR *expr3);
PUBLIC EXPR *	mkbinary(	EVAL *eval, TOKEN op, EXPR *expr1, EXPR *expr2);
PUBLIC EXPR *	mkunary(	EVAL *eval, TOKEN op, EXPR *expr);
d1065 1
a1065 1
PUBLIC EXPR *	mkexprlist(	EVAL *eval, EXPR *expr1, EXPR *expr2);
d1070 1
a1070 1
PUBLIC EXPR *	mkexprlist(	EXPR *expr1, EXPR *expr2);
d1072 8
a1079 8
PUBLIC EXPR *	mkfieldref(	EVAL *eval, TOKEN op, EXPR *expr, char *name);
PUBLIC EXPR *	mkidentifier(	ENTRY *entry);
PUBLIC EXPR *	mkcast(		EVAL *eval, TYPE *type, EXPR *expr);
PUBLIC int	strideofexpr(	EXPR *expr);
PUBLIC BOOL	isfunction(	TYPE *type);
PUBLIC void	semerr(		EVAL *eval, char *format, ...);
PUBLIC BOOL	isunsigned(	TYPE *type);
PUBLIC BOOL	isstring(	TYPE *type);
d1081 3
a1083 3
PUBLIC BOOL	isaggregate(	TYPE *type);
PUBLIC char *	expandcmd(	INTERP *interp, char *buf, char *cmd, uword bufsiz);
PUBLIC void	tidyup(		void);
d1085 5
a1089 5
PUBLIC EVAL *	neweval(	DEBUG *debug);
PUBLIC TABLE *	newtable(	void);
PUBLIC BOOL	readcode(	DEBUG *debug);
PUBLIC void	remeval(	EVAL *eval);
PUBLIC void	putwatchpoint(	WATCHPOINT *watchpoint, DEBUG *debug);
@


1.7
log
@added prototype of isShortArray()
@
text
@d16 1
a16 1
*         (c) Copyright 1988 - 1992, Perihelion Software Ltd.
d24 1
a24 1
* $Header: /hsrc/cmds/debugger/RCS/tla.h,v 1.6 1993/03/10 16:16:04 nickc Exp nickc $
d550 27
a576 27
PUBLIC void receiver(DEBUG *);
PUBLIC void syscall(DEBUG *, void *, int, void *, int, void *);
PUBLIC void sysfree(DEBUG *, int);
PUBLIC void sysfreeall(DEBUG *);
PUBLIC void sysgo(DEBUG *, int);
PUBLIC void sysgoall(DEBUG *);
PUBLIC void sysgoto(DEBUG *, int, int, int);
PUBLIC void sysgotoall(DEBUG *, int, int);
PUBLIC void sysgotoframe(DEBUG *, int, int);
PUBLIC void sysgotoframeall(DEBUG *, int);
PUBLIC void syskill(DEBUG *, int);
PUBLIC void syskillall(DEBUG *);
PUBLIC void sysprofile(DEBUG *, int, int, int, int);
PUBLIC void sysstep(DEBUG *, int);
PUBLIC void sysstepall(DEBUG *);
PUBLIC void sysstop(DEBUG *, int);
PUBLIC void sysstopall(DEBUG *);
PUBLIC void systrace(DEBUG *, int, int, int, int);
PUBLIC void systraceall(DEBUG *);
PUBLIC void sysaddbreak(DEBUG *, int, int, int);
PUBLIC void sysrembreak(DEBUG *, int, int);
PUBLIC void peekmem(DEBUG *, void *, void *, int);
PUBLIC void peekdata(DEBUG *, void *, int, int, int);
PUBLIC void peekstack(DEBUG *, void *, int, int, int, int);
PUBLIC void pokemem(DEBUG *, void *, void *, int);
PUBLIC void *locatedata(DEBUG *, int, int);
PUBLIC void *locatestack(DEBUG *, int, int, int);
d578 2
a579 2
PUBLIC void *locateframe(	DEBUG *, int, int, int);
PUBLIC void *locateregister(DEBUG *, int, int, int);
d581 9
a589 9
PUBLIC void sysaddwatch(DEBUG *, void *, int);
PUBLIC void sysremwatch(DEBUG *, void *, int);
PUBLIC int syswhere(DEBUG *, int, int, LOCATION *);
PUBLIC void systimeout(DEBUG *, int);
PUBLIC void systimeoutall(DEBUG *);

PUBLIC UBYTE peekbyte(DEBUG *, void *);
PUBLIC USHORT peekshort(DEBUG *, void *);
PUBLIC UWORD peekword(DEBUG *, void *);
d794 1
a794 1
PUBLIC ENTRY *	findtype(		TABLE, BLOCK *, char *);
d796 1
a796 1
PUBLIC ENTRY *	findtag(		TABLE, BLOCK *, char *);
d1019 2
a1020 2
PUBLIC int	sopen(Stream *stream);
PUBLIC void	_cd(DEBUG *debug, char *path);
d1022 1
a1022 1
PUBLIC void 	_dump(DEBUG *);
d1024 1
a1024 1
PUBLIC void 	_dump(DEBUG *debug, char *exprstr);
d1026 9
a1034 9
PUBLIC void 	_edit(DEBUG *debug, LOCATION loc);
PUBLIC void	_help(DEBUG *debug, char *topic);
PUBLIC void	_make(DEBUG *debug);
PUBLIC void	_menu(DEBUG *debug, char *title, int cmd, char *cmdv[], char *labv[]);
PUBLIC void	_print(DEBUG *debug, char *exprstr, FORMAT format, int chase);
PUBLIC void	_pwd(DEBUG *debug);
PUBLIC void	_shell(DEBUG *debug, char *cmdline);
PUBLIC void	_watchpoint(DEBUG *debug, char *eprstr, char *docmd, FORMAT format, BOOL silent);
PUBLIC void	_whatis(DEBUG *debug, char *exprstr);
d1037 1
a1037 1
PUBLIC void	_where(DEBUG *debug) ; /* , BOOL all); */
d1039 8
a1046 8
PUBLIC void	_whereis(DEBUG *debug, char *name);
PUBLIC void	_which(DEBUG *debug, char *name);
PUBLIC void	putvalue(DEBUG *debug, TYPE *type, FORMAT format, int inden, int chase);
PUBLIC TYPE *	typeofexpr(EXPR *expr);
PUBLIC void	checkstack(EVAL *eval);
PUBLIC void	freeexpr(EXPR *expr);
PUBLIC int	sizeofexpr(EXPR *expr);
PUBLIC void	puttype(TYPE *type, FILE *file);
d1048 12
a1059 12
PUBLIC int	pop(EVAL *eval);
PUBLIC byte *	ppop(EVAL *eval);
PUBLIC BOOL	isintegral(TYPE *type);
PUBLIC BOOL	isfloat(TYPE *type);
PUBLIC int	sizeoftype(TYPE *type);
PUBLIC EXPR *	mkintconst(EVAL *eval, int value);
PUBLIC EXPR *	mkstring(EVAL *eval, char *value);
PUBLIC EXPR *	mkfloatconst(EVAL *eval, double value);
PUBLIC void	recover(EVAL *eval);
PUBLIC EXPR *	mkcond(EVAL *eval, EXPR *expr1, EXPR *expr2, EXPR *expr3);
PUBLIC EXPR *	mkbinary(EVAL *eval, TOKEN op, EXPR *expr1, EXPR *expr2);
PUBLIC EXPR *	mkunary(EVAL *eval, TOKEN op, EXPR *expr);
d1062 1
a1062 1
PUBLIC EXPR *	mkexprlist(EVAL *eval, EXPR *expr1, EXPR *expr2);
d1067 1
a1067 1
PUBLIC EXPR *	mkexprlist(EXPR *expr1, EXPR *expr2);
d1069 18
a1086 18
PUBLIC EXPR *	mkfieldref(EVAL *eval, TOKEN op, EXPR *expr, char *name);
PUBLIC EXPR *	mkidentifier(ENTRY *entry);
PUBLIC EXPR *	mkcast(EVAL *eval, TYPE *type, EXPR *expr);
PUBLIC int	strideofexpr(EXPR *expr);
PUBLIC BOOL	isfunction(TYPE *type);
PUBLIC void	semerr(EVAL *eval, char *format, ...);
PUBLIC BOOL	isunsigned(TYPE *type);
PUBLIC BOOL	isstring(TYPE *type);
PUBLIC BOOL	isShortArray( TYPE * type );
PUBLIC BOOL	isaggregate(TYPE *type);
PUBLIC char *	expandcmd(INTERP *interp, char *buf, char *cmd, uword bufsiz);
PUBLIC void	tidyup(void);
PUBLIC void	initmem(BOOL memchecking);
PUBLIC EVAL *	neweval(DEBUG *debug);
PUBLIC TABLE *	newtable(void);
PUBLIC BOOL	readcode(DEBUG *debug);
PUBLIC void	remeval(EVAL *eval);
PUBLIC void	putwatchpoint(WATCHPOINT *watchpoint, DEBUG *debug);
d1089 1
a1089 1
PUBLIC void	tagerr(EVAL *eval, char *format, ...);/* CR: nearly the same as semerr */
@


1.6
log
@added String type to FORMAT enum
@
text
@d24 1
a24 1
* $Header: /hsrc/cmds/debugger/RCS/tla.h,v 1.5 1992/11/04 14:53:45 nickc Exp nickc $
d1077 1
@


1.5
log
@C40 version completed
@
text
@d24 1
a24 1
* $Header: /m/giga/Helios.tmp/Helios/cmds/debugger/RCS/tla.h,v 1.4 1992/10/27 13:48:29 nickc Exp nickc $
d81 1
a81 1
    Default, Ascii, Binary, Decimal, Error, Float, Hexadecimal, Octal, Unsigned
d408 2
a409 2
#define PageUp		(PageKeys + 4)
#define PageDown	(PageKeys + 3)
@


1.4
log
@changed definitions of popword9) and expandcmd() and increased WordMax
@
text
@d11 1
a11 1
-- crf : August 1991 - some modifications
d13 2
a14 1
*         (c) Copyright 1988, Perihelion Software Ltd.
d16 2
d24 1
a24 1
* $Header: /hsrc/cmds/debugger/RCS/tla.h,v 1.3 1991/10/01 13:41:27 craig Exp nickc $
d64 12
a75 12
typedef long LONG;
typedef unsigned long ULONG;
typedef int BOOL;
typedef Node NODE;
typedef List LIST;

#define AND &&
#define OR  ||

#define strequ(s, t)     (strcmp(s, t) == 0)
#define strnequ(s, t, n) (strncmp(s, t, n) == 0)
#define NEW(t)           (t *)newmem(sizeof(t))
d77 1
a77 1
#define PathMax 512
d80 4
a83 3
{
  Default, Ascii, Binary, Decimal, Error, Float, Hexadecimal, Octal, Unsigned
} FORMAT;
d86 5
a90 4
{
  struct module *module;
  int line;
} LOCATION;
d92 1
a92 1
#define HASH_MAX 211  /* CR: guess this def is better here */
d95 4
a98 3
{
  struct link *head;
} CHAIN;
d101 4
a104 3
{
  struct link *next;	
} LINK;
d107 6
a112 5
{
  LINK link;
  CHAIN entrylist;
  char name[1];
} SYMBOL;
d114 1
a114 1
typedef CHAIN TABLE[HASH_MAX]; /* CR: was in table.h */
d117 30
a146 28
{
  char name[256];
  LIST modulelist;
  LIST breakpointlist;
  LIST watchlist;
  LIST watchpointlist;
  LIST threadlist;
  Port port, reply;
  struct thread *thread;
  struct display *display;
  struct interp *interp;
  Environ env;
  struct line *line;
  struct eval *eval;
  struct chain *table; /* CR: was 'struct table' but there is no struct table */
  int ifwatchpoint; /* CR: im sorry for this doggy solution of the varwindow */
  void *tempwatchpoint;/*   refreshing problem */
} DEBUG;

PUBLIC void *newmem(int);
PUBLIC void freemem(void *);
PUBLIC void putmem(void);

PUBLIC void initdebug(int, char *[]);
PUBLIC void debugf(char *, ...);
PUBLIC DEBUG *newdebug(char *);
PUBLIC void startdebug(DEBUG *, Port, Port);
PUBLIC void remdebug(DEBUG *);
d150 3
a152 2
extern Semaphore loadlock;
extern FILE      my_iob[_MYSYS_OPEN];
d160 15
a174 14
{
  NODE node;
  char *name;
  int modnum;
  DEBUG *debug;
  struct source *source;
  struct block *outerblock;
} MODULE;

PUBLIC BOOL addmodule(DEBUG *, char *name, int modnum);
PUBLIC void remmodule(MODULE *);
PUBLIC MODULE *getmodule(DEBUG *, int modnum);
PUBLIC MODULE *findmodule(DEBUG *, char *name);
PUBLIC struct source *getsource(MODULE *);
d181 7
a187 6
{
  NODE node;
  LOCATION loc;
  int count;
  char *docmd;
} BREAKPOINT;
d191 5
a195 4
{
  NODE node;
  union expr *expr;
} WATCH;
d198 7
a204 6
{
  NODE node;
  union expr *expr;
  LIST watchelementlist;
  BOOL recalc;
} WATCHPOINT;
d207 12
a218 6
{
  NODE node;
  void *addr;
  int size;
} WATCHELEMENT;
#else
a219 5

typedef struct block *blockptr;
typedef struct thread *threadptr;
typedef struct eval *evalptr;

d221 12
a232 12
{
  NODE node;
  char *expr;
  void *addr;
  int size;
  char *docmd;
  FORMAT format;
  BOOL silent;
  int scope; /* CR: I need this to indicate the level of def */
  blockptr block; /* CR: Saved context for evaluation */
  threadptr thread; /* CR: Saved thread for evaluation */
  evalptr eval;
d239 1
a239 1
  int num_elements ;
d241 5
a245 2
} WATCHPOINT;
#endif
d248 19
a266 18
{
  void *addr;
  int size;
} MEM_LOCATION;

PUBLIC void stopped(DEBUG *, int, int, int);
PUBLIC void traced(DEBUG *, int, int, int);
PUBLIC void entered(DEBUG *, int, int, int);
PUBLIC void returned(DEBUG *, int, int, int);
PUBLIC void endthread(DEBUG *, int);
PUBLIC void addbreakpoint(DEBUG *, LOCATION, int, char *);
PUBLIC void rembreakpoint(DEBUG *, LOCATION);
PUBLIC void freebreakpoint(BREAKPOINT *);
PUBLIC BREAKPOINT *findbreakpoint(DEBUG *, LOCATION);
PUBLIC void listbreakpoints(DEBUG *);
PUBLIC void remwatchpoint(DEBUG *, WATCHPOINT *);
PUBLIC void freewatchpoint(WATCHPOINT *);
PUBLIC void listwatchpoints(DEBUG *);
d275 6
a280 5
{
  int row;
  int col;
  int size;
} CURSOR;
d283 11
a293 10
{
  NODE node;
  struct display *display;
  int pos;
  int size;
  LOCATION loc;
  LOCATION progloc;
  CURSOR cur;
  FILE *traceout;
} WINDOW;
d296 45
a340 18
{
  DEBUG *debug;
  FILE *filein;
  FILE *fileout;
  LIST windowlist;
  WINDOW *topwin;
  Semaphore lock;
  int height;
  int width;
  int row;
  int col;
  int varsize;

/*
-- crf : 14/08/91 - related to Bug 708
-- Keep track of last line of watch window
*/
  int varline ;
a341 26
  struct watchpoint **varvec;
  Port breakport;
  BOOL breakflag;
  BOOL stop_display;
} DISPLAY;

PUBLIC DISPLAY *dopen(DEBUG *, char *, char *);
PUBLIC BOOL testbreak(DISPLAY *);
PUBLIC void dclose(DISPLAY *);
PUBLIC void drefresh(DISPLAY *);
PUBLIC void dcursor(DISPLAY *, int, int);
PUBLIC void dstart(DISPLAY *);
PUBLIC void dend(DISPLAY *, BOOL);
PUBLIC void dclear(DISPLAY *);
PUBLIC void dinverse(DISPLAY *);
PUBLIC void dnormal(DISPLAY *);
PUBLIC void deol(DISPLAY *);
PUBLIC void dlock(DISPLAY *);
PUBLIC void dunlock(DISPLAY *);
PUBLIC void dprintf(DISPLAY *, char *, ...);
PUBLIC void xdputc(DISPLAY *, int);
PUBLIC void dputc(DISPLAY *, int);
PUBLIC int dgetc(DISPLAY *);
PUBLIC void raw(DISPLAY *);
PUBLIC void cooked(DISPLAY *);

d343 6
a348 2
PUBLIC void vgrow(DISPLAY *);
PUBLIC void vshrink(DISPLAY *);
d351 25
a375 29
/* -- crf : 24/07/91 - Bug 708 */
PUBLIC void vgrow(DISPLAY *, int);
PUBLIC void vshrink(DISPLAY *, int);

PUBLIC void vinsert(DISPLAY *, struct watchpoint *);
PUBLIC void vdelete(DISPLAY *, int);
PUBLIC void vupdate(DISPLAY *, struct watchpoint *);
PUBLIC WINDOW *wopen(DISPLAY *);
PUBLIC void wclose(WINDOW *);
PUBLIC void wclear(WINDOW *);
PUBLIC void wselect(WINDOW *);
PUBLIC void wgrow(WINDOW *);
PUBLIC void wshrink(WINDOW *);
PUBLIC void lowlight(WINDOW *);
PUBLIC void wgoto(WINDOW *, LOCATION);
PUBLIC void view(WINDOW *, LOCATION);
PUBLIC void scrollup(WINDOW *, int);
PUBLIC void scrolldown(WINDOW *, int);
PUBLIC void pageup(WINDOW *);
PUBLIC void pagedown(WINDOW *);
PUBLIC void pagefirst(WINDOW *);
PUBLIC void pagelast(WINDOW *);
PUBLIC void cursorup(WINDOW *);
PUBLIC void cursordown(WINDOW *);
PUBLIC void cursorleft(WINDOW *);
PUBLIC void cursorright(WINDOW *);
PUBLIC void cursorgrow(WINDOW *);
PUBLIC void cursorshrink(WINDOW *);
PUBLIC char *getcurtext(WINDOW *, char *);
d380 1
a380 1
#define MAX_KEY 255
d382 1
a382 1
typedef char *KEYMAP[MAX_KEY + 1];
d384 6
a389 6
PUBLIC void initkeymap(KEYMAP);
PUBLIC void freekeymap(KEYMAP);
PUBLIC void addkey(KEYMAP, int, char *);
PUBLIC void remkey(KEYMAP, int);
PUBLIC char *getkey(KEYMAP, int);
PUBLIC void listkeys(KEYMAP, struct display *);
d424 4
a427 4
#define LineMax 255
#define SaveMax 20
#define prevslot(s) if (--(s) < 0) (s) = SaveMax - 1
#define nextslot(s) if (++(s) == SaveMax) (s) = 0
d429 1
a429 1
#define iscst(c) ((c) >= 0x20 AND (c) <= 0x7f)
d432 19
a450 18
{
  int index;
  int length;
  BOOL update;
  struct display *display;
  char buffer[LineMax + 1];
  char savebuffer[LineMax + 1];
  int firstslot;
  int lastslot;
  int currentslot;
  char *vec[SaveMax];
  KEYMAP keymap;
} LINE;

PUBLIC LINE *newline(struct display *);
PUBLIC void remline(LINE *);
PUBLIC char *getinput(LINE *, char *, char *);
PUBLIC char *getline(LINE *);
d456 1
a456 1
#define MAX_LINEVEC 100
d459 17
a475 16
{
  NODE node;
  char *name;
  char **linevec;
  int lastline;
  int usage;
} SOURCE;

PUBLIC void initsource(void);
PUBLIC SOURCE *loadsource(DEBUG *, char *);
PUBLIC void unloadsource(SOURCE *);
PUBLIC SOURCE *findsource(char *);
PUBLIC void list(struct display *, SOURCE *, int, int);
PUBLIC int search(SOURCE *, char *, int, BOOL, BOOL);
PUBLIC char *getword(char *, SOURCE *, int, int, int);
PUBLIC char *gettext(char *, SOURCE *, int, int, int);
d482 17
a498 16
{
  NODE node;
  int id;
  LOCATION loc;
  struct block *block;
  struct entry *function;
  struct window *window;
  Semaphore sync;
} THREAD;

PUBLIC THREAD *newthread(DEBUG *, int);
PUBLIC void remthread(THREAD *);
PUBLIC THREAD *findthread(DEBUG *, int);
PUBLIC void nextthread(DEBUG *);
PUBLIC void prevthread(DEBUG *);
PUBLIC void resume(THREAD *);
d504 2
a505 2
#define EOL      '\0'
#define StackMax 1024
d508 10
a517 9
{
  LIST aliaslist;
  LIST definelist;
  int charindex;
  char charstack[StackMax];
  jmp_buf home;
  DEBUG *debug;
  Semaphore lock;
} INTERP;
d520 24
a543 23
{
  NODE node;
  char *name;
  char *text;
} MACRO;

PUBLIC INTERP *newinterp(DEBUG *);
PUBLIC void reminterp(INTERP *);
PUBLIC void lockinterp(INTERP *);
PUBLIC void unlockinterp(INTERP *);
PUBLIC void alias(INTERP *, char *, char *);
PUBLIC void define(INTERP *, char *, char *);
PUBLIC char *getalias(INTERP *, char *);
PUBLIC char *getdefine(INTERP *, char *);
PUBLIC void unalias(INTERP *, char *);
PUBLIC void undefine(INTERP *, char *);
PUBLIC void listaliases(INTERP *, DISPLAY *);
PUBLIC void listdefines(INTERP *, DISPLAY *);
PUBLIC void pushchar(INTERP *, char);
PUBLIC void pushword(INTERP *, char *);
PUBLIC void pushcmd(INTERP *, char *);
PUBLIC int popchar(INTERP *);
PUBLIC char *popword(INTERP *, char *, uword);
d577 4
d629 10
a638 9
{
  LINK link;
  struct block *parent;
  CHAIN blocklist;
  struct entry *entry;
  struct module *module;
  int lines;
  LINENO *linevec;
} BLOCK;
d643 5
a647 4
{
  TYPEID id;
  typeptr type;
} REUSE;
d650 5
a654 4
{
  TYPEID id;
  typeptr type;
} TYPENAME;
d657 5
a661 4
{
  TYPEID id;
  typeptr host;
} POINTER;
d664 7
a670 5
{
  TYPEID id;
  typeptr host;
  int size, first;
} ARRAY;
d673 6
a678 5
{
  TYPEID id;
  struct entry *tag;
  CHAIN memberlist;
} STRUCTURE;
d681 6
a686 5
{
  TYPEID id;
  typeptr host;
  CHAIN paramlist;
} FUNCTION;
d689 5
a693 4
{
  TYPEID id;
  CHAIN constlist;
} ENUMERATION;
d696 6
a701 5
{
  TYPEID id;
  short size;
  short issigned;
} BASETYPE;
a703 2
{
  struct
d705 17
a721 12
    TYPEID id;
    typeptr host;
  } generic;
  REUSE reuse;
  TYPENAME typename;
  POINTER pointer;
  ARRAY array;
  STRUCTURE structure;
  FUNCTION function;
  ENUMERATION enumeration;
  BASETYPE basetype;
} TYPE;
d724 8
a731 7
{
  LINK link;
  char *name;
  CLASS class;
  TYPE *type;
  BLOCK *block;  /*** war als ifdef OLDCODE ***/
} TYPEDEF;
d734 8
a741 7
{
  LINK link;
  char *name;
  CLASS class;
  TYPE *type;
  int offset;
} MEMBER;
d744 8
a751 7
{
  LINK link;
  char *name;
  CLASS class;
  TYPE *type;
  int offset;
} ENUMCONST;
d754 8
a761 7
{
  LINK link;
  char *name;
  CLASS class;
  TYPE *type;
  int offset;
} PARAM;
d764 9
a772 8
{
  LINK link;
  char *name;
  CLASS class;
  TYPE *type;
  int offset;
  BLOCK *block;
} LOCAL;
d775 54
a828 52
{
  LINK link;
  char *name;
  CLASS class;
  TYPE *type;
  int offset;
  BLOCK *block;
} ENTRY;

PUBLIC ENTRY *declarevar(TABLE, BLOCK *, char *, CLASS, TYPE *, int, BLOCK *);
PUBLIC ENTRY *declarelocal(TABLE, BLOCK *, char *, TYPE *, int);
PUBLIC ENTRY *declaretype(TABLE, BLOCK *, char *, TYPE *);
PUBLIC ENTRY *declaretag(TABLE, BLOCK *, char *, TYPE *);
PUBLIC ENTRY *declareparam(TABLE, TYPE *, char *, TYPE *, int);
PUBLIC ENTRY *declareenum(TABLE, TYPE *, char *, TYPE *, int);
PUBLIC ENTRY *declaremember(TABLE, TYPE *, char *, TYPE *, int);
PUBLIC ENTRY *findvar(TABLE, BLOCK *, char *);
PUBLIC ENTRY *findtype(TABLE, BLOCK *, char *);
PUBLIC ENTRY *findtypeid(TABLE, BLOCK *, int, char *);
PUBLIC ENTRY *findtag(TABLE, BLOCK *, char *);
PUBLIC ENTRY *findmember(TYPE *, char *);
PUBLIC ENTRY *findenumconst(TYPE *, int);
PUBLIC ENTRY *whichentry(BLOCK *, void *, char *);
PUBLIC ENTRY *whichmember(TYPE *, int);
PUBLIC TYPE *newpointer(TYPE *);
PUBLIC TYPE *newarray(TYPE *, int, int);
PUBLIC TYPE *newstruct(void);
PUBLIC TYPE *newfunction(TYPE *);
PUBLIC TYPE *newenumeration(void);
PUBLIC TYPE *newtag(ENTRY *);
PUBLIC TYPE *newtypedef(ENTRY *);
PUBLIC TYPE *newbasetype(TYPEID, int, BOOL);
PUBLIC TYPE *newintegraltype(int, BOOL);
PUBLIC TYPE *newfloatingtype(int);
PUBLIC TYPE *reusetype(TYPE *);
PUBLIC TYPE *skipreuse(TYPE *);
PUBLIC TYPE *skiptypedef(TYPE *);
PUBLIC TYPE *hosttype(TYPE *);
PUBLIC BLOCK *newblock(BLOCK *);
PUBLIC void addline(BLOCK *, int);
PUBLIC void walkblock(BLOCK *, void (*)(), long);
PUBLIC BLOCK *searchblock(BLOCK *, BOOL (*)(), long);
PUBLIC BLOCK *findblock(LOCATION);
PUBLIC ENTRY *findfunction(struct module *, int);
PUBLIC BOOL validline(LOCATION);
PUBLIC void freetype(TYPE *);
PUBLIC void freeblock(BLOCK *);
PUBLIC void freesymbol(SYMBOL *);
PUBLIC void freeentry(ENTRY *);
PUBLIC void putblock(BLOCK *, FILE *);
PUBLIC void putentry(ENTRY *, FILE *);
PUBLIC void putsymbol(SYMBOL *, FILE *);
d842 13
a854 16
  T_Auto, T_Break, T_Case, T_Char, T_Const, T_Continue, T_Default, T_Do,
  T_Double, T_Else, T_Enum, T_Extern, T_Float, T_For, T_Goto, T_If, T_Int,
  T_Long, T_Register, T_Return, T_Short, T_Signed, T_Sizeof, T_STATIC,
  T_Struct, T_Switch, T_Typedef, T_Union, T_Unsigned, T_Void, T_Volatile,
  T_While, T_Identifier, T_Constant, T_String, T_LBracket, T_RBracket,
  T_LParen, T_RParen, T_Dot, T_Arrow, T_PlusPlus, T_MinusMinus, T_BitAnd,
  T_Times, T_Plus, T_Minus, T_BitNot, T_LogNot, T_Divide, T_Remainder,
  T_LShift, T_RShift, T_LT, T_GT, T_LE, T_GE, T_EQ, T_NE, T_BitXOr, T_BitOr,
  T_LogAnd, T_LogOr, T_Conditional, T_Assign, T_TimesEq, T_DivideEq,
  T_RemainderEq, T_PlusEq, T_MinusEq, T_LShiftEq,
  T_RShiftEq, T_BitAndEq, T_BitXOrEq, T_BitOrEq, T_Comma,
  T_LBrace, T_RBrace, T_Colon, T_Semicolon, T_Ellipsis,

  T_Subscript, T_Call, T_Function, T_Pointer, T_Array, T_UPlus,
  T_UMinus, T_Address, T_Indirect, T_PostInc, T_PostDec, T_Convert,
  T_Cast, T_Error, T_Member, T_Parameter, T_Tag, T_End, T_List
d858 6
a863 5
{
  int integral;
  float floating4;
  double floating8;
} VALUE;
d865 1
a865 1
typedef union expr *exprptr;
a867 2
{
  struct
d869 43
a911 29
    TOKEN op;
    typeptr type;
    exprptr expr1, expr2, expr3;
  } generic;
  struct
  {
    TOKEN token;
    typeptr type;
    struct entry *entry;
  } identifier;
  struct
  {
    TOKEN token;
    typeptr type;
    VALUE value;
  } constant;
  struct
  {
    TOKEN token;
    typeptr type;
    char *value;
  } string;
  struct
  {
    TOKEN op;
    typeptr type;
    exprptr expr;
  } cast;
} EXPR;
d914 6
a919 5
{
  long number;
  EXPR *expr;
  ENTRY *entry;
} VAL;
d922 12
a933 11
{
  TOKEN token;
  VAL value;
} LEXICON;

extern char *tokennames[];

PUBLIC BOOL evalcond(struct eval *, char *, BLOCK *);
PUBLIC EXPR *parseexpr(struct eval *, char *, BLOCK *);
PUBLIC void *evaladdr(struct eval *, EXPR *);
PUBLIC void putexpr(EXPR *, FILE *);
d942 23
a964 22
{
  int ch;
  char *chptr;
  TOKEN token;
  VAL tokenvalue;
  int tokenindex;
  char tokenbuffer[NAME_MAX + 1];
  BOOL backtracked; /* ACE: must initialise to FALSE */
  LEXICON nextlexicon;
  LEXICON prevlexicon;
  byte stack[STACK_SIZE];
  byte *stackptr;
  DEBUG *debug;
  struct block *block;
} EVAL;

PUBLIC void genexpr(EVAL *, EXPR *);
PUBLIC void genvoidexpr(EVAL *, EXPR *);
PUBLIC void genaddr(EVAL *, EXPR *);
PUBLIC void genparam(EVAL *, PARAM *, int);
PUBLIC void lvalue(EVAL *, ENTRY *);
PUBLIC void rvalue(EVAL *, ENTRY *);
d970 2
a971 2
#define WordMax	511
#define ArgMax	80
d981 6
a986 6
PUBLIC void _do(DEBUG *, char *);
PUBLIC void interp(DEBUG *);
PUBLIC int cmdexec(DEBUG *, char *);
PUBLIC void cmderr(DEBUG *, char *, ...);
PUBLIC void cmdmsg(DEBUG *, char *, ...);
PUBLIC void cmdjmp(DEBUG *, int);
d992 1
a992 1
#define TabSize 8
d994 14
a1007 14
PUBLIC char *strdup(char *);
PUBLIC void tabexp(char *, char *, int);
PUBLIC BOOL optequ(char *, char *);
PUBLIC char *getvar(char **, char *);
PUBLIC LOCATION getloc(DEBUG *, char *);
PUBLIC char *formloc(char *, LOCATION);
PUBLIC char *basename(char *);
PUBLIC int getkeyname(char *);
PUBLIC void formkeyname(char *, int);
PUBLIC void formvarloc(char *, struct entry *);
PUBLIC char *formword(char **);
PUBLIC void bigbuf(FILE *);
PUBLIC FILE *my_fopen(const char *, const char *);
PUBLIC FILE *my_fdopen(int, char *);
d1013 1
a1013 1
PUBLIC BLOCK *loadinfo(DEBUG *, struct module *);
d1019 2
a1020 2
PUBLIC int sopen(Stream *stream);
PUBLIC void _cd(DEBUG *debug, char *path);
d1022 1
a1022 1
PUBLIC void _dump(DEBUG *);
d1024 1
a1024 1
PUBLIC void _dump(DEBUG *debug, char *exprstr);
d1026 9
a1034 9
PUBLIC void _edit(DEBUG *debug, LOCATION loc);
PUBLIC void _help(DEBUG *debug, char *topic);
PUBLIC void _make(DEBUG *debug);
PUBLIC void _menu(DEBUG *debug, char *title, int cmd, char *cmdv[], char *labv[]);
PUBLIC void _print(DEBUG *debug, char *exprstr, FORMAT format, int chase);
PUBLIC void _pwd(DEBUG *debug);
PUBLIC void _shell(DEBUG *debug, char *cmdline);
PUBLIC void _watchpoint(DEBUG *debug, char *eprstr, char *docmd, FORMAT format, BOOL silent);
PUBLIC void _whatis(DEBUG *debug, char *exprstr);
d1037 1
a1037 1
PUBLIC void _where(DEBUG *debug) ; /* , BOOL all); */
d1039 21
a1059 21
PUBLIC void _whereis(DEBUG *debug, char *name);
PUBLIC void _which(DEBUG *debug, char *name);
PUBLIC void putvalue(DEBUG *debug, TYPE *type, FORMAT format, int inden, int chase);
PUBLIC TYPE *typeofexpr(EXPR *expr);
PUBLIC void checkstack(EVAL *eval);
PUBLIC void freeexpr(EXPR *expr);
PUBLIC int sizeofexpr(EXPR *expr);
PUBLIC void puttype(TYPE *type, FILE *file);
PUBLIC void notifywatchpoints(DEBUG *debug, void *addr, int size, word scope);
PUBLIC int pop(EVAL *eval);
PUBLIC byte *ppop(EVAL *eval);
PUBLIC BOOL isintegral(TYPE *type);
PUBLIC BOOL isfloat(TYPE *type);
PUBLIC int sizeoftype(TYPE *type);
PUBLIC EXPR *mkintconst(EVAL *eval, int value);
PUBLIC EXPR *mkstring(EVAL *eval, char *value);
PUBLIC EXPR *mkfloatconst(EVAL *eval, double value);
PUBLIC void recover(EVAL *eval);
PUBLIC EXPR *mkcond(EVAL *eval, EXPR *expr1, EXPR *expr2, EXPR *expr3);
PUBLIC EXPR *mkbinary(EVAL *eval, TOKEN op, EXPR *expr1, EXPR *expr2);
PUBLIC EXPR *mkunary(EVAL *eval, TOKEN op, EXPR *expr);
d1062 1
a1062 1
PUBLIC EXPR *mkexprlist(EVAL *eval, EXPR *expr1, EXPR *expr2);
d1067 1
a1067 1
PUBLIC EXPR *mkexprlist(EXPR *expr1, EXPR *expr2);
d1069 17
a1085 17
PUBLIC EXPR *mkfieldref(EVAL *eval, TOKEN op, EXPR *expr, char *name);
PUBLIC EXPR *mkidentifier(ENTRY *entry);
PUBLIC EXPR *mkcast(EVAL *eval, TYPE *type, EXPR *expr);
PUBLIC int strideofexpr(EXPR *expr);
PUBLIC BOOL isfunction(TYPE *type);
PUBLIC void semerr(EVAL *eval, char *format, ...);
PUBLIC BOOL isunsigned(TYPE *type);
PUBLIC BOOL isstring(TYPE *type);
PUBLIC BOOL isaggregate(TYPE *type);
PUBLIC char *expandcmd(INTERP *interp, char *buf, char *cmd, uword bufsiz);
PUBLIC void tidyup(void);
PUBLIC void initmem(BOOL memchecking);
PUBLIC EVAL *neweval(DEBUG *debug);
PUBLIC TABLE *newtable(void);
PUBLIC BOOL readcode(DEBUG *debug);
PUBLIC void remeval(EVAL *eval);
PUBLIC void putwatchpoint(WATCHPOINT *watchpoint, DEBUG *debug);
d1088 1
a1088 1
PUBLIC void tagerr(EVAL *eval, char *format, ...);/* CR: nearly the same as semerr */
d1091 1
a1091 1
PUBLIC int actualisewatchpoints(DEBUG *, word , int , word );/* CR: for notifywp */
d1095 1
a1095 1
PUBLIC int actualisewatchpoints(DEBUG *, word , int , word , UWORD *);
d1097 1
a1097 1
PUBLIC WATCHPOINT *addwatchpoint(DEBUG *, char *, void *, int, char *, FORMAT, BOOL, BLOCK *);
d1100 1
a1100 1
PUBLIC int num_watch_elements (WATCHPOINT *, DEBUG *) ;
@


1.3
log
@Related to Bug 677 - define the name of the environment variable that is
used to define the directory in which the source and .dbg files can be
located (currently, this is DBGSRC)
@
text
@d21 1
a21 1
* $Header: /hsrc/cmds/debugger/RCS/tla.h,v 1.2 1991/08/19 10:13:07 craig Exp $
d515 1
a515 1
PUBLIC char *popword(INTERP *, char *);
d905 1
a905 1
#define WordMax	255
d1013 1
a1013 1
PUBLIC char *expandcmd(INTERP *interp, char *buf, char *cmd);
@


1.2
log
@Changes to Copyright comment
@
text
@d21 1
a21 1
* $Header: $
d1043 13
@


1.1
log
@Initial revision
@
text
@a13 1
*	  (c) Copyright 1990, Parsytec GmBh
@
