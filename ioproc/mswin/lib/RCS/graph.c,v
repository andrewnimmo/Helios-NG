head	1.4;
access;
symbols
	Helios_1_3_1:1.4
	Helios_C40_1_3_Official_Release:1.4;
locks; strict;
comment	@ * @;


1.4
date	93.04.27.17.06.28;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	92.10.16.08.44.00;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	92.10.15.15.07.36;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	92.07.09.14.55.13;	author craig;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The code to install event handlers was rather original. See the log for
startws.c for further details.
@
text
@/****************************************************************************/
/****************************************************************************/
/***									  ***/
/***		     Helios Graphics for MS-WINDOWS I/O Server		  ***/
/***		     =========================================		  ***/
/***									  ***/
/***		       Copyright (c) 1990,  CSIR - MIKOMTEK		  ***/
/***			  All Rights Reserved.				  ***/
/***									  ***/
/***  graph.c								  ***/
/***									  ***/
/***	This file contains the source code of the graphics library.	  ***/
/***	Most of the definitions may be found in the file graphlib.h.	  ***/
/***									  ***/
/***  Author  :  S.A. Wilson.						  ***/
/***									  ***/
/***  Date    :  March 1990.						  ***/
/***									  ***/
/****************************************************************************/
/****************************************************************************/



#include <attrib.h>
#include <stdarg.h>
#include <stdio.h>
#include <codes.h>
#include <string.h>
#include <nonansi.h>
#include <helios.h>
#include <ioevents.h>
#include "graphlib.h"

/* private protocol messages to MSWIN server */

#define FG_EnableMouse      FG_PrivateFirst
#define FG_EnableMSEvents   (FG_PrivateFirst + 0x10)
#define FG_RegisterWindow   (FG_PrivateFirst + 0x20)
#define FG_DeregisterWindow (FG_PrivateFirst + 0x30)
#define FG_DisableMouse     (FG_PrivateFirst + 0x40)

#define Mouse_Limit       64
#define Event_MSMouse     0x40L
#define Event_MSEvents    0x80L
#define MSMouse_EventSize (sizeof(IOEventHdr) + sizeof(MSMouse_Event))
#define MSEvent_EventSize (sizeof(IOEventHdr) + sizeof(MSEvent))

typedef struct MSMouse_Event {
   SHORT X;
   SHORT Y;
   WORD  Buttons;
   word  WinID;
} MSMouse_Event;

typedef struct MSEvent {
   SHORT Type;      /* the msevent type  */
   SHORT WinID;     /* the window ID     */
   word  Word1;     /* two words of data */
   word  Word2;
} MSEvent;



static Semaphore sem;
static word  control_vector[max_words + 1],  /* control vector for MCB */
	     MaxX,		    /* max width of graphics screen	    */
	     MaxY,		    /* max height of graphics screen	    */
	     buf_size,		    /* size of message buffer on I/O server */
	     CaptionSize,
	     MenuSize,
	     SwapButton,
	     ResizeFrameX,
	     ResizeFrameY,
	     BorderFrameX,
	     BorderFrameY;
	     
static BYTE *data_vector;	    /* data vector for MCB		    */
static unsigned short data_size;    /* size of data vector in MCB	    */
static word control_size,	    /* size of control vector in MCB	    */
	   last_command;	    /* last graphic command issued	    */
static word Timeout;		    /* timeout before data sent fails	    */
static MCB  mcb;	 	    /* Message Control Block 		    */

static int initialised = 0, graphics_availiable = 0;

static int    print_jobs = 0;
static Stream *active_graph = (Stream *) NULL;	/* Id active graphic window */
static Stream *MSWin_Server;        /* stream to mouse/windows servers */
static int    mouse_available = 0;
static int    msevent_available = 0;


GraphNode   Graph_List;   /* Head of the list of open graphic windows */


int	    add_to_list(word , Stream *, BYTE *, BYTE *);
GraphNode   *valid_stream(Stream *);
void        HandleMouseEvents(Port, VoidFnPtr);
void        HandleMSEvents(Port, VoidFnPtr);


/**************************************************************************/
/*  Reset_All								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Clears the first word of the control vector, which   */
/*		     is used when buffering commands. Resets data and	  */
/*		     control vector sizes.				  */
/*									  */
/*		     Normally called after a send_message call. 	  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/

void Reset_All(void)
{
   control_vector[0] = (word) 0;
   data_size	     = 0;
   control_size      = 0;
}



/**************************************************************************/
/*  InitGraphics							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Initialises the graphics library. Allocates	  */
/*		     "buf_size" bytes for a message buffer. Does an	  */
/*		     ObjectInfo on the graphics server, to get the screen */
/*		     device dimensions. Sets "initialised" flag and	  */
/*		     "graphics_availiable" flag if successful.		  */
/*									  */
/*		     Normally called by user.				  */
/*									  */
/*    Returns	  :  1 if library initialised, 0 if intialise fails.	  */
/*									  */
/**************************************************************************/


int InitGraphics(MouseFn, MSEventFn)
   VoidFnPtr MouseFn, MSEventFn;
{
   Object   *graph_obj;   /* Info returned by Locate.		       */
   DeviceInfo *GrphInfo;	/* Structure for info returned by ObjectInfo */

   initialised = 1;    /* set initialised flag */
   Graph_List.next     = (GraphNode *) NULL;  /* initialise list of open */
   Graph_List.graph_id = (Stream *) NULL;     /* graphics windows	 */
   Timeout = OneSec * 60;

   graph_obj   = Locate(NULL, "/graphics");

   if (graph_obj != (Object *) NULL) graphics_availiable = 1;
     else
	graphics_availiable = 0;

	  /* allocate a temporary data vector */
   data_vector = (BYTE *) Malloc(sizeof(DeviceInfo));
   if (data_vector == (BYTE *) NULL) graphics_availiable = 0;


   if (graphics_availiable) {
     if (ObjectInfo(graph_obj, "/graphics", data_vector) != 0L) {
	Free(data_vector);
	graphics_availiable = 0;
     }
     else {
	GrphInfo = (DeviceInfo *) data_vector;
	MaxX	 = GrphInfo->info[0];	  /* Screen device width  */
	MaxY	 = GrphInfo->info[1];	  /* Screen device height */
	buf_size = GrphInfo->info[2];	  /* size of buffer on PC */
	CaptionSize = GrphInfo->info[3];
	MenuSize = GrphInfo->info[4];
	SwapButton = GrphInfo->info[5];
	ResizeFrameX = GrphInfo->info[6];
	ResizeFrameY = GrphInfo->info[7];
	BorderFrameX = GrphInfo->info[8];
	BorderFrameY = GrphInfo->info[9];
     	Reset_All();
     }
   }

   if (graphics_availiable) {
     Free(data_vector);    /* Free temp data vector */
				  /* Allocate data vector */
     data_vector = (BYTE *) Malloc(buf_size * sizeof(BYTE));
     if (data_vector == (BYTE *) NULL) graphics_availiable = 0;
   }

   Close(graph_obj);
   InitSemaphore(&sem, 1);
   
   /* now open stream to MSWIN server and activate mouse and msevents */
   if ((MouseFn != (VoidFnPtr)NULL) || (MSEventFn != (VoidFnPtr)NULL)) {
      Object *file;
      Object *MSWIN = Locate(NULL, "/MSWIN");
      char applic[15];
      word Control[1];
      int i;
      MCB m;
      
      if (MSWIN == (Object *)NULL) {
         mouse_available = 0;
         msevent_available = 0;
         return(graphics_availiable);
      }
      
      /* get unique name */
      i = 1;
      for (i=1; ; i++) {
         sprintf(applic, "winapp.%d", i);
         file = Locate(MSWIN, applic);
         if (file == (Object *)NULL)  break;
         Close(file);
      }

      MSWin_Server = Open(MSWIN, applic, O_ReadWrite | O_Create);
      if (MSWin_Server == (Stream *)NULL) {
         mouse_available = 0;
         msevent_available = 0;
         Close(MSWIN);
         return(graphics_availiable);
      }
      Close(MSWIN);
      
      /* now we have a stream, we can boot the mouse handler */
      if (MouseFn != (VoidFnPtr)NULL) {
	 Port	event_port	= NewPort();
	
         /* now send the message to enable the mouse */
         InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
                 event_port, FG_EnableMouse);
         m.Control = &(Control[0]);
         Control[0] = 0xffffffff;
         m.MsgHdr.ContSize = 1;
         m.Timeout = 5 * OneSec;
      
         if (PutMsg(&m) >= Err_Null) {
            m.MsgHdr.Dest	= event_port;
            m.Timeout		= 20 * OneSec;
            if ((GetMsg(&m) >= Err_Null) &&
                 Fork(2000, HandleMouseEvents, sizeof(Port)+sizeof(VoidFnPtr), event_port, MouseFn))
            	mouse_available = 1;
         }
         unless (mouse_available) FreePort(event_port);
      }

      /* now send a message to enable msevents */         
      if (MSEventFn != (VoidFnPtr)NULL) {
	Port	event_port	= NewPort();
	
         /* now send the message to enable the msevents */
         InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
                 event_port, FG_EnableMSEvents);
         m.Control = Control;
         Control[0] = 0xffffffff;
         m.MsgHdr.ContSize = 1;
         m.Timeout = 5 * OneSec;
      
         if (PutMsg(&m) >= Err_Null) {
            m.MsgHdr.Dest	= event_port;
            m.Timeout		= 20 * OneSec;
            if ((GetMsg(&m) >= Err_Null) &&
            	 Fork(2000, HandleMSEvents, sizeof(Port)+sizeof(VoidFnPtr), 
                       event_port, MSEventFn))
            	msevent_available	= 1;
         }
         unless(msevent_available) FreePort(event_port);
      }
         
   }
   return(graphics_availiable);
}


/**************************************************************************/
/*  Init_Graph_Attributes						  */
/*									  */
/*    Parameters  :  graph_node 					  */
/*			  Pointer to a node in the open window list.	  */
/*									  */
/*    Function	  :  Fills in the default line, background, text, fill	  */
/*		     and mapping attributes for each graphic window	  */
/*		     opened.						  */
/*									  */
/*		     Called by "add_to_list".				  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/



void Init_Graph_Attributes(graph_node)
   GraphNode *graph_node;
{
   /* first do the line attributes */

   graph_node->line_attr.color	       = BLACK;
   graph_node->line_attr.color_changed = 0;
   graph_node->line_attr.style	       = SOLID;
   graph_node->line_attr.style_changed = 0;
   graph_node->line_attr.width	       = 1;
   graph_node->line_attr.width_changed = 0;

   /* Then do the background attributes */

   graph_node->BKground.color	  = WHITE;
   graph_node->BKground.mode	  = OPAQUE;

   /* then do the fill attributes */

   graph_node->fill_attr.color     = WHITE;
   graph_node->fill_attr.style	   = SOLID;
   graph_node->fill_attr.mode	   = ALTERNATE;

   /* then do the text attributes */

   graph_node->text_attr.color	   = BLACK;
   graph_node->text_attr.align	   = LEFT;
   graph_node->text_attr.spacing   = 0;

  /* Finally do the screen mapping attributes */

   graph_node->map_attr.mode	       = M_TEXT;
   graph_node->map_attr.window_org[0]  = 0;
   graph_node->map_attr.window_org[1]  = 0;
   graph_node->map_attr.viewprt_org[0] = 0;
   graph_node->map_attr.viewprt_org[1] = 0;
   graph_node->map_attr.window_ext[0]  = 1;
   graph_node->map_attr.window_ext[1]  = 1;
   graph_node->map_attr.viewprt_ext[0] = 1;
   graph_node->map_attr.viewprt_ext[1] = 1;
}


/**************************************************************************/
/*  add_to_list 							  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			  Id of an open graphic window. 		  */
/*									  */
/*		     graph_name 					  */
/*			  Unique name of the open graphic window.	  */
/*									  */
/*		     info						  */
/*			  Information pertaining to the graphic device	  */
/*			  being opened, ie. screen or printer.		  */
/*									  */
/*    Function	  :  Creates a "GraphNode", fills in the structure, and   */
/*		     adds the "GraphNode" to the end of the list of	  */
/*		     open graphic windows.				  */
/*									  */
/*		     Called by "OpenGraph".				  */
/*									  */
/*    Returns	  :  1 if the "GraphNode" is added, 0 if not.		  */
/*									  */
/**************************************************************************/


int
add_to_list(
	    word      id_no,
	    Stream *  graph_stream,
	    BYTE *    graph_name,
	    BYTE *    info )
{
   GraphNode  *last_node = &Graph_List, *new_node;
   DeviceInfo *GrphInfo  = (DeviceInfo *) &info[0];
   int	      ct;

      /* Find the end of the list of open graph windows */
   for (;last_node->next != (GraphNode *) NULL; last_node = last_node->next);

   new_node = (GraphNode *) Malloc(sizeof(GraphNode));
   if (new_node == (GraphNode *) NULL) return(0);
   last_node->next    = new_node;	      /* Fill in GraphNode	   */
   new_node->next     = (GraphNode *) NULL;   /* structure and add node to */
   new_node->graph_id = graph_stream;	      /* the end of the list	   */
   new_node->WinID    = (word)id_no;
   strcpy(new_node->Name, graph_name);
   Init_Graph_Attributes(new_node);	      /* Initailise graph attr.    */
   for (ct = 0; ct < 18; ct++)
      new_node->info[ct] = GrphInfo->info[ct];
   return(1);
}


/**************************************************************************/
/*  del_from_list							  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			  Id of an open graphic window. 		  */
/*									  */
/*    Function	  :  Deletes the "GraphNode" containing the id defined	  */
/*		     by "graph_stream", from the list of open graphic	  */
/*		     windows.						  */
/*									  */
/*		     Called by "CloseGraph".				  */
/*									  */
/*    Returns	  :  The id of the open graphic window, prior to the	  */
/*		     window just removed, in the list of open graphic	  */
/*		     windows. May be NULL if only "GraphNode" left is the */
/*		     head of the list of open graphic windows.		  */
/*									  */
/**************************************************************************/



Stream *del_from_list(graph_stream)
   Stream *graph_stream;
{
   GraphNode *last_node = &Graph_List, *prev_node = last_node;

	/* Search for the correct GraphNode */
   for (;(last_node->graph_id != graph_stream) &&
	 (last_node != (GraphNode *) NULL); ) {
      prev_node = last_node;
      last_node = last_node->next;
   }
   if (last_node == (GraphNode *) NULL) return(0);	/* graph not found */
   prev_node->next = last_node->next;  /* remove node from list */
   Free(last_node);   /*free memory used to hold graph node */
   if (prev_node->graph_id == (Stream *) NULL) {
     if (prev_node->next != (GraphNode *) NULL)   /* Get next valid graph */
	prev_node = prev_node->next;		  /* id.		  */
   }
   return(prev_node->graph_id);
}


/**************************************************************************/
/*  valid_stream							  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			  Id of an open graphic window. 		  */
/*									  */
/*    Function	  :  Checks to see that the graphic window id,		  */
/*		     "graph_stream", is valid.				  */
/*									  */
/*		     Normally called by each graphics function. 	  */
/*									  */
/*    Returns	  :  The "GraphNode" in the list of open graphic windows  */
/*		     containing the id, "graph_stream". 		  */
/*									  */
/**************************************************************************/

GraphNode *valid_stream(graph_stream)
   Stream *graph_stream;
{
   GraphNode *next_node;

   if (!graphics_availiable) return((GraphNode *) NULL);

   if (graph_stream == (Stream *) NULL) return((GraphNode *) NULL);

       /* Search for the node containing "graph_stream" */
   for (next_node = Graph_List.next; next_node != (GraphNode *) NULL;
	next_node = next_node->next)
     if (next_node->graph_id == graph_stream) return(next_node);

   return((GraphNode *) NULL);
}


/**************************************************************************/
/*  send_message							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Sends a message to the graphics server.		  */
/*									  */
/*		     Normally called by non-buffered graphics functions,  */
/*		     or by "buffer_command".				  */
/*									  */
/*    Returns	  :  1 if the messsage was successfully sent, 0 if the	  */
/*		     message failed to be sent. 			  */
/*									  */
/**************************************************************************/


int send_message()
{

   if (active_graph == (Stream *) NULL) return(1);  /* Don't send bogus */
   if (last_command < 0) return(1);		    /* messages.	*/
   if ((control_size < 1) && (data_size < 1)) return(1);
      /* Dont send messages to dummy printer streams */
   if ((active_graph->Server == 0L) && (active_graph->Reply == 0L)) return(1);

	    /* "last_command" contains the actual graphics function number */
   InitMCB(&mcb, MsgHdr_Flags_preserve, active_graph->Server,
	   active_graph->Reply, Graph_Message | last_command);

   mcb.Timeout	       = Timeout;	   /* 1 minute */
   mcb.Control	       = (WORD *) &control_vector[0];
   mcb.MsgHdr.ContSize = (unsigned char) control_size;
   mcb.Data	       = data_vector;
   mcb.MsgHdr.DataSize = data_size;

   if (PutMsg(&mcb) != Err_Null) return(0);    /* send message */

   mcb.MsgHdr.Dest = active_graph->Reply;
   if (GetMsg(&mcb) != Err_Null) return(0);    /* get reply */

   if (mcb.MsgHdr.FnRc != 0) return(0);        /* error code? */
   return(1);
}


/**************************************************************************/
/*  buffer_command							  */
/*									  */
/*    Parameters  :  no_params						  */
/*			 The no. of parameters in the command.		  */
/*		     params						  */
/*			 A pointer to the parameters of the command.	  */
/*									  */
/*    Function	  :  Buffers the command represented by the command no.   */
/*		     in "last_command". If the buffer overflows during	  */
/*		     the buffering operation, the buffer is flushed.	  */
/*		     The number of commands buffered in the buffer is	  */
/*		     reflected in "control_vector[0]".                    */
/*									  */
/*		     Called by graphic functions that employ buffering.   */
/*									  */
/*    Returns	  :  1 if the messsage was buffered successfully, 0 if	  */
/*		     buffering operation failed.			  */
/*									  */
/**************************************************************************/


int
buffer_command(
	       word 	no_params,
	       word *	params )
{
   int	 ret_code = 1, count;
   word *data = (word *) data_vector;

   if ((data_size + (no_params * sizeof(word))) >= buf_size) {
      ret_code = send_message();    /* flush buffer if it is going to */
      Reset_All();		    /* overflow.		      */
   }

   control_size = 1;
   control_vector[0]++;
   for (count = 0; count < no_params; count++) {       /* add command to */
      data[data_size / sizeof(word)] = params[count];  /* buffer.	 */
      data_size += sizeof(word);
   }

   return(ret_code);
}


/**************************************************************************/
/*  check_last_command							  */
/*									  */
/*    Parameters  :  graph						  */
/*			 Id of an open graphic window.			  */
/*		     cmd_no						  */
/*			 The graphics function's command number.          */
/*									  */
/*    Function	  :  Checks that the last graphics command issued is the  */
/*		     same as that represented by "cmd_no", and that the   */
/*		     last command was issued for the graphic window	  */
/*		     identified by "graph".				  */
/*									  */
/*		     Called by all graphic functions.			  */
/*									  */
/*    Returns	  :  1 if the messsage was buffered successfully, 0 if	  */
/*		     buffering operation failed.			  */
/*									  */
/**************************************************************************/


word
check_last_command(
		   Stream * graph,
		   word	    cmd_no )
{
   int ret_code = 1;

   if (graph != active_graph) {
      ret_code = send_message();   /* new command to be issued to a	*/
      Reset_All();		   /* different window, so flush buffer */
      active_graph = graph;	   /* of previous window.		*/
      last_command = cmd_no;
   }
   else {
     if (last_command != cmd_no) {    /* graphics command being issued	*/
	ret_code = send_message();    /* differs from previous command	*/
	Reset_All();		      /* so flush buffer containing	*/
	last_command = cmd_no;	      /* previous commands.		*/
     }
   }

   return(ret_code);
}


/**************************************************************************/
/*  get_valid_graph_name						  */
/*									  */
/*    Parameters  :  temp						  */
/*			 Returns a unique name for a graphic window.	  */
/*									  */
/*    Function	  :  Generates a name for a graphic window, using "Graph" */
/*		     as a name, and generating a unique extension for the */
/*		     name. (i.e. Graph.xxx where xxx is a unique number)  */
/*		     A Locate is done on each name generated, until a	  */
/*		     non-exisiting name is found.			  */
/*									  */
/*		     Called by OpenGraph.				  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/


word get_valid_graph_name(temp)
   char *temp;
{
   Object *new_file = Locate(NULL, "/graphics");   /* find graphics server */
   char    path_name[40];
   int     num_graphs;

   for (num_graphs = 1; new_file != (Object *) NULL; num_graphs++) {
      sprintf(temp, "%s.%d","Graph", num_graphs);   /* Unique name? */
      path_name[0] = '\0';
      strcpy(&(path_name[0]), "/graphics/");   /* set up path name for	    */
      strcat(path_name, temp);		       /* Locate.		    */
      new_file = Locate(NULL, path_name);      /* Does generated name exist */
   }
   return(num_graphs);
}


/**************************************************************************/
/*  GetMaxX								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  Width of the screen device. eg. for VGA = 640	  */
/*									  */
/**************************************************************************/


word GetMaxX()
{
   return(MaxX)	;
}


/**************************************************************************/
/*  GetMaxY								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of the screen device. eg. for VGA = 480	  */
/*									  */
/**************************************************************************/


word GetMaxY()
{
   return(MaxY);
}      


/**************************************************************************/
/*  GetCaptionSize							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of the caption bar				  */
/*									  */
/**************************************************************************/


word GetCaptionSize()
{
   return(CaptionSize);
}      


/**************************************************************************/
/*  GetMenuSize								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of the menu bar				  */
/*									  */
/**************************************************************************/


word GetMenuSize()
{
   return(MenuSize);
}      


/**************************************************************************/
/*  GetSwapButton							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  true or false indicating whether the mouse buttons   */
/*                   should be swapped					  */
/*									  */
/**************************************************************************/


word GetSwapButton()
{
   return(SwapButton);
}      


/**************************************************************************/
/*  GetResizeFrameX							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  width of resizable frame border 			  */
/*									  */
/**************************************************************************/


word GetResizeFrameX()
{
   return(ResizeFrameX);
}      


/**************************************************************************/
/*  GetResizeFrameY							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of the resizable frame border		  */
/*									  */
/**************************************************************************/


word GetResizeFrameY()
{
   return(ResizeFrameY);
}      


/**************************************************************************/
/*  GetBorderFrameX							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  width of non-resizable border			  */
/*									  */
/**************************************************************************/


word GetBorderFrameX()
{
   return(BorderFrameX);
}      


/**************************************************************************/
/*  GetBorderFrameY							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of non-resizable border			  */
/*									  */
/**************************************************************************/


word GetBorderFrameY()
{
   return(BorderFrameY);
}      


/**************************************************************************/
/*  FLUSH								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Flushes the graphics buffer.			  */
/*									  */
/*		     Called by User, or whenever buffer needs to be	  */
/*		     flushed.						  */
/*									  */
/*    Returns	  :  1 if buffer successfully flushed, 0 if not.	  */
/*									  */
/**************************************************************************/


int FLUSH()
{
   int ret_val;

   if ((control_size < 1) && (data_size < 1)) {
      Reset_All();     /* No data in buffer, so just reset */
      return(1);
   }

   ret_val = send_message();   /* flush buffer */
   Reset_All(); 	       /* reset        */
   return(ret_val);
}

/**************************************************************************/
/*   EnableMouse		Internal to Helios                        */
/**************************************************************************/

int EnableMouse(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);
   MCB m;
   word Control[1];
      
   if (!mouse_available)   return(FALSE);

   if (graph_node == (GraphNode *)NULL)   return(FALSE);
      
   /* now send the message to the handler to enable the mouse */
   InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
               MSWin_Server->Reply, FG_EnableMouse);
   m.Control = Control;
   Control[0] = graph_node->WinID;
   m.MsgHdr.ContSize = 1;
   m.Timeout = OneSec*5;  /* five seconds for the server to respond */
      
   if (PutMsg(&m) != EK_Timeout)
      return(TRUE);
   else
      return(FALSE);
}

/**************************************************************************/
/*   DisableMouse		Internal to Helios                        */
/**************************************************************************/

int DisableMouse(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   MCB m;
   word Control[1];
   
   if (!mouse_available)   return(FALSE);

   if (graph_node == (GraphNode *) NULL) return(FALSE);

   /* now send the message to the handler to disable the mouse */
   InitMCB(&m, 0, MSWin_Server->Server, NullPort, FG_DisableMouse);
   m.Timeout = OneSec*5;  /* five seconds for the server to respond */
   m.Control = Control;
   m.MsgHdr.ContSize = 1;
   Control[0] = graph_node->WinID;
   m.Timeout = OneSec*5;
      
   if (PutMsg(&m) != EK_Timeout)
      return(TRUE);
   else
      return(FALSE);
}

/**************************************************************************/
/*   HandleMouseEvents		Internal to Helios                        */
/**************************************************************************/

void HandleMouseEvents(port, fn)
   Port port;
   VoidFnPtr fn;
{
   IOEvent Buffer;
   IOEvent *event = (IOEvent *)&(Buffer);
   MSMouse_Event *mouse = (MSMouse_Event *)&(event->Device.Mouse);
   MCB m;
word e;

   forever {
      InitMCB(&m, MsgHdr_Flags_preserve, port, NullPort, 0);
      m.Data = (char *)&(Buffer);
      m.Timeout = OneSec * 1800;   /* stream timeout */
      if ((e = GetMsg(&m)) == Err_Null) {
         /* data received - call function */
         if (fn != (VoidFnPtr)NULL)
            fn(mouse->WinID, mouse->X, mouse->Y, mouse->Buttons);
      }
   }
}

int MSMouseSupported(void)
{
   int ret_val = mouse_available;
   return(ret_val);
}


/**************************************************************************/
/*   HandleMSEvents		Internal to Helios                        */
/**************************************************************************/

void HandleMSEvents(port, fn)
   Port port;
   VoidFnPtr fn;
{
   IOEvent Buffer;
   IOEvent *event = (IOEvent *)&(Buffer);
   MSEvent *msevents = (MSEvent *)&(event->Device.Mouse);
   MCB m;

   forever {
      InitMCB(&m, MsgHdr_Flags_preserve, port, NullPort, 0);
      m.Data = (char *)&(Buffer);
      m.Timeout = OneSec * 1800;   /* stream timeout */
            
      if (GetMsg(&m) == Err_Null) {
         /* data received - call function */
         if (fn != (VoidFnPtr)NULL)
            fn(msevents->Type, msevents->WinID, msevents->Word1, msevents->Word2);
      }
   }
}


int MSEventSupported(void)
{
   int ret_val = msevent_available;
   return(ret_val);
}


/**************************************************************************/
/*  OpenGraph					Command number = 0	  */
/*									  */
/*    Parameters  :  graph_name 					  */
/*			Caption for the graphic window			  */
/*		     xstart, ystart					  */
/*			Position of top left hand corner of window	  */
/*		     width						  */
/*			Width of window.				  */
/*		     height						  */
/*			Height of window.				  */
/*		     border						  */
/*			Type of border surrounding window		  */
/*									  */
/*    Function	  :  Opens a graphic window.				  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  A pointer uniquely identifying the window if the	  */
/*		     window was opened successfully. A NULL pointer if	  */
/*		     the window failed to open. 			  */
/*									  */
/**************************************************************************/


Stream *OpenGraph(graph_name, xstart, ystart, width, height, border, show_mode)
   BYTE *graph_name;
   word  xstart, ystart, width, height, border, show_mode;
{
   Object     *graph_obj;	/* Object structure for the graphics server */
   Stream     *graph_stream;	/* To hold unique id of graphic window	    */
   BYTE       temp[15]; 	/* To hold the unique window name	    */
   word        id_no;            /* the id number of the current window      */
   MCB        m;                /* to send data to MSWIN server             */
   word       Control[1];       /* control buffer			    */

   if (!initialised) return((Stream *)NULL);

   if (!graphics_availiable) return((Stream *) NULL);

   Wait(&sem);

   FLUSH();  /* Flush buffer of previous window */

   id_no = get_valid_graph_name(&(temp[0]));  /* generate unique window name */

   graph_obj = Locate(NULL, "/graphics");    /* find graphics server */
   if (graph_obj == (Object *) NULL) {
      Signal(&sem);
      return((Stream *) NULL);
   }

	/* Open a stream for accessing the window */
   graph_stream = Open(graph_obj, temp, O_ReadWrite | O_Create);
   if (graph_stream == (Stream *) NULL) {
      Close(graph_obj);
      Signal(&sem);
      return((Stream *) NULL);
   }

/* Now get information pertaining to the window just opened! */

   if (ObjectInfo(graph_obj, temp, data_vector) != Err_Null) {
      Close(graph_obj);
      Close(graph_stream);
      Signal(&sem);
      return((Stream *) NULL);
   }

   Close(graph_obj);

		 /* Add new window to list of open graphic windows */
   if (!add_to_list(id_no, graph_stream, temp, data_vector)) {
      Close(graph_stream);
      Signal(&sem);
      return((Stream *) NULL);
   }

   if (graph_name == (BYTE *) NULL)
     data_size = 0;
   else {
     data_size = strlen(graph_name) + 1;	      /* set up data vector */
     data_vector[0] = '\0';
     strcpy(data_vector, graph_name);
     data_vector[strlen(graph_name)] = '\0';
   }

			   /* set up control vector */
   control_vector[0] = border;   control_vector[1] = xstart;
   control_vector[2] = ystart;	 control_vector[3] = width;
   control_vector[4] = height;	 control_vector[5] = show_mode;
   control_vector[6] = id_no;
   
   control_size = 7;
   last_command = 0;

   active_graph = graph_stream;

   if (!send_message()) {	    /* tell graphic server to open window */
     del_from_list(graph_stream);
     Close(graph_stream);
     Signal(&sem);
     return((Stream *) NULL);
   }

   Reset_All();
  
   if (msevent_available) {
      /* now register the window with the MSWIN server */
      InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
              MSWin_Server->Reply, FG_RegisterWindow);
      m.Control = Control;
      m.MsgHdr.ContSize = 1;
      Control[0] = id_no;
      PutMsg(&m);
   }
  
   Signal(&sem);
   return(graph_stream);
}

/**************************************************************************/
/*  GraphID								  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			Id of window					  */
/*									  */
/*    Function	  :  returns ID word for testing in MSEvents handler	  */
/*									  */
/*    Returns	  :  ID number (word)					  */
/*									  */
/**************************************************************************/

word GraphID(graph_stream)
   Stream *graph_stream;
{
   GraphNode   *graph = valid_stream(graph_stream);  /* Id valid? */
   return( graph->WinID );
}


/**************************************************************************/
/*  CloseGraph								  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			Id of window to be closed.			  */
/*									  */
/*    Function	  :  Closes a graphic window				  */
/*									  */
/*		     Called by User, or "TidyGraphics". 		  */
/*									  */
/*    Returns	  :  1 if window closed, 0 if not.			  */
/*									  */
/**************************************************************************/


int CloseGraph(graph_stream)
   Stream *graph_stream;
{
   GraphNode   *graph = valid_stream(graph_stream);  /* Id valid? */
   BYTE   *graph_name;	    /* To hold unique window name */
   Object *graph_obj;	    /* Object structure for graphics server */
   word   Control[1];

   if (graph == (GraphNode *) NULL) return(0);
    /* Are we closing a printer stream? */
   if ((graph_stream->Server == 0L) && (graph_stream->Reply == 0L)) {
     active_graph = del_from_list(graph_stream);
     return(1);
   }
   
	 /* If any outstanding commands in buffer, flush buffer */
   Wait(&sem);
   if ((control_size > 0) || (data_size > 0)) send_message();
   graph_name = graph->Name;
   if (mouse_available)
      DisableMouse(graph_stream);
   if (msevent_available) {
      MCB m;
      InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
              MSWin_Server->Reply, FG_DeregisterWindow);
      m.Control = Control;
      m.MsgHdr.ContSize = 1;
      Control[0] = graph->WinID;
      PutMsg(&m);
   }
      
      
   if ((Close(graph_stream)) != 0) {
      Signal(&sem);
      return(0);	/* Close stream to window */
   }

   graph_obj = Locate(NULL, "/graphics");
   if (graph_obj == (Object *) NULL) {
      Signal(&sem);
      return(0);
   }
   if ((Delete(graph_obj, graph_name)) != 0) {
      Signal(&sem);
      return(0);  /* Close window */
   }
   active_graph = del_from_list(graph_stream);	 /* Remove window from list */
   Signal(&sem);
   return(1);					 /* of open graphic windows */
}


/**************************************************************************/
/*  TidyGraphics							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Closes all open graphic windows, and frees space	  */
/*		     taken up by graphics buffer.			  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  1 if successful, 0 if not. 			  */
/*									  */
/**************************************************************************/


int TidyGraphics()
{
  GraphNode *curr_node = Graph_List.next, *next_node;

  if (curr_node == (GraphNode *) NULL) return(1);

     /* Go through list of open graphic windows, and close them */

  for (next_node = curr_node->next; next_node != (GraphNode *) NULL;
       next_node = next_node->next) {
     if (!CloseGraph(curr_node->graph_id)) return(0);
     curr_node = next_node;
  }
  if (!CloseGraph(curr_node->graph_id)) return(0);
  
  Close(MSWin_Server);
  
  Free(data_vector);   /* free space used by graphics buffer */
  return(1);
}


/**************************************************************************/
/*									  */
/*   The vast majority of the functions hereafter, provide the interface  */
/*   between the user issuing graphic commands on the transputer, and	  */
/*   graphics server, implementing the commands.			  */
/*									  */
/*   The functions providing the interface between transputer and server  */
/*   all check to see that the ID of the window they are accessing, is	  */
/*   valid, by calling "valid_stream".					  */
/*									  */
/*   Each function has a unique command number, which is interpreted on   */
/*   server side. Each function does a "check_last_command" call, to	  */
/*   ensure that previously buffered calls are sent before their call is  */
/*   implemented.							  */
/*									  */
/*   Apart from the common ground mentioned above, the function fall into */
/*   two groups, Buffered and Non-buffered functions.			  */
/*									  */
/*   For buffered commands, the structure of the command is set up, i.e.  */
/*   the parameters neccessary to implement the command. The function	  */
/*   will then issue a "buffer_command" call to buffer the command.	  */
/*   Messages are not sent to the server by these commands.		  */
/*									  */
/*   For the non-buffered commands, messages are explicitly sent to the   */
/*   the server, by the function. So the message structure has to be	  */
/*   filled in within the function, and a "send_message" call made.	  */
/*									  */
/*   For the functions providing the interface between transputer and	  */
/*   server, consult the Helios Graphics under MS-WINDOWS Users Manual	  */
/*   for details of the functions of these commands, and the role of the  */
/*   parameters passed to them. 					  */
/*									  */
/**************************************************************************/


/**************************************************************************/
/*   PutPixel	      Command Number = 1				  */
/**************************************************************************/

int PutPixel(graph_stream, x, y, color)
   Stream *graph_stream;
   word   x, y, color;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      params[3];

   if (graph_node == (GraphNode *) NULL) return(0);
   Wait(&sem);
   if (!check_last_command(graph_stream, 1)) {
      Signal(&sem);
      return(0);
   }
   
   params[0] = x;			  /* set up parameters */
   params[1] = y;
   params[2] = color;

   if (!buffer_command(3, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*   MoveTo	      Command Number = 2				  */
/**************************************************************************/

int MoveTo(graph_stream, x, y)
   Stream *graph_stream;
   word   x, y;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 2)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = x;   control_vector[1] = y;  /* set up message */
   control_size = 2;
   data_size = 0;

   ret_val = send_message();	   /* send message to server */
   Reset_All();
   
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  check_line_attributes						  */
/*									  */
/*    Parameters  :  graph_node 					  */
/*			 A node in the list of open graphic windows	  */
/*		     params						  */
/*			 A pointer to an array of words 		  */
/*									  */
/*    Function	  :  Utility that helps to set up the parameters for	  */
/*		     the "buffer_command" call for functions dealing with */
/*		     line drawing operations, in the event of some of the */
/*		     line attributes having changed since the last call.  */
/*									  */
/*		     Normally called by buffered line drawing functions.  */
/*									  */
/*    Returns	  :  the number of parameters inserted into the parameter */
/*		     list.						  */
/*									  */
/**************************************************************************/


word check_line_attributes(graph_node, params)
   GraphNode *graph_node;
   word      *params;
{
   LineAttr *attr = &(graph_node->line_attr);
   word     ret_val;

   if (attr->color_changed || attr->style_changed || attr->width_changed) {
     params[0] = 1;
     params[1] = attr->color;	  /* line attributes have changed since last */
     params[2] = attr->style;	  /* graphics call.			     */
     params[3] = attr->width;
     ret_val = 4;		  /* added four parameters */
   }
   else {
      params[0] = 0;		  /* line attributes have not changed */
      ret_val = 1;		  /* added one parameter	      */
   }

   /* reset attributes changed flags */

   if (attr->color_changed != 0) attr->color_changed = 0;
   if (attr->style_changed != 0) attr->style_changed = 0;
   if (attr->width_changed != 0) attr->width_changed = 0;
   return(ret_val);
}

/**************************************************************************/
/*   LineTo	      Command Number = 3				  */
/**************************************************************************/


int LineTo(graph_stream, x, y)
   Stream *graph_stream;
   word   x, y;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   word      params[6], index;
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 3)) {
      Signal(&sem);
      return(0);
   }

   index = check_line_attributes(graph_node, &params[0]); /* attr. changed? */
   params[index++] = x;  params[index++] = y;
   if (!buffer_command(index, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}   	      
   		     
/**************************************************************************/
/*   DrawLine	      Command Number = 4				  */
/**************************************************************************/


int DrawLine(graph_stream, x1, y1, x2, y2)
   Stream *graph_stream;
   word   x1, y1, x2, y2;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      params[8], index;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 4)) {
      Signal(&sem);
      return(0);
   }

   index = check_line_attributes(graph_node, &params[0]);  /* attr. changed? */

   params[index++] = x1;    params[index++] = y1;
   params[index++] = x2;    params[index++] = y2;
   if (!buffer_command(index, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*   TextOut	      Command Number = 5				  */
/**************************************************************************/

int TextOut(graph_stream, x, y, line)
   Stream *graph_stream;
   word   x, y;
   BYTE   *line;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;
   BYTE      *old_vector;    /* used to save graphics buffer */
   
   if (graph_node == (GraphNode *) NULL) return(0);

/*   IOdebug( "waiting" ); */
   
   Wait(&sem);

/*   IOdebug( "checking last command" ); */
   
   if (!check_last_command(graph_stream, 5)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = x;  control_vector[1] = y;
   
   if (graph_node->text_attr.color_changed) {	 /* Text color changed */
     control_vector[2] = 1;
     control_vector[3] = graph_node->text_attr.color;
     graph_node->text_attr.color_changed = 0;
     control_size = 4;
   }
   else {
     control_vector[2] = 0;   /* text color has not changed */
     control_size = 3;
   }

/*   IOdebug( "line = %s", line ); */
   
   control_vector[control_size++] = strlen(line);  /* set up control vector */
   
   old_vector  = data_vector;	   /* save graphics buffer */
   data_vector = line;		   /* set up data vector */
   data_size   = strlen(line);

  /* IOdebug( "sending message" ); */
   
   ret_val = send_message();	  /* send message to server */

/*   IOdebug( "message sent" ); */
   
   data_vector = old_vector;	  /* restore graphics buffer */

   Reset_All();

   Signal(&sem);

   return(ret_val);
}

/**************************************************************************/
/*   Squares_Circles	       Command Number = 7			  */
/*									  */
/*   Does								  */
/*	   Rectangle	       mode = 0 				  */
/*	   Ellipse	       mode = 1 				  */
/*	   Circle	       mode = 1 				  */
/*									  */
/*   The mode field is interpreted by the graphics server.		  */
/**************************************************************************/


int Squares_Circles(graph_stream, mode, x1, y1, x2, y2)
   Stream *graph_stream;
   word   mode, x1, y1, x2, y2;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      params[9], index;
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 7)) {
      Signal(&sem);
      return(0);
   }

   index = check_line_attributes(graph_node, &params[0]); /* attr. changed? */

   params[index++] = mode;   params[index++] = x1;
   params[index++] = y1;     params[index++] = x2;
   params[index++] = y2;
   if (!buffer_command(index, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}   

/**************************************************************************/
/*   poly_functions	       Command Number = 6			  */
/*									  */
/*   Does								  */
/*	   PolyLine	       mode = 0 				  */
/*	   FillPoly	       mode = 1 				  */
/*									  */
/*   The mode field is interpreted by the graphics server.		  */
/**************************************************************************/


int poly_functions(graph_stream, num_pts, pts, mode)
   Stream *graph_stream;
   word   num_pts, *pts, mode;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      *tmp_pts, index, params[6];

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 6)) {
      Signal(&sem);
      return(0);
   }

      /* will an empty graphics buffer overflow if command implemented? */
   if (((num_pts + 8) * sizeof(word)) > buf_size) {
      Signal(&sem);
      return(0);
   }

   tmp_pts = (word *) Malloc(sizeof(word) * num_pts);
   if (tmp_pts == (word *) NULL) {
      Signal(&sem);
      return(0);
   }

   params[0] = mode;
   index = check_line_attributes(graph_node, &params[1]);  /* attr. changed? */
   params[index + 1] = num_pts;
   if ((data_size + ((index + 3 + num_pts) * sizeof(word))) > buf_size)
       FLUSH();   /* flush buffer if command causes buffer to overflow */
   if (!buffer_command(index + 2, &params[0])) {
	 Free(tmp_pts);
	 Signal(&sem);
	 return(0);
   }
   control_vector[0]--;   /* full command not yet buffered */

   /* Since points for PolyLine and FillPoly calls are only 16 bit integers */
   /* we compress two points into 1 32bit transputer word. */

   for (index = 0; index < num_pts * 2; index += 2)
     tmp_pts[index / 2] = ((pts[index + 1] << 16) + (0xFFFF & pts[index]));

   if (!buffer_command(num_pts, tmp_pts)) {
	  Free(tmp_pts);
	  Signal(&sem);
	  return(0);
   }
   Free(tmp_pts);

   Signal(&sem);
   return(1);
}   

/**************************************************************************/
/*   arc_functions	      Command Number = 8			  */
/*									  */
/*   Does								  */
/*	   Arc		       mode = 1 				  */
/*	   Pie		       mode = 2 				  */
/*	   Chord	       mode = 3 				  */
/*									  */
/*   The mode field is interpreted by the graphics server.		  */
/**************************************************************************/


int arc_functions(graph_stream, xleft, ytop, xright, ybottom,
				xstart, ystart, xend, yend, mode)
   Stream *graph_stream;
   word   xleft, ytop, xright, ybottom, xstart, ystart, xend, yend,
	  mode;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      params[13], index;
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 8)) {
      Signal(&sem);
      return(0);
   }

   index = check_line_attributes(graph_node, &params[0]);  /* attr. changed? */
   params[index++] = mode;	   params[index++] = xleft;
   params[index++] = ytop;	   params[index++] = xright;
   params[index++] = ybottom;	   params[index++] = xstart;
   params[index++] = ystart;	   params[index++] = xend;
   params[index++] = yend;

   if (!buffer_command(index, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}


/***************************************************************************/
/*  SetLineColor, SetLineStyle, SetLineWidth				   */
/*									   */
/*  These functions all require two parameters, the first being a pointer  */
/*  to a window, and the second being either a color, style or width.	   */
/*  No messages are sent to the graphics server. If the second parameter   */
/*  value is different from the existing line attribute for that window,   */
/*  then a flag is set indicating a change in the line attributes, and the */
/*  attribute is changed.						   */
/***************************************************************************/



int SetLineColor(graph_stream, color)
   Stream *graph_stream;
   word   color;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   LineAttr  *attr = &(graph_node->line_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (attr->color == color) {
      Signal(&sem);
      return(1);
   }

   attr->color	       = color;
   attr->color_changed = 1;	 /* set color changed flag */

   Signal(&sem);
   return(1);
}



int SetLineStyle(graph_stream, style)
   Stream *graph_stream;
   word   style;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   LineAttr  *attr = &(graph_node->line_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (attr->style == style) {
      Signal(&sem);
      return(1);
   }

   attr->style = style;
   attr->style_changed = 1;    /* set line style changed flag */

   Signal(&sem);
   return(1);
}


int SetLineWidth(graph_stream, width)
   Stream *graph_stream;
   word   width;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   LineAttr  *attr = &(graph_node->line_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (attr->width == width) {
      Signal(&sem);
      return(1);
   }

   attr->width = width;
   attr->width_changed = 1;   /* set line width changed flag */

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*   SetBkColor 	      Command Number = 9			  */
/**************************************************************************/

int SetBkColor(graph_stream, color)
   Stream *graph_stream;
   word   color;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 9)) {
      Signal(&sem);
      return(0);
   }

   if (graph_node->BKground.color == color) {
      Signal(&sem);
      return(1);
   }

   control_size = 1;			   /* set up message structure */
   graph_node->BKground.color = color;
   control_vector[0] = color;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();

   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   SetBkMode		      Command Number = 10			  */
/**************************************************************************/

int SetBkMode(graph_stream, mode)
   Stream *graph_stream;
   word   mode;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if ((mode < 1) || (mode > 2)) mode = 2; /*default = OPAQUE mode */
   if (graph_node->BKground.mode == mode) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 10)) {
      Signal(&sem);
      return(0);
   }

   graph_node->BKground.mode = mode;
   control_vector[0] = mode;	     /* set up message structure */
   control_size = 1;
   data_size = 0;

   ret_val = send_message();  /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   SetFillMode	      Command Number = 12			  */
/**************************************************************************/

int SetFillMode(graph_stream, mode)
   Stream *graph_stream;
   word   mode;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if ((mode < ALTERNATE) || (mode > WINDING)) {
      Signal(&sem);
      return(0);
   }
   if (graph_node->fill_attr.mode == mode) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 12)) {
      Signal(&sem);
      return(0);
   }

   graph_node->fill_attr.mode = mode;
   control_vector[0] = mode;	     /* set up message structure */
   control_size = 1;
   data_size = 0;

   ret_val = send_message();	/* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   SetFillAttr	      Command Number = 11			  */
/**************************************************************************/

int SetFillAttr(graph_stream, style, color)
   Stream *graph_stream;
   word   style, color;
{
   GraphNode *graph_node = valid_stream(graph_stream);
   int	   ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
     /* dont send message if nothing is to change */
   if ((color == graph_node->fill_attr.color) &&
       (style == graph_node->fill_attr.style)) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 11)) {
      Signal(&sem);
      return(0);
   }

   graph_node->fill_attr.style = style;
   control_vector[0] = style;
   graph_node->fill_attr.color = color;
   control_size = 2;			 /* set up message structure */
   control_vector[1] = color;
   data_size = 0;

   ret_val = send_message();	/* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/***************************************************************************/
/* SetTextColor 							   */
/*									   */
/* The function does not send a message to the graphics server, but rather */
/* checks to see if the new text color is different from the previos text  */
/* color. If that is the case, then a flag is set saying the text color    */
/* has changed, and the new color is inserted in the attribute list of the */
/* graphic window. When the next TextOut call is made, this new text color */
/* will be incorporated into the TextOut command.			   */
/***************************************************************************/


int SetTextColor(graph_stream, color)
   Stream *graph_stream;
   word   color;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */

   if (graph_node == (GraphNode *) NULL) return(0);

   if ((color < BLACK) || (color > WHITE)) return(0);

   Wait(&sem);
   if (graph_node->text_attr.color == color) {
      Signal(&sem);
      return(1);
   }

   graph_node->text_attr.color = color;
   graph_node->text_attr.color_changed = 1;  /* set text color changed flag */

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*   SetTextOps 	      Command Number = 13			  */
/*									  */
/*   Does								  */
/*	 SetTextSpacing       Mode = 0					  */
/*	 SetTextAlign	      Mode = 1					  */
/*									  */
/*   Mode is interpreted by the graphics server.			  */
/**************************************************************************/

int SetTextOps(graph_stream, value, mode)
   Stream *graph_stream;
   word   value, mode;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (mode == 0) {
      if (value < 0) {
         Signal(&sem);
         return(0);	  /* cannot have -ve spacing */
      }
      graph_node->text_attr.spacing = value;
   }
   else {     /* are align values valid? */
     if ((value != LEFT) && (value != RIGHT) && (value != CENTRE)) {
        Signal(&sem);
        return(0);
     }
     graph_node->text_attr.align = value;
   }

   if (!check_last_command(graph_stream, 13)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = mode;	  /* set up message structure */
   control_vector[1] = value;
   control_size = 2;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*  check_font								  */
/*									  */
/*    Parameters  :  font						  */
/*			 A pointer to a FONT structure. 		  */
/*									  */
/*    Function	  :  Utility that checks the values in the FONT structure */
/*		     and sets defaults in invalid fields of the structure */
/*									  */
/*		     Called by "CreateFont".				  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/

void check_font(font)
   FONT *font;
{
   UBYTE family, pitch;

   if ((font->tilt < 0) || (font->tilt > 3600)) font->tilt = 0;
   if ((font->orientation < 0) || (font->orientation > 3600))
      font->orientation = 0;
   if ((font->weight != W_NORMAL) && (font->weight != W_BOLD))
      font->weight = W_NORMAL;
   if (font->italic != 1) font->italic = 0;
   if (font->underline != 1) font->underline = 0;
   if (font->strikeout != 1) font->strikeout = 0;
   if ((font->charset != OEM_CHAR) && (font->charset != ANSI_CHAR))
       font->charset = ANSI_CHAR;
   if ((font->quality != Q_DEFAULT) && (font->quality != Q_DRAFT) &&
       (font->quality != Q_PROOF)) font->quality = Q_DEFAULT;

   if ((font->OutPrecision < OUT_DEFAULT) && (font->OutPrecision > OUT_STROKE))
      font->OutPrecision = OUT_DEFAULT;

   if ((font->ClipPrecision < CLIP_DEFAULT) && (font->ClipPrecision > CLIP_STROKE))
      font->ClipPrecision = CLIP_DEFAULT;

   pitch = font->pitch_family & 15;
   family = font->pitch_family & 240;
   family >>= 4;

   if ((pitch != P_DEFAULT) && (pitch != P_FIXED) &&(pitch != P_VARIABLE))
      pitch = P_DEFAULT;

   if ((family < 0) || (family > 5)) family = ANYONE;
     else
	 family <<= 4;

   font->pitch_family = family | pitch;
}


/**************************************************************************/
/*   FontOps		      Command Number = 14			  */
/*									  */
/*   Does								  */
/*	 SelectFont	      font_type = other fonts			  */
/*	 CreateFont	      font_type = USER_FONT			  */
/*									  */
/*   font_type is interpreted by the graphics server.			  */
/**************************************************************************/

int font_ops(graph_stream, font_type, font)
   Stream *graph_stream;
   word   font_type;
   FONT   *font;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   int	     ret_val;
   BYTE      *old_vector;  /* to save graphics buffer */


   if (graph_node == (GraphNode *) NULL) return(0);

      /* invalid font_type parameter? */
   if ((font_type < OEM_FIXED) || (font_type > USER_FONT)) return(0);

   Wait(&sem);
      /* Selecting font already in existence? */
   if ((font_type != USER_FONT) &&
       (font_type == graph_node->text_attr.font_type)) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 14)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = font_type;
   control_size = 1;

   if (font_type != USER_FONT) {
      graph_node->text_attr.font_type = font_type;
      data_size = 0;			    /* SelectFont's code */
      ret_val = send_message();    /* send message to server */
      Reset_All();
   }
   else {
     if (font == (FONT *) NULL) {
        Signal(&sem);
        return(0);  /* CreatFont's code */
     }
     check_font(font);

     graph_node->text_attr.font_type = font_type;
     graph_node->text_attr.font      = font;

     old_vector  = data_vector;     /* save graphics buffer */
     data_vector = (BYTE *) font;   /* FONT structure becomes data vector */
     data_size = sizeof(FONT);
     ret_val = send_message();	   /* send message to server */
     Reset_All();
     data_vector = old_vector;	   /* restore graphics buffer */
   }
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   SetMapMode 	      Command Number = 15			  */
/**************************************************************************/

int SetMapMode(graph_stream, mode)
   Stream *graph_stream;
   word   mode;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

       /* default mapping mode is M_TEXT */
   if ((mode < M_TEXT) || (mode > M_ANISOTROPIC)) mode = M_TEXT;

   Wait(&sem);
       /* mapping mode already in existence? */
   if (mode == graph_node->map_attr.mode) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 15)) {
      Signal(&sem);
      return(0);
   }

   graph_node->map_attr.mode = mode;
   control_vector[0] = mode;	     /* set up message structure */
   control_size = 1;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   SetDeviceOrigins	      Command Number = 16			  */
/*									  */
/*   Does								  */
/*	 SetDeviceOrg	      org_type = other fonts			  */
/*	 SetLogicalOrg	      org_type = USER_FONT			  */
/*									  */
/*   org_type is interpreted by the graphics server.			  */
/**************************************************************************/

int SetDeviceOrigins(graph_stream, x, y, org_type)
   Stream *graph_stream;
   word   x, y, org_type;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;
   MapAttr   *attr = &(graph_node->map_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
      /* Are the origins already what is desired? */
   if (org_type == DEVICE) {
     if ((attr->window_org[0] == x) && (attr->window_org[1] == y)) {
        Signal(&sem);
        return(1);
     }
   }
   else {
     if ((attr->viewprt_org[0] == x) && (attr->viewprt_org[1] == y)) {
        Signal(&sem);
        return(1);
     }
   }

   if (!check_last_command(graph_stream, 16)) {
      Signal(&sem);
      return(0);
   }

   if (org_type == DEVICE) {			/* SetDeviceOrg code */
       graph_node->map_attr.window_org[0] = x;
       graph_node->map_attr.window_org[1] = y;
       control_vector[0] = 0;
   }
   else {					/* SetLogicalOrg code */
       graph_node->map_attr.viewprt_org[0] = x;
       graph_node->map_attr.viewprt_org[1] = y;
       control_vector[0] = 1;
   }

   control_vector[1] = x;   control_vector[2] = y;
   control_size = 3;		 /* set up message structure */
   data_size = 0;

   ret_val = send_message();	/* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   SetDeviceExtents	      Command Number = 17			  */
/*									  */
/*   Does								  */
/*	 SetDeviceExt	      org_type = other fonts			  */
/*	 SetLogicalExt	      org_type = USER_FONT			  */
/*									  */
/*   ext_type is interpreted by the graphics server.			  */
/**************************************************************************/

int SetDeviceExtents(graph_stream, x, y, ext_type)
   Stream *graph_stream;
   word   x, y, ext_type;
{
   GraphNode *graph_node = valid_stream(graph_stream);	 /* ID valid? */
   int	     ret_val;
   MapAttr   *attr = &(graph_node->map_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
       /* Extents only apply to M_ISOTROPIC & M_ANISOTROPIC */
   if (graph_node->map_attr.mode < M_ISOTROPIC) {
      Signal(&sem);
      return(0);
   }

      /* are extents already what is desired? */
   if (ext_type == DEVICE) {
      if ((attr->window_ext[0] == x) && (attr->window_ext[1] == y)) {
         Signal(&sem);
         return(0);
      }
   }
   else {
      if ((attr->viewprt_ext[0] == x) && (attr->viewprt_ext[1] == y)) {
         Signal(&sem);
         return(0);
      }
   }

   if (!check_last_command(graph_stream, 17)) {
      Signal(&sem);
      return(0);
   }

   if (ext_type == DEVICE) {		       /* SetDeviceExt code */
      graph_node->map_attr.window_ext[0] = x;
      graph_node->map_attr.window_ext[1] = y;
      control_vector[0] = 0;
   }
   else {				       /* SetLogicalExt code */
      graph_node->map_attr.viewprt_ext[0] = x;
      graph_node->map_attr.viewprt_ext[1] = y;
      control_vector[0] = 1;
   }

   control_vector[1] = x;  control_vector[2] = y;
   control_size = 3;			    /* set up message structure */
   data_size = 0;

   ret_val = send_message();	 /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   get_two_words	      Command Number = mess_no			  */
/*									  */
/*   Does								  */
/*	 GetWindowSize	      mess_no = 18				  */
/*	 GetXY		      mess_no = 19				  */
/*									  */
/*   mess_no is the command number sent to the server.			  */
/**************************************************************************/


int get_two_words(graph, x, y, mess_no)
   Stream *graph;
   word   *x, *y, mess_no;
{
   GraphNode *graph_node = valid_stream(graph);  /*ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, mess_no)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;	       /* set up message structure */
   data_size = 0;
   ret_val = send_message();

   *x = mcb.Control[0];       /* retrieve two words sent by graphics server */
   *y = mcb.Control[1];       /* from Message Control Block */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   get_text_attr							  */
/*									  */
/*   Does								  */
/*	 GetTextColor	      mess_no = 1				  */
/*	 GetTextAlign	      mess_no = 2				  */
/*	 GetTextSpacing       mess_no = 3				  */
/*	 GetFont	      mess_no = 4				  */
/**************************************************************************/

word get_text_attr(graph, mess_no)
   Stream *graph;
   word   mess_no;
{
   GraphNode *graph_node = valid_stream(graph);    /* ID valid? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   switch (mess_no) {
      case 1  : ret_val = graph_node->text_attr.color;   /* GetTextColor */
		break;
      case 2  : ret_val = graph_node->text_attr.align;   /* GetTextAlign */
		break;
      case 3  : ret_val = graph_node->text_attr.spacing; /* GetTextSpacing */
		break;
      case 4  : if (graph_node->text_attr.font_type == USER_FONT) /* GetFont */
		   ret_val = (word) graph_node->text_attr.font;  /* Font selected */
		 else					       /* by CreateFont */
		   ret_val = graph_node->text_attr.font_type; /* Font selected */
		 break; 				    /* by SelectFont */
      default : ret_val = 0;
                break;
   }
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   get_fill_attr							  */
/*									  */
/*   Does								  */
/*	 GetFillColor	      mess_no = 1				  */
/*	 GetFillStyle	      mess_no = 2				  */
/*	 GetFillMode	      mess_no = 3				  */
/**************************************************************************/

word get_fill_attr(graph, mess_no)
   Stream *graph;
   word   mess_no;
{
   GraphNode *graph_node = valid_stream(graph);     /* ID valid? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   switch (mess_no) {
      case 1  : ret_val = graph_node->fill_attr.color;   /* GetFillColor */
		break;
      case 2  : ret_val = graph_node->fill_attr.style;   /* GetFillStyle */
		break;
      case 3  : ret_val = graph_node->fill_attr.mode;    /* GetFillMode */
		break;
      default : ret_val = 0;
                break;
   }
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   get_line_attr							  */
/*									  */
/*   Does								  */
/*	 GetLineColor	      mess_no = 1				  */
/*	 GetLineStyle	      mess_no = 2				  */
/*	 GetLineWidth	      mess_no = 3				  */
/**************************************************************************/

word get_line_attr(graph, mess_no)
   Stream *graph;
   word   mess_no;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid ? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   switch (mess_no) {
      case 1  : ret_val = graph_node->line_attr.color;   /* GetLineColor */
		break;
      case 2  : ret_val = graph_node->line_attr.style;   /* GetLineStyle */
		break;
      case 3  : ret_val = graph_node->line_attr.width;   /* GetLineWidth */
		break;
      default : ret_val = 0;
                break;
   }
   Signal(&sem);
   return(ret_val);
}


word GetMapMode(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   ret_val = graph_node->map_attr.mode;
   Signal(&sem);
   return(ret_val);	/* return window's mapping mode */
}

/**************************************************************************/
/*   org_and_ext	      Command Number = 24			  */
/*									  */
/*   Does								  */
/*	 GetLogicalOrg	      mess_no = 1				  */
/*	 GetDeviceOrg	      mess_no = 2				  */
/*	 GetLogicalExt	      mess_no = 3				  */
/*	 GetDeviceExt	      mess_no = 4				  */
/**************************************************************************/

int org_and_ext(graph, x, y, mess_no)
   Stream *graph;
   word   *x, *y, mess_no;
{
   GraphNode *graph_node = valid_stream(graph);    /* ID valid? */
   int	      ret_val = 1;

   if (graph_node == (GraphNode *) NULL) return(0);

      /* Don't need to send a message to server if looking for orgins or */
      /* if looking for extents in any of the non metric mapping modes	 */

   Wait(&sem);
   if ((mess_no < 3) || (graph_node->map_attr.mode == M_TEXT) ||
			(graph_node->map_attr.mode == M_ANISOTROPIC)) {
     switch (mess_no) {
	case 1	: *x = graph_node->map_attr.window_org[0];   /* GetLogicalOrg */
		  *y = graph_node->map_attr.window_org[1];
		  break;
	case 2	: *x = graph_node->map_attr.viewprt_org[0]; /* GetDeviceOrg */
		  *y = graph_node->map_attr.viewprt_org[1];
		  break;
	case 3	: *x = graph_node->map_attr.window_ext[0];  /* GetLogicalExt */
		  *y = graph_node->map_attr.window_ext[1];
		  break;
	case 4	: *x = graph_node->map_attr.viewprt_ext[0]; /* GetDeviceExt */
		  *y = graph_node->map_attr.viewprt_ext[1];
		  break;
	default : Signal(&sem);
	          return(0);
     }
   }
   else {   /* must send message if get extents using the metric mapping modes*/
      if (!check_last_command(graph, 24)) {
         Signal(&sem);
         return(0);
      }
      if (mess_no == 3) control_vector[0] = 0;
	else
	 control_vector[0] = 1;
      control_size = 1;
      data_size = 0;

      ret_val = send_message();   /* send message to server */
      *x = mcb.Control[0];   *y = mcb.Control[1];   /* retrieve extents from */
      Reset_All();				    /* server. */
   }
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   get_bk_attr							  */
/*									  */
/*   Does								  */
/*	 GetBkColor	      mess_no = 1				  */
/*	 GetBkMode	      mess_no = 2				  */
/**************************************************************************/

word get_bk_attr(graph, mess_no)
   Stream *graph;
   word   mess_no;
{
   GraphNode *graph_node = valid_stream(graph);    /* ID valid ? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   switch (mess_no) {
      case 1  : ret_val = graph_node->BKground.color;   /* GetBkColor */
		break;
      case 2  : ret_val = graph_node->BKground.mode;    /* GetBkMode */
		break;
      default : ret_val = 0;
                break;
   }
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   GetTextDim 		     Command Number = 20		  */
/**************************************************************************/

int GetTextDim(graph, textdim)
   Stream  *graph;
   TextDim *textdim;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 20)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;
   data_size = 0;

   ret_val = send_message();	/* send message to graphics server */

   textdim->height	     = mcb.Control[0];	  /* retrieve text   */
   textdim->ave_width	     = mcb.Control[1];	  /* dimensions from */
   textdim->ascent	     = mcb.Control[2];	  /* the graphics    */
   textdim->descent	     = mcb.Control[3];	  /* server	     */
   textdim->internal_leading = mcb.Control[4];
   textdim->external_leading = mcb.Control[5];

   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  MessageBox		       Command Number = 21			  */
/**************************************************************************/

word MessageBox(graph, text, caption, flags)
   Stream *graph;
   char *text, *caption;
   word flags;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word	     ret_val;
   char      sbuffer[255], *old_vect;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 21)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = strlen(text);
   if (caption == (char *)NULL)
      control_vector[1] = 1;
   else
      control_vector[1] = strlen(caption);
   control_vector[2] = flags;
   control_size = 3;
   
   old_vect = &data_vector[0];
   data_vector = &sbuffer[0];
   
   sbuffer[0] = '\0';
   strcpy(sbuffer, text);
   strcat(sbuffer, " ");
   strcat(sbuffer, caption);
   /* if no caption, insert a space as caption */
   if (caption == (char *)NULL)
      sbuffer[control_vector[0]+control_vector[1]] = ' ';
   data_size = (unsigned short)(control_vector[0] + control_vector[1] + 1);

   Timeout = OneSec * 1800;      /* Stream timeout */
   ret_val = send_message();
   Timeout = OneSec * 60;        /* reset the timeout */
   ret_val = mcb.Control[0];
   
   data_vector = old_vect;
   Reset_All();
   
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  squash_bits 							  */
/*									  */
/*    Parameters  :  num_bits						  */
/*			 The number of bits to be compressed		  */
/*		     bits						  */
/*			 A pointer to an array of 1' & 0's.		  */
/*		     bytes						  */
/*			 A pointer to the array which will contain the	  */
/*			 compressed bits.				  */
/*									  */
/*    Function	  :  Utility that takes an array of 'bits', i.e. 1's and  */
/*		     0's, where each 1 or 0 is a byte, and compresses the */
/*		     'bits' so that there are 8 1's and/or 0's in a byte. */
/*		     The compressed 'bits' are returned in the array	  */
/*		     pointed to by "bytes".				  */
/*									  */
/*		     Called by "CreateBitMap".				  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/

void squash_bits(num_bits, bits, bytes)
   word num_bits;
   BYTE *bits, *bytes;
{
   BYTE  temp_byte;
   word	 ct, count;

   for (ct = 0; ct < num_bits;) {   /* go through all the bits */
      temp_byte = 0;
      for (count = 0; (count < 8) && ((ct + count) < num_bits); count ++) {
      	 temp_byte = temp_byte << 1;   /* shift byte left 1 */
	 if (*bits == '0') *bits = (BYTE) 0;
	 if (*bits == '1') *bits = (BYTE) 1;
	 if (*bits++ > 0) temp_byte = temp_byte + 1;   /* set leftmost bit */
	    else				      /* in byte	  */
		temp_byte = temp_byte + 0;
      }
      *bytes++ = temp_byte;   /* put byte in array pointed to by "bytes" */
      ct += 8;
   }
   bytes--;
   for (ct = 0; ct < (8 - (num_bits % 8)); ct++)  /* if num_bits % 8 <> 0, */
      *bytes = *bytes << 1;                /* shift bits to most significant */
}                                          /* bit in last byte */

/**************************************************************************/
/*  CreateBitMap							  */
/**************************************************************************/

BITMAP *CreateBitMap(width, height, planes, bits_pix, bits)
   word  width, height, planes, bits_pix;
   BYTE  *bits;
{
   BYTE   *pixels;
   BITMAP *bitmap;
   word   num_bits, byte_width, size_bits;

   bitmap = (BITMAP *) Malloc(sizeof(BITMAP));	    /* memory for the BITMAP */
   if (bitmap == (BITMAP *) NULL)		    /* structure	     */
      return((BITMAP *) NULL);

   byte_width = (width * bits_pix + 15) / 16 * 2;  /* even number of bytes */
						   /* per scan line!	   */
   bitmap->width      = width;
   bitmap->height     = height; 	   /* Fill in the BITMAP structure */
   bitmap->planes     = planes;
   bitmap->bits_pix   = bits_pix;
   bitmap->byte_width = byte_width;
   bitmap->bits       = (BYTE *) NULL;

   num_bits   = width * height * planes * bits_pix;  /* no. bits in "bits" */
   size_bits  = byte_width * height * planes;	/* size of MS-WINDOWS	   */
   pixels = Malloc(size_bits);			/* compatible bitmap	   */
   if (pixels == (BYTE *) NULL) {
     Free(bitmap);
     return((BITMAP *) NULL);
   }
   bitmap->bits = pixels;

   if (bits != (BYTE *) NULL)
      memcpy(pixels, bits, (size_t)size_bits);
      
   return(bitmap);
}

/**************************************************************************/
/*  CreateDIBitMap							  */
/**************************************************************************/

BITMAP *CreateDIBitMap(graph, width, height)
   Stream *graph;
   word  width, height;
{
   BYTE   *pixels;
   BITMAP *bitmap;
   word   num_bits;
   word byte_width, size_bits;
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word bits_pix = graph_node->info[5];
   word planes = graph_node->info[6];

   if (graph_node == (GraphNode *) NULL) return(0);

   bitmap = (BITMAP *) Malloc(sizeof(BITMAP));	    /* memory for the BITMAP */
   if (bitmap == (BITMAP *) NULL)		    /* structure	     */
      return((BITMAP *) NULL);

   byte_width = (width * bits_pix + 15) / 16 * 2;  /* even number of bytes */
						   /* per scan line!	   */
   bitmap->width      = width;
   bitmap->height     = height; 	   /* Fill in the BITMAP structure */
   bitmap->planes     = planes;
   bitmap->bits_pix   = bits_pix;
   bitmap->byte_width = byte_width;
   bitmap->bits       = (BYTE *) NULL;

   num_bits   = width * height * planes * bits_pix;  /* no. bits in "bits" */
   size_bits  = byte_width * height * planes;	/* size of MS-WINDOWS	   */
   pixels = Malloc(size_bits);			/* compatible bitmap	   */
   if (pixels == (BYTE *) NULL) {
     Free(bitmap);
     return((BITMAP *) NULL);
   }
   bitmap->bits = pixels;

   return(bitmap);
}

/**************************************************************************/
/*  DeleteBitMap 							  */
/**************************************************************************/

void DeleteBitMap(bitmap)
   BITMAP *bitmap;
{
   if (bitmap != (BITMAP *)NULL) {
      if (bitmap->bits != NULL)  Free(bitmap->bits);
      Free(bitmap);
      bitmap = (BITMAP *) NULL;
   }
}

/**************************************************************************/
/*  SetBitMapBits							  */
/**************************************************************************/

int SetBitMapBits(bitmap, bits)
   BITMAP *bitmap;
   BYTE   *bits;
{
   int size_bits;

   if (bitmap == (BITMAP *) NULL) return(0);
   
   size_bits = (int)(bitmap->byte_width * bitmap->height * bitmap->planes);
   memcpy(bitmap->bits, bits, size_bits);

   return(size_bits/8);    /* return the no of bytes used */
}


/**************************************************************************/
/*  determine_max_block        Command Number = 29			  */
/*									  */
/*  This function is called by the Graphics Library, to determine the	  */
/*  largest block of memory availiable on the server, and is used when	  */
/*  sending data for a bitmap down the link. The largest block will be	  */
/*  the size of the message buffer if there is more memory availiable on  */
/*  the PC than the size of the message buffer on the PC, or the amount   */
/*  of memory left on the PC, if the memory left is less than the size of */
/*  the message buffer. 						  */
/*									  */
/**************************************************************************/

word determine_max_block(graph)
   Stream *graph;
{
   word ret_val;

   if (!check_last_command(graph, 29))  return(0);

   control_size = 1;
   data_size = 0;
   if (!send_message()) {	/* send message to server */
      Reset_All();		/* if function fails on server, no memory */
      return(0);		/* left on server. */
   }
   ret_val = control_vector[0];   /* Get size returned by server */
   Reset_All();
   return(ret_val);
}



/**************************************************************************/
/*  send_bitmap 							  */
/*									  */
/*    Parameters  :  graph						  */
/*			 The ID of the window receiving a bitmap.	  */
/*		     bitmap						  */
/*			 A pointer to BITMAP structure defining a bitmap. */
/*		     x							  */
/*			 X co-ordinate the bitmap is drawn from 	  */
/*		     y							  */
/*			 Y co-ordinate the bitmap is drawn from 	  */
/*		     rop						  */
/*			 ROP code bitmap is drawn with. 		  */
/*									  */
/*    Function	  :  The function is called if the bitmap to be drawn	  */
/*		     cannot be drawn in one go, but has to sent to the	  */
/*		     server in smaller blocks.				  */
/*									  */
/*		     Called by "DrawBitMap".				  */
/*									  */
/*    Returns	  :  1 if bitmap successfully drawn, 0 if not.		  */
/*									  */
/**************************************************************************/

int send_bitmap(graph, bitmap, x, y, rop, max_block)
   Stream *graph;
   BITMAP *bitmap;
   word   x, y, rop, max_block;
{
   BYTE *block, *old_vector, **plane_ptr;
   word scan_width, lines_block, bytes_plane;
   word	ret_val, ct, count, counter;

   if (!check_last_command(graph, 22))  return(0);

   block = Malloc(max_block);
   if (block == (BYTE *) NULL)  return(0);
   
   plane_ptr = Malloc(sizeof(BYTE *) * bitmap->planes);
   if (plane_ptr == NULL) {
     Free(block);
     return(0);
   }

   scan_width	= bitmap->byte_width;	 /* bytes per scan line */
   lines_block	= max_block / scan_width / bitmap->planes; /* scan lines/block*/
   bytes_plane	= scan_width * bitmap->height;
   for (ct = 0; ct < bitmap->planes; ct++)
     plane_ptr[ct] = bitmap->bits + (ct * bytes_plane);

/* everything should now be initialised */

   old_vector  = data_vector;	 /* save data vector */
   data_vector = block;
   for (ct = 0; ct < bitmap->height; ) {     /* transfer a bit of the bitmap */
     count = scan_width * lines_block;
     for (counter = 0; counter < bitmap->planes; counter++) {	 /* to "block" */
        memcpy(block, plane_ptr[counter], (int)count);
        plane_ptr[counter] += (int)count;
     }

     /* initialise message stucture */
     control_vector[0] = bitmap->width;   control_vector[1] = lines_block;
     control_vector[2] = bitmap->planes;  control_vector[3] = bitmap->bits_pix;
     control_vector[4] = x;		  control_vector[5] = y;
     control_vector[6] = rop;
     control_size = 7;
     data_size	  = (unsigned short)(count * bitmap->planes);
     ret_val = send_message();	  /* send bitmap to server */
     if (ret_val == 0) {
       Reset_All();
       data_vector = old_vector;
       return(0);
     }
     x = control_vector[0]; y = control_vector[1];  /* starting co-ordinates */
     Reset_All();				    /* of next bit of bitmap */
     ct += lines_block;
     if ((ct + lines_block) > bitmap->height) lines_block = bitmap->height - ct;
   }
   Reset_All();
   data_vector = old_vector;	 /* restore data vector */
   Free(block);
   return(1);
}


/**************************************************************************/
/*  DrawBitMap		       Command Number = 22			  */
/**************************************************************************/

int DrawBitMap(graph, bitmap, x, y, rop)
   Stream *graph;
   BITMAP *bitmap;
   word   x, y, rop;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word      max_block, scan_width, image_size;
   BYTE      *old_vector;
   int	     ret_val;


   if (graph_node == (GraphNode *) NULL) return(0);

   if (bitmap == (BITMAP *) NULL) return(0);

   Wait(&sem);
   max_block = determine_max_block(graph);
   
   if (max_block > 10000) max_block -= 10000;

   scan_width = bitmap->byte_width;  /* bytes per scan line */
     /* 1 scan line > size of buffer? */
   if (max_block < (scan_width * bitmap->planes)) {
      Signal(&sem);
      return(0);
   }

   image_size = scan_width * bitmap->height * bitmap->planes; /* bitmap size */
   if (image_size < max_block) {    /* bitmap fits into buffer! */
      if (!check_last_command(graph, 22))  {
         Signal(&sem);
         return(0);
      }

      old_vector = data_vector;   /* save data vector */

      /* set up message structure */
      control_vector[0] = bitmap->width;   control_vector[1] = bitmap->height;
      control_vector[2] = bitmap->planes;  control_vector[3] = bitmap->bits_pix;
      control_vector[4] = x;		   control_vector[5] = y;
      control_vector[6] = rop;
      control_size = 7;
      data_size    = (unsigned short)image_size;
      data_vector  = bitmap->bits;
      ret_val = send_message();   /* send bitmap to server */
      Reset_All();
      data_vector = old_vector;
   }
   else   /* break bitmap into chunks and send */
      ret_val = send_bitmap(graph, bitmap, x, y, rop, max_block);
      
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  FillRect		       Command Number = 23			  */
/**************************************************************************/

int FillRect(graph, x1, y1, x2, y2, color)
   Stream *graph;
   word   x1, y1, x2, y2, color;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word      params[5];

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 23)) {
      Signal(&sem);
      return(0);
   }

   params[0] = x1;     params[1] = y1;	 /* set up parameters for command */
   params[2] = x2;     params[3] = y2;
   params[4] = color;

   if (!buffer_command(5, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*  ClearGraph		       Command Number = 25			  */
/**************************************************************************/

int ClearGraph(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);  /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 25)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;
   data_size = 0;
   ret_val = send_message();  /* tell server to clear graphic window */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*  SetCursorPos	       Command Number = 26			  */
/**************************************************************************/

int SetCursorPos(graph, x, y)
   Stream *graph;
   word   x, y;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 26)) {
      Signal(&sem);
      return(0);
   }

   control_size = 2;		    /* set up control vector */
   control_vector[0] = x;
   control_vector[1] = y;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*  ClipCursor		       Command Number = 27			  */
/**************************************************************************/

int ClipCursor(graph, x1, y1, x2, y2)
   Stream *graph;
   word   x1, y1, x2, y2;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 27)) {
      Signal(&sem);
      return(0);
   }

   control_size = 4;		    /* set up control vector */
   control_vector[0] = x1;    control_vector[1] = y1;
   control_vector[2] = x2;    control_vector[3] = y2;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  ChangeCursor	       Command Number = 28			  */
/**************************************************************************/

int ChangeCursor(graph, shape)
   Stream *graph;
   word   shape;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 28)) {
      Signal(&sem);
      return(0);
   }

   switch (shape) {
     case ARROW   :
     case CROSS   :		   /* make sure that the new cursor shape */
     case IBEAM   :		   /* is valid!. If not default to ARROW  */
     case ICON	  :
     case SIZE	  :
     case UPARROW :
     case WAIT	  : break;
     default	  : shape = ARROW;
   }

   control_size = 1;		   /* set up control vector */
   control_vector[0] = shape;
   data_size = 0;

   ret_val = send_message();	 /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  CreateMetaFile	       Command Number = 32			  */
/**************************************************************************/

word CreateMetaFile(graph, name)
   Stream *graph;
   byte   *name;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val, name_len;
   word      result;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 32)) {
      Signal(&sem);
      return(0);
   }

   if (name == (byte *) NULL) control_size = 1;  /* no name, so no data */
      else {
	name_len = strlen(name);	 /* put name in data vector */
	if (name_len > 80) {
	   Signal(&sem);
	   return(0);
	}
	strcpy(data_vector, name);
	data_vector[name_len] = '\0';
	data_size = name_len;
      }

   ret_val = send_message();	  /* send message to graphics server */
   if (ret_val == 0) {
      Signal(&sem);
      return(0);
   }
   result = control_vector[0];
   Reset_All();
   Signal(&sem);
   return(result);
}


/**************************************************************************/
/*  CloseMetaFile	       Command Number = 33			  */
/**************************************************************************/

int CloseMetaFile(graph, DC)
   Stream *graph;
   word   DC;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 33)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;
   control_vector[0] = DC;     /* set up parameter for graphics server */
   ret_val = send_message();   /* send message to graphics server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  GetMetaFile 	       Command Number = 34			  */
/**************************************************************************/

word GetMetaFile(graph, name)
   Stream *graph;
   byte   *name;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;
   word      result;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 34)) {
      Signal(&sem);
      return(0);
   }

   if (name == (byte *) NULL) control_size = 1;  /* no name, so no data */
      else {
	strcpy(data_vector, name);    /* put name in data vector of MCB */
	data_size = strlen(name);
      }

   ret_val = send_message();	  /* send message to graphics server */
   if (ret_val == 0) {
      Signal(&sem);
      return(0);
   }
   result = control_vector[0];
   Reset_All();
   Signal(&sem);
   return(result);
}


/**************************************************************************/
/*  PlayMetaFile	       Command Number = 35			  */
/**************************************************************************/

int PlayMetaFile(graph, handle)
   Stream *graph;
   word   handle;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 35)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;
   control_vector[0] = handle;	 /* set up parameter for graphics server */
   ret_val = send_message();	 /* send message to graphics server */
   if (ret_val == 0) {
      Signal(&sem);
      return(0);
   }
   ret_val = (int) control_vector[0];
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  DeleteMetaFile	       Command Number = 36			  */
/**************************************************************************/

int DeleteMetaFile(graph, handle)
   Stream *graph;
   word   handle;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 36)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = handle;	 /* set up parameter for graphics server */
   control_size = 1;
   ret_val = send_message();	 /* send message to graphics server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/****************************************************************************/
/* GetDeviceCaps							    */
/*									    */
/*   Parameters :-							    */
/*									    */
/*	  graph - A pointer uniquely identifying a graphic device.	    */
/*									    */
/*	  index - An index into a table of capabilities and attributes	    */
/*		  pertaining to a graphic device.			    */
/*									    */
/*   Function :-							    */
/*     The function does not send a message to the graphics server on the   */
/*     PC. A list of capabilities and attributes is obtained from the PC    */
/*     when each device is opened, ie. A graphic window, or a graphic	    */
/*     printer. This information is stored in the GraphNode structure	    */
/*     associated with each device. GetDeviceCaps returns a value from this */
/*     information table. A particular value can be selected via the index  */
/*     parameter.							    */
/*									    */
/*   Returns :- 							    */
/*     The value in the information table at the address indicated by index */
/****************************************************************************/

int GetDeviceCaps(graph, index)
   Stream *graph;
   word   index;
{
   GraphNode *graph_node = valid_stream(graph);   /* valid window? */
   int ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   if ((index < 0) || (index > 17)) return(0);	 /* valid index? */

   Wait(&sem);
   ret_val = (int) graph_node->info[index];
   Signal(&sem);
   return(ret_val);
}


/***************************************************************************/
/* The following routines allow for the use of colour palettes.  The user  */
/* would allocate sufficient space for a logical palette and would then    */
/* set the data fields up for the required colours.  The palette would     */
/* then be selected.  Many of the subsequent graphics calls may then use   */
/* index into the logical palette rather than a color in order to improve  */
/* the output quality and to take advantage of as many colours as the      */
/* hardware can handle.                                                    */


LOGPALETTE *CreatePalette(num_entries)
   unsigned short num_entries;
{
   LOGPALETTE *pal;
   
   pal = Malloc(sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * ((word)num_entries - 1));
   if (pal != (LOGPALETTE *) NULL) {
      pal->num_entries = (unsigned short) num_entries;
      pal->version = 0x300;
   }
   else   return((LOGPALETTE *)NULL);
   return(pal);
}

/* a simple routine to remove a palette */

int FreePalette(pal)
   LOGPALETTE *pal;
{
   if (pal == (LOGPALETTE *)NULL)    return(0);   /* failed */
   Free(pal);
   return(1);
}


/***************************************************************************/
/* SelectPalette             Command Number 30                             */
/***************************************************************************/

word SelectPalette(graph, pal)
   Stream *graph;
   LOGPALETTE *pal;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   word	     ret_val;
   char      *old_vect;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 30)) {
      Signal(&sem);
      return(0);
   }

   old_vect = data_vector;
   data_vector = (BYTE *)pal;
   data_size = sizeof(LOGPALETTE) + (pal->num_entries-1)*sizeof(PALETTEENTRY);
   ret_val = send_message();	 /* send message to graphics server */
   ret_val = control_vector[0];
   data_vector = old_vect;
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/***************************************************************************/
/* UnselectPalette             Command Number 31                           */
/***************************************************************************/

word UnselectPalette(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   word	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 31)) {
      Signal(&sem);
      return(0);
   }
   data_size = 1;
   ret_val = send_message();	 /* send message to graphics server */
   ret_val = control_vector[0];
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/***************************************************************************/
/* GetTextExtent              Command Number 37                            */
/***************************************************************************/

word GetTextExtent(graph, text)
   Stream *graph;
   char *text;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   word	     ret_val;
   char      *old_vect;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 37)) {
      Signal(&sem);
      return(0);
   }
   old_vect = data_vector;
   data_size = strlen(text);
   data_vector = text;
   ret_val = send_message();	 /* send message to graphics server */
   ret_val = control_vector[0];
   data_vector = old_vect;
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

   
/***************************************************************************/
/* The ability to print graphics from the transputer is supplied not by    */
/* the graphics server, but by a seperate server, the graphics printer	   */
/* server. This server can be located using the directory name "/grfxprn". */
/* The server allows a programmer on the transputer to open a printer	   */
/* stream, and to close a printer stream. Further commands are available   */
/* through the use of a private protocol. At present there are two further */
/* commands available to a programmer using the private protocol. By using */
/* a message number of 0, the programmer is able to print a file, and by   */
/* using a message number of 1, the programmer is able to determine when   */
/* the print job is finished. The use of the private protocol is not shown */
/* here, as we use the file "prngrfx" to actually print graphics. (The use */
/* of the protocol can be seen in that file.)				   */
/*									   */
/* At present the graphics printer server will only allow the printing of  */
/* a graphics metafile, which has been created through this library, or    */
/* been created in Microsoft Windows.					   */
/***************************************************************************/


/****************************************************************************/
/*  InitPrinter()							    */
/*									    */
/*  Parameters :-							    */
/*     None.								    */
/*									    */
/*  Function :- 							    */
/*     The function attempts to locate the graphics printer server. Once    */
/*     found, the function allocates memory for a dummy stream structure.   */
/*     This will be the structure passed back to the caller, but it does    */
/*     represent an actual stream, and its only purpose is to provide	    */
/*     compatability with the rest of the graphics library. Naturally we    */
/*     take precautions so that normal graphics commands are not sent to    */
/*     this stream. Once the dummy stream has been created, the function    */
/*     obtains the capabilities and attributes of the current printer and   */
/*     adds the dummy stream pointer to the list of open graphic windows.   */
/*									    */
/*  Returns :-								    */
/*     The address of the dummy stream structure if successful, or NULL if  */
/*     unsuccessful.							    */
/****************************************************************************/

Stream * InitPrinter()
{
   Object *prn_obj;
   Stream *prn;

   if (!graphics_availiable) return((Stream *) NULL);

   prn_obj = Locate(NULL, "/grfxprn");	/* graphics printer server available */
   if (prn_obj == (Object *) NULL) return((Stream *) NULL);

   prn = (Stream *) Malloc(sizeof(Stream));   /* create a dummy stream */
   if (prn == (Stream *) NULL) {
      Close(prn_obj);
      return((Stream *) NULL);
   }
   prn->Server = 0L;	 /* make sure its recognised as being invalid */
   prn->Reply  = 0L;
			 /* get info on printer */
   if (ObjectInfo(prn_obj, NULL, data_vector) != Err_Null) {
     Free(prn);
     Close(prn_obj);
     return((Stream *) NULL);
   }

   Close(prn_obj);
   Wait(&sem);
			 /* add printer to list of open graphic windows */
   if (!add_to_list(0, prn, "PrnJob", data_vector)) {
      Signal(&sem);
      Free(prn);
      return((Stream *) NULL);
   }

   Signal(&sem);
   return(prn);
}


/****************************************************************************/
/*  PrintGraphics							    */
/*									    */
/*  Parameters :-							    */
/*     prn  - A pointer to a stream structure associated with the printer   */
/*     name - The name of the metafile to be printed.			    */
/*									    */
/*  Function :- 							    */
/*     The function checks that a file name for the metafile has actually   */
/*     been supplied, and checks that the name does not exceed 80	    */
/*     characters. Once the name has been verified, the program "prngrfx"   */
/*     is started up, with the name of the metafile being passed to it.     */
/*     "prngrfx" must be in the BIN directory of HELIOS. The program will   */
/*     run in conjunction with the program using the graphics library, thus */
/*     enabling the program to continue once printing is under way.	    */
/*									    */
/*  Returns :-								    */
/*     1 if the print was successfully started, 0 if not.		    */
/****************************************************************************/

int PrintGraphics(prn, name)
   Stream *prn;
   BYTE   *name;
{
   GraphNode *graph_node = valid_stream(prn);
   char      *dummy = Null(char),
	     **argv;   /* used to pass the name of the metafile to prngrfx */
   Object    *prog, *code, *objv[2];
   Stream    *str1, *strv[4];
   Environ   env;
   int	     ct;

   if (graph_node == (GraphNode *) NULL) return(0);

   if ((name == NULL) || (strlen(name) == 0) || (strlen(name) > 80)) return(0);

   /* Give a previous print job time to start up before starting up */
   /* current job.						    */

   if (print_jobs > 0) {
      prog = Locate(NULL, "/grfxprn/PrnJob1");
      if (prog == (Object *) NULL) {
	 for (ct = 0; (ct < 5) && (prog == (Object *) NULL); ct++) {
	    Delay(OneSec * 6);
	    prog = Locate(NULL, "/grfxprn/PrnJob1");
	 }
       }

     if (prog != (Object *) NULL) Close(prog);
   }
   
   prog = (Object *) NULL;
   print_jobs++;

   argv = Malloc(sizeof(char *));
   if (argv == NULL) return(0);

   *argv = Malloc(sizeof(char) * (word)strlen(name));
   if (*argv == (char *) NULL) {
     printf("Unable to allocate memory for argument to prngrfx!\r\n");
     Free(argv);
     return(0);
   }

   code = Locate(NULL, "/helios/bin/prngrfx");
   if (code == (Object *) NULL) return(0);

   prog = Execute(NULL, code);		/* startup prngrfx */
   if (prog == (Object *) NULL) {
      Close(code); 	
      return(0);
   }

   Close(code);
   
   str1 = Open(prog, NULL, O_WriteOnly);
   if (str1 == (Stream *) NULL) {
      Close(prog);
      return(0);
   }
   
   Close(prog);

   objv[0] = Null(Object);	   /* set up object, stream and argument */
   objv[1] = Null(Object);	   /* stuff for prngrfx.		 */

   strv[0] = Heliosno(stdin);
   strv[1] = Heliosno(stdout);
   strv[2] = Heliosno(stderr);
   strv[3] = Null(Stream);

   strcpy(argv[0], name);
   env.Argv = argv;
   env.Envv = &dummy;
   env.Objv = &objv[0];
   env.Strv = &strv[0];

   if (SendEnv(str1->Server, &env) != 0L) {   /* send environment to prngrfx */
      Close(str1);
      return(0);
   }

   Close(str1);
   return(1);
}
@


1.3
log
@added suppressed debugging
@
text
@d232 2
d236 1
a236 1
                 MSWin_Server->Reply, FG_EnableMouse);
d242 6
a247 6
         if (PutMsg(&m) != EK_Timeout) {
            mouse_available = 1;
            InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Reply, NullPort, 0);
            m.Control = &(Control[0]);
            GetMsg(&m);
            Fork(2000, HandleMouseEvents, sizeof(Port)+sizeof(VoidFnPtr), (Port)Control[0], MouseFn);
d249 1
d254 2
d258 1
a258 1
                 MSWin_Server->Reply, FG_EnableMSEvents);
d264 7
a270 4
         if (PutMsg(&m) != EK_Timeout) {
            msevent_available = 1;
            Fork(2000, HandleMSEvents, sizeof(Port)+sizeof(VoidFnPtr), 
                       MSWin_Server->Reply, MSEventFn);
d272 1
d906 1
d912 1
a912 2
            
      if (GetMsg(&m) == Err_Null) {
@


1.2
log
@fixed compile time warnings
@
text
@d1421 2
d1424 3
d1433 1
d1445 2
d1448 1
d1451 1
a1451 1
   data_size = strlen(line);
d1453 2
d1457 2
d1460 1
d1462 1
d1464 1
@


1.1
log
@Initial revision
@
text
@d1 3581
a3581 3576
/****************************************************************************/
/****************************************************************************/
/***									  ***/
/***		     Helios Graphics for MS-WINDOWS I/O Server		  ***/
/***		     =========================================		  ***/
/***									  ***/
/***		       Copyright (c) 1990,  CSIR - MIKOMTEK		  ***/
/***			  All Rights Reserved.				  ***/
/***									  ***/
/***  graph.c								  ***/
/***									  ***/
/***	This file contains the source code of the graphics library.	  ***/
/***	Most of the definitions may be found in the file graphlib.h.	  ***/
/***									  ***/
/***  Author  :  S.A. Wilson.						  ***/
/***									  ***/
/***  Date    :  March 1990.						  ***/
/***									  ***/
/****************************************************************************/
/****************************************************************************/



#include <attrib.h>
#include <stdarg.h>
#include <stdio.h>
#include <codes.h>
#include <string.h>
#include <nonansi.h>
#include <helios.h>
#include <ioevents.h>
#include "graphlib.h"

/* private protocol messages to MSWIN server */

#define FG_EnableMouse      FG_PrivateFirst
#define FG_EnableMSEvents   (FG_PrivateFirst + 0x10)
#define FG_RegisterWindow   (FG_PrivateFirst + 0x20)
#define FG_DeregisterWindow (FG_PrivateFirst + 0x30)
#define FG_DisableMouse     (FG_PrivateFirst + 0x40)

#define Mouse_Limit       64
#define Event_MSMouse     0x40L
#define Event_MSEvents    0x80L
#define MSMouse_EventSize (sizeof(IOEventHdr) + sizeof(MSMouse_Event))
#define MSEvent_EventSize (sizeof(IOEventHdr) + sizeof(MSEvent))

typedef struct MSMouse_Event {
   SHORT X;
   SHORT Y;
   WORD  Buttons;
   word  WinID;
} MSMouse_Event;

typedef struct MSEvent {
   SHORT Type;      /* the msevent type  */
   SHORT WinID;     /* the window ID     */
   word  Word1;     /* two words of data */
   word  Word2;
} MSEvent;



static Semaphore sem;
static word  control_vector[max_words + 1],  /* control vector for MCB */
	     MaxX,		    /* max width of graphics screen	    */
	     MaxY,		    /* max height of graphics screen	    */
	     buf_size,		    /* size of message buffer on I/O server */
	     CaptionSize,
	     MenuSize,
	     SwapButton,
	     ResizeFrameX,
	     ResizeFrameY,
	     BorderFrameX,
	     BorderFrameY;
	     
static BYTE *data_vector;	    /* data vector for MCB		    */
static unsigned short data_size;    /* size of data vector in MCB	    */
static int control_size,	    /* size of control vector in MCB	    */
	   last_command;	    /* last graphic command issued	    */
static word Timeout;		    /* timeout before data sent fails	    */
static MCB  mcb;	 	    /* Message Control Block 		    */

static int initialised = 0, graphics_availiable = 0;

static int    print_jobs = 0;
static Stream *active_graph = (Stream *) NULL;	/* Id active graphic window */
static Stream *MSWin_Server;        /* stream to mouse/windows servers */
static int    mouse_available = 0;
static int    msevent_available = 0;


GraphNode   Graph_List;   /* Head of the list of open graphic windows */


int	    add_to_list(int , Stream *, BYTE *, BYTE *);
GraphNode   *valid_stream(Stream *);
void        HandleMouseEvents(Port, VoidFnPtr);
void        HandleMSEvents(Port, VoidFnPtr);


/**************************************************************************/
/*  Reset_All								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Clears the first word of the control vector, which   */
/*		     is used when buffering commands. Resets data and	  */
/*		     control vector sizes.				  */
/*									  */
/*		     Normally called after a send_message call. 	  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/

void Reset_All(void)
{
   control_vector[0] = (word) 0;
   data_size	     = 0;
   control_size      = 0;
}



/**************************************************************************/
/*  InitGraphics							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Initialises the graphics library. Allocates	  */
/*		     "buf_size" bytes for a message buffer. Does an	  */
/*		     ObjectInfo on the graphics server, to get the screen */
/*		     device dimensions. Sets "initialised" flag and	  */
/*		     "graphics_availiable" flag if successful.		  */
/*									  */
/*		     Normally called by user.				  */
/*									  */
/*    Returns	  :  1 if library initialised, 0 if intialise fails.	  */
/*									  */
/**************************************************************************/


int InitGraphics(MouseFn, MSEventFn)
   VoidFnPtr MouseFn, MSEventFn;
{
   Object   *graph_obj;   /* Info returned by Locate.		       */
   DeviceInfo *GrphInfo;	/* Structure for info returned by ObjectInfo */

   initialised = 1;    /* set initialised flag */
   Graph_List.next     = (GraphNode *) NULL;  /* initialise list of open */
   Graph_List.graph_id = (Stream *) NULL;     /* graphics windows	 */
   Timeout = OneSec * 60;

   graph_obj   = Locate(NULL, "/graphics");

   if (graph_obj != (Object *) NULL) graphics_availiable = 1;
     else
	graphics_availiable = 0;

	  /* allocate a temporary data vector */
   data_vector = (BYTE *) Malloc(sizeof(DeviceInfo));
   if (data_vector == (BYTE *) NULL) graphics_availiable = 0;


   if (graphics_availiable) {
     if (ObjectInfo(graph_obj, "/graphics", data_vector) != 0L) {
	Free(data_vector);
	graphics_availiable = 0;
     }
     else {
	GrphInfo = (DeviceInfo *) data_vector;
	MaxX	 = GrphInfo->info[0];	  /* Screen device width  */
	MaxY	 = GrphInfo->info[1];	  /* Screen device height */
	buf_size = GrphInfo->info[2];	  /* size of buffer on PC */
	CaptionSize = GrphInfo->info[3];
	MenuSize = GrphInfo->info[4];
	SwapButton = GrphInfo->info[5];
	ResizeFrameX = GrphInfo->info[6];
	ResizeFrameY = GrphInfo->info[7];
	BorderFrameX = GrphInfo->info[8];
	BorderFrameY = GrphInfo->info[9];
     	Reset_All();
     }
   }

   if (graphics_availiable) {
     Free(data_vector);    /* Free temp data vector */
				  /* Allocate data vector */
     data_vector = (BYTE *) Malloc(buf_size * sizeof(BYTE));
     if (data_vector == (BYTE *) NULL) graphics_availiable = 0;
   }

   Close(graph_obj);
   InitSemaphore(&sem, 1);
   
   /* now open stream to MSWIN server and activate mouse and msevents */
   if ((MouseFn != (VoidFnPtr)NULL) || (MSEventFn != (VoidFnPtr)NULL)) {
      Object *file;
      Object *MSWIN = Locate(NULL, "/MSWIN");
      char applic[15];
      word Control[1];
      int i;
      MCB m;
      
      if (MSWIN == (Object *)NULL) {
         mouse_available = 0;
         msevent_available = 0;
         return(graphics_availiable);
      }
      
      /* get unique name */
      i = 1;
      for (i=1; ; i++) {
         sprintf(applic, "winapp.%d", i);
         file = Locate(MSWIN, applic);
         if (file == (Object *)NULL)  break;
         Close(file);
      }

      MSWin_Server = Open(MSWIN, applic, O_ReadWrite | O_Create);
      if (MSWin_Server == (Stream *)NULL) {
         mouse_available = 0;
         msevent_available = 0;
         Close(MSWIN);
         return(graphics_availiable);
      }
      Close(MSWIN);
      
      /* now we have a stream, we can boot the mouse handler */
      if (MouseFn != (VoidFnPtr)NULL) {
         /* now send the message to enable the mouse */
         InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
                 MSWin_Server->Reply, FG_EnableMouse);
         m.Control = &(Control[0]);
         Control[0] = 0xffffffff;
         m.MsgHdr.ContSize = 1;
         m.Timeout = 5 * OneSec;
      
         if (PutMsg(&m) != EK_Timeout) {
            mouse_available = 1;
            InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Reply, NullPort, 0);
            m.Control = &(Control[0]);
            GetMsg(&m);
            Fork(2000, HandleMouseEvents, sizeof(Port)+sizeof(VoidFnPtr), (Port)Control[0], MouseFn);
         }
      }

      /* now send a message to enable msevents */         
      if (MSEventFn != (VoidFnPtr)NULL) {
         /* now send the message to enable the msevents */
         InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
                 MSWin_Server->Reply, FG_EnableMSEvents);
         m.Control = Control;
         Control[0] = 0xffffffff;
         m.MsgHdr.ContSize = 1;
         m.Timeout = 5 * OneSec;
      
         if (PutMsg(&m) != EK_Timeout) {
            msevent_available = 1;
            Fork(2000, HandleMSEvents, sizeof(Port)+sizeof(VoidFnPtr), 
                       MSWin_Server->Reply, MSEventFn);
         }
      }
         
   }
   return(graphics_availiable);
}


/**************************************************************************/
/*  Init_Graph_Attributes						  */
/*									  */
/*    Parameters  :  graph_node 					  */
/*			  Pointer to a node in the open window list.	  */
/*									  */
/*    Function	  :  Fills in the default line, background, text, fill	  */
/*		     and mapping attributes for each graphic window	  */
/*		     opened.						  */
/*									  */
/*		     Called by "add_to_list".				  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/



void Init_Graph_Attributes(graph_node)
   GraphNode *graph_node;
{
   /* first do the line attributes */

   graph_node->line_attr.color	       = BLACK;
   graph_node->line_attr.color_changed = 0;
   graph_node->line_attr.style	       = SOLID;
   graph_node->line_attr.style_changed = 0;
   graph_node->line_attr.width	       = 1;
   graph_node->line_attr.width_changed = 0;

   /* Then do the background attributes */

   graph_node->BKground.color	  = WHITE;
   graph_node->BKground.mode	  = OPAQUE;

   /* then do the fill attributes */

   graph_node->fill_attr.color     = WHITE;
   graph_node->fill_attr.style	   = SOLID;
   graph_node->fill_attr.mode	   = ALTERNATE;

   /* then do the text attributes */

   graph_node->text_attr.color	   = BLACK;
   graph_node->text_attr.align	   = LEFT;
   graph_node->text_attr.spacing   = 0;

  /* Finally do the screen mapping attributes */

   graph_node->map_attr.mode	       = M_TEXT;
   graph_node->map_attr.window_org[0]  = 0;
   graph_node->map_attr.window_org[1]  = 0;
   graph_node->map_attr.viewprt_org[0] = 0;
   graph_node->map_attr.viewprt_org[1] = 0;
   graph_node->map_attr.window_ext[0]  = 1;
   graph_node->map_attr.window_ext[1]  = 1;
   graph_node->map_attr.viewprt_ext[0] = 1;
   graph_node->map_attr.viewprt_ext[1] = 1;
}


/**************************************************************************/
/*  add_to_list 							  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			  Id of an open graphic window. 		  */
/*									  */
/*		     graph_name 					  */
/*			  Unique name of the open graphic window.	  */
/*									  */
/*		     info						  */
/*			  Information pertaining to the graphic device	  */
/*			  being opened, ie. screen or printer.		  */
/*									  */
/*    Function	  :  Creates a "GraphNode", fills in the structure, and   */
/*		     adds the "GraphNode" to the end of the list of	  */
/*		     open graphic windows.				  */
/*									  */
/*		     Called by "OpenGraph".				  */
/*									  */
/*    Returns	  :  1 if the "GraphNode" is added, 0 if not.		  */
/*									  */
/**************************************************************************/


int add_to_list(id_no, graph_stream, graph_name, info)
   int       id_no;
   Stream    *graph_stream;
   BYTE      *graph_name, *info;
{
   GraphNode  *last_node = &Graph_List, *new_node;
   DeviceInfo *GrphInfo  = (DeviceInfo *) &info[0];
   int	      ct;

      /* Find the end of the list of open graph windows */
   for (;last_node->next != (GraphNode *) NULL; last_node = last_node->next);

   new_node = (GraphNode *) Malloc(sizeof(GraphNode));
   if (new_node == (GraphNode *) NULL) return(0);
   last_node->next    = new_node;	      /* Fill in GraphNode	   */
   new_node->next     = (GraphNode *) NULL;   /* structure and add node to */
   new_node->graph_id = graph_stream;	      /* the end of the list	   */
   new_node->WinID    = (word)id_no;
   strcpy(new_node->Name, graph_name);
   Init_Graph_Attributes(new_node);	      /* Initailise graph attr.    */
   for (ct = 0; ct < 18; ct++)
      new_node->info[ct] = GrphInfo->info[ct];
   return(1);
}


/**************************************************************************/
/*  del_from_list							  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			  Id of an open graphic window. 		  */
/*									  */
/*    Function	  :  Deletes the "GraphNode" containing the id defined	  */
/*		     by "graph_stream", from the list of open graphic	  */
/*		     windows.						  */
/*									  */
/*		     Called by "CloseGraph".				  */
/*									  */
/*    Returns	  :  The id of the open graphic window, prior to the	  */
/*		     window just removed, in the list of open graphic	  */
/*		     windows. May be NULL if only "GraphNode" left is the */
/*		     head of the list of open graphic windows.		  */
/*									  */
/**************************************************************************/



Stream *del_from_list(graph_stream)
   Stream *graph_stream;
{
   GraphNode *last_node = &Graph_List, *prev_node = last_node;

	/* Search for the correct GraphNode */
   for (;(last_node->graph_id != graph_stream) &&
	 (last_node != (GraphNode *) NULL); ) {
      prev_node = last_node;
      last_node = last_node->next;
   }
   if (last_node == (GraphNode *) NULL) return(0);	/* graph not found */
   prev_node->next = last_node->next;  /* remove node from list */
   Free(last_node);   /*free memory used to hold graph node */
   if (prev_node->graph_id == (Stream *) NULL) {
     if (prev_node->next != (GraphNode *) NULL)   /* Get next valid graph */
	prev_node = prev_node->next;		  /* id.		  */
   }
   return(prev_node->graph_id);
}


/**************************************************************************/
/*  valid_stream							  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			  Id of an open graphic window. 		  */
/*									  */
/*    Function	  :  Checks to see that the graphic window id,		  */
/*		     "graph_stream", is valid.				  */
/*									  */
/*		     Normally called by each graphics function. 	  */
/*									  */
/*    Returns	  :  The "GraphNode" in the list of open graphic windows  */
/*		     containing the id, "graph_stream". 		  */
/*									  */
/**************************************************************************/

GraphNode *valid_stream(graph_stream)
   Stream *graph_stream;
{
   GraphNode *next_node;

   if (!graphics_availiable) return((GraphNode *) NULL);

   if (graph_stream == (Stream *) NULL) return((GraphNode *) NULL);

       /* Search for the node containing "graph_stream" */
   for (next_node = Graph_List.next; next_node != (GraphNode *) NULL;
	next_node = next_node->next)
     if (next_node->graph_id == graph_stream) return(next_node);

   return((GraphNode *) NULL);
}


/**************************************************************************/
/*  send_message							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Sends a message to the graphics server.		  */
/*									  */
/*		     Normally called by non-buffered graphics functions,  */
/*		     or by "buffer_command".				  */
/*									  */
/*    Returns	  :  1 if the messsage was successfully sent, 0 if the	  */
/*		     message failed to be sent. 			  */
/*									  */
/**************************************************************************/


int send_message()
{

   if (active_graph == (Stream *) NULL) return(1);  /* Don't send bogus */
   if (last_command < 0) return(1);		    /* messages.	*/
   if ((control_size < 1) && (data_size < 1)) return(1);
      /* Dont send messages to dummy printer streams */
   if ((active_graph->Server == 0L) && (active_graph->Reply == 0L)) return(1);

	    /* "last_command" contains the actual graphics function number */
   InitMCB(&mcb, MsgHdr_Flags_preserve, active_graph->Server,
	   active_graph->Reply, Graph_Message | last_command);

   mcb.Timeout	       = Timeout;	   /* 1 minute */
   mcb.Control	       = (WORD *) &control_vector[0];
   mcb.MsgHdr.ContSize = (unsigned char) control_size;
   mcb.Data	       = data_vector;
   mcb.MsgHdr.DataSize = data_size;

   if (PutMsg(&mcb) != Err_Null) return(0);    /* send message */

   mcb.MsgHdr.Dest = active_graph->Reply;
   if (GetMsg(&mcb) != Err_Null) return(0);    /* get reply */

   if (mcb.MsgHdr.FnRc != 0) return(0);        /* error code? */
   return(1);
}


/**************************************************************************/
/*  buffer_command							  */
/*									  */
/*    Parameters  :  no_params						  */
/*			 The no. of parameters in the command.		  */
/*		     params						  */
/*			 A pointer to the parameters of the command.	  */
/*									  */
/*    Function	  :  Buffers the command represented by the command no.   */
/*		     in "last_command". If the buffer overflows during	  */
/*		     the buffering operation, the buffer is flushed.	  */
/*		     The number of commands buffered in the buffer is	  */
/*		     reflected in "control_vector[0]".                    */
/*									  */
/*		     Called by graphic functions that employ buffering.   */
/*									  */
/*    Returns	  :  1 if the messsage was buffered successfully, 0 if	  */
/*		     buffering operation failed.			  */
/*									  */
/**************************************************************************/


int buffer_command(no_params, params)
   word no_params, *params;
{
   int	 ret_code = 1, count;
   word *data = (word *) data_vector;

   if ((data_size + (no_params * sizeof(word))) >= buf_size) {
      ret_code = send_message();    /* flush buffer if it is going to */
      Reset_All();		    /* overflow.		      */
   }

   control_size = 1;
   control_vector[0]++;
   for (count = 0; count < no_params; count++) {       /* add command to */
      data[data_size / sizeof(word)] = params[count];  /* buffer.	 */
      data_size += sizeof(word);
   }

   return(ret_code);
}


/**************************************************************************/
/*  check_last_command							  */
/*									  */
/*    Parameters  :  graph						  */
/*			 Id of an open graphic window.			  */
/*		     cmd_no						  */
/*			 The graphics function's command number.          */
/*									  */
/*    Function	  :  Checks that the last graphics command issued is the  */
/*		     same as that represented by "cmd_no", and that the   */
/*		     last command was issued for the graphic window	  */
/*		     identified by "graph".				  */
/*									  */
/*		     Called by all graphic functions.			  */
/*									  */
/*    Returns	  :  1 if the messsage was buffered successfully, 0 if	  */
/*		     buffering operation failed.			  */
/*									  */
/**************************************************************************/


int check_last_command(graph, cmd_no)
   Stream *graph;
   int	  cmd_no;
{
   int ret_code = 1;

   if (graph != active_graph) {
      ret_code = send_message();   /* new command to be issued to a	*/
      Reset_All();		   /* different window, so flush buffer */
      active_graph = graph;	   /* of previous window.		*/
      last_command = cmd_no;
   }
   else {
     if (last_command != cmd_no) {    /* graphics command being issued	*/
	ret_code = send_message();    /* differs from previous command	*/
	Reset_All();		      /* so flush buffer containing	*/
	last_command = cmd_no;	      /* previous commands.		*/
     }
   }

   return(ret_code);
}


/**************************************************************************/
/*  get_valid_graph_name						  */
/*									  */
/*    Parameters  :  temp						  */
/*			 Returns a unique name for a graphic window.	  */
/*									  */
/*    Function	  :  Generates a name for a graphic window, using "Graph" */
/*		     as a name, and generating a unique extension for the */
/*		     name. (i.e. Graph.xxx where xxx is a unique number)  */
/*		     A Locate is done on each name generated, until a	  */
/*		     non-exisiting name is found.			  */
/*									  */
/*		     Called by OpenGraph.				  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/


word get_valid_graph_name(temp)
   char *temp;
{
   Object *new_file = Locate(NULL, "/graphics");   /* find graphics server */
   char    path_name[40];
   int     num_graphs;

   for (num_graphs = 1; new_file != (Object *) NULL; num_graphs++) {
      sprintf(temp, "%s.%d","Graph", num_graphs);   /* Unique name? */
      path_name[0] = '\0';
      strcpy(&(path_name[0]), "/graphics/");   /* set up path name for	    */
      strcat(path_name, temp);		       /* Locate.		    */
      new_file = Locate(NULL, path_name);      /* Does generated name exist */
   }
   return(num_graphs);
}


/**************************************************************************/
/*  GetMaxX								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  Width of the screen device. eg. for VGA = 640	  */
/*									  */
/**************************************************************************/


word GetMaxX()
{
   return(MaxX)	;
}


/**************************************************************************/
/*  GetMaxY								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of the screen device. eg. for VGA = 480	  */
/*									  */
/**************************************************************************/


word GetMaxY()
{
   return(MaxY);
}      


/**************************************************************************/
/*  GetCaptionSize							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of the caption bar				  */
/*									  */
/**************************************************************************/


word GetCaptionSize()
{
   return(CaptionSize);
}      


/**************************************************************************/
/*  GetMenuSize								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of the menu bar				  */
/*									  */
/**************************************************************************/


word GetMenuSize()
{
   return(MenuSize);
}      


/**************************************************************************/
/*  GetSwapButton							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  true or false indicating whether the mouse buttons   */
/*                   should be swapped					  */
/*									  */
/**************************************************************************/


word GetSwapButton()
{
   return(SwapButton);
}      


/**************************************************************************/
/*  GetResizeFrameX							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  width of resizable frame border 			  */
/*									  */
/**************************************************************************/


word GetResizeFrameX()
{
   return(ResizeFrameX);
}      


/**************************************************************************/
/*  GetResizeFrameY							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of the resizable frame border		  */
/*									  */
/**************************************************************************/


word GetResizeFrameY()
{
   return(ResizeFrameY);
}      


/**************************************************************************/
/*  GetBorderFrameX							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  width of non-resizable border			  */
/*									  */
/**************************************************************************/


word GetBorderFrameX()
{
   return(BorderFrameX);
}      


/**************************************************************************/
/*  GetBorderFrameY							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  height of non-resizable border			  */
/*									  */
/**************************************************************************/


word GetBorderFrameY()
{
   return(BorderFrameY);
}      


/**************************************************************************/
/*  FLUSH								  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Flushes the graphics buffer.			  */
/*									  */
/*		     Called by User, or whenever buffer needs to be	  */
/*		     flushed.						  */
/*									  */
/*    Returns	  :  1 if buffer successfully flushed, 0 if not.	  */
/*									  */
/**************************************************************************/


int FLUSH()
{
   int ret_val;

   if ((control_size < 1) && (data_size < 1)) {
      Reset_All();     /* No data in buffer, so just reset */
      return(1);
   }

   ret_val = send_message();   /* flush buffer */
   Reset_All(); 	       /* reset        */
   return(ret_val);
}

/**************************************************************************/
/*   EnableMouse		Internal to Helios                        */
/**************************************************************************/

int EnableMouse(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);
   MCB m;
   word Control[1];
      
   if (!mouse_available)   return(FALSE);

   if (graph_node == (GraphNode *)NULL)   return(FALSE);
      
   /* now send the message to the handler to enable the mouse */
   InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
               MSWin_Server->Reply, FG_EnableMouse);
   m.Control = Control;
   Control[0] = graph_node->WinID;
   m.MsgHdr.ContSize = 1;
   m.Timeout = OneSec*5;  /* five seconds for the server to respond */
      
   if (PutMsg(&m) != EK_Timeout)
      return(TRUE);
   else
      return(FALSE);
}

/**************************************************************************/
/*   DisableMouse		Internal to Helios                        */
/**************************************************************************/

int DisableMouse(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   MCB m;
   word Control[1];
   
   if (!mouse_available)   return(FALSE);

   if (graph_node == (GraphNode *) NULL) return(FALSE);

   /* now send the message to the handler to disable the mouse */
   InitMCB(&m, 0, MSWin_Server->Server, NullPort, FG_DisableMouse);
   m.Timeout = OneSec*5;  /* five seconds for the server to respond */
   m.Control = Control;
   m.MsgHdr.ContSize = 1;
   Control[0] = graph_node->WinID;
   m.Timeout = OneSec*5;
      
   if (PutMsg(&m) != EK_Timeout)
      return(TRUE);
   else
      return(FALSE);
}

/**************************************************************************/
/*   HandleMouseEvents		Internal to Helios                        */
/**************************************************************************/

void HandleMouseEvents(port, fn)
   Port port;
   VoidFnPtr fn;
{
   IOEvent Buffer;
   IOEvent *event = (IOEvent *)&(Buffer);
   MSMouse_Event *mouse = (MSMouse_Event *)&(event->Device.Mouse);
   MCB m;

   forever {
      InitMCB(&m, MsgHdr_Flags_preserve, port, NullPort, 0);
      m.Data = (char *)&(Buffer);
      m.Timeout = OneSec * 1800;   /* stream timeout */
            
      if (GetMsg(&m) == Err_Null) {
         /* data received - call function */
         if (fn != (VoidFnPtr)NULL)
            fn(mouse->WinID, mouse->X, mouse->Y, mouse->Buttons);
      }
   }
}

int MSMouseSupported(void)
{
   int ret_val = mouse_available;
   return(ret_val);
}


/**************************************************************************/
/*   HandleMSEvents		Internal to Helios                        */
/**************************************************************************/

void HandleMSEvents(port, fn)
   Port port;
   VoidFnPtr fn;
{
   IOEvent Buffer;
   IOEvent *event = (IOEvent *)&(Buffer);
   MSEvent *msevents = (MSEvent *)&(event->Device.Mouse);
   MCB m;

   forever {
      InitMCB(&m, MsgHdr_Flags_preserve, port, NullPort, 0);
      m.Data = (char *)&(Buffer);
      m.Timeout = OneSec * 1800;   /* stream timeout */
            
      if (GetMsg(&m) == Err_Null) {
         /* data received - call function */
         if (fn != (VoidFnPtr)NULL)
            fn(msevents->Type, msevents->WinID, msevents->Word1, msevents->Word2);
      }
   }
}


int MSEventSupported(void)
{
   int ret_val = msevent_available;
   return(ret_val);
}


/**************************************************************************/
/*  OpenGraph					Command number = 0	  */
/*									  */
/*    Parameters  :  graph_name 					  */
/*			Caption for the graphic window			  */
/*		     xstart, ystart					  */
/*			Position of top left hand corner of window	  */
/*		     width						  */
/*			Width of window.				  */
/*		     height						  */
/*			Height of window.				  */
/*		     border						  */
/*			Type of border surrounding window		  */
/*									  */
/*    Function	  :  Opens a graphic window.				  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  A pointer uniquely identifying the window if the	  */
/*		     window was opened successfully. A NULL pointer if	  */
/*		     the window failed to open. 			  */
/*									  */
/**************************************************************************/


Stream *OpenGraph(graph_name, xstart, ystart, width, height, border, show_mode)
   BYTE *graph_name;
   word  xstart, ystart, width, height, border, show_mode;
{
   Object     *graph_obj;	/* Object structure for the graphics server */
   Stream     *graph_stream;	/* To hold unique id of graphic window	    */
   BYTE       temp[15]; 	/* To hold the unique window name	    */
   int        id_no;            /* the id number of the current window      */
   MCB        m;                /* to send data to MSWIN server             */
   word       Control[1];       /* control buffer			    */

   if (!initialised) return((Stream *)NULL);

   if (!graphics_availiable) return((Stream *) NULL);

   Wait(&sem);

   FLUSH();  /* Flush buffer of previous window */

   id_no = get_valid_graph_name(&(temp[0]));  /* generate unique window name */

   graph_obj = Locate(NULL, "/graphics");    /* find graphics server */
   if (graph_obj == (Object *) NULL) {
      Signal(&sem);
      return((Stream *) NULL);
   }

	/* Open a stream for accessing the window */
   graph_stream = Open(graph_obj, temp, O_ReadWrite | O_Create);
   if (graph_stream == (Stream *) NULL) {
      Close(graph_obj);
      Signal(&sem);
      return((Stream *) NULL);
   }

/* Now get information pertaining to the window just opened! */

   if (ObjectInfo(graph_obj, temp, data_vector) != Err_Null) {
      Close(graph_obj);
      Close(graph_stream);
      Signal(&sem);
      return((Stream *) NULL);
   }

   Close(graph_obj);

		 /* Add new window to list of open graphic windows */
   if (!add_to_list(id_no, graph_stream, temp, data_vector)) {
      Close(graph_stream);
      Signal(&sem);
      return((Stream *) NULL);
   }

   if (graph_name == (BYTE *) NULL)
     data_size = 0;
   else {
     data_size = strlen(graph_name) + 1;	      /* set up data vector */
     data_vector[0] = '\0';
     strcpy(data_vector, graph_name);
     data_vector[strlen(graph_name)] = '\0';
   }

			   /* set up control vector */
   control_vector[0] = border;   control_vector[1] = xstart;
   control_vector[2] = ystart;	 control_vector[3] = width;
   control_vector[4] = height;	 control_vector[5] = show_mode;
   control_vector[6] = id_no;
   
   control_size = 7;
   last_command = 0;

   active_graph = graph_stream;

   if (!send_message()) {	    /* tell graphic server to open window */
     del_from_list(graph_stream);
     Close(graph_stream);
     Signal(&sem);
     return((Stream *) NULL);
   }

   Reset_All();
  
   if (msevent_available) {
      /* now register the window with the MSWIN server */
      InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
              MSWin_Server->Reply, FG_RegisterWindow);
      m.Control = Control;
      m.MsgHdr.ContSize = 1;
      Control[0] = id_no;
      PutMsg(&m);
   }
  
   Signal(&sem);
   return(graph_stream);
}

/**************************************************************************/
/*  GraphID								  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			Id of window					  */
/*									  */
/*    Function	  :  returns ID word for testing in MSEvents handler	  */
/*									  */
/*    Returns	  :  ID number (word)					  */
/*									  */
/**************************************************************************/

word GraphID(graph_stream)
   Stream *graph_stream;
{
   GraphNode   *graph = valid_stream(graph_stream);  /* Id valid? */
   return( graph->WinID );
}


/**************************************************************************/
/*  CloseGraph								  */
/*									  */
/*    Parameters  :  graph_stream					  */
/*			Id of window to be closed.			  */
/*									  */
/*    Function	  :  Closes a graphic window				  */
/*									  */
/*		     Called by User, or "TidyGraphics". 		  */
/*									  */
/*    Returns	  :  1 if window closed, 0 if not.			  */
/*									  */
/**************************************************************************/


int CloseGraph(graph_stream)
   Stream *graph_stream;
{
   GraphNode   *graph = valid_stream(graph_stream);  /* Id valid? */
   BYTE   *graph_name;	    /* To hold unique window name */
   Object *graph_obj;	    /* Object structure for graphics server */
   word   Control[1];

   if (graph == (GraphNode *) NULL) return(0);
    /* Are we closing a printer stream? */
   if ((graph_stream->Server == 0L) && (graph_stream->Reply == 0L)) {
     active_graph = del_from_list(graph_stream);
     return(1);
   }
   
	 /* If any outstanding commands in buffer, flush buffer */
   Wait(&sem);
   if ((control_size > 0) || (data_size > 0)) send_message();
   graph_name = graph->Name;
   if (mouse_available)
      DisableMouse(graph_stream);
   if (msevent_available) {
      MCB m;
      InitMCB(&m, MsgHdr_Flags_preserve, MSWin_Server->Server, 
              MSWin_Server->Reply, FG_DeregisterWindow);
      m.Control = Control;
      m.MsgHdr.ContSize = 1;
      Control[0] = graph->WinID;
      PutMsg(&m);
   }
      
      
   if ((Close(graph_stream)) != 0) {
      Signal(&sem);
      return(0);	/* Close stream to window */
   }

   graph_obj = Locate(NULL, "/graphics");
   if (graph_obj == (Object *) NULL) {
      Signal(&sem);
      return(0);
   }
   if ((Delete(graph_obj, graph_name)) != 0) {
      Signal(&sem);
      return(0);  /* Close window */
   }
   active_graph = del_from_list(graph_stream);	 /* Remove window from list */
   Signal(&sem);
   return(1);					 /* of open graphic windows */
}


/**************************************************************************/
/*  TidyGraphics							  */
/*									  */
/*    Parameters  :  None.						  */
/*									  */
/*    Function	  :  Closes all open graphic windows, and frees space	  */
/*		     taken up by graphics buffer.			  */
/*									  */
/*		     Called by User.					  */
/*									  */
/*    Returns	  :  1 if successful, 0 if not. 			  */
/*									  */
/**************************************************************************/


int TidyGraphics()
{
  GraphNode *curr_node = Graph_List.next, *next_node;

  if (curr_node == (GraphNode *) NULL) return(1);

     /* Go through list of open graphic windows, and close them */

  for (next_node = curr_node->next; next_node != (GraphNode *) NULL;
       next_node = next_node->next) {
     if (!CloseGraph(curr_node->graph_id)) return(0);
     curr_node = next_node;
  }
  if (!CloseGraph(curr_node->graph_id)) return(0);
  
  Close(MSWin_Server);
  
  Free(data_vector);   /* free space used by graphics buffer */
  return(1);
}


/**************************************************************************/
/*									  */
/*   The vast majority of the functions hereafter, provide the interface  */
/*   between the user issuing graphic commands on the transputer, and	  */
/*   graphics server, implementing the commands.			  */
/*									  */
/*   The functions providing the interface between transputer and server  */
/*   all check to see that the ID of the window they are accessing, is	  */
/*   valid, by calling "valid_stream".					  */
/*									  */
/*   Each function has a unique command number, which is interpreted on   */
/*   server side. Each function does a "check_last_command" call, to	  */
/*   ensure that previously buffered calls are sent before their call is  */
/*   implemented.							  */
/*									  */
/*   Apart from the common ground mentioned above, the function fall into */
/*   two groups, Buffered and Non-buffered functions.			  */
/*									  */
/*   For buffered commands, the structure of the command is set up, i.e.  */
/*   the parameters neccessary to implement the command. The function	  */
/*   will then issue a "buffer_command" call to buffer the command.	  */
/*   Messages are not sent to the server by these commands.		  */
/*									  */
/*   For the non-buffered commands, messages are explicitly sent to the   */
/*   the server, by the function. So the message structure has to be	  */
/*   filled in within the function, and a "send_message" call made.	  */
/*									  */
/*   For the functions providing the interface between transputer and	  */
/*   server, consult the Helios Graphics under MS-WINDOWS Users Manual	  */
/*   for details of the functions of these commands, and the role of the  */
/*   parameters passed to them. 					  */
/*									  */
/**************************************************************************/


/**************************************************************************/
/*   PutPixel	      Command Number = 1				  */
/**************************************************************************/

int PutPixel(graph_stream, x, y, color)
   Stream *graph_stream;
   word   x, y, color;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      params[3];

   if (graph_node == (GraphNode *) NULL) return(0);
   Wait(&sem);
   if (!check_last_command(graph_stream, 1)) {
      Signal(&sem);
      return(0);
   }
   
   params[0] = x;			  /* set up parameters */
   params[1] = y;
   params[2] = color;

   if (!buffer_command(3, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*   MoveTo	      Command Number = 2				  */
/**************************************************************************/

int MoveTo(graph_stream, x, y)
   Stream *graph_stream;
   word   x, y;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 2)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = x;   control_vector[1] = y;  /* set up message */
   control_size = 2;
   data_size = 0;

   ret_val = send_message();	   /* send message to server */
   Reset_All();
   
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  check_line_attributes						  */
/*									  */
/*    Parameters  :  graph_node 					  */
/*			 A node in the list of open graphic windows	  */
/*		     params						  */
/*			 A pointer to an array of words 		  */
/*									  */
/*    Function	  :  Utility that helps to set up the parameters for	  */
/*		     the "buffer_command" call for functions dealing with */
/*		     line drawing operations, in the event of some of the */
/*		     line attributes having changed since the last call.  */
/*									  */
/*		     Normally called by buffered line drawing functions.  */
/*									  */
/*    Returns	  :  the number of parameters inserted into the parameter */
/*		     list.						  */
/*									  */
/**************************************************************************/


word check_line_attributes(graph_node, params)
   GraphNode *graph_node;
   word      *params;
{
   LineAttr *attr = &(graph_node->line_attr);
   word     ret_val;

   if (attr->color_changed || attr->style_changed || attr->width_changed) {
     params[0] = 1;
     params[1] = attr->color;	  /* line attributes have changed since last */
     params[2] = attr->style;	  /* graphics call.			     */
     params[3] = attr->width;
     ret_val = 4;		  /* added four parameters */
   }
   else {
      params[0] = 0;		  /* line attributes have not changed */
      ret_val = 1;		  /* added one parameter	      */
   }

   /* reset attributes changed flags */

   if (attr->color_changed != 0) attr->color_changed = 0;
   if (attr->style_changed != 0) attr->style_changed = 0;
   if (attr->width_changed != 0) attr->width_changed = 0;
   return(ret_val);
}

/**************************************************************************/
/*   LineTo	      Command Number = 3				  */
/**************************************************************************/


int LineTo(graph_stream, x, y)
   Stream *graph_stream;
   word   x, y;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   word      params[6], index;
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 3)) {
      Signal(&sem);
      return(0);
   }

   index = check_line_attributes(graph_node, &params[0]); /* attr. changed? */
   params[index++] = x;  params[index++] = y;
   if (!buffer_command(index, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}   	      
   		     
/**************************************************************************/
/*   DrawLine	      Command Number = 4				  */
/**************************************************************************/


int DrawLine(graph_stream, x1, y1, x2, y2)
   Stream *graph_stream;
   word   x1, y1, x2, y2;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      params[8], index;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 4)) {
      Signal(&sem);
      return(0);
   }

   index = check_line_attributes(graph_node, &params[0]);  /* attr. changed? */

   params[index++] = x1;    params[index++] = y1;
   params[index++] = x2;    params[index++] = y2;
   if (!buffer_command(index, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*   TextOut	      Command Number = 5				  */
/**************************************************************************/

int TextOut(graph_stream, x, y, line)
   Stream *graph_stream;
   word   x, y;
   BYTE   *line;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;
   BYTE      *old_vector;    /* used to save graphics buffer */
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 5)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = x;  control_vector[1] = y;
   if (graph_node->text_attr.color_changed) {	 /* Text color changed */
     control_vector[2] = 1;
     control_vector[3] = graph_node->text_attr.color;
     graph_node->text_attr.color_changed = 0;
     control_size = 4;
   }
   else {
     control_vector[2] = 0;   /* text color has not changed */
     control_size = 3;
   }

   control_vector[control_size++] = strlen(line);  /* set up control vector */
   old_vector  = data_vector;	   /* save graphics buffer */
   data_vector = line;		   /* set up data vector */
   data_size = strlen(line);

   ret_val = send_message();	  /* send message to server */

   data_vector = old_vector;	  /* restore graphics buffer */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   Squares_Circles	       Command Number = 7			  */
/*									  */
/*   Does								  */
/*	   Rectangle	       mode = 0 				  */
/*	   Ellipse	       mode = 1 				  */
/*	   Circle	       mode = 1 				  */
/*									  */
/*   The mode field is interpreted by the graphics server.		  */
/**************************************************************************/


int Squares_Circles(graph_stream, mode, x1, y1, x2, y2)
   Stream *graph_stream;
   word   mode, x1, y1, x2, y2;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      params[9], index;
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 7)) {
      Signal(&sem);
      return(0);
   }

   index = check_line_attributes(graph_node, &params[0]); /* attr. changed? */

   params[index++] = mode;   params[index++] = x1;
   params[index++] = y1;     params[index++] = x2;
   params[index++] = y2;
   if (!buffer_command(index, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}   

/**************************************************************************/
/*   poly_functions	       Command Number = 6			  */
/*									  */
/*   Does								  */
/*	   PolyLine	       mode = 0 				  */
/*	   FillPoly	       mode = 1 				  */
/*									  */
/*   The mode field is interpreted by the graphics server.		  */
/**************************************************************************/


int poly_functions(graph_stream, num_pts, pts, mode)
   Stream *graph_stream;
   word   num_pts, *pts, mode;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      *tmp_pts, index, params[6];

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 6)) {
      Signal(&sem);
      return(0);
   }

      /* will an empty graphics buffer overflow if command implemented? */
   if (((num_pts + 8) * sizeof(word)) > buf_size) {
      Signal(&sem);
      return(0);
   }

   tmp_pts = (word *) Malloc(sizeof(word) * num_pts);
   if (tmp_pts == (word *) NULL) {
      Signal(&sem);
      return(0);
   }

   params[0] = mode;
   index = check_line_attributes(graph_node, &params[1]);  /* attr. changed? */
   params[index + 1] = num_pts;
   if ((data_size + ((index + 3 + num_pts) * sizeof(word))) > buf_size)
       FLUSH();   /* flush buffer if command causes buffer to overflow */
   if (!buffer_command(index + 2, &params[0])) {
	 Free(tmp_pts);
	 Signal(&sem);
	 return(0);
   }
   control_vector[0]--;   /* full command not yet buffered */

   /* Since points for PolyLine and FillPoly calls are only 16 bit integers */
   /* we compress two points into 1 32bit transputer word. */

   for (index = 0; index < num_pts * 2; index += 2)
     tmp_pts[index / 2] = ((pts[index + 1] << 16) + (0xFFFF & pts[index]));

   if (!buffer_command(num_pts, tmp_pts)) {
	  Free(tmp_pts);
	  Signal(&sem);
	  return(0);
   }
   Free(tmp_pts);

   Signal(&sem);
   return(1);
}   

/**************************************************************************/
/*   arc_functions	      Command Number = 8			  */
/*									  */
/*   Does								  */
/*	   Arc		       mode = 1 				  */
/*	   Pie		       mode = 2 				  */
/*	   Chord	       mode = 3 				  */
/*									  */
/*   The mode field is interpreted by the graphics server.		  */
/**************************************************************************/


int arc_functions(graph_stream, xleft, ytop, xright, ybottom,
				xstart, ystart, xend, yend, mode)
   Stream *graph_stream;
   word   xleft, ytop, xright, ybottom, xstart, ystart, xend, yend,
	  mode;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   word      params[13], index;
   
   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 8)) {
      Signal(&sem);
      return(0);
   }

   index = check_line_attributes(graph_node, &params[0]);  /* attr. changed? */
   params[index++] = mode;	   params[index++] = xleft;
   params[index++] = ytop;	   params[index++] = xright;
   params[index++] = ybottom;	   params[index++] = xstart;
   params[index++] = ystart;	   params[index++] = xend;
   params[index++] = yend;

   if (!buffer_command(index, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}


/***************************************************************************/
/*  SetLineColor, SetLineStyle, SetLineWidth				   */
/*									   */
/*  These functions all require two parameters, the first being a pointer  */
/*  to a window, and the second being either a color, style or width.	   */
/*  No messages are sent to the graphics server. If the second parameter   */
/*  value is different from the existing line attribute for that window,   */
/*  then a flag is set indicating a change in the line attributes, and the */
/*  attribute is changed.						   */
/***************************************************************************/



int SetLineColor(graph_stream, color)
   Stream *graph_stream;
   word   color;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   LineAttr  *attr = &(graph_node->line_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (attr->color == color) {
      Signal(&sem);
      return(1);
   }

   attr->color	       = color;
   attr->color_changed = 1;	 /* set color changed flag */

   Signal(&sem);
   return(1);
}



int SetLineStyle(graph_stream, style)
   Stream *graph_stream;
   word   style;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   LineAttr  *attr = &(graph_node->line_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (attr->style == style) {
      Signal(&sem);
      return(1);
   }

   attr->style = style;
   attr->style_changed = 1;    /* set line style changed flag */

   Signal(&sem);
   return(1);
}


int SetLineWidth(graph_stream, width)
   Stream *graph_stream;
   word   width;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   LineAttr  *attr = &(graph_node->line_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (attr->width == width) {
      Signal(&sem);
      return(1);
   }

   attr->width = width;
   attr->width_changed = 1;   /* set line width changed flag */

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*   SetBkColor 	      Command Number = 9			  */
/**************************************************************************/

int SetBkColor(graph_stream, color)
   Stream *graph_stream;
   word   color;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph_stream, 9)) {
      Signal(&sem);
      return(0);
   }

   if (graph_node->BKground.color == color) {
      Signal(&sem);
      return(1);
   }

   control_size = 1;			   /* set up message structure */
   graph_node->BKground.color = color;
   control_vector[0] = color;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();

   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   SetBkMode		      Command Number = 10			  */
/**************************************************************************/

int SetBkMode(graph_stream, mode)
   Stream *graph_stream;
   word   mode;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if ((mode < 1) || (mode > 2)) mode = 2; /*default = OPAQUE mode */
   if (graph_node->BKground.mode == mode) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 10)) {
      Signal(&sem);
      return(0);
   }

   graph_node->BKground.mode = mode;
   control_vector[0] = mode;	     /* set up message structure */
   control_size = 1;
   data_size = 0;

   ret_val = send_message();  /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   SetFillMode	      Command Number = 12			  */
/**************************************************************************/

int SetFillMode(graph_stream, mode)
   Stream *graph_stream;
   word   mode;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if ((mode < ALTERNATE) || (mode > WINDING)) {
      Signal(&sem);
      return(0);
   }
   if (graph_node->fill_attr.mode == mode) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 12)) {
      Signal(&sem);
      return(0);
   }

   graph_node->fill_attr.mode = mode;
   control_vector[0] = mode;	     /* set up message structure */
   control_size = 1;
   data_size = 0;

   ret_val = send_message();	/* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   SetFillAttr	      Command Number = 11			  */
/**************************************************************************/

int SetFillAttr(graph_stream, style, color)
   Stream *graph_stream;
   word   style, color;
{
   GraphNode *graph_node = valid_stream(graph_stream);
   int	   ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
     /* dont send message if nothing is to change */
   if ((color == graph_node->fill_attr.color) &&
       (style == graph_node->fill_attr.style)) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 11)) {
      Signal(&sem);
      return(0);
   }

   graph_node->fill_attr.style = style;
   control_vector[0] = style;
   graph_node->fill_attr.color = color;
   control_size = 2;			 /* set up message structure */
   control_vector[1] = color;
   data_size = 0;

   ret_val = send_message();	/* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/***************************************************************************/
/* SetTextColor 							   */
/*									   */
/* The function does not send a message to the graphics server, but rather */
/* checks to see if the new text color is different from the previos text  */
/* color. If that is the case, then a flag is set saying the text color    */
/* has changed, and the new color is inserted in the attribute list of the */
/* graphic window. When the next TextOut call is made, this new text color */
/* will be incorporated into the TextOut command.			   */
/***************************************************************************/


int SetTextColor(graph_stream, color)
   Stream *graph_stream;
   word   color;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */

   if (graph_node == (GraphNode *) NULL) return(0);

   if ((color < BLACK) || (color > WHITE)) return(0);

   Wait(&sem);
   if (graph_node->text_attr.color == color) {
      Signal(&sem);
      return(1);
   }

   graph_node->text_attr.color = color;
   graph_node->text_attr.color_changed = 1;  /* set text color changed flag */

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*   SetTextOps 	      Command Number = 13			  */
/*									  */
/*   Does								  */
/*	 SetTextSpacing       Mode = 0					  */
/*	 SetTextAlign	      Mode = 1					  */
/*									  */
/*   Mode is interpreted by the graphics server.			  */
/**************************************************************************/

int SetTextOps(graph_stream, value, mode)
   Stream *graph_stream;
   word   value, mode;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (mode == 0) {
      if (value < 0) {
         Signal(&sem);
         return(0);	  /* cannot have -ve spacing */
      }
      graph_node->text_attr.spacing = value;
   }
   else {     /* are align values valid? */
     if ((value != LEFT) && (value != RIGHT) && (value != CENTRE)) {
        Signal(&sem);
        return(0);
     }
     graph_node->text_attr.align = value;
   }

   if (!check_last_command(graph_stream, 13)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = mode;	  /* set up message structure */
   control_vector[1] = value;
   control_size = 2;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*  check_font								  */
/*									  */
/*    Parameters  :  font						  */
/*			 A pointer to a FONT structure. 		  */
/*									  */
/*    Function	  :  Utility that checks the values in the FONT structure */
/*		     and sets defaults in invalid fields of the structure */
/*									  */
/*		     Called by "CreateFont".				  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/

void check_font(font)
   FONT *font;
{
   UBYTE family, pitch;

   if ((font->tilt < 0) || (font->tilt > 3600)) font->tilt = 0;
   if ((font->orientation < 0) || (font->orientation > 3600))
      font->orientation = 0;
   if ((font->weight != W_NORMAL) && (font->weight != W_BOLD))
      font->weight = W_NORMAL;
   if (font->italic != 1) font->italic = 0;
   if (font->underline != 1) font->underline = 0;
   if (font->strikeout != 1) font->strikeout = 0;
   if ((font->charset != OEM_CHAR) && (font->charset != ANSI_CHAR))
       font->charset = ANSI_CHAR;
   if ((font->quality != Q_DEFAULT) && (font->quality != Q_DRAFT) &&
       (font->quality != Q_PROOF)) font->quality = Q_DEFAULT;

   if ((font->OutPrecision < OUT_DEFAULT) && (font->OutPrecision > OUT_STROKE))
      font->OutPrecision = OUT_DEFAULT;

   if ((font->ClipPrecision < CLIP_DEFAULT) && (font->ClipPrecision > CLIP_STROKE))
      font->ClipPrecision = CLIP_DEFAULT;

   pitch = font->pitch_family & 15;
   family = font->pitch_family & 240;
   family >>= 4;

   if ((pitch != P_DEFAULT) && (pitch != P_FIXED) &&(pitch != P_VARIABLE))
      pitch = P_DEFAULT;

   if ((family < 0) || (family > 5)) family = ANYONE;
     else
	 family <<= 4;

   font->pitch_family = family | pitch;
}


/**************************************************************************/
/*   FontOps		      Command Number = 14			  */
/*									  */
/*   Does								  */
/*	 SelectFont	      font_type = other fonts			  */
/*	 CreateFont	      font_type = USER_FONT			  */
/*									  */
/*   font_type is interpreted by the graphics server.			  */
/**************************************************************************/

int font_ops(graph_stream, font_type, font)
   Stream *graph_stream;
   word   font_type;
   FONT   *font;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   int	     ret_val;
   BYTE      *old_vector;  /* to save graphics buffer */


   if (graph_node == (GraphNode *) NULL) return(0);

      /* invalid font_type parameter? */
   if ((font_type < OEM_FIXED) || (font_type > USER_FONT)) return(0);

   Wait(&sem);
      /* Selecting font already in existence? */
   if ((font_type != USER_FONT) &&
       (font_type == graph_node->text_attr.font_type)) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 14)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = font_type;
   control_size = 1;

   if (font_type != USER_FONT) {
      graph_node->text_attr.font_type = font_type;
      data_size = 0;			    /* SelectFont's code */
      ret_val = send_message();    /* send message to server */
      Reset_All();
   }
   else {
     if (font == (FONT *) NULL) {
        Signal(&sem);
        return(0);  /* CreatFont's code */
     }
     check_font(font);

     graph_node->text_attr.font_type = font_type;
     graph_node->text_attr.font      = font;

     old_vector  = data_vector;     /* save graphics buffer */
     data_vector = (BYTE *) font;   /* FONT structure becomes data vector */
     data_size = sizeof(FONT);
     ret_val = send_message();	   /* send message to server */
     Reset_All();
     data_vector = old_vector;	   /* restore graphics buffer */
   }
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   SetMapMode 	      Command Number = 15			  */
/**************************************************************************/

int SetMapMode(graph_stream, mode)
   Stream *graph_stream;
   word   mode;
{
   GraphNode *graph_node = valid_stream(graph_stream); /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

       /* default mapping mode is M_TEXT */
   if ((mode < M_TEXT) || (mode > M_ANISOTROPIC)) mode = M_TEXT;

   Wait(&sem);
       /* mapping mode already in existence? */
   if (mode == graph_node->map_attr.mode) {
      Signal(&sem);
      return(1);
   }

   if (!check_last_command(graph_stream, 15)) {
      Signal(&sem);
      return(0);
   }

   graph_node->map_attr.mode = mode;
   control_vector[0] = mode;	     /* set up message structure */
   control_size = 1;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   SetDeviceOrigins	      Command Number = 16			  */
/*									  */
/*   Does								  */
/*	 SetDeviceOrg	      org_type = other fonts			  */
/*	 SetLogicalOrg	      org_type = USER_FONT			  */
/*									  */
/*   org_type is interpreted by the graphics server.			  */
/**************************************************************************/

int SetDeviceOrigins(graph_stream, x, y, org_type)
   Stream *graph_stream;
   word   x, y, org_type;
{
   GraphNode *graph_node = valid_stream(graph_stream);	/* ID valid? */
   int	     ret_val;
   MapAttr   *attr = &(graph_node->map_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
      /* Are the origins already what is desired? */
   if (org_type == DEVICE) {
     if ((attr->window_org[0] == x) && (attr->window_org[1] == y)) {
        Signal(&sem);
        return(1);
     }
   }
   else {
     if ((attr->viewprt_org[0] == x) && (attr->viewprt_org[1] == y)) {
        Signal(&sem);
        return(1);
     }
   }

   if (!check_last_command(graph_stream, 16)) {
      Signal(&sem);
      return(0);
   }

   if (org_type == DEVICE) {			/* SetDeviceOrg code */
       graph_node->map_attr.window_org[0] = x;
       graph_node->map_attr.window_org[1] = y;
       control_vector[0] = 0;
   }
   else {					/* SetLogicalOrg code */
       graph_node->map_attr.viewprt_org[0] = x;
       graph_node->map_attr.viewprt_org[1] = y;
       control_vector[0] = 1;
   }

   control_vector[1] = x;   control_vector[2] = y;
   control_size = 3;		 /* set up message structure */
   data_size = 0;

   ret_val = send_message();	/* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   SetDeviceExtents	      Command Number = 17			  */
/*									  */
/*   Does								  */
/*	 SetDeviceExt	      org_type = other fonts			  */
/*	 SetLogicalExt	      org_type = USER_FONT			  */
/*									  */
/*   ext_type is interpreted by the graphics server.			  */
/**************************************************************************/

int SetDeviceExtents(graph_stream, x, y, ext_type)
   Stream *graph_stream;
   word   x, y, ext_type;
{
   GraphNode *graph_node = valid_stream(graph_stream);	 /* ID valid? */
   int	     ret_val;
   MapAttr   *attr = &(graph_node->map_attr);

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
       /* Extents only apply to M_ISOTROPIC & M_ANISOTROPIC */
   if (graph_node->map_attr.mode < M_ISOTROPIC) {
      Signal(&sem);
      return(0);
   }

      /* are extents already what is desired? */
   if (ext_type == DEVICE) {
      if ((attr->window_ext[0] == x) && (attr->window_ext[1] == y)) {
         Signal(&sem);
         return(0);
      }
   }
   else {
      if ((attr->viewprt_ext[0] == x) && (attr->viewprt_ext[1] == y)) {
         Signal(&sem);
         return(0);
      }
   }

   if (!check_last_command(graph_stream, 17)) {
      Signal(&sem);
      return(0);
   }

   if (ext_type == DEVICE) {		       /* SetDeviceExt code */
      graph_node->map_attr.window_ext[0] = x;
      graph_node->map_attr.window_ext[1] = y;
      control_vector[0] = 0;
   }
   else {				       /* SetLogicalExt code */
      graph_node->map_attr.viewprt_ext[0] = x;
      graph_node->map_attr.viewprt_ext[1] = y;
      control_vector[0] = 1;
   }

   control_vector[1] = x;  control_vector[2] = y;
   control_size = 3;			    /* set up message structure */
   data_size = 0;

   ret_val = send_message();	 /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*   get_two_words	      Command Number = mess_no			  */
/*									  */
/*   Does								  */
/*	 GetWindowSize	      mess_no = 18				  */
/*	 GetXY		      mess_no = 19				  */
/*									  */
/*   mess_no is the command number sent to the server.			  */
/**************************************************************************/


int get_two_words(graph, x, y, mess_no)
   Stream *graph;
   word   *x, *y, mess_no;
{
   GraphNode *graph_node = valid_stream(graph);  /*ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, mess_no)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;	       /* set up message structure */
   data_size = 0;
   ret_val = send_message();

   *x = mcb.Control[0];       /* retrieve two words sent by graphics server */
   *y = mcb.Control[1];       /* from Message Control Block */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   get_text_attr							  */
/*									  */
/*   Does								  */
/*	 GetTextColor	      mess_no = 1				  */
/*	 GetTextAlign	      mess_no = 2				  */
/*	 GetTextSpacing       mess_no = 3				  */
/*	 GetFont	      mess_no = 4				  */
/**************************************************************************/

word get_text_attr(graph, mess_no)
   Stream *graph;
   word   mess_no;
{
   GraphNode *graph_node = valid_stream(graph);    /* ID valid? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   switch (mess_no) {
      case 1  : ret_val = graph_node->text_attr.color;   /* GetTextColor */
		break;
      case 2  : ret_val = graph_node->text_attr.align;   /* GetTextAlign */
		break;
      case 3  : ret_val = graph_node->text_attr.spacing; /* GetTextSpacing */
		break;
      case 4  : if (graph_node->text_attr.font_type == USER_FONT) /* GetFont */
		   ret_val = (word) graph_node->text_attr.font;  /* Font selected */
		 else					       /* by CreateFont */
		   ret_val = graph_node->text_attr.font_type; /* Font selected */
		 break; 				    /* by SelectFont */
      default : ret_val = 0;
                break;
   }
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   get_fill_attr							  */
/*									  */
/*   Does								  */
/*	 GetFillColor	      mess_no = 1				  */
/*	 GetFillStyle	      mess_no = 2				  */
/*	 GetFillMode	      mess_no = 3				  */
/**************************************************************************/

word get_fill_attr(graph, mess_no)
   Stream *graph;
   word   mess_no;
{
   GraphNode *graph_node = valid_stream(graph);     /* ID valid? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   switch (mess_no) {
      case 1  : ret_val = graph_node->fill_attr.color;   /* GetFillColor */
		break;
      case 2  : ret_val = graph_node->fill_attr.style;   /* GetFillStyle */
		break;
      case 3  : ret_val = graph_node->fill_attr.mode;    /* GetFillMode */
		break;
      default : ret_val = 0;
                break;
   }
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   get_line_attr							  */
/*									  */
/*   Does								  */
/*	 GetLineColor	      mess_no = 1				  */
/*	 GetLineStyle	      mess_no = 2				  */
/*	 GetLineWidth	      mess_no = 3				  */
/**************************************************************************/

word get_line_attr(graph, mess_no)
   Stream *graph;
   word   mess_no;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid ? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   switch (mess_no) {
      case 1  : ret_val = graph_node->line_attr.color;   /* GetLineColor */
		break;
      case 2  : ret_val = graph_node->line_attr.style;   /* GetLineStyle */
		break;
      case 3  : ret_val = graph_node->line_attr.width;   /* GetLineWidth */
		break;
      default : ret_val = 0;
                break;
   }
   Signal(&sem);
   return(ret_val);
}


word GetMapMode(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   ret_val = graph_node->map_attr.mode;
   Signal(&sem);
   return(ret_val);	/* return window's mapping mode */
}

/**************************************************************************/
/*   org_and_ext	      Command Number = 24			  */
/*									  */
/*   Does								  */
/*	 GetLogicalOrg	      mess_no = 1				  */
/*	 GetDeviceOrg	      mess_no = 2				  */
/*	 GetLogicalExt	      mess_no = 3				  */
/*	 GetDeviceExt	      mess_no = 4				  */
/**************************************************************************/

int org_and_ext(graph, x, y, mess_no)
   Stream *graph;
   word   *x, *y, mess_no;
{
   GraphNode *graph_node = valid_stream(graph);    /* ID valid? */
   int	      ret_val = 1;

   if (graph_node == (GraphNode *) NULL) return(0);

      /* Don't need to send a message to server if looking for orgins or */
      /* if looking for extents in any of the non metric mapping modes	 */

   Wait(&sem);
   if ((mess_no < 3) || (graph_node->map_attr.mode == M_TEXT) ||
			(graph_node->map_attr.mode == M_ANISOTROPIC)) {
     switch (mess_no) {
	case 1	: *x = graph_node->map_attr.window_org[0];   /* GetLogicalOrg */
		  *y = graph_node->map_attr.window_org[1];
		  break;
	case 2	: *x = graph_node->map_attr.viewprt_org[0]; /* GetDeviceOrg */
		  *y = graph_node->map_attr.viewprt_org[1];
		  break;
	case 3	: *x = graph_node->map_attr.window_ext[0];  /* GetLogicalExt */
		  *y = graph_node->map_attr.window_ext[1];
		  break;
	case 4	: *x = graph_node->map_attr.viewprt_ext[0]; /* GetDeviceExt */
		  *y = graph_node->map_attr.viewprt_ext[1];
		  break;
	default : Signal(&sem);
	          return(0);
     }
   }
   else {   /* must send message if get extents using the metric mapping modes*/
      if (!check_last_command(graph, 24)) {
         Signal(&sem);
         return(0);
      }
      if (mess_no == 3) control_vector[0] = 0;
	else
	 control_vector[0] = 1;
      control_size = 1;
      data_size = 0;

      ret_val = send_message();   /* send message to server */
      *x = mcb.Control[0];   *y = mcb.Control[1];   /* retrieve extents from */
      Reset_All();				    /* server. */
   }
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   get_bk_attr							  */
/*									  */
/*   Does								  */
/*	 GetBkColor	      mess_no = 1				  */
/*	 GetBkMode	      mess_no = 2				  */
/**************************************************************************/

word get_bk_attr(graph, mess_no)
   Stream *graph;
   word   mess_no;
{
   GraphNode *graph_node = valid_stream(graph);    /* ID valid ? */
   word ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   switch (mess_no) {
      case 1  : ret_val = graph_node->BKground.color;   /* GetBkColor */
		break;
      case 2  : ret_val = graph_node->BKground.mode;    /* GetBkMode */
		break;
      default : ret_val = 0;
                break;
   }
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*   GetTextDim 		     Command Number = 20		  */
/**************************************************************************/

int GetTextDim(graph, textdim)
   Stream  *graph;
   TextDim *textdim;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 20)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;
   data_size = 0;

   ret_val = send_message();	/* send message to graphics server */

   textdim->height	     = mcb.Control[0];	  /* retrieve text   */
   textdim->ave_width	     = mcb.Control[1];	  /* dimensions from */
   textdim->ascent	     = mcb.Control[2];	  /* the graphics    */
   textdim->descent	     = mcb.Control[3];	  /* server	     */
   textdim->internal_leading = mcb.Control[4];
   textdim->external_leading = mcb.Control[5];

   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  MessageBox		       Command Number = 21			  */
/**************************************************************************/

int MessageBox(graph, text, caption, flags)
   Stream *graph;
   char *text, *caption;
   word flags;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;
   char      sbuffer[255], *old_vect;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 21)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = strlen(text);
   if (caption == (char *)NULL)
      control_vector[1] = 1;
   else
      control_vector[1] = strlen(caption);
   control_vector[2] = flags;
   control_size = 3;
   
   old_vect = &data_vector[0];
   data_vector = &sbuffer[0];
   
   sbuffer[0] = '\0';
   strcpy(sbuffer, text);
   strcat(sbuffer, " ");
   strcat(sbuffer, caption);
   /* if no caption, insert a space as caption */
   if (caption == (char *)NULL)
      sbuffer[control_vector[0]+control_vector[1]] = ' ';
   data_size = control_vector[0] + control_vector[1] + 1;

   Timeout = OneSec * 1800;      /* Stream timeout */
   ret_val = send_message();
   Timeout = OneSec * 60;        /* reset the timeout */
   ret_val = mcb.Control[0];
   
   data_vector = old_vect;
   Reset_All();
   
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  squash_bits 							  */
/*									  */
/*    Parameters  :  num_bits						  */
/*			 The number of bits to be compressed		  */
/*		     bits						  */
/*			 A pointer to an array of 1' & 0's.		  */
/*		     bytes						  */
/*			 A pointer to the array which will contain the	  */
/*			 compressed bits.				  */
/*									  */
/*    Function	  :  Utility that takes an array of 'bits', i.e. 1's and  */
/*		     0's, where each 1 or 0 is a byte, and compresses the */
/*		     'bits' so that there are 8 1's and/or 0's in a byte. */
/*		     The compressed 'bits' are returned in the array	  */
/*		     pointed to by "bytes".				  */
/*									  */
/*		     Called by "CreateBitMap".				  */
/*									  */
/*    Returns	  :  Nothing.						  */
/*									  */
/**************************************************************************/

void squash_bits(num_bits, bits, bytes)
   word num_bits;
   BYTE *bits, *bytes;
{
   BYTE  temp_byte;
   int	 ct, count;

   for (ct = 0; ct < num_bits;) {   /* go through all the bits */
      temp_byte = 0;
      for (count = 0; (count < 8) && ((ct + count) < num_bits); count ++) {
      	 temp_byte = temp_byte << 1;   /* shift byte left 1 */
	 if (*bits == '0') *bits = (BYTE) 0;
	 if (*bits == '1') *bits = (BYTE) 1;
	 if (*bits++ > 0) temp_byte = temp_byte + 1;   /* set leftmost bit */
	    else				      /* in byte	  */
		temp_byte = temp_byte + 0;
      }
      *bytes++ = temp_byte;   /* put byte in array pointed to by "bytes" */
      ct += 8;
   }
   bytes--;
   for (ct = 0; ct < (8 - (num_bits % 8)); ct++)  /* if num_bits % 8 <> 0, */
      *bytes = *bytes << 1;                /* shift bits to most significant */
}                                          /* bit in last byte */

/**************************************************************************/
/*  CreateBitMap							  */
/**************************************************************************/

BITMAP *CreateBitMap(width, height, planes, bits_pix, bits)
   word  width, height, planes, bits_pix;
   BYTE  *bits;
{
   BYTE   *pixels;
   BITMAP *bitmap;
   word   num_bits, byte_width, size_bits;

   bitmap = (BITMAP *) Malloc(sizeof(BITMAP));	    /* memory for the BITMAP */
   if (bitmap == (BITMAP *) NULL)		    /* structure	     */
      return((BITMAP *) NULL);

   byte_width = (width * bits_pix + 15) / 16 * 2;  /* even number of bytes */
						   /* per scan line!	   */
   bitmap->width      = width;
   bitmap->height     = height; 	   /* Fill in the BITMAP structure */
   bitmap->planes     = planes;
   bitmap->bits_pix   = bits_pix;
   bitmap->byte_width = byte_width;
   bitmap->bits       = (BYTE *) NULL;

   num_bits   = width * height * planes * bits_pix;  /* no. bits in "bits" */
   size_bits  = byte_width * height * planes;	/* size of MS-WINDOWS	   */
   pixels = Malloc(size_bits);			/* compatible bitmap	   */
   if (pixels == (BYTE *) NULL) {
     Free(bitmap);
     return((BITMAP *) NULL);
   }
   bitmap->bits = pixels;

   if (bits != (BYTE *) NULL)
      memcpy(pixels, bits, (size_t)size_bits);
      
   return(bitmap);
}

/**************************************************************************/
/*  CreateDIBitMap							  */
/**************************************************************************/

BITMAP *CreateDIBitMap(graph, width, height)
   Stream *graph;
   word  width, height;
{
   BYTE   *pixels;
   BITMAP *bitmap;
   word   num_bits;
   word byte_width, size_bits;
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word bits_pix = graph_node->info[5];
   word planes = graph_node->info[6];

   if (graph_node == (GraphNode *) NULL) return(0);

   bitmap = (BITMAP *) Malloc(sizeof(BITMAP));	    /* memory for the BITMAP */
   if (bitmap == (BITMAP *) NULL)		    /* structure	     */
      return((BITMAP *) NULL);

   byte_width = (width * bits_pix + 15) / 16 * 2;  /* even number of bytes */
						   /* per scan line!	   */
   bitmap->width      = width;
   bitmap->height     = height; 	   /* Fill in the BITMAP structure */
   bitmap->planes     = planes;
   bitmap->bits_pix   = bits_pix;
   bitmap->byte_width = byte_width;
   bitmap->bits       = (BYTE *) NULL;

   num_bits   = width * height * planes * bits_pix;  /* no. bits in "bits" */
   size_bits  = byte_width * height * planes;	/* size of MS-WINDOWS	   */
   pixels = Malloc(size_bits);			/* compatible bitmap	   */
   if (pixels == (BYTE *) NULL) {
     Free(bitmap);
     return((BITMAP *) NULL);
   }
   bitmap->bits = pixels;

   return(bitmap);
}

/**************************************************************************/
/*  DeleteBitMap 							  */
/**************************************************************************/

void DeleteBitMap(bitmap)
   BITMAP *bitmap;
{
   if (bitmap != (BITMAP *)NULL) {
      if (bitmap->bits != NULL)  Free(bitmap->bits);
      Free(bitmap);
      bitmap = (BITMAP *) NULL;
   }
}

/**************************************************************************/
/*  SetBitMapBits							  */
/**************************************************************************/

int SetBitMapBits(bitmap, bits)
   BITMAP *bitmap;
   BYTE   *bits;
{
   word size_bits;

   if (bitmap == (BITMAP *) NULL) return(0);
   
   size_bits = bitmap->byte_width * bitmap->height * bitmap->planes;
   memcpy(bitmap->bits, bits, size_bits);

   return(size_bits/8);    /* return the no of bytes used */
}


/**************************************************************************/
/*  determine_max_block        Command Number = 29			  */
/*									  */
/*  This function is called by the Graphics Library, to determine the	  */
/*  largest block of memory availiable on the server, and is used when	  */
/*  sending data for a bitmap down the link. The largest block will be	  */
/*  the size of the message buffer if there is more memory availiable on  */
/*  the PC than the size of the message buffer on the PC, or the amount   */
/*  of memory left on the PC, if the memory left is less than the size of */
/*  the message buffer. 						  */
/*									  */
/**************************************************************************/

int determine_max_block(graph)
   Stream *graph;
{
   int ret_val;

   if (!check_last_command(graph, 29))  return(0);

   control_size = 1;
   data_size = 0;
   if (!send_message()) {	/* send message to server */
      Reset_All();		/* if function fails on server, no memory */
      return(0);		/* left on server. */
   }
   ret_val = control_vector[0];   /* Get size returned by server */
   Reset_All();
   return(ret_val);
}



/**************************************************************************/
/*  send_bitmap 							  */
/*									  */
/*    Parameters  :  graph						  */
/*			 The ID of the window receiving a bitmap.	  */
/*		     bitmap						  */
/*			 A pointer to BITMAP structure defining a bitmap. */
/*		     x							  */
/*			 X co-ordinate the bitmap is drawn from 	  */
/*		     y							  */
/*			 Y co-ordinate the bitmap is drawn from 	  */
/*		     rop						  */
/*			 ROP code bitmap is drawn with. 		  */
/*									  */
/*    Function	  :  The function is called if the bitmap to be drawn	  */
/*		     cannot be drawn in one go, but has to sent to the	  */
/*		     server in smaller blocks.				  */
/*									  */
/*		     Called by "DrawBitMap".				  */
/*									  */
/*    Returns	  :  1 if bitmap successfully drawn, 0 if not.		  */
/*									  */
/**************************************************************************/

int send_bitmap(graph, bitmap, x, y, rop, max_block)
   Stream *graph;
   BITMAP *bitmap;
   word   x, y, rop, max_block;
{
   BYTE *block, *old_vector, **plane_ptr;
   word scan_width, lines_block, bytes_plane;
   int	ret_val, ct, count, counter;

   if (!check_last_command(graph, 22))  return(0);

   block = Malloc(max_block);
   if (block == (BYTE *) NULL)  return(0);
   
   plane_ptr = Malloc(sizeof(BYTE *) * bitmap->planes);
   if (plane_ptr == NULL) {
     Free(block);
     return(0);
   }

   scan_width	= bitmap->byte_width;	 /* bytes per scan line */
   lines_block	= max_block / scan_width / bitmap->planes; /* scan lines/block*/
   bytes_plane	= scan_width * bitmap->height;
   for (ct = 0; ct < bitmap->planes; ct++)
     plane_ptr[ct] = bitmap->bits + (ct * bytes_plane);

/* everything should now be initialised */

   old_vector  = data_vector;	 /* save data vector */
   data_vector = block;
   for (ct = 0; ct < bitmap->height; ) {     /* transfer a bit of the bitmap */
     count = scan_width * lines_block;
     for (counter = 0; counter < bitmap->planes; counter++) {	 /* to "block" */
        memcpy(block, plane_ptr[counter], count);
        plane_ptr[counter] += count;
     }

     /* initialise message stucture */
     control_vector[0] = bitmap->width;   control_vector[1] = lines_block;
     control_vector[2] = bitmap->planes;  control_vector[3] = bitmap->bits_pix;
     control_vector[4] = x;		  control_vector[5] = y;
     control_vector[6] = rop;
     control_size = 7;
     data_size	  = count * bitmap->planes;
     ret_val = send_message();	  /* send bitmap to server */
     if (ret_val == 0) {
       Reset_All();
       data_vector = old_vector;
       return(0);
     }
     x = control_vector[0]; y = control_vector[1];  /* starting co-ordinates */
     Reset_All();				    /* of next bit of bitmap */
     ct += lines_block;
     if ((ct + lines_block) > bitmap->height) lines_block = bitmap->height - ct;
   }
   Reset_All();
   data_vector = old_vector;	 /* restore data vector */
   Free(block);
   return(1);
}


/**************************************************************************/
/*  DrawBitMap		       Command Number = 22			  */
/**************************************************************************/

int DrawBitMap(graph, bitmap, x, y, rop)
   Stream *graph;
   BITMAP *bitmap;
   word   x, y, rop;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word      max_block, scan_width, image_size;
   BYTE      *old_vector;
   int	     ret_val;


   if (graph_node == (GraphNode *) NULL) return(0);

   if (bitmap == (BITMAP *) NULL) return(0);

   Wait(&sem);
   max_block = determine_max_block(graph);
   
   if (max_block > 10000) max_block -= 10000;

   scan_width = bitmap->byte_width;  /* bytes per scan line */
     /* 1 scan line > size of buffer? */
   if (max_block < (scan_width * bitmap->planes)) {
      Signal(&sem);
      return(0);
   }

   image_size = scan_width * bitmap->height * bitmap->planes; /* bitmap size */
   if (image_size < max_block) {    /* bitmap fits into buffer! */
      if (!check_last_command(graph, 22))  {
         Signal(&sem);
         return(0);
      }

      old_vector = data_vector;   /* save data vector */

      /* set up message structure */
      control_vector[0] = bitmap->width;   control_vector[1] = bitmap->height;
      control_vector[2] = bitmap->planes;  control_vector[3] = bitmap->bits_pix;
      control_vector[4] = x;		   control_vector[5] = y;
      control_vector[6] = rop;
      control_size = 7;
      data_size    = image_size;
      data_vector  = bitmap->bits;
      ret_val = send_message();   /* send bitmap to server */
      Reset_All();
      data_vector = old_vector;
   }
   else   /* break bitmap into chunks and send */
      ret_val = send_bitmap(graph, bitmap, x, y, rop, max_block);
      
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  FillRect		       Command Number = 23			  */
/**************************************************************************/

int FillRect(graph, x1, y1, x2, y2, color)
   Stream *graph;
   word   x1, y1, x2, y2, color;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   word      params[5];

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 23)) {
      Signal(&sem);
      return(0);
   }

   params[0] = x1;     params[1] = y1;	 /* set up parameters for command */
   params[2] = x2;     params[3] = y2;
   params[4] = color;

   if (!buffer_command(5, &params[0])) {
      Signal(&sem);
      return(0);
   }

   Signal(&sem);
   return(1);
}

/**************************************************************************/
/*  ClearGraph		       Command Number = 25			  */
/**************************************************************************/

int ClearGraph(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);  /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 25)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;
   data_size = 0;
   ret_val = send_message();  /* tell server to clear graphic window */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*  SetCursorPos	       Command Number = 26			  */
/**************************************************************************/

int SetCursorPos(graph, x, y)
   Stream *graph;
   word   x, y;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 26)) {
      Signal(&sem);
      return(0);
   }

   control_size = 2;		    /* set up control vector */
   control_vector[0] = x;
   control_vector[1] = y;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

/**************************************************************************/
/*  ClipCursor		       Command Number = 27			  */
/**************************************************************************/

int ClipCursor(graph, x1, y1, x2, y2)
   Stream *graph;
   word   x1, y1, x2, y2;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 27)) {
      Signal(&sem);
      return(0);
   }

   control_size = 4;		    /* set up control vector */
   control_vector[0] = x1;    control_vector[1] = y1;
   control_vector[2] = x2;    control_vector[3] = y2;
   data_size = 0;

   ret_val = send_message();   /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  ChangeCursor	       Command Number = 28			  */
/**************************************************************************/

int ChangeCursor(graph, shape)
   Stream *graph;
   word   shape;
{
   GraphNode *graph_node = valid_stream(graph);   /* ID valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 28)) {
      Signal(&sem);
      return(0);
   }

   switch (shape) {
     case ARROW   :
     case CROSS   :		   /* make sure that the new cursor shape */
     case IBEAM   :		   /* is valid!. If not default to ARROW  */
     case ICON	  :
     case SIZE	  :
     case UPARROW :
     case WAIT	  : break;
     default	  : shape = ARROW;
   }

   control_size = 1;		   /* set up control vector */
   control_vector[0] = shape;
   data_size = 0;

   ret_val = send_message();	 /* send message to server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  CreateMetaFile	       Command Number = 32			  */
/**************************************************************************/

word CreateMetaFile(graph, name)
   Stream *graph;
   byte   *name;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val, name_len;
   word      result;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 32)) {
      Signal(&sem);
      return(0);
   }

   if (name == (byte *) NULL) control_size = 1;  /* no name, so no data */
      else {
	name_len = strlen(name);	 /* put name in data vector */
	if (name_len > 80) {
	   Signal(&sem);
	   return(0);
	}
	strcpy(data_vector, name);
	data_vector[name_len] = '\0';
	data_size = name_len;
      }

   ret_val = send_message();	  /* send message to graphics server */
   if (ret_val == 0) {
      Signal(&sem);
      return(0);
   }
   result = control_vector[0];
   Reset_All();
   Signal(&sem);
   return(result);
}


/**************************************************************************/
/*  CloseMetaFile	       Command Number = 33			  */
/**************************************************************************/

int CloseMetaFile(graph, DC)
   Stream *graph;
   word   DC;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 33)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;
   control_vector[0] = DC;     /* set up parameter for graphics server */
   ret_val = send_message();   /* send message to graphics server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  GetMetaFile 	       Command Number = 34			  */
/**************************************************************************/

word GetMetaFile(graph, name)
   Stream *graph;
   byte   *name;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;
   word      result;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 34)) {
      Signal(&sem);
      return(0);
   }

   if (name == (byte *) NULL) control_size = 1;  /* no name, so no data */
      else {
	strcpy(data_vector, name);    /* put name in data vector of MCB */
	data_size = strlen(name);
      }

   ret_val = send_message();	  /* send message to graphics server */
   if (ret_val == 0) {
      Signal(&sem);
      return(0);
   }
   result = control_vector[0];
   Reset_All();
   Signal(&sem);
   return(result);
}


/**************************************************************************/
/*  PlayMetaFile	       Command Number = 35			  */
/**************************************************************************/

int PlayMetaFile(graph, handle)
   Stream *graph;
   word   handle;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 35)) {
      Signal(&sem);
      return(0);
   }

   control_size = 1;
   control_vector[0] = handle;	 /* set up parameter for graphics server */
   ret_val = send_message();	 /* send message to graphics server */
   if (ret_val == 0) {
      Signal(&sem);
      return(0);
   }
   ret_val = (int) control_vector[0];
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/**************************************************************************/
/*  DeleteMetaFile	       Command Number = 36			  */
/**************************************************************************/

int DeleteMetaFile(graph, handle)
   Stream *graph;
   word   handle;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 36)) {
      Signal(&sem);
      return(0);
   }

   control_vector[0] = handle;	 /* set up parameter for graphics server */
   control_size = 1;
   ret_val = send_message();	 /* send message to graphics server */
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/****************************************************************************/
/* GetDeviceCaps							    */
/*									    */
/*   Parameters :-							    */
/*									    */
/*	  graph - A pointer uniquely identifying a graphic device.	    */
/*									    */
/*	  index - An index into a table of capabilities and attributes	    */
/*		  pertaining to a graphic device.			    */
/*									    */
/*   Function :-							    */
/*     The function does not send a message to the graphics server on the   */
/*     PC. A list of capabilities and attributes is obtained from the PC    */
/*     when each device is opened, ie. A graphic window, or a graphic	    */
/*     printer. This information is stored in the GraphNode structure	    */
/*     associated with each device. GetDeviceCaps returns a value from this */
/*     information table. A particular value can be selected via the index  */
/*     parameter.							    */
/*									    */
/*   Returns :- 							    */
/*     The value in the information table at the address indicated by index */
/****************************************************************************/

int GetDeviceCaps(graph, index)
   Stream *graph;
   word   index;
{
   GraphNode *graph_node = valid_stream(graph);   /* valid window? */
   int ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   if ((index < 0) || (index > 17)) return(0);	 /* valid index? */

   Wait(&sem);
   ret_val = (int) graph_node->info[index];
   Signal(&sem);
   return(ret_val);
}


/***************************************************************************/
/* The following routines allow for the use of colour palettes.  The user  */
/* would allocate sufficient space for a logical palette and would then    */
/* set the data fields up for the required colours.  The palette would     */
/* then be selected.  Many of the subsequent graphics calls may then use   */
/* index into the logical palette rather than a color in order to improve  */
/* the output quality and to take advantage of as many colours as the      */
/* hardware can handle.                                                    */


LOGPALETTE *CreatePalette(num_entries)
   unsigned short num_entries;
{
   LOGPALETTE *pal;
   
   pal = Malloc(sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * (num_entries-1));
   if (pal != (LOGPALETTE *) NULL) {
      pal->num_entries = (unsigned short) num_entries;
      pal->version = 0x300;
   }
   else   return((LOGPALETTE *)NULL);
   return(pal);
}

/* a simple routine to remove a palette */

int FreePalette(pal)
   LOGPALETTE *pal;
{
   if (pal == (LOGPALETTE *)NULL)    return(0);   /* failed */
   Free(pal);
   return(1);
}


/***************************************************************************/
/* SelectPalette             Command Number 30                             */
/***************************************************************************/

int SelectPalette(graph, pal)
   Stream *graph;
   LOGPALETTE *pal;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;
   char      *old_vect;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 30)) {
      Signal(&sem);
      return(0);
   }

   old_vect = data_vector;
   data_vector = (BYTE *)pal;
   data_size = sizeof(LOGPALETTE) + (pal->num_entries-1)*sizeof(PALETTEENTRY);
   ret_val = send_message();	 /* send message to graphics server */
   ret_val = control_vector[0];
   data_vector = old_vect;
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/***************************************************************************/
/* UnselectPalette             Command Number 31                           */
/***************************************************************************/

int UnselectPalette(graph)
   Stream *graph;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 31)) {
      Signal(&sem);
      return(0);
   }
   data_size = 1;
   ret_val = send_message();	 /* send message to graphics server */
   ret_val = control_vector[0];
   Reset_All();
   Signal(&sem);
   return(ret_val);
}


/***************************************************************************/
/* GetTextExtent              Command Number 37                            */
/***************************************************************************/

word GetTextExtent(graph, text)
   Stream *graph;
   char *text;
{
   GraphNode *graph_node = valid_stream(graph);   /* window valid? */
   int	     ret_val;
   char      *old_vect;

   if (graph_node == (GraphNode *) NULL) return(0);

   Wait(&sem);
   if (!check_last_command(graph, 37)) {
      Signal(&sem);
      return(0);
   }
   old_vect = data_vector;
   data_size = strlen(text);
   data_vector = text;
   ret_val = send_message();	 /* send message to graphics server */
   ret_val = control_vector[0];
   data_vector = old_vect;
   Reset_All();
   Signal(&sem);
   return(ret_val);
}

   
/***************************************************************************/
/* The ability to print graphics from the transputer is supplied not by    */
/* the graphics server, but by a seperate server, the graphics printer	   */
/* server. This server can be located using the directory name "/grfxprn". */
/* The server allows a programmer on the transputer to open a printer	   */
/* stream, and to close a printer stream. Further commands are available   */
/* through the use of a private protocol. At present there are two further */
/* commands available to a programmer using the private protocol. By using */
/* a message number of 0, the programmer is able to print a file, and by   */
/* using a message number of 1, the programmer is able to determine when   */
/* the print job is finished. The use of the private protocol is not shown */
/* here, as we use the file "prngrfx" to actually print graphics. (The use */
/* of the protocol can be seen in that file.)				   */
/*									   */
/* At present the graphics printer server will only allow the printing of  */
/* a graphics metafile, which has been created through this library, or    */
/* been created in Microsoft Windows.					   */
/***************************************************************************/


/****************************************************************************/
/*  InitPrinter()							    */
/*									    */
/*  Parameters :-							    */
/*     None.								    */
/*									    */
/*  Function :- 							    */
/*     The function attempts to locate the graphics printer server. Once    */
/*     found, the function allocates memory for a dummy stream structure.   */
/*     This will be the structure passed back to the caller, but it does    */
/*     represent an actual stream, and its only purpose is to provide	    */
/*     compatability with the rest of the graphics library. Naturally we    */
/*     take precautions so that normal graphics commands are not sent to    */
/*     this stream. Once the dummy stream has been created, the function    */
/*     obtains the capabilities and attributes of the current printer and   */
/*     adds the dummy stream pointer to the list of open graphic windows.   */
/*									    */
/*  Returns :-								    */
/*     The address of the dummy stream structure if successful, or NULL if  */
/*     unsuccessful.							    */
/****************************************************************************/

Stream * InitPrinter()
{
   Object *prn_obj;
   Stream *prn;

   if (!graphics_availiable) return((Stream *) NULL);

   prn_obj = Locate(NULL, "/grfxprn");	/* graphics printer server available */
   if (prn_obj == (Object *) NULL) return((Stream *) NULL);

   prn = (Stream *) Malloc(sizeof(Stream));   /* create a dummy stream */
   if (prn == (Stream *) NULL) {
      Close(prn_obj);
      return((Stream *) NULL);
   }
   prn->Server = 0L;	 /* make sure its recognised as being invalid */
   prn->Reply  = 0L;
			 /* get info on printer */
   if (ObjectInfo(prn_obj, NULL, data_vector) != Err_Null) {
     Free(prn);
     Close(prn_obj);
     return((Stream *) NULL);
   }

   Close(prn_obj);
   Wait(&sem);
			 /* add printer to list of open graphic windows */
   if (!add_to_list(0, prn, "PrnJob", data_vector)) {
      Signal(&sem);
      Free(prn);
      return((Stream *) NULL);
   }

   Signal(&sem);
   return(prn);
}


/****************************************************************************/
/*  PrintGraphics							    */
/*									    */
/*  Parameters :-							    */
/*     prn  - A pointer to a stream structure associated with the printer   */
/*     name - The name of the metafile to be printed.			    */
/*									    */
/*  Function :- 							    */
/*     The function checks that a file name for the metafile has actually   */
/*     been supplied, and checks that the name does not exceed 80	    */
/*     characters. Once the name has been verified, the program "prngrfx"   */
/*     is started up, with the name of the metafile being passed to it.     */
/*     "prngrfx" must be in the BIN directory of HELIOS. The program will   */
/*     run in conjunction with the program using the graphics library, thus */
/*     enabling the program to continue once printing is under way.	    */
/*									    */
/*  Returns :-								    */
/*     1 if the print was successfully started, 0 if not.		    */
/****************************************************************************/

int PrintGraphics(prn, name)
   Stream *prn;
   BYTE   *name;
{
   GraphNode *graph_node = valid_stream(prn);
   char      *dummy = Null(char),
	     **argv;   /* used to pass the name of the metafile to prngrfx */
   Object    *prog, *code, *objv[2];
   Stream    *str1, *strv[4];
   Environ   env;
   int	     ct;

   if (graph_node == (GraphNode *) NULL) return(0);

   if ((name == NULL) || (strlen(name) == 0) || (strlen(name) > 80)) return(0);

   /* Give a previous print job time to start up before starting up */
   /* current job.						    */

   if (print_jobs > 0) {
      prog = Locate(NULL, "/grfxprn/PrnJob1");
      if (prog == (Object *) NULL) {
	 for (ct = 0; (ct < 5) && (prog == (Object *) NULL); ct++) {
	    Delay(OneSec * 6);
	    prog = Locate(NULL, "/grfxprn/PrnJob1");
	 }
       }

     if (prog != (Object *) NULL) Close(prog);
   }
   
   prog = (Object *) NULL;
   print_jobs++;

   argv = Malloc(sizeof(char *));
   if (argv == NULL) return(0);

   *argv = Malloc(sizeof(char) * strlen(name));
   if (*argv == (char *) NULL) {
     printf("Unable to allocate memory for argument to prngrfx!\r\n");
     Free(argv);
     return(0);
   }

   code = Locate(NULL, "/helios/bin/prngrfx");
   if (code == (Object *) NULL) return(0);

   prog = Execute(NULL, code);		/* startup prngrfx */
   if (prog == (Object *) NULL) {
      Close(code); 	
      return(0);
   }

   Close(code);
   
   str1 = Open(prog, NULL, O_WriteOnly);
   if (str1 == (Stream *) NULL) {
      Close(prog);
      return(0);
   }
   
   Close(prog);

   objv[0] = Null(Object);	   /* set up object, stream and argument */
   objv[1] = Null(Object);	   /* stuff for prngrfx.		 */

   strv[0] = Heliosno(stdin);
   strv[1] = Heliosno(stdout);
   strv[2] = Heliosno(stderr);
   strv[3] = Null(Stream);

   strcpy(argv[0], name);
   env.Argv = argv;
   env.Envv = &dummy;
   env.Objv = &objv[0];
   env.Strv = &strv[0];

   if (SendEnv(str1->Server, &env) != 0L) {   /* send environment to prngrfx */
      Close(str1);
      return(0);
   }

   Close(str1);
   return(1);
}
@
