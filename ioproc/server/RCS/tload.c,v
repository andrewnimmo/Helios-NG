head	1.49;
access;
symbols
	Helios_1_3_1:1.38
	Helios_C40_1_3_Official_Release:1.33
	Helios-C40:1.33
	Alenia_release:1.27
	Helios1_3:1.27
	C40_Field_Test_2:1.27
	Helios13_beta:1.21
	Helios1_2_1:1.13;
locks; strict;
comment	@ * @;


1.49
date	94.07.15.11.05.19;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	94.07.14.10.39.54;	author mgun;	state Exp;
branches;
next	1.47;

1.47
date	94.07.06.10.44.59;	author mgun;	state Exp;
branches;
next	1.46;

1.46
date	94.06.29.13.42.25;	author tony;	state Exp;
branches;
next	1.45;

1.45
date	94.05.25.10.44.36;	author vlsi;	state Exp;
branches;
next	1.44;

1.44
date	94.05.11.13.00.49;	author vlsi;	state Exp;
branches;
next	1.43;

1.43
date	94.04.20.09.55.23;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	94.04.19.15.35.39;	author bart;	state Exp;
branches;
next	1.41;

1.41
date	94.04.07.10.57.33;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	94.01.25.11.47.01;	author bart;	state Exp;
branches;
next	1.39;

1.39
date	93.12.01.17.30.20;	author bart;	state Exp;
branches;
next	1.38;

1.38
date	93.10.27.14.35.36;	author bart;	state Exp;
branches;
next	1.37;

1.37
date	93.09.01.16.10.24;	author paul;	state Exp;
branches;
next	1.36;

1.36
date	93.08.22.12.08.34;	author bart;	state Exp;
branches;
next	1.35;

1.35
date	93.07.02.17.10.01;	author bart;	state Exp;
branches;
next	1.34;

1.34
date	93.06.16.12.19.37;	author bart;	state Exp;
branches;
next	1.33;

1.33
date	93.04.23.15.26.34;	author bart;	state Exp;
branches;
next	1.32;

1.32
date	93.04.01.16.32.22;	author nick;	state Exp;
branches;
next	1.31;

1.31
date	93.03.23.14.29.23;	author bart;	state Exp;
branches;
next	1.30;

1.30
date	93.03.05.11.15.19;	author nick;	state Exp;
branches;
next	1.29;

1.29
date	93.02.03.11.53.53;	author nick;	state Exp;
branches;
next	1.28;

1.28
date	93.01.21.14.40.03;	author paul;	state Exp;
branches;
next	1.27;

1.27
date	92.09.15.14.25.32;	author bart;	state Exp;
branches;
next	1.26;

1.26
date	92.09.14.13.51.51;	author bart;	state Exp;
branches;
next	1.25;

1.25
date	92.07.08.17.27.41;	author paul;	state Exp;
branches;
next	1.24;

1.24
date	92.07.08.16.20.15;	author paul;	state Exp;
branches;
next	1.23;

1.23
date	92.07.06.10.36.13;	author craig;	state Exp;
branches;
next	1.22;

1.22
date	92.06.30.10.32.00;	author paul;	state Exp;
branches;
next	1.21;

1.21
date	92.06.19.10.35.15;	author bart;	state Exp;
branches;
next	1.20;

1.20
date	92.03.06.12.10.17;	author martyn;	state Exp;
branches;
next	1.19;

1.19
date	92.03.06.12.05.11;	author martyn;	state Exp;
branches;
next	1.18;

1.18
date	91.07.31.16.23.04;	author martyn;	state Exp;
branches;
next	1.17;

1.17
date	91.07.30.10.39.03;	author martyn;	state Exp;
branches;
next	1.16;

1.16
date	91.07.29.14.05.48;	author al;	state Exp;
branches;
next	1.15;

1.15
date	91.07.26.16.38.13;	author al;	state Exp;
branches;
next	1.14;

1.14
date	91.07.22.14.39.12;	author al;	state Exp;
branches;
next	1.13;

1.13
date	91.04.02.17.32.11;	author martyn;	state Exp;
branches;
next	1.12;

1.12
date	91.03.20.18.53.38;	author paul;	state Exp;
branches;
next	1.11;

1.11
date	91.03.11.19.45.35;	author paul;	state Exp;
branches;
next	1.10;

1.10
date	91.03.06.22.01.03;	author paul;	state Exp;
branches;
next	1.9;

1.9
date	91.02.26.22.16.16;	author paul;	state Exp;
branches;
next	1.8;

1.8
date	91.02.20.14.37.19;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	91.02.05.20.46.08;	author paul;	state Exp;
branches;
next	1.6;

1.6
date	90.12.08.04.09.24;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	90.10.19.16.47.36;	author alan;	state Exp;
branches;
next	1.4;

1.4
date	90.10.19.12.16.39;	author alan;	state Exp;
branches;
next	1.3;

1.3
date	90.10.18.11.10.25;	author alan;	state Exp;
branches;
next	1.2;

1.2
date	90.10.17.14.23.01;	author alan;	state Exp;
branches;
next	1.1;

1.1
date	90.10.16.16.03.18;	author alan;	state Exp;
branches;
next	;


desc
@generic bootstrap code
@


1.49
log
@Changed VY86PID in displayed strings to be DEMON monior
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--          H E L I O S   I N P U T / O U T P U T   S E R V E R         --
--          ---------------------------------------------------         --
--                                                                      --
--             Copyright (C) 1987, Perihelion Software Ltd.             --
--          Copyright (c) 1994, Perihelion Distributed Software.        --
--                        All Rights Reserved.                          --
--                                                                      --
--      tload.c                                                         --
--                                                                      --
--              This module is responsible for bootstrapping the        --
--                                                                      --
--      root processor on start-up, and interacting with the            --
--                                                                      --
--      processor network.                                              --
--                                                                      --
--  Author:  BLV 8/10/87                                                --
--                                                                      --
------------------------------------------------------------------------*/
/* RcsId: $Id: tload.c,v 1.1.1.1 1994/07/15 09:09:37 nickc Exp $ */
/* Copyright (C) 1987, Perihelion Software Ltd. 			*/

#define Tload_Module

#include "helios.h"

#include <stdlib.h>
#include <sys\types.h>
#include <sys\stat.h>

/*{{{  description */
/**
*** The bits below are pretty horrible. The code for booting up the processor
*** used to be a separate program tload, but it is necessary for the server
*** and the debugger to be able to do this themselves. Hence the code from
*** tload.c was inserted here and fiddled about to make it work. Things become
*** very nasty because the Server and the debugger have rather different
*** requirements.
**/
/*}}}*/
/*{{{  statics and prototypes */

PRIVATE int bootstrap_mode;
PRIVATE word processor_memory;
PRIVATE char *box_type;

#define MAXREAD  0xffffL
#if (UNIX)
#define MAXCHUNK 0x20000L
#define C40MAXCHUNK MAXCHUNK
#else
#define C40MAXCHUNK 30720 	/* try to stop mem probs - 30k */
				/*  else revert to 0xD000L = ~50k */
#define MAXCHUNK 0x1000L
#endif

PRIVATE List  system_list;
List  *Image_List = (List *) NULL;
word  isize;

FILE  *infd;

PRIVATE void fn( timeout,       (char *));
PRIVATE void fn( send_boot,     (void));
PRIVATE void fn( send_idrom,    (void));
PRIVATE void fn( send_nucleus,  (void));
PRIVATE void fn( send_conf,     (void));
PRIVATE void fn( handle_info_request, (void));
PRIVATE int  fn( send_info_request, (void));
PRIVATE int  fn( send_resync, (void));
PRIVATE void fn( server_helios, (void));
PRIVATE int  fn( test_processor, (void));
PRIVATE void fn( load_boot,      (void));
/*}}}*/
/*{{{  init_boot() */
/**
*** This code deals with selecting the appropriate parts of the bootstrap,
*** depending on the processor types, and invoking them in turn.
**/
int init_boot()
{ char *conf;

	/* The default processor type is transputer			*/
  target_processor = Processor_Trannie;
  bootstrap_mode   = B_Reset_Processor | B_Send_Bootstrap | B_Send_Image |
                      B_Send_Config | B_Wait_Sync | B_Check_Processor;

  processor_memory = get_int_config("transputer_memory");
  if (processor_memory eq Invalid_config)
   processor_memory = get_int_config("processor_memory");

	/* The particular board type can affect the configuration	*/
	/* vector and ID rom.						*/
  box_type = get_config("box");

  conf = get_config("target_processor");
  if (conf ne (char *) NULL)
  { if (!mystrcmp(conf, "T414") ||
        !mystrcmp(conf, "T800") ||
        !mystrcmp(conf, "T425") ||
        !mystrcmp(conf, "T400"))
     target_processor = Processor_Trannie;
    elif (!mystrcmp(conf, "ARM"))
     { target_processor = Processor_Arm;
       /* R140 Ram based system defaults */
       bootstrap_mode = B_Reset_Processor | B_Send_Image | B_Send_Config |
         B_Wait_Sync;
     }
    elif (!mystrcmp(conf, "I860"))
     target_processor = Processor_i860;
    elif (!mystrcmp(conf, "68000"))
     target_processor = Processor_68000;
    elif ((!mystrcmp(conf, "C40")) || (!mystrcmp(conf, "320C40")) ||
	  (!mystrcmp(conf, "TMS320C40")))
     { target_processor = Processor_C40;
       bootstrap_mode = B_Reset_Processor | B_Send_Bootstrap | B_Send_IdRom |
		B_Send_Image | B_Send_Config | B_Wait_Sync;
     }
    else
     { ServerDebug("Unknown processor type : %s", conf);
       ServerDebug(
    "Supported processors are : T414, T800, T425, T400, ARM, i860, 68000 and TMS320C40.");
/*       longjmp(exit_jmpbuf, 1); */
       longjmp_exit;
     }
  }

	/* Primarily for debugging purposes, parts of the bootstrap	*/
	/* can be suppressed.						*/
  if (get_config("no_reset_target") ne (char *) NULL)
   bootstrap_mode &= ~B_Reset_Processor;          
  if (get_config("no_bootstrap") ne (char *) NULL)
   bootstrap_mode &= ~B_Send_Bootstrap;
  if (get_config("no_image") ne (char *) NULL)
   bootstrap_mode &= ~B_Send_Image;   
  if (get_config("no_config") ne (char *) NULL)
   bootstrap_mode &= ~B_Send_Config;
  if (get_config("no_sync") ne (char *) NULL)
   bootstrap_mode &= ~B_Wait_Sync;
  if (get_config("no_idrom"))
   bootstrap_mode &= ~B_Send_IdRom;
  if (get_config("attach") ne (char *) NULL)
  {  bootstrap_mode &= ~B_Wait_Sync;
     bootstrap_mode |= B_Send_Sync;
  }
  if (get_config("no_check_processor") ne (char *) NULL)
   bootstrap_mode &= ~B_Check_Processor;

  if ((get_config("just_attach") ne (char *) NULL) ||
      (get_config("enable_link") ne (char *) NULL) ||
       EnableThatLink )
  {
   /* do not attempt to reset or boot system */
   /* allows IO processor to attach to running system */

   /* bootstrap_mode &= ~B_Reset_Processor; */
   /* bootstrap_mode &= ~B_Send_Bootstrap;  */
   /* bootstrap_mode &= ~B_Send_Image;      */
   /* bootstrap_mode &= ~B_Send_Config;	    */
   /* bootstrap_mode &= ~B_Wait_Sync;       */
   /* bootstrap_mode &= ~B_Check_Processor; */
   /* bootstrap_mode |= B_Send_Sync;	    */
   /* The above is equivalent to: 	    */
   
   bootstrap_mode = B_Send_Sync;

   /* Confusion here between ROM based systems you want to RESET before
    * attaching to, and IO Server as a fileserver/console type system where you
    * dont. Also in the case of some inmos boards where the processor reset
    * is actually shared with the link chipreset, the procreset line has to be
    * cut and the "reset_target" directive used with "just attach".
    * (The just_attach directive defaults to (no_reset_target").
    */

   if (get_config("reset_target") ne NULL)
	bootstrap_mode |= B_Reset_Processor;
  }

  	/* The half duplex protocol is on by default for C40 and ARM, unless	*/
  	/* c40_disable_halfduplex is specified.					*/
  if (((target_processor eq Processor_C40) || (target_processor eq Processor_Arm)) &&
       (get_config("c40_disable_halfduplex") == NULL))
   C40HalfDuplex = TRUE;

	/* For transputers the default bootlink is 0. For C40s it is  */
	/* normally 3, unless a special link interface is needed in   */
        /* which case the bootlink is the seventh.                    */
  if (target_processor eq Processor_C40)
   { Default_BootLink = 3;
     if ((!mystrcmp(box_type, "DSP1")) || (!mystrcmp(box_type, "HYDRA")))
      Default_BootLink = 6;
   }

  InitList(&system_list);
  Image_List = &system_list;

  if (bootstrap_mode & B_Send_Bootstrap)
    {
      load_boot();
    }

  if (bootstrap_mode & B_Check_Processor)
  {
    return (test_processor ());
  }

  return(1);
}
/*}}}*/
/*{{{  tidy_boot() */

void tidy_boot()
{
  if (bootstrap ne NULL)
  { iofree(bootstrap); bootstrap = NULL; }

  if ((Image_List ne (List *) NULL) && (TstList(Image_List)) )
    FreeList(Image_List);
}
/*}}}*/
/*{{{  test_processor() */
/**
*** This routine checks that the processor really is available
**/
PRIVATE int  test_processor()
{
  if (target_processor eq Processor_Trannie)
   { int  retries;
     word start_time = get_unix_time();

#if SOLARIS
     for (retries = 0; retries < 10; retries++)
#else
     for (retries = 0; (retries < 3) && ((get_unix_time() - start_time) < 5L);
          retries++)
#endif
      { 
	resetlnk();
	xpreset();
	unless(xpwrbyte(0L))          continue;
        unless(xpwrint(0x80000100L))  continue;
        unless(xpwrint(0x12345678L))  continue;
        unless(xpwrbyte(1L))          continue;
        unless(xpwrint(0x80000100L))  continue;
        if (xprdint() ne 0x12345678L) continue; 
	   /* And again for good measure */
        unless(xpwrbyte(0L))          continue;
        unless(xpwrint(0x80000104L))  continue;
        unless(xpwrint(0x87654321L))  continue;
        unless(xpwrbyte(1L))          continue;
        unless(xpwrint(0x80000104L))  continue;
        if (xprdint() ne 0x87654321L) continue;

           /* Two successful exchanges is good enough  */
        return(1);
      }

     return(0);
   }

  return 1;
}
/*}}}*/
/*{{{  boot_processor */
/**
*** When the Server or the debugger wants to boot the processor it calls
*** this routine in either mode debugboot or serverboot. The routine loads
*** the bootstrap code and the system image, and sends them off to the
*** processor. Then the space take up by the bootstrap code is freed, and
*** if the system is in Server mode the space taken up by the system image
*** is freed as well because this lets me have a couple more coroutines before
*** running out of memory, and that is rather important on a 640K PC.
**/

#if SOLARIS

static jmp_buf * failure_buf;	/* memory assigned in boot_processor () */
#define longjmp_fail	longjmp (*failure_buf, 1)

#else

static jmp_buf failure_buf;
#define longjmp_fail	longjmp (failure_buf, 1)

#endif

/*{{{  timeout() */
/**
*** Timeout() is called when any of the boot writes to the processor fails.
*** It longjmps back to boot_processor() above, which either recovers or
*** exits depending on what the user is doing.
**/
PRIVATE void timeout(when)
char *when;
{ ServerDebug("Timed out when sending %s.", when);
/*  longjmp(failure_buf, 1); */
  longjmp_fail;
}
/*}}}*/

void boot_processor(mode)
int mode;
{
#if SOLARIS
  failure_buf = (jmp_buf *)(malloc (256));

  if (setjmp (*failure_buf) ne 0) goto failed;
#else
  if (setjmp(failure_buf) ne 0) goto failed;
#endif

  infd = (FILE *)NULL;

  if ( (bootstrap_mode & B_Send_Image) && (!loadimage()) )
  {
    goto failed;
  }

  send_boot();

  if (bootstrap_mode & B_Send_IdRom)   send_idrom();
  if (bootstrap_mode & B_Send_Image)   send_nucleus();
  if (bootstrap_mode & B_Send_Config)  send_conf();

  if ((mode ne debugboot) && TstList(Image_List))
   FreeList(Image_List);

#if multi_tasking
#if SOLARIS
    /* last 0 in call is a dummy value to keep the C++ compiler happy */
    AddMultiwait(Multi_LinkMessage, &link_table[current_link].ready,
                 current_link, 0);
#else
    AddMultiwait(Multi_LinkMessage, &link_table[current_link].ready,
                 current_link);
#endif
    link_table[current_link].ready = 0L;
#endif

  if (mode ne debugboot)
   server_helios();

#if (UNIX && !MEIKORTE)
  { extern void fn( Hydra_SwitchMode, (void));
    if (Server_Mode eq Mode_Remote)
     Hydra_SwitchMode();
  }
#endif

  return;

failed:                      /* to bootstrap the processor for some reason */
  if (mode eq debugboot)
   return;                   /* continue debugging */
  else
   output("Processor bootstrap has failed.\r\n");
}
/*}}}*/
/*{{{  disk I/O */
/**
*** The following bits of code deal with loading items off disk. The file name
*** corresponding to the system image is known because the system cannot
*** start up without it - either it is in the configuration file or it is on
*** the command line. Also, the system image may be loaded already if in
*** debugging mode so I check for that. The system image is loaded in chunks
*** because some systems object to loading vast quantities of data in one go.
*** On some processors the system image may be too large to hold in memory.
***
*** loadboot() is called once only, from main() in module server.c . A bootfile
*** may be specified in the configuration file, with the default being nboot.i
*** The space for the bootstrap code is freed at the end of main().
**/
 
int loadimage()
{ word l;
  int  cur;
  GenData *cur_data;
  struct stat sbuf;

  /* If the nucleus is already loaded or the processor is not a transputer */
  /* wait for send_boot() to load and send system image in small chunks */
  /* Most processors nuclei can get too large to load in one go. */
  if (target_processor ne Processor_Trannie || TstList(Image_List))
	return(1);

  if (system_image[0] eq '\0')
   { ServerDebug("No system image defined in host.con file.");
/*     longjmp(exit_jmpbuf, 1); */
       longjmp_exit;
   }

  Debug(Boot_Flag, ("Loading system image %s.", system_image) );

#if (UNIX)
  infd = fopen(system_image,"r");
#else
  infd = fopen(system_image,"rb");
#endif
  if( infd eq (FILE *) NULL ) 
   { ServerDebug("Cannot open image %s for input.", system_image);
     return(0);
   }

#if 0	/* Old style of finding size of nucleus image. */
	/* This requires a standardised format for the nucleus */
	/* header. This can no longer be relied on in the V2 world. */
	
  if (fread((byte *) &isize,1,4,infd) ne 4)
   { ServerDebug("Cannot read image header.");
     goto done;
   }
  isize = swap(isize);                   /* extract size of system image */

  if (fseek(infd, 0L, SEEK_SET) ne 0)    /* and reset file to beginning */
   { ServerDebug("Failed to seek in image.");
     goto done;
   }
#else
	/* New style. */
  if (stat(system_image, &sbuf) ne 0)
   { ServerDebug("stat failed on %s.", system_image);
     goto done;
   }

  isize = sbuf.st_size;

  ServerDebug("Image size returned from stat = %d.",isize);

  if (isize <= 0)
   { ServerDebug("Bad image size returned from stat.");
     goto done;
   }
#endif

  for (l = 0L; l < isize; l += MAXCHUNK)
   { cur = ((isize - l) > MAXCHUNK) ? (int) MAXCHUNK : (int) (isize - l);
     cur_data = (GenData *) malloc(sizeof(GenData) + cur);
     if (cur_data eq (GenData *) NULL)
      { ServerDebug("Insufficient memory to store system image.");
        goto done;
      }
     if (fread(&(cur_data->data[0]), 1, cur, infd) eq 0)
      { ServerDebug("Failed to read system image.");
        goto done;
      }
     cur_data->size = cur;
     AddTail(&(cur_data->node), Image_List);
   }

  fclose( infd );                           /* finished successfully */
  infd = (FILE *) NULL;
  return(1);

done:
  fclose( infd );
  infd = (FILE *) NULL;
  FreeList(Image_List);
  return(0);  /* return error */
}

#if SUN3
extern int	VC40_Type;

extern int	vc40_settype ();
extern void	vc40_enint ();
#endif

PRIVATE void load_boot()
{ int s;
  word ihdr[3];
  char *name = get_config("bootfile");    /* get boot name from configuration */

  if (name eq (char *) NULL)              /* use default bootfile */     
   { if (target_processor eq Processor_C40)
      { 	/* Some C40 systems need special versions of the bootstrap */
        if (!mystrcmp(box_type, "dsp1"))
         name = "c40hboot.i";
#if SUN3
        else if( !mystrcmp(box_type, "VC40"))
	  {
	    /* HYDRA I or HYDRA II ??? */
	    if (VC40_Type == 0)	VC40_Type = vc40_settype ();

	    if (VC40_Type == 1)		name = "c40ah1boot.i";
	    else if (VC40_Type == 2) 	name = "c40ah2boot.i";
	  }
#endif
        else if( !mystrcmp(box_type, "SPIRIT40"))
         name = "c40sboot.i";
        else
         name = "c40boot.i";
      }
     else
      name = "nboot.i";
   }

   if( !mystrcmp(box_type, "VC40") || !mystrcmp(box_type, "SPIRIT40") )
   {
        	
        	/* For shared memory boards, the bootstrap is actually sent	*/
        	/* when the processor is reset. We need B_Send_Bootstrap	*/
        	/* to cause load_boot to be called, but not send_boot.		*/
        	bootstrap_mode &= ~B_Send_Bootstrap;
   }

  Debug(Boot_Flag, ("Loading bootstrap program %s", name) );

#if (UNIX)
  infd = fopen(name,"r");
#else
  infd = fopen(name,"rb");
#endif
  if( infd eq (FILE *) NULL ) 
   { ServerDebug("Cannot open boot program %s for input.",name);
     goto fail;
   }

  if( (s=fread((byte *) &(ihdr[0]),1,12,infd)) ne 12)
   { ServerDebug("Cannot read boot header %d %d.",s,ferror(infd));
     goto fail;
   }

   {
	/* Check bootstrap's image magic */
	word magic = 0x12345678L; /* default to transputer */

	if (target_processor eq Processor_C40)
		magic = 0xc4045601L;
	else if (target_processor eq Processor_Arm)
		magic = 0x0a245601L;
	else if (target_processor eq Processor_i860)
		magic = 0x86045601L;
	
	if( swap(ihdr[0]) ne magic) {
		ServerDebug("Error: bootstrap is not an executable Helios file.");
		goto fail;
	}
   }

  bootsize = swap(ihdr[2]);

  bootstrap =  (char *)(malloc((uint) bootsize));
  if( bootstrap eq NULL )
   { ServerDebug("Cannot get image buffer."); goto fail; }

  if( (s=fread(bootstrap,1,(int)bootsize,infd)) ne (int) bootsize)
   { ServerDebug("Image too small %d, error %d.",s,ferror(infd)); goto fail; }

  fclose( infd );
  infd = (FILE *) NULL; 
  return;

fail:
  if (infd ne (FILE *) NULL)
   { fclose( infd );
     infd = (FILE *) NULL;
   }
/*  longjmp(exit_jmpbuf, 1); */
  longjmp_exit;
}
/*}}}*/
/*{{{  send bootstrap */
PRIVATE void send_boot()
{ char *temp;

  Debug(Boot_Flag, ("Resetting link and processor.") );
  resetlnk();

   /* Confusion here between ROM based systems you want to RESET before
    * attaching to, and IO Server as a fileserver/console type system where you
    * dont. Also in the case of some inmos boards where the processor reset
    * is actually shared with the link chipreset, the procreset line has to be
    * cut and the "reset_target" directive used with "just attach".
    * (The just_attach directive defaults to no_reset_target").
    */
  if (bootstrap_mode & B_Reset_Processor)
   {
#if TR5
     poll(0,0,1000);
#endif
     xpreset();
   }
   
  if (bootstrap_mode & B_Send_Bootstrap)
   { Debug(Boot_Flag, ("Sending bootstrap, size is %ld", bootsize) );

     if (target_processor eq Processor_C40) 
/*{{{  C40 bootstrap */
      {
      /*
		Raw 'C40 bootstrap consists of:
			Global Bus memory control word:		0x3e39fff0
			Local Bus memory constrol word:		0x3e39fff0
			(can be any value bootstrap will use IDROM values)
			Block size of bootstrap to be loaded
			Address where boostrap is to be loaded

			The bootstrap...

			End of blocks word (0x0000 0000)
			Interrupt vector pointer
			Trap vector pointer
			Local Memory address for dummy IACK instruction
	*/

        if (!xpwrint(0x3e39fff0))		 /* global bus cntrl */
         timeout("global bus ctrl (first word of bootstrap)");
        if (!xpwrint(0x3e39fff0))		 /* local bus cntrl */
         timeout("local bus ctrl (second word of bootstrap)");

        if (!xpwrint(bootsize / 4L))       /* bootstrap size */
         timeout("bootstrap size");
        if (!xpwrint(0x002ffc00))          /* load address (internal ram blk 1) */
         timeout("load address");
        if (!xpwrdata(bootstrap,bootsize)) /* bootstrap */
         timeout("bootstrap code");
        if (!xpwrint(0x0)) 	         /* end of blocks to load */
         timeout("end block marker");
        if (!xpwrint(0x0)) 	         /* IVTP address */
         timeout("IVTP address");
        if (!xpwrint(0x0)) 	         /* TVTP address */
         timeout("TVTP address");
        if (!xpwrint(0x00300000)) 	 /* dummy IACK address */
         timeout("IACK address");	 /* start of local bus */

 	/* 'C40 should now be executing bootstrap */
	if (xprdint() != 1) {
	 ServerDebug("Failed to receive bootstrap acknowledge");
/*	 longjmp(failure_buf, 1); */
	 longjmp_fail;
	}

      }
/*}}}*/
     elif (target_processor eq Processor_Trannie)
/*{{{  transputer bootstrap */
      {
	if (!xpwrbyte(bootsize))              /* bootstrap size */
         timeout("bootstrap size");
        if (!xpwrdata(bootstrap,bootsize))    /* bootstrap */
         timeout("bootstrap code");

        temp = get_config("BOX");          /* This entry is known to exist */
        if (!mystrcmp(temp, "MK026"))      /* or anything else with parity memory */
         { word size = processor_memory;
           if (size eq Invalid_config) size = 0x300000L;
           xpwrbyte(5L);
           xpwrint(size);
           while (!xprdrdy());           /* wait for the clear to finish */
           (void) xprdbyte();
         }
        xpwrbyte(4L);
      }	/* end of transputer version */
/*}}}*/
   }
}
/*}}}*/
/*{{{  send ID Rom */
static void send_idrom()
{ 
  if (target_processor eq Processor_C40)
   {   	word C40_HW_Config = 0;
		/* set defaults for pseudo IDROM */
	static IDROM ID_ROM = {
					/* self inclusive size of this block */
			sizeof(IDROM) / sizeof(word),
			0,		/* TIM-40 module manufacturers ID */
			0,		/* CPU type (00 = C40) */
			49,		/* CPU cycle time (49 = 50ns = 40Mhz) */
			0,		/* manufactures module type */
			0,		/* module revision level */
			0,		/* reserved byte */

			0x80000000,	/* address base of global bus strobe 0 */
	/* none */	0xffffffff,	/* address base of global bus strobe 1 */
			0x300000,	/* address base of local bus strobe 0 */
	/* none */	0xffffffff,	/* address base of local bus strobe 1 */

					/* sizes are in words */
	/* 4Mb */	0x100000,	/* size of memory on global bus strobe 0 */
			0,		/* size of memory on global bus strobe 1 */
	/* 4Mb */	0x100000,	/* size of memory on local bus strobe 0 */
			0,		/* size of memory on local bus strobe 1 */
			0x800,		/* size of fast ram pool (inc. on-chip RAM) */

			/* assume fast DRAM here */
			0x22,		/* within page on global bus */
			0x22,		/* within page on local bus */
			0x55,		/* outside page on global bus */
			0x55,		/* outside page on local bus */

			/* 1ms on 40Mhz C40 */
			0x2710,		/* period time for 1ms interval on timer 0 */

			/* no refresh required */
			0x80,		/* period for DRAM refresh timer (optional) */
			0x2c2,		/* contents set TCLK0 to access RAM not IDROM */

			0,		/* sets up timer to refresh DRAM (optional) */

/* same as C40 reset */	0x3e39fff0,	/* global bus control register */
/* same as C40 reset */	0x3e39fff0,	/* local bus control register */

	/* none */	0		/* total size of auto-initialisation data */
		};


	/* Send a hardware configuration word to the bootstrap. */
	/* This allows it to configure itself for different C40 */
	/* hardware environments and nucleus load positions. */
	
	if (get_config("c40_disable_cache") != NULL)
	{
		C40_HW_Config |= HW_CacheOff;
	}

	if (get_config("c40_load_nucleus_local_S0") != NULL)
	{
		C40_HW_Config |= HW_NucleusLocalS0;
	}
	if (get_config("c40_load_nucleus_local_S1") != NULL)
	{
		C40_HW_Config |= HW_NucleusLocalS1;
	}
	if (get_config("c40_load_nucleus_global_S0") != NULL)
	{
		C40_HW_Config |= HW_NucleusGlobalS0;
	}
	if (get_config("c40_load_nucleus_global_S1") != NULL)
	{
		C40_HW_Config |= HW_NucleusGlobalS1;
	}

	if ((!mystrcmp(box_type, "DSP1")) ||
	    (!mystrcmp(box_type, "VC40")) ||
	    (!mystrcmp(box_type, "SPIRIT40")) ||
            (get_config("c40_replace_idrom") != NULL) ||
	    (get_config("c40_use_pseudo_idrom") != NULL)) {
		word i;

		/* now let the users overload any part of the IDROM */
		if ((i = get_int_config("c40_idrom_man_id")) != Invalid_config)
		{
			ID_ROM.MAN_ID = (short)i;
		}

		if ((i = get_int_config("c40_idrom_cpu_id")) != Invalid_config)
		{
			ID_ROM.CPU_ID = (byte)i;
		}

		if ((i = get_int_config("c40_idrom_cpu_clk")) != Invalid_config)
		{
			ID_ROM.CPU_CLK = (byte)i;
		}

		if ((i = get_int_config("c40_idrom_model_no")) != Invalid_config)
		{
			ID_ROM.MODEL_NO = (short)i;
		}
		if ((i = get_int_config("c40_idrom_rev_lvl")) != Invalid_config)
		{
			ID_ROM.REV_LVL = (byte)i;
		}
		if ((i = get_int_config("c40_idrom_reserved")) != Invalid_config)
		{
			ID_ROM.RESERVED = (byte)i;
		}

		if ((i = get_int_config("c40_idrom_gbase0")) != Invalid_config)
		{
			ID_ROM.GBASE0 = (word)i;
		}
		if ((i = get_int_config("c40_idrom_gbase1")) != Invalid_config)
		{
			ID_ROM.GBASE1 = (word)i;
		}
		if ((i = get_int_config("c40_idrom_lbase0")) != Invalid_config)
		{
			ID_ROM.LBASE0 = (word)i;
		}
		if ((i = get_int_config("c40_idrom_lbase1")) != Invalid_config)
		{
			ID_ROM.LBASE1 = (word)i;
		}

		if ((i = get_int_config("c40_idrom_gsize0")) != Invalid_config)
		{
			ID_ROM.GSIZE0 = (word)i;
		}
		if ((i = get_int_config("c40_idrom_gsize1")) != Invalid_config)
		{
			ID_ROM.GSIZE1 = (word)i;
		}
		if ((i = get_int_config("c40_idrom_lsize0")) != Invalid_config)
		{
			ID_ROM.LSIZE0 = (word)i;
		}
		if ((i = get_int_config("c40_idrom_lsize1")) != Invalid_config)
		{
			ID_ROM.LSIZE1 = (word)i;
		}

		if ((i = get_int_config("c40_idrom_fsize")) != Invalid_config)
		{
			ID_ROM.FSIZE = (word)i;
		}

		if ((i = get_int_config("c40_idrom_wait_g0")) != Invalid_config)
		{
			ID_ROM.WAIT_G = (ID_ROM.WAIT_G & 0xf0) | (byte)i;
		}
		if ((i = get_int_config("c40_idrom_wait_g1")) != Invalid_config)
		{
			ID_ROM.WAIT_G = (ID_ROM.WAIT_G & 0x0f) | (byte)i << 4;
		}

		if ((i = get_int_config("c40_idrom_wait_l0")) != Invalid_config)
		{
			ID_ROM.WAIT_L = (ID_ROM.WAIT_L & 0xf0) | (byte)i;
		}
		if ((i = get_int_config("c40_idrom_wait_l1")) != Invalid_config)
		{
			ID_ROM.WAIT_L = (ID_ROM.WAIT_L & 0x0f) | (byte)i << 4;
		}

		if ((i = get_int_config("c40_idrom_pwait_g0")) != Invalid_config)
		{
			ID_ROM.PWAIT_G = (ID_ROM.PWAIT_G & 0xf0) | (byte)i;
		}
		if ((i = get_int_config("c40_idrom_pwait_g1")) != Invalid_config)
		{
			ID_ROM.PWAIT_G = (ID_ROM.PWAIT_G & 0x0f) | (byte)i << 4;
		}

		if ((i = get_int_config("c40_idrom_pwait_l0")) != Invalid_config)
		{
			ID_ROM.PWAIT_L = (ID_ROM.PWAIT_L & 0xf0) | (byte)i;
		}
		if ((i = get_int_config("c40_idrom_pwait_l1")) != Invalid_config)
		{
			ID_ROM.PWAIT_L = (ID_ROM.PWAIT_L & 0x0f) | (byte)i << 4;
		}

		if ((i = get_int_config("c40_idrom_timer0_period")) != Invalid_config)
		{
			ID_ROM.TIMER0_PERIOD = (word)i;
		}
		if ((i = get_int_config("c40_idrom_timer1_period")) != Invalid_config)
		{
			ID_ROM.TIMER1_PERIOD = (word)i;
		}
		if ((i = get_int_config("c40_idrom_timer0_ctrl")) != Invalid_config)
		{
			ID_ROM.TIMER0_CTRL = (short)i;
		}
		if ((i = get_int_config("c40_idrom_timer1_ctrl")) != Invalid_config)
		{
			ID_ROM.TIMER1_CTRL = (short)i;
		}

		if ((i = get_int_config("c40_idrom_gbcr")) != Invalid_config)
		{
			ID_ROM.GBCR = (word)i;
		}
		if ((i = get_int_config("c40_idrom_lbcr")) != Invalid_config)
		{
			ID_ROM.LBCR = (word)i;
		}

		if (get_config("c40_use_pseudo_idrom") != NULL)
		{
			C40_HW_Config |= HW_PseudoIDROM;
		}

	 	if (get_config("c40_replace_idrom") != NULL)
		{
			C40_HW_Config |= HW_ReplaceIDROM;
		}

		/* For SML type links, adjust the size of the appropriate */
		/* global strobe by the size of the shared RAM area	*/

		/* ... Except for Ariel's HYDRA II board, in which case the */
		/* SML link always extends upwards from 0x80000000	    */
		if( mystrcmp(box_type, "VC40") == 0 ||
		    mystrcmp(box_type, "SPIRIT40") == 0 )
		{
#if SUN3
			if (mystrcmp (box_type, "VC40") == 0)
			{
				if (VC40_Type == -1)	VC40_Type = vc40_settype ();
			}
#endif

			if (    mystrcmp (box_type, "SPIRIT40") == 0 
#if SUN3
			     || VC40_Type != 2
#endif
			   )
			{
				word sramsize = get_int_config("c40_sml_size");
				switch( sramsize )
				{
				default:
					ServerDebug("Invalid size for shared RAM, 8k assumed");
				case Invalid_config:
					sramsize = 8;
				case 8:
				case 16:
				case 32:
				case 64:
					sramsize *= 256;	/* size in WORDS */
				}
			
				if( get_config("c40_sml_g1") )
				{
					ID_ROM.GSIZE1 -= sramsize;
				}
				else
				{
					ID_ROM.GSIZE0 -= sramsize;
				}
			}
		}

		if( mystrcmp(box_type, "VC40") == 0 )
		{
			/* For the VC40 we have to swap the whole ROM.	*/
			/* Because the structure contains word,short and*/
			/* byte fields, we have to swap each field	*/
			/* individually (*SIGH*).			*/

#define swapword(x) swap(x)
#define swapshort(x) (swap(x)>>16)
#define swapbyte(x) (x)
			ID_ROM.SIZE 		= swapword(ID_ROM.SIZE);
			ID_ROM.MAN_ID 		= swapshort(ID_ROM.MAN_ID);
			ID_ROM.CPU_ID 		= swapbyte(ID_ROM.CPU_ID);
			ID_ROM.CPU_CLK 		= swapbyte(ID_ROM.CPU_CLK);
			ID_ROM.MODEL_NO 	= swapshort(ID_ROM.MODEL_NO);
			ID_ROM.REV_LVL 		= swapbyte(ID_ROM.REV_LVL);
			ID_ROM.RESERVED 	= swapbyte(ID_ROM.RESERVED);
			ID_ROM.GBASE0 		= swapword(ID_ROM.GBASE0);
			ID_ROM.GBASE1 		= swapword(ID_ROM.GBASE1);
			ID_ROM.LBASE0 		= swapword(ID_ROM.LBASE0);
			ID_ROM.LBASE1 		= swapword(ID_ROM.LBASE1);
			ID_ROM.GSIZE0 		= swapword(ID_ROM.GSIZE0);
			ID_ROM.GSIZE1 		= swapword(ID_ROM.GSIZE1);
			ID_ROM.LSIZE0 		= swapword(ID_ROM.LSIZE0);
			ID_ROM.LSIZE1 		= swapword(ID_ROM.LSIZE1);
			ID_ROM.FSIZE 		= swapword(ID_ROM.FSIZE);
			ID_ROM.WAIT_G 		= swapbyte(ID_ROM.WAIT_G);
			ID_ROM.WAIT_L 		= swapbyte(ID_ROM.WAIT_L);
			ID_ROM.PWAIT_G 		= swapbyte(ID_ROM.PWAIT_G);
			ID_ROM.PWAIT_L 		= swapbyte(ID_ROM.PWAIT_L);
			ID_ROM.TIMER0_PERIOD 	= swapword(ID_ROM.TIMER0_PERIOD);
			ID_ROM.TIMER1_PERIOD 	= swapword(ID_ROM.TIMER1_PERIOD);
			ID_ROM.TIMER0_CTRL 	= swapshort(ID_ROM.TIMER0_CTRL);
			ID_ROM.TIMER1_CTRL 	= swapshort(ID_ROM.TIMER1_CTRL);
			ID_ROM.GBCR 		= swapword(ID_ROM.GBCR);
			ID_ROM.LBCR 		= swapword(ID_ROM.LBCR);
			ID_ROM.AINIT_SIZE 	= swapword(ID_ROM.AINIT_SIZE);
		} 
			
			
		if (!xpwrint(C40_HW_Config))      /* Hardware Config word */
			timeout("Initial communication with bootstrap");

		/* send Pseudo IDROM */
		if (!xpwrdata((char *)&ID_ROM, sizeof(IDROM)))
			timeout("pseudo IDROM");
	} else {
		if (!xpwrint(C40_HW_Config))      /* Hardware Config word */
			timeout("Initial communication with bootstrap");
	}
   } /* C40 */
}
/*}}}*/
/*{{{  send nucleus */
/*{{{  send_bit() */
PRIVATE word send_bit(data)
GenData *data;
{
  poll_the_devices();
  if (Special_Exit) 
    {
/*      longjmp(exit_jmpbuf, 1); */
      longjmp_exit;
    }

  Debug(Boot_Flag, ("Sending %d bytes at %p.", data->size, &(data->data[0])));

  if (!xpwrdata(&(data->data[0]), (word) data->size))
   return(1L);
  else
   return(0L);
}
/*}}}*/

static void send_nucleus()
{
/*  printf ("@@send_nucleus ()\n"); */

  if (!TstList(Image_List))
   {      /* image is too big to load in one go, so load bit, send bit, load ... */
        word l;
        int  cur;
        char *cur_data;
	word armnucbase, kernelstartaddress;
	word MaxChunk = C40MAXCHUNK;
	struct stat sbuf;

/*	printf ("send_nucleus () - send nucleus in chunks\n"); */

/*	printf ("send_nucleus () - box_type = %s\n", box_type); */

        if ((target_processor eq Processor_Arm) && (mystrcmp(box_type, "vy86pid") == 0))
	  {
	    MaxChunk = 1024 * 4;
	  }

#if SUN3
	if ((target_processor eq Processor_C40) && (mystrcmp (box_type, "VC40") == 0))
	{
		if (VC40_Type == -1)	VC40_Type = vc40_settype ();

		if (VC40_Type == 2)
		{
			MaxChunk = 1024 * 4;
		}
	}
#endif

        if (system_image[0] eq '\0')
	  { ServerDebug("No system image defined in host.con file.");
	    /*           longjmp(exit_jmpbuf, 1); */
	    longjmp_exit;
	  }

	    /* allocate mem for chunk to be read in and sent */
        if ((cur_data = (char *)malloc((uint)MaxChunk)) eq NULL)
	  { ServerDebug("Insufficient memory to store system image.");
	    /*           longjmp(exit_jmpbuf, 1); */
	    longjmp_exit;
	  }

#if (UNIX)
        infd = fopen(system_image,"r");
#else
        infd = fopen(system_image,"rb");
#endif
        if( infd eq (FILE *) NULL )  
	  { ServerDebug("Cannot open image %s for input.", system_image);
	    /*           longjmp(exit_jmpbuf, 1); */
	    longjmp_exit;
	  }

#if 0	/* Old style of finding size of nucleus image. */
	/* This requires a standardised format for the nucleus */
	/* header. This can no longer be relied on in the V2 world. */

        if (fread((byte *) &isize,1,4,infd) ne 4) 
	  { ServerDebug("Cannot read image header.");
	    /*           longjmp(exit_jmpbuf, 1); */
	    longjmp_exit;
	  }

        isize = swap(isize);                   /* extract size of system image */

        if (fseek(infd, 0L, SEEK_SET) ne 0)
	  {  /* and reset file to beginning */
	    ServerDebug("Failed to seek image.");
	    /*           longjmp(exit_jmpbuf, 1); */
	    longjmp_exit;
	  }
#else
	/* New style. */
  if (stat(system_image, &sbuf) ne 0)
   { ServerDebug("stat failed on %s.", system_image);
    longjmp_exit;
   }

  isize = sbuf.st_size;

  if (isize <= 0)
   { ServerDebug("Bad image size returned from stat %d.",isize);
    longjmp_exit;
   }
#endif

	if (target_processor eq Processor_Arm)
	  {
	    armnucbase = get_int_config("arm_nucleus_base");

	    if (armnucbase == Invalid_config)
	      armnucbase = 0xa000L;

	    /* Calculate ARM nucleus execution address: */

	    kernelstartaddress = get_int_config ("kernel_start_address");

	    if (kernelstartaddress == Invalid_config)
	      {
		/* Start address = nucbase + size word + 6 module slot words */
		/*			+ 0 word + modhdr struct */
		kernelstartaddress = ((word)(armnucbase + (8 * 4) + 60));
	      }

#if (PC || SUN3 || SUN4 || ARMBSD || SOLARIS)

#define NUM_ARM_REGS	6

	    if (mystrcmp(box_type, "vy86pid") == 0)
	      {
		word regs[NUM_ARM_REGS];
		word reqspeed, pidspeed, hwconfig;
		char ack;

#if 0
		char *	leds_type = get_config ("arm_leds");
#endif
		/* Get host.con defined comms speed. */
		reqspeed = vy86pid_get_configbaud();

		/* FIXME: The following flag bits are defined in the
		 * "include/ampp/arm.m" header only at the moment. This source
		 * should be kept in step until the header files are
		 * cleaned-up.
		 */
		hwconfig = 0; /* default state */

		if (get_config("arm_disable_cache") == NULL)
		  hwconfig |= (1 << 24) ; /* cache should be on */
		if (get_config("arm_disable_writebuffer") == NULL)
		  hwconfig |= (1 << 25) ; /* write-buffer should be on */
		if (get_config("arm_protect_nucleus") != NULL)
		  hwconfig |= (1 << 26) ; /* nucleus should be protected */
		
#if 1 /* 940524 : simple boolean LEDs control */
		if (get_config ("arm_user_leds") == NULL)
		  {
		    hwconfig |= (1 << 27); /* the Kernel uses the LEDs */
		  }
#else
		if (leds_type != NULL)
		  {
		    if (mystrcmp(leds_type,"heartbeat") == 0)
		      {
			hwconfig |= (1 << 27) ;
		      }
		    else
		      {
			if (mystrcmp(leds_type,"user") != 0)
			  {
			    ServerDebug("Error: Invalid arm_leds option \"%s\"",leds_type);
			    /* longjmp(exit_jmpbuf, 1);  */
			    longjmp_exit;
			  }
		      }
		  }
#endif

		ServerDebug("Initialising communications with DEMON monitor (%ld baud)", reqspeed);

		/* Convert host.con requested comms speed to PID values. */
		/* 1 = 9600, 2 = 19200, 3 = 38400 */
		pidspeed = (reqspeed == 38400L) ? 3L : ((reqspeed == 19200L) ? 2L : 1L);

		/* Default baud rate is 9600. The initial open must be done     */
		/* at this speed, all further comms will be at requested speed. */
		/* The second parameter controls the use of the fifo.           */
		vy86pid_set_baudrate(9600L, FALSE);
		
		/* 0x0 = Open/Init RDP request, 0x2 = cold reset cpu, reset comms */
		/* 0 = use all memory on board, speed = 1/9600, 2/19200, 3/38400 */

		if ((!xpwrbyte(0x0)) || (!xpwrbyte(0x2)) || (!xpwrint(0)) ||
		    (!xpwrbyte((byte)pidspeed)))
		  {
		    timeout("Initialising communications with DEMON monitor");
		  }

		/* Ack is returned at old speed */
		if ((ack = xprdbyte()) != 0x5f)
		  {
		    ServerDebug("Error: Unexpected ack type (0x%x) when initialising communications.", ack);
		    /*    		longjmp(exit_jmpbuf, 1); */
		    longjmp_exit;
		  }
		if ((ack = xprdbyte()) != 0)
		  {
		    ServerDebug("Error: Bad status (0x%x) when initialising communications.", ack);
		    /*    		longjmp(exit_jmpbuf, 1); */
		    longjmp_exit;
		  }

		/* Now set to host.con requested speed for further transactions */
		vy86pid_set_baudrate(reqspeed, FALSE);
		
		Debug(Boot_Flag, ("Initialising execution environment."));
		
		/* Setup register contents required for kernel startup */
		regs[0] = swap(0x02000020L);		/* r0 = comms port address */
		regs[1] = swap(armnucbase);		/* r1 = nucleus base */
		regs[2] = swap (hwconfig);		/* r2 = hardware configuration */
		regs[3] = swap (0x00000000);		/* r3 = reserved (for configuration) */
		regs[4] = swap(kernelstartaddress);	/* pc = kernel start address */
		regs[5] = swap(0xD3L);			/* cpsr = SVC32 mode FIQ/IRQ disabled */

	      
		/* 0x5 = Write CPU state RDP request, 0xff = current mode */
		/* 0x050003 = mask to write regs r0, r1, r2, r3, pc and cpsr */
		/* and the contents of the four registers. */
		if ((!xpwrbyte(0x5)) || (!xpwrbyte(0xff)) || (!xpwrint(0x05000FL)) ||
		    (!xpwrdata((byte *)regs, NUM_ARM_REGS * sizeof(word))) )
		  {
		    timeout("Initialising execution environment");
		  }

		if ((ack = xprdbyte()) != 0x5f)
		  {
		    ServerDebug("Error: Unexpected ack type (0x%x) when initialising execution environment.", ack);
		    /*    		longjmp(exit_jmpbuf, 1); */
		    longjmp_exit;
		  }
		if ((ack = xprdbyte()) != 0)
		  {
		    ServerDebug("Error: Bad status (0x%x) when initialising execution environment.", ack);
		    /*    		longjmp(exit_jmpbuf, 1); */
		    longjmp_exit;
		  }
		
		/* Do a little validation that we are talking the same language. */
		Debug(Boot_Flag, ("Checking execution environment."));
		regs[0] = regs[1] = regs[2] = regs[3] = regs[4] = regs[5] = 0;
		
		/* 0x4 = Read CPU state RDP request, 0xff = current mode */
		/* 0x05000F = mask to read regs r0, r1, r2, r3, pc, cpsr. */
		if ((!xpwrbyte(0x4)) || (!xpwrbyte(0xff)) || (!xpwrint(0x05000FL)))
		  {
		    timeout("Checking execution environment");
		  }
		
		if ((ack = xprdbyte()) != 0x5f) 
		  {
		    ServerDebug("Error: Unexpected ack type (0x%x) when checking execution environment.", ack);
		    /*    		longjmp(exit_jmpbuf, 1); */
		    longjmp_exit;
		  }
		if (!xprddata((byte *)regs, NUM_ARM_REGS * sizeof(word)) )
		  {
		    timeout("Reading execution environment");
		  }
		
		Debug(Boot_Flag, ("Execution Env: r0 (comms port addr) : %lx", swap (regs[0])));
		Debug(Boot_Flag, ("               r1 (nucleus base)    : %lx", swap (regs[1])));
		Debug(Boot_Flag, ("               r2 (hardware config) : %lx", swap (regs[2])));
		Debug(Boot_Flag, ("               r3 (config reserved) : %lx", swap (regs[3])));
		Debug(Boot_Flag, ("               pc                   : %lx", swap (regs[4])));
		Debug(Boot_Flag, ("               psr                  : %lx", swap (regs[5])));

		if ((ack = xprdbyte()) != 0)
		  {
		    ServerDebug("Error: Bad status (0x%x) when checking execution environment.", ack);
		    /*    		longjmp(exit_jmpbuf, 1); */
		    longjmp_exit;
		  }

		Debug(Boot_Flag, ("Setting the LED's."));
		/* Light all the Leds! */
		/* Send memory write request to transfer the nucleus into the PID. */
		/* 0x3 = Write PID memory RDP request, ledaddr, 1*/
		if ((!xpwrbyte(0x3)) || (!xpwrint(0x200006c))
		    || (!xpwrint(1L)) || (!xpwrbyte(0)))
		  {
		    timeout("Setting the LED's");
		  }

		if ((ack = xprdbyte()) != 0x5f)
		  {
		    ServerDebug("Error: Unexpected ack type (0x%x) when setting LED's.", ack);
		    /*    		longjmp(exit_jmpbuf, 1); */
		    longjmp_exit;
		  }
		
		if ((ack = xprdbyte()) != 0)
		  {
		    ServerDebug("Error: Bad status (0x%x) when setting LED's.", ack);
		    /*    		longjmp(exit_jmpbuf, 1); */
		    longjmp_exit;
		  }

		ServerDebug("Sending download request (@@ 0x%lx, size 0x%lx).", armnucbase, isize);

		/* Send memory write request to transfer the nucleus into the PID. */
		/* 0x3 = Write PID memory RDP request, @@ armnucbase, nucsize */
		if ((!xpwrbyte(0x3)) || (!xpwrint(armnucbase))
		    || (!xpwrint(isize)))
		  {
		    timeout("Sending DEMON monitor download request");
		  }
		
		/* PID demon now expects 'isize' bytes to be sent, */
		/* followed by ack byte and status. */

	      }
	    else

#endif /* (SUN3 || SUN4 || ...) */
	      {
		char buf[80];
		int i;

		/* Send download command to monitor running on Archimedes. */

		ServerDebug("Sending ARM monitor download request (t %lX %lX).", armnucbase, isize);

		/* t = transfer(startaddr,size) : binary download */
		sprintf(buf,"t %lX %lX\n", armnucbase, isize) ;

		for (i=0; i < strlen(buf); i++)
		  {
		    if (!xpwrdata(&buf[i], 1))
		      timeout("sending 't' download command to monitor");

#if (!MSWINDOWS)
		    while( xprdrdy() ) /* get rid of any echoed chars */
		      xprdbyte();
#endif
		  }
	      }
	  }
        Debug(Boot_Flag, ("Downloading system image %s, size 0x%lx", system_image, isize) );
/*	printf ("Downloading system image %s, size 0x%lx\n", system_image, isize); */

        for (l = 0L; l < isize; l += MaxChunk) 
	 {
	   cur = (int) (((isize - l) > MaxChunk) ? MaxChunk : isize - l);

			/* read chunk */
           if (fread(cur_data, 1, (size_t)cur, infd) eq 0)
	    {
	      ServerDebug("Failed to read (%x) bytes in system image (read 0x%lx out of 0x%lx).", cur, l, isize);

              fclose( infd );
              infd = (FILE *) NULL;

/*              longjmp(exit_jmpbuf, 1); */
	      longjmp_exit;
            }

	       /* check for user interaction */
           poll_the_devices();
           if (Special_Exit)
	     {
/*	       longjmp(exit_jmpbuf, 1); */
	       longjmp_exit;
	     }

	      /* send image chunk */
           if (!xpwrdata(cur_data, (word) cur))
	    {
	      ServerDebug("Failed to send %d bytes 0x%lx/0x%lx.", cur, l, isize);

              fclose( infd );
              infd = (FILE *) NULL;

              timeout("nucleus");
            }
	   if (target_processor eq Processor_Arm)
	     output(".");
         }
	if (target_processor eq Processor_Arm)
	   {
	     output("\n\r");
	   }

	if (target_processor eq Processor_Arm) {

#if (PC || SUN3 || SUN4 || ARMBSD)

	 if (mystrcmp(box_type, "vy86pid") == 0) {
	   char ack;

	   /* Check PID write memory RDP request acknowledge. */
	   if ((ack = xprdbyte()) != 0x5f) {
		if (ack != 0) {
	    	   	ServerDebug("Error: Unexpected ack type (0x%x) after download request.", ack);
/*    			longjmp(exit_jmpbuf, 1); */
			longjmp_exit;

		} else {
	    	   	ServerDebug("Warning: DEMON monitor request acknowledge was lost.");
		}
	   } else {
		   if ((ack = xprdbyte()) != 0) {
    		   	ServerDebug("Error: Bad status (0x%x) after downloading nucleus, only 0x%x bytes received.", ack, xprdbyte());
/*    			longjmp(exit_jmpbuf, 1); */
			longjmp_exit;

		   }
	   }

#if 1
	    Debug(Boot_Flag, ("Setting the LED's (again)."));
	   /* Light some of the Leds */
	   /* Send memory write request to transfer the nucleus into the PID. */
	   /* 0x3 = Write PID memory RDP request, ledaddr, 1*/
	   if ((!xpwrbyte(0x3)) || (!xpwrint(0x200006c))
		|| (!xpwrint(1L)) || (!xpwrbyte(0x30)))
		timeout("Setting LED's (1100) on");

	   if ((ack = xprdbyte()) != 0x5f) {
    	   	ServerDebug("Error: Unexpected ack type (0x%x) when setting LED's (1100).", ack);
/*    		longjmp(exit_jmpbuf, 1); */
		longjmp_exit;
	   }

	   if ((ack = xprdbyte()) != 0) {
    	   	ServerDebug("Error: Bad status (0x%x) when setting LED's.", ack);
/*    		longjmp(exit_jmpbuf, 1); */
		longjmp_exit;
	   }
#endif
	   ServerDebug("Starting Helios-ARM system (@@ %lX).", kernelstartaddress);

	   /* Send execute request to ROM demon running on PID */
	   /* 0x3 = execute RDP request, 0 = no ack required */
	   if ((!xpwrbyte(0x10)) || (!xpwrbyte(0))) {
		timeout("sending execute request to DEMON monitor");
	   }

	   vy86pid_setup_handshake();
	   
	 } else

#endif
	 {
	   /* Send go command to monitor running on Archimedes. */
	   char buf[80];
	   char *b;

	   ServerDebug("Starting Helios-ARM system (g %lX).", kernelstartaddress);
    	   sprintf(buf,"g %lX\n", kernelstartaddress);
    	   for (b = buf ; *b != '\0'; ) {
		if (!xpwrbyte(*b++))
			timeout("sending 'go' command to monitor") ;
	   }
	 }
	}
      	      /* sent entire nucleus successfully */
        Debug(Boot_Flag, ("System image downloaded"));
        fclose( infd );
        infd = (FILE *) NULL;
        iofree(cur_data);
      }
     else
      { Debug(Boot_Flag, ("Sending System Image (%ld bytes) ...",isize) );
        if (Wander(Image_List, (WordNodeFnPtr)send_bit))
         timeout("system image");
      }
}
/*}}}*/
/*{{{  send configuration vector */
/**
*** The configuration vector
**/

#if !(PC)
PRIVATE Config config;
#else
PRIVATE Config far config;
#endif

/*{{{  build_config() */
PRIVATE word build_config()
{ char *procname = slashDefaultRootName, *myname = slashDefaultServerName;
  char *tempname;
  word memory_size = processor_memory;
  word bootlink    = get_int_config("bootlink");
  word numlinks	   = 4L;
  word flags = 0;
  word i;

  tempname = get_config("root_processor");
  if (tempname ne (char *) NULL) procname = tempname;
  tempname = get_config("io_processor");
  if (tempname ne (char *) NULL) myname = tempname;
  if (memory_size eq Invalid_config) memory_size = 0L;
  if (bootlink eq Invalid_config) bootlink = (word) Default_BootLink;
  if (target_processor eq Processor_C40)
   { numlinks = 6;
     if (!mystrcmp(box_type, "DSP1") ||
	 !mystrcmp(box_type, "VC40") ||
	 !mystrcmp(box_type, "SPIRIT40") )
      numlinks = 7;
   }

  config.PortTabSize = swap(1024L);
  config.Incarnation = swap(1L);
  config.loadbase    = swap(0x80001000L);	/* will be ignored by kernel */
  if (bootstrap_mode & B_Send_Image)
   config.ImageSize   = swap(isize);		/* will be ignored by kernel */
  else
   config.ImageSize  = swap(0L);
  config.Date        = swap(get_unix_time());
  config.FirstProg   = get_int_config("nucleus_firstprog");
  if (config.FirstProg == Invalid_config)
    config.FirstProg   = swap(0L);		/* will default to procman */
  else
    config.FirstProg	= swap (config.FirstProg);
  config.Memory      = swap(memory_size);

  config.Flags       = swap(Config_Flags_rootnode);
  if (get_config("c40_disable_cache") != NULL)
    config.Flags |= swap(Config_Flags_CacheOff);
#if (PC || SUN3 || SUN4 || ARMBSD)

  if ((target_processor eq Processor_Arm) && (mystrcmp(box_type, "vy86pid") == 0))
    config.Spare       = swap(vy86pid_get_configbaud());
  else

#endif
    config.Spare       = swap(0L);

  config.NLinks      = swap(numlinks);
	/* By default the links are dead (not connected). The bootlink	*/
	/* is intelligent and running and has the right flags set, 	*/
	/* parent +  debug + ioserver					*/
  for (i = 0L; i < numlinks; i++)
   config.LinkConf[(int) i] = swap(0x00060000L | (i << 24));

  config.LinkConf[(int) bootlink] &= swap(0xFF00FF00L); 
  if (!mystrcmp(box_type, "DSP1"))
   config.LinkConf[(int) bootlink] |= swap(0x00100370L);
  elif (!mystrcmp(box_type, "HYDRA"))
   config.LinkConf[(int) bootlink] |= swap(0x00110370L);
  elif( !mystrcmp(box_type, "VC40") || !mystrcmp(box_type, "SPIRIT40") )
  {
  	/* setup configuration for shared memory links */

	/*
	 * 00e00000 => SML link, 
	 * 00000300 => Special link,
	 * 00000070 => parent + ioserver + debug
	 */
  	word cfg = 0x00e00370L;
	word tmp;


	/*
 	 * Set SML type
	 */	
#if SUN3
  	if( !mystrcmp(box_type, "VC40") )
	{
		if (VC40_Type == -1)	VC40_Type = vc40_settype ();

		if (VC40_Type == 1)
		{
			/* Ariel's HYDRA I board */
		 	cfg |= 0x00000000L;
		}
		else if (VC40_Type == 2)
		{
			/* Ariel's HYDRA II board */
			cfg |= 0x00100000L;
		}
		else
		{
			ServerDebug ("Error - unknown board type %d", VC40_Type);
		}
	}
#endif
	if( !mystrcmp(box_type, "SPIRIT40") ) 	cfg |= 0x00080000L;

	/*
	 * Set SML strobe
	 */
	if( get_config("c40_sml_g1") ) 		cfg |= 0x00040000L;

	/*
	 * Set SML size
	 */
	tmp = get_int_config("c40_sml_size");

#if SUN3
	if (VC40_Type == 2)
	{
		/* Ariel's HYDRA II board */
		if (tmp == 64)
		{
			ServerDebug ("Bad shared memory size %d, setting to 8", tmp);

			tmp == 8;
		}
	}
#endif
	switch( tmp )
	{
	default:
		ServerDebug("Invalid value for c40_sml_size, set to 8");
	case Invalid_config:
	case 8:		cfg |= 0x00000000;	break;
	case 16:	cfg |= 0x00010000;	break;
	case 32:	cfg |= 0x00020000;	break;
	case 64:	cfg |= 0x00030000;	break;
	}

	config.LinkConf[(int) bootlink] |= swap(cfg);
  }
  else
  {
	config.LinkConf[(int) bootlink] |= swap(0x00030270L);
  }

  /* if half duplex protocol is not disabled, set it on the boot link */
  if (C40HalfDuplex)
	    config.LinkConf[(int) bootlink] |= swap(Link_Flags_HalfDuplex);

  config.MyName      = swap( ((word) &config.LinkConf[numlinks]) -
                             ((word) &config.MyName));
  config.ParentName  = swap( (((word) &config.LinkConf[numlinks]) +
			     strlen(procname) + 1) -
                             ((word) &config.ParentName) );

  strcpy( ((char *)&config.LinkConf[numlinks]), procname);
  strcpy( ((char *)&config.LinkConf[numlinks]) + strlen(procname) + 1, myname );

  return((word) (sizeof(Config) + ((numlinks - 1) * sizeof(word)) +
		strlen(procname) + 1 + strlen(myname) + 1 - CONFIGSPACE));
}
/*}}}*/

PRIVATE void send_conf()
{ word size = build_config();

  if (debugflags & Boot_Flag)
     ServerDebug("Sending configuration ...");

#if (PC || SUN3 || SUN4 || ARMBSD)

  /* Initial comms with VLSI PID board must be at a know rate (9600). */
  /* The config vector defines the agreed rate for all future communications */
  if ((target_processor eq Processor_Arm) && (mystrcmp(box_type, "vy86pid") == 0))
   vy86pid_set_baudrate(9600L, FALSE);

#endif

  if (!xpwrint(size))
   timeout("system configuration size");
  if (target_processor eq Processor_C40)
   size = (size + 3L) & ~3L;

  if (!xpwrdata((byte *) &config,size))
    timeout("system configuration");

#if (PC || SUN3 || SUN4 || ARMBSD)

  /* Now communicate at agreed rate defined in host.con and sent via config. */
  /* The second argument controls use of the fifo.			     */
  if ((target_processor eq Processor_Arm) && (mystrcmp(box_type, "vy86pid") == 0))
  {
    vy86pid_set_baudrate(vy86pid_get_configbaud(), TRUE);
  }

#endif
}
/*}}}*/
/*{{{  wait for ACK */
/**
*** The main job of this routine is to wait for the kernel to start up
*** sufficiently for it to need to know a port on my side of the link. This
*** involves the processor sending a byte F0, followed by some more junk,
*** and I reply with junk plus a pseudo port for the IOproc device.
***
*** If we are trying to attach to a running system we simply send a sync
*** message to it. This lets it know we are now attached, we do not then
*** need to wait for a sync back.
**/

PRIVATE void server_helios()
{ 
  long i;

  if(bootstrap_mode & B_Send_Sync)
  {
    Debug(Boot_Flag, ("Attaching to remote system") );

/*{{{  ARMBSD bodge */
#if ARMBSD
    if (get_config("abc_protobodge3") ne NULL) {
	/* *TEMPORARY FIX* */
	/* send ResyncRequest that we know will get mangled */
        /* by abc's exec. The exec erroneously */
	/* duplicates the first char it receives down the link. */
	/* Thus creating the impression that the port to talk to the IO */
        /* Server on is 100, rather than 1! */
	send_resync();
	/* @@@@@@ This should probably become standard */
    }
#endif
/*}}}*/

    if (!send_info_request())
      timeout("attach request");
    else
      output("Attached...\r\n");

    return;
  }

  if(!(bootstrap_mode & B_Wait_Sync))
    return;

  if (target_processor == Processor_C40) 
   {	/* Due to problems with the half duplex nature of the links */
	/* The C40 never sends the IOServer Proto_Info's. Instead   */
        /* the bootstrap code acknowledges earlier on.              */

#if SUN3
	if (VC40_Type == -1)	VC40_Type = vc40_settype ();

	if (VC40_Type == 2)
	{
		/* 
		 * Need to wait for helios kernel to initialise shared mem link
		 * before enabling interupts.
		 */
		vc40_enint ();
	}
#endif
	output("TMS320C40 Booted...\r\n");
  	return; /* the processor is now ready */
   }

  Debug(Boot_Flag, ("Waiting for sync byte from kernel") );

  for(i=0L;i < 1000000L;i++)
   {
#if multi_tasking
     if (!Multiwait()) continue;
#endif

     poll_the_devices();
     if (Special_Exit)
       {
	 /* longjmp(exit_jmpbuf, 1); */
	 longjmp_exit;
       }

     if (Special_Status)                /* or for status request */
      { ServerDebug("Server alive and well.");
        Special_Status = false;
      }
     if (Special_Reboot || DebugMode)            /* or for reboot condition */
        return;
     if( xprdrdy() )
      { word b=0L;

	if (target_processor eq Processor_C40)
	 b = xprdint();
	else
         b = xprdbyte();

        switch( (int) b )
         { case Proto_Info:
                      handle_info_request();
                      output("Booted...\r\n");
                      return; /* the processor is now ready */
           default:
                      ServerDebug("Unexpected byte 0x%lx.",b);
                      break;
         }
      }
   }

   printf("Failed to receive synchronisation byte.\n Server Aborting\n");
/*   longjmp(exit_jmpbuf, 1); */
	longjmp_exit;
}

PRIVATE void handle_info_request()
{ word a, iocport;
  word *x = (word *) &(misc_buffer1[0]);

  if (target_processor == Processor_C40)
	ServerDebug("Warning: C40 requested info exchange");

  Debug(Boot_Flag, ("Received an F0 sync.") );

  if (target_processor == Processor_C40)
    xprddata(&(misc_buffer1[4]), 8L);	/* C40 sends word size prototype byte */
  else
    xprddata(&(misc_buffer1[1]), 11L);

  a = swap(x[1]);
  iocport = swap(x[2]);

  if ( (a & 0x00FF0000L) ne 0L)
   { Debug(Boot_Flag, ("Sending back info"));
     x[0] = swap(0xf0f0f0f0L);
     x[1] = swap(0x00000100L);
     x[2] = swap(1L);
     xpwrdata(&(misc_buffer1[0]), 12L);
   }
}

PRIVATE int send_info_request()
{
  word *x = (word *) &(misc_buffer1[0]);

  x[0] = swap(0xf0f0f0f0L);	/* Proto_Sync */
  x[1] = swap(0x00000100L);	/* 1st incarnation + no reply required */
  x[2] = swap(1L);		/* IO Servers port */

  return (int)(xpwrdata(&(misc_buffer1[0]), 12L));
}

PRIVATE int send_resync()
{
  word *x = (word *) &(misc_buffer1[0]);

  /* Send at least same size as a SendInfo message */

  /* Sending resyncs of at least sizeof(MshHdr) + MaxContolSize + MaxDataSize */
  /* (16 + 256 + 64k) would probably be acceptable over 10Mb links */

  x[0] = swap(0x7f7f7f7fL);
  x[1] = swap(0x7f7f7f7fL);
  x[2] = swap(0x7f7f7f7fL);

  return (int)(xpwrdata(&(misc_buffer1[0]), 12L));
}
/*}}}*/
/*{{{  message passing */

/*------------------------------------------------------------------------
-- The following routines provide an interface to message passing       --
-- with the processor.                                                 --
------------------------------------------------------------------------*/

/**
*** It is desirable that all message interaction between processor and host
*** go via a small set of routines, and for historical reasons these are the
*** ones. Messages are always received by the root coroutine inside the main
*** loop, by calls to Request_Stat() and Request_Get(). The messages are
*** buffered in mcbstruct, which is set up by init_main_message() and the
*** space obtained is freed again by free_main_message(). It is important
*** that coroutines do not do their own GetMsg's, because the local GetMsg
*** does not know anything about ports etc. and I do not want to complicate it.
*** 
*** Request_Stat() is the routine that gets hold of any messages the processor
*** is trying to send. Some of these messages may be very low-level debugging
*** ones, identified by a FnRc of 0x22222222L, and these are treated separately.
*** I have to worry a little bit to make sure that all debugging messages
*** appear on separate lines, assuming they are not too interleaved. If another
*** message is received the routine returns true, and main_loop calls
*** Request_Get() to get hold of it. In fact the value returned is always the
*** same, the address of the main message, but this call allows me to clear
*** the flags field which is desirable according to NHG.
***
*** When a reply is to be sent to the processor this goes via Request_Return(),
*** which plays about a bit with the message to make sure that each coroutine
*** does not have to worry about swapping ports around etc. There is also a
*** user debugging facility, and a test for the special case of sending a
*** message to the invalid port zero which is strongly indicative of a bug
*** in the server. If for some reason Request_Return() is unable to send its
*** message this is indicative of the processor having crashed, so I output
*** a suitable message.
***
*** GetMsg() can return three values. It can return true if the machine has
*** received a complete Helios message, false if it has not received anything
*** or 0xF0 if it has received the first byte of a raw message. GetMsg() itself
*** is responsible for handling all peek and poke requests coming from the
*** processor.
**/

PRIVATE MCB  mcbstruct;
PRIVATE word control[256];
PRIVATE byte *real_buff = (byte *) NULL;

void init_main_message()
{ uint amount = (uint) (maxdata + 1000L);
  byte *temp;

#if PC
  if (maxdata > 64000L) maxdata = 64000L;	/* segment problems */
#endif

  temp = (byte *) malloc(amount);
  if (temp eq NULL)
    { ServerDebug("Insufficient memory on the server machine for message buffer.");
/*      longjmp(exit_jmpbuf, 1); */
	longjmp_exit;
    }
  real_buff          = temp;
  mcbstruct.Data     = (byte *) (( ((word)temp) + 511L) & 0xFFFFFE00L);
  mcbstruct.Control  = &(control[0]);
  mcb = &mcbstruct;
}

#if ANSI_prototypes
void free_main_message(void)
#else
void free_main_message()
#endif
{ if (real_buff ne (byte *) NULL) iofree(real_buff);
}

int newdebug = true;

word Request_Stat()
{ word j = 0L;

  mcbstruct.Timeout = 0x0FFL;
#if AMIGA
  j = GetHeliosMsg(&mcbstructs);
#else  
  j = GetMsg(&mcbstruct);
#endif

  if (j eq Proto_Info)
   { handle_info_request(); return(0); }
  elif (j) 
     { if (mcbstruct.MsgHdr.FnRc eq 0x22222222L)
         { int x;
           for (x = 0; x < (int)(mcbstruct.MsgHdr.DataSize); x++)
            { if (newdebug)
               { ServerDebug("+++ %q");
                 newdebug = false;
               }

              if (mcbstruct.Data[x] eq '\r')	/* remove spurious CR's */
		continue;

              if (mcbstruct.Data[x] eq '\n')
               { ServerDebug("");		/* add in spurious CR's */
                 newdebug = true;
                 continue;
               }
              ServerDebug("%c%q", mcbstruct.Data[x]);
            }
           mcbstruct.MsgHdr.Flags = 0;
           mcbstruct.MsgHdr.Dest = 0;
           mcbstruct.MsgHdr.Reply = 0;
           return(false);
         }
       else
        { mcbstruct.MsgHdr.Flags = 0;        /* on NickG's orders */
          return(true);
        }
     }

   return(false);
}

void Request_Return(code, contlen, datalen)
word code, contlen, datalen;
{ word temp;

  mcb->MsgHdr.FnRc      = code;
  mcb->MsgHdr.DataSize  = (USHORT) datalen;
  mcb->MsgHdr.ContSize  = (byte) contlen;
  temp                  = mcb->MsgHdr.Dest;
  mcb->MsgHdr.Dest      = mcb->MsgHdr.Reply;
  mcb->MsgHdr.Reply     = temp;
  mcb->Timeout          = 0x07FFFL;
  
  if (debugflags)
  {
    if (debugflags & Message_Flag)
      ServerDebug("Reply (from 0x%lx) : fn 0x%lx, port 0x%lx, csize %ld, dsize %ld",
             mcb->MsgHdr.Reply, code, mcb->MsgHdr.Dest, contlen, datalen);
  
    if (debugflags & Error_Flag)
       if ((code & 0x80000000L) ne 0)
          ServerDebug("Error : fn 0x%lx", code);
  }

  if (mcb->MsgHdr.Dest eq 0L)
      return;

#if AMIGA
  if (!PutHeliosMsg(mcb))
#else  
  if (!PutMsg(mcb))
#endif
    { output("***\r\n");
      output("*** Serious : the root processor failed to receive a message.\r\n");
#if (ST || PC)
      output("***           To reboot the system, use the Control, Shift and\r\n");
      output("***           F10 keys at the same time.\r\n");
#endif
      output("***\r\n");
    }

  mcb->MsgHdr.Flags = 0;     /* Clean out these entries */
  mcb->MsgHdr.Dest  = 0L;
  mcb->MsgHdr.Reply = 0L;
}
/*}}}*/
@


1.48
log
@tload checks size of nucleus when sending data, rather than
reading the size from the first word in the nucleus.
@
text
@d7 1
d14 1
a14 1
--      root processor on start-up, and interacting with the           --
d16 1
a16 1
--      processor network.                                             --
d21 1
a21 1
/* RcsId: $Id: tload.c,v 1.46 1994/06/29 13:42:25 tony Exp $ */
d1165 1
a1165 1
		ServerDebug("Initialising communications with VY86PID (%ld baud)", reqspeed);
d1182 1
a1182 1
		    timeout("Initialising communications with VY86PID");
d1302 1
a1302 1
		    timeout("Sending VY86PID download request");
d1395 1
a1395 1
	    	   	ServerDebug("Warning: VY86PID demon request acknowledge was lost.");
d1432 1
a1432 1
		timeout("sending execute request to VY86PID");
@


1.47
log
@Fixed some bugs introduced by Tony's changes
@
text
@d28 2
d378 1
d404 4
a411 1

d418 16
d1012 1
d1059 4
d1077 14
@


1.46
log
@Support for Ariel's Hydra II board added.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.39 1993/12/01 17:30:20 bart Exp $ */
d439 1
a439 1
#if !SOLARIS
d456 1
a456 1
#if !SOLARIS
d867 1
a867 1
#if !SOLARIS
d875 1
a875 1
#if !SOLARIS
d1000 1
a1000 1
#if !SOLARIS
d1514 1
a1514 1
#if !SOLARIS
d1547 1
a1547 1
#if !SOLARIS
d1681 1
a1681 1
#if !SOLARIS
@


1.45
log
@Updated ARM LEDs control to be a simple boolean control.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.38 1993/10/27 14:35:36 bart Exp $ */
d27 2
a71 1

a73 1

d121 2
a122 1
       longjmp(exit_jmpbuf, 1);
d196 4
a199 2
   load_boot();
 
d201 3
a203 1
   return(test_processor());
a206 1

d213 1
a213 1
  { free(bootstrap); bootstrap = NULL; }
d229 3
d234 5
a238 3
      { resetlnk();
        xpreset();
        unless(xpwrbyte(0L))          continue;
d243 1
a243 1
        if (xprdint() ne 0x12345678L) continue;
d255 1
d258 2
d273 7
d281 3
d294 2
a295 1
  longjmp(failure_buf, 1);
d301 3
a303 1
{ if (setjmp(failure_buf) ne 0) goto failed;
d305 5
d313 1
d315 1
d318 1
d327 5
d334 1
d385 2
a386 1
     longjmp(exit_jmpbuf, 1);
d439 7
d456 1
d458 8
a465 1
         name = "c40aboot.i";
d520 1
a520 1
  bootstrap =  malloc((uint) bootsize);
d536 2
a537 1
  longjmp(exit_jmpbuf, 1);
d607 2
a608 1
	 longjmp(failure_buf, 1);
d615 2
a616 1
      { if (!xpwrbyte(bootsize))              /* bootstrap size */
a636 1

d691 1
d693 1
d696 1
d698 1
d700 1
d702 1
d704 1
d706 1
d708 1
d710 1
d721 1
d723 1
d726 1
d728 1
d731 1
d733 1
d736 1
d738 1
d740 1
d742 1
d744 1
d746 1
d749 1
d751 1
d753 1
d755 1
d757 1
d759 1
d761 1
d763 1
d766 1
d768 1
d770 1
d772 1
d774 1
d776 1
d778 1
d780 1
d783 1
d785 1
d788 1
d790 1
d792 1
d794 1
d797 1
d799 1
d801 1
d803 1
d806 1
d808 1
d810 1
d812 1
d815 1
d817 1
d819 1
d821 1
d824 1
d826 1
d828 1
d830 1
d832 1
d834 1
d836 1
d838 1
d841 1
d843 1
d845 1
d847 1
d850 1
d852 2
d855 1
d857 1
d861 3
d867 2
a868 2
			word sramsize = get_int_config("c40_sml_size");
			switch( sramsize )
d870 1
a870 9
			default:
				ServerDebug("Invalid size for shared RAM, 8k assumed");
			case Invalid_config:
				sramsize = 8;
			case 8:
			case 16:
			case 32:
			case 64:
				sramsize *= 256;	/* size in WORDS */
d872 21
d894 9
a902 4
			if( get_config("c40_sml_g1") )
				ID_ROM.GSIZE1 -= sramsize;
			else
				ID_ROM.GSIZE0 -= sramsize;
a956 1

a958 1

d964 5
a968 1
  if (Special_Exit) longjmp(exit_jmpbuf, 1);
d981 2
d991 4
d996 15
a1010 1
		MaxChunk = 1024 * 4;
d1013 4
a1016 3
         { ServerDebug("No system image defined in host.con file.");
           longjmp(exit_jmpbuf, 1);
         }
d1018 1
a1018 1
      	     /* allocate mem for chunk to be read in and sent */
d1020 4
a1023 3
	 { ServerDebug("Insufficient memory to store system image.");
           longjmp(exit_jmpbuf, 1);
         }
d1031 4
a1034 3
	 { ServerDebug("Cannot open image %s for input.", system_image);
           longjmp(exit_jmpbuf, 1);
         }
d1037 4
a1040 3
	 { ServerDebug("Cannot read image header.");
           longjmp(exit_jmpbuf, 1);
         }
d1045 54
a1098 47
	 {  /* and reset file to beginning */
           ServerDebug("Failed to seek image.");
           longjmp(exit_jmpbuf, 1);
         }

	if (target_processor eq Processor_Arm) {
	 armnucbase = get_int_config("arm_nucleus_base");

	 if (armnucbase == Invalid_config)
		armnucbase = 0xa000L;

	 /* Calculate ARM nucleus execution address: */
	 kernelstartaddress = get_int_config( "kernel_start_address" );
	 
	 if (kernelstartaddress == Invalid_config)
	   {
        /* Start address = nucbase + size word + 6 module slot words */
        /*			+ 0 word + modhdr struct */
        kernelstartaddress = ((word)(armnucbase + (8 * 4) + 60));
       }

#if (PC || SUN3 || SUN4 || ARMBSD)
	 if (mystrcmp(box_type, "vy86pid") == 0) {
	   word regs[6];
	   word reqspeed, pidspeed, hwconfig;
	   char ack;
#if 0 /* 940524 : changed to single boolean LED control */
       char *leds_type = get_config("arm_leds");
#endif

	   /* Get host.con defined comms speed. */
	   reqspeed = vy86pid_get_configbaud();

       /* FIXME: The following flag bits are defined in the
        * "include/ampp/arm.m" header only at the moment. This source
        * should be kept in step until the header files are
        * cleaned-up.
        */
       hwconfig = 0; /* default state */

       if (get_config("arm_disable_cache") == NULL)
        hwconfig |= (1 << 24) ; /* cache should be on */
       if (get_config("arm_disable_writebuffer") == NULL)
        hwconfig |= (1 << 25) ; /* write-buffer should be on */
       if (get_config("arm_protect_nucleus") != NULL)
        hwconfig |= (1 << 26) ; /* nucleus should be protected */

d1100 4
a1103 2
       if (get_config("arm_user_leds") == NULL)
        hwconfig |= (1 << 27) ; /* the Kernel uses the LEDs */
d1105 180
a1284 106
       if (mystrcmp(leds_type,"heartbeat") == 0)
        hwconfig |= (1 << 27) ;
       else
        if (mystrcmp(leds_type,"user") != 0) {
         ServerDebug("Error: Invalid arm_leds option \"%s\"",leds_type);
         longjmp(exit_jmpbuf, 1);
        }
#endif

	   ServerDebug("Initialising communications with VY86PID (%ld baud)", reqspeed);

	   /* Convert host.con requested comms speed to PID values. */
	   /* 1 = 9600, 2 = 19200, 3 = 38400 */
	   pidspeed = (reqspeed == 38400L) ? 3L : ((reqspeed == 19200L) ? 2L : 1L);

	   /* Default baud rate is 9600. The initial open must be done */
	   /* at this speed, all further comms will be at requested speed. */
	   /* The second parameter controls use of the fifo.			*/
	   vy86pid_set_baudrate(9600L,FALSE);

	   /* 0x0 = Open/Init RDP request, 0x2 = cold reset cpu, reset comms */
	   /* 0 = use all memory on board, speed = 1/9600, 2/19200, 3/38400 */
	   if ((!xpwrbyte(0x0)) || (!xpwrbyte(0x2)) || (!xpwrint(0)) ||
		(!xpwrbyte((byte)pidspeed)))
		timeout("Initialising communications with VY86PID");

	   /* Ack is returned at old speed */
	   if ((ack = xprdbyte()) != 0x5f) {
    	   	ServerDebug("Error: Unexpected ack type (0x%x) when initialising communications.", ack);
    		longjmp(exit_jmpbuf, 1);
	   }
	   if ((ack = xprdbyte()) != 0) {
    	   	ServerDebug("Error: Bad status (0x%x) when initialising communications.", ack);
    		longjmp(exit_jmpbuf, 1);
	   }

	   /* Now set to host.con requested speed for further transactions */
	   vy86pid_set_baudrate(reqspeed,FALSE);

	   Debug(Boot_Flag, ("Initialising execution environment."));

	   /* Setup register contents required for kernel startup */
	   regs[0] = swap(0x02000020L);		/* r0 = comms port address */
	   regs[1] = swap(armnucbase);		/* r1 = nucleus base */
       regs[2] = swap(hwconfig);        /* r2 = hardware configuration */
       regs[3] = swap(0x00000000);      /* r3 = reserved (for configuration) */
	   regs[4] = swap(kernelstartaddress);	/* pc = kernel start address */
	   regs[5] = swap(0xD3L);		/* cpsr = SVC32 mode FIQ/IRQ disabled */

	   /* 0x5 = Write CPU state RDP request, 0xff = current mode */
	   /* 0x05000F = mask to write regs r0, r1, r2, r3 pc and cpsr */
	   /* and the contents of the four registers. */
	   if ((!xpwrbyte(0x5)) || (!xpwrbyte(0xff)) || (!xpwrint(0x05000FL)) ||
		(!xpwrdata((byte *)regs, 6L * sizeof(word))) )
		timeout("Initialising execution environment");

	   if ((ack = xprdbyte()) != 0x5f) {
    	   	ServerDebug("Error: Unexpected ack type (0x%x) when initialising execution environment.", ack);
    		longjmp(exit_jmpbuf, 1);
	   }
	   if ((ack = xprdbyte()) != 0) {
    	   	ServerDebug("Error: Bad status (0x%x) when initialising execution environment.", ack);
    		longjmp(exit_jmpbuf, 1);
	   }

	   /* Do a little validation that we are talking the same language. */
	   Debug(Boot_Flag, ("Checking execution environment."));
	   regs[0] = regs[1] = regs[2] = regs[3] = regs[4] = regs[5] = 0;

	   /* 0x4 = Read CPU state RDP request, 0xff = current mode */
	   /* 0x05000F = mask to read regs r0, r1, r2, r3, pc, cpsr. */
	   if ((!xpwrbyte(0x4)) || (!xpwrbyte(0xff)) || (!xpwrint(0x05000FL)))
		timeout("Checking execution environment");

	   if ((ack = xprdbyte()) != 0x5f) {
    	   	ServerDebug("Error: Unexpected ack type (0x%x) when checking execution environment.", ack);
    		longjmp(exit_jmpbuf, 1);
	   }
	   if (!xprddata((byte *)regs, 6L * sizeof(word)) )
		timeout("Reading execution environment");

	   Debug(Boot_Flag, ("Execution Env: r0/a1 %lx, r1/a2 %lx, r2/a3 %lx, pc %lx, psr %lx", swap(regs[0]),
		swap(regs[1]), swap(regs[2]), swap(regs[4]), swap(regs[5])));

	   if ((ack = xprdbyte()) != 0) {
    	   	ServerDebug("Error: Bad status (0x%x) when checking execution environment.", ack);
    		longjmp(exit_jmpbuf, 1);
	   }

	    Debug(Boot_Flag, ("Setting the LED's."));
	   /* Light all the Leds! */
	   /* Send memory write request to transfer the nucleus into the PID. */
	   /* 0x3 = Write PID memory RDP request, ledaddr, 1*/
	   if ((!xpwrbyte(0x3)) || (!xpwrint(0x200006c))
		|| (!xpwrint(1L)) || (!xpwrbyte(0)))
		timeout("Setting the LED's");

	   if ((ack = xprdbyte()) != 0x5f) {
    	   	ServerDebug("Error: Unexpected ack type (0x%x) when when setting LED's.", ack);
    		longjmp(exit_jmpbuf, 1);
	   }

	   if ((ack = xprdbyte()) != 0) {
    	   	ServerDebug("Error: Bad status (0x%x) when setting LED's.", ack);
    		longjmp(exit_jmpbuf, 1);
	   }
a1285 28
	   ServerDebug("Sending download request (@@ 0x%lx, size 0x%lx).", armnucbase, isize);

	   /* Send memory write request to transfer the nucleus into the PID. */
	   /* 0x3 = Write PID memory RDP request, @@ armnucbase, nucsize */
	   if ((!xpwrbyte(0x3)) || (!xpwrint(armnucbase))
		|| (!xpwrint(isize)))
		timeout("Sending VY86PID download request");

	   /* PID demon now expects 'isize' bytes to be sent, */
	   /* followed by ack byte and status. */

	 } else
#endif
	 {
	   char buf[80];
	   int i;

	   /* Send download command to monitor running on Archimedes. */

	   ServerDebug("Sending ARM monitor download request (t %lX %lX).", armnucbase, isize);

	   /* t = transfer(startaddr,size) : binary download */
	   sprintf(buf,"t %lX %lX\n", armnucbase, isize) ;

    	   for (i=0; i < strlen(buf); i++) {
    	      if (!xpwrdata(&buf[i], 1))
    	      	timeout("sending 't' download command to monitor");

d1287 2
a1288 2
	      while( xprdrdy() ) /* get rid of any echoed chars */
	        xprdbyte();
d1290 3
a1292 3
	   }
	 }
	}
d1294 1
d1297 3
a1299 1
	 { cur = (int) (((isize - l) > MaxChunk) ? MaxChunk : isize - l);
d1302 3
a1304 1
	    { ServerDebug("Failed to read (%x) bytes in system image (read 0x%lx out of 0x%lx).", cur, l, isize);
d1307 3
a1309 1
              longjmp(exit_jmpbuf, 1);
d1314 5
a1318 1
           if (Special_Exit) longjmp(exit_jmpbuf, 1);
d1322 3
a1324 1
	    { ServerDebug("Failed to send %d bytes 0x%lx/0x%lx.", cur, l, isize);
d1327 1
d1331 1
a1331 1
	    output(".");
d1333 4
a1336 2
         if (target_processor eq Processor_Arm)
          output("\n\r");
d1341 1
d1349 3
a1351 1
    			longjmp(exit_jmpbuf, 1);
d1358 3
a1360 1
    			longjmp(exit_jmpbuf, 1);
d1365 2
a1366 2
	    Debug(Boot_Flag, ("Setting the LED's"));
	   /* Light all the Leds! */
d1374 3
a1376 2
    	   	ServerDebug("Error: Unexpected ack type (0x%x) when when setting LED's (1100).", ack);
    		longjmp(exit_jmpbuf, 1);
d1381 2
a1382 1
    		longjmp(exit_jmpbuf, 1);
d1396 1
d1415 1
a1415 1
        free(cur_data);
d1419 1
a1419 1
        if (Wander(Image_List, send_bit))
a1422 1

a1435 1

a1466 2
  config.Memory      = swap(memory_size);

d1469 1
a1469 1
   config.FirstProg  = 0L; /* will default to procman */
d1471 2
a1472 1
   config.FirstProg  = swap(config.FirstProg);
d1478 1
d1482 1
d1502 5
d1509 26
a1534 2
	
  	if( !mystrcmp(box_type, "VC40") ) 	cfg |= 0x00000000L;
d1536 4
d1541 4
d1546 13
d1573 4
a1576 2
   config.LinkConf[(int) bootlink] |= swap(0x00030270L);
   
a1592 1

d1602 1
d1606 2
a1607 1
   vy86pid_set_baudrate(9600L,FALSE);
d1619 1
d1621 1
a1621 1
  /* The second argument controls use of the fifo.				*/
d1623 4
a1626 3
   {
    vy86pid_set_baudrate(vy86pid_get_configbaud(),TRUE);
   }
d1680 13
d1706 6
a1711 1
     if (Special_Exit) longjmp(exit_jmpbuf, 1);
d1739 2
a1740 2
   longjmp(exit_jmpbuf, 1);

d1854 2
a1855 1
      longjmp(exit_jmpbuf, 1);
d1863 3
d1867 2
a1868 1
{ if (real_buff ne (byte *) NULL) free(real_buff);
d1888 1
a1888 1
           for (x = 0; x < mcbstruct.MsgHdr.DataSize; x++)
@


1.44
log
@Added some new configuration support for Helios-ARM.
   arm_disable_cache
   arm_disable_writebuffer
   arm_leds
Also updated PID/PIE startup registers.
@
text
@d894 1
d896 1
d915 4
d926 1
@


1.43
log
@Added another (ARM specific) configuration option: "kernel_start_address" which specifies where to start execution of the kernel.  Default is 0xa05c.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.42 1994/04/19 15:35:39 bart Exp nickc $ */
d70 1
d579 1
d806 1
d884 4
a887 4
	     /* Start address = nucbase + size word + 6 module slot words */
	     /*			+ 0 word + modhdr struct */
	     kernelstartaddress = ((word)(armnucbase + (8 * 4) + 60));
	   }
d891 2
a892 2
	   word regs[4];
	   word reqspeed, pidspeed;
d894 1
d899 22
d927 2
a928 2
	   /* Default baud rate is 9600. The initial open must be done		*/
	   /* at this speed, all further comms will be at requested speed.	*/
d930 1
a930 1
	   vy86pid_set_baudrate(9600L, FALSE);
d949 1
a949 1
	   vy86pid_set_baudrate(reqspeed, FALSE);
d956 4
a959 7
	   regs[2] = swap(kernelstartaddress);	/* pc = kernel start address */
#if 1
		/* New APCS3 32bit ARM6 world */
	   regs[3] = swap(0xD3L);		/* cpsr = SVC32 mode FIQ/IRQ disabled */
#else
	   regs[3] = swap(0xC3L);		/* cpsr = SVC26 mode FIQ/IRQ disabled */
#endif
d962 1
a962 1
	   /* 0x050003 = mask to write regs r0, r1, pc, cpsr */
d964 2
a965 2
	   if ((!xpwrbyte(0x5)) || (!xpwrbyte(0xff)) || (!xpwrint(0x050003L)) ||
		(!xpwrdata((byte *)regs, 4L * sizeof(word))) )
d979 1
a979 1
	   regs[0] = regs[1] = regs[2] = regs[3] = 0;
d982 2
a983 2
	   /* 0x050003 = mask to read regs r0, r1, pc, cpsr. */
	   if ((!xpwrbyte(0x4)) || (!xpwrbyte(0xff)) || (!xpwrint(0x050003L)))
d990 1
a990 1
	   if (!xprddata((byte *)regs, 4L * sizeof(word)) )
d993 2
a994 2
	   Debug(Boot_Flag, ("Execution Env: r0 %lx, r1 %lx, pc %lx, psr %lx", swap(regs[0]),
		swap(regs[1]), swap(regs[2]), swap(regs[3])));
d1174 1
d1210 1
a1210 1
   config.FirstProg  = 0L;
d1279 1
d1292 1
a1292 1
   vy86pid_set_baudrate(9600L, FALSE);
d1304 1
a1304 1
  /* Now communicate at agreed rate defined in host.con and sent via config.	*/
d1307 3
a1309 3
  {
  	vy86pid_set_baudrate(vy86pid_get_configbaud(), TRUE);
  }
@


1.42
log
@New host.con option nucleus_firstprog, which can be used to specify the
nucleus slot associated with the program that should be started by the
kernel.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.41 1994/04/07 10:57:33 nickc Exp $ */
d877 8
a884 3
	 /* Start address = nucbase + size word + 6 module slot words */
	 /*			+ 0 word + modhdr struct */
	 kernelstartaddress = ((word)(armnucbase + (8 * 4) + 60));
@


1.41
log
@fixed default value for arm_nucleus_base
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.40 1994/01/25 11:47:01 bart Exp nickc $ */
a1176 1
  config.FirstProg   = swap(0L);		/* will default to procman */
d1178 6
@


1.40
log
@Various changes to the VY86PID bootstrap
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.39 1993/12/01 17:30:20 bart Exp $ */
d72 1
d201 1
d806 1
d873 1
a873 1
	 if (armnucbase == 0)
d1132 1
@


1.39
log
@Added support for vy86pid hardware handshaking
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.38 1993/10/27 14:35:36 bart Exp $ */
d893 4
a896 3
	   /* Default baud rate is 9600. The initial open must be done */
	   /* at this speed, all further comms will be at requested speed. */
	   vy86pid_set_baudrate(9600L);
d915 1
a915 1
	   vy86pid_set_baudrate(reqspeed);
d1253 1
a1253 1
   vy86pid_set_baudrate(9600L);
d1265 2
a1266 1
  /* Now communicate at agreed rate defined in host.con and sent via config. */
d1268 3
a1270 1
   vy86pid_set_baudrate(vy86pid_get_configbaud());
@


1.38
log
@Fixed problem with Windows I/O Server, the timer routine could walk
down an uninitialised list.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.37 1993/09/01 16:10:24 paul Exp $ */
d1099 2
@


1.37
log
@fixed for new 32bit ARM world on the VLSI PID board.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.36 1993/08/22 12:08:34 bart Exp $ */
a1023 4
#if (MSWINDOWS)
	SkipTimer = TRUE;
#endif

a1049 4

#if (MSWINDOWS)
	SkipTimer = FALSE;
#endif
@


1.36
log
@Various changes by Mike Gunning to fix problems with vy86pid bootstrap
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.35 1993/07/02 17:10:01 bart Exp bart $ */
d922 4
d927 1
@


1.35
log
@Fixed the C40 magic numbers - again
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.32 1993/04/01 16:32:22 nick Exp $ */
d1010 1
d1013 1
d1019 4
d1049 4
@


1.34
log
@Changed the magic numbers used for global and local bus control
when booting up a C40
@
text
@d511 2
a512 2
			Global Bus memory control word:		0x3d39fff0
			Local Bus memory constrol word:		0x3d39fff0
d525 1
a525 1
        if (!xpwrint(0x3d39fff0))		 /* global bus cntrl */
d527 1
a527 1
        if (!xpwrint(0x3d39fff0))		 /* local bus cntrl */
d618 2
a619 2
/* same as C40 reset */	0x1e39fff0,	/* global bus control register */
/* same as C40 reset */	0x1e39fff0,	/* local bus control register */
@


1.33
log
@Incorrect use of WORD rather than word, causing problems with
Windows I/O Server
@
text
@d511 2
a512 2
			Global Bus memory constrol word:	0x3e4a4000
			Local Bus memory constrol word:		0x3e4a4000
d525 1
a525 1
        if (!xpwrint(0x3e4a000))		 /* global bus cntrl */
d527 1
a527 1
        if (!xpwrint(0x3e4a000))		 /* local bus cntrl */
d529 1
@


1.32
log
@Adjustment to global strobe size added for shared RAM systems.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.31 1993/03/23 14:29:23 bart Exp $ */
d729 1
a729 1
			WORD sramsize = get_int_config("c40_sml_size");
@


1.31
log
@1) cleaned up the C40HalfDuplex support
2) changed various interactions with Hydra, so that Hydra can support
   C40 boards
3) new bootstrap mechanism to support the VY86PID board
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.30 1993/03/05 11:15:19 nick Exp $ */
d723 25
@


1.30
log
@Shared memory links are now configurable to some extent from the
host.con file. Code added to support this.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.29 1993/02/03 11:53:53 nick Exp $ */
d42 1
a42 1
                             
d174 5
a178 2
  if (get_config("c40_disable_halfduplex") != NULL)
  	C40HalfDuplex = FALSE;
a255 4
***
*** There are various nasty cases to consider near the end, mostly affecting
*** Unix boxes. For example, if the processor is being booted remotely,
*** using the link daemon hydra, the bootstrap process has to be modified.
d296 1
a296 3
  if (Server_Mode eq Mode_Remote)
   ServerDebug("Booted.");
  else if (mode ne debugboot)
d299 7
a487 8
  if (Server_Mode eq Mode_Remote)
   {
     Debug(Boot_Flag, ("Starting remote bootstrap.") );
     xpwrbyte((word) Proto_RemoteReset);
     xpwrbyte((word) Proto_Boot);
     xpwrint( (word) bootstrap_mode);
   }

d495 1
a495 1
  else if (bootstrap_mode & B_Reset_Processor)
d801 2
d804 3
d813 1
a813 1
        if ((cur_data = (char *)malloc((uint)C40MAXCHUNK)) eq NULL)
a840 1
		/* send initial message to monitor running on Archimedies. */
d842 128
d973 1
a973 1
#	   define ARMNUCBASE 0x3000L
d975 1
a975 1
	   ServerDebug("Sending ARM monitor download request (t %lX %lX)\n", ARMNUCBASE, isize);
d978 1
a978 1
	   sprintf(buf,"t %lX %lX\n", ARMNUCBASE, isize) ;
d988 2
d991 2
a992 4
        Debug(Boot_Flag, ("Downloading system image %s, size 0x%lx", system_image, isize) );
 
        for (l = 0L; l < isize; l += C40MAXCHUNK) 
	 { cur = (int) (((isize - l) > C40MAXCHUNK) ? C40MAXCHUNK : isize - l);
d1007 1
a1007 1
	    { Debug(Boot_Flag, ("Failed to send %d bytes 0x%lx/0x%lx.", cur, l, isize));
d1012 2
d1015 2
a1017 6
      	      /* sent entire nucleus successfully */
        Debug(Boot_Flag, ("System image downloaded"));
        fclose( infd );
        infd = (FILE *) NULL;
        free(cur_data);
		/* Send go command to monitor running on Archimedies. */
d1019 51
d1073 2
a1074 5
/* Start address = nuc load address + nuc size + 6 module slots + 0 + modhdr */
#define KERNELSTARTADDRESS ((word)(ARMNUCBASE + (8 * 4) + 60))

	   ServerDebug("\n\rStarting Helios-ARM system. (g %lX)\n", KERNELSTARTADDRESS);
    	   sprintf(buf,"g %lX\n", KERNELSTARTADDRESS);
d1078 2
a1079 1
	    }
d1081 5
d1142 7
a1148 2
	  config.Flags |= swap(Config_Flags_CacheOff);
  config.Spare       = swap(0L);
d1190 1
a1190 1
  if (get_config("c40_disable_halfduplex") == NULL)
d1213 7
d1227 6
@


1.29
log
@Support for shared memory links (VC40 and SPIRIT40) added.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.28 1993/01/21 14:40:03 paul Exp nick $ */
a974 4
  elif (!mystrcmp(box_type, "VC40"))
   config.LinkConf[(int) bootlink] |= swap(0x00120370L);
  elif (!mystrcmp(box_type, "SPIRIT40"))
   config.LinkConf[(int) bootlink] |= swap(0x00120370L);
d977 24
d1003 1
a1003 1

@


1.28
log
@updated for ARM port + MSC v6.0 compatibility
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.27 1992/09/15 14:25:32 bart Exp paul $ */
d402 4
d413 9
d645 2
d728 40
d943 3
a945 1
     if (!mystrcmp(box_type, "DSP1"))
d975 4
@


1.27
log
@Fixed bug in construction of IDRom
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.25 1992/07/08 17:27:41 paul Exp $ */
d331 4
a334 3
  /* already loaded ? or in the case of the C40 wait for send_boot() to load */
  /* and send system image in small chunks - C40 too large to load in one go */
  if (target_processor eq Processor_C40 || TstList(Image_List))
d785 21
d836 15
a856 188

/*{{{  ARMBSD bodges */

#if ARMBSD
/* Temporary addition to support pseudo ROM images downloaded to the ABC
 * prototypes monitor.
 */

#define B_SIZE 32*1024
    if (get_config("abc_protobodge"))
    {
    	   int b_size = 1;
    	   int x =0;
           FILE *infd;
	   int i;
    	   char buf[B_SIZE];
    	   
	   output("Sending pseudo ROM image.");

	   while( xprdrdy() )
	     xprdbyte();

#if 1
	   /* DBG get around wierd first byte duplication after reset problem */
	   xpwrdata("\n",1);
	   while( xprdrdy() )
	     xprdbyte();

#endif

           if((infd = fopen(system_image,"rb")) eq NULL) {
           	ServerDebug("Cannot open system image");
           	longjmp(exit_jmpbuf, 1);
           }

           do {
		if (x>=19)
		 b_size = B_SIZE;
		else
		  x++;

           	i = fread(buf,1,b_size/*size*/,infd);
	        Debug(Boot_Flag, ("Sending %d pseudo ROM bytes.", i));

           	if (!xpwrdata(buf,i))
           		timeout("abc_protobodge: main write");
           	output(".");

		poll_the_devices();
		if (Special_Exit) longjmp(exit_jmpbuf, 1);

	        while( xprdrdy() )
	          xprdbyte();

           } while (i eq b_size);

           fclose(infd);
	   ServerDebug("\n\rStarting pseudo ROM system.");
    	   strcpy(buf,"\ng 2000000\n");

    	   for (i=0; i < strlen("\ng 2000000\n"); i++)
    	   {
    	      if (!xpwrdata(&buf[i],1))
    	      	timeout("abc_protobodge: sending end bit");
#if 0
		/* strange - only works on some prototypes! */
    	      if (!xprddata(&buf[i],1))
    	      	timeout("abc_protobodge: getting end bit");
#else
	      while( xprdrdy() )
	        xprdbyte();
#endif
	   }

	   while( xprdrdy() )
	     xprdbyte();
    }
    else if (get_config("abc_protobodge2"))
    {
	   struct stat st;
           FILE *infd;
    	   char buf[B_SIZE];
	   int i, size;
           int address = 0 ;		/* destination memory address */
	   int limit = (2 << 20) ;	/* largest image size allowed */

           Debug(Boot_Flag, ("Binary download to ABC monitor"));

	   if (get_config("abc_protobodge4"))
	    {
	     /* system with 2MB of RAM at 32MB */
	     limit = (512 << 10) ;	/* 512K image size limit imposed */
	     address = (34 << 20) ;	/* minus the image size */
	    }
	   else
	    {
	     if (get_config("abc_protobodge5"))
	      {
	       /* system with 4MB of RAM at 32MB */
	       address = (36 << 20) ;	/* minus the image size */
	      }
	     else
	      {
	       if (get_config("abc_protobodge6"))
	        {
		 /* system with 2MB of RAM at 48MB */
		 address = (50 << 20) ;	/* minus the image size */
	        }
	       else
	        {
           	 ServerDebug("abc_protobodge[4|5|6] not given in host.con") ;
           	 longjmp(exit_jmpbuf,1) ;
	        }
	      }
	    }
    	   
	   while( xprdrdy() )
	     xprdbyte();

	   if (stat(system_image, &st)) {
           	ServerDebug("abc_protobodge2: cannot find system image");
           	longjmp(exit_jmpbuf, 1);
           }

	   if ((size = st.st_size) eq 0) {
           	ServerDebug("abc_protobodge2: system image file is empty");
           	longjmp(exit_jmpbuf, 1);
           }

	   if (size > limit)
	    {
	     /* the specified image will not fit in the RAM available */
             ServerDebug("abc_protobodge2: system image too large for RAM available") ;
             longjmp(exit_jmpbuf,1) ;
 	    }
	   address -= size ;	/* actual address where data to be loaded */

           if((infd = fopen(system_image,"rb")) eq NULL) {
           	ServerDebug("abc_protobodge2: cannot open system image");
           	longjmp(exit_jmpbuf, 1);
           }

	   output("Downloading pseudo ROM binary image.");

	   /* t = transfer(startaddr,size) : binary download */
	   sprintf(buf,"\nt %X %X\n",address,size) ;

    	   for (i=0; i < strlen(buf); i++)
    	   {
    	      if (!xpwrdata(&buf[i],1))
    	      	timeout("abc_protobodge2: sending 't' download command to monitor");

	      while( xprdrdy() ) /* get rid of echoed chars */
	        xprdbyte();
	   }

           while (size > 0) {
           	if ((i = fread(buf,1,B_SIZE,infd)) eq 0) {
	           	ServerDebug("abc_protobodge2: failed to read and send %d characters from system image",size);
        	   	longjmp(exit_jmpbuf, 1);
	        }
		size -= i;

	        Debug(Boot_Flag, ("Sending %d pseudo ROM bytes (%d bytes left).", i, size));

           	if (!xpwrdata(buf,i))
           		timeout("abc_protobodge2: downloading binary image to monitor");
           	output(".");

		poll_the_devices();
		if (Special_Exit||Special_Reboot) longjmp(exit_jmpbuf, 1);
           }

           fclose(infd);

	   ServerDebug("\n\rStarting pseudo ROM system.");
    	   sprintf(buf,"g %X\n",address) ;
    	   for (i = 0; (i < strlen(buf)); i++)
    	    {
    	     if (!xpwrdata(&buf[i],1))
    	      timeout("abc_protobodge2: sending 'go' command to monitor") ;

	     while (xprdrdy()) /* get rid of echoed chars */
	      xprdbyte() ;
	    }
    }
#endif
/*}}}*/
d900 1
a900 1
  config.FirstProg   = swap(6L);
@


1.26
log
@Clean-up, plus support for the DSP1 board
@
text
@d676 1
a676 1
			ID_ROM.WAIT_G = (ID_ROM.WAIT_G & 0xf0) | (byte)i << 4;
d681 1
a681 1
			ID_ROM.WAIT_L = (ID_ROM.WAIT_L & 0xf0) | (byte)i << 4;
d686 1
a686 1
			ID_ROM.PWAIT_G = (ID_ROM.PWAIT_G & 0xf0) | (byte)i << 4;
d691 1
a691 1
			ID_ROM.PWAIT_L = (ID_ROM.PWAIT_L & 0xf0) | (byte)i << 4;
@


1.25
log
@fixed for new image magics
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.24 1992/07/08 16:20:15 paul Exp $ */
d27 1
d36 2
d41 1
d61 2
d65 2
a66 2
PRIVATE int fn( send_info_request, (void));
PRIVATE int fn( send_resync, (void));
d70 6
a75 1

d79 1
d83 1
d88 4
d109 6
a114 4
    elif (!mystrcmp(conf, "C40"))
     target_processor = Processor_C40;
    elif (!mystrcmp(conf, "TMS320C40"))
     target_processor = Processor_C40;
d123 2
d135 2
d174 6
d181 4
a184 1
   Default_BootLink = 3;
a194 3
  if (get_config("c40_disable_halfduplex") != NULL)
  	C40HalfDuplex = FALSE;

d197 2
d208 2
a209 1

d215 3
a217 2
  if (target_processor eq Processor_C40)
   return(1);	/* Cannot test */
d219 23
a241 16
  resetlnk();
  xpreset();
  unless(xpwrbyte(0L))           return(0);
  unless(xpwrint(0x80000100L))   return(0);
  unless(xpwrint(0x12345678L))   return(0);
  unless(xpwrbyte(1L))           return(0);
  unless(xpwrint(0x80000100L))   return(0);
  if (xprdint() ne 0x12345678L)  return(0);
  /* And again for good measure */
  unless(xpwrbyte(0L))           return(0);
  unless(xpwrint(0x80000104L))   return(0);
  unless(xpwrint(0x87654321L))   return(0);
  unless(xpwrbyte(1L))           return(0);
  unless(xpwrint(0x80000104L))   return(0);
  if (xprdint() ne 0x87654321L)  return(0);
  return(1);
d243 2
a244 1

d261 13
d284 3
d310 2
a311 1

d319 1
d398 6
a403 1
      name = "c40boot.i";
d462 2
a463 42

/**
*** Timeout() is called when any of the boot writes to the processor fails.
*** It longjmps back to boot_processor() above, which either recovers or
*** exits depending on what the user is doing.
**/

PRIVATE void timeout(when)
char *when;
{ ServerDebug("Timed out when sending %s.", when);
  longjmp(failure_buf, 1);
}

/**
*** Send_boot() is responsible for sending all the bootstrap code to the
*** processor. First I attempt to reset all the processor hardware, which is
*** a very troublesome piece of code. Then I send the size of the bootstrap
*** program, followed by the bootstrap program itself. This program starts to
*** run on the processor and on Meiko hardware the first thing it does is
*** clear all of the parity memory - Yukk. Then the program does an IN
*** instruction to receive the system image, and I send that. When the system
*** image has been loaded the kernel starts to run and expects some
*** configuration to come down its link, so I send that.
***
*** Next there is some low-level message interaction between the processor and
*** the host, involving a byte-F0 message, which only NHG understands. In
*** server mode this involves calling server_helios(), and in debugging mode
*** it involves calling debug_helios() in module debug.c .
**/

PRIVATE word send_bit(data)
GenData *data;
{ poll_the_devices();
  if (Special_Exit) longjmp(exit_jmpbuf, 1);
  Debug(Boot_Flag, ("Sending %d bytes at %p.", data->size, &(data->data[0])));

  if (!xpwrdata(&(data->data[0]), (word) data->size))
   return(1L);
  else
   return(0L);
}

d497 1
a498 2
      	word C40_HW_Config = 0;
      	
d540 8
a547 6
	/* Send a hardware configuration word to the bootstrap. */
	/* This allows it to configure itself for different C40 */
	/* hardware environments and nucleus load positions. */
	
	if (get_config("c40_disable_cache") != NULL)
		C40_HW_Config |= HW_CacheOff;
d549 20
a568 13
	if (get_config("c40_load_nucleus_local_S0") != NULL)
		C40_HW_Config |= HW_NucleusLocalS0;
	if (get_config("c40_load_nucleus_local_S1") != NULL)
		C40_HW_Config |= HW_NucleusLocalS1;
	if (get_config("c40_load_nucleus_global_S0") != NULL)
		C40_HW_Config |= HW_NucleusGlobalS0;
	if (get_config("c40_load_nucleus_global_S1") != NULL)
		C40_HW_Config |= HW_NucleusGlobalS1;

	if ((get_config("c40_replace_idrom") != NULL) ||
	    (get_config("c40_use_pseudo_idrom") != NULL)) {
		word i;

d570 1
a570 1
		static IDROM ID_ROM = {
d610 1
a610 1
/* none */		0		/* total size of auto-initialisation data */
d613 22
d722 10
a731 6
      }
     else	/* not C40, probably a transputer */
      { if (!xpwrbyte(bootsize))              /* bootstrap size */
         timeout("bootstrap size");
        if (!xpwrdata(bootstrap,bootsize))    /* bootstrap */
         timeout("bootstrap code");
d733 1
a733 12
        temp = get_config("BOX");          /* This entry is known to exist */
        if (!mystrcmp(temp, "MK026"))      /* or anything else with parity memory */
         { word size = processor_memory;
           if (size eq Invalid_config) size = 0x300000L;
           xpwrbyte(5L);
           xpwrint(size);
           while (!xprdrdy());           /* wait for the clear to finish */
           (void) xprdbyte();
         }
        xpwrbyte(4L);
      }	/* end of transputer version */
   }	/* end of Send_Bootstrap test */
d735 11
a745 3
  if (bootstrap_mode & B_Send_Image)
   { if (target_processor eq Processor_C40)
      {      /* image is too big to load in one go, so load bit, send bit, load ... */
a819 1
   }
d821 2
d1007 1
a1007 2
  if (bootstrap_mode & B_Send_Config)
	  send_conf();
d1009 2
a1010 1

d1021 1
d1024 1
a1024 1
  char *tempname = get_config("root_processor");
d1031 1
d1037 5
a1058 3
  if (target_processor eq Processor_C40)
   numlinks = 6;

d1067 7
a1073 1
  config.LinkConf[(int) bootlink] |= swap(0x00030270L);
d1090 1
d1100 4
a1103 4
  if (!xpwrdata((byte *) &config,
	(target_processor eq Processor_C40) ?	/* word multiple */
	(size + 3) & ~3L :
	size))
d1106 2
a1107 1

d1126 2
d1140 2
d1155 2
a1156 1
	/* The C40 never sends the IOServer Proto_Info's */
d1254 2
d1416 1
@


1.24
log
@added booted acknowledge protocol for C40
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.21 1992/06/19 10:35:15 bart Exp $ */
d361 15
a375 3
  if( swap(ihdr[0]) ne 0x12345678L )
   { ServerDebug("First word of file not magic number.");
     goto fail;
@


1.23
log
@ID_ROM (line 522) declared as static
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.22 1992/06/30 10:32:00 paul Exp craig $ */
d499 5
a503 1
 	/* 'C40 is now executing bootstrap */
@


1.22
log
@added configurable HalfDuplex protocol
added IDROM override facility
added C40 cache disable config
changed debug msgs to note they are hex
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.21 1992/06/19 10:35:15 bart Exp $ */
d522 1
a522 1
		IDROM ID_ROM = {
@


1.21
log
@Major upgrade to V3.91 :
 1) includes C40 support
 2) now compiles for Helios and for Windows
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.2 1992/06/05 10:34:06 bart Exp $ */
d44 2
a45 1
#define C40MAXCHUNK 0xD000L	/* ~50k */
d163 3
d461 4
a464 1
      {	/*
d498 155
a652 2
 	/* 'C40 will now start executing bootstrap */
       }
d713 1
a713 1
        Debug(Boot_Flag, ("Downloading system image %s, size %lx", system_image, isize) );
d719 1
a719 1
	    { ServerDebug("Failed to read (%x) bytes in system image (read %lx out of %lx).", cur, l, isize);
d731 1
a731 1
	    { Debug(Boot_Flag, ("Failed to send %d bytes %lx/%lx.", cur, l, isize));
d955 1
d974 4
a977 1
  config.Flags       = swap(Config_flags_rootnode);
d989 1
d992 3
d1102 1
a1102 1
                      ServerDebug("Unexpected byte %lx.",b);
d1296 1
a1296 1
      ServerDebug("Reply (from %lx) : fn %lx, port %lx, csize %ld, dsize %ld",
d1301 1
a1301 1
          ServerDebug("Error : fn %lx", code);
@


1.20
log
@oops can't spell
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.19 1992/03/06 12:05:11 martyn Exp $ */
a35 1
PRIVATE int target_processor;
d37 1
a37 1
PRIVATE WORD processor_memory;
d42 1
d44 1
a47 4
#if (UNIX || PC)
void tidy_link();
#endif

d50 1
a50 1
WORD  isize;
d91 4
d98 1
a98 1
    "Supported processors are : T414, T800, T425, T400, ARM, i860, and 68000.");
d146 1
a146 1
   if (get_config("reset_target") != NULL)
d150 3
a171 6

#if (UNIX || PC)
  if (debugflags & Quit_Flag)
   printf("Restoring link interface.\r\n");
  tidy_link();
#endif
d179 3
a189 1

a196 1
  
d264 1
a264 1
{ WORD l;
d268 4
a271 1
  if (TstList(Image_List)) return(1);               /* already loaded ? */
d290 1
a290 1
  if (fread((BYTE *) &isize,1,4,infd) ne 4)
d298 1
a298 1
   { ServerDebug("Failed to read image.");
d330 1
a330 1
  WORD ihdr[3];
d334 5
a338 1
    name = "nboot.i";
d352 1
a352 1
  if( (s=fread((BYTE *) &(ihdr[0]),1,12,infd)) ne 12)
d412 1
a412 1
PRIVATE WORD send_bit(data)
d418 1
a418 1
  if (!xpwrdata(&(data->data[0]), (WORD) data->size))
d433 3
a435 3
     xpwrbyte((WORD) Proto_RemoteReset);
     xpwrbyte((WORD) Proto_Boot);
     xpwrint( (WORD) bootstrap_mode);
d443 1
a443 1
    * (The just_attach directive defaults to (no_reset_target").
d448 1
a448 1
   poll(0,0,1000);
d450 1
a450 1
   xpreset();
d454 1
a454 1
  { Debug(Boot_Flag, ("Sending bootstrap, size is %ld", bootsize) );
d456 8
a463 4
    if (!xpwrbyte(bootsize))              /* bootstrap size */
     timeout("bootstrap size");
    if (!xpwrdata(bootstrap,bootsize))    /* bootstrap */
     timeout("bootstrap code");
d465 1
a465 9
    temp = get_config("BOX");          /* This entry is known to exist */
    if (!mystrcmp(temp, "MK026"))      /* or anything else with parity memory */
      { WORD size = processor_memory;
        if (size eq Invalid_config) size = 0x300000L;
        xpwrbyte(5L);
        xpwrint(size);
        while (!xprdrdy());           /* wait for the clear to finish */
        (void) xprdbyte();
      }
d467 5
a471 2
    xpwrbyte(4L);
  }
d473 39
d513 5
a517 1
  { Debug(Boot_Flag, ("Sending System Image (%ld bytes) ...",isize) );
d519 4
a522 3
    if (Wander(Image_List, send_bit))
     timeout("system image");
  }
d524 67
d618 1
a618 1
           if((infd = fopen(system_image,"rb")) == NULL) {
d642 1
a642 1
           } while (i == b_size);
d712 1
a712 1
	   if ((size = st.st_size) == 0) {
d725 1
a725 1
           if((infd = fopen(system_image,"rb")) == NULL) {
d745 1
a745 1
           	if ((i = fread(buf,1,B_SIZE,infd)) == 0) {
d789 1
a789 1
PRIVATE WORD build_config()
d792 4
a795 2
  WORD memory_size = processor_memory;
  WORD bootlink    = get_int_config("bootlink");
d801 1
a801 1
  if (bootlink eq Invalid_config) bootlink = 0L;
d805 1
a805 1
  config.loadbase    = swap(0x80001000L);
d807 1
a807 1
   config.ImageSize   = swap(isize);
d815 11
a825 6
  config.NLinks      = swap(4L);
  config.LinkConf[0] = swap(0x00060000L);  /* by default the links are dead */
  config.LinkConf[1] = swap(0x01060000L);  /* The bootlink is            */
  config.LinkConf[2] = swap(0x02060000L);  /* intelligent and running, and */
  config.LinkConf[3] = swap(0x03060000L);  /* has the right flags set */
  config.LinkConf[(int) bootlink] &= swap(0x0300FF00L); 
d828 11
a838 7
  config.MyName      = swap(((WORD) &(config.names[0])) -
                            ((WORD) &(config.MyName  )) );
  config.ParentName  = swap(((WORD) &(config.names[strlen(procname)+1])) -
                            ((WORD) &(config.ParentName)) );
  strcpy(config.names, procname);
  strcpy(&(config.names[strlen(procname) + 1]), myname);
  return((WORD) (sizeof(Config) + strlen(procname) + strlen(myname) - 48));
d842 1
a842 1
{ WORD size = build_config();
d849 4
a852 1
  if (!xpwrdata((BYTE *) &config, size))
d875 1
a875 1
    if (get_config("abc_protobodge3") != NULL) {
d897 7
d916 1
a916 1
        Special_Status = FALSE;
d921 1
a921 1
      { WORD b=0L;
d923 4
a926 1
        b = xprdbyte();
d946 2
a947 2
{ WORD a, iocport;
  WORD *x = (WORD *) &(misc_buffer1[0]);
d949 2
a950 1
  Debug(Boot_Flag, ("Received a byte F0.") );
d952 7
a958 1
  xprddata(&(misc_buffer1[1]), 11L);
d963 2
a964 1
   { x[0] = swap(0xf0f0f0f0L);
d973 1
a973 2
  WORD a, iocport;
  WORD *x = (WORD *) &(misc_buffer1[0]);
d984 1
a984 1
  WORD *x = (WORD *) &(misc_buffer1[0]);
d1018 1
a1018 1
*** message is received the routine returns TRUE, and main_loop calls
d1032 2
a1033 2
*** GetMsg() can return three values. It can return TRUE if the machine has
*** received a complete Helios message, FALSE if it has not received anything
d1041 1
a1041 1
PRIVATE BYTE *real_buff = (BYTE *) NULL;
d1045 1
a1045 1
  BYTE *temp;
d1051 1
a1051 1
  temp = (BYTE *) malloc(amount);
d1057 1
a1057 1
  mcbstruct.Data     = (BYTE *) (( ((WORD)temp) + 511L) & 0xFFFFFE00L);
d1063 1
a1063 1
{ if (real_buff ne (BYTE *) NULL) free(real_buff);
d1066 1
a1066 1
int newdebug = TRUE;
d1086 1
a1086 1
                 newdebug = FALSE;
d1094 1
a1094 1
                 newdebug = TRUE;
d1102 1
a1102 1
           return(FALSE);
d1106 1
a1106 1
          return(TRUE);
d1110 1
a1110 1
   return(FALSE);
d1119 1
a1119 1
  mcb->MsgHdr.ContSize  = (BYTE) contlen;
@


1.19
log
@added TR5000 stuff
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.18 1991/07/31 16:23:04 martyn Exp martyn $ */
d443 1
a443 1
#ensif
@


1.18
log
@change tidy_link prototype to compile on SUN4
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.17 1991/07/30 10:39:03 martyn Exp $ */
d440 4
d445 1
@


1.17
log
@removed redundant ServerDebug
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.16 1991/07/29 14:05:48 al Exp martyn $ */
d48 1
a48 1
void tidy_link(void);
@


1.16
log
@Fixed lost cluster problem (on DOS) and added proper shutdown of
DOS device driver.  Also fixed some minor oversights.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.13 1991/04/02 17:32:11 martyn Exp $ */
d975 3
a977 3
    if (debugflags & Message_Flag) {
        ServerDebug("Reply from %lx : fn %lx, port %lx, csize %ld, dsize %ld",
                      mcb->MsgHdr.Reply, code, mcb->MsgHdr.Dest, contlen, datalen);
a978 13
        ServerDebug("Reply contents %x %x %x %x %x %x %x %x %x %x %x",
                    mcb->Data[0],
                    mcb->Data[1],
                    mcb->Data[2],
                    mcb->Data[3],
                    mcb->Data[4],
                    mcb->Data[5],
                    mcb->Data[6],
                    mcb->Data[7],
                    mcb->Data[8],
                    mcb->Data[9],
                    mcb->Data[10]);
	}
@


1.15
log
@Extra features added, including DOS device driver support and TMB16
board support.  Also added extra info on -m debug.
box=DOSDEVICE
dosdevname=LINK1
tmb16=word or byte
@
text
@d47 4
d169 1
a169 1
#if UNIX
@


1.14
log
@Nick G's changes to reset flags
@
text
@d185 9
d971 3
a973 3
    if (debugflags & Message_Flag)
        ServerDebug("Reply  : fn %lx, port %lx, csize %ld, dsize %ld",
                      code, mcb->MsgHdr.Dest, contlen, datalen);
d975 13
@


1.13
log
@removed some debugging messages
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.12 1991/03/20 18:53:38 paul Exp martyn $ */
d934 3
@


1.12
log
@added new binary download for ABC monitor - copes with different memory
sizes
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.9 91/02/26 22:16:16 paul Exp Locker: paul $ */
d726 1
a726 1
#ifdef ARMBSD
@


1.11
log
@removed spurious CR's from IOdebugs
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.10 91/03/06 22:01:03 paul Exp Locker: paul $ */
d463 1
a463 1
  if (get_config("abc_protobodge"))
d537 32
d583 8
a595 1

d598 2
a599 1
	   sprintf(buf,"\nt 2000000 %x\n",size); /* t = transfer(startaddr,size) */
a624 4
#if 0
	        while( xprdrdy() ) /* get rid of any echoed chars */
	          xprdbyte();
#endif
a628 10
#if 1
/* The monitor enables echoing if it receives a NewLine, or a help command
 * or an error is generated. This means that we shouldn't send leading
 * newlines after a binary download command (since the IOserver will then
 * receive the prompt characters).
 */
# define GOCMDSTR "g 2000000\n"	/* goto the address where code was loaded */
#else
# define GOCMDSTR "\ng 2000000\n"
#endif
d630 5
a634 1
    	   strcpy(buf,GOCMDSTR);
d636 3
a638 8
    	   for (i=0; i < sizeof(GOCMDSTR); i++)
    	   {
    	      if (!xpwrdata(&buf[i],1))
    	      	timeout("abc_protobodge2: sending 'go' command to monitor");

	      while( xprdrdy() ) /* get rid of echoed chars */
	        xprdbyte();
	   }
a640 1

d928 1
a928 2
               {
		 ServerDebug("");		/* add in spurious CR's! */
@


1.10
log
@fixed abc_protobodge2 (binary download)
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.9 91/02/26 22:16:16 paul Exp Locker: paul $ */
d899 4
d904 2
a905 1
               { ServerDebug("");
@


1.9
log
@added resync fix for ARMBSD
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.8 91/02/20 14:37:19 paul Exp Locker: paul $ */
a537 2
	   output("Downloading pseudo ROM binary image.");

d556 2
a557 1
	   output("\n\rStarting pseudo ROM system.");
d593 10
a602 2
#define GOCMDSTR "\ng 2000000\n"

d797 5
a801 1
  /* at least same size as a SendInfo message */
@


1.8
log
@added support for reset whilst attaching and binary download abc_protobodge2
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.7 91/02/05 20:46:08 paul Exp Locker: paul $ */
d58 1
d695 12
d782 12
@


1.7
log
@fixed core dump if no abc_protobodge image file
,.
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.6 90/12/08 04:09:24 paul Exp $ */
d113 1
d128 1
a128 1
   /* The above is equivalent to 	    */
d132 7
a138 2
   /* confusion here between ROM based systems you want to reset */
   /* and IO Server as a fileserver type applications where you dont */
d140 2
a141 5
#if ARMBSD
   if (get_config("no_reset_target") eq NULL)
      bootstrap_mode |= B_Reset_Processor;
#endif

d416 9
a424 1
   }   
d475 8
d530 77
a606 4
# if 0
	/*delay(4*OneSec);*/
	{int i; for(i=1;i<1000000*4;i++);}
# endif	
@


1.6
log
@put in a bit of debugging and then took it out again!
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.5 90/10/19 16:47:36 alan Exp $ */
d464 4
a467 1
           infd = fopen(system_image,"rb");
@


1.5
log
@EnableTheLink (again!!)
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.4 90/10/19 12:16:39 alan Exp Locker: alan $ */
d508 4
@


1.4
log
@add EnableThatLink 
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.3 90/10/18 11:10:25 alan Exp Locker: alan $ */
d36 2
a37 3
PRIVATE int target_processor = Processor_Trannie;
PRIVATE int bootstrap_mode = B_Reset_Processor | B_Send_Bootstrap |
       B_Send_Image | B_Send_Config | B_Wait_Sync | B_Check_Processor;
d65 3
a128 1
   EnableThatLink = 0;			/* only works first time */
d671 1
a671 1
  return (xpwrdata(&(misc_buffer1[0]), 12L));
@


1.3
log
@fixed problem with remote reboot over hydra
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.2 90/10/17 14:23:01 alan Exp Locker: alan $ */
d112 2
a113 1
      (get_config("enable_link") ne (char *) NULL) )
d126 2
a127 1

@


1.2
log
@stop server waiting for sync byte forever
@
text
@d20 1
a20 1
/* RcsId: $Id: tload.c,v 1.1 90/10/16 16:03:18 alan Exp Locker: alan $ */
d407 1
a407 1
     xpwrbyte((WORD) Proto_Reset);
d587 1
a587 1
  LONG i;
d636 1
a636 1
   printf("Failed to receive sychronisation byte.\n Server Aborting\n");
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
/* RcsId: $Id$ */
d587 2
d605 1
a605 1
  for(;;)
d635 4
@
