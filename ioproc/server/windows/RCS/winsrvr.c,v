head	1.4;
access;
symbols;
locks; strict;
comment	@ * @;


1.4
date	93.10.13.17.29.25;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	93.09.29.11.33.34;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	93.08.12.14.05.18;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	92.06.19.09.59.30;	author bart;	state Exp;
branches;
next	;


desc
@Windows-specific component of the I/O Server
@


1.4
log
@minor clean-ups, including eliminating the old comment by CSIR
Also, sorted out the debugging options handling
@
text
@/***************************************************************************/
/***************************************************************************/
/**             Helios I/O Server under Microsoft Windows                 **/
/**                                                                       **/
/**             Copyright (C) 1993, Perihelion Software Ltd.		  **/
/**                           All Rights Reserved.                        **/
/**                                                                       **/
/**   winsrvr.c                                                           **/
/**                                                                       **/
/**     This file contains the main driver engine of the I/O Server.      **/
/**     The file initiates the startup procedure of the I/O Server, and   **/
/**     contains the most outer loop of the server. The file also         **/
/**     contains the I/O Server interface with Microsoft Windows.         **/
/**                                                                       **/
/**   Author : S.A. Wilson  05/90   (Code incorporates original code by   **/
/**                                 (BLV. of Perihelion Software Ltd.  )  **/
/**                                                                       **/
/**   Site   : CSIR - MIKOMTEK                                            **/
/**									  **/
/**   Rewritten: BLV, Mike Gunning, eliminating most of the hacks put in. **/
/**                                                                       **/
/***************************************************************************/
/***************************************************************************/

#define Windows_Module

#include "helios.h"
#include "sccs.h"
#include "windows\menus.h"

static char *argv[20];  /* for command line arguments */
int          argc;      /* for no. of cmd line args */
PRIVATE HANDLE  global_hInstance;
        int     global_nCmdShow;

long FAR PASCAL WndProc(HWND, unsigned, WORD, LONG);
long FAR PASCAL PopupProc(HWND, unsigned, WORD, LONG);
BOOL FAR PASCAL AboutDlgProc(HWND, unsigned, WORD, LONG);
BOOL FAR PASCAL DbgBoxProc(HWND, unsigned, WORD, LONG);

#include "windows\graph.h"      /* deferred message calls */

extern DirHeader Graph_List;
extern long FAR PASCAL GraphProc(HWND, unsigned, WORD, LONG);

void getcmdline (LPSTR lpszCmdLine, int *argc, char **argv);
extern int server_main(int argc, char **argv);

extern void  add_to_key_buffer(HWND, LPSTR);
PRIVATE void Update_Debug_Options(HWND);
PRIVATE void Check_Current_Boxes(HWND);
extern  void show_logger_name(HWND);
extern  void set_logger_name(HWND);

#define WM_TIDYDIALOG   (WM_USER+1)
PRIVATE char *configname = "host.con";
PRIVATE bool hid_program_manager = FALSE;
PRIVATE HWND hDbgDialog = NULL;
PRIVATE HWND hAboutDialog = NULL;
PRIVATE FARPROC lpfnDlgBox = NULL;
PRIVATE FARPROC lpfnAboutBox = NULL;


/**************************************************************************/
/*                                                                        */
/* The function WinMain provides the I/O server with the standard Windows */
/* application entry point.                                               */
/*                                                                        */
/* The function is the main driver routine for the I/O server, providing  */
/* the interface between the two message passing systems of Helios and    */
/* Microsoft Windows, via the MainLoop and PeekMessage calls.             */
/*                                                                        */
/* The function registers two window classes, the first being the main    */
/* server window, and the other class being the console window and other  */
/* shell windows. Once the two classes have been registered, the main     */
/* server window is opened.                                               */
/*                                                                        */
/* If the graphics server is incorporated, a seperate graphics window     */
/* class is registered. The same applies if the graphics printer server   */
/* is incorporated.                                                       */
/*                                                                        */
/* The function checks the version of Microsoft Windows, and determines   */
/* whether the server will be able to function under that particular      */
/* version. The server's environment is then set up, via a call to        */
/* server_main.                                                           */
/*                                                                        */
/* Once the server has been set up, the function enters the main outer    */
/* loop of the server, where it remains until the server is terminated.   */
/* Upon entry to the main loop, the server is initialised. (This must     */
/* only happen the first time the loop is entered or when the server is   */
/* rebooted) Once initialised, the server runs until completion,          */
/* servicing mesages from the transputer and from the Microsoft Windows.  */
/*                                                                        */
/**************************************************************************/


int PASCAL WinMain(hInstance, hPrevInstance, lpszCmdLine, nCmdShow)
   HANDLE     hInstance, hPrevInstance;
   LPSTR      lpszCmdLine;
   int        nCmdShow;
{
  int ret;

  global_hInstance      = hInstance;
  PROGINSTANCE          = hInstance;
  global_nCmdShow       = nCmdShow;
  Server_window.handle  = 0L;
  real_windows          = 1;

        /* Only one I/O Server please   */
  if (hPrevInstance)
   return(1);

  InitTable();   /* initialise the HashTable for the open windows */

  getcmdline(lpszCmdLine, &argc, argv);
  ret = server_main(argc, argv);

  if (hid_program_manager)
  {
      HWND hWnd = FindWindow(NULL, "Program Manager");
      if (hWnd ne NULL)
          ShowWindow(hWnd, SW_RESTORE);
  }

  if (IsWindow(hDbgDialog))
      DestroyWindow(hDbgDialog);
  if (IsWindow(hAboutDialog))
      DestroyWindow(hAboutDialog);
  if (lpfnDlgBox != NULL)
      FreeProcInstance(lpfnDlgBox);
  if (lpfnAboutBox != NULL)
      FreeProcInstance(lpfnAboutBox);

  return ret;
}

void initialise_Windows(void)
{ char  szCaption [] = "Helios I/O Server";     /* caption for main server */
  WNDCLASS     wndclass;
  HWND         hWnd;
  HDC          deskDC;
  int          colors,
               count = 0,     /* counter */
               CARRYON = 1,   /* flag used in the main loop */
               xdim, ydim;    /* dimensions of the graphics screen */
  char *hide_program_manager = get_config("hide_program_manager");

/* We attempt to access the Windows Desktop in order to determine the number */
/* of colors Windows is able to display. We then can use either the color    */
/* icons, or the monochrome icons. */

  hWnd = GetDesktopWindow();
  if (hWnd eq 0) colors = 2;   /* if we cant access desktop, use mono */
    else {
        deskDC = GetDC(hWnd);
        if (deskDC eq 0) colors = 2;
            else {
                colors = GetDeviceCaps(deskDC, NUMCOLORS);
                ReleaseDC(hWnd, deskDC);
            }
    }


  /* Register the main server window class */

    wndclass.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_NOCLOSE | CS_BYTEALIGNCLIENT;
    wndclass.lpfnWndProc   = WndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = global_hInstance;
    if (colors > 7)
       wndclass.hIcon         = LoadIcon(global_hInstance, "mainicon");
    else
       wndclass.hIcon         = LoadIcon(global_hInstance, "monomain");
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = COLOR_WINDOW + 1;
    wndclass.lpszMenuName  = "MainMenu";
    wndclass.lpszClassName = szAppName;

    if (!RegisterClass (&wndclass)) longjmp(exit_jmpbuf, 1);

/* Register the console and shell window class */

    wndclass.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_NOCLOSE | CS_BYTEALIGNCLIENT;
    wndclass.lpfnWndProc   = PopupProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = global_hInstance;
    if (colors > 7)
       wndclass.hIcon         = LoadIcon(global_hInstance, "shellicon");
    else
       wndclass.hIcon         = LoadIcon(global_hInstance, "monoshell");
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = COLOR_WINDOW + 1;
    wndclass.lpszMenuName  = "ShellMenu";
    wndclass.lpszClassName = szPopupClass;

    if (!RegisterClass (&wndclass)) longjmp(exit_jmpbuf, 1);

    graphics_registered = 1;

  if (hide_program_manager ne NULL)
  {
      HWND hWnd = FindWindow(NULL, "Program Manager");
      if (hWnd ne NULL)
      {
          ShowWindow(hWnd, SW_SHOWMINNOACTIVE);
          hid_program_manager = TRUE;
      }
  }

  xdim = GetSystemMetrics(SM_CXSCREEN);   /* dimensions of graphics screen */
  ydim = GetSystemMetrics(SM_CYSCREEN);

}

void restart_windows(void)
{ MSG           msg;
/* We need to clear the message buffer of Windows. What remains in the  */
/* message buffer is the key up messages from the reboot sequence and a */
/* paint message.                                                       */

  while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
}

void restore_windows(void)
{ MSG           msg;
/* We need to clear the message buffer of Windows. What remains in the  */
/* message buffer is the key up messages from the reboot sequence and a */
/* paint message.                                                       */

  while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
    TranslateMessage(&msg);
    DispatchMessage(&msg);
  }
}

void poll_windows(void)
{ MSG           msg;

   /* Now service Microsoft Windows messages */
  bExitMessageLoop = FALSE;
  while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE)) {
      GetMessage(&msg, NULL, 0, 0);
      if (IsWindow(hDbgDialog) || !IsDialogMessage(hDbgDialog, &msg))
      {
          TranslateMessage(&msg);

          DispatchMessage(&msg);
      }

      if (bExitMessageLoop)
         break;
  }

}


/***************************************************************************/
/*                                                                         */
/*  getcmdline                                                             */
/*                                                                         */
/*  Parameters :-                                                          */
/*       lpszCmdLine - The command line Windows gives to an application.   */
/*       argc        - Used to return the number of arguments in the       */
/*                     command line.                                       */
/*       argv        - Used to hold all the different arguments on the     */
/*                     command line.                                       */
/*                                                                         */
/*  Function :-                                                            */
/*       The function extracts the various command line arguments from the */
/*       command line string passed to the I/O server by Microsoft Windows */
/*                                                                         */
/*  Returns :-                                                             */
/*       The command line arguments in argv.                               */
/*       The number of command line arguments in argc.                     */
/***************************************************************************/

void getcmdline(lpszCmdLine, argc, argv)
  LPSTR          lpszCmdLine;
  int            *argc;
  char           **argv;
{
  int  count = 0;
  char temp[80];

  argv[0] = "winsrvr";
  *argc = 1;
  lpszCmdLine--;
  do  {
    lpszCmdLine++;
    if (*lpszCmdLine == '"') {    /* a string name as part of the command line */
      count = 0;
      do {
        temp[count] = *lpszCmdLine;  /* store the name in temp */
        lpszCmdLine++;
        count++;
      }
      while (*lpszCmdLine != '"');
    }
       /* Have we reached the end of an argument on the cmd line? */
    if ((*lpszCmdLine == ' ') || ((*lpszCmdLine == NULL) && (count > 0))) {
      temp[count] = '\0';
      argv[*argc] = malloc(count + 1);
      strcpy(argv[*argc], temp);
      (*argc)++;
      count = 0;
    }
    else {
      temp[count] = *lpszCmdLine;   /* store part of argument in temp */
      count++;
    }
   }
  while (*lpszCmdLine != NULL);
}

/***************************************************************************/
/*                                                                         */
/*  Function : Check_Current_Boxes                                         */
/*                                                                         */
/*  The function will place a check in the check boxes of the dialog box   */
/*  used for selecting debug options. The function checks to see what the  */
/*  current debug settings are, and places the check mark in the relevant  */
/*  box.                                                                   */
/*                                                                         */
/***************************************************************************/

PRIVATE void Check_Current_Boxes(hDlg)
   HWND hDlg;
{
   int ct;

   show_logger_name(hDlg);  /* displays the current logfile name */

   if (log_dest eq Log_to_both) {
      CheckDlgButton(hDlg, IDD_SCREEN, 1);  /* set current logfile options */
      CheckDlgButton(hDlg, IDD_TOFILE, 1);
   }
   else {
     if (log_dest eq Log_to_file)
       CheckDlgButton(hDlg, IDD_TOFILE, 1);
     else
       CheckDlgButton(hDlg, IDD_SCREEN, 1);
   }

	/* go through check boxes and set those flags selected */
#define check_btn(a,b) if (debugflags & a) CheckDlgButton(hDlg, b, 1)
    check_btn(Boot_Flag,	IDD_BOOT);
    check_btn(Com_Flag,		IDD_COMS);
    check_btn(Delete_Flag,	IDD_DEL);
    check_btn(Error_Flag,	IDD_ERR);
    check_btn(FileIO_Flag,	IDD_FILE);
    check_btn(Graphics_Flag,	IDD_GRAPHICS);
    check_btn(HardDisk_Flag,	IDD_RAWD);
    check_btn(Init_Flag,	IDD_INIT);
    check_btn(Directory_Flag,	IDD_DIR);
    check_btn(Keyboard_Flag,	IDD_KEYB);
    check_btn(Message_Flag,	IDD_MESS);
    check_btn(Name_Flag,	IDD_NAME);
    check_btn(Open_Flag,	IDD_OPEN);
    check_btn(Close_Flag,	IDD_CLOSE);
    check_btn(Quit_Flag,	IDD_EXIT);
    check_btn(Read_Flag,	IDD_READ);
    check_btn(Search_Flag,	IDD_SRCH);
    check_btn(Timeout_Flag,	IDD_TIME);
    check_btn(OpenReply_Flag,	IDD_OPRPLY);
    check_btn(Write_Flag,	IDD_WRITE);
    check_btn(DDE_Flag,		IDD_DDE);
#undef check_btn
}


/**************************************************************************/
/*                                                                        */
/*   Function : Update_Debug_Options                                      */
/*                                                                        */
/*   The function captures the user input on the dialog box used for      */
/*   changing debug settings in the server, and updates the dialog box    */
/*   display to reflect the users input.                                  */
/*                                                                        */
/**************************************************************************/

PRIVATE void Update_Debug_Options(hDlg)
   HWND hDlg;
{
   int ct, old_log = log_dest;

   set_logger_name(hDlg);   /* changes the logfile name if necessary */

   if ((IsDlgButtonChecked(hDlg, IDD_TOFILE)) &&
       (IsDlgButtonChecked(hDlg, IDD_SCREEN)))
     log_dest = Log_to_both;               /* has the log destination */
   else {                                  /* changed?                */
     if (IsDlgButtonChecked(hDlg, IDD_TOFILE)) log_dest = Log_to_file;
        else
     log_dest = Log_to_screen;
   }

/* Check all the check boxes and if they have been checked, set the */
/* corresponding debug flag */
#define check_btn(a,b) \
   if (IsDlgButtonChecked(hDlg, b)) \
    debugflags |= a; \
   else \
    debugflags &= ~a;

    check_btn(Boot_Flag,	IDD_BOOT);
    check_btn(Com_Flag,		IDD_COMS);
    check_btn(Delete_Flag,	IDD_DEL);
    check_btn(Error_Flag,	IDD_ERR);
    check_btn(FileIO_Flag,	IDD_FILE);
    check_btn(Graphics_Flag,	IDD_GRAPHICS);
    check_btn(HardDisk_Flag,	IDD_RAWD);
    check_btn(Init_Flag,	IDD_INIT);
    check_btn(Directory_Flag,	IDD_DIR);
    check_btn(Keyboard_Flag,	IDD_KEYB);
    check_btn(Message_Flag,	IDD_MESS);
    check_btn(Name_Flag,	IDD_NAME);
    check_btn(Open_Flag,	IDD_OPEN);
    check_btn(Close_Flag,	IDD_CLOSE);
    check_btn(Quit_Flag,	IDD_EXIT);
    check_btn(Read_Flag,	IDD_READ);
    check_btn(Search_Flag,	IDD_SRCH);
    check_btn(Timeout_Flag,	IDD_TIME);
    check_btn(OpenReply_Flag,	IDD_OPRPLY);
    check_btn(Write_Flag,	IDD_WRITE);
    check_btn(DDE_Flag,		IDD_DDE);

    check_btn(Memory_Flag,	IDD_MEMORY);
    check_btn(Reconfigure_Flag,	IDD_RECON);
#undef check_btn
}


/* WndProc is the standard Windows Procedure, associated with the main   */
/* server window, called by Microsoft Windows, when passing messages     */
/* pertaining to the main server window.                                 */

long FAR PASCAL WndProc( hWnd, iMessage, wParam, lParam)
  HWND         hWnd;
  unsigned     iMessage;
  WORD         wParam;
  LONG         lParam;
{
  PAINTSTRUCT ps;    /* used during paint messages */
  int         caption_height,   /* Height of the caption in pixels */
              screen_height,    /* Height of the screen in pixels */
              screen_width;     /* width of the screen in pixels */
  HDC         hDC;
  TEXTMETRIC  tm;
  HFONT       hFont;
  FARPROC     lpfnAboutProc;
  short       i;

  switch (iMessage) {
     case WM_TIDYDIALOG:
        if (lpfnDlgBox != NULL)
            FreeProcInstance(lpfnDlgBox);
        if (lpfnAboutBox != NULL)
            FreeProcInstance(lpfnAboutBox);
        break;

     case WM_CREATE:
        caption_height = GetSystemMetrics(SM_CYCAPTION);
        screen_height  = GetSystemMetrics(SM_CYSCREEN);
        screen_width   = GetSystemMetrics(SM_CXSCREEN);
        hFont          = GetStockObject(SYSTEM_FIXED_FONT);
        hDC = GetDC(hWnd);
        SelectObject(hDC, hFont);
        GetTextMetrics(hDC, &tm);
        ReleaseDC(hWnd, hDC);
   /* determine the max. no. of lines of text in a full screen window */
        CHAR_WIDTH  = tm.tmAveCharWidth;
        CHAR_HEIGHT = tm.tmHeight + tm.tmExternalLeading;
        MAXLINES = screen_height / CHAR_HEIGHT;
   /* determine the max. no. of chars per text line in a full screen window */
        MAXCOLS  = (screen_width) / CHAR_WIDTH;
        if (MAXCOLS > 255) MAXCOLS = 255;
        if (MAXCOLS < 81) MAXCOLS = 81;
        Caret_Offset = CHAR_HEIGHT - tm.tmInternalLeading;

        Server_window.handle = hWnd;
        Set_Up_Window(hWnd);
        SetErrorMode(SEM_NOOPENFILEERRORBOX);
        break;

     case WM_COMMAND:
        switch(wParam) {
            case IDM_QUIT    : Special_Exit = TRUE;
                               break;

            case IDM_REBOOT  : Special_Reboot = TRUE;
                               break;

            case IDM_STATUS  : Special_Status = TRUE;
                               break;

            case IDM_DBGSET  :
                  if (!IsWindow(hDbgDialog))
                  {
                      lpfnDlgBox = MakeProcInstance(DbgBoxProc, PROGINSTANCE);
                      hDbgDialog = CreateDialog(PROGINSTANCE, "DbgBox", NULL, lpfnDlgBox);
                      ShowWindow(hDbgDialog, SW_SHOWNORMAL);
                      UpdateWindow(hDbgDialog);
                  }
                  else
                      SetFocus(hDbgDialog);
                  break;

            case IDM_SETALL :
                  debugflags = All_Debug_Flags;
                  break;

            case IDM_RESETALL :
                  debugflags = 0L;
                  break;

            case IDM_ABOUT   :
                  if (!IsWindow(hAboutDialog))
                  {
                      lpfnAboutBox = MakeProcInstance(AboutDlgProc, PROGINSTANCE);
                      hAboutDialog = CreateDialog(PROGINSTANCE, "AboutBox", NULL, lpfnAboutBox);
                      ShowWindow(hAboutDialog, SW_SHOWNORMAL);
                      UpdateWindow(hAboutDialog);
                  }
                  else
                      SetFocus(hAboutDialog);
                  break;
        }
        break;

     case WM_PAINT:
       BeginPaint(hWnd, &ps);
       if (!(IsIconic(hWnd)))
         Repaint_Screen(hWnd, ps.rcPaint.top / CHAR_HEIGHT,
                              (ps.rcPaint.bottom / CHAR_HEIGHT) + 1,
                              ps.rcPaint.left / CHAR_WIDTH,
                              (ps.rcPaint.right / CHAR_WIDTH) + 1);
       EndPaint(hWnd, &ps);
       break;

     case WM_SIZE:
        {
        extern BOOL in_create;
        if ((wParam != SIZEICONIC) || (in_create))
         Set_Window_Size(hWnd);
        }
        break;


/* For keys pressed whem the main window is active, only interpret  */
/* non character keys, eg. function keys, alt, etc */

     case WM_KEYDOWN:
        if (!(non_char_keys(hWnd, wParam, lParam)))
           return(DefWindowProc(hWnd, iMessage, wParam, lParam));
        else
           break;

     case WM_SYSKEYDOWN:
        if (!(non_char_keys(hWnd,wParam,lParam)))
           return(DefWindowProc(hWnd, iMessage, wParam, lParam));
        else
           break;

     case WM_DESTROY:
       PostQuitMessage(0);
       break;

     case WM_CHAR:
        for (i = 0; i < (short) LOWORD(lParam); i++)
           process_keyboard(hWnd, wParam, lParam);
        break;

        /* Handling of alt-letter input					*/
     case WM_SYSCHAR:
	if ((wParam >= 'a') && (wParam <= 'z') && (lParam & 0x20000000))
	 if ((wParam != 'f') && (wParam != 'd') && (wParam != 'h'))
          return(0L);
      return DefWindowProc(hWnd, iMessage, wParam, lParam);
        
     case WM_SETFOCUS:
        create_a_caret(hWnd);   /* displays a cursor in the graphics screen */
        break;

     case WM_KILLFOCUS:
        delete_a_caret(hWnd);
        break;

    default:
      return DefWindowProc(hWnd, iMessage, wParam, lParam);
  }
  return 0l;
}


/* PopupProc is the standard Windows Procedure, associated with the console */
/* and shell windows, called by Microsoft Windows when passing messages     */
/* pertaining to the console or shell windows.                              */


long FAR PASCAL PopupProc( hWnd, iMessage, wParam, lParam)
  HWND         hWnd;
  unsigned     iMessage;
  WORD         wParam;
  LONG         lParam;
{
   PAINTSTRUCT ps;
   short       i;
   HFONT       hFont;
   HDC         hDC;

   switch (iMessage) {
     case WM_CREATE:
        hFont = GetStockObject(SYSTEM_FIXED_FONT);
        hDC   = GetDC(hWnd);
        SelectObject(hDC, hFont);
        ReleaseDC(hWnd, hDC);
        Set_Up_Window(hWnd);   /* See mswindow.c */
        break;

     case WM_COMMAND:
        switch(wParam) {
            case IDM_QUIT    : Special_Exit = TRUE;
                               break;

            case IDM_REBOOT  : Special_Reboot = TRUE;
                               break;

            case IDM_STATUS  : Special_Status = TRUE;
                               break;

            case IDM_DBGSET  :
                  if (!IsWindow(hDbgDialog))
                  {
                      lpfnDlgBox = MakeProcInstance(DbgBoxProc, PROGINSTANCE);
                      hDbgDialog = CreateDialog(PROGINSTANCE, "DbgBox", NULL, lpfnDlgBox);
                      ShowWindow(hDbgDialog, SW_SHOWNORMAL);
                      UpdateWindow(hDbgDialog);
                  }
                  else
                      SetFocus(hDbgDialog);
                  break;

            case IDM_SETALL   :
                  debugflags = (0xFFFFFFFFL & ~(Memory_Flag + Log_Flag));
                  break;

            case IDM_RESETALL :
                  debugflags = 0L;
                  break;

            default:
                  NotifyMenu(wParam);
                  break;
        }



     case WM_PAINT:
        BeginPaint(hWnd, &ps);
        if (!(IsIconic(hWnd)))        /* see mswindow.c */
          Repaint_Screen(hWnd, ps.rcPaint.top / CHAR_HEIGHT,
                               (ps.rcPaint.bottom / CHAR_HEIGHT) + 1,
                               ps.rcPaint.left / CHAR_WIDTH,
                               (ps.rcPaint.right / CHAR_WIDTH) + 1);
        EndPaint(hWnd, &ps);
        break;

     case WM_SIZE:
       if (wParam != SIZEICONIC)
         Set_Window_Size(hWnd);    /* see mswindow.c */
       break;

/* trap all keys hit in the console or shell windows. See mswindow.c */
     case WM_KEYDOWN:
        if (!(non_char_keys(hWnd, wParam, lParam)))
           return(DefWindowProc(hWnd, iMessage, wParam, lParam));
        else
           break;

     case WM_SYSKEYDOWN:
        if (!(non_char_keys(hWnd,wParam,lParam)))
           return(DefWindowProc(hWnd, iMessage, wParam, lParam));
        else
           break;

     case WM_CHAR:
        for (i = 0; i < (short) LOWORD(lParam); i++)
           process_keyboard(hWnd, wParam, lParam);
        break;

        /* Handling of alt-letter input					*/
     case WM_SYSCHAR:
	if ((wParam >= 'a') && (wParam <= 'z') && (lParam & 0x20000000))
	 if ((wParam != 'f') && (wParam != 'd') && (wParam != 'h'))
          return(0L);
      return DefWindowProc(hWnd, iMessage, wParam, lParam);
        
     case WM_SETFOCUS:
        create_a_caret(hWnd);   /* displays a cursor in the graphics screen */
        break;

     case WM_KILLFOCUS:
        delete_a_caret(hWnd);
        break;

     default:
       return DefWindowProc(hWnd, iMessage, wParam, lParam);
   }
   return (0l);
}

void DrawFocus(HDC hDC, int x, int y, int cx, int cy, BOOL bFocus)
{
   RECT rect;
   rect.left = x;
   rect.top = y;
   rect.right = cx;
   rect.bottom = cy;
   InvertRect(hDC, &rect);
   if (bFocus)
        DrawFocusRect(hDC, &rect);
}

/*************************************************************************/
/*                                                                       */
/*   Function : AboutDlgProc                                             */
/*                                                                       */
/*   The function handles the servers about message box.                 */
/*                                                                       */
/*************************************************************************/


BOOL FAR PASCAL AboutDlgProc(hDlg, iMessage, wParam, lParam)
    HWND     hDlg;
    unsigned iMessage;
    WORD     wParam;
    LONG     lParam;
{
    switch(iMessage) {
        case WM_INITDIALOG:
             SetDlgItemText(hDlg, IDD_VERSION, SccsId1);
             break;

        case WM_COMMAND:
             switch(wParam) {
                case IDOK :
                      DestroyWindow(hDlg);
                      hAboutDialog = NULL;

                      PostMessage(LOWORD(Server_window.handle), WM_TIDYDIALOG, 0, 0);
                      break;

                default   : return FALSE;
             }
             break;

        default : return FALSE;
    }
    return TRUE;
}


/***********************************************************************/
/*                                                                     */
/*   Function : DbgBoxProc                                             */
/*                                                                     */
/*   A standard Windows dialog function to handle the dialog box used  */
/*   for modifying the debug settings of the server.                   */
/*                                                                     */
/***********************************************************************/


BOOL FAR PASCAL DbgBoxProc(hDlg, iMessage, wParam, lParam)
    HWND     hDlg;
    unsigned iMessage;
    WORD     wParam;
    LONG     lParam;
{
    switch(iMessage) {
        case WM_INITDIALOG:
             SetDlgItemText(hDlg, IDD_FNAME, "   ");
             Check_Current_Boxes(hDlg);
             break;

        case WM_COMMAND:
             switch(wParam) {
                case IDOK :
                      Update_Debug_Options(hDlg);
                      /* fall through */

                case IDCANCEL :
                      DestroyWindow(hDlg);
                      hDbgDialog = NULL;

                      PostMessage(LOWORD(Server_window.handle), WM_TIDYDIALOG, 0, 0);
                      break;

                case  IDD_BOOT    :
                case  IDD_COMS    :
                case  IDD_DEL     :
                case  IDD_ERR     :
                case  IDD_FILE    :
                case  IDD_GRAPHICS:
                case  IDD_RAWD    :
                case  IDD_INIT    :
                case  IDD_DIR     :
                case  IDD_KEYB    :
                case  IDD_MESS    :
                case  IDD_NAME    :
                case  IDD_OPEN    :
                case  IDD_CLOSE   :
                case  IDD_EXIT    :
                case  IDD_READ    :
                case  IDD_SRCH    :
                case  IDD_TIME    :
                case  IDD_OPRPLY  :
                case  IDD_WRITE   :
                case  IDD_MEMORY  :
                case  IDD_RECON   :
                case  IDD_DDE     :
                case  IDD_SCREEN  :
                case  IDD_TOFILE  :

                case IDD_FNAME    :
                         break;

                default   : return FALSE;
             }
             break;

        default : return FALSE;
    }
    return TRUE;
}


#if use_own_memory_management
void initialise_memory()
{       /* Do not allow the default data segment to move !!! */
  LockData(0);
}

char *get_mem(uint size)
{ HANDLE        handle  = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, size + 4);
  char          *result;

  if (handle eq 0) return(NULL);
  result = GlobalLock(handle);
  *((HANDLE *) result) = handle;
  return(&(result[4]));
}

void free_mem(char *a_ptr)
{ HANDLE        handle;
  a_ptr = a_ptr - 4;
  handle = *((HANDLE *) a_ptr);
  GlobalUnlock(handle);
  GlobalFree(handle);
}

void memory_map()
{
}

#endif
@


1.3
log
@Sorted out enabling all debug options, plus the handling of
Alt-key combinations
@
text
@d5 1
a5 1
/**             Copyright (C) 1990, CSIR - MIKOMTEK.                      **/
d19 2
a30 139

/****************************************************************************/
/*                                                                          */
/* Let me give you some idea as to what is involved in porting the standard */
/* PC I/O Server to run under Microsoft Windows.                            */
/*                                                                          */
/* Firstly, there are a number of definitions in the I/O Server which       */
/* conflict with definitions in Microsoft Windows. For instance, WORD,      */
/* which is defined in the I/O Server to be a 32 bit integer, is defined in */
/* Windows to be a 16 bit integer. I have thus not defined WORD int the I/O */
/* Server. WORD refers to a 16 bit integer, as defined in Windows. The type */
/* word is still defined in the I/O server to be a 32 bit integer. Similar  */
/* problems arise with the definitions of TRUE, FALSE and BYTE. These types */
/* are not defined in the server, and are defined in windows.h to be 16 bit */
/* values. The types true, false and byte are used in the I/O server under  */
/* windows to hold 32 bit values.                                           */
/*                                                                          */
/* Many of the modifications to the original I/O server are as a result of  */
/* the conflict between the type declarations of Windows and of the Server. */
/* I have used the compiler directive   #if MSWINDOWS   to overcome this    */
/* conflict, so these mods, and all other mods for that matter, should be   */
/* easy to spot.                                                            */
/*                                                                          */
/* Another really tedious task is going through the server's code and       */
/* modifying all the memory allocation functions. The normal C memory       */
/* allocation function, malloc, is not suitable for use in the server. We   */
/* thus have to make use of the Windows memory allocation functions         */
/* LocalAlloc and GlobalAlloc. The values returned from these two functions */
/* cause further problems. Since both functions return handles and not      */
/* addresses, I have had to modify some of the structures used in the I/O   */
/* server, so that these handles can be stored. Without the handles, I      */
/* would be unable to free any memory allocated. So have a look in          */
/* structs.h, etc for additions to some of the structures defined there.    */
/*                                                                          */
/* Another problem arises from the fact that the original I/O Server was    */
/* compiled using the LARGE memory model. According to all documentation on */
/* Microsoft Windows, this is a no-no. (So I didnt even try.) The I/O       */
/* Server under Windows is compiled using the MEDIUM memory model. We thus  */
/* have that all code addresses are far pointers, (good), and that all data */
/* addresses are near pointers by default. (YuuUUUKKKkk!!!!).               */
/*                                                                          */
/* The original I/O server is obviously designed around the LARGE memory    */
/* model, which is logical since all addresses, etc on the transputer are   */
/* 32 bit adresses. However, this design causes prblems in the MEDIUM model */
/* as we need to explicitly access 32 bit adresses. There is thus a fair    */
/* amount of type casting and modifications to parameter lists, especially  */
/* when accessing large memory buffers in the server. In an attempt to cut  */
/* changes to the original server to a minimum, all list nodes or           */
/* structures should be allocated from the automatic data segment and other */
/* large memory allocations should be done from global memory. By           */
/* allocating memory from the data segment, we get a near pointer which is  */
/* still compatible with the existing parameter and variable definitions of */
/* the server. The addresses of these near pointers are still stored in 32  */
/* bit words in the server, but this does not present a big problem as a    */
/* cast to far when storing the address does the trick, and the use of the  */
/* macro LOWORD, does the trick when retrieving the address. All we have to */
/* really be careful with is when we are working with far pointers to       */
/* memory, eg. the data field in the MCB structure.                         */
/*                                                                          */
/* The concept of using coroutines is definitely not kosher in Windows. As  */
/* far as Windows is concerned, your program has ONE stack, located in the  */
/* automatic data segment. This being the case, Windows allows the program  */
/* to have moveable and discardable code and data segments. Windows employs */
/* a method of walking the stack to determine whether return addresses, etc */
/* are valid when returning from a function call, etc. If the segment to be */
/* returned to has moved or has been discarded, Windows is able locate it   */
/* again and jump to it. Programs are thus able to run in a lot less memory */
/* than would be the case if it were a DOS application. Using coroutines    */
/* however, means that this whole concept falls flat, because we basically  */
/* have n stacks in the program, where n is the number of coroutines in the */
/* program. We are thus unable to use moveable code segments in the program */
/* and the segments have to be fixed. Since Windows helps itself to a large */
/* chunk of memory, we are faced with a serious memory problem, (using 640K */
/* that is.) and it is not made any easier by the fact that we only have    */
/* 64K in which to hold the programs static data, the programs stack, and   */
/* enough of a local heap to make the necessary dynamic allocations         */
/* required in the server. As a result, many of the functions of the server */
/* have been curtailed in this version under Windows. If a user were using  */
/* expanded memory, then it would be possible to incorporate these          */
/* functions again. (See defines.h for what is not supported).              */
/*                                                                          */
/* The problems caused by using coroutines in Windows does not stop there   */
/* and there is a fair amount of really horrible hacking going on in the    */
/* server to overcome them. (See pcasm.asm) That code has been done though, */
/* and may only need to be changed if a new version of Windows appears on   */
/* scene.                                                                   */
/*                                                                          */
/* What I have done to get around the problem of having multiple stacks in  */
/* a Windows program is not nice by any stretch of the imagination, but it  */
/* works for version 2.1 of Windows. (286 & 386). There are a growing       */
/* number of articles describing methods of coping with Windows' memory     */
/* management, but I have yet to come across one that deals with having     */
/* multiple stacks in a program in Windows. However, I suspect that there   */
/* probably is a nice neat way to deal with it. Any sort of information in  */
/* this regard has been unavailable, so I have had make do. Should any such */
/* information become available, I recommend that my hack be replaced with  */
/* a more acceptable method.                                                */
/*                                                                          */
/* The original server made extensive use of interrupts to drive keyboard   */
/* mouse, coms ports, etc. This is a no-no in Windows, as Windows takes     */
/* complete control of these interrupts. This being the case, I gleefully   */
/* erased 3/4's of the assembler code contained in the original server.     */
/* All that's left is the low level coroutine library, and the low level    */
/* link interface. (Plus some wicked looking code you dont want to look at  */
/* again.) So when it comes to writing the interfaces to the keyboard,      */
/* screen, mouse, printer, RS232, etc, we have to ditch even more of the    */
/* original servers code, and replace it with Windows code. (Billions of    */
/* Blistering Blue ... etc, etc. Well at least you will become a Windows    */
/* buff).                                                                   */
/*                                                                          */
/* Fortunately Windows does not have any special file handling functions    */
/* and is content to use those of DOS. Even so, the problem of having far   */
/* pointers to data buffers rose its ugly head again, and we are forced to  */
/* use some of the undocumented Windows low level file handling routines,   */
/* _lread and _lwrite. Should these calls be discarded by Windows, the file */
/* I/O part of the server will have to be revised.                          */
/*                                                                          */
/* We need Windows compatible code to handle the opening and closing of     */
/* windows, and the output and input associated with the various            */
/* windows. So all the use_ANSI_emulator code found in the original server  */
/* is not used, and the screen and keyboard interfaces for the server under */
/* Windows can be found in mswindow.c.                                      */
/*                                                                          */
/* There is a graphics interface, using the Windows graphics calls, that    */
/* can be found in the file graph.c, and there is a printer interface that  */
/* can only be used to print metafiles previously stored using the graphics */
/* server. (or a metafile created in Windows.) This code can be found in    */
/* file grfxprn.c. (Gives an example of how the printer interface in        */
/* Windows works.)                                                          */
/*                                                                          */
/* All modifications to the original server sources are prefixed by the     */
/* compiler directives   #if MSWINDOWS    or  #if !(MSWINDOWS) so they      */
/* should be easy to spot!!                                                 */
/*                                                                          */
/****************************************************************************/

/* BLV - please ignore most of the above */


a40 1
#if graphics
a44 4
#endif
#if print_graphics
extern long FAR PASCAL GrfPrnProc(HWND, unsigned, WORD, LONG);
#endif
a200 1
#if graphics
a201 1
#endif
a202 18
#if print_graphics

     wndclass.style         = CS_NOCLOSE; /* dont allow user to close window */
     wndclass.lpfnWndProc   = GrfPrnProc;
     wndclass.cbClsExtra    = 0;
     wndclass.cbWndExtra    = 0;
     wndclass.hInstance     = PROGINSTANCE;
     wndclass.hIcon         = LoadIcon(global_hInstance, "prnicon");
     wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
     wndclass.hbrBackground = GetStockObject(WHITE_BRUSH);
     wndclass.lpszMenuName  = NULL;
     wndclass.lpszClassName = Print_Name;

     if (!RegisterClass(&wndclass)) print_registered = 0;
        else
            print_registered = 1;
#endif

d344 4
a347 3
     if (log_dest eq Log_to_file) CheckDlgButton(hDlg, IDD_TOFILE, 1);
        else
           CheckDlgButton(hDlg, IDD_SCREEN, 1);
d350 24
a373 110
/* If all the debug flags are selected, set all check boxes */

   if (debugflags eq (0xFFFFFFFFL & ~(Memory_Flag + Log_Flag))) {
      for (ct = IDD_ALL; ct <= IDD_WRITE; ct++)
        CheckDlgButton(hDlg, ct, 1);
      return;
   }

/* go thorugh check boxes and set those flags selected */

   for (ct = IDD_DEL; ct <= IDD_GRAPHICS; ct++) {
      switch(ct) {
         case IDD_DEL    :
                if (debugflags & Delete_Flag)
                    CheckDlgButton(hDlg, IDD_DEL, 1);
                break;

         case IDD_FILE   :
                if (debugflags & FileIO_Flag)
                    CheckDlgButton(hDlg, IDD_FILE, 1);
                break;

         case IDD_RAWD   :
                if (debugflags & HardDisk_Flag)
                    CheckDlgButton(hDlg, IDD_RAWD, 1);
                break;

         case IDD_INIT   :
                if (debugflags & Init_Flag)
                    CheckDlgButton(hDlg, IDD_INIT, 1);
                break;

         case IDD_DIR    :
                if (debugflags & Directory_Flag)
                    CheckDlgButton(hDlg, IDD_DIR, 1);
                break;

         case IDD_KEYB   :
                if (debugflags & Keyboard_Flag)
                    CheckDlgButton(hDlg, IDD_KEYB, 1);
                break;

         case IDD_LOG    :
                if (debugflags & Log_Flag)
                    CheckDlgButton(hDlg, IDD_LOG, 1);
                break;

         case IDD_MESS   :
                if (debugflags & Message_Flag)
                    CheckDlgButton(hDlg, IDD_MESS, 1);
                break;

         case IDD_NAME   :
                if (debugflags & Name_Flag)
                    CheckDlgButton(hDlg, IDD_NAME, 1);
                break;

         case IDD_OPEN   :
                if (debugflags & Open_Flag)
                    CheckDlgButton(hDlg, IDD_OPEN, 1);
                break;

         case IDD_CLOSE  :
                if (debugflags & Close_Flag)
                    CheckDlgButton(hDlg, IDD_CLOSE, 1);
                break;

         case IDD_EXIT   :
                if (debugflags & Quit_Flag)
                    CheckDlgButton(hDlg, IDD_EXIT, 1);
                break;

         case IDD_READ   :
                if (debugflags & Read_Flag)
                    CheckDlgButton(hDlg, IDD_READ, 1);
                break;

         case IDD_SRCH   :
                if (debugflags & Search_Flag)
                    CheckDlgButton(hDlg, IDD_SRCH, 1);
                break;

         case IDD_TIME   :
                if (debugflags & Timeout_Flag)
                    CheckDlgButton(hDlg, IDD_TIME, 1);
                break;

         case IDD_OPRPLY :
                if (debugflags & OpenReply_Flag)
                    CheckDlgButton(hDlg, IDD_OPRPLY, 1);
                break;

         case IDD_WRITE  :
                if (debugflags & Write_Flag)
                    CheckDlgButton(hDlg, IDD_WRITE, 1);
                break;

         case IDD_DDE  :
                if (debugflags & DDE_Flag)
                    CheckDlgButton(hDlg, IDD_DDE, 1);
                break;

         case IDD_GRAPHICS  :
                if (debugflags & Graphics_Flag)
                    CheckDlgButton(hDlg, IDD_GRAPHICS, 1);
                break;

         default         : break;
      }
   }
d400 1
a400 1
           log_dest = Log_to_screen;
a402 11
/* if All debug options has been selected, set all debug flags */
/* if All is not selected, set debug flags to 0, and see what has been */
/* selected */

   if (IsDlgButtonChecked(hDlg, IDD_ALL)) {
     debugflags = (0xFFFFFFFFL & ~(Memory_Flag + Log_Flag));
     return;
   }
   else
     debugflags = 0L;

d405 5
d411 21
a431 6
   for (ct = IDD_DEL; ct <= IDD_GRAPHICS; ct++) {
      switch(ct) {
         case IDD_DEL    :
            if (IsDlgButtonChecked(hDlg, IDD_DEL))
                debugflags ^= Delete_Flag;
            break;
d433 3
a435 93
         case IDD_FILE   :
            if (IsDlgButtonChecked(hDlg, IDD_FILE))
                debugflags ^= FileIO_Flag;
            break;

         case IDD_RAWD   :
            if (IsDlgButtonChecked(hDlg, IDD_RAWD))
                debugflags ^= HardDisk_Flag;
            break;

         case IDD_INIT   :
            if (IsDlgButtonChecked(hDlg, IDD_INIT))
                debugflags ^= Init_Flag;
            break;

         case IDD_DIR    :
            if (IsDlgButtonChecked(hDlg, IDD_DIR))
                debugflags ^= Directory_Flag;
            break;

         case IDD_KEYB   :
            if (IsDlgButtonChecked(hDlg, IDD_KEYB))
                debugflags ^= Keyboard_Flag;
            break;

         case IDD_LOG    :
            if (IsDlgButtonChecked(hDlg, IDD_LOG) && (old_log eq log_dest))
                debugflags ^= Log_Flag;
            break;

         case IDD_MESS   :
            if (IsDlgButtonChecked(hDlg, IDD_MESS))
                debugflags ^= Message_Flag;
            break;

         case IDD_NAME   :
            if (IsDlgButtonChecked(hDlg, IDD_NAME))
                debugflags ^= Name_Flag;
            break;

         case IDD_OPEN   :
            if (IsDlgButtonChecked(hDlg, IDD_OPEN))
                debugflags ^= Open_Flag;
            break;

         case IDD_CLOSE  :
            if (IsDlgButtonChecked(hDlg, IDD_CLOSE))
                debugflags ^= Close_Flag;
            break;

         case IDD_EXIT   :
            if (IsDlgButtonChecked(hDlg, IDD_EXIT))
                debugflags ^= Quit_Flag;
            break;

         case IDD_READ   :
            if (IsDlgButtonChecked(hDlg, IDD_READ))
                debugflags ^= Read_Flag;
            break;

         case IDD_SRCH   :
            if (IsDlgButtonChecked(hDlg, IDD_SRCH))
                debugflags ^= Search_Flag;
            break;

         case IDD_TIME   :
            if (IsDlgButtonChecked(hDlg, IDD_TIME))
                debugflags ^= Timeout_Flag;
            break;

         case IDD_OPRPLY :
            if (IsDlgButtonChecked(hDlg, IDD_OPRPLY))
                debugflags ^= OpenReply_Flag;
            break;

         case IDD_WRITE  :
            if (IsDlgButtonChecked(hDlg, IDD_WRITE))
                debugflags ^= Write_Flag;
            break;

         case IDD_DDE  :
            if (IsDlgButtonChecked(hDlg, IDD_DDE))
                debugflags ^= DDE_Flag;
            break;

         case IDD_GRAPHICS  :
            if (IsDlgButtonChecked(hDlg, IDD_GRAPHICS))
                debugflags ^= Graphics_Flag;
            break;

         default         : break;
      }
   }
d804 2
a805 1
                case  IDD_ALL     :
d807 1
d809 1
a813 1
                case  IDD_LOG     :
d824 3
a828 5
                case  IDD_DDE     :
                case  IDD_GRAPHICS:
                         CheckDlgButton(hDlg, wParam,
                                         !IsDlgButtonChecked(hDlg, wParam));
                         break;
d830 1
a830 1
                case IDD_FNAME   :
@


1.2
log
@Rewrite of Windows-specific bits of the I/O Server by Mike Gunning
@
text
@d843 1
a843 1
                  debugflags = (0xFFFFFFFFL & ~(Memory_Flag + Log_Flag));
d907 7
d1025 7
@


1.1
log
@Initial revision
@
text
@d3 12
a14 12
/**		Helios I/O Server under Microsoft Windows		  **/
/**									  **/
/**		Copyright (C) 1990, CSIR - MIKOMTEK.			  **/
/**			      All Rights Reserved.			  **/
/**									  **/
/**   winsrvr.c 							  **/
/**									  **/
/**	This file contains the main driver engine of the I/O Server.	  **/
/**	The file initiates the startup procedure of the I/O Server, and   **/
/**	contains the most outer loop of the server. The file also	  **/
/**	contains the I/O Server interface with Microsoft Windows.	  **/
/**									  **/
d16 4
a19 4
/**				    (BLV. of Perihelion Software Ltd.  )  **/
/**									  **/
/**   Site   : CSIR - MIKOMTEK						  **/
/**									  **/
a27 1
#include "windows\msevent.h"
d31 1
a31 1
/*									    */
d33 4
a36 4
/* PC I/O Server to run under Microsoft Windows.			    */
/*									    */
/* Firstly, there are a number of definitions in the I/O Server which	    */
/* conflict with definitions in Microsoft Windows. For instance, WORD,	    */
d44 2
a45 2
/* windows to hold 32 bit values.					    */
/*									    */
d48 1
a48 1
/* I have used the compiler directive	#if MSWINDOWS	to overcome this    */
d50 2
a51 2
/* easy to spot.							    */
/*									    */
d53 1
a53 1
/* modifying all the memory allocation functions. The normal C memory	    */
d55 1
a55 1
/* thus have to make use of the Windows memory allocation functions	    */
d57 1
a57 1
/* cause further problems. Since both functions return handles and not	    */
d59 2
a60 2
/* server, so that these handles can be stored. Without the handles, I	    */
/* would be unable to free any memory allocated. So have a look in	    */
d62 1
a62 1
/*									    */
d65 1
a65 1
/* Microsoft Windows, this is a no-no. (So I didnt even try.) The I/O	    */
d68 2
a69 2
/* addresses are near pointers by default. (YuuUUUKKKkk!!!!).		    */
/*									    */
d76 1
a76 1
/* changes to the original server to a minimum, all list nodes or	    */
d78 1
a78 1
/* large memory allocations should be done from global memory. By	    */
d85 3
a87 3
/* really be careful with is when we are working with far pointers to	    */
/* memory, eg. the data field in the MCB structure.			    */
/*									    */
d104 1
a104 1
/* enough of a local heap to make the necessary dynamic allocations	    */
d107 3
a109 3
/* expanded memory, then it would be possible to incorporate these	    */
/* functions again. (See defines.h for what is not supported).		    */
/*									    */
d114 2
a115 2
/* scene.								    */
/*									    */
d118 1
a118 1
/* works for version 2.1 of Windows. (286 & 386). There are a growing	    */
d125 2
a126 2
/* a more acceptable method.						    */
/*									    */
d133 1
a133 1
/* again.) So when it comes to writing the interfaces to the keyboard,	    */
d137 2
a138 2
/* buff).								    */
/*									    */
d144 2
a145 2
/* I/O part of the server will have to be revised.			    */
/*									    */
d147 1
a147 1
/* windows, and the output and input associated with the various	    */
d150 2
a151 2
/* Windows can be found in mswindow.c.					    */
/*									    */
d156 3
a158 3
/* file grfxprn.c. (Gives an example of how the printer interface in	    */
/* Windows works.)							    */
/*									    */
d160 3
a162 3
/* compiler directives	 #if MSWINDOWS	  or  #if !(MSWINDOWS) so they	    */
/* should be easy to spot!!						    */
/*									    */
d168 4
a171 4
static char *argv[20];	/* for command line arguments */
int	     argc;	/* for no. of cmd line args */
PRIVATE HANDLE	global_hInstance;
	int	global_nCmdShow;
d179 3
d194 2
a195 3
extern	void show_logger_name(HWND);
extern	void set_logger_name(HWND);
extern	int  No_Help_Present(void);
d197 1
d199 5
d207 1
a207 1
/*									  */
d209 2
a210 2
/* application entry point.						  */
/*									  */
d212 4
a215 4
/* the interface between the two message passing systems of Helios and	  */
/* Microsoft Windows, via the MainLoop and PeekMessage calls.		  */
/*									  */
/* The function registers two window classes, the first being the main	  */
d217 4
a220 4
/* shell windows. Once the two classes have been registered, the main	  */
/* server window is opened.						  */
/*									  */
/* If the graphics server is incorporated, a seperate graphics window	  */
d222 2
a223 2
/* is incorporated.							  */
/*									  */
d225 1
a225 1
/* whether the server will be able to function under that particular	  */
d227 3
a229 3
/* server_main. 							  */
/*									  */
/* Once the server has been set up, the function enters the main outer	  */
d231 1
a231 1
/* Upon entry to the main loop, the server is initialised. (This must	  */
d233 1
a233 1
/* rebooted) Once initialised, the server runs until completion,	  */
d235 1
a235 1
/*									  */
d244 1
a244 5
  global_hInstance	= hInstance;
  PROGINSTANCE		= hInstance;
  global_nCmdShow	= nCmdShow;
  Server_window.handle	= 0L;
  real_windows		= 1;
d246 7
a252 1
	/* Only one I/O Server please	*/
d256 2
d259 19
a277 1
  return(server_main(argc, argv));
d281 1
a281 1
{ char  szCaption [] = "Helios I/O Server";	/* caption for main server */
d283 7
a289 6
  HWND	       hWnd;
  HDC	       deskDC;
  int	       colors,
	       count = 0,     /* counter */
	       CARRYON = 1,   /* flag used in the main loop */
	       xdim, ydim;    /* dimensions of the graphics screen */
d298 6
a303 6
	deskDC = GetDC(hWnd);
	if (deskDC eq 0) colors = 2;
	    else {
		colors = GetDeviceCaps(deskDC, NUMCOLORS);
		ReleaseDC(hWnd, deskDC);
	    }
d309 1
a309 1
    wndclass.style	   = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_NOCLOSE;
d313 1
a313 1
    wndclass.hInstance	   = global_hInstance;
d315 1
a315 1
       wndclass.hIcon	      = LoadIcon(global_hInstance, "mainicon");
d317 1
a317 1
       wndclass.hIcon	      = LoadIcon(global_hInstance, "monomain");
d319 1
a319 1
    wndclass.hbrBackground = GetStockObject(WHITE_BRUSH);
d327 1
a327 1
    wndclass.style	   = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_NOCLOSE;
d331 1
a331 1
    wndclass.hInstance	   = global_hInstance;
d333 1
a333 1
       wndclass.hIcon	      = LoadIcon(global_hInstance, "shellicon");
d335 3
a337 3
       wndclass.hIcon	      = LoadIcon(global_hInstance, "monoshell");
    wndclass.hCursor	   = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = GetStockObject(WHITE_BRUSH);
d344 1
a344 18

/* register the graphics window class for the graphics server */

     wndclass.style	    = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_NOCLOSE;
     wndclass.lpfnWndProc   = GraphProc;
     wndclass.cbClsExtra    = 0;
     wndclass.cbWndExtra    = 0;
     wndclass.hInstance     = PROGINSTANCE;
     wndclass.hIcon	    = LoadIcon(global_hInstance, "graphicon");
     wndclass.hCursor	    = LoadCursor(NULL, IDC_ARROW);
     wndclass.hbrBackground = GetStockObject(WHITE_BRUSH);
     wndclass.lpszMenuName  = NULL;
     wndclass.lpszClassName = Graph_Name;

     if (!RegisterClass(&wndclass)) graphics_registered = 0;
	else
	    graphics_registered = 1;

d349 1
a349 1
     wndclass.style	    = CS_NOCLOSE; /* dont allow user to close window */
d354 2
a355 2
     wndclass.hIcon	    = LoadIcon(global_hInstance, "prnicon");
     wndclass.hCursor	    = LoadCursor(NULL, IDC_ARROW);
d361 2
a362 2
	else
	    print_registered = 1;
d365 10
d381 2
a382 2
{ MSG		msg;
/* We need to clear the message buffer of Windows. What remains in the	*/
d384 1
a384 1
/* paint message.							*/
d393 2
a394 2
{ MSG		msg;
/* We need to clear the message buffer of Windows. What remains in the	*/
d396 1
a396 1
/* paint message.							*/
d405 1
a405 1
{ MSG		msg;
d408 1
d411 9
a419 2
      TranslateMessage(&msg);
      DispatchMessage(&msg);
a421 2
  do_msevent();
  do_msmouse();
d426 17
a442 17
/*									   */
/*  getcmdline								   */
/*									   */
/*  Parameters :-							   */
/*	 lpszCmdLine - The command line Windows gives to an application.   */
/*	 argc	     - Used to return the number of arguments in the	   */
/*		       command line.					   */
/*	 argv	     - Used to hold all the different arguments on the	   */
/*		       command line.					   */
/*									   */
/*  Function :- 							   */
/*	 The function extracts the various command line arguments from the */
/*	 command line string passed to the I/O server by Microsoft Windows */
/*									   */
/*  Returns :-								   */
/*	 The command line arguments in argv.				   */
/*	 The number of command line arguments in argc.			   */
d446 3
a448 3
  LPSTR 	 lpszCmdLine;
  int		 *argc;
  char		 **argv;
d458 1
a458 1
    if (*lpszCmdLine == '"') {	  /* a string name as part of the command line */
d461 1
a461 1
	temp[count] = *lpszCmdLine;  /* store the name in temp */
d484 3
a486 3
/*									   */
/*  Function : Check_Current_Boxes					   */
/*									   */
d490 2
a491 2
/*  box.								   */
/*									   */
d507 2
a508 2
	else
	   CheckDlgButton(hDlg, IDD_SCREEN, 1);
d515 1
a515 1
	CheckDlgButton(hDlg, ct, 1);
d521 1
a521 1
   for (ct = IDD_DEL; ct <= IDD_WRITE; ct++) {
d523 4
a526 4
	 case IDD_DEL	 :
		if (debugflags & Delete_Flag)
		    CheckDlgButton(hDlg, IDD_DEL, 1);
		break;
d528 4
a531 4
	 case IDD_FILE	 :
		if (debugflags & FileIO_Flag)
		    CheckDlgButton(hDlg, IDD_FILE, 1);
		break;
d533 4
a536 4
	 case IDD_RAWD	 :
		if (debugflags & HardDisk_Flag)
		    CheckDlgButton(hDlg, IDD_RAWD, 1);
		break;
d538 4
a541 4
	 case IDD_INIT	 :
		if (debugflags & Init_Flag)
		    CheckDlgButton(hDlg, IDD_INIT, 1);
		break;
d543 4
a546 4
	 case IDD_DIR	 :
		if (debugflags & Directory_Flag)
		    CheckDlgButton(hDlg, IDD_DIR, 1);
		break;
d548 4
a551 4
	 case IDD_KEYB	 :
		if (debugflags & Keyboard_Flag)
		    CheckDlgButton(hDlg, IDD_KEYB, 1);
		break;
d553 4
a556 4
	 case IDD_LOG	 :
		if (debugflags & Log_Flag)
		    CheckDlgButton(hDlg, IDD_LOG, 1);
		break;
d558 4
a561 4
	 case IDD_MESS	 :
		if (debugflags & Message_Flag)
		    CheckDlgButton(hDlg, IDD_MESS, 1);
		break;
d563 4
a566 4
	 case IDD_NAME	 :
		if (debugflags & Name_Flag)
		    CheckDlgButton(hDlg, IDD_NAME, 1);
		break;
d568 4
a571 4
	 case IDD_OPEN	 :
		if (debugflags & Open_Flag)
		    CheckDlgButton(hDlg, IDD_OPEN, 1);
		break;
d573 4
a576 4
	 case IDD_CLOSE  :
		if (debugflags & Close_Flag)
		    CheckDlgButton(hDlg, IDD_CLOSE, 1);
		break;
d578 4
a581 4
	 case IDD_EXIT	 :
		if (debugflags & Quit_Flag)
		    CheckDlgButton(hDlg, IDD_EXIT, 1);
		break;
d583 4
a586 4
	 case IDD_READ	 :
		if (debugflags & Read_Flag)
		    CheckDlgButton(hDlg, IDD_READ, 1);
		break;
d588 4
a591 4
	 case IDD_SRCH	 :
		if (debugflags & Search_Flag)
		    CheckDlgButton(hDlg, IDD_SRCH, 1);
		break;
d593 4
a596 4
	 case IDD_TIME	 :
		if (debugflags & Timeout_Flag)
		    CheckDlgButton(hDlg, IDD_TIME, 1);
		break;
d598 4
a601 4
	 case IDD_OPRPLY :
		if (debugflags & OpenReply_Flag)
		    CheckDlgButton(hDlg, IDD_OPRPLY, 1);
		break;
d603 4
a606 4
	 case IDD_WRITE  :
		if (debugflags & Write_Flag)
		    CheckDlgButton(hDlg, IDD_WRITE, 1);
		break;
d608 11
a618 1
	 default	 : break;
d625 7
a631 7
/*									  */
/*   Function : Update_Debug_Options					  */
/*									  */
/*   The function captures the user input on the dialog box used for	  */
/*   changing debug settings in the server, and updates the dialog box	  */
/*   display to reflect the users input.				  */
/*									  */
d643 2
a644 2
     log_dest = Log_to_both;		   /* has the log destination */
   else {				   /* changed?		      */
d646 2
a647 2
	else
	   log_dest = Log_to_screen;
d664 1
a664 1
   for (ct = IDD_DEL; ct <= IDD_WRITE; ct++) {
d666 4
a669 4
	 case IDD_DEL	 :
	    if (IsDlgButtonChecked(hDlg, IDD_DEL))
		debugflags ^= Delete_Flag;
	    break;
d671 4
a674 4
	 case IDD_FILE	 :
	    if (IsDlgButtonChecked(hDlg, IDD_FILE))
		debugflags ^= FileIO_Flag;
	    break;
d676 4
a679 4
	 case IDD_RAWD	 :
	    if (IsDlgButtonChecked(hDlg, IDD_RAWD))
		debugflags ^= HardDisk_Flag;
	    break;
d681 4
a684 4
	 case IDD_INIT	 :
	    if (IsDlgButtonChecked(hDlg, IDD_INIT))
		debugflags ^= Init_Flag;
	    break;
d686 4
a689 4
	 case IDD_DIR	 :
	    if (IsDlgButtonChecked(hDlg, IDD_DIR))
		debugflags ^= Directory_Flag;
	    break;
d691 4
a694 4
	 case IDD_KEYB	 :
	    if (IsDlgButtonChecked(hDlg, IDD_KEYB))
		debugflags ^= Keyboard_Flag;
	    break;
d696 4
a699 4
	 case IDD_LOG	 :
	    if (IsDlgButtonChecked(hDlg, IDD_LOG) && (old_log eq log_dest))
		debugflags ^= Log_Flag;
	    break;
d701 4
a704 4
	 case IDD_MESS	 :
	    if (IsDlgButtonChecked(hDlg, IDD_MESS))
		debugflags ^= Message_Flag;
	    break;
d706 4
a709 4
	 case IDD_NAME	 :
	    if (IsDlgButtonChecked(hDlg, IDD_NAME))
		debugflags ^= Name_Flag;
	    break;
d711 4
a714 4
	 case IDD_OPEN	 :
	    if (IsDlgButtonChecked(hDlg, IDD_OPEN))
		debugflags ^= Open_Flag;
	    break;
d716 4
a719 4
	 case IDD_CLOSE  :
	    if (IsDlgButtonChecked(hDlg, IDD_CLOSE))
		debugflags ^= Close_Flag;
	    break;
d721 4
a724 4
	 case IDD_EXIT	 :
	    if (IsDlgButtonChecked(hDlg, IDD_EXIT))
		debugflags ^= Quit_Flag;
	    break;
d726 4
a729 4
	 case IDD_READ	 :
	    if (IsDlgButtonChecked(hDlg, IDD_READ))
		debugflags ^= Read_Flag;
	    break;
d731 4
a734 4
	 case IDD_SRCH	 :
	    if (IsDlgButtonChecked(hDlg, IDD_SRCH))
		debugflags ^= Search_Flag;
	    break;
d736 4
a739 4
	 case IDD_TIME	 :
	    if (IsDlgButtonChecked(hDlg, IDD_TIME))
		debugflags ^= Timeout_Flag;
	    break;
d741 4
a744 4
	 case IDD_OPRPLY :
	    if (IsDlgButtonChecked(hDlg, IDD_OPRPLY))
		debugflags ^= OpenReply_Flag;
	    break;
d746 4
a749 4
	 case IDD_WRITE  :
	    if (IsDlgButtonChecked(hDlg, IDD_WRITE))
		debugflags ^= Write_Flag;
	    break;
d751 11
a761 1
	 default	 : break;
d767 3
a769 3
/* WndProc is the standard Windows Procedure, associated with the main	 */
/* server window, called by Microsoft Windows, when passing messages	 */
/* pertaining to the main server window.				 */
d775 1
a775 1
  LONG	       lParam;
d778 4
a781 4
  int	      caption_height,	/* Height of the caption in pixels */
	      screen_height,	/* Height of the screen in pixels */
	      screen_width;	/* width of the screen in pixels */
  HDC	      hDC;
d784 1
a784 1
  FARPROC     lpfnAboutProc, lpfnDlgBox;
d788 6
d796 8
a803 8
	caption_height = GetSystemMetrics(SM_CYCAPTION);
	screen_height  = GetSystemMetrics(SM_CYSCREEN);
	screen_width   = GetSystemMetrics(SM_CXSCREEN);
	hFont	       = GetStockObject(SYSTEM_FIXED_FONT);
	hDC = GetDC(hWnd);
	SelectObject(hDC, hFont);
	GetTextMetrics(hDC, &tm);
	ReleaseDC(hWnd, hDC);
d805 3
a807 3
	CHAR_WIDTH  = tm.tmAveCharWidth;
	CHAR_HEIGHT = tm.tmHeight + tm.tmExternalLeading;
	MAXLINES = screen_height / CHAR_HEIGHT;
d809 4
a812 4
	MAXCOLS  = (screen_width) / CHAR_WIDTH;
	if (MAXCOLS > 255) MAXCOLS = 255;
	if (MAXCOLS < 81) MAXCOLS = 81;
	Caret_Offset = CHAR_HEIGHT - tm.tmInternalLeading;
d814 4
a817 3
	Server_window.handle = hWnd;
	Set_Up_Window(hWnd);
	break;
d820 3
a822 3
	switch(wParam) {
	    case IDM_QUIT    : Special_Exit = TRUE;
			       break;
d824 2
a825 2
	    case IDM_REBOOT  : Special_Reboot = TRUE;
			       break;
d827 2
a828 2
	    case IDM_STATUS  : Special_Status = TRUE;
			       break;
d830 11
a840 5
	    case IDM_DBGSET  :
		  lpfnDlgBox = MakeProcInstance(DbgBoxProc, PROGINSTANCE);
		  DialogBox(PROGINSTANCE, "DbgBox", hWnd, lpfnDlgBox);
		  FreeProcInstance(lpfnDlgBox);
		  break;
d842 3
a844 3
	    case IDM_SETALL :
		  debugflags = (0xFFFFFFFFL & ~(Memory_Flag + Log_Flag));
		  break;
d846 3
a848 3
	    case IDM_RESETALL :
		  debugflags = 0L;
		  break;
d850 13
a862 2
	    case IDM_WINHLP :
	    case IDM_HELHLP : break;
a863 9
	    case IDM_ABOUT   :
		  lpfnAboutProc = MakeProcInstance(AboutDlgProc, PROGINSTANCE);
		  DialogBox(PROGINSTANCE, "AboutBox", hWnd,
			     lpfnAboutProc);
		  FreeProcInstance(lpfnAboutProc);
		  break;
	}
	break;

d867 4
a870 4
	 Repaint_Screen(hWnd, ps.rcPaint.top / CHAR_HEIGHT,
			      (ps.rcPaint.bottom / CHAR_HEIGHT) + 1,
			      ps.rcPaint.left / CHAR_WIDTH,
			      (ps.rcPaint.right / CHAR_WIDTH) + 1);
d875 6
a880 3
       if (wParam != SIZEICONIC)   /* dont reset size of window if window */
	 Set_Window_Size(hWnd);    /* minimized */
	break;
d887 4
a890 4
	if (!(non_char_keys(hWnd, wParam, lParam)))
	   return(DefWindowProc(hWnd, iMessage, wParam, lParam));
	else
	   break;
d893 4
a896 4
	if (!(non_char_keys(hWnd,wParam,lParam)))
	   return(DefWindowProc(hWnd, iMessage, wParam, lParam));
	else
	   break;
d903 3
a905 3
	for (i = 0; i < (short) LOWORD(lParam); i++)
	   process_keyboard(hWnd, wParam, lParam);
	break;
d908 2
a909 2
	create_a_caret(hWnd);	/* displays a cursor in the graphics screen */
	break;
d912 2
a913 2
	delete_a_caret(hWnd);
	break;
a914 3
    case WM_TIMER :
	break;

d924 1
a924 1
/* pertaining to the console or shell windows.				    */
d931 1
a931 1
  LONG	       lParam;
d936 1
a936 2
   HDC	       hDC;
   FARPROC     lpfnDlgBox;
a938 1

d940 6
a945 6
	hFont = GetStockObject(SYSTEM_FIXED_FONT);
	hDC   = GetDC(hWnd);
	SelectObject(hDC, hFont);
	ReleaseDC(hWnd, hDC);
	Set_Up_Window(hWnd);   /* See mswindow.c */
	break;
d948 3
a950 3
	switch(wParam) {
	    case IDM_QUIT    : Special_Exit = TRUE;
			       break;
d952 2
a953 2
	    case IDM_REBOOT  : Special_Reboot = TRUE;
			       break;
d955 2
a956 2
	    case IDM_STATUS  : Special_Status = TRUE;
			       break;
d958 11
a968 5
	    case IDM_DBGSET  :
		  lpfnDlgBox = MakeProcInstance(DbgBoxProc, PROGINSTANCE);
		  DialogBox(PROGINSTANCE, "DbgBox", hWnd, lpfnDlgBox);
		  FreeProcInstance(lpfnDlgBox);
		  break;
d970 3
a972 3
	    case IDM_SETALL   :
		  debugflags = (0xFFFFFFFFL & ~(Memory_Flag + Log_Flag));
		  break;
d974 3
a976 3
	    case IDM_RESETALL :
		  debugflags = 0L;
		  break;
d978 4
a981 1
	    case IDM_WINHLP : break;
a982 14
	    case IDM_HELHLP :
		  if (!MsEvent_Active)
		    MessageBox(NULL,
	"Helios MS-Windows Server Not Active - To activate, run startws!",
	"startws not loaded!", MB_ICONSTOP | MB_OK);
		  else	{
		    if (No_Help_Present())
		       new_msevent(MenuSelection, -1, HeliosHelp, 0L);
		    else
			MessageBox(NULL,
	 "Unable to Spawn New HELP Window - Helios HELP window already exists!",
	 "Existence Of HELP", MB_ICONSTOP | MB_OK);
		  }
		  break;
a983 8
	    case IDM_NEWSH   :
		  if (!MsEvent_Active)
		    MessageBox(NULL,
	"Helios MS-Windows Server Not Active - To activate, run startws!",
	"startws not loaded!", MB_ICONSTOP | MB_OK);
		  else
		    new_msevent(MenuSelection, -1, NewShell, 0L);
		  break;
a984 8
	    case IDM_CLOSESH : add_to_key_buffer(hWnd, "exit");
			       break;

	}
	break;



d986 8
a993 8
	BeginPaint(hWnd, &ps);
	if (!(IsIconic(hWnd)))	      /* see mswindow.c */
	  Repaint_Screen(hWnd, ps.rcPaint.top / CHAR_HEIGHT,
			       (ps.rcPaint.bottom / CHAR_HEIGHT) + 1,
			       ps.rcPaint.left / CHAR_WIDTH,
			       (ps.rcPaint.right / CHAR_WIDTH) + 1);
	EndPaint(hWnd, &ps);
	break;
d997 1
a997 1
	 Set_Window_Size(hWnd);    /* see mswindow.c */
d1002 4
a1005 4
	if (!(non_char_keys(hWnd, wParam, lParam)))
	   return(DefWindowProc(hWnd, iMessage, wParam, lParam));
	else
	   break;
d1008 4
a1011 4
	if (!(non_char_keys(hWnd,wParam,lParam)))
	   return(DefWindowProc(hWnd, iMessage, wParam, lParam));
	else
	   break;
d1014 3
a1016 3
	for (i = 0; i < (short) LOWORD(lParam); i++)
	   process_keyboard(hWnd, wParam, lParam);
	break;
d1019 2
a1020 2
	create_a_caret(hWnd);	/* displays a cursor in the graphics screen */
	break;
d1023 2
a1024 2
	delete_a_caret(hWnd);
	break;
d1032 11
d1045 5
a1049 5
/*									 */
/*   Function : AboutDlgProc						 */
/*									 */
/*   The function handles the servers about message box.		 */
/*									 */
d1060 3
a1062 2
	case WM_INITDIALOG:
	     break;
d1064 5
a1068 5
	case WM_COMMAND:
	     switch(wParam) {
		case IDOK :
		      EndDialog(hDlg, 0);
		      break;
d1070 2
a1071 3
		default   : return FALSE;
	     }
	     break;
d1073 5
a1077 1
	default : return FALSE;
d1084 3
a1086 3
/*								       */
/*   Function : DbgBoxProc					       */
/*								       */
d1088 2
a1089 2
/*   for modifying the debug settings of the server.		       */
/*								       */
d1100 4
a1103 4
	case WM_INITDIALOG:
	     SetDlgItemText(hDlg, IDD_FNAME, "   ");
	     Check_Current_Boxes(hDlg);
	     break;
d1105 5
a1109 6
	case WM_COMMAND:
	     switch(wParam) {
		case IDOK :
		      Update_Debug_Options(hDlg);
		      EndDialog(hDlg, 0);
		      break;
d1111 3
a1113 3
		case IDCANCEL :
		      EndDialog(hDlg, 0);
		      break;
d1115 2
a1116 23
		case  IDD_ALL	 :
		case  IDD_DEL	 :
		case  IDD_FILE	 :
		case  IDD_RAWD	 :
		case  IDD_INIT	 :
		case  IDD_DIR	 :
		case  IDD_KEYB	 :
		case  IDD_LOG	 :
		case  IDD_MESS	 :
		case  IDD_NAME	 :
		case  IDD_OPEN	 :
		case  IDD_CLOSE  :
		case  IDD_EXIT	 :
		case  IDD_READ	 :
		case  IDD_SRCH	 :
		case  IDD_TIME	 :
		case  IDD_OPRPLY :
		case  IDD_WRITE  :
		case  IDD_SCREEN :
		case  IDD_TOFILE :
			 CheckDlgButton(hDlg, wParam,
					 !IsDlgButtonChecked(hDlg, wParam));
			 break;
d1118 25
a1142 2
		case IDD_FNAME	 :
			 break;
d1144 2
a1145 3
		default   : return FALSE;
	     }
	     break;
d1147 5
a1151 1
	default : return FALSE;
a1156 1

d1159 1
a1159 1
{ 	/* Do not allow the default data segment to move !!! */
d1164 2
a1165 2
{ HANDLE	handle	= GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, size + 4);
  char		*result;
d1170 1
a1170 1
  return(&(result[4]));  
d1174 1
a1174 1
{ HANDLE	handle;	
@
