head	1.7;
access;
symbols;
locks; strict;
comment	@ * @;


1.7
date	93.10.27.14.45.24;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	93.10.20.17.03.52;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	93.10.13.17.13.01;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	93.08.22.12.09.06;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	93.08.12.14.02.23;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	92.07.29.16.13.04;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	92.06.19.09.55.54;	author bart;	state Exp;
branches;
next	;


desc
@Windows-specific component of the I/O Server
@


1.7
log
@ Fixed problems with the Timer callback walking down an uninitialised
list
@
text
@/**************************************************************************/
/**************************************************************************/
/**            Helios I/O Server Under Microsoft Windows                 **/
/**                                                                      **/
/**        Copyright (C) 1993, Perihelion Software Limited               **/
/**                      All Rights Reserved                             **/
/**                                                                      **/
/**   Graph.c (version 2)                                                **/
/**                                                                      **/
/**************************************************************************/
/**************************************************************************/

#define Graphics_Module
#include "helios.h"
#include <ddeml.h>

#include "windows\graph.h"
#include "windows\hash.h"
#include "windows\graphdef.h"

/**************************************************************************/
/**   This provides the Microsoft Windows support to the I/O server.     **/
/**   There are four groups of functions:                                **/
/**          Graph_XXXX - These are the /graphics server functions,      **/
/**                       providing the usual server functionality.      **/
/**                                                                      **/
/**          IO_XXXX    - All requests via the private protocol above    **/
/**                       specify a function number, which maps onto     **/
/**                       an IO_XXXX function.                           **/
/**                                                                      **/
/**          GraphProc  - The callback function for all window classes   **/
/**                       registered from Helios.                        **/
/**                                                                      **/
/**          all others - Private helper functions used internally       **/
/**                       and by the message loop for handling the       **/
/**                       deferred messages.                             **/
/**                                                                      **/
/**************************************************************************/

long FAR PASCAL GraphProc(HWND, unsigned, WORD, LONG);

#include "windows\graphfn.h"       /* include IO_XXXX function prototypes */


/****** Helper functions for the graphics server **************************/
PRIVATE Graphnode  *find_app_name(LPCSTR);
PRIVATE Graphnode  *create_graph_node(LPCSTR);
PRIVATE Windownode *find_window_node(HWND);
PRIVATE BOOL remove_window_node(HWND);
PRIVATE void close_windows(Windownode *);
PRIVATE void unregister_classes(Classlink *);
PRIVATE Classnode *find_class(LPCSTR);
PRIVATE BOOL remove_class(Classnode *);
PRIVATE Classnode *add_class(WNDCLASS FAR *);
PRIVATE void remove_menus(Menunode *);
PRIVATE void remove_instance(DdeInstancenode *);
PRIVATE void remove_menu_item(HMENU, UINT);
PRIVATE BOOL remove_app_servers(Graphnode *);
PRIVATE BOOL remove_app_convs(Graphnode *);
PRIVATE void marshal_params(HWND, UINT, WPARAM, LPARAM);
PRIVATE word add_msg_to_buffer(Windownode *, LPMSG);
PRIVATE void send_msg_to_port(Port, LPMSG, word);
PRIVATE void build_message_and_send(HWND, UINT, WPARAM, LPARAM);
PRIVATE void pop_mcb(void);


/* variables shared between graph.c, winsrvr.c and hash.c */
LRESULT DeferredResult;
BOOL    bExitMessageLoop;
HashTable hashWindows;         /* a hash table for created windows */

/* local global variables */

static int       open_graph = 0;
static DirHeader Graph_List;
static List      Class_List;
static List      MCB_List;

/* Graph_Routines is an array containing the addresses of the routines    */
/* providing the graphics interface. This allows us to index into the     */
/* function, speeding up the whole process. The position of each function */
/* in the array, corresponds to the message number received from the      */
/* graphics library, invoking the function. Eg. The Graphics Library on   */
/* the transputer issues the OpenGraph call with a message number of 0.   */
/* The message number is OR'ed with the private message format,           */
/* i.e. 0x60000000. The private message format is masked off, leaving the */
/* message number, which is 0.                                            */


VoidFnPtr Graph_Routines[num_routines]=
   {
     IO_RegisterPort,       IO_RegisterClass,       IO_CreateWindow,            /* 0,, */
     IO_DefWindowProc,      IO_PostQuitMessage,     IO_PostMessage,
     IO_DestroyWindow,      IO_ShowWindow,          IO_UnregisterClass,
     IO_GetWindowRect,      IO_GetClientRect,       IO_CreatePen,               /* ,10, */
     IO_CreateSolidBrush,   IO_CreateFont,          IO_SelectObject,
     IO_GetDC,              IO_ReleaseDC,           IO_BeginPaint,
     IO_EndPaint,           IO_GetStockObject,      IO_DPtoLP,                  /* ,,20 */
     IO_LPtoDP,             IO_ClientToScreen,      IO_ScreenToClient,
     IO_MoveTo,             IO_LineTo,              IO_FillRect,
     IO_TextOut,            IO_GetTextMetrics,      IO_GetTextAlign,
     IO_SetTextAlign,       IO_GetTextExtent,       IO_Ack,                     /* 30,, */
     IO_NegAck,             IO_DeleteObject,        IO_MoveWindow,
     IO_AdjustWindowRect,   IO_EnableWindow,        IO_GetActiveWindow,
     IO_GetClassLong,       IO_GetClassWord,        IO_GetDesktopWindow,        /* ,40, */
     IO_GetFocus,           IO_GetNextWindow,       IO_GetParent,
     IO_GetTopWindow,       IO_GetWindow,           IO_GetWindowLong,
     IO_GetWindowWord,      IO_IsChild,             IO_IsWindow,                /* ,,50 */
     IO_IsWindowEnabled,    IO_IsWindowVisible,     IO_SetClassLong,
     IO_SetClassWord,       IO_SetWindowLong,       IO_SetWindowWord,
     IO_SetCapture,         IO_ReleaseCapture,      IO_SetCursor,
     IO_LoadCursor,         IO_GetBkColor,          IO_GetBkMode,               /* 60,, */
     IO_GetDeviceCaps,      IO_GetMapMode,          IO_GetSystemMetrics,
     IO_GetTextColor,       IO_SetBkColor,          IO_SetBkMode,
     IO_SetMapMode,         IO_SetTextColor,        IO_Arc,                     /* ,70, */
     IO_Chord,              IO_CreateHatchBrush,    IO_CreatePatternBrush,
     IO_Ellipse,            IO_FloodFill,           IO_GetCurrentPosition,
     IO_GetNearestColor,    IO_GetPixel,            IO_GetPolyFillMode,         /* ,,80 */
     IO_GetROP2,            IO_InvalidateRect,      IO_InvertRect,
     IO_Pie,                IO_Polygon,             IO_Polyline,
     IO_Rectangle,          IO_SetPixel,            IO_SetPolyFillMode,
     IO_SetROP2,            IO_UnrealizeObject,     IO_UpdateWindow,            /* 90,, */
     IO_ValidateRect,       IO_CreatePalette,       IO_GetPaletteEntries,
     IO_GetNearestPaletteIndex, IO_RealizePalette,  IO_SelectPalette,
     IO_SetPaletteEntries,  IO_BitBlt,              IO_CreateBitmap,            /* ,100, */
     IO_CreateCompatibleBitmap, IO_CreateDIBitmap,  IO_GetBitmapBits,
     IO_GetDIBits,          IO_SetBitmapBits,       IO_SetDIBits,
     IO_SetDIBitsToDevice,  IO_CreateCompatibleDC,  IO_RegisterBuffer,          /* ,,110 */
     IO_AppendBuffer,       IO_DeleteBuffer,        IO_AppendMenu,
     IO_CheckMenuItem,      IO_CreatePopupMenu,     IO_CreateMenu,
     IO_DeleteMenu,         IO_DestroyMenu,         IO_DrawMenuBar,
     IO_EnableMenuItem,     IO_GetMenu,             IO_GetMenuItemCount,        /* 120,, */
     IO_GetMenuItemID,      IO_GetMenuState,        IO_GetMenuString,
     IO_GetSubMenu,         IO_GetSystemMenu,       IO_InsertMenu,
     IO_RemoveMenu,         IO_SetMenu,             IO_FindWindow,              /* ,130, */
     IO_RegisterIOMenu,     IO_DeleteDC,            IO_GetUpdateRect,
     IO_SendMessage,        IO_GetObject,           IO_DdeInitialize,
     IO_DdeUninitialize,    IO_DdeConnectList,      IO_DdeQueryNextServer,      /* ,,140 */
     IO_DdeDisconnectList,  IO_DdeConnect,          IO_DdeDisconnect,
     IO_DdeReconnect,       IO_DdeQueryConvInfo,    IO_DdeSetUserHandle,
     IO_DdeAbandonTransaction, IO_DdePostAdvise,    IO_DdeEnableCallback,
     IO_DdeNameService,     IO_DdeClientTransaction,IO_DdeCreateDataHandle,     /* 150,, */
     IO_DdeAddData,         IO_DdeGetData,          IO_DdeAccessData,
     IO_DdeUnaccessData,    IO_DdeFreeDataHandle,   IO_DdeGetLastError,
     IO_DdeCreateStringHandle, IO_DdeQueryString,   IO_DdeFreeStringHandle,     /* ,160, */
     IO_DdeKeepStringHandle,IO_DdeCmpStringHandles, IO_DdeReturnResult,
     IO_DdeReturnAdvise,    IO_GetBuffer,           IO_SetScrollRange,
     IO_GetScrollRange,     IO_SetScrollPos,        IO_GetScrollPos,		/* 170 */
     IO_ShowScrollBar,	    IO_EnableScrollBar
   };

/**************************************************************************/
/* This is the start of the graphics server code.  The graphics server    */
/* provides the support for the usual server protocol (opening, deleting, */
/* etc.) and the private protocol which is used to call the windows API   */
/* and private support functions (between graph.lib and the graphics      */
/* server).                                                               */
/**************************************************************************/


void Graph_Testfun(ret_code)
   bool *ret_code;
{
  *ret_code = graphics_registered;
}


void Graph_InitServer(myco)
   Conode *myco;
{
   InitList(&(Graph_List.list));  /* Initialise the linked list, containing */
   InitList(&Class_List);         /* init list of registered classes        */
   InitList(&MCB_List);
   lpfnDdeCallback = MakeProcInstance((FARPROC)DdeCallback, PROGINSTANCE);
   Graph_List.entries = 0L;       /* info on all open graphic windows       */
   SkipTimer = FALSE;
}

/* Graph_TidyServer will close down the graphics server on the PC. It closes */
/* all open graphic windows, deletes the linked list of open graphic         */
/* windows and then UnRegisters all registered classes.                      */

void Graph_TidyServer(myco)
   Conode *myco;
{ Graphnode *app, *next;

  SkipTimer = TRUE;

  /* for each app, remove the windows and unregister the classes */
  for (app = (Graphnode *) Graph_List.list.head; /* go through list of   */
       app->node.node.next ne (Node *) NULL; )   /* open graphic windows */
  {
       close_windows((Windownode *)app->window_list.head);
       unregister_classes((Classlink *)app->class_list.head);
       remove_menus((Menunode *)app->menu_list.head);
       remove_instance((DdeInstancenode *)app->dde_list.head);
       next = (Graphnode *) app->node.node.next;
       free(Remove(&(app->node.node)));             /* Delete linked   */
       app = next;
   }
   
   TidyHashTable(&hashWindows);
   FreeProcInstance(lpfnDdeCallback);
   use(myco);
}

/* Graph_Open is invoked by the standard Helios call Open, when applied to */
/* the graphics server. The function will open a new stream for either the */
/* graphics server itself, for an existing window, or for a new window. A  */
/* stream for a new graphic window is opened only if the O_Create flag is  */
/* set, and the OpenMode is specified, in the Helios Open call.            */
/*                                                                         */
/* To open a new graphic window, we first initialise a Graphnode for the   */
/* window, and add the node to the list of open graphic windows. If this   */
/* successful then we open a new stream for the window.                    */

void Graph_Open(myco)
   Conode *myco;
{
  char      *temp;
  word      openmode = mcb->Control[OpenMode_off];
  Graphnode *new_app;

  if (!strcmp(IOname, "graphics")) {      /* Stream for the server? */
     NewStream(Type_Directory, Flags_Closeable,
                (word) ((DirHeader far *) &(Graph_List)), WindowDir_Handlers);
     return;
  }

  for (temp = IOname; (*temp ne '/') && (*temp ne '\0'); temp++);

  if (*temp eq '\0') {
      Request_Return(EC_Error + SS_IOProc + EG_Name + EO_Message, 0L, 0L);
      return;
  }

  temp++;
  new_app = find_app_name(temp);   /* does the specified window exist? */
  if (new_app eq (Graphnode *) NULL) {  /* No, so stream is for a new    */
    if (openmode & O_Create) {            /* window */
          /* Initialise a Graphnode for the new window */
       if ((new_app = create_graph_node((LPCSTR) temp)) eq (Graphnode *) NULL) {
          Request_Return(EC_Error + SS_IOProc + EG_NoMemory + EO_File, 0L, 0L);
          return;
       }
       open_graph = 1;  /* If Graphnode successfully created and added to */
                        /* to the list of open graphic windows, set       */
                        /* open graph flag. This flag will be accessed in */
                        /* the open_a_graph routine.                      */

    }
    else {
      Request_Return(EC_Error + SS_IOProc + EG_Unknown + EO_File, 0L, 0L);
      return;
    }
  }

  NewStream(Type_File, Flags_Closeable + Flags_Interactive,
              (word) ((Graphnode far *) new_app), Graph_Handlers);
  use(myco);
}


/* Graph_Locate services the Helios Locate Request. */

void Graph_Locate(myco)
   Conode *myco;
{
   char      *name;
   word      temp;
   Graphnode *app;

   if (!strcmp(IOname, "graphics")) {   /* Locate the server */
      temp = FormOpenReply(Type_Directory, 0L, -1L, -1L);
      Request_Return(ReplyOK, open_reply, temp);
      return;
   }

   /* Locate request not for the server, but for a graphic window!! */

   for (name = IOname; (*name ne '/') && (*name ne '\0'); name++);

   if (*name eq '\0') {
      Request_Return(EC_Error + SS_IOProc + EG_Name + EO_Message, 0L, 0L);
      return;
   }

   name++;
   app = find_app_name(name);   /* Try to find graphic window */
   if (app ne (Graphnode *) NULL) {
      temp = FormOpenReply(Type_File, 0L, -1L, -1L);
      Request_Return(ReplyOK, open_reply, temp);
      return;
   }

   Request_Return(EC_Error + SS_IOProc + EG_Unknown + EO_File, 0L, 0L);
   use(myco);
}


/* Graph_Delete is used to delete an open graphic window. This routine is    */
/* invoked by the Graphics Library on the transputer, or can be invoked by   */
/* using the "rm" command on the Helios command line, to delete any apps     */
/* that did not terminate properly.  This will close all windows and         */
/* unregister all classes associated with that app.                          */
/*                                                                           */
/* The app can only be closed if there are no open streams associated with   */
/* it. After deleting the window, the Graphnode associated with the window   */
/* is removed from the list of open graphic windows.                         */

void Graph_Delete(myco)
   Conode *myco;
{ char      *name;
  Graphnode *app;

  if (!strcmp(IOname, "graphics")) {    /* Cannot delete the server */
     Request_Return(EC_Error + SS_IOProc + EG_InUse + EO_Server, 0L, 0L);
     return;
  }

  for (name = IOname; (*name ne '/') && (*name ne '\0'); name++);

  if (*name eq '\0') {
     Request_Return(EC_Error + SS_IOProc + EG_Name + EO_Message, 0L, 0L);
     return;
  }

  name++;
  app = find_app_name(name);

  if (app eq (Graphnode *) NULL) {  /* Does not exist!! */
    Request_Return(EC_Error + SS_IOProc + EG_Unknown +EO_File, 0L, 0L);
    return;
  }
  else {
    if (app->stream_count ne 0) {  /* can only delete if not in use */
        Request_Return(EC_Error + SS_IOProc + EG_InUse + EO_Stream, 0L, 0L);
        return;
    }

    /* first remove all windows and unregister all classes */
    close_windows((Windownode *)app->window_list.head);
    unregister_classes((Classlink *)app->class_list.head);
    remove_menus((Menunode *)app->menu_list.head);
    remove_app_convs(app);
    remove_app_servers(app);
    remove_instance((DdeInstancenode *)app->dde_list.head);

    RemoveAppHandles(&hashWindows, (void FAR *)app);

    free(Remove(&(app->node.node)));      /* remove the window from   */
    Graph_List.entries--;
    Request_Return(ReplyOK, 0L, 0L);
    return;
  }
  use(myco);
}



word Graph_InitStream(myco)
   Conode *myco;
{
   Graphnode *graph = (Graphnode *) myco->extra;

   graph->stream_count++;
   return(ReplyOK);
}


word Graph_TidyStream(myco)
   Conode *myco;
{
   Graphnode *graph = (Graphnode *) myco->extra;

   graph->stream_count--;
   return(0L);
}


/* Graph_PrivateStream intercepts a message from the transputer, generated  */
/* by the Graphics Library, masks off the Private Stream message format, to */
/* get the message number, and uses the message number to index into the    */
/* function that performs the task required by the Graphics Library. The    */
/* graphic window for which the message was intended, now becomes the       */
/* active graphic window, although the window as such is not activated in   */
/* MS-WINDOWS.                                                              */

void Graph_PrivateStream(myco)
   Conode *myco;
{
   int   mess_no;
   Graphnode *app = (Graphnode *) myco->extra;

   mess_no         = (int) mcb->MsgHdr.FnRc & 0xFFF;  /* get the message number */
   (Graph_Routines[mess_no]) (app);    /* call the desired function */
}


/* We should not get any read requests, but we set up a suitable reply anyway */

void Graph_Read(myco)
   Conode *myco;
{
   Request_Return(ReadRc_EOF, 0L, 0L);
   use(myco);
}


/* We should not get any write requests, but we set up a suitable reply */
/* anyway */

void Graph_Write(myco)
   Conode *myco;
{
   word count     = mcb->Control[WriteSize_off];
   word replyport = mcb->MsgHdr.Reply;

   mcb->Control[Reply1_off] = count;
   mcb->MsgHdr.Reply = replyport;
   Request_Return(WriteRc_Done, 1L, 0L);
   use(myco);
}


/* Graph_Close is used to close a stream associated with an open graphic */
/* window. The stream is actually a co-routine, which is destroyed by    */
/* calling seppuku.                                                      */

void Graph_Close(myco)
   Conode *myco;
{
   if (mcb->MsgHdr.Reply ne 0L)
       Request_Return(ReplyOK, 0L, 0L);

   Graph_TidyStream(myco);    /* decrement stream count */
   Graph_Delete(myco);    /* closed stream indicates a terminated program */

   Seppuku();                 /* kill off stream co-routine */
}


/* There are no strange stream attributes associated with graphic windows */
/* at present, but we may introduce some later.                           */

void Graph_GetAttr(myco)
   Conode *myco;
{
   Graphnode *graph = (Graphnode *) myco->extra;

   CopyAttributes((Attributes far *) mcb->Data,
                      (Attributes far *) &(graph->attr));
   Request_Return(ReplyOK, 0L, (word) sizeof(Attributes));
}


void Graph_SetAttr(myco)
   Conode *myco;
{
   Graphnode *graph = (Graphnode *) myco->extra;

   CopyAttributes((Attributes far *) &(graph->attr),
                          (Attributes far *) mcb->Data);
   Request_Return(ReplyOK, 0L, 0L);
}



/* Graph_ObjectInfo is used to return information about either the graphics */
/* server, or an application. For the graphics server, we return the        */
/* standard ObjInfo structure used in the I/O Server, as well as the width  */
/* and height of the screen, obtained from the GetSystemmetrics call.       */
/* The size of the message buffer in the server is also returned!.          */
/* The structure returned to the transputer is the DeviceInfo structure.    */
/*                                                                          */
/* For an application, we return the number of registered classes, the      */
/* number of open windows and the number of open streams.                   */

void Graph_ObjectInfo(myco)
   Conode *myco;
{
   DeviceInfo far *Heliosinfo = (DeviceInfo far *) mcb->Data;
   char           *name;
   Graphnode      *app;
   HDC            hDC;
   int            ct;

   Heliosinfo->obj.DirEntry.Type   = swap(Type_File);       /* standard I/O */
   Heliosinfo->obj.DirEntry.Flags  = swap(0L);              /* server return*/
   Heliosinfo->obj.DirEntry.Matrix = swap(DefFileMatrix);   /* to an        */
   Heliosinfo->obj.Account         = swap(0L);              /* ObjectInfo   */
   Heliosinfo->obj.Creation        = swap(Startup_Time);    /* request      */
   Heliosinfo->obj.Access          = swap(Startup_Time);
   Heliosinfo->obj.Modified        = swap(Startup_Time);

   if (!strcmp(IOname, "graphics")) {     /* Info on the graphics server */
      Heliosinfo->obj.DirEntry.Type   = swap(Type_Directory);
      Heliosinfo->obj.DirEntry.Matrix = swap(DefDirMatrix);
      strcpy(Heliosinfo->obj.DirEntry.Name, "graphics");
      Heliosinfo->obj.Size            = swap(0L);

#ifdef never
    /* Put in the info required by the Graphics Library*/

      Heliosinfo->info[0] = maxdata;
      Heliosinfo->info[1] = (word)PROGINSTANCE;
#endif

      Request_Return(ReplyOK, 0L, (word) sizeof(DeviceInfo));
      return;
   }

   for (name = IOname; (*name ne '/') && (name ne '\0'); name++);

   if (*name eq '\0') {
      Request_Return(EC_Error + SS_IOProc + EG_Name + EO_Message, 0L, 0L);
      return;
   }

   name++;
   app = find_app_name(name);

   if (app ne (Graphnode *) NULL) {   /* Info on open graphic windows */
      strcpy(Heliosinfo->obj.DirEntry.Name, app->node.direntry.Name);
      Heliosinfo->obj.Size = swap((word) app->stream_count);

#ifdef never
      for (ct = 2; ct < 18; ct++)
         Heliosinfo->info[ct] = 0;

      Heliosinfo->info[0] = (word)app->num_classes;
      Heliosinfo->info[1] = (word)app->num_windows;
#endif

      Request_Return(ReplyOK, 0L, (word) sizeof(DeviceInfo));
      return;
   }

   Request_Return(EC_Error + SS_IOProc + EG_Unknown + EO_File, 0L, 0L);
   use(myco);
}


/***************************************************************************/
/* TimerProc                                                               */
/*                                                                         */
/* Intercepts the timer function and sends a null message to each app.     */
/***************************************************************************/

void CALLBACK TimerProc(HWND hWnd, UINT message, UINT wParam, DWORD lParam)
{
   Graphnode *app;
   MSG msg;
   int insert;

   if (SkipTimer)
        return;

   for (app = (Graphnode *) Graph_List.list.head;   /* search through list */
        app->node.node.next ne (Node *) NULL;       /* of open graphic     */
        app = (Graphnode *) app->node.node.next)    /* windows             */
   {
        msg.hwnd = NULL;
        msg.message = WM_NULL;
        msg.wParam = WM_TIMER;
        msg.lParam = 0;

        /* add the msg to the buffer */
        insert = app->msg_head;
        memcpy(&(app->msg_buffer[insert].msg), &msg, sizeof(MSG));
        app->msg_buffer[insert].sequence_no = app->send_sequence++;
        app->msg_head = (app->msg_head + 1) % MAX_MESSAGES;

        /* now send it to the port */
        send_msg_to_port(app->msg_port, &msg, app->msg_buffer[insert].sequence_no);
   }
}



/* The following routines are the helper functions used internally and     */
/* exported for use in the message loop (deferred functions).              */


/***************************************************************************/
/* InitTable                                                               */
/*                                                                         */
/* Initialises the Hash table                                              */
/***************************************************************************/

void InitTable(void)
{
   InitHashTable(&hashWindows);
}


/***************************************************************************/
/* NotifyMenu                                                              */
/*                                                                         */
/* Purpose                                                                 */
/*      When the shell receives a menu item that is unknown, it calls this */
/*      function assuming that the application that installed a menu item  */
/*      has registered with the server.                                    */
/*                                                                         */
/* Parameters                                                              */
/*      ID - The ID of the menu item called                                */
/***************************************************************************/

void NotifyMenu(UINT ID)
{
   Graphnode *app;
   Menunode  *menunode;

   for (app = (Graphnode *) Graph_List.list.head;   /* search through list */
        app->node.node.next ne (Node *) NULL;       /* of open graphic     */
        app = (Graphnode *) app->node.node.next)    /* windows             */
   {
        for (menunode=(Menunode *)app->menu_list.head;
             menunode->node.next ne (Node *)NULL;
             menunode = (Menunode *)menunode->node.next)
        {
            if (menunode->ID eq ID)
            {
                MSG msg;
                int insert;

                msg.hwnd = NULL;
                msg.message = WM_COMMAND;
                msg.wParam = ID;
                msg.lParam = 0;

                /* add the msg to the buffer */
                insert = app->msg_head;
                memcpy(&(app->msg_buffer[insert].msg), &msg, sizeof(MSG));
                app->msg_buffer[insert].sequence_no = app->send_sequence++;
                app->msg_head = (app->msg_head + 1) % MAX_MESSAGES;

                /* now send it to the port */
                send_msg_to_port(app->msg_port, &msg, app->msg_buffer[insert].sequence_no);
                return;
            }
        }
   }
}


/***************************************************************************/
/* close_windows                                                           */
/*                                                                         */
/* Parameters:                                                             */
/*      root  - A pointer to the root of the Windownode list of windows.   */
/*                                                                         */
/* Returns                                                                 */
/*      none                                                               */
/*                                                                         */
/* Side-effects                                                            */
/*      The routine will walk the list of windows, closing them and        */
/*      freeing the space used by the node.                                */
/*                                                                         */
/***************************************************************************/

void close_windows(Windownode *root)
{
   Windownode *window, *next;
   HWND hWnd;

   for (window=root;  window->node.next ne (Node *)NULL; )
   {
        /* remove the list of deferred messages */
        next = (Windownode *)window->node.next;
        hWnd = window->hwnd;
        free(Remove(&(window->node)));
        RemoveHandle(&hashWindows, hWnd, HT_HWND);
        DestroyWindow(hWnd);
        window = next;
   }
}

/***************************************************************************/
/* unregister_classes                                                      */
/*                                                                         */
/* Parameters:                                                             */
/*      root  - A pointer to the root of the Classlink list of classes.    */
/*                                                                         */
/* Returns                                                                 */
/*      none                                                               */
/*                                                                         */
/* Side-effects                                                            */
/*      The routine will walk the list of classes and unregister them      */
/*      freeing the space used by the node.                                */
/*                                                                         */
/***************************************************************************/

void unregister_classes(Classlink *root)
{
   Classlink *class, *next;

   for (class=root;  class->node.next ne (Node *)NULL; )
   {
        /* now remove class */
        remove_class(class->class);

        next = (Classlink *) class->node.next;
        free(Remove(&(class->node)));
        class = next;
   }
}


/***************************************************************************/
/* find_class                                                              */
/*                                                                         */
/* Parameters:                                                             */
/*      name  - The name of the class to find.                             */
/*                                                                         */
/* Returns                                                                 */
/*      A pointer to the Classnode if it exists or NULL                    */
/*                                                                         */
/***************************************************************************/

Classnode *find_class(LPCSTR name)
{
   Classnode *class;
   BOOL      bNotFound = TRUE;

   for (class = (Classnode *)Class_List.head;
        (bNotFound = mystrcmp((char *)(name),
                              (char *)&(class->szClassName))) &&
        (class->node.next ne (Node *)NULL);
        class = (Classnode *)class->node.next);

   if (bNotFound)
        return (Classnode *)NULL;

   return class;
}



/***************************************************************************/
/* remove_class                                                            */
/*                                                                         */
/* Parameters:                                                             */
/*      root  - A pointer to the class to be removed.                      */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if UnregisterClass succeeds or FALSE if not                   */
/*                                                                         */
/* Side-effects                                                            */
/*      The routine decrements the usage counter, and if it is now zero    */
/*      it will unregister the class and remove the node from memory.      */
/*                                                                         */
/***************************************************************************/

BOOL remove_class(Classnode *class)
{
   BOOL bRet=TRUE;
   if ((--(class->usage)) eq 0)
   {
        bRet = UnregisterClass((LPCSTR)&(class->szClassName[0]), PROGINSTANCE);
        free(Remove(&(class->node)));
   }
   return bRet;
}



/***************************************************************************/
/* add_class                                                               */
/*                                                                         */
/*      The routine searches the list for the class name.  If found and    */
/*      some of the settings are different, the addition will fail (false  */
/*      is returned).  If the settings are the same, a pointer to that     */
/*      Classnode is returned and the usage incremented.  If not found,    */
/*      the class is registered, a Classnode structure is added and        */
/*      returned to the calling program.                                   */
/*                                                                         */
/* Parameters:                                                             */
/*      lpWc  - A pointer to the class information to add                  */
/*                                                                         */
/* Returns                                                                 */
/*      NULL if unsuccessful, otherwise a pointer to the Classnode.        */
/*                                                                         */
/***************************************************************************/

Classnode *add_class(WNDCLASS FAR *lpWc)
{
   Classnode *class;
   ATOM      atomClass;

   if ((class = find_class(lpWc->lpszClassName)) ne NULL)
   {
        /* if found */
        if ((lpWc->style eq class->style) &&
            (lpWc->cbClsExtra eq class->cbClsExtra) &&
            (lpWc->cbWndExtra eq class->cbWndExtra) &&
            (lpWc->hInstance eq class->hInstance) &&
            (lpWc->hCursor eq class->hCursor) &&
            (lpWc->hbrBackground eq class->hbrBackground))
        {
           class->usage++;
           return class;
        }

        return (Classnode *)NULL;       /* error - name already used */
   }

   /* if not found, register class, add node and return new node */
   if ((atomClass=RegisterClass(lpWc)))
   {
        class = (Classnode *)malloc(sizeof(Classnode));
        if (class eq (Classnode *)NULL)
        {
           UnregisterClass(lpWc->lpszClassName, PROGINSTANCE);
           return (Classnode *)NULL;
        }
        class->usage = 1;
        class->style = lpWc->style;
        class->cbClsExtra = lpWc->cbClsExtra;
        class->cbWndExtra = lpWc->cbWndExtra;
        class->hInstance = lpWc->hInstance;
        class->hCursor = lpWc->hCursor;
        class->hbrBackground = lpWc->hbrBackground;
        class->atomClass = atomClass;
        strcpy(&(class->szClassName[0]), lpWc->lpszClassName);

        AddTail(&(class->node), &Class_List);
        return class;
   }

   return (Classnode *)NULL;            /* error - registration failed */
}


/***************************************************************************/
/* remove_menus                                                            */
/*                                                                         */
/* Parameters:                                                             */
/*      root  - A pointer to the root of the Menunode items                */
/*                                                                         */
/* Returns                                                                 */
/*      none                                                               */
/*                                                                         */
/* Side-effects                                                            */
/*      The routine will walk the list of registered menus and remove them */
/*      from the shell menu.                                               */
/*                                                                         */
/***************************************************************************/

void remove_menus(Menunode *root)
{
   Menunode *menunode, *next;
   HWND hWnd;

   for (menunode=root;  menunode->node.next ne (Node *)NULL; )
   {
        hWnd = FindWindow(szPopupClass, NULL);
        if (hWnd ne NULL)
            remove_menu_item(GetMenu(hWnd), menunode->ID);

        next = (Menunode *) menunode->node.next;
        free(Remove(&(menunode->node)));
        menunode = next;
   }
}


/***************************************************************************/
/* remove_menu_item                                                        */
/*                                                                         */
/* Parameters:                                                             */
/*      hMenu - The menu to look in                                        */
/*      ID    - The ID of the item to remove                               */
/*                                                                         */
/* Returns                                                                 */
/*      none                                                               */
/*                                                                         */
/* Side-effects                                                            */
/*      The routine will find the I/O server shell menu and search for the */
/*      item to remove it from the menu.  If it is a popup menu, it is     */
/*      destroyed.                                                         */
/*                                                                         */
/***************************************************************************/

void remove_menu_item(HMENU hMenu, UINT ID)
{
   int  i, count;

   if (hMenu eq (HMENU)NULL)
        return;
   count = GetMenuItemCount(hMenu);
   for (i=0; i<count; i++)
   {
        UINT id = GetMenuItemID(hMenu, i);
        if (id eq -1)
            remove_menu_item(GetSubMenu(hMenu, i), ID);
        else
            if (id eq ID)
            {
                RemoveMenu(hMenu, i, MF_BYPOSITION);
                break;
            }
   }
}


/***************************************************************************/
/* add_instance                                                            */
/*                                                                         */
/* Purpose                                                                 */
/*      This adds a DdeInstancenode to the list associated with an app.    */
/*                                                                         */
/* Parameters                                                              */
/*      app     - A pointer to the application node to which the instance  */
/*                is to be added                                           */
/*      idInst  - The instance to be added                                 */
/*      port    - The port to which this instance's data is to be sent     */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL add_instance(Graphnode FAR *app, DWORD idInst, Port port)
{
   DdeInstancenode *dde=(DdeInstancenode *)malloc(sizeof(DdeInstancenode));
   if (dde eq (DdeInstancenode *)NULL)
        return FALSE;
   dde->idInst = idInst;
   dde->port = port;
   dde->app = app;
   dde->bAdviseFlag = FALSE;
   dde->nAdviseCount = 0;
   dde->nAdviseTotal = 0;
   AddTail(&(dde->node), &(app->dde_list));
   return TRUE;
}


/***************************************************************************/
/* find_instance                                                           */
/*                                                                         */
/* Purpose                                                                 */
/*      This returns the DdeInstancenode containing the instance           */
/*                                                                         */
/* Parameters                                                              */
/*      app     - A pointer to the application node                        */
/*      idInst  - The instance to search for                               */
/*                                                                         */
/* Returns                                                                 */
/*      A pointer to the instance or null if it does not exist             */
/***************************************************************************/

DdeInstancenode FAR *find_instance(Graphnode FAR *app, DWORD idInst)
{
   DdeInstancenode *dde;
   BOOL             bNotFound = TRUE;

   for (dde = (DdeInstancenode *)app->dde_list.head;
        (dde->node.next != (Node *)NULL) &&
        (bNotFound=(dde->idInst != idInst));
        dde = (DdeInstancenode *)dde->node.next);

   if (bNotFound)
       return (DdeInstancenode *)NULL;
   
   return dde;
}


/***************************************************************************/
/* delete_instance                                                         */
/*                                                                         */
/* Purpose                                                                 */
/*      This removes the instance from the app's instance list             */
/*                                                                         */
/* Parameters                                                              */
/*      app     - A pointer to the application node to which the instance  */
/*                is to be removed                                         */
/*      idInst  - The instance to be removed                               */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL delete_instance(Graphnode FAR *app, DWORD idInst)
{
   DdeInstancenode *dde = find_instance(app, idInst);

   if (dde == (DdeInstancenode *)NULL)
        return FALSE;
   free(Remove(&(dde->node)));
   return TRUE;
}


/***************************************************************************/
/* remove_instance                                                         */
/*                                                                         */
/* Parameters:                                                             */
/*      root  - A pointer to the instance to remove                        */
/***************************************************************************/

void remove_instance(DdeInstancenode *dde)
{
    DdeInstancenode *next;
    while (dde->node.next != (Node *)NULL)
    {
        next = (DdeInstancenode *)dde->node.next;
        free(Remove(&dde->node));
        dde = next;
    }
}


/***************************************************************************/
/* add_server                                                              */
/*                                                                         */
/* Purpose                                                                 */
/*      This adds an HT_DDE_SERVER entry into the hash table with an       */
/*      associated DdeInstancenode *.                                      */     
/*                                                                         */
/* Parameters                                                              */
/*      hsz     - The server string handle                                 */
/*      pInst   - The pointer to the DdeInstancenode                       */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL add_server(BIG_HANDLE hsz, DdeInstancenode FAR *pInst)
{
   AddHandle(&hashWindows, hsz, HT_DDE_SERVER, (VOID FAR *)pInst);
   return TRUE;
}


/***************************************************************************/
/* delete_server                                                           */
/*                                                                         */
/* Purpose                                                                 */
/*      This removes an HT_DDE_SERVER entry from the hash table            */
/*                                                                         */
/* Parameters                                                              */
/*      hsz     - The server string handle                                 */
/*      pInst   - The pointer to the DdeInstancenode                       */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL delete_server(BIG_HANDLE hsz, DWORD idInst)
{
   void FAR *pPos;
   DdeInstancenode *dde;
   Node *node;
   pPos = NULL;
   
   do
   {
        dde = (DdeInstancenode FAR *)GetData(&hashWindows, hsz, HT_DDE_SERVER, &pPos);
        if (idInst == dde->idInst)
        {
            node = (Node *)pPos;
            free(Remove(node->prev));
            return TRUE;
        }
   } while (pPos != NULL);

   return FALSE;
}


/***************************************************************************/
/* remove_servers                                                          */
/*                                                                         */
/* Purpose                                                                 */
/*      This removes all HT_DDE_SERVER entries that correspond with the    */
/*      indicated instance.                                                */
/*                                                                         */
/* Parameters                                                              */
/*      idInst  - The instance id to be removed                            */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL remove_servers(DWORD idInst)
{
   void FAR *pPos;
   DdeInstancenode *dde;
   Node *node;
   int i;
   
   for (i=0; i<HashTableSize; i++)
   {
        pPos = (void FAR *)hashWindows.bucket[i].head;
        while ((dde = (DdeInstancenode FAR *)GetData(&hashWindows, NULL, HT_DDE_SERVER, &pPos)) != NULL)
            if (idInst == dde->idInst)
            {
                node = (Node *)pPos;
                free(Remove(node->prev));
            }
   }

   return FALSE;
}


/***************************************************************************/
/* remove_app_servers                                                      */
/*                                                                         */
/* Purpose                                                                 */
/*      This removes all HT_DDE_SERVER entries that correspond with the    */
/*      indicated application.                                             */
/*                                                                         */
/* Parameters                                                              */
/*      app     - The pointer to the application data.                     */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL remove_app_servers(Graphnode *app)
{
   void FAR *pPos;
   DdeInstancenode *dde;
   Node *node;
   int i;
   
   for (i=0; i<HashTableSize; i++)
   {
        pPos = (void FAR *)hashWindows.bucket[i].head;
        while ((dde = (DdeInstancenode FAR *)GetData(&hashWindows, NULL, HT_DDE_SERVER, &pPos)) != NULL)
            if (app == dde->app)
            {
                node = (Node *)pPos;
                free(Remove(node->prev));
            }
   }

   return FALSE;
}


/***************************************************************************/
/* find_server                                                             */
/*                                                                         */
/* Purpose                                                                 */
/*      This returns a DdeInstancenode which is registered as the indi-    */
/*      cated server                                                       */
/*                                                                         */
/* Parameters                                                              */
/*      hsz     - The handle to search for                                 */
/*                                                                         */
/* Returns                                                                 */
/*      A pointer to the instance or null if it does not exist             */
/***************************************************************************/

DdeInstancenode FAR *find_server(BIG_HANDLE hsz)
{
   void FAR *pPos;
   pPos = NULL;

   return (DdeInstancenode FAR *)GetData(&hashWindows, hsz, HT_DDE_SERVER, &pPos);
}


/***************************************************************************/
/* add_conv                                                                */
/*                                                                         */
/* Purpose                                                                 */
/*      This adds an HT_CONV entry in the hash tables with the associated  */
/*      DdeInstancenode *.                                                 */
/*                                                                         */
/* Parameters                                                              */
/*      hConv   - The conversation handle                                  */
/*      pInst   - The pointer to the DdeInstancenode                       */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL add_conv(BIG_HANDLE hConv, DdeInstancenode FAR *pInst)
{
   DdeConvnode *conv = (DdeConvnode *)malloc(sizeof(DdeConvnode));
   if (conv == (DdeConvnode *)NULL)
       return FALSE;

   conv->dde = pInst;
   conv->bIsBlocked = FALSE;
   conv->hData = NULL;
   conv->hAdvData = NULL;
   AddHandle(&hashWindows, hConv, HT_HCONV, (VOID FAR *)conv);
   return TRUE;
}


/***************************************************************************/
/* delete_conv                                                             */
/*                                                                         */
/* Purpose                                                                 */
/*      This removes an HT_HCONV entry from the hash table                 */
/*                                                                         */
/* Parameters                                                              */
/*      hConv   - The conversation handle                                  */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL delete_conv(BIG_HANDLE hConv)
{
   void FAR *pPos;
   DdeConvnode *conv;
   Node *node;

   pPos = NULL;
   conv = (DdeConvnode *)GetData(&hashWindows, hConv, HT_HCONV, &pPos);
   if (conv != (DdeConvnode *)NULL)
   {
       node = (Node *)pPos;
       free(Remove(node->prev));
       free(conv);
       return TRUE;
   }
   return FALSE;
}


/***************************************************************************/
/* remove_convs                                                            */
/*                                                                         */
/* Purpose                                                                 */
/*      This removes all HT_HCONV entries that correspond with the         */
/*      indicated instance.                                                */
/*                                                                         */
/* Parameters                                                              */
/*      idInst  - The instance id to be removed                            */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL remove_convs(DWORD idInst)
{
   void FAR *pPos;
   DdeConvnode *conv;
   Node *node;
   int i;
   
   for (i=0; i<HashTableSize; i++)
   {
        pPos = (void FAR *)hashWindows.bucket[i].head;
        while ((conv = (DdeConvnode FAR *)GetData(&hashWindows, NULL, HT_HCONV, &pPos)) != NULL)
            if (idInst == conv->dde->idInst)
            {
                node = (Node *)pPos;
                DdeDisconnect(GetHandle((void FAR *)node->prev));
                free(Remove(node->prev));
                free(conv);
            }
   }

   return FALSE;
}


/***************************************************************************/
/* remove_app_convs                                                        */
/*                                                                         */
/* Purpose                                                                 */
/*      This removes all HT_HCONV entries that correspond with the         */
/*      indicated application.                                             */
/*                                                                         */
/* Parameters                                                              */
/*      app     - The pointer to the application data.                     */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL remove_app_convs(Graphnode *app)
{
   void FAR *pPos;
   DdeConvnode *conv;
   Node *node;
   int i;
   
   for (i=0; i<HashTableSize; i++)
   {
        pPos = (void FAR *)hashWindows.bucket[i].head;
        while ((conv = (DdeConvnode FAR *)GetData(&hashWindows, NULL, HT_HCONV, &pPos)) != NULL)
            if (app == conv->dde->app)
            {
                node = (Node *)pPos;
                DdeDisconnect(GetHandle((void FAR *)node->prev));
                free(Remove(node->prev));
                free(conv);
            }
   }

   return FALSE;
}


/***************************************************************************/
/* find_conv                                                               */
/*                                                                         */
/* Purpose                                                                 */
/*      This returns a DdeConvnode for the conversation handle             */
/*                                                                         */
/* Parameters                                                              */
/*      hConv   - The handle to search for                                 */
/*                                                                         */
/* Returns                                                                 */
/*      A pointer to the instance or null if it does not exist             */
/***************************************************************************/

DdeConvnode FAR *find_conv(BIG_HANDLE hConv)
{
   void FAR *pPos;
   pPos = NULL;

   return (DdeConvnode *)GetData(&hashWindows, hConv, HT_HCONV, &pPos);
}


/***************************************************************************/
/* find_conv_dde                                                           */
/*                                                                         */
/* Purpose                                                                 */
/*      This returns a DdeInstancenode which is registered as the indi-    */
/*      cated conversation                                                 */
/*                                                                         */
/* Parameters                                                              */
/*      hConv   - The handle to search for                                 */
/*                                                                         */
/* Returns                                                                 */
/*      A pointer to the instance or null if it does not exist             */
/***************************************************************************/

DdeInstancenode FAR *find_conv_dde(BIG_HANDLE hConv)
{
   void FAR *pPos;
   DdeConvnode *conv;
   pPos = NULL;

   conv = (DdeConvnode *)GetData(&hashWindows, hConv, HT_HCONV, &pPos);
   if (conv == NULL)
       return NULL;
   else
       return conv->dde;
}


/***************************************************************************/
/* add_pending                                                             */
/*                                                                         */
/* Purpose                                                                 */
/*      This adds a pending connection to the instance record passed to    */
/*      the routine                                                        */
/*                                                                         */
/* Parameters                                                              */
/*      pInst     - The pointer to the DdeInstancenode                     */
/*      hszServer - The server string handle                               */
/*      hszTopic  - The topic string handle                                */
/*                                                                         */
/* Returns                                                                 */
/*      TRUE if successful                                                 */
/***************************************************************************/

BOOL add_pending(BIG_HANDLE hszServer, BIG_HANDLE hszTopic, DdeInstancenode FAR *pInst)
{
   DdeServicenode *service = (DdeServicenode *)malloc(sizeof(DdeServicenode));
   if (service == (DdeServicenode *)NULL)
        return FALSE;
   service->server = hszServer;
   service->dde = pInst;
   AddHandle(&hashWindows, hszTopic, HT_DDE_SERVICE, (VOID FAR *)service);
   return TRUE;
}


/***************************************************************************/
/* find_pending                                                            */
/*                                                                         */
/* Purpose                                                                 */
/*      This finds the indicated server/topic pair and returns the         */
/*      associated instance pointer.  It also removes the service node     */
/*      of the returned pointer.                                           */
/*                                                                         */
/* Parameters                                                              */
/*      hszServer - The server string handle                               */
/*      hszTopic  - The topic string handle                                */
/*                                                                         */
/* Returns                                                                 */
/*      The DdeInstancenode * or NULL if not found                         */
/***************************************************************************/

DdeInstancenode FAR * find_pending(BIG_HANDLE hszServer, BIG_HANDLE hszTopic)
{
   void FAR *pPos;
   DdeServicenode *service;
   DdeInstancenode *dde;
   Node *node;
   pPos = NULL;
   
   do
   {
        service = (DdeServicenode FAR *)GetData(&hashWindows, hszTopic, HT_DDE_SERVICE, &pPos);
        if (hszServer == service->server)
        {
            dde = service->dde;
            node = (Node *)pPos;
            free(Remove(node->prev));
            free(service);
            return dde;
        }
   } while (pPos != NULL);

   return NULL;
}


/***************************************************************************/
/* find_window_node                                                        */
/*                                                                         */
/* Parameters :-                                                           */
/*                                                                         */
/*         handle - A MS-WINDOWS handle for an open graphic window         */
/*                                                                         */
/* Function :-                                                             */
/*      The function searches through the list of open graphic windows,    */
/*      until it finds the Windownode structure which contains the speci-  */
/*      field handle.                                                      */
/*                                                                         */
/* Returns :-                                                              */
/*      The address of the Windownode structure if the handle is found,    */
/*      NULL if the handle was not found.                                  */
/***************************************************************************/

Windownode *find_window_node(handle)
   HWND handle;
{
   void FAR *pPos;
   pPos = NULL;
   return (Windownode *)GetData(&hashWindows, handle, HT_HWND, &pPos);
}

BOOL remove_window_node(HWND hWnd)
{
   Windownode *window = find_window_node(hWnd);
   if (window ne (Windownode *)NULL)
   {
        window->app->num_windows--;
        RemoveHandle(&hashWindows, window->hwnd, HT_HWND);
        free(Remove(&(window->node)));
        return TRUE;
   }
   return FALSE;
}


/***************************************************************************/
/* find_app_name                                                           */
/*                                                                         */
/* Parameters :-                                                           */
/*                                                                         */
/*         name - Pointer to name to search for                            */
/*                                                                         */
/* Function :-                                                             */
/*      The function searches through the list of open apps to get a       */
/*      pointer to a Graphnode corresponding to that name.  It returns     */
/*      NULL if not found.                                                 */
/*                                                                         */
/* Returns :-                                                              */
/*      The address of the Graphnode structure if the handle is found,     */
/*      NULL if the handle was not found.                                  */
/***************************************************************************/

Graphnode *find_app_name(name)
   LPCSTR name;
{
   Graphnode *app;  /* address of the Graphnode structure */

   for (app = (Graphnode *) Graph_List.list.head;   /* search through list */
        app->node.node.next ne (Node *) NULL;       /* of open graphic     */
        app = (Graphnode *) app->node.node.next)    /* windows             */
   {
        if (!mystrcmp((char *)name, &(app->node.direntry.Name[0])))
           return(app);   /* return address of Graphnode structure if found */
   }

   return((Graphnode *) NULL);  /* NULL if not found */
}


/***************************************************************************/
/* create_graph_node                                                       */
/*                                                                         */
/* Parameters :-                                                           */
/*                                                                         */
/*         temp - A string containing a unique name for the graphic        */
/*                window associated with the Graphnode structure being     */
/*                created.                                                 */
/*                                                                         */
/* Function :-                                                             */
/*      The function creates a Graphnode structure, initialises the fields */
/*      of the structure, and adds the structure to the end of the list of */
/*      open graphic windows. Memory for the Graphnode structure is        */
/*      allocated from local memory.                                       */
/*                                                                         */
/* Returns :-                                                              */
/*      The address of the Graphnode structure if it was successfully      */
/*      created and added to the list, NULL if it was not.                 */
/***************************************************************************/

Graphnode *create_graph_node(name)
   LPCSTR name;
{
   Graphnode *new_app;       /* address of the created Graphnode structure */

   /* Allocate memory for the Graphnode structure. */
   new_app = (Graphnode *)malloc(sizeof(Graphnode));
   if (new_app eq NULL)
   {
      return((Graphnode *) NULL);
   }

   new_app->stream_count = 0;            /* no streams open yet   */
   new_app->msg_port = NullPort;         /* no port registered    */
   InitList(&(new_app->class_list));     /* no classes registered */
   InitList(&(new_app->window_list));    /* no windows open yet   */
   InitList(&(new_app->menu_list));
   InitList(&(new_app->dde_list));
   new_app->num_classes = 0;
   new_app->num_windows = 0;
   new_app->app_id = 0;

   new_app->msg_head = 0;
   new_app->msg_tail = 0;
   new_app->send_sequence = 0L;

   strcpy(&(new_app->node.direntry.Name[0]), name);   /* insert name of */
                                        /* window associated with structure */

   new_app->node.direntry.Type = Type_File;
   Graph_List.entries++;
   InitAttributes((Attributes far *) &(new_app->attr));
   AddTail(&(new_app->node.node), &(Graph_List.list)); /* Add to list of  */
   return(new_app);                                    /* graphic windows */
}


void unmarshal_params(HWND *hWnd, UINT *msg, WPARAM *wParam, LPARAM *lParam)
{
   *hWnd = (HWND)mcb->Control[0];
   *msg = (UINT)mcb->Control[1];
   *wParam = (WPARAM)mcb->Control[2];
   *lParam = (LPARAM)mcb->Control[3];
}


void marshal_params(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
   mcb->Control[0] = (word)hWnd;
   mcb->Control[1] = (word)msg;
   mcb->Control[2] = (word)wParam;
   mcb->Control[3] = (word)lParam;
}

void my_Request_Return(word FnRc, word CtrlSize, word DataSize)
{
   pop_mcb();
   Request_Return(ReplyOK, CtrlSize, DataSize);
}

Graphnode *get_first_app(void)
{
    return (Graphnode *)Graph_List.list.head;
}

void send_dde_to_port(Port port, UINT wType, UINT wFmt, DWORD hConv,
                DWORD hsz1, DWORD hsz2, DWORD hData, DWORD dwData1, DWORD dwData2)
{
   mcb->MsgHdr.Reply = port;
   mcb->MsgHdr.Dest = NullPort;
   mcb->MsgHdr.Flags = MsgHdr_Flags_preserve;
   mcb->Control[0] = wType;
   mcb->Control[1] = wFmt;
   mcb->Control[2] = hConv;
   mcb->Control[3] = hsz1;
   mcb->Control[4] = hsz2;
   mcb->Control[5] = hData;
   mcb->Control[6] = dwData1;
   mcb->Control[7] = dwData2;
   Request_Return(ReplyOK, 8L, 0);
}

word add_msg_to_buffer(Windownode *window, LPMSG lpMsg)
{
   Graphnode *app = window->app;
   int insert = app->msg_head;

   memcpy(&(app->msg_buffer[insert].msg), lpMsg, sizeof(MSG));
   app->msg_buffer[insert].sequence_no = app->send_sequence++;
   app->msg_head = (app->msg_head + 1) % MAX_MESSAGES;

   return app->msg_buffer[insert].sequence_no;
}

void send_msg_to_port(Port port, LPMSG lpMsg, word sequence)
{
   mcb->MsgHdr.Reply = port;
   mcb->MsgHdr.Dest = NullPort;
   mcb->MsgHdr.Flags = MsgHdr_Flags_preserve;
   mcb->Control[0] = sequence;
   mcb->Control[1] = lpMsg->hwnd;
   mcb->Control[2] = lpMsg->message;
   mcb->Control[3] = lpMsg->wParam;
   mcb->Control[4] = lpMsg->lParam;
   Request_Return(ReplyOK, 5L, 0);
}

void build_message_and_send(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
   MSG msg;
   Windownode *window = find_window_node(hWnd);

   if (window eq (Windownode *)NULL)
       return;

   msg.hwnd = hWnd;
   msg.message = iMessage;
   msg.wParam = wParam;
   msg.lParam = lParam;
   send_msg_to_port(window->app->msg_port, &msg, add_msg_to_buffer(window, &msg));
}

void push_mcb(void)
{
   MCBnode *pmcb = (MCBnode *)malloc(sizeof(MCBnode));
   memcpy(&(pmcb->mcb), mcb, sizeof(MCB));
   AddHead(&(pmcb->node), &MCB_List);
}

void pop_mcb(void)
{
   MCBnode *pmcb = (MCBnode *)MCB_List.head;
   if (pmcb->node.next != (Node *)NULL)
   {
        memcpy(mcb, &(pmcb->mcb), sizeof(MCB));
        free(Remove(&(pmcb->node)));
   }
}

/***************************************************************************/
/***************************************************************************/
/*                                                                         */
/* The following functions are to handle the function calls made from      */
/* Helios, that is the ones in graph.lib.  Most of the function names are  */
/* the same as the windows equivalent (with IO_ on the front).  This       */
/* indicates that IO_RegisterClass, for instance, provides the             */
/* RegisterClass functionality for the graphics libraries.  There are      */
/* some functions which are for internal use (between the graph.lib and    */
/* IO server), such as the IO_RegisterPort function used by the library    */
/* to register the port to which the windows messages will be sent.        */
/*                                                                         */
/***************************************************************************/
/***************************************************************************/

/* 000 */
void IO_RegisterPort(Graphnode *app)
{
	app->msg_port		= (Port)(mcb->MsgHdr.Reply);
	mcb->Control[0]		= maxdata;
	mcb->Control[1]		= (word)PROGINSTANCE;
	mcb->MsgHdr.Flags	= MsgHdr_Flags_preserve;
	Request_Return(ReplyOK, 2L, 0L);
	GraphicsDebug(("graphics (internal): RegisterPort 0x%x", app->msg_port));
}

/* 001 */
void IO_RegisterClass(Graphnode *app)
{
   WNDCLASS wc;
   Classnode *class;

   if (mcb->Data[0] eq '\0')
   {
        /* error in class name */
        mcb->Control[0] = (word)NULL;
        Request_Return(ReplyOK, 1L, 0L);
        return;
   }

   wc.style = (UINT)(mcb->Control[0]);
   wc.lpfnWndProc = (WNDPROC)GraphProc;
   wc.cbClsExtra = (int)(mcb->Control[1]);
   wc.cbWndExtra = (int)(mcb->Control[2]);
   wc.hInstance = (HINSTANCE)(mcb->Control[3]);
   wc.hIcon = LoadIcon(PROGINSTANCE, "graphicon");
   wc.hCursor = (HCURSOR)(mcb->Control[4]);
   wc.hbrBackground = (HBRUSH)(mcb->Control[5]);
   wc.lpszMenuName = NULL;
   wc.lpszClassName = (LPCSTR)&(mcb->Data[0]);

   push_mcb();
   if ((class = add_class(&wc)) ne (Classnode *)NULL)
   {
        /* class creation OKAY, so add a link to it */
        Classlink *link = (Classlink *)malloc(sizeof(Classlink));
        if (link eq (Classlink *)NULL)
        {
          remove_class(class);
          mcb->Control[0] = (word)NULL;
          my_Request_Return(ReplyOK, 1L, 0L);
          return;
        }
        link->class = class;
        Addtail(&(link->node), &(app->class_list));
        mcb->Control[0] = (word)class->atomClass;
        GraphicsDebug(("RegisterClass succeeded: '%s'", wc.lpszClassName));
        my_Request_Return(ReplyOK, 1L, 0L);
        return;
   }

   mcb->Control[0] = (word)NULL;
   GraphicsDebug(("RegisterClass failed: '%s'", wc.lpszClassName));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 002 */
void IO_CreateWindow(Graphnode *app)
{
   Classnode *class;
   /* get parameters from control and data blocks */
   DWORD dwStyle = (DWORD)mcb->Control[0];
   int   x = (int)mcb->Control[1],
         y = (int)mcb->Control[2],
         width = (int)mcb->Control[3],
         height = (int)mcb->Control[4];
   HWND  hwndParent = (HWND)mcb->Control[5];
   HMENU hMenu = (HMENU)mcb->Control[6];
   HINSTANCE hInst = (HINSTANCE)mcb->Control[7];
   LPCSTR lpszClassName, lpszWindowName;
   HWND  hWnd;

   lpszClassName = (LPCSTR)&(mcb->Data[0]);
   push_mcb();
   class = find_class(lpszClassName);

   /* find start of window name string in the control block */
   for (lpszWindowName = lpszClassName; *lpszWindowName ne '\0'; lpszWindowName++);
   lpszWindowName++;

   GraphicsDebug(("CreateWindow(,,0x%lx,%d,%d,%d,%d,0x%x,0x%x,0x%x)",
        dwStyle, x, y, width, height, hwndParent, hMenu, hInst));

   hWnd = CreateWindow(lpszClassName, lpszWindowName, dwStyle,
                       x, y, width, height, hwndParent, hMenu, hInst, NULL);
   if (hWnd ne NULL)
   {
        if (class ne (Classnode *)NULL)
        {
            /* make a new Windownode if one of our classes (not "button" etc) */
            Windownode *window = (Windownode *)malloc(sizeof(Windownode));
            if (window eq (Windownode *)NULL)
            {
                DestroyWindow(hWnd);
                mcb->Control[0] = (word)NULL;
                my_Request_Return(ReplyOK, 1L, 0L);
                return;
            }
            window->num = 0;
            window->hwnd = hWnd;
            window->class = class;
            window->app = app;
            window->rectInvalid.left = 0;
            window->rectInvalid.top = 0;
            window->rectInvalid.right = 0;
            window->rectInvalid.bottom = 0;
            app->num_windows++;
            AddHandle(&hashWindows, hWnd, HT_HWND, (VOID FAR *)window);
            AddTail(&(window->node), &(app->window_list));
            SendMessage(hWnd, WM_CREATE, 0, 0L);
        }
        mcb->Control[0] = (word)hWnd;
        GraphicsDebug(("CreateWindow succeeded: '%s','%s' HWND=0x%x", lpszClassName, lpszWindowName, hWnd));
        my_Request_Return(ReplyOK, 1L, 0L);
        return;
   }
   mcb->Control[0] = (word)NULL;
   GraphicsDebug(("CreateWindow failed: '%s','%s'", lpszClassName, lpszWindowName));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 003 */
void IO_DefWindowProc(Graphnode *app)
{
   HWND   hWnd;
   UINT   message;
   WPARAM wParam;
   LPARAM lParam;
   LRESULT ret;

   unmarshal_params(&hWnd, &message, &wParam, &lParam);

   /* call function and supply function return as reply */
   push_mcb();
   ret = DefWindowProc(hWnd, message, wParam, lParam);
   mcb->Control[0] = ret;
   GraphicsDebug(("DefWindowProc(0x%x,0x%x,0x%x,0x%lx) = %x", hWnd, message, wParam, lParam, ret));
   my_Request_Return(ReplyOK, 1L, 0L);
}


/* 004 */
void IO_PostQuitMessage(Graphnode *app)
{
    /* defunct message - handled on Helios side */
}


/* 005 */
void IO_PostMessage(Graphnode *app)
{
   HWND   hWnd;
   UINT   msg;
   WPARAM wParam;
   LPARAM lParam;
   LRESULT ret;

   unmarshal_params(&hWnd, &msg, &wParam, &lParam);
   push_mcb();

   /* we may need to trap some other messages here, so that they are not */
   /* posted but handled in some other way.                              */

   /* else send via usual PostMessage */
   ret = PostMessage(hWnd, msg, wParam, lParam);
   mcb->Control[0] = ret;
   GraphicsDebug(("PostMessage(0x%x,0x%x,0x%x,0x%lx) = 0x%x", hWnd, msg, wParam, lParam, ret));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 006 */
void IO_DestroyWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   LRESULT ret;

   push_mcb();
   ret = DestroyWindow(hWnd);
   mcb->Control[0] = (word)ret;
   GraphicsDebug(("DestroyWindow(0x%x) = 0x%x", hWnd, ret));
   my_Request_Return(ReplyOK, 1L, 0L);
}


/* 007 */
void IO_ShowWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int  nCmdShow = (int)mcb->Control[1];
   LRESULT ret;

   push_mcb();
   ret = (word)ShowWindow(hWnd, nCmdShow);
   mcb->Control[0] = (word)ret;
   GraphicsDebug(("ShowWindow(0x%x,0x%x) = 0x%x", hWnd, nCmdShow, ret));
   my_Request_Return(ReplyOK, 1L, 0L);
}


/* 008 */
void IO_UnregisterClass(Graphnode *app)
{
   HINSTANCE hInst = (HINSTANCE)mcb->Control[0];
   LPCSTR lpszClassName = (LPCSTR)&(mcb->Data[0]);
   Classnode *class = find_class(lpszClassName);
   BOOL bRet;

   push_mcb();
   if (class eq (Classnode *)NULL)
        bRet = FALSE;
   else
   {
        /* we have our class, so find classlink pointing to it & remove */
        Classlink *link;
        for (link = (Classlink *)app->class_list.head;
                   (class != link->class) &&
                   (link->node.next ne (Node *) NULL);
                   link = (Classlink *) link->node.next);
        if (class == link->class)
        {
            free(Remove(&(link->node)));
            bRet = remove_class(class);
        }
        else
            bRet = FALSE;
   }
   mcb->Control[0] = (word)bRet;
   GraphicsDebug(("UnregisterClass(0x%x,%s) = 0x%x", hInst, lpszClassName, bRet));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 009 */
void IO_GetWindowRect(Graphnode *app)
{
   HWND hWnd = mcb->Control[0];
   RECT rect;
   push_mcb();
   GetWindowRect(hWnd, &rect);
   memcpy(&mcb->Data[0], &rect, sizeof(RECT));
   GraphicsDebug(("GetWindowRect(0x%x) = (%d,%d,%d,%d)", hWnd, rect.left,
                 rect.top, rect.right, rect.bottom));
   my_Request_Return(ReplyOK, 0L, sizeof(RECT));
}

/* 010 */
void IO_GetClientRect(Graphnode *app)
{
   HWND hWnd = mcb->Control[0];
   RECT rect;
   push_mcb();
   GetClientRect(hWnd, &rect);
   memcpy(&mcb->Data[0], &rect, sizeof(RECT));
   GraphicsDebug(("GetClientRect(0x%x) = (%d,%d,%d,%d)", hWnd, rect.left,
                 rect.top, rect.right, rect.bottom));
   my_Request_Return(ReplyOK, 0L, sizeof(RECT));
}

/* 011 */
void IO_CreatePen(Graphnode *app)
{
   int style = (int)mcb->Control[0];
   int width = (int)mcb->Control[1];
   COLORREF color = (COLORREF)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)CreatePen(style, width, color);
   GraphicsDebug(("CreatePen(0x%x,%d,0x%08lx) = 0x%x", style, width, color, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HPEN, app);
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 012 */
void IO_CreateSolidBrush(Graphnode *app)
{
   COLORREF color = (COLORREF)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)CreateSolidBrush(color);
   GraphicsDebug(("CreateSolidBrush(0x%08lx) = 0x%x", color, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HBRUSH, app);
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 013 */
void IO_CreateFont(Graphnode *app)
{
   int height = (int)mcb->Control[0];
   int width = (int)mcb->Control[1];
   int escape = (int)mcb->Control[2];
   int orientation = (int)mcb->Control[3];
   int weight = (int)mcb->Control[4];
   BYTE italic = mcb->Data[0];
   BYTE underline = mcb->Data[1];
   BYTE strikeout = mcb->Data[2];
   BYTE charset = mcb->Data[3];
   BYTE precision = mcb->Data[4];
   BYTE clipprecision = mcb->Data[5];
   BYTE quality = mcb->Data[6];
   BYTE pitch = mcb->Data[7];
   LPCSTR lpszFace = &mcb->Data[8];
   push_mcb();

   mcb->Control[0] = (word)CreateFont(height, width, escape, orientation, weight,
                                italic, underline, strikeout, charset,
                                precision, clipprecision, quality, pitch,
                                lpszFace);
   GraphicsDebug(("CreateFont(...) = 0x%x", mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HFONT, app);
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 014 */
void IO_SelectObject(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   HGDIOBJ obj = (HGDIOBJ)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)SelectObject(hDC, obj);
   GraphicsDebug(("SelectObject(0x%x,0x%x) = 0x%x", hDC, obj, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 015 */
void IO_GetDC(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetDC(hWnd);
   GraphicsDebug(("GetDC(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 016 */
void IO_ReleaseDC(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   HDC  hDC  = (HDC)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)ReleaseDC(hWnd, hDC);
   GraphicsDebug(("ReleaseDC(0x%x,0x%x) = 0x%x", hWnd, hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 017 */
void IO_BeginPaint(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   Windownode *window = find_window_node(hWnd);
   PAINTSTRUCT FAR *lpps = (PAINTSTRUCT FAR *)&mcb->Data[0];
   push_mcb();
   if (window != (Windownode *)NULL)
        InvalidateRect(hWnd, &window->rectInvalid, FALSE);
   mcb->Control[0] = (word)BeginPaint(hWnd, lpps);
   GraphicsDebug(("BeginPaint(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, sizeof(PAINTSTRUCT));
}

/* 018 */
void IO_EndPaint(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   Windownode *window = find_window_node(hWnd);
   PAINTSTRUCT FAR *lpps = (PAINTSTRUCT FAR *)&mcb->Data[0];
   push_mcb();
   EndPaint(hWnd, lpps);
   if (window ne (Windownode *)NULL)
   {
        window->rectInvalid.left = 0;
        window->rectInvalid.top = 0;
        window->rectInvalid.right = 0;
        window->rectInvalid.bottom = 0;
   }
   GraphicsDebug(("EndPaint(0x%x)", hWnd));
   my_Request_Return(ReplyOK, 0L, 0L);
}

/* 019 */
void IO_GetStockObject(Graphnode *app)
{
   int obj_no = (int)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetStockObject(obj_no);
   GraphicsDebug(("GetStockObject(%d) = 0x%x", obj_no, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 020 */
void IO_DPtoLP(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int pnts = (int)mcb->Control[1];
   LPPOINT lppt = (LPPOINT)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = DPtoLP(hDC, lppt, pnts);
   my_Request_Return(ReplyOK, 1L, sizeof(POINT)*pnts);
}

/* 021 */
void IO_LPtoDP(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int pnts = (int)mcb->Control[1];
   LPPOINT lppt = (LPPOINT)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = LPtoDP(hDC, lppt, pnts);
   my_Request_Return(ReplyOK, 1L, sizeof(POINT)*pnts);
}

/* 022 */
void IO_ClientToScreen(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   LPPOINT lppt = (LPPOINT)&mcb->Data[0];
   push_mcb();
   ClientToScreen(hWnd, lppt);
   my_Request_Return(ReplyOK, 0L, sizeof(POINT));
}

/* 023 */
void IO_ScreenToClient(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   LPPOINT lppt = (LPPOINT)&mcb->Data[0];
   push_mcb();
   ScreenToClient(hWnd, lppt);
   my_Request_Return(ReplyOK, 0L, sizeof(POINT));
}

/* 024 */
void IO_MoveTo(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int x   = (int)mcb->Control[1];
   int y   = (int)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = MoveTo(hDC, x, y);
   GraphicsDebug(("MoveTo(0x%x,%d,%d) = 0x%x", hDC, x, y, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 025 */
void IO_LineTo(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int x   = (int)mcb->Control[1];
   int y   = (int)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = LineTo(hDC, x, y);
   GraphicsDebug(("LineTo(0x%x,%d,%d) = 0x%x", hDC, x, y, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 026 */
void IO_FillRect(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   HBRUSH hbr = (HBRUSH)mcb->Control[1];
   LPRECT lprt = (LPRECT)&mcb->Data[0];
   push_mcb();
   FillRect(hDC, lprt, hbr);
   GraphicsDebug(("FillRect(0x%x,0x%x,(%d,%d,%d,%d))", hDC, hbr, lprt->left,
                lprt->top, lprt->right, lprt->bottom));
   my_Request_Return(ReplyOK, 0L, 0L);
}

/* 027 */
void IO_TextOut(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int xStart = (int)mcb->Control[1];
   int yStart = (int)mcb->Control[2];
   int cb = (int)mcb->Control[3];
   LPCSTR lpszString = (LPCSTR)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = TextOut(hDC, xStart, yStart, lpszString, cb);
   GraphicsDebug(("TextOut(0x%x,%d,%d,%d,%s) = %d", hDC, xStart, yStart,
                cb, lpszString, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 028 */
void IO_GetTextMetrics(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   TEXTMETRIC FAR *lptm = (TEXTMETRIC FAR *)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = GetTextMetrics(hDC, lptm);
   GraphicsDebug(("GetTextMetrics(0x%x) = 0x%x", hDC, mcb->Control[0]));

   /* I must move the data so that it is word aligned for helios */
   memmove(&mcb->Data[26], &mcb->Data[25], 6);
   my_Request_Return(ReplyOK, 1L, sizeof(TEXTMETRIC)+1);
}

/* 029 */
void IO_GetTextAlign(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = GetTextAlign(hDC);
   GraphicsDebug(("GetTextAlign(0x%x) = 0x%x", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 030 */
void IO_SetTextAlign(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   UINT align = (UINT)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = SetTextAlign(hDC, align);
   GraphicsDebug(("SetTextAlign(0x%x,0x%x) = 0x%x", hDC, align, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 031 */
void IO_GetTextExtent(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int cb = (int)mcb->Control[1];
   LPCSTR lpszString = (LPCSTR)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = GetTextExtent(hDC, lpszString, cb);
   GraphicsDebug(("GetTextExtent(0x%x,%d,%s) = 0x%x", hDC, cb, lpszString, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1L, 0L);
}

/* 032 */
void IO_Ack(Graphnode *app)
{
   word AckNo = mcb->Control[0];
   int *msg_tail = &app->msg_tail;
   int *msg_head = &app->msg_head;
   MSGnode *msg_buffer = &app->msg_buffer[0];

   Request_Return(ReplyOK, 0L, 0L);

   GraphicsDebug(("(internal) Ack WM_ message 0x%08lx", AckNo));

   while ((*msg_tail ne *msg_head) &&
          (AckNo >= msg_buffer[*msg_tail].sequence_no))
        *msg_tail = (*msg_tail + 1) % MAX_MESSAGES;
}

/* 033 */
void IO_NegAck(Graphnode *app)
{
   word NegAckNo = mcb->Control[0];
   int i;
   int *msg_tail = &app->msg_tail;
   int *msg_head = &app->msg_head;
   MSGnode *msg_buffer = &app->msg_buffer[0];

   Request_Return(ReplyOK, 0L, 0L);

   GraphicsDebug(("(internal) NegAck WM_ message 0x%08lx", NegAckNo));

   /* first ack to 1 less than negack */
   while ((*msg_tail ne *msg_head) &&
          (NegAckNo > msg_buffer[*msg_tail].sequence_no))
        *msg_tail = (*msg_tail + 1) % MAX_MESSAGES;

   /* now resend the rest */
   for (i=*msg_tail; i<*msg_head; i++)
       send_msg_to_port(app->msg_port, &(msg_buffer[i].msg), msg_buffer[i].sequence_no);
}

/* 034 */
void IO_DeleteObject(Graphnode *app)
{
   HGDIOBJ hObject = (HGDIOBJ)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = DeleteObject(hObject);
   GraphicsDebug(("DeleteObject(0x%x) = 0x%x", hObject, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       RemoveHandleApp(&hashWindows, hObject, (void FAR *)app);
   my_Request_Return(ReplyOK, 1, 0);
}


/* 035 */
void IO_MoveWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int x = (int)mcb->Control[1];
   int y = (int)mcb->Control[2];
   int width = (int)mcb->Control[3];
   int height = (int)mcb->Control[4];
   BOOL bRepaint = (BOOL)mcb->Control[5];
   push_mcb();
   mcb->Control[0] = MoveWindow(hWnd, x, y, width, height, bRepaint);
   GraphicsDebug(("MoveWindow(0x%x,%d,%d,%d,%d,%d) = 0x%x", hWnd, x, y, width, height, bRepaint, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}


/* 036 */
void IO_AdjustWindowRect(Graphnode *app)
{
   LONG dwStyle = (LONG)mcb->Control[0];
   BOOL bMenu = (BOOL)mcb->Control[1];
   LPRECT lprc = (LPRECT)&mcb->Data[0];
   push_mcb();
   AdjustWindowRect(lprc, dwStyle, bMenu);
   GraphicsDebug(("AdjustWindowRect(0x%x,0x%x)", dwStyle, bMenu));
   my_Request_Return(ReplyOK, 0, sizeof(RECT));
}

/* 037 */
void IO_EnableWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   BOOL bEnable = (BOOL)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)EnableWindow(hWnd, bEnable);
   GraphicsDebug(("EnableWindow(0x%x,0x%x) = 0x%x", hWnd, bEnable, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 038 */
void IO_GetActiveWindow(Graphnode *app)
{
   push_mcb();
   mcb->Control[0] = (word)GetActiveWindow();
   GraphicsDebug(("GetActiveWindow() = 0x%x", mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 039 */
void IO_GetClassLong(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetClassLong(hWnd, offset);
   GraphicsDebug(("GetClassLong(0x%x,%d) = 0x%lx", hWnd, offset, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 040 */
void IO_GetClassWord(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetClassWord(hWnd, offset);
   GraphicsDebug(("GetClassWord(0x%x,%d) = 0x%x", hWnd, offset, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 041 */
void IO_GetDesktopWindow(Graphnode *app)
{
   push_mcb();
   mcb->Control[0] = (word)GetDesktopWindow();
   GraphicsDebug(("GetDesktopWindow() = 0x%x", mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 042 */
void IO_GetFocus(Graphnode *app)
{
   push_mcb();
   mcb->Control[0] = (word)GetFocus();
   GraphicsDebug(("GetFocus() = 0x%x", mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 043 */
void IO_GetNextWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   UINT uFlags = (UINT)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetNextWindow(hWnd, uFlags);
   GraphicsDebug(("GetNextWindow(0x%x,0x%x) = 0x%x", hWnd, uFlags, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 044 */
void IO_GetParent(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetParent(hWnd);
   GraphicsDebug(("GetParent(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 045 */
void IO_GetTopWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetTopWindow(hWnd);
   GraphicsDebug(("GetTopWindow(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 046 */
void IO_GetWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   UINT uRel = (UINT)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetWindow(hWnd, uRel);
   GraphicsDebug(("GetWindow(0x%x,0x%x) = 0x%x", hWnd, uRel, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 047 */
void IO_GetWindowLong(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetWindowLong(hWnd, offset);
   GraphicsDebug(("GetWindowLong(0x%x,%d) = 0x%lx", hWnd, offset, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 048 */
void IO_GetWindowWord(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetWindowWord(hWnd, offset);
   GraphicsDebug(("GetWindowWord(0x%x,%d) = 0x%x", hWnd, offset, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 049 */
void IO_IsChild(Graphnode *app)
{
   HWND hParent = (HWND)mcb->Control[0];
   HWND hChild = (HWND)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)IsChild(hParent, hChild);
   GraphicsDebug(("IsChild(0x%x,0x%x) = 0x%x", hParent, hChild, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 050 */
void IO_IsWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)IsWindow(hWnd);
   GraphicsDebug(("IsWindow(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 051 */
void IO_IsWindowEnabled(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)IsWindowEnabled(hWnd);
   GraphicsDebug(("IsWindowEnabled(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 052 */
void IO_IsWindowVisible(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)IsWindowVisible(hWnd);
   GraphicsDebug(("IsWindowVisible(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 053 */
void IO_SetClassLong(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   LONG value = (LONG)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)SetClassLong(hWnd, offset, value);
   GraphicsDebug(("SetClassLong(0x%x,%d,0x%lx) = 0x%x", hWnd, offset, value, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 054 */
void IO_SetClassWord(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   WORD value = (WORD)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)SetClassWord(hWnd, offset, value);
   GraphicsDebug(("SetClassWord(0x%x,%d,0x%x) = 0x%x", hWnd, offset, value, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 055 */
void IO_SetWindowLong(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   LONG value = (LONG)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)SetWindowLong(hWnd, offset, value);
   GraphicsDebug(("SetWindowLong(0x%x,%d,0x%lx) = 0x%x", hWnd, offset, value, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 056 */
void IO_SetWindowWord(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   WORD value = (WORD)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)SetWindowWord(hWnd, offset, value);
   GraphicsDebug(("SetWindowWord(0x%x,%d,0x%x) = 0x%x", hWnd, offset, value, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 057 */
void IO_SetCapture(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)SetCapture(hWnd);
   GraphicsDebug(("SetCapture(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 058 */
void IO_ReleaseCapture(Graphnode *app)
{
   push_mcb();
   ReleaseCapture();
   GraphicsDebug(("ReleaseCapture() = 0x%x", mcb->Control[0]));
   my_Request_Return(ReplyOK, 0, 0);
}

/* 059 */
void IO_SetCursor(Graphnode *app)
{
   HCURSOR hCursor = (HCURSOR)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)SetCursor(hCursor);
   GraphicsDebug(("SetCursor(0x%x) = 0x%x", hCursor, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 060 */
void IO_LoadCursor(Graphnode *app)
{
   LPCSTR lpszName = (LPCSTR)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = LoadCursor(NULL, lpszName);
   GraphicsDebug(("LoadCursor(NULL, 0x%x) = 0x%x", lpszName, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 061 */
void IO_GetBkColor(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = GetBkColor(hDC);
   GraphicsDebug(("GetBkColor(0x%x) = 0x%08lx", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 062 */
void IO_GetBkMode(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = GetBkMode(hDC);
   GraphicsDebug(("GetBkMode(0x%x) = 0x%x", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 063 */
void IO_GetDeviceCaps(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int index = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetDeviceCaps(hDC, index);
   GraphicsDebug(("GetDeviceCaps(0x%x,%d) = 0x%x", hDC, index, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 064 */
void IO_GetMapMode(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = GetMapMode(hDC);
   GraphicsDebug(("GetMapMode(0x%x) = 0x%x", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 065 */
void IO_GetSystemMetrics(Graphnode *app)
{
   int index = (int)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetSystemMetrics(index);
   GraphicsDebug(("GetSystemMetrics(0x%x) = 0x%x", index, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 066 */
void IO_GetTextColor(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = GetTextColor(hDC);
   GraphicsDebug(("GetTextColor(0x%x) = 0x%08lx", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 067 */
void IO_SetBkColor(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   COLORREF cr = (COLORREF)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = SetBkColor(hDC, cr);
   GraphicsDebug(("SetBkColor(0x%x,0x%08lx) = 0x%x", hDC, cr, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 068 */
void IO_SetBkMode(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int mode = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = SetBkMode(hDC, mode);
   GraphicsDebug(("SetBkMode(0x%x,0x%x) = 0x%x", hDC, mode, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 069 */
void IO_SetMapMode(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int mode = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = SetMapMode(hDC, mode);
   GraphicsDebug(("SetMapMode(0x%x,0x%x) = 0x%x", hDC, mode, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 070 */
void IO_SetTextColor(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   COLORREF cr = (COLORREF)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = SetTextColor(hDC, cr);
   GraphicsDebug(("SetTextColor(0x%x,0x%08lx) = 0x%x", hDC, cr, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 071 */
void IO_Arc(Graphnode *app)
{
   HDC hDC       = (HDC)mcb->Control[0];
   int nLeft     = (int)mcb->Control[1];
   int nTop      = (int)mcb->Control[2];
   int nRight    = (int)mcb->Control[3];
   int nBottom   = (int)mcb->Control[4];
   int XStartArc = (int)mcb->Control[5];
   int YStartArc = (int)mcb->Control[6];
   int XEndArc   = (int)mcb->Control[7];
   int YEndArc   = (int)mcb->Control[8];
   push_mcb();
   mcb->Control[0] = Arc(hDC, nLeft, nTop, nRight, nBottom,
                         XStartArc, YStartArc, XEndArc, YEndArc);
   GraphicsDebug(("Arc(0x%x,%d,%d,%d,%d,%d,%d,%d,%d) = 0x%x", hDC, nLeft, nTop, 
        nRight, nBottom, XStartArc, YStartArc, XEndArc, YEndArc, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 072 */
void IO_Chord(Graphnode *app)
{
   HDC hDC        = (HDC)mcb->Control[0];
   int nLeft      = (int)mcb->Control[1];
   int nTop       = (int)mcb->Control[2];
   int nRight     = (int)mcb->Control[3];
   int nBottom    = (int)mcb->Control[4];
   int XStartLine = (int)mcb->Control[5];
   int YStartLine = (int)mcb->Control[6];
   int XEndLine   = (int)mcb->Control[7];
   int YEndLine   = (int)mcb->Control[8];
   push_mcb();
   mcb->Control[0] = Chord(hDC, nLeft, nTop, nRight, nBottom,
                           XStartLine, YStartLine, XEndLine, YEndLine);
   GraphicsDebug(("Chord(0x%x,%d,%d,%d,%d,%d,%d,%d,%d) = 0x%x", hDC, nLeft, nTop, 
        nRight, nBottom, XStartLine, YStartLine, XEndLine, YEndLine, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 073 */
void IO_CreateHatchBrush(Graphnode *app)
{
   int style = (int)mcb->Control[0];
   COLORREF cr = (COLORREF)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = CreateHatchBrush(style, cr);
   GraphicsDebug(("CreateHatchBrush(0x%x,0x%08lx) = 0x%x", style, cr, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HBRUSH, app);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 074 */
void IO_CreatePatternBrush(Graphnode *app)
{
   HBITMAP hBitmap = (HBITMAP)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = CreatePatternBrush(hBitmap);
   GraphicsDebug(("CreatePatternBrush(0x%x) = 0x%x", hBitmap, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HBRUSH, app);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 075 */
void IO_Ellipse(Graphnode *app)
{
   HDC hDC     = (HDC)mcb->Control[0];
   int nLeft   = (int)mcb->Control[1];
   int nTop    = (int)mcb->Control[2];
   int nRight  = (int)mcb->Control[3];
   int nBottom = (int)mcb->Control[4];
   push_mcb();
   mcb->Control[0] = Ellipse(hDC, nLeft, nTop, nRight, nBottom);
   GraphicsDebug(("Ellipse(0x%x,%d,%d,%d,%d) = 0x%x", hDC, nLeft, nTop, nRight, nBottom, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 076 */
void IO_FloodFill(Graphnode *app)
{
   HDC hDC     = (HDC)mcb->Control[0];
   int X       = (int)mcb->Control[1];
   int Y       = (int)mcb->Control[2];
   COLORREF cr = (COLORREF)mcb->Control[3];
   push_mcb();
   mcb->Control[0] = FloodFill(hDC, X, Y, cr);
   GraphicsDebug(("FloodFill(0x%x,%d,%d,0x%08lx) = 0x%x", hDC, X, Y, cr, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 077 */
void IO_GetCurrentPosition(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetCurrentPosition(hDC);
   GraphicsDebug(("GetCurrentPosition(0x%x) = 0x%x", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 078 */
void IO_GetNearestColor(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   COLORREF cr = (COLORREF)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetNearestColor(hDC, cr);
   GraphicsDebug(("GetNearestColor(0x%x,0x%08lx) = 0x%08lx", hDC, cr, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 079 */
void IO_GetPixel(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int X   = (int)mcb->Control[1];
   int Y   = (int)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)GetPixel(hDC, X, Y);
   GraphicsDebug(("GetPixel(0x%x,%d,%d) = 0x%08lx", hDC, X, Y, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 080 */
void IO_GetPolyFillMode(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetPolyFillMode(hDC);
   GraphicsDebug(("GetPolyFillMode(0x%x) = 0x%x", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 081 */
void IO_GetROP2(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetROP2(hDC);
   GraphicsDebug(("GetROP2(0x%x) = 0x%x", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 082 */
void IO_InvalidateRect(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   BOOL bErase = (BOOL)mcb->Control[1];
   LPRECT lprc;
   push_mcb();
   if (mcb->MsgHdr.DataSize eq 1)
       lprc = NULL;
   else
       lprc = (LPRECT)&mcb->Data[0];
   InvalidateRect(hWnd, lprc, bErase);
   if (mcb->MsgHdr.DataSize eq 1)
       GraphicsDebug(("InvalidateRect(0x%x,NULL,0x%x) = 0x%x", hWnd, bErase, 
                mcb->Control[0]));
   else
       GraphicsDebug(("InvalidateRect(0x%x,(%d,%d,%d,%d),0x%x) = 0x%x", hWnd, 
                lprc->left, lprc->top, lprc->right, lprc->bottom, bErase, mcb->Control[0]));
   my_Request_Return(ReplyOK, 0, 0);
}

/* 083 */
void IO_InvertRect(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   LPRECT lprc = (LPRECT)&mcb->Data[0];
   push_mcb();
   InvertRect(hWnd, lprc);
   GraphicsDebug(("InvertRect(0x%x,(%d,%d,%d,%d)) = 0x%x", hWnd, 
        lprc->left, lprc->top, lprc->right, lprc->bottom, mcb->Control[0]));
   my_Request_Return(ReplyOK, 0, 0);
}

/* 084 */
void IO_Pie(Graphnode *app)
{
   HDC hDC       = (HDC)mcb->Control[0];
   int nLeft     = (int)mcb->Control[1];
   int nTop      = (int)mcb->Control[2];
   int nRight    = (int)mcb->Control[3];
   int nBottom   = (int)mcb->Control[4];
   int XStartArc = (int)mcb->Control[5];
   int YStartArc = (int)mcb->Control[6];
   int XEndArc   = (int)mcb->Control[7];
   int YEndArc   = (int)mcb->Control[8];
   push_mcb();
   mcb->Control[0] = Pie(hDC, nLeft, nTop, nRight, nBottom,
                         XStartArc, YStartArc, XEndArc, YEndArc);
   GraphicsDebug(("Pie(0x%x,%d,%d,%d,%d,%d,%d,%d,%d) = 0x%x", hDC, nLeft, nTop, 
        nRight, nBottom, XStartArc, YStartArc, XEndArc, YEndArc, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 085 */
void IO_Polygon(Graphnode *app)
{
   HDC     hDC     = (HDC)mcb->Control[0];
   HGLOBAL hBuffer = (HGLOBAL)mcb->Control[1];
   int     count   = (int)mcb->Control[2];
   LPPOINT lppt;

   push_mcb();

   lppt = (LPPOINT)GlobalLock(hBuffer);
   if (lppt eq (LPPOINT)NULL)
   {
        mcb->Control[0] = FALSE;
        my_Request_Return(ReplyOK, 1, 0);
        return;
   }
   mcb->Control[0] = Polygon(hDC, lppt, count);
   GraphicsDebug(("Polygon(0x%x,,%d) = 0x%x", hDC, count, mcb->Control[0]));
   GlobalUnlock(hBuffer);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 086 */
void IO_Polyline(Graphnode *app)
{
   HDC     hDC     = (HDC)mcb->Control[0];
   HGLOBAL hBuffer = (HGLOBAL)mcb->Control[1];
   int     count   = (int)mcb->Control[2];
   LPPOINT lppt;

   push_mcb();

   lppt = (LPPOINT)GlobalLock(hBuffer);
   if (lppt eq (LPPOINT)NULL)
   {
        mcb->Control[0] = FALSE;
        my_Request_Return(ReplyOK, 1, 0);
        return;
   }
   mcb->Control[0] = Polyline(hDC, lppt, count);
   GraphicsDebug(("Polyline(0x%x,,%d) = 0x%x", hDC, count, mcb->Control[0]));
   GlobalUnlock(hBuffer);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 087 */
void IO_Rectangle(Graphnode *app)
{
   HDC hDC      = (HDC)mcb->Control[0];
   int nLeft    = (int)mcb->Control[1];
   int nTop     = (int)mcb->Control[2];
   int nRight   = (int)mcb->Control[3];
   int nBottom  = (int)mcb->Control[4];
   push_mcb();
   mcb->Control[0] = (word)Rectangle(hDC, nLeft, nTop, nRight, nBottom);
   GraphicsDebug(("Rectangle(0x%x,%d,%d,%d,%d) = 0x%x", hDC, nLeft, nTop, 
        nRight, nBottom, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 088 */
void IO_SetPixel(Graphnode *app)
{
   HDC hDC      = (HDC)mcb->Control[0];
   int X        = (int)mcb->Control[1];
   int Y        = (int)mcb->Control[2];
   COLORREF cr  = (COLORREF)mcb->Control[3];
   push_mcb();
   mcb->Control[0] = (word)SetPixel(hDC, X, Y, cr);
   GraphicsDebug(("SetPixel(0x%x,%d,%d,0x%08lx) = 0x%x", hDC, X, Y, cr, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 089 */
void IO_SetPolyFillMode(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int mode = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)SetPolyFillMode(hDC, mode);
   GraphicsDebug(("SetPolyFillMode(0x%x,0x%x) = 0x%x", hDC, mode, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 090 */
void IO_SetROP2(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   int mode = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)SetROP2(hDC, mode);
   GraphicsDebug(("SetROP2(0x%x,0x%x) = 0x%x", hDC, mode, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 091 */
void IO_UnrealizeObject(Graphnode *app)
{
   HGDIOBJ hObj = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)UnrealizeObject(hObj);
   GraphicsDebug(("UnrealizeObject(0x%x) = 0x%x", hObj, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 092 */
void IO_UpdateWindow(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   push_mcb();
   UpdateWindow(hWnd);
   GraphicsDebug(("UpdateWindow(0x%x) = 0x%x", hWnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 0, 0);
}

/* 093 */
void IO_ValidateRect(Graphnode *app)
{
   HWND hWnd = (HWND)mcb->Control[0];
   LPRECT lprc = (LPRECT)&mcb->Data[0];
   push_mcb();
   ValidateRect(hWnd, lprc);
   GraphicsDebug(("ValidateRect(0x%x,(%d,%d,%d,%d)) = 0x%x", hWnd, lprc->left, 
        lprc->top, lprc->right, lprc->bottom, mcb->Control[0]));
   my_Request_Return(ReplyOK, 0, 0);
}

/* 094 */
void IO_CreatePalette(Graphnode *app)
{
   LOGPALETTE FAR *lplgpl = (LOGPALETTE FAR *)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = (word)CreatePalette(lplgpl);
   GraphicsDebug(("CreatePalette(..) = 0x%x", mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HPALETTE, app);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 095 */
void IO_GetPaletteEntries(Graphnode *app)
{
   HPALETTE hPal   = (HPALETTE)mcb->Control[0];
   UINT     uStart = (UINT)mcb->Control[1];
   UINT     uNo    = (UINT)mcb->Control[2];
   PALETTEENTRY FAR *lppe = (PALETTEENTRY FAR *)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = GetPaletteEntries(hPal, uStart, uNo, lppe);
   GraphicsDebug(("GetPaletteEntries(0x%x,%d,%d,) = 0x%x", hPal, uStart, uNo, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, sizeof(PALETTEENTRY)*mcb->Control[0]);
}

/* 096 */
void IO_GetNearestPaletteIndex(Graphnode *app)
{
   HPALETTE hPal   = (HPALETTE)mcb->Control[0];
   COLORREF cr     = (COLORREF)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = GetNearestPaletteIndex(hPal, cr);
   GraphicsDebug(("GetNearestPaletteIndex(0x%x,0x%08lx) = 0x%x", hPal, cr, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 097 */
void IO_RealizePalette(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = RealizePalette(hDC);
   GraphicsDebug(("RealizePalette(0x%x) = 0x%x", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 098 */
void IO_SelectPalette(Graphnode *app)
{
   HDC      hDC      = (HDC)mcb->Control[0];
   HPALETTE hPal     = (HPALETTE)mcb->Control[1];
   BOOL     bBackgnd = (BOOL)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = SelectPalette(hDC, hPal, bBackgnd);
   GraphicsDebug(("SelectPalette(0x%x,0x%x,0x%x) = 0x%x", hDC, hPal, bBackgnd, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 099 */
void IO_SetPaletteEntries(Graphnode *app)
{
   HPALETTE hPal   = (HPALETTE)mcb->Control[0];
   UINT     uStart = (UINT)mcb->Control[1];
   UINT     uNo    = (UINT)mcb->Control[2];
   PALETTEENTRY FAR *lppe = (PALETTEENTRY FAR *)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = SetPaletteEntries(hPal, uStart, uNo, lppe);
   GraphicsDebug(("SetPaletteEntries(0x%x,%d,%d,) = 0x%x", hPal, uStart, uNo, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 100 */
void IO_BitBlt(Graphnode *app)
{
   HDC   hDest  = (HDC)mcb->Control[0];
   int   XDest  = (int)mcb->Control[1];
   int   YDest  = (int)mcb->Control[2];
   int   width  = (int)mcb->Control[3];
   int   height = (int)mcb->Control[4];
   HDC   hSrc   = (HDC)mcb->Control[5];
   int   XSrc   = (int)mcb->Control[6];
   int   YSrc   = (int)mcb->Control[7];
   DWORD dwROP  = (DWORD)mcb->Control[8];
   push_mcb();
   mcb->Control[0] = (word)BitBlt(hDest, XDest, YDest, width, height,
                                  hSrc, XSrc, YSrc, dwROP);
   GraphicsDebug(("BitBlt(0x%x,%d,%d,%d,%d,0x%x,%d,%d,0x%lx) = 0x%x", hDest, 
        XDest, YDest, width, height, hSrc, YSrc, XSrc, dwROP, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* 101 */
void IO_CreateBitmap(Graphnode *app)
{
   int     width  = (int)mcb->Control[0];
   int     height = (int)mcb->Control[1];
   UINT    planes = (UINT)mcb->Control[2];
   UINT    bpp    = (UINT)mcb->Control[3];
   HGLOBAL hMem   = (HGLOBAL)mcb->Control[4];
   VOID FAR *lpvBits;

   push_mcb();
   if (hMem ne NULL)
   {
        lpvBits = (VOID FAR *)GlobalLock(hMem);
        if (lpvBits eq (VOID FAR *)NULL)
        {
            mcb->Control[0] = NULL;
            ServerDebug("CreateBitmap failed to access init data");
            my_Request_Return(ReplyOK, 1, 0);
            return;
        }
   }
   else
       lpvBits = NULL;

   mcb->Control[0] = (word)CreateBitmap(width, height, planes, bpp, lpvBits);
   GraphicsDebug(("CreateBitmap(%d,%d,%d,%d,) = 0x%x", width, height, planes, bpp, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HBITMAP, app);
   GlobalUnlock(hMem);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 102 */
void IO_CreateCompatibleBitmap(Graphnode *app)
{
   HDC hDC    = (HDC)mcb->Control[0];
   int width  = (int)mcb->Control[1];
   int height = (int)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)CreateCompatibleBitmap(hDC, width, height);
   GraphicsDebug(("CreateCompatibleBitmap(0x%x,%d,%d) = 0x%x", hDC, width, height, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HBITMAP, app);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 103 */
void IO_CreateDIBitmap(Graphnode *app)
{
   HDC hDC = mcb->Control[0];
   DWORD dwInit = mcb->Control[1];
   UINT ColorUse = mcb->Control[2];
   HGLOBAL hMem = mcb->Control[3];
   BITMAPINFOHEADER FAR *lpbih = (BITMAPINFOHEADER FAR *)&mcb->Data[0];
   BITMAPINFO FAR *lpbi = (BITMAPINFO FAR *)&mcb->Data[lpbih->biSize];
   void FAR *lpvBits = NULL;

   push_mcb();

   if (dwInit != CBM_INIT)
       lpbi = NULL;

   if (hMem != NULL)
   {
       lpvBits = (void FAR *)GlobalLock(hMem);
       if (lpvBits == NULL)
       {
           mcb->Control[0] = NULL;
           ServerDebug("CreateDIBitmap failed to access init data");
           my_Request_Return(ReplyOK, 1, 0);
           return;
       }
   }

   mcb->Control[0] = CreateDIBitmap(hDC, lpbih, dwInit, lpvBits, lpbi, ColorUse);
   GraphicsDebug(("CreateDIBitmap(0x%x,,0x%lx,,,%x) = 0x%x", hDC, dwInit, ColorUse, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HBITMAP, app);
   GlobalUnlock(hMem);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 104 */
void IO_GetBitmapBits(Graphnode *app)
{
   HBITMAP hBitmap  = (HBITMAP)mcb->Control[0];
   LONG    cbBuffer = (LONG)mcb->Control[1];
   HGLOBAL hMem = GlobalAlloc(GHND, cbBuffer);
   void FAR *lpvBits = (void FAR *)GlobalLock(hMem);
   push_mcb();

   if ((hMem == NULL) || (lpvBits == (void FAR *)NULL))
   {
        mcb->Control[0] = NULL;
        mcb->Control[1] = NULL;
        ServerDebug("GetBitmapBits failed to allocate data buffer");
        my_Request_Return(ReplyOK, 2, 0);
        return;
   }

   mcb->Control[0] = GetBitmapBits(hBitmap, cbBuffer, lpvBits);
   GraphicsDebug(("GetBitmapBits(0x%x,%ld,) = %ld", hBitmap, cbBuffer, mcb->Control[0]));
   GlobalUnlock(hMem);
   mcb->Control[1] = hMem;

   my_Request_Return(ReplyOK, 2, 0);
}

/* 105 */
void IO_GetDIBits(Graphnode *app)
{
   HDC     hDC          = (HDC)mcb->Control[0];
   HBITMAP hBitmap      = (HBITMAP)mcb->Control[1];
   UINT    start        = (UINT)mcb->Control[2];
   UINT    lines        = (UINT)mcb->Control[3];
   UINT    fuColorUse   = (UINT)mcb->Control[4];
   BITMAPINFO FAR *lpbi = (BITMAPINFO FAR *)&mcb->Data[0];
   HGLOBAL hMem;
   BITMAP  bm;
   DWORD   dwBitmapSize;
   void FAR *lpvBits;

   push_mcb();

   GetObject(hBitmap, sizeof(BITMAP), (void FAR *)&bm);
   dwBitmapSize = (DWORD)(bm.bmWidthBytes * bm.bmHeight * bm.bmPlanes);
   hMem = GlobalAlloc(GHND, dwBitmapSize);
   lpvBits = (void FAR *)GlobalLock(hMem);
   if ((hMem == NULL) || (lpvBits == (void FAR *)NULL))
   {
       mcb->Control[0] = 0;
       mcb->Control[1] = 0;
       mcb->Control[2] = 0;
       ServerDebug("GetDIBits failed to allocate data buffer");
       my_Request_Return(ReplyOK, 3, 0);
       return;
   }

   mcb->Control[0] = GetDIBits(hDC, hBitmap, start, lines, lpvBits, lpbi, fuColorUse);
   GraphicsDebug(("GetDIBits(0x%x,0x%x,%d,%d,,,0x%x) = %d", hDC, hBitmap, start, lines, fuColorUse, mcb->Control[0]));
   GlobalUnlock(hMem);
   mcb->Control[1] = hMem;
   mcb->Control[2] = dwBitmapSize;

   my_Request_Return(ReplyOK, 3, sizeof(BITMAPINFO));
}

/* 106 */
void IO_SetBitmapBits(Graphnode *app)
{
   HBITMAP hBitmap = (HBITMAP)mcb->Control[0];
   DWORD   dwCount = (DWORD)mcb->Control[1];
   HGLOBAL hMem    = (HGLOBAL)mcb->Control[2];
   void FAR *lpvBits;

   push_mcb();
   lpvBits = (void FAR *)GlobalLock(hMem);
   if (lpvBits eq (void FAR *)NULL)
   {
        mcb->Control[0] = 0;
        ServerDebug("SetBitmapBits: Unable to access bitmap data");
        my_Request_Return(ReplyOK, 1, 0);
        return;
   }
   mcb->Control[0] = SetBitmapBits(hBitmap, dwCount, lpvBits);
   GraphicsDebug(("SetBitmapBits(0x%x,%ld,) = 0x%lx", hBitmap, dwCount, mcb->Control[0]));
   GlobalUnlock(hMem);

   my_Request_Return(ReplyOK, 1, 0);
}

/* 107 */
void IO_SetDIBits(Graphnode *app)
{
   HDC hDC = mcb->Control[0];
   HBITMAP hBitmap = mcb->Control[1];
   UINT start = mcb->Control[2];
   UINT count = mcb->Control[3];
   void FAR *lpvBits;
   BITMAPINFO FAR *lpbi = (BITMAPINFO FAR *)&mcb->Data[0];
   UINT ColorUse = mcb->Control[4];
   HGLOBAL hMem = mcb->Control[5];

   push_mcb();

   lpvBits = (void FAR *)GlobalLock(hMem);
   if (lpvBits == NULL)
   {
       mcb->Control[0] = 0;
       ServerDebug("SetDIBits: Unable to access bitmap data");
       my_Request_Return(ReplyOK, 1, 0);
       return;
   }

   mcb->Control[0] = SetDIBits(hDC, hBitmap, start, count, lpvBits, lpbi, ColorUse);
   GraphicsDebug(("SetDIBits(0x%x,0x%x,%d,%d,,,0x%x) = 0x%lx", hDC, hBitmap, start, count, ColorUse, mcb->Control[0]));
   GlobalUnlock(hMem);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 108 */
void IO_SetDIBitsToDevice(Graphnode *app)
{
    HDC hDC = mcb->Control[0];
    int XDest = mcb->Control[1];
    int YDest = mcb->Control[2];
    int cx = mcb->Control[3];
    int cy = mcb->Control[4];
    int XSrc = mcb->Control[5];
    int YSrc = mcb->Control[6];
    UINT uStart = mcb->Control[7];
    UINT uNo = mcb->Control[8];
    UINT ColorUse = mcb->Control[9];
    HGLOBAL hMem = mcb->Control[10];
    BITMAPINFO FAR *lpbi = (BITMAPINFO FAR *)&mcb->Data[0];
    void FAR *lpvBits = GlobalLock(hMem);

    push_mcb();

    if (lpvBits == NULL)
    {
         mcb->Control[0] = 0;
         my_Request_Return(ReplyOK, 1, 0);
         return;
    }
    mcb->Control[0] = SetDIBitsToDevice(hDC, XDest, YDest, cx, cy,
                                XSrc, YSrc, uStart, uNo, lpvBits, lpbi, ColorUse);
    GraphicsDebug(("SetDIBitsToDevice() = 0x%lx", mcb->Control[0]));
    GlobalUnlock(hMem);
    my_Request_Return(ReplyOK, 1, 0);
}

/* 109 */
void IO_CreateCompatibleDC(Graphnode *app)
{
   HDC hDC = (HDC)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)CreateCompatibleDC(hDC);
   GraphicsDebug(("CreateCompatibleDC(0x%x) = 0x%x", hDC, mcb->Control[0]));
   my_Request_Return(ReplyOK, 1, 0);
}

/* BLV - the code below manipulates Windows buffers which can exceed 64K,
 * i.e. which must be processed using huge pointers. Therefore the usual
 * inline versions of memcpy etc. do not work.
 */
#pragma function(memcpy)

/* 110 */
void IO_RegisterBuffer(Graphnode *app)
{
   DWORD dwSize = mcb->Control[0];

   push_mcb();
   mcb->Control[0] = GlobalAlloc(GHND, dwSize);
   GraphicsDebug(("RegisterBuffer(%ld) = 0x%x", dwSize, mcb->Control[0]));
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HGLOBAL, (void FAR *)app);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 111 */
void IO_AppendBuffer(Graphnode *app)
{
   HGLOBAL hMem = (HGLOBAL)mcb->Control[0];
   DWORD offset = (DWORD)mcb->Control[1];
   DWORD size = (DWORD)mcb->Control[2];
   DWORD dwBufSize = GlobalSize(hMem);
   BYTE huge *lpData;
   push_mcb();

   /* check validity of buffer access to prevent protection faults */
   if ((offset < 0L) || (offset+size > dwBufSize))
   {
        mcb->Control[0] = FALSE;
        my_Request_Return(ReplyOK, 1, 0);
        return;
   }

   lpData = (BYTE huge *)GlobalLock(hMem);

   memcpy(&lpData[offset], &mcb->Data[0], (UINT)size);

   GlobalUnlock(hMem);
   mcb->Control[0] = TRUE;
   my_Request_Return(ReplyOK, 1, 0);
}

/* 166 - send back to Helios */
void IO_GetBuffer(Graphnode *app)
{
   HGLOBAL hMem = (HGLOBAL)mcb->Control[0];
   int offset = (int)mcb->Control[1];
   DWORD size = (DWORD)mcb->Control[2];
   DWORD dwBufSize = GlobalSize(hMem);
   BYTE huge *lpData;

   push_mcb();

   /* check validity of buffer access to prevent protection faults */
   if ((offset < 0) || (offset+size > dwBufSize))
   {
        ServerDebug("GetBuffer ERROR: offset and size out of range");
        mcb->Control[0] = FALSE;
        my_Request_Return(ReplyOK, 1, 0);
        return;
   }

   lpData = (BYTE huge *)GlobalLock(hMem);

   memcpy(&mcb->Data[0], &lpData[offset], (UINT)size);

   GlobalUnlock(hMem);
   mcb->Control[0] = size;
   my_Request_Return(ReplyOK, 1, size);
}

/* 112 */
void IO_DeleteBuffer(Graphnode *app)
{
   HGLOBAL hMem = mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (GlobalFree(hMem) ne NULL);
   GraphicsDebug(("DeleteBuffer(0x%x) = 0x%x", hMem, mcb->Control[0]));
   RemoveHandle(&hashWindows, hMem, HT_HGLOBAL);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 113 */
void IO_AppendMenu(Graphnode *app)
{
   HMENU  hMenu    = (HMENU)mcb->Control[0];
   UINT   uFlags   = (UINT)mcb->Control[1];
   UINT   ID       = (UINT)mcb->Control[2];
   LPCSTR lpszText = (LPCSTR)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = (word)AppendMenu(hMenu, uFlags, ID, lpszText);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 114 */
void IO_CheckMenuItem(Graphnode *app)
{
   HMENU hMenu  = (HMENU)mcb->Control[0];
   UINT  ID     = (UINT)mcb->Control[1];
   UINT  uCheck = (UINT)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)CheckMenuItem(hMenu, ID, uCheck);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 115 */
void IO_CreatePopupMenu(Graphnode *app)
{
   push_mcb();
   mcb->Control[0] = (word)CreatePopupMenu();
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HMENU, (void FAR *)app);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 116 */
void IO_CreateMenu(Graphnode *app)
{
   push_mcb();
   mcb->Control[0] = (word)CreateMenu();
   if (mcb->Control[0] != NULL)
       AddHandle(&hashWindows, mcb->Control[0], HT_HMENU, (void FAR *)app);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 117 */
void IO_DeleteMenu(Graphnode *app)
{
   HMENU  hMenu    = (HMENU)mcb->Control[0];
   UINT   ID       = (UINT)mcb->Control[1];
   UINT   uFlags   = (UINT)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)DeleteMenu(hMenu, ID, uFlags);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 118 */
void IO_DestroyMenu(Graphnode *app)
{
   HMENU  hMenu    = (HMENU)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)DestroyMenu(hMenu);
   RemoveHandle(&hashWindows, hMenu, HT_HMENU);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 119 */
void IO_DrawMenuBar(Graphnode *app)
{
   HWND  hWnd    = (HWND)mcb->Control[0];
   push_mcb();
   DrawMenuBar(hWnd);
   my_Request_Return(ReplyOK, 0, 0);
}

/* 120 */
void IO_EnableMenuItem(Graphnode *app)
{
   HMENU  hMenu    = (HMENU)mcb->Control[0];
   UINT   ID       = (UINT)mcb->Control[1];
   UINT   uFlags   = (UINT)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)EnableMenuItem(hMenu, ID, uFlags);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 121 */
void IO_GetMenu(Graphnode *app)
{
   HWND  hWnd    = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetMenu(hWnd);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 122 */
void IO_GetMenuItemCount(Graphnode *app)
{
   HMENU  hMenu = (HMENU)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = (word)GetMenuItemCount(hMenu);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 123 */
void IO_GetMenuItemID(Graphnode *app)
{
   HMENU  hMenu = (HMENU)mcb->Control[0];
   int    nPos  = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetMenuItemID(hMenu, nPos);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 124 */
void IO_GetMenuState(Graphnode *app)
{
   HMENU  hMenu    = (HMENU)mcb->Control[0];
   UINT   ID       = (UINT)mcb->Control[1];
   UINT   uFlags   = (UINT)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)GetMenuState(hMenu, ID, uFlags);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 125 */
void IO_GetMenuString(Graphnode *app)
{
   HMENU  hMenu    = (HMENU)mcb->Control[0];
   UINT   ID       = (UINT)mcb->Control[1];
   int    max      = (int)mcb->Control[2];
   UINT   uFlags   = (UINT)mcb->Control[3];
   LPSTR  str      = (LPSTR)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = (word)GetMenuString(hMenu, ID, str, max, uFlags);
   my_Request_Return(ReplyOK, 1, mcb->Control[0]+1);
}

/* 126 */
void IO_GetSubMenu(Graphnode *app)
{
   HMENU  hMenu = (HMENU)mcb->Control[0];
   int    nPos  = (int)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetSubMenu(hMenu, nPos);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 127 */
void IO_GetSystemMenu(Graphnode *app)
{
   HWND   hWnd = (HWND)mcb->Control[0];
   BOOL   bRevert = (BOOL)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)GetSystemMenu(hWnd, bRevert);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 128 */
void IO_InsertMenu(Graphnode *app)
{
   HMENU  hMenu    = (HMENU)mcb->Control[0];
   UINT   ID       = (UINT)mcb->Control[1];
   UINT   uFlags   = (UINT)mcb->Control[2];
   UINT   NewID    = (UINT)mcb->Control[3];
   LPSTR  str      = (LPSTR)&mcb->Data[0];
   push_mcb();
   mcb->Control[0] = (word)InsertMenu(hMenu, ID, uFlags, NewID, str);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 129 */
void IO_RemoveMenu(Graphnode *app)
{
   HMENU  hMenu    = (HMENU)mcb->Control[0];
   UINT   ID       = (UINT)mcb->Control[1];
   UINT   uFlags   = (UINT)mcb->Control[2];
   push_mcb();
   mcb->Control[0] = (word)RemoveMenu(hMenu, ID, uFlags);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 130 */
void IO_SetMenu(Graphnode *app)
{
   HWND   hWnd     = (HWND)mcb->Control[0];
   HMENU  hMenu    = (HMENU)mcb->Control[1];
   push_mcb();
   mcb->Control[0] = (word)SetMenu(hWnd, hMenu);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 131 */
void IO_FindWindow(Graphnode *app)
{
   int    length = (int)mcb->Control[0];
   LPCSTR lpszClassName = (LPCSTR)&mcb->Data[0];
   LPCSTR lpszWindow = (LPCSTR)&mcb->Data[length];
   push_mcb();
   if (strlen(lpszClassName) == 0)
       lpszClassName = NULL;
   if (strlen(lpszWindow ) == 0)
       lpszWindow = NULL;
   mcb->Control[0] = (word)FindWindow(lpszClassName, lpszWindow);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 133 */
void IO_RegisterIOMenu(Graphnode *app)
{
   UINT ID = (UINT)mcb->Control[0];
   Menunode *menunode;
   push_mcb();

   /* now we add the menu to the app's list */
   menunode = (Menunode *)malloc(sizeof(Menunode));
   if (menunode eq (Menunode *)NULL)
   {
        mcb->Control[0] = FALSE;
        my_Request_Return(ReplyOK, 1, 0);
        return;
   }

   menunode->ID = ID;
   AddTail(&(menunode->node), &(app->menu_list));
   mcb->Control[0] = TRUE;
   my_Request_Return(ReplyOK, 1, 0);
}

/* 133 */
void IO_DeleteDC(Graphnode *app)
{
   HDC hDC = (HWND)mcb->Control[0];
   push_mcb();
   mcb->Control[0] = DeleteDC(hDC);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 134 */
void IO_GetUpdateRect(Graphnode *app)
{
   HWND hWnd = mcb->Control[0];
   BOOL bErase = mcb->Control[1];
   Windownode *window = find_window_node(hWnd);
   RECT rect;
   push_mcb();

   if (window != (Windownode *)NULL)
        memcpy(&mcb->Data[0], &window->rectInvalid, sizeof(RECT));
   else
   {
        mcb->Control[0] = GetUpdateRect(hWnd, &rect, bErase);
        memcpy(&mcb->Data[0], &rect, sizeof(RECT));
   }

   my_Request_Return(ReplyOK, 1L, sizeof(RECT));
}

/* 135 */
void IO_SendMessage(Graphnode *app)
{
   HWND hWnd = mcb->Control[0];
   UINT msg  = mcb->Control[1];
   WPARAM wParam = mcb->Control[2];
   LPARAM lParam = mcb->Control[3];
   push_mcb();
   mcb->Control[0] = SendMessage(hWnd, msg, wParam, lParam);
   my_Request_Return(ReplyOK, 1, 0);
}

/* 136 */
void IO_GetObject(Graphnode *app)
{
   HGDIOBJ hObj = mcb->Control[0];
   int     cbBuffer = mcb->Control[1];
   void FAR *lpvBuffer = &mcb->Data[0];
   push_mcb();
   mcb->Control[0] = GetObject(hObj, cbBuffer, lpvBuffer);
   my_Request_Return(ReplyOK, 1, mcb->Control[0]);
}

/* 167 */
void IO_SetScrollRange(Graphnode *app)
{
	HWND hWnd	= (HWND) mcb->Control[0];
	int  nBar	= (int)  mcb->Control[1];
	int  nMinPos	= (int)  mcb->Control[2];
	int  nMaxPos	= (int)  mcb->Control[3];
	int  bRedraw	= (int)  mcb->Control[4];
	push_mcb();
	SetScrollRange(hWnd, nBar, nMinPos, nMaxPos, bRedraw);
	my_Request_Return(ReplyOK, 0, 0);
}

/* 168 */
void IO_GetScrollRange(Graphnode *app)
{
	HWND hWnd	= (HWND) mcb->Control[0];
	int  nBar	= (int)  mcb->Control[1];
	int  nMinPos;
	int  nMaxPos;

	push_mcb();
	GetScrollRange(hWnd, nBar, &nMinPos, &nMaxPos);
	mcb->Control[0]	= (word) nMinPos;
	mcb->Control[1] = (word) nMaxPos;
	my_Request_Return(ReplyOK, 2, 0);	
}

/* 169 */
void IO_SetScrollPos(Graphnode *app)
{
	HWND	hWnd	= (HWND) mcb->Control[0];
	int	nBar	= (int)  mcb->Control[1];
	int	nPos	= (int)  mcb->Control[2];
	int	bRedraw = (int)  mcb->Control[3];

	push_mcb();
	mcb->Control[0]	= SetScrollPos(hWnd, nBar, nPos, bRedraw);
	my_Request_Return(ReplyOK, 1, 0);
}

/* 170 */
void IO_GetScrollPos(Graphnode *app)
{
	HWND	hWnd	= (HWND) mcb->Control[0];
	int	nBar	= (int)  mcb->Control[1];

	push_mcb();
	mcb->Control[0]	= GetScrollPos(hWnd, nBar);
	my_Request_Return(ReplyOK, 1, 0);
}

/* 171 */
void IO_ShowScrollBar(Graphnode *app)
{
	HWND	hWnd	= (HWND) mcb->Control[0];
	WORD	wBar	= (WORD) mcb->Control[1];
	BOOL	bShow	= (WORD) mcb->Control[2];

	push_mcb();
	ShowScrollBar(hWnd, wBar, bShow);
	my_Request_Return(ReplyOK, 0, 0);
}

/* 172 */
void IO_EnableScrollBar(Graphnode *app)
{
	HWND	hWnd		= (HWND) mcb->Control[0];
	WORD	wSBFlags	= (WORD) mcb->Control[1];
	WORD	wArrowFlags	= (WORD) mcb->Control[2];

	push_mcb();
	mcb->Control[0]	= EnableScrollBar(hWnd, wSBFlags, wArrowFlags);
	my_Request_Return(ReplyOK, 0, 0);
}

/* This is the procedure called by MS-WINDOWS to process messages generated */
/* for windows opened by the graphics server. The only messages intercepted */
/* here are the mouse and keyboard messages.                                */

long FAR PASCAL GraphProc(hWnd, iMessage, wParam, lParam)
    HWND     hWnd;
    unsigned iMessage;
    WORD     wParam;
    LONG     lParam;
{
   LPMSG lpMsg;

   switch (iMessage) {
    /* specially handled messages */
      case WM_DESTROY:
        GraphicsDebug(("GraphProc(0x%x,WM_DESTROY,0x%x,0x%lx)", hWnd, wParam, lParam));
        build_message_and_send(hWnd, iMessage, wParam, lParam);
        remove_window_node(hWnd);
        break;

      case WM_PAINT:
      {
        Windownode *window = find_window_node(hWnd);
        GraphicsDebug(("GraphProc(0x%x,WM_PAINT,0x%x,0x%lx)", hWnd, wParam, lParam));
        build_message_and_send(hWnd, iMessage, wParam, lParam);
        InvalidateRect(hWnd, &window->rectInvalid, FALSE);
        GetUpdateRect(hWnd, &window->rectInvalid, FALSE);
        ValidateRect(hWnd, &window->rectInvalid);
        break;
      }

      case WM_SIZE:
        GraphicsDebug(("GraphProc(0x%x,WM_SIZE,0x%x,0x%lx)", hWnd, wParam, lParam));
        build_message_and_send(hWnd, iMessage, wParam, lParam);
        break;

    /* normal messages - are sent to helios with no special handling */
      case WM_ACTIVATE:
      case WM_CHAR:
      case WM_CHILDACTIVATE:
      case WM_CLOSE:
      case WM_CREATE:
      case WM_COMMAND:
      case WM_ENABLE:
      case WM_ENDSESSION:
      case WM_FONTCHANGE:
      case WM_HSCROLL:
      case WM_KILLFOCUS:
      case WM_LBUTTONDBLCLK:
      case WM_LBUTTONDOWN:
      case WM_LBUTTONUP:
      case WM_MBUTTONDBLCLK:
      case WM_MBUTTONDOWN:
      case WM_MBUTTONUP:
      case WM_MOUSEACTIVATE:
      case WM_MOVE:
      case WM_MOUSEMOVE:
      case WM_PALETTECHANGED:
      case WM_PARENTNOTIFY:
      case WM_QUERYNEWPALETTE:
      case WM_RBUTTONDBLCLK:
      case WM_RBUTTONDOWN:
      case WM_RBUTTONUP:
      case WM_SETFOCUS:
      case WM_SHOWWINDOW:
      /* case WM_SIZE: */
      case WM_SYSCHAR:
      case WM_SYSCOLORCHANGE:
      case WM_TIMECHANGE:
      case WM_VSCROLL:
      case WM_WININICHANGE:
        GraphicsDebug(("GraphProc(0x%x,0x%x,0x%x,0x%lx)", hWnd, iMessage, wParam, lParam));
        build_message_and_send(hWnd, iMessage, wParam, lParam);
        break;

    /* all others are handled by default handler */
      default:
        if (iMessage >= WM_USER)
        {
            GraphicsDebug(("GraphProc(0x%x,WM_USER,0x%x,0x%lx)", hWnd, iMessage, wParam, lParam));
            build_message_and_send(hWnd, iMessage, wParam, lParam);
        }
        else
            return(DefWindowProc(hWnd, iMessage, wParam, lParam));
   }
   return 0L;
}


@


1.6
log
@1) fixed RegisterPort so that it works with processors other than the root
2) fixed problems with the buffer code, which was fouling up pixmaps
   larger than 32K
3) added scrollbar functions
@
text
@d176 1
d186 2
@


1.5
log
@minor clean-up
@
text
@d147 3
a149 1
     IO_DdeReturnAdvise,    IO_GetBuffer
d1672 6
a1677 5
   app->msg_port = (Port)(mcb->Control[0]);
   mcb->Control[0] = maxdata;
   mcb->Control[1] = (word)PROGINSTANCE;
   Request_Return(ReplyOK, 2L, 0L);
   GraphicsDebug(("graphics (internal): RegisterPort 0x%x", app->msg_port));
d3300 6
d3310 1
d3323 1
a3323 1
   int offset = (int)mcb->Control[1];
a3326 1

d3330 1
a3330 1
   if ((offset < 0) || (offset+size > dwBufSize))
d3665 75
@


1.4
log
@various changes by Mike Gunning
@
text
@a16 2
#if (MSWINDOWS && graphics)

a3745 1
#endif  /* MSWINDOWS */
@


1.3
log
@Rewrite of Windows-specific bits of the I/O Server by Mike Gunning
@
text
@d553 3
d1752 3
@


1.2
log
@Patches to compile under Microsoft C 7.0
@
text
@d3 7
a9 16
/**	       Helios I/O Server Under Microsoft Windows		 **/
/**									 **/
/**	       Copyright (c) 1990,  CSIR - MIKOMTEK			 **/
/**		  All Rights Reserved.					 **/
/**									 **/
/**   Graph.c								 **/
/**									 **/
/**   The code in this file provides the graphics interface between the  **/
/**   Graphics Library for the Helios I/O Server under MS-WINDOWS, and	 **/
/**   Microsoft Windows' GDI functions.                                  **/
/**									 **/
/**   The standard I/O server function declarations and definitions for  **/
/**   the graphics server are defined in the files graph.def,		 **/
/**   winstrm.inc and windev.inc. These three files are included in the  **/
/**   main I/O server header file,  helios.h.				 **/
/**									 **/
d13 1
a13 1

d15 1
d19 3
a21 1
#include "msevent.h"   /* for keypress, repaint and resize events */
d23 18
a40 4
/* Graphnode is the structure that maintains all the required information */
/* on a particular graphic window. The Graphnode structures associated	  */
/* with each open graphics window are kept in a linked list, whose header */
/* is Graph_List.							  */
a41 15
typedef struct Graphnode { DirEntryNode node;	   /* Linked list stuff  */
			   HWND 	handle;    /* Window's ID        */
			   Attributes	attr;	   /* Window's Attributes*/
			   HBRUSH	Brush;	   /* window's fill brush*/
			   HFONT	hFont;	   /* window's text font */
			   HPALETTE	hPal;	   /* windows palette	 */
			   int		stream_count;  /* open streams */
			   int		meta_on;
			   char 	*meta_name;
			   LOCALHANDLE	meta_handle;
			   HDC		metaDC;
			   int		window_id;
} Graphnode;


d44 1
a45 1
#define num_routines  38 /* Number of routines providing graphics interface */
d47 20
a66 1
/* Definitions of functions providing the graphics interface */
a67 1
void get_meta_name(LPSTR);
d69 4
a72 43
PRIVATE void	  clear_meta_name(Graphnode *);
PRIVATE Graphnode *find_graph_name(char *);
PRIVATE Graphnode *create_graph_node(LPSTR);
PRIVATE Graphnode *find_graph(HWND);
PRIVATE void  close_graph_window(Graphnode *);
PRIVATE void  open_a_graph(Graphnode *);
PRIVATE void  put_a_pixel(Graphnode *);
PRIVATE void  move_to(Graphnode *);
PRIVATE void  line_to(Graphnode *);
PRIVATE void  draw_line(Graphnode *);
PRIVATE void  write_text(Graphnode *);
PRIVATE void  draw_poly_line(Graphnode *);
PRIVATE void  draw_rectangle(Graphnode *);
PRIVATE void  do_arc_functions(Graphnode *);
PRIVATE void  Set_Bk_Color(Graphnode *);
PRIVATE void  Set_Bk_Mode(Graphnode *);
PRIVATE void  Set_Fill_Styles(Graphnode *);
PRIVATE void  Set_Fill_Mode(Graphnode *);
PRIVATE void  Text_Ops(Graphnode *);
PRIVATE void  Font_Ops(Graphnode *);
PRIVATE void  DefineMapMode(Graphnode *);
PRIVATE void  DefineOrigins(Graphnode *);
PRIVATE void  DefineExtents(Graphnode *);
PRIVATE void  graph_size(Graphnode *);
PRIVATE void  graph_cur_pos(Graphnode *);
PRIVATE void  text_dimensions(Graphnode *);
PRIVATE void  display_bit_map(Graphnode *);
PRIVATE void  fill_area(Graphnode *);
PRIVATE void  get_extents(Graphnode *);
PRIVATE void  clear_graph(Graphnode *);
PRIVATE void  position_cursor(Graphnode *);
PRIVATE void  clip_cursor(Graphnode *);
PRIVATE void  set_cursor(Graphnode *);
PRIVATE void  get_max_block(Graphnode *);
PRIVATE void  create_meta_file(Graphnode *);
PRIVATE void  close_meta_file(Graphnode *);
PRIVATE void  get_meta_file(Graphnode *);
PRIVATE void  play_meta_file(Graphnode *);
PRIVATE void  delete_meta_file(Graphnode *);
PRIVATE void  do_message_box(Graphnode *);
PRIVATE void  select_palette(Graphnode *);
PRIVATE void  unselect_palette(Graphnode *);
PRIVATE void  get_text_extent(Graphnode *);
a73 8
/* local functions to handle msevents */
PRIVATE void send_char_key(HWND, WORD, LONG);
PRIVATE void send_sys_key(HWND, WORD, LONG);
PRIVATE void send_paint_request(HWND, PAINTSTRUCT far *);
PRIVATE void send_resize_request(HWND, WORD, LONG);

int new_line_attr(Graphnode *, HDC, word *);

d76 1
a76 1
static int	 open_graph = 0;
d78 2
d81 2
a82 3

/* Graph_Routines is an array containing the addresses of the routines	  */
/* providing the graphics interface. This allows us to index into the	  */
d84 1
a84 1
/* in the array, corresponds to the message number received from the	  */
d89 1
a89 2
/* message number, which is 0. The function required to implement the	  */
/* OpenGraph call must thus reside at position 0 in Graph_Routines.	  */
d92 1
a92 1
VoidFnPtr Graph_Routines[num_routines] =
d94 57
a150 9
     open_a_graph, put_a_pixel, move_to, line_to, draw_line, write_text,
     draw_poly_line, draw_rectangle, do_arc_functions,
     Set_Bk_Color, Set_Bk_Mode, Set_Fill_Styles, Set_Fill_Mode, Text_Ops,
     Font_Ops, DefineMapMode, DefineOrigins, DefineExtents, graph_size,
     graph_cur_pos, text_dimensions, do_message_box, display_bit_map,
     fill_area, get_extents, clear_graph, position_cursor, clip_cursor,
     set_cursor, get_max_block, select_palette, unselect_palette,
     create_meta_file, close_meta_file, get_meta_file, play_meta_file,
     delete_meta_file, get_text_extent };
d152 7
a159 9
/* Graph_Testfun is caled when the I/O server initialises. The function   */
/* registers the graphic window class with MS-WINDOWS. If the registering */
/* of the window class fails, the graphics server will not be availiable. */
/*									  */
/* The graphic window class is defined so that each window opened has its */
/* own device context. This takes up a bit of memory but means that we	  */
/* don't have to save the state of the device context each time it is     */
/* released, i.e. Fill brush, graphic cursor position, etc. We also need  */
/* to prevent the user from closing the window using MS-WINDOWS functions */
a160 1

a167 1

d172 4
a175 1
   Graph_List.entries = 0L;	  /* info on all open graphic windows	    */
d179 2
a180 2
/* all open graphic windows, and deletes the linked list of open graphic     */
/* windows.								     */
d184 1
a184 1
{ Graphnode *graph, *next;
d186 3
a188 2
  for (graph = (Graphnode *) Graph_List.list.head; /* go through list of   */
       graph->node.node.next ne (Node *) NULL; )   /* open graphic windows */
d190 7
a196 4
       close_graph_window(graph);	    /* close window */
       next = (Graphnode *) graph->node.node.next;
       free(Remove(&(graph->node.node)));	      /* Delete linked	 */
       graph = next;
d198 3
d208 2
a209 2
/* set, and the OpenMode is specified, in the Helios Open call. 	   */
/*									   */
d212 1
a212 1
/* successful then we open a new stream for the window. 		   */
d217 3
a219 3
  char	    *temp;
  word	    openmode = mcb->Control[OpenMode_off];
  Graphnode *new_graph;
d221 1
a221 1
  if (!strcmp(IOname, "graphics")) {	  /* Stream for the server? */
d223 1
a223 1
		(word) ((DirHeader far *) &(Graph_List)), WindowDir_Handlers);
d235 7
a241 7
  new_graph = find_graph_name(temp);   /* does the specified window exist? */
  if (new_graph eq (Graphnode *) NULL) {  /* No, so stream is for a new    */
    if (openmode & O_Create) {		  /* window */
	  /* Initialise a Graphnode for the new window */
       if ((new_graph = create_graph_node((LPSTR) temp)) eq (Graphnode *) NULL) {
	  Request_Return(EC_Error + SS_IOProc + EG_NoMemory + EO_File, 0L, 0L);
	  return;
d243 4
a246 4
       open_graph = 1;	/* If Graphnode successfully created and added to */
			/* to the list of open graphic windows, set	  */
			/* open graph flag. This flag will be accessed in */
			/* the open_a_graph routine.			  */
d256 1
a256 1
	      (word) ((Graphnode far *) new_graph), Graph_Handlers);
d268 1
a268 1
   Graphnode *graph;
d270 1
a270 1
   if (!strcmp(IOname, "graphics")) {	/* Locate the server */
d286 2
a287 2
   graph = find_graph_name(name);   /* Try to find graphic window */
   if (graph ne (Graphnode *) NULL) {
d300 7
a306 7
/* using the "rm" command on the Helios command line, to delete any graphic  */
/* windows still open after a graphics program on the transputer has	     */
/* terminated.								     */
/*									     */
/* The graphic window can only be closed if there are no open streams	     */
/* associated with it. After deleting the window, the Graphnode associated   */
/* with the window is removed from the list of open graphic windows.	     */
d310 2
a311 2
{ char	    *name;
  Graphnode *graph;
d313 1
a313 1
  if (!strcmp(IOname, "graphics")) {	/* Cannot delete the server */
d320 5
d326 3
a328 2
  graph = find_graph_name(name);    /* find graphic window */
  if (graph eq (Graphnode *) NULL)  /* Does not exist!! */
d330 2
d333 3
a335 3
    if (graph->stream_count ne 0) {  /* can only delete if not in use */
	Request_Return(EC_Error + SS_IOProc + EG_InUse + EO_Stream, 0L, 0L);
	return;
d338 11
a348 2
    close_graph_window(graph);		    /* close the window */
    free(Remove(&(graph->node.node)));	    /* remove the window from	*/
d382 1
a382 1
/* graphic window for which the message was intended, now becomes the	    */
d384 1
a384 1
/* MS-WINDOWS.								    */
d389 2
a390 2
   int	 mess_no;
   Graphnode *graph = (Graphnode *) myco->extra;
d392 2
a393 2
   mess_no	   = (int) mcb->MsgHdr.FnRc & 0xFFF;  /* get the message number */
   (Graph_Routines[mess_no]) (graph);	 /* call the desired function */
d413 1
a413 1
   word count	  = mcb->Control[WriteSize_off];
d424 2
a425 2
/* window. The stream is actually a co-routine, which is destroyed by	 */
/* calling seppuku.							 */
d434 1
d436 1
a436 1
   Seppuku();		      /* kill off stream co-routine */
d441 1
a441 1
/* at present, but we may introduce some later. 			  */
d449 1
a449 1
		      (Attributes far *) &(graph->attr));
d460 1
a460 1
			  (Attributes far *) mcb->Data);
d467 4
a470 4
/* server, or a graphic window. For the graphics server, we return the	    */
/* the standard ObjInfo structure used in the I/O Server, as well as the    */
/* width and height of the screen, obtained from the GetSystemmetrics call. */
/* The size of the message buffer in the server is also returned!.	    */
d472 3
a474 6
/*									    */
/* For a graphics window, information pertaining to that window is returned */
/* with the standard directory information normally supplied by a server in */
/* Helios. The extra information returned is a subset of that available     */
/* the GetDeviceCaps call. We return 18 values indicating various	    */
/* capablilities associated with the graphics device.			    */
d480 4
a483 4
   char 	  *name;
   Graphnode	  *graph;
   HDC		  hDC;
   int		  ct;
d485 7
a491 7
   Heliosinfo->obj.DirEntry.Type   = swap(Type_File);	    /* standard I/O */
   Heliosinfo->obj.DirEntry.Flags  = swap(0L);		    /* server return*/
   Heliosinfo->obj.DirEntry.Matrix = swap(DefFileMatrix);   /* to an	    */
   Heliosinfo->obj.Account	   = swap(0L);		    /* ObjectInfo   */
   Heliosinfo->obj.Creation	   = swap(Startup_Time);    /* request	    */
   Heliosinfo->obj.Access	   = swap(Startup_Time);
   Heliosinfo->obj.Modified	   = swap(Startup_Time);
d493 1
a493 1
   if (!strcmp(IOname, "graphics")) {	  /* Info on the graphics server */
d497 1
a497 1
      Heliosinfo->obj.Size	      = swap(0L);
d499 1
d502 3
a504 10
      Heliosinfo->info[0] = (word) GetSystemMetrics(SM_CXSCREEN);
      Heliosinfo->info[1] = (word) GetSystemMetrics(SM_CYSCREEN);
      Heliosinfo->info[2] = maxdata;
      Heliosinfo->info[3] = (word) GetSystemMetrics(SM_CYCAPTION);
      Heliosinfo->info[4] = (word) GetSystemMetrics(SM_CYMENU);
      Heliosinfo->info[5] = (word) GetSystemMetrics(SM_SWAPBUTTON);
      Heliosinfo->info[6] = (word) GetSystemMetrics(SM_CXFRAME);
      Heliosinfo->info[7] = (word) GetSystemMetrics(SM_CYFRAME);
      Heliosinfo->info[8] = (word) GetSystemMetrics(SM_CXBORDER);
      Heliosinfo->info[9] = (word) GetSystemMetrics(SM_CYBORDER);
d518 1
a518 1
   graph = find_graph_name(name);
d520 3
a522 3
   if (graph ne (Graphnode *) NULL) {	/* Info on open graphic windows */
      strcpy(Heliosinfo->obj.DirEntry.Name, graph->node.direntry.Name);
      Heliosinfo->obj.Size = swap((word) graph->stream_count);
d524 3
a526 4
      hDC = GetDC(graph->handle);
      if (hDC ne (HDC) 0) {
	 for (ct = 2; ct < 25; ct += 2)
	    Heliosinfo->info[ct / 2 - 1] = (word) GetDeviceCaps(hDC, ct);
d528 3
a530 12
	 Heliosinfo->info[12] = (word) GetDeviceCaps(hDC, RASTERCAPS);
	 Heliosinfo->info[13] = (word) GetDeviceCaps(hDC, ASPECTX);
	 Heliosinfo->info[14] = (word) GetDeviceCaps(hDC, ASPECTY);
	 Heliosinfo->info[15] = (word) GetDeviceCaps(hDC, ASPECTXY);
	 Heliosinfo->info[16] = (word) GetDeviceCaps(hDC, LOGPIXELSX);
	 Heliosinfo->info[17] = (word) GetDeviceCaps(hDC, LOGPIXELSY);
	 ReleaseDC(graph->handle, hDC);
      }
      else  {
	for (ct = 0; ct < 18; ct++)
	   Heliosinfo->info[ct] = 0;
      }
a540 7

/* The above routines are the standard Helios I/O server routines, needed  */
/* to create and use a server in Helios. The routines that follow, are the */
/* routines that implement the graphic functions required by the Graphics  */
/* Library that resides on the transputer.				   */


d542 3
a544 14
/* find_graph_name							   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   name - A string identifying a particular graphic window	   */
/*									   */
/* Function :-								   */
/*	The function searches through the list of open graphic windows,    */
/*	until it finds the Graphnode structure containing the string	   */
/*	specified by name.						   */
/*									   */
/* Returns :-								   */
/*	The address of the Graphnode structure if the string is found,	   */
/*	NULL if the string was not found.				   */
d547 1
a547 2
Graphnode *find_graph_name(name)
   char *name;
d549 3
a551 1
   Graphnode *graph;  /* address of the Graphnode structure */
d553 3
a555 3
   for (graph = (Graphnode *) Graph_List.list.head;   /* search through list */
	graph->node.node.next ne (Node *) NULL;       /* of open graphic     */
	graph = (Graphnode *) graph->node.node.next)  /* windows	     */
d557 4
a560 3
	if (!mystrcmp(name, &(graph->node.direntry.Name[0])))
	    return(graph);   /* return address of Graphnode structure if found */
    }
d562 9
a570 1
    return((Graphnode *) NULL);  /* NULL if not found */
d574 5
d580 3
a582 14
/* find_graph								   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   handle - A MS-WINDOWS handle for an open graphic window	   */
/*									   */
/* Function :-								   */
/*	The function searches through the list of open graphic windows,    */
/*	until it finds the Graphnode structure containing the handle	   */
/*	specified by handle						   */
/*									   */
/* Returns :-								   */
/*	The address of the Graphnode structure if the handle is found,	   */
/*	NULL if the handle was not found.				   */
d585 1
a585 2
Graphnode *find_graph(handle)
   HWND handle;
d587 1
a587 9
   Graphnode *graph;   /* address of the Graphnode structure */

   for (graph = (Graphnode *) Graph_List.list.head;
	(graph->handle ne handle) && (graph->node.node.next ne (Node *) NULL);
	graph = (Graphnode *) graph->node.node.next);

   if (graph->handle ne handle) return((Graphnode *) NULL);
      else
	return(graph);
d592 9
a600 15
/* clear_meta_name							   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to a GraphNode structure.			   */
/*									   */
/* Function :-								   */
/*	The function deletes the temporary metafile name created by the    */
/*	graphics library when a CreateMetaFile call was made on the	   */
/*	transputer without specifying a file name for the meta file. The   */
/*	file is removed from the disk, and the memory required to store    */
/*	the file name is freed. 					   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
d603 1
a603 3

void clear_meta_name(graph)
   Graphnode *graph;
d605 2
a606 8
   if (graph->meta_name ne NULL) {
      remove(graph->meta_name);       /* remove file from disk */
      LocalUnlock(graph->meta_handle);
      LocalFree(graph->meta_handle);	/* free memory for file name */
      graph->meta_name = NULL;
      graph->meta_handle = 0;
    }
}
d608 12
d621 4
d626 5
a630 20
/***************************************************************************/
/* create_graph_node							   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   temp - A string containing a unique name for the graphic	   */
/*		  window associated with the Graphnode structure being	   */
/*		  created.						   */
/*									   */
/* Function :-								   */
/*	The function creates a Graphnode structure, initialises the fields */
/*	of the structure, and adds the structure to the end of the list of */
/*	open graphic windows. Memory for the Graphnode structure is	   */
/*	allocated from local memory, and can thus be accessed using near   */
/*	pointers.							   */
/*									   */
/* Returns :-								   */
/*	The address of the Graphnode structure if it was successfully	   */
/*	created and added to the list, NULL if it was not.		   */
/***************************************************************************/
d632 7
a639 3
Graphnode *create_graph_node(temp)
  LPSTR temp;
{  Graphnode *new_graph;       /* address of the created Graphnode structure */
d641 14
a654 6
      /* Allocate memory for the Graphnode structure. */
   new_graph = malloc(sizeof(Graphnode));
   if (new_graph eq NULL)
    { Request_Return(EC_Warn + SS_IOProc + EG_NoMemory + EO_Server, 0L, 0L);
      return((Graphnode *) NULL);
    }
d656 4
a659 4
   new_graph->handle = (HWND) 0;	   /* window not yet open!! */
   new_graph->stream_count = 0; 	   /* no streams open yet   */
   strcpy(&(new_graph->node.direntry.Name[0]), temp);	/* insert name of */
				      /* window associated with structure */
d661 10
a670 5
   new_graph->node.direntry.Type = Type_File;
   Graph_List.entries++;
   InitAttributes((Attributes far *) &(new_graph->attr));
   AddTail(&(new_graph->node.node), &(Graph_List.list)); /* Add to list of  */
   return(new_graph);					 /* graphic windows */
a672 1

d674 12
a685 14
/* close_graph_window							   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   the graphic window to be closed.			   */
/*									   */
/* Function :-								   */
/*	The function closes the window, whose handle is extracted from the */
/*	Graphnode structure pointed to by graph. All GDI objects	   */
/*	associated with the window are deleted. 			   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
d688 1
a688 3

void close_graph_window(graph)
   Graphnode *graph;
d690 1
a690 1
   HDC hDC;
d692 8
a699 12
   if (graph->handle != (HWND) 0) {   /* has window been opened? */
     hDC = GetDC(graph->handle);
     DeleteObject(SelectObject(hDC, GetStockObject(NULL_PEN)));
     if (graph->Brush ne (HBRUSH) 0)	   /* delete GDI objects */
	 DeleteObject(SelectObject(hDC, GetStockObject(NULL_BRUSH)));
     if (graph->hFont ne (HFONT) 0)
	 DeleteObject(SelectObject(hDC, GetStockObject(SYSTEM_FONT)));
     if (graph->hPal ne (HPALETTE) 0)
	 UnrealizeObject(graph->hPal);
     ReleaseDC(graph->handle, hDC);
     clear_meta_name(graph);
     DestroyWindow(graph->handle);    /* close the window */
d705 8
a712 32
/* open_a_graph 		message number = 0			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function opens a graphic window, using the arguments passed by */
/*	the Graphics Library on the transputer. If a stream has not been   */
/*	opened for the window, (in Graph_Open), the window must not be	   */
/*	opened. This can be determined by looking at the open_graph flag.  */
/*	The flag must be reset if it has been set.			   */
/*									   */
/*	The arguments required to perform the function are passed from the */
/*	transputer in the control vector of the message. The function	   */
/*	requires 6 arguments.						   */
/*									   */
/*	The first argument defines the type of window to be opened. If a   */
/*	caption needs to be displayed, an OVERLAPPED window is created,    */
/*	otherwise a POPUP window is created. The sixth argument defines    */
/*	type of border surrounding the window. This will only be a thin    */
/*	border for now. Once we find a way to notofy the user that his	   */
/*	graphics window has been erased, we can add other window styles.   */
/*	The other arguments define the size and starting co-ordinates of   */
/*	the window. We have to cater for -1's for these arguments, as in   */
/*	this case we need to create a window whose size is the maximum	   */
/*	size of the screen.						   */
/*									   */
/* Returns :-								   */
/*	Whether the window was sucessfully opened or not. Reply sent to    */
/*	transputer.							   */
d715 1
a715 2
void open_a_graph(graph)
   Graphnode *graph;
d717 2
a718 6
   word  window_type;  /* style of window */
   HDC	 hDC;
   word  *args = (word *) &mcb->Control[0]; /* arguments to function */
   HPEN  new_pen;	      /* pen created by function */
   LPSTR caption = mcb->Data;	/* the caption for the window being */
					/* opened */
d720 5
a724 1
   if (!open_graph) return;   /* can we open the window? */
d726 2
a727 4
   open_graph = 0;
   if (mcb->MsgHdr.DataSize eq 0) caption = (LPSTR) NULL;  /* no caption */
      else
	 caption[mcb->MsgHdr.DataSize] = '\0';
d729 2
a730 2
      /* 1st argument defines type of window being opened */
   window_type = args[0];
a731 2
/* If the size and location arguments are -1, then create a full screen */
/* window */
a732 7
   if (((int) args[1] eq -1) && ((int) args[2] eq -1) &&
       ((int) args[3] eq -1) && ((int) args[4] eq -1)) {
      args[1] = 0;
      args[2] = 0;
      args[3] = GetSystemMetrics(SM_CXSCREEN);
      args[4] = GetSystemMetrics(SM_CYSCREEN);
   }
d734 14
a747 6
/* Create the window */
   graph->handle = CreateWindow(Graph_Name, caption,
				window_type,
				(int) args[1], (int) args[2], (int) args[3],
				(int) args[4],
				NULL, NULL, PROGINSTANCE, NULL);
d749 7
a755 3
   if (graph->handle eq 0) { /* unable to open window!! */
      Request_Return(EC_Error + SS_IOProc + EG_NoMemory + EO_File, 0L, 0L);
      return;
d757 2
a758 8
   new_pen	= CreatePen(PS_SOLID, 1, 0L);  /* create solid black pen */
					       /* used as default pen	 */
   graph->Brush = (HBRUSH) 0;	    /* Still using default background brush */
   graph->hFont = (HFONT) 0;	    /* Still using default text font	    */
   graph->hPal	= (HPALETTE) 0;
   hDC = GetDC(graph->handle);
   SelectObject(hDC, new_pen);		  /*use pen as default pen */
   ReleaseDC(graph->handle, hDC);
a759 3
   graph->meta_on = 0;		  /* initialise metafile defaults */
   graph->meta_handle = 0;
   graph->meta_name = NULL;
a760 1
   graph->window_id = (int) args[6];
d762 17
a778 4
   ShowWindow(graph->handle, (int) args[5]);
   UpdateWindow(graph->handle);
   Request_Return(ReplyOK, 0L, 0L);    /* window opened successfully */
}
d780 4
d785 13
a797 23
/* Most of the function that follow implement graphics commands required    */
/* by the Graphics Library on the transputer.				    */
/*									    */
/* These commands that need to be implemented fall into two cataegories.    */
/* The commands have been buffered, or are one off commands.		    */
/*									    */
/* For buffered commands, the arguments for the commands are generally in   */
/* the data vector of the message. The first word in the control vector of  */
/* the message determines how many commands have been buffered. The general */
/* idea is then to implement that many commands, taking the parameters for  */
/* each command from the list of arguments stored in the data vector. All   */
/* arguments are long words, so the data vector must be cast from a char *  */
/* to a word *. 							    */
/*									    */
/* For the one off commands, the arguments for the command are generally    */
/* stored in the control vector of the message. 			    */
/*									    */
/* Each function performing a task required by the Graphics Library, must   */
/* send a reply to the transputer, using Request_Return, giving the result  */
/* of the task. 							    */
/*									    */
/* Each function is activated by a message number, and the location of the  */
/* function in Graph_Routines must correspond to that message number.	    */
d799 2
d802 18
d821 3
d825 4
d830 12
a841 17
/* put_a_pixel			message number = 1			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS call, SetPixel. The function	   */
/*	needs three arguments per command. The arguments are in the data   */
/*	vector of the message. The commands from the transputer are	   */
/*	buffered.							   */
/*									   */
/* Returns :-								   */
/*	Always returns success. If the sequence of commands fails, no	   */
/*	pixels will be drawn, thus supplying visual confirmation of	   */
/*	success or failure.						   */
d844 1
a844 3

void put_a_pixel(graph)
   Graphnode *graph;
d846 2
a847 5
   int	 ct,	      /* a counter */
	 index = 0,   /* used to index into the list of arguments */
	 num_cmds = (int) mcb->Control[0];   /* No. of buffered commands */
   HDC	 hDC;
   word  far *args = (word far *) mcb->Data;   /* the list of arguments */
d849 5
a853 4
   Request_Return(ReplyOK, 0L, 0L);  /* always return success */
   if (graph->meta_on) hDC = graph->metaDC;
      else
	 hDC = GetDC(graph->handle);
d855 3
a857 4
   for (ct = 0; ct < num_cmds; ct++) {
     SetPixel(hDC, (int) args[index], (int) args[index + 1],
	      args[index + 2]);
     index += 3;
a858 2
   if (!graph->meta_on)
     ReleaseDC(graph->handle, hDC);
d863 14
a876 14
/* move_to			message number = 2			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS call MoveTo. The arguments for   */
/*	the command are in the control vector. The command from the	   */
/*	transputer is not buffered.					   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d879 1
a879 2
void move_to(graph)
   Graphnode *graph;
d881 1
a881 1
   HDC hDC;
d883 15
a897 7

   if (graph->meta_on) hDC = graph->metaDC;
      else
	hDC = GetDC(graph->handle);
   MoveTo(hDC, (int) mcb->Control[0], (int) mcb->Control[1]);
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d902 13
a914 22
/* new_line_attr							   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*	   hDC	 - A MS-WINDOWS handle to the device context of the window */
/*	   args  - The list of arguments for the graphics commands that    */
/*		   need to draw lines when executing. Eg. LineTo, Arc, etc */
/*									   */
/* Function :-								   */
/*	The function looks at the first argument to see if any of the line */
/*	attributes have changed. If the first argument is 1 the line	   */
/*	attributes have changed. In this case, a new pen is created, using */
/*	the next three arguments as arguments to the MS-WINDOWS CreatePen  */
/*	call. The previous pen is deleted, and the new pen selected into   */
/*	the device context. The function is called by all function that    */
/*	need to draw lines.						   */
/*									   */
/* Returns :-								   */
/*	Returns the number of arguments used. 1 if the line attributes did */
/*	not change, 4 if the line attributes have changed.		   */
d917 1
a917 4
int new_line_attr(graph, hDC, args)
   Graphnode *graph;
   HDC	     hDC;
   word      *args;
d919 11
a929 9
   HPEN  new_pen, old_pen;   /* Used to create the new line drawing pen */

   if ((int) args[0] eq 0) return(1);	/* attr. have not changed */
      else {
	   new_pen = CreatePen((int) args[2], (int) args[3], args[1]);
	   old_pen = SelectObject(hDC, new_pen);
	   if (!graph->meta_on) DeleteObject(old_pen);
	   return(4);
       }
d934 11
a944 18
/* line_to			message number = 3			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS call LineTo. The command needs   */
/*	two arguments. A further argument is supplied, indicating any	   */
/*	change in the line attributes. If the line attributes have changed */
/*	three further arguments are supplied. The line attribute arguments */
/*	are addressed by the new_line_attr function.			   */
/*	The arguments are in the data vector of the message.		   */
/*	The commands from the transputer are buffered.			   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d947 1
a947 2
void line_to(graph)
   Graphnode *graph;
d949 2
a950 5
   HDC	hDC;
   word far *args = (word far *) mcb->Data;  /* arguments for commands */
   int	ct,	   /* a counter */
	index,	   /* to index into the buffered arguments */
	num_cmds = (int) mcb->Control[0];   /* No. of buffered commands */
d952 4
a955 4
   Request_Return(ReplyOK, 0L, 0L);
   if (graph->meta_on) hDC = graph->metaDC;
      else
	 hDC = GetDC(graph->handle);
d957 4
a960 8
   for (ct = 0; ct < num_cmds; ct++) {
     index = new_line_attr(graph, hDC, args);	/* have line attr. changed */
     args += index;
     LineTo(hDC, (int) args[0], (int) args[1]);
     args += 2;
   }
   if (!graph->meta_on)
     ReleaseDC(graph->handle, hDC);
d965 12
a976 19
/* draw_line			message number = 4			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS calls MoveTo and LineTo. The	   */
/*	command needs four arguments. A further argument is supplied,	   */
/*	indicating any change in the line attributes. If the line	   */
/*	attributes have changed three further arguments are supplied. The  */
/*	line attribute arguments are addressed by the new_line_attr	   */
/*	function.							   */
/*	The arguments are in the data vector of the message.		   */
/*	The commands from the transputer are buffered.			   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d979 1
a979 2
void draw_line(graph)
   Graphnode *graph;
d981 1
a981 5
   HDC	hDC;
   word far *args = (word far *) mcb->Data;   /* arguments for the command */
   int	ct,	    /* a counter */
	index,	    /* used to index into the list of arguments */
	num_cmds = (int) mcb->Control[0];  /* No. of buffered commands */
d983 5
a987 4
   Request_Return(ReplyOK, 0L, 0L);
   if (graph->meta_on) hDC = graph->metaDC;
      else
	 hDC = GetDC(graph->handle);
d989 17
a1005 9
   for (ct = 0; ct < num_cmds; ct++) {
     index = new_line_attr(graph, hDC, args);	  /* line attr. changed? */
     args += index;
     MoveTo(hDC, (int) args[0], (int) args[1]);  /* Draw line using MoveTo and */
     LineTo(hDC, (int) args[2], (int) args[3]);  /* LineTo */
     args += 4;
   }
   if (!graph->meta_on)
     ReleaseDC(graph->handle, hDC);
d1010 12
a1021 18
/* write_text			message number = 5			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS call TextOut. The function needs */
/*	three arguments. A further argument is supplied indicating a	   */
/*	change in the text color. If the text color is to change, then a   */
/*	further argument is supplied, giving the text color.		   */
/*	The arguments are in the control vector of the message. The text   */
/*	string to be written is in the data vector. The commands from the  */
/*	transputer are not buffered.					   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1024 1
a1024 2
void write_text(graph)
   Graphnode *graph;
d1026 3
a1028 3
   HDC	 hDC;
   word  *args = &mcb->Control[0];
   int	 num_chars;
d1031 13
a1043 3
   if (graph->meta_on) hDC = graph->metaDC;
     else
	hDC = GetDC(graph->handle);
d1045 17
a1061 5
   num_chars = (int) args[3];	 /* Number of characters to be written */
   if (args[2] ne 0) {		/* Has text color changed? */
     SetTextColor(hDC, args[3]);  /* Yes, so set new text color */
     num_chars = (int) args[4];
   }
d1063 1
a1063 4
   TextOut(hDC, (int) args[0], (int) args[1], mcb->Data, num_chars);
   if (!graph->meta_on)
     ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);   /* always return success */
d1068 11
a1078 28
/* draw_poly_line		message number = 6			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls either the PolyLine, or the Polygon, MS-WINDOWS */
/*	calls. The function performs the PolyLine, or FillPoly Graphics    */
/*	Library calls. Each commands arguments have a mode field, giving   */
/*	the function to be performed, i.e. FillPoly, or PolyLine. There    */
/*	will also be an argument saying how many points define the	   */
/*	polyline, or Polygonal region. There is a futher argument	   */
/*	indicating any change in the line attributes. If the line	   */
/*	attributes have changed, three further arguments are supplied,	   */
/*	giving the changed attributes. The line attributes are handled by  */
/*	the new_line_attr function. Finally, each command will have all    */
/*	points defining the polyline or polygonal region. All arguments    */
/*	are in the data vector. 					   */
/*	The points defining the polyline or polygonal region have been	   */
/*	compressed, so that each point (ie. two integer values) is stored  */
/*	in one 32 bit word, or 4 bytes in the data vector.		   */
/*	The commands from the transputer are buffered. The number of	   */
/*	buffered commands is in the first word of the control vector.	   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1081 1
a1081 2
void draw_poly_line(graph)
   Graphnode *graph;
d1083 15
a1097 7
   HDC	       hDC;
   word        far * args = (word far *) mcb->Data; /* arguments for function */
   int	       mode,	     /* PolyLine or Polygon */
	       num_pts,      /* no. of points defining polyline or polygonal region */
	       index,	     /* value returned from new_line_attr. Also a counter */
	       ct,	     /* a counter */
	       num_cmds = (int) mcb->Control[0]; /* no. of buffered commands */
d1099 1
a1099 20

   if (graph->meta_on) hDC = graph->metaDC;
      else
	 hDC = GetDC(graph->handle);
   for (ct = 0; ct < num_cmds; ct++) {
     mode = (int) args[0];
     args++;
     index = new_line_attr(graph, hDC, args); /* line attr. changed? */
     args += index;
     num_pts = (int) args[0];
     args++;
     if (mode eq 0)
	Polyline(hDC, (LPPOINT) args, num_pts);
     else
	Polygon(hDC, (LPPOINT) args, num_pts);
     args += num_pts;
   }
   Request_Return(ReplyOK, 0L, 0L);  /* always return success */
   if (!graph->meta_on)
     ReleaseDC(graph->handle, hDC);
d1102 1
d1104 11
a1114 21
/* draw_rectangle		message number = 7			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls either the Rectangle or the Ellipse, MS-WINDOWS */
/*	calls. Each commands arguments have a mode field, giving the	   */
/*	function to be performed, i.e. Rectangle or Ellipse. The functions */
/*	need four arguments. There is a futher argument indicating any	   */
/*	change in the line attributes. If the line attributes have changed */
/*	three further arguments are supplied, giving the changed	   */
/*	attributes. The line attributes are handled by the new_line_attr   */
/*	function.							   */
/*	The arguments are in the data vector.				   */
/*	The commands from the transputer are buffered.			   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1117 1
a1117 2
void draw_rectangle(graph)
   Graphnode *graph;
d1119 15
a1133 5
   HDC	hDC;
   word far *args = (word far *) mcb->Data; /* arguments */
   int	ct,	       /* a counter */
	index,	       /* value returned from new_line_attr */
	num_cmds = (int) mcb->Control[0];  /* no. of buffered commands */
d1135 2
a1136 4
   Request_Return(ReplyOK, 0L, 0L);    /* always return success */
   if (graph->meta_on) hDC = graph->metaDC;
     else
       hDC = GetDC(graph->handle);
a1137 1
   for (ct = 0; ct < num_cmds; ct++) {
d1139 13
a1151 2
     index = new_line_attr(graph, hDC, args);	/* line attr. changed? */
     args += index;
d1153 4
a1156 7
     if (args[0] eq 0) {
       Rectangle(hDC, (int) args[1], (int) args[2], (int) args[3],
		      (int) args[4]);
     }
     else
       Ellipse(hDC, (int) args[1], (int) args[2], (int) args[3],
		    (int) args[4]);
d1158 1
a1158 4
     args += 5;
   }
   if (!graph->meta_on)
     ReleaseDC(graph->handle, hDC);
d1163 12
a1174 20
/* do_arc_functions		message number = 8			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls either the Arc, Chord or Pie MS-WINDOWS calls.  */
/*	Each commands arguments have a mode field, giving the function to  */
/*	be performed, i.e. Arc, Chrod or Pie. The functions need four	   */
/*	arguments. There is a futher argument indicating any change in the */
/*	line attributes. If the line attributes have changed three further */
/*	arguments are supplied, giving the changed attributes. The line    */
/*	attributes are handled by the new_line_attr function.		   */
/*	The arguments are in the data vector.				   */
/*	The commands from the transputer are buffered.			   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1177 1
a1177 2
void do_arc_functions(graph)
   Graphnode *graph;
d1179 3
a1181 5
   HDC	hDC;
   word far *args = (word far *) mcb->Data;   /* arguments */
   int	ct,	  /* a counter */
	index,	  /* value returned from new_line_attr */
	num_cmds = (int) mcb->Control[0];  /* no. of buffered commands */
d1183 7
a1189 4
   Request_Return(ReplyOK, 0L, 0L);   /* always return success */
   if (graph->meta_on) hDC = graph->metaDC;
      else
	hDC = GetDC(graph->handle);
a1190 1
   for (ct = 0; ct < num_cmds; ct++) {
d1192 12
a1203 2
      index = new_line_attr(graph, hDC, args);	 /* line attr. changed */
      args += index;
d1205 5
a1209 15
      switch ((int) args[0]) {	  /* What function must we do? */
	case 1	: Arc(hDC, (int) args[1], (int) args[2], (int) args[3],
		      (int) args[4], (int) args[5], (int) args[6],
		       (int) args[7], (int) args[8]);
		  break;
	case 2	: Chord(hDC, (int) args[1], (int) args[2], (int) args[3],
			(int) args[4], (int) args[5], (int) args[6],
			(int) args[7], (int) args[8]);
		  break;
	case 3	: Pie(hDC, (int) args[1], (int) args[2], (int) args[3],
		      (int) args[4], (int) args[5], (int) args[6],
		      (int) args[7], (int) args[8]);
		  break;
	default : break;
      }
d1211 8
a1218 1
      args += 9;
d1220 1
a1220 2
   if (!graph->meta_on)
     ReleaseDC(graph->handle, hDC);
d1223 1
d1225 11
a1235 14
/* Set_Bk_Color 		message number = 9			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS call, SetBkColor. The function   */
/*	needs one argument. The argument is in the control vector.	   */
/*	The command from the transputer is not buffered.		   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1238 1
a1238 3

void Set_Bk_Color(graph)
   Graphnode *graph;
d1240 17
a1256 1
   HDC	 hDC;
d1258 1
a1258 6
   if (graph->meta_on) hDC = graph->metaDC;
      else
	hDC = GetDC(graph->handle);
   SetBkColor(hDC, mcb->Control[0]);
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d1261 1
d1263 11
a1273 14
/* Set_Bk_Mode			message number = 10			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS call, SetBkMode. The function    */
/*	needs one argument. The argument is in the control vector.	   */
/*	The command from the transputer is not buffered.		   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1276 1
a1276 2
void Set_Bk_Mode(graph)
   Graphnode *graph;
d1278 17
a1294 1
   HDC hDC;
d1296 1
a1296 6
   if (graph->meta_on) hDC = graph->metaDC;
     else
	hDC = GetDC(graph->handle);
   SetBkMode(hDC, (int) mcb->Control[0]);
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d1299 1
d1301 10
a1310 15
/* Set_Fill_Styles		message number = 11			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS calls, CreateSolidBrush or	   */
/*	CreateHatchBrush, and SelectObject. The function requires two	   */
/*	arguments, and they are in the control vector. The command from    */
/*	the transputer is not buffered. 				   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1313 1
a1313 2
void Set_Fill_Styles(graph)
   Graphnode *graph;
d1315 2
a1316 3
   HDC	  hDC;
   HBRUSH new_brush, old_brush;
   word   *args = &mcb->Control[0];   /* arguments */
d1318 2
a1320 4
   if (args[0] < 2) new_brush = CreateSolidBrush(args[1]);  /* solid fill style */
      else
	new_brush = CreateHatchBrush((int) args[0] - 2, args[1]);  /* hatched */
							      /* fill style */
a1321 14
   if (graph->meta_on) hDC = graph->metaDC;
      else
	 hDC = GetDC(graph->handle);
   if (graph->Brush eq (HBRUSH) 0)    /* select brush into DC. If a brush has */
      SelectObject(hDC, new_brush);   /* previously been created, it must be */
     else {			      /* deleted.			     */
	old_brush = SelectObject(hDC, new_brush);
	if (!graph->meta_on) DeleteObject(old_brush);
     }
   if (!graph->metaDC) ReleaseDC(graph->handle, hDC);
   graph->Brush = new_brush;
   Request_Return(ReplyOK, 0L, 0L);
}

d1323 11
a1333 14
/* Set_Fill_Mode		message number = 12			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS call, SetPolyFillMode. The	   */
/*	function needs one argument, which is in the control vector.	   */
/*	The command from the transputer is not buffered.		   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1336 1
a1336 2
void Set_Fill_Mode(graph)
   Graphnode *graph;
d1338 3
a1340 1
   HDC hDC;
d1342 5
a1346 6
   if (graph->meta_on) hDC = graph->metaDC;
      else
	 hDC = GetDC(graph->handle);
   SetPolyFillMode(hDC, (int) mcb->Control[0]);
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d1349 1
d1351 13
a1363 16
/* Text_Ops			message number = 13			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS calls, SetTextAlign, or	   */
/*	SetTextCharacterExtra. The command from the transputer has a mode  */
/*	field, indicating which MS-WINDOWS call should be performed. There */
/*	is one further argument. The mode and argument is in the control   */
/*	vector. The command from the transputer is not buffered.	   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1366 1
a1366 2
void Text_Ops(graph)
   Graphnode *graph;
d1368 8
a1375 2
   HDC	 hDC;
   word  *args = &mcb->Control[0];   /* arguments */
d1378 15
a1392 3
   if (graph->meta_on) hDC = graph->metaDC;
     else
       hDC = GetDC(graph->handle);
d1394 20
a1413 7
   switch ((int) args[0]) {
     case 0  : SetTextCharacterExtra(hDC, (int) args[1]);
	       break;
     case 1  : SetTextAlign(hDC, (int) args[1]);
	       break;
     default : break;
   }
d1415 1
a1415 2
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d1418 1
d1420 14
a1433 16
/* Font_Ops			message number = 14			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function must either select one of MS-WINDOWS' stock fonts, or */
/*	create a new font. For a stock font the font identifier will be in */
/*	the control vector. To create a font, the LOGFONT structure will   */
/*	be in the data vector. The command from the transputer is not	   */
/*	buffered.							   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1436 2
a1437 2
void Font_Ops(graph)
   Graphnode *graph;
d1439 4
a1442 3
   LOGFONT far *font;
   HFONT       new_font, old_font;
   HDC	       hDC;
d1444 9
a1452 8

   if (graph->meta_on) hDC = graph->metaDC;
     else
       hDC = GetDC(graph->handle);
   if ((int) mcb->Control[0] ne 15) {	 /* stock fonts */
      new_font = GetStockObject((int) mcb->Control[0]);
      SelectObject(hDC, new_font);
      graph->hFont = (HFONT) 0;
d1454 1
a1454 12
   else {		/* create a font */
      font = (LOGFONT far *) mcb->Data;
      if (!graph->meta_on) old_font = graph->hFont;
      new_font = CreateFontIndirect(font);
      SelectObject(hDC, new_font);
      if (!graph->meta_on) {
	if (old_font ne (HFONT) 0) DeleteObject(old_font);
	graph->hFont = new_font;
      }
   }
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d1457 1
d1459 14
a1472 14
/* DefineMapMode		message number = 15			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function defines the mapping mode for a window. The function   */
/*	needs one argument from the transputer. The argument is in the	   */
/*	control vector. The command from the transputer is not buffered.   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1475 2
a1476 2
void DefineMapMode(graph)
   Graphnode *graph;
d1478 1
a1478 1
   HDC hDC;
d1480 9
a1488 6
   if (graph->meta_on) hDC = graph->metaDC;
     else
       hDC = GetDC(graph->handle);
   SetMapMode(hDC, (int) mcb->Control[0]);
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d1491 1
d1493 17
a1509 16
/* DefineOrigins		message number = 16			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function defines the window and viewport origins in a window.  */
/*	The function takes three arguments. The first indicating the	   */
/*	MS-WINDOWS call, the others the parameters for the MS-WINDOWS call.*/
/*	The arguments are in the control vector.			   */
/*	The command from the transputer is not buffered.		   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
d1512 2
a1513 2
void DefineOrigins(graph)
   Graphnode *graph;
d1515 1
a1515 1
   HDC hDC;
d1517 29
a1545 9
   if (graph->meta_on) hDC = graph->metaDC;
      else
	 hDC = GetDC(graph->handle);
   if ((int) mcb->Control[0] eq 0)   /* Which MS-WINDOWS call? */
     SetWindowOrg(hDC, (int) mcb->Control[1], (int) mcb->Control[2]);
   else
     SetViewportOrg(hDC, (int) mcb->Control[1], (int) mcb->Control[2]);
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
a1547 18
/***************************************************************************/
/* DefineExtents		message number = 17			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function defines the window and viewport extents in a window.  */
/*	The function takes three arguments. The first indicating the	   */
/*	MS-WINDOWS call, the others the parameters for the MS-WINDOWS call.*/
/*	The arguments are in the control vector.			   */
/*	The command from the transputer is not buffered.		   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
/***************************************************************************/
d1549 1
a1549 2
void DefineExtents(graph)
   Graphnode *graph;
d1551 5
a1555 1
   HDC hDC;
d1557 7
a1563 9
   if (graph->meta_on) hDC = graph-> metaDC;
      else
	hDC = GetDC(graph->handle);
   if ((int) mcb->Control[0] eq 0)  /* Which MS-WINDOWS call? */
     SetWindowExt(hDC, (int) mcb->Control[1], (int) mcb->Control[2]);
   else
     SetViewportExt(hDC, (int) mcb->Control[1], (int) mcb->Control[2]);
   if (!graph->meta_on) ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d1566 5
d1572 4
a1575 17
/***************************************************************************/
/* fill_area			message number = 23			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function fills a rectangular area in the desired color. The    */
/*	function takes five arguments, four for the rectangle, and one for */
/*	the color. The arguments are in the data buffer.		   */
/*	The commands from the trasnputer are buffered.			   */
/*									   */
/* Returns :-								   */
/*	Always returns success. 					   */
/***************************************************************************/
d1577 2
a1578 2
void fill_area(graph)
   Graphnode *graph;
d1580 13
a1592 6
   HDC	  hDC;
   word   far *args = (word far *) mcb->Data;	/* arguments */
   RECT   rect;
   HBRUSH brush;
   int	  num_cmds = (int) mcb->Control[0],  /* No. of buffered commands */
	  ct;	  /* a counter */
d1594 10
a1603 10
   hDC = GetDC(graph->handle);
   for (ct = 0; ct < num_cmds; ct++) {
     SetRect(&rect, (int) args[0], (int) args[1], (int) args[2], (int) args[3]);
     brush = CreateSolidBrush(args[4]);
     FillRect(hDC, &rect, brush);
     DeleteObject(brush);
     args += 5;
   }
   ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d1606 12
d1619 4
a1622 15
/***************************************************************************/
/* graph_size			message number = 18			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function returns the size of the client area of a window.	   */
/*	The size of the window is returned in the control vector.	   */
/*									   */
/* Returns :-								   */
/*	The size of the window. 					   */
/***************************************************************************/
d1624 11
a1634 2
void graph_size(graph)
   Graphnode *graph;
d1636 4
a1639 1
   RECT rect;
d1641 8
a1648 4
   GetClientRect(graph->handle, &rect);
   mcb->Control[0] = (word) rect.right;
   mcb->Control[1] = (word) rect.bottom;
   Request_Return(ReplyOK, 2L, 0L);
a1651 14
/* graph_cur_pos		message number = 19			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function returns the position of the graphics cursor in a	   */
/*	window. The position of the graphics cursor is returned in the	   */
/*	control vector. 						   */
/*									   */
/* Returns :-								   */
/*	The position of the graphics cursor.				   */
d1653 12
d1666 2
a1667 2
void graph_cur_pos(graph)
   Graphnode *graph;
d1669 3
a1671 8
   HDC	 hDC;
   DWORD pos;

   hDC = GetDC(graph->handle);
   pos = GetCurrentPosition(hDC);
   ReleaseDC(graph->handle, hDC);
   mcb->Control[0] = (word) LOWORD(pos);
   mcb->Control[1] = (word) HIWORD(pos);
d1673 1
d1676 5
a1680 15
/***************************************************************************/
/* text_dimensions		message number = 20			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function returns the characteristics of the curent font in a   */
/*	window. The text dimensions are returned in the control vector.    */
/*									   */
/* Returns :-								   */
/*	The characteristics of the current font.			   */
/***************************************************************************/
d1682 46
a1727 2
void text_dimensions(graph)
   Graphnode *graph;
d1729 12
a1740 2
   HDC	      hDC;
   TEXTMETRIC tm;
d1742 3
a1744 3
   hDC = GetDC(graph->handle);
   GetTextMetrics(hDC, &tm);
   ReleaseDC(graph->handle, hDC);
d1746 3
a1748 6
   mcb->Control[0] = tm.tmHeight;
   mcb->Control[1] = tm.tmAveCharWidth;
   mcb->Control[2] = tm.tmAscent;
   mcb->Control[3] = tm.tmDescent;
   mcb->Control[4] = tm.tmInternalLeading;
   mcb->Control[5] = tm.tmExternalLeading;
d1750 36
a1785 1
   Request_Return(ReplyOK, 6L, 0L);
d1788 8
a1795 17
/***************************************************************************/
/* get_extents			message number = 24			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function returns the window or viewport extents depending on   */
/*	mode defined by the first word of the control vector.		   */
/*									   */
/*	The extents are returned in the control vector. 		   */
/*									   */
/* Returns :-								   */
/*	The window or viewport extents. 				   */
/***************************************************************************/
d1797 13
a1809 2
PRIVATE void get_extents(graph)
   Graphnode *graph;
d1811 2
a1812 2
   HDC	 hDC = GetDC(graph->handle);
   DWORD extent;
a1813 4
   if (mcb->Control[0] eq 0)
     extent = GetWindowExt(hDC);
   else
     extent = GetViewportExt(hDC);
d1815 20
a1834 4
   ReleaseDC(graph->handle, hDC);
   mcb->Control[0] = (word) LOWORD(extent);
   mcb->Control[1] = (word) HIWORD(extent);
   Request_Return(ReplyOK, 2L, 0L);
d1837 5
d1843 6
a1848 22
/***************************************************************************/
/* display_bit_map		message number = 22			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function recieves a description of the bitmap from the	   */
/*	transputer. The description of the bitmap is in the first four	   */
/*	words of the control vector. The bits representing the bitmap are  */
/*	in the data vector. The function will then create the bitmap and   */
/*	display it, starting at the point specified by the fifth and sixth */
/*	arguments. The function will return the co-ordinates of the next   */
/*	open scan line in the window.					   */
/*									   */
/* Returns :-								   */
/*	If the bitmap is drawn, returns success, if it not drawn, returns  */
/*	failure. Also returns the co-ordinates of the next available scan  */
/*	line.								   */
/***************************************************************************/
d1851 2
a1852 2
PRIVATE void display_bit_map(graph)
   Graphnode *graph;
d1854 3
a1856 3
   HBITMAP  hbitmap;
   BITMAP   bm;
   HDC	    memDC, hDC, bitDC;
d1858 6
a1863 3
   hbitmap = CreateBitmap((int) mcb->Control[0], (int) mcb->Control[1],
			  (BYTE) mcb->Control[2], (BYTE) mcb->Control[3],
			  (LPSTR) mcb->Data);
d1865 27
a1891 11
   if (hbitmap eq 0) {	  /* unable to create the bitmap */
     Request_Return(EC_Error + SS_IOProc + EG_NoMemory + EO_Server, 0L, 0L);
     return;
   }
   hDC	 = GetDC(graph->handle);
   memDC = CreateCompatibleDC(hDC);
   if (memDC eq 0) {		/* unable to create memory device context */
     Request_Return(EC_Error + SS_IOProc + EG_NoMemory + EO_Server, 0L, 0L);
     ReleaseDC(graph->handle, hDC);
     DeleteObject(hbitmap);
     return;
d1893 4
d1898 12
a1909 6
   SelectObject(memDC, hbitmap);
   GetObject(hbitmap, sizeof(BITMAP), (LPSTR) &bm);
      /* draw the bitmap */
   if (graph->meta_on) bitDC = graph->metaDC;
      else
	  bitDC = hDC;
d1911 12
a1922 11
   if (!BitBlt(bitDC, (int) mcb->Control[4], (int) mcb->Control[5],
	  (int) bm.bmWidth, (int) bm.bmHeight, memDC, 0, 0, mcb->Control[6])) {
      DeleteDC(memDC);
      DeleteObject(hbitmap);
      ReleaseDC(graph->handle, hDC);
      Request_Return(EC_Error + SS_IOProc + EG_NoMemory + EO_Server, 0L, 0L);
      return;
   }
   mcb->Control[0] = mcb->Control[4];	 /* co-ordinates of next free scan */
   mcb->Control[1] = mcb->Control[5] + (long) bm.bmHeight;	/* line */
   Request_Return(ReplyOK, 2L, 0L);
d1924 12
a1935 3
   DeleteDC(memDC);	      /* delete memory device and bitmap */
   DeleteObject(hbitmap);
   ReleaseDC(graph->handle, hDC);
d1938 11
d1950 18
a1967 16
/***************************************************************************/
/* clear_graph			message number = 25			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function clears the window, using the default background color */
/*	WHITE, and frees the list of files used to store the contents of   */
/*	the window.							   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d1969 12
a1980 2
void clear_graph(graph)
   Graphnode *graph;
d1982 7
a1988 2
   HDC	    hDC;
   RECT     rect;
d1990 9
a1998 5
   GetClientRect(graph->handle, &rect);   /* clear the window */
   hDC = GetDC(graph->handle);
   DPtoLP(hDC, (LPPOINT) &rect, 2);	  /* get logical points */
   FillRect(hDC, &rect, GetClassWord(graph->handle, GCW_HBRBACKGROUND));
   MoveTo(hDC, 0, 0);
d2000 9
a2008 2
   ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d2011 13
a2023 15
/***************************************************************************/
/* position_cursor		message number = 26			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function moves the mouse cursor to the position defined in the */
/*	first two words of the control vector.				   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2025 2
a2026 2
PRIVATE void position_cursor(graph)
   Graphnode *graph;
d2028 14
a2041 3
   SetCursorPos((int) mcb->Control[0], (int) mcb->Control[1]);
   Request_Return(ReplyOK, 0L, 0L);
   use(graph);
d2044 9
a2052 15
/***************************************************************************/
/* clip_cursor			message number = 27			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function restricts the mouse cursor to the rectangle defined   */
/*	in the first four words of the control vector.			   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2054 2
a2055 2
PRIVATE void clip_cursor(graph)
   Graphnode *graph;
d2057 7
a2063 1
   RECT  rect;
d2065 19
a2083 5
   SetRect(&rect, (int) mcb->Control[0], (int) mcb->Control[1],
		  (int) mcb->Control[2], (int) mcb->Control[3]);
   ClipCursor(&rect);
   Request_Return(ReplyOK, 0L, 0L);
   use(graph);
d2086 9
a2094 15
/***************************************************************************/
/* set_cursor			message number = 28			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function changes the shape of the mouse cursor to that defined */
/*	in the first word of the control vector.			   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2096 2
a2097 2
PRIVATE void set_cursor(graph)
   Graphnode *graph;
d2099 8
a2106 2
   HCURSOR  cursor;
   int	    shape = (int) mcb->Control[0];
d2108 10
a2117 7
   cursor = LoadCursor(NULL, MAKEINTRESOURCE(shape));
   if (cursor != (HCURSOR) NULL) {
     SetCursor(cursor);
     SetClassWord(graph->handle, GCW_HCURSOR, cursor);
   }
   Request_Return(ReplyOK, 0L, 0L);
   use(graph);
d2120 12
a2131 19
/***************************************************************************/
/* get_max_block		message number = 29			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function detemines the maximum message size allowed by the PC  */
/*	server. If the amount of memory left is greater than the message   */
/*	buffer of the server, then the value returned to the transputer is */
/*	the size of the message buffer. If the amount of memory left is    */
/*	less than the size of the message buffer, then the amount of	   */
/*	memory left is returned to the server.				   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2133 2
a2134 2
PRIVATE void get_max_block(graph)
   Graphnode *graph;
d2136 11
a2146 1
   long memleft;
d2148 12
a2159 7
   memleft = GlobalCompact(0L) / 2;    /* memory left div 2 */
   if (memleft < 8192) memleft = 0;    /* if only 8K left, forget about it!! */
   if (memleft < 0) memleft = 0;
   if (memleft > maxdata) mcb->Control[0] = maxdata; /* message buffer size */
      else
	  mcb->Control[0] = memleft;
   Request_Return(ReplyOK, 1L, 0L);
d2162 9
a2170 16
/***************************************************************************/
/* get_meta_name							   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   name - The full path name of a file. 			   */
/*									   */
/* Function :-								   */
/*	The function decodes the file name, converting it from the Helios  */
/*	format, to a DOS format. It is basically a copy of the routine	   */
/*	get_local_name, with a few minor alterations. get_local_name can   */
/*	be found in the file files.c.					   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2172 10
d2183 2
a2184 2
void get_meta_name(name)
   LPSTR name;
d2186 8
a2193 1
  LPSTR tempptr = mcb->Data, destptr;
d2195 7
a2201 5
  for ( ; *tempptr ne '/' && *tempptr ne '\0'; tempptr++);
  if (tempptr eq mcb->Data) {
     tempptr++;
     for ( ; *tempptr ne '/' && *tempptr ne '\0'; tempptr++);
  }
d2203 1
a2203 18
  if (*tempptr eq '\0')
    { if (!strcmp(mcb->Data, "helios"))
	strcpy(name, Heliosdir);
      else
	{ strcpy(name, mcb->Data);
	  strcat(name, ":");
        }
    }
  else
    { *tempptr = '\0';
      if (!strcmp(mcb->Data, "helios"))
	strcpy(name, Heliosdir);
      else
	{ strcpy(name, mcb->Data);
	  strcat(name, ":");
        }
      *tempptr++ = '/';
    }
d2205 1
a2205 7
  destptr = name + strlen(name);
  for (; *tempptr ne '\0'; )
   { *destptr++ = '\\';
     for (; *tempptr ne '\0' && *tempptr ne '/'; )
       *destptr++ = *tempptr++;
     if (*tempptr eq '/') tempptr++;
   }
d2207 4
a2210 1
  *destptr = '\0';
d2212 8
a2219 8
  tempptr--;
  if (*tempptr eq '/') *tempptr = '\0';  /* Strip trailing / */
  for ( ; (tempptr > mcb->Data) && (*tempptr ne '/'); tempptr--)
    if (*tempptr eq '.')  /* and allow only three characters after . */
     { tempptr++; tempptr++; tempptr++; tempptr++;
       *tempptr = '\0';
       break;
     }
d2221 1
a2221 11
  for (tempptr = name, destptr = name; *tempptr ne '\0';
       tempptr++ )
   if (isalnum(*tempptr))
    *destptr++ = *tempptr;
   else if((*tempptr eq ':') || (*tempptr eq '\\') ||
           (*tempptr eq '.') || (*tempptr eq '$') || (*tempptr eq '%') ||
	   (*tempptr eq '\'') || (*tempptr eq '_') || (*tempptr eq '@@') ||
           (*tempptr eq '{') || (*tempptr eq '}') || (*tempptr eq '~') ||
	   (*tempptr eq (UBYTE) 0x60) || (*tempptr eq '!') || (*tempptr eq '#') ||
	   (*tempptr eq '-') || ((uint) *tempptr >= (UBYTE) 0x0080) )
	*destptr++ = *tempptr;
d2223 1
a2223 1
  *destptr = '\0';
d2225 8
d2235 11
a2246 23
/***************************************************************************/
/* create_meta_file		message number = 32			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS function CreateMetaFile to	   */
/*	create a metafile. The name of the metafile is passed in the data  */
/*	vector. If no name is supplied by the transputer, then the	   */
/*	gets a temporary file name, using the function GetTempFileName,    */
/*	stores this file name in the meta_name field of the Graphnode	   */
/*	structure. When the metafile is to be deleted, the temporary file  */
/*	name is extracted from the meta_name field, and is removed from    */
/*	the disk.							   */
/*	The function returns the metafile handle created by WINDOWS to the */
/*	transputer.							   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2248 14
d2264 2
a2265 2
PRIVATE void create_meta_file(graph)
   Graphnode *graph;
d2267 8
a2274 3
   char        *name;	      /* to store the metafile file name */
   int	       tempname = 0;  /* flag to say if we used a temporary file */
   LOCALHANDLE hmem;
d2276 10
a2285 6
   hmem = LocalAlloc(LMEM_FIXED, (uint) 80);
   if (hmem eq (LOCALHANDLE) 0) {
      Request_Return(EC_Error + SS_IOProc + EG_NoMemory + EO_Server, 0L, 0L);
      return;
   }
   name = LocalLock(hmem);
d2287 8
a2294 1
   mcb->Data[(int) mcb->MsgHdr.DataSize] = '\0';
d2296 10
a2305 10
   if (mcb->MsgHdr.DataSize ne 0) {
     tempname++;
     get_meta_name(name);	/* convert file name supplied */
   }
   else {
     clear_meta_name(graph);	     /* no name supplied */
     GetTempFileName(0, "MF", 0, name); /* so get a temporary file name */
     graph->meta_name	= name;
     graph->meta_handle = hmem;
   }
d2307 9
a2315 12
   graph->metaDC = CreateMetaFile(name);
   if ((!graph->metaDC) || (tempname)) {
      LocalUnlock(hmem);
      LocalFree(hmem);
      if (!tempname) {
	graph->meta_name = NULL;
	graph->handle	 = 0;
      }
    }
   if (graph->metaDC ne (HDC) 0) graph->meta_on = 1;
   mcb->Control[0] = (word) graph->metaDC;  /* return handle */
   Request_Return(ReplyOK, 1L, 0L);
d2318 8
d2327 8
a2334 18
/***************************************************************************/
/* close_meta_file		message number = 33			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS function CloseMetaFile and	   */
/*	DeleteMetaFile to close the metafile and free the memory taken up  */
/*	by the metafile on the PC. The metafile is identified by the	   */
/*	argument supplied by the transputer in the control vector. This    */
/*	should be the handle returned by the call to CreateMetaFile.	   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2336 10
d2347 2
a2348 2
PRIVATE void close_meta_file(graph)
   Graphnode *graph;
d2350 6
a2355 2
   HANDLE hMF;
   HDC	  metaDC;
d2357 8
a2364 5
   metaDC = (HDC) mcb->Control[0];
   hMF	  = CloseMetaFile(metaDC);
   DeleteMetaFile(hMF);
   graph->meta_on = 0;
   Request_Return(ReplyOK, 0L, 0L);
d2367 10
d2378 10
a2387 18
/***************************************************************************/
/* get_meta_file		message number = 34			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS function GetMetaFile. The name   */
/*	of the metafile is supplied in the data vector. If no name is	   */
/*	supplied, then the temporary name stored in the meta_name field of */
/*	the Graphnode structure is used. The handle returned by the	   */
/*	GetMetaFile call, is returned to the transputer.		   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2389 10
d2400 2
a2401 2
PRIVATE void get_meta_file(graph)
   Graphnode *graph;
d2403 7
a2409 2
   char   name[80];
   HANDLE hMF;
d2411 9
a2419 1
   mcb->Data[(int) mcb->MsgHdr.DataSize] = '\0';
d2421 9
a2429 10
   if (mcb->MsgHdr.DataSize ne 0) get_meta_name(name);
      else {
	if (graph->meta_name eq NULL) {
	    mcb->Control[0] = 0L;
	    Request_Return(ReplyOK, 1L, 0L);
	    return;
	}
	else
	  strcpy(name, graph->meta_name);
      }
d2431 8
a2438 3
   hMF = GetMetaFile(name);
   mcb->Control[0] = (word) hMF;
   Request_Return(ReplyOK, 1L, 0L);
d2441 11
d2453 11
a2463 17
/***************************************************************************/
/* play_meta_file		message number = 35			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS function PlayMetaFile. The	   */
/*	metafile is identified by the argument supplied in the first word  */
/*	of the control vector. This is the handle returned by the call to  */
/*	GetMetaFile.							   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2465 11
d2477 2
a2478 2
PRIVATE void play_meta_file(graph)
   Graphnode *graph;
d2480 8
a2487 2
   HANDLE hMF;
   HDC	  hDC;
d2489 8
a2496 9
   hMF = (HANDLE) mcb->Control[0];
   if (hMF eq (HANDLE) 0) {
      Request_Return(ReplyOK, 0L, 0L);
      return;
   }
   hDC = GetDC(graph->handle);
   PlayMetaFile(hDC, hMF);
   ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 0L, 0L);
d2499 8
d2508 9
a2516 17
/***************************************************************************/
/* delete_meta_file		message number = 36			   */
/*									   */
/* Parameters :-							   */
/*									   */
/*	   graph - A pointer to the Graphnode structure associated with    */
/*		   a graphic window.					   */
/*									   */
/* Function :-								   */
/*	The function calls the MS-WINDOWS function DeleteMetaFile. The	   */
/*	metafile is identified by the argument supplied in the first word  */
/*	of the control vector. This is the handle returned by the call to  */
/*	GetMetaFile.							   */
/*									   */
/* Returns :-								   */
/*	Nothing.							   */
/***************************************************************************/
d2518 9
d2528 2
a2529 2
PRIVATE void delete_meta_file(graph)
   Graphnode *graph;
d2531 6
a2536 1
   HANDLE hMF;
d2538 8
a2545 7
   hMF = (HANDLE) mcb->Control[0];
   if (hMF eq (HANDLE) 0) {
      Request_Return(ReplyOK, 0L, 0L);
      return;
   }
   DeleteMetaFile(hMF);
   Request_Return(ReplyOK, 0L, 0L);
d2548 10
d2559 9
a2567 9
/**************************************************************************/
/*									  */
/*   Function : do_message_box		     Message Number : 21	  */
/*									  */
/*   The function displays a message box, as defined by the Helios	  */
/*   Graphics Library. The result of the message box will be returned to  */
/*   the graphics library.						  */
/*									  */
/**************************************************************************/
d2569 9
d2579 2
a2580 2
PRIVATE void do_message_box(graph)
   Graphnode *graph;
d2582 6
a2587 3
   LPSTR mess_text, cap_text;
   int	 retval, text_len = (int) mcb->Control[0],
	 cap_len = (int) mcb->Control[1];
d2589 10
a2598 4
   mess_text	       = mcb->Data;
   mess_text[text_len] = '\0';
   cap_text	       = &(mcb->Data[text_len + 1]);
   cap_text[cap_len]   = '\0';
d2600 10
a2609 2
   retval = MessageBox(graph->handle, mess_text, cap_text,
		       (WORD) mcb->Control[2]);
d2611 9
a2619 2
   mcb->Control[0] = (word) retval;
   Request_Return(ReplyOK, 1L, 0L);
d2622 10
d2633 19
a2651 8
/**************************************************************************/
/*									  */
/*   Function : select_palette	       Message Number = 30		  */
/*									  */
/*   The function creates and selects a new logical palette into a	  */
/*   windows device context.						  */
/*									  */
/**************************************************************************/
d2653 19
d2673 2
a2674 2
PRIVATE void select_palette(graph)
   Graphnode *graph;
d2676 9
a2684 4
   LOGPALETTE far *Pal = (LOGPALETTE far *) mcb->Data;
   HPALETTE   hPal;
   HDC	      hDC;
   word       success;
d2686 161
a2846 3
   if (graph->hPal ne (HPALETTE) 0) {
      UnrealizeObject(hPal);
      graph->hPal = (HPALETTE) 0;
d2848 5
d2854 16
a2869 8
   hPal = CreatePalette(Pal);
   if (hPal ne (HPALETTE) 0) {
      hDC = GetDC(graph->handle);
      SelectPalette(hDC, hPal, 0);	/* include palette in device context */
      RealizePalette(hDC);
      ReleaseDC(graph->handle, hDC);
      graph->hPal = hPal;
      success = 1;
d2871 5
a2875 2
   else
      success = 0;
d2877 13
a2889 2
   mcb->Control[0] = success;
   Request_Return(ReplyOK, 1L, 0L);
d2892 12
d2905 10
a2914 7
/****************************************************************************/
/*									    */
/*   Function : unselect_palette	 Message Number = 31		    */
/*									    */
/*   The function removes a selected palette from a windows device context  */
/*									    */
/****************************************************************************/
d2916 10
d2927 2
a2928 2
PRIVATE void unselect_palette(graph)
   Graphnode *graph;
d2930 6
a2935 1
   int ret_val;
d2937 9
a2945 1
   if (graph->hPal eq (HPALETTE) 0) mcb->Control[0] = 1;
d2947 124
a3070 4
   ret_val = UnrealizeObject(graph->hPal);
   if (ret_val) {
      graph->hPal = (HPALETTE) 0;
      mcb->Control[0] = 1L;
d3073 1
a3073 1
      mcb->Control[0] = 0L;
d3075 6
a3080 1
   Request_Return(ReplyOK, 1L, 0L);
d3083 13
d3097 10
d3108 1
a3108 7
/*************************************************************************/
/*									 */
/*   Function : get_text_extent      Message Number = 37		 */
/*									 */
/*   The function returns the width and height of a given text string	 */
/*									 */
/*************************************************************************/
d3110 25
a3134 2
PRIVATE void get_text_extent(graph)
   Graphnode *graph;
d3136 5
a3140 1
   HDC	hDC;
d3142 15
a3156 4
   hDC = GetDC(graph->handle);
   mcb->Control[0] = GetTextExtent(hDC, mcb->Data, mcb->MsgHdr.DataSize);
   ReleaseDC(graph->handle, hDC);
   Request_Return(ReplyOK, 1L, 0L);
d3159 13
d3173 1
d3175 13
a3187 9
/**************************************************************************/
/*									  */
/*   Function : send_char_key						  */
/*									  */
/*   The function sends a character back to Helios, via the msevent event */
/*   handler. The event will contain the actual character pressed, and	  */
/*   the state of the alt, control and shift keys.			  */
/*									  */
/**************************************************************************/
d3189 5
a3193 4
PRIVATE void send_char_key(hWnd, key, status)
   HWND hWnd;
   WORD key;
   LONG status;
d3195 5
d3201 4
a3204 3
   Graphnode *graph;
   short     control, alt, shift, key_state = 0;
   LONG      word1, word2;
d3206 12
a3217 2
   graph = find_graph(hWnd);
   if (graph eq (Graphnode *) NULL) return;
d3219 2
a3220 4
   get_key_status(status, &shift, &alt, &control);
   if (control) key_state += 1;
   if (alt)	key_state += 2;
   if (shift)	key_state += 4;
d3222 11
a3232 2
   word1 = MAKELONG(key, key_state);
   word2 = 0L;
d3234 15
a3248 1
   new_msevent(KeyPress, graph->window_id, word1, word2);
d3251 16
d3268 1
a3268 9
/**************************************************************************/
/*									  */
/*   Function : send_sys_key						  */
/*									  */
/*   The function sends a character back to Helios, via the msevent event */
/*   handler. The event will contain the Windows virtual key pressed, and */
/*   the state of the alt, control and shift keys.			  */
/*									  */
/**************************************************************************/
d3270 12
a3281 4
PRIVATE void send_sys_key(hWnd, key, status)
   HWND hWnd;
   WORD key;
   LONG status;
d3283 2
d3286 6
a3291 3
   Graphnode *graph;
   short     control, alt, shift, key_state = 0;
   LONG      word1, word2;
d3293 11
a3303 2
   graph = find_graph(hWnd);
   if (graph eq (Graphnode *) NULL) return;
d3305 8
a3312 25
   switch (key) {
     case VK_F1     :
     case VK_F2     :
     case VK_F3     :
     case VK_F4     :
     case VK_F5     :
     case VK_F6     :
     case VK_F7     :
     case VK_F8     :
     case VK_F9     :
     case VK_F10    :
     case VK_UP     :
     case VK_DOWN   :
     case VK_LEFT   :
     case VK_RIGHT  :
     case VK_INSERT :
     case VK_HOME   :
     case VK_PRIOR  :
     case VK_DELETE :
     case VK_END    :
     case VK_NEXT   :
		     get_key_status(status, &shift, &alt, &control);
		     if (control) key_state += 1;
		     if (alt)	  key_state += 2;
		     if (shift)   key_state += 4;
d3314 1
a3314 2
		     word1 = MAKELONG(key, key_state);
		     word2 = 1L;
d3316 7
a3322 2
		     new_msevent(KeyPress, graph->window_id, word1, word2);
		     break;
d3324 27
a3350 1
     default	    : break;
d3352 8
d3362 10
d3373 11
a3383 8
/***************************************************************************/
/*									   */
/*   Function : send_paint_request					   */
/*									   */
/*   The function sends an event to the Helios Graphics Library, informing */
/*   the library that a section of a graphics window needs to be repainted */
/*									   */
/***************************************************************************/
d3385 10
d3396 2
a3397 3
PRIVATE void send_paint_request(hWnd, ps)
   HWND 	   hWnd;
   PAINTSTRUCT far *ps;
d3399 6
a3404 2
   Graphnode *graph = find_graph(hWnd);
   LONG      word1, word2;
d3406 9
a3414 1
   if (graph eq (Graphnode *) NULL) return;
d3416 10
a3425 2
   word1 = MAKELONG(ps->rcPaint.left, ps->rcPaint.top);
   word2 = MAKELONG(ps->rcPaint.right, ps->rcPaint.bottom);
d3427 8
a3434 1
   new_msevent(RepaintRequest, graph->window_id, word1, word2);
d3437 8
d3446 10
a3455 9
/***************************************************************************/
/*									   */
/*   Function : send_resize_request					   */
/*									   */
/*   The function sends a message to the Helios Graphics Library,	   */
/*   informing the library of the new size of a graphics window, should    */
/*   the size of a graphics window change.				   */
/*									   */
/***************************************************************************/
d3457 8
d3466 2
a3467 4
PRIVATE void send_resize_request(hWnd, mode, size)
   HWND hWnd;
   WORD mode;
   LONG size;
d3469 5
a3473 1
   Graphnode *graph = find_graph(hWnd);
d3475 9
a3483 1
   if (graph eq (Graphnode *) NULL) return;
d3485 10
a3494 1
   if (mode eq SIZEICONIC) size = -1L;
d3496 11
a3506 1
   new_msevent(ResizeRequest, graph->window_id, size, 0L);
d3509 9
d3519 9
d3529 12
a3540 3
/* This is the procedure called by MS-WINDOWS to process messages generated */
/* for windows opened by the graphics server. The only messages intercepted */
/* here are the mouse and keyboard messages.				    */
d3542 2
a3543 5
long FAR PASCAL GraphProc(hWnd, iMessage, wParam, lParam)
    HWND     hWnd;
    unsigned iMessage;
    WORD     wParam;
    LONG     lParam;
d3545 7
a3551 4
   Graphnode	*graph;
   PAINTSTRUCT	ps;
   static SHORT x = 0, y = 0;
   HDC		hDC;
d3553 9
a3561 1
   switch (iMessage) {
d3563 14
a3576 9
      case WM_MOUSEMOVE :
		    if (MsMouse_Active) {
		       graph = find_graph(hWnd);
		       if (graph eq (Graphnode *) NULL) break;
		       x = LOWORD(lParam);
		       y = HIWORD(lParam);
		       new_msmouse(x, y, Buttons_Unchanged, graph->window_id);
		    }
		    break;
d3578 6
a3583 7
      case WM_LBUTTONDOWN :
		    if (MsMouse_Active) {
		       graph = find_graph(hWnd);
		       if (graph eq (Graphnode *) NULL) break;
		       new_msmouse(x, y, Buttons_Button0_Down, graph->window_id);
		    }
		    break;
d3585 8
a3592 7
      case WM_LBUTTONUP :
		    if (MsMouse_Active) {
		       graph = find_graph(hWnd);
		       if (graph eq (Graphnode *) NULL) break;
		       new_msmouse(x, y, Buttons_Button0_Up, graph->window_id);
		    }
		    break;
d3594 5
a3598 7
      case WM_RBUTTONDOWN :
		    if (MsMouse_Active) {
		       graph = find_graph(hWnd);
		       if (graph eq (Graphnode *) NULL) break;
		       new_msmouse(x, y, Buttons_Button1_Down, graph->window_id);
		    }
		    break;
d3600 8
a3607 7
      case WM_RBUTTONUP :
		    if (MsMouse_Active) {
		       graph = find_graph(hWnd);
		       if (graph eq (Graphnode *) NULL) break;
		       new_msmouse(x, y, Buttons_Button1_Up, graph->window_id);
		    }
		    break;
d3609 8
a3616 7
      case WM_MBUTTONDOWN :
		    if (MsMouse_Active) {
		       graph = find_graph(hWnd);
		       if (graph eq (Graphnode *) NULL) break;
		       new_msmouse(x, y, Buttons_Button2_Down, graph->window_id);
		    }
		    break;
d3618 7
a3624 7
      case WM_MBUTTONUP :
		    if (MsMouse_Active) {
		       graph = find_graph(hWnd);
		       if (graph eq (Graphnode *) NULL) break;
		       new_msmouse(x, y, Buttons_Button2_Up, graph->window_id);
		    }
		    break;
d3626 2
a3627 4
      case WM_CHAR :
		 if (MsEvent_Active)
		    send_char_key(hWnd, wParam, lParam);
		 break;
d3629 11
a3639 4
      case WM_KEYUP :
		 if (MsEvent_Active)
		    send_sys_key(hWnd, wParam, lParam);
		 break;
d3641 10
a3650 4
       case WM_SYSKEYUP :
		 if (MsEvent_Active)
		    send_sys_key(hWnd, wParam, lParam);
		 break;
a3651 6
       case WM_PAINT :
		 BeginPaint(hWnd, &ps);
		 if (MsEvent_Active)
		    send_paint_request(hWnd, (PAINTSTRUCT far *) &ps);
		 EndPaint(hWnd, &ps);
		 break;
d3653 3
a3655 4
       case WM_SIZE  :
		 if (MsEvent_Active)
		    send_resize_request(hWnd, wParam, lParam);
		 break;
d3657 7
a3663 16
       case WM_QUERYNEWPALETTE :
		 graph = find_graph(hWnd);
		 if (graph eq (Graphnode *) NULL) return(0);
		 if (graph->hPal eq (HPALETTE) 0) return(0);
		 hDC = GetDC(hWnd);
		 SelectPalette(hDC, graph->hPal, 0);
		 if (RealizePalette(hDC)) {
		    ReleaseDC(hWnd, hDC);
		    InvalidateRect(hWnd, (LPRECT) NULL, 1);
		    return(1);
		 }
		 else {
		    ReleaseDC(hWnd, hDC);
		    return(0);
		 }
		 break;
d3665 72
a3736 1
      default	    : return(DefWindowProc(hWnd, iMessage, wParam, lParam));
d3738 1
d3742 1
a3742 1
#endif	/* MSWINDOWS */
@


1.1
log
@Initial revision
@
text
@d203 1
a203 1
  if (!lstrcmp(IOname, "graphics")) {	  /* Stream for the server? */
d252 1
a252 1
   if (!lstrcmp(IOname, "graphics")) {	/* Locate the server */
d295 1
a295 1
  if (!lstrcmp(IOname, "graphics")) {	/* Cannot delete the server */
d460 1
a460 1
   if (!lstrcmp(IOname, "graphics")) {	  /* Info on the graphics server */
d463 1
a463 1
      lstrcpy(Heliosinfo->obj.DirEntry.Name, "graphics");
d494 1
a494 1
      lstrcpy(Heliosinfo->obj.DirEntry.Name, graph->node.direntry.Name);
d665 1
a665 1
   lstrcpy(&(new_graph->node.direntry.Name[0]), temp);	/* insert name of */
@
