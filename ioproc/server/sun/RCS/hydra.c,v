head	1.18;
access;
symbols
	Helios_1_3_1:1.18
	Helios_C40_1_3_Official_Release:1.16
	Helios-C40:1.16
	Alenia_release:1.10
	Helios1_3:1.10
	C40_Field_Test_2:1.10
	C40_Field_Test_R1:1.9
	Helios13_beta:1.9
	Helios1_2_2:1.7
	Helios1_2_2Beta:1.6
	Helios1_2_1:1.4;
locks; strict;
comment	@ * @;


1.18
date	93.09.28.12.24.05;	author bart;	state Exp;
branches;
next	1.17;

1.17
date	93.05.13.11.33.57;	author bart;	state Exp;
branches;
next	1.16;

1.16
date	93.03.23.15.15.08;	author bart;	state Exp;
branches;
next	1.15;

1.15
date	93.02.25.15.08.07;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	93.02.09.14.06.58;	author bart;	state Exp;
branches;
next	1.13;

1.13
date	93.02.05.15.02.50;	author bart;	state Exp;
branches;
next	1.12;

1.12
date	93.02.05.14.39.22;	author bart;	state Exp;
branches;
next	1.11;

1.11
date	93.01.12.15.58.37;	author bart;	state Exp;
branches;
next	1.10;

1.10
date	92.10.09.12.25.37;	author martyn;	state Exp;
branches;
next	1.9;

1.9
date	92.06.22.11.40.38;	author martyn;	state Exp;
branches;
next	1.8;

1.8
date	92.03.06.11.52.58;	author martyn;	state Exp;
branches;
next	1.7;

1.7
date	91.10.02.15.54.55;	author martyn;	state Exp;
branches;
next	1.6;

1.6
date	91.07.22.14.15.59;	author martyn;	state Exp;
branches;
next	1.5;

1.5
date	91.06.06.10.08.46;	author martyn;	state Exp;
branches;
next	1.4;

1.4
date	90.11.27.15.07.13;	author alan;	state Exp;
branches;
next	1.3;

1.3
date	90.10.17.13.51.21;	author alan;	state Exp;
branches;
next	1.2;

1.2
date	90.10.17.09.58.47;	author alan;	state Exp;
branches;
next	1.1;

1.1
date	90.10.17.09.23.34;	author alan;	state Exp;
branches;
next	;


desc
@Hydra Link Daemon
@


1.18
log
@Added the debugflags variable as port of the Parsytec integration
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--         H E L I O S   I N P U T / O U T P U T   S E R V E R          --
--         ---------------------------------------------------          --
--                                                                      --
--         Copyright (C) 1989, Perihelion Software Ltd.                 --
--                       All Rights Reserved.                           --
--                                                                      --
--  hydra.c                                                             --
--                                                                      --
--  Author:  BLV 8/6/89                                                 --
--                                                                      --
------------------------------------------------------------------------*/
/* RcsId: $Id: hydra.c,v 1.17 1993/05/13 11:33:57 bart Exp $ */
/* Copyright (C) 1989, Perihelion Software Ltd.       			*/

/**
*** This program supports access to links over the ethernet, using 
*** TCP/IP sockets.
**/

/*{{{  header files, declarations, etc. */
#define Daemon_Module

/**
*** Different levels of debugging may be compiled in.
***
*** 0 -> no debugging
*** 1 -> limited debugging only
*** 2 -> most debugging
*** 3 -> everything, lots of debugging even when idle
**/
#define debug 0

#ifdef ARMBSD
#include "helios.h"
#else
#include "../helios.h"
#endif
#include "../sccs.h"

#if (0)
	/* was needed for RISCiX 1.1 */
#include <pwd.h>
char *cuserid(buf)
char *buf;
{ struct passwd *pw = getpwuid(getuid());
  strcpy(buf, pw->pw_name);
  return(buf);
}
#endif

/*@@@@@@ 16.05.90 */
#define TIMEOUT_VALUE 100  /* gives 10 seconds for inmos compatible links */
/**
*** The link daemon is linked with module sun/linklib.c and any
*** hardware-specific modules, e.g. sun/kpar.c on a Sun386,
*** b011.c & b014.c & b016.c & niche.c on Sun3 and Sun4, etc.
*** Access to the link I/O functions is by indirecting through a set
*** of pointers, which are set up by the resetlnk() routine in
*** module sun/linklib.c
**/
extern int (*open_link_fn)();
extern void (*free_link_fn)();
int  (*rdrdy_fn)();
int  (*wrrdy_fn)();
int  (*byte_to_link_fn)();
int  (*byte_from_link_fn)();
int  (*send_block_fn)();
int  (*fetch_block_fn)();
void (*reset_fn)();
void (*analyse_fn)();

/**
*** To keep the code slightly more legible, these macros indirect
*** through the above function pointers.
**/
#define open_link         (*open_link_fn)
#define free_link         (*free_link_fn)
#define rdrdy             (*rdrdy_fn)
#define wrrdy             (*wrrdy_fn)
#define byte_to_link      (*byte_to_link_fn)
#define byte_from_link    (*byte_from_link_fn)
#define send_block        (*send_block_fn)
#define fetch_block       (*fetch_block_fn)
#define reset_processor   (*reset_fn)
#define analyse_processor (*analyse_fn)

/**
*** Various variables are needed to link with sun/linklib.c, these
*** are in the header file server.h in the I/O Server.
**/
int                Server_Mode = Mode_Daemon;
jmp_buf            exit_jmpbuf;
int                current_link = 0;
int                number_of_links = 1;
int                transputer_site = 0;
PRIVATE Trans_link first_link;
Trans_link         *link_table = &(first_link);
bool               C40HalfDuplex = FALSE;
word               target_processor = Processor_C40;
char	           *bootstrap;
word               bootsize;
word               debugflags	= 0;

/**
*** Here are various variables specific to Hydra. Hydra can have two
*** different types of connections, Server connections and Debugging
*** connections from Hydramon. At present I allow for 64 of the former,
*** and 4 for the latter. The table con_table contains details of the
*** Server connections, e.g. the user name and location. The table
*** debug_table does something similar for the Debugging connections,
*** but less information is needed. These limits are rather generous
*** given the probable amount of available hardware and the restricted
*** number of file descriptors available, but never mind.
**/
#define MaxConnections 64         /* Maximum number of link conections       */
                                  /* Telmat SM90 has up to 48 link adapters  */
                                  /* which is the current record */
#define Max_debug_connections 4   /* allow up to 4 hydramon sessions */

socket_msg con_table[MaxConnections];  /* to hold all the connections */

typedef struct debug_connection {
        WORD   fildes;
        WORD   flags;
} debug_connection;
debug_connection debug_table[Max_debug_connections];
#define Debugtab_Free 0x0001

/**
*** Here is a buffer for holding messages. 512K is a bit excessive,
*** but Hydra will only run on Unix boxes with plenty of virtual
*** memory. 64K is not enough because the buffer may be used to hold
*** a system image larger than a Helios message.
**/
UBYTE big_buffer[512 * 1024]; 

/**
*** Here are some variables to hold the connection and socket details.
*** family_type can be AF_UNIX or AF_INET. For Unix sockets, socket_name
*** will contain the name of the socket extracted from the configuration
*** file. last_connection holds the last time when a Server connected.
*** During the initial bootstrap phase there is so much link traffic that
*** Hydra can get overloaded, so a delay is enforced between connections.
*** This delay is obtained from the configuration file, defaulting to
*** 10 seconds. Finally, my_socket is the socket on which Hydra waits
*** for new connections.
**/
PRIVATE int family_type = AF_UNIX;
PRIVATE char *socket_name;
PRIVATE WORD last_connection = 0;
PRIVATE WORD connection_delay;
PRIVATE int my_socket;

/**
*** This may be set inside a signal routine
**/
PRIVATE int Special_Exit = 0;

/**
*** Like the I/O Server, Hydra reads in a configuration file.
*** The default file name is hydra.con, but this may be overwritten
*** using a command-line argument.
**/
/*@@@@@@ 16.05.90 */
PRIVATE char *configname = "hydra.con";


/**
*** Various function prototypes.
**/
PRIVATE int  fn( read_config, (char *));
PRIVATE void fn( tidy_config, (void));
PRIVATE void fn( create_socket, (void));
PRIVATE void fn( main_loop, (void));
PRIVATE void fn( initialise_signals, (void));
void fn( socket_broken, (int));
/*}}}*/
/*{{{  main() */

/**
*** And at long last some code. First the jump buffer is initialised so
*** that an exit is possible at all times. Next the copyright message
*** is displayed. The arguments are processed to look for a
*** configuration file, and the configuration file is read in.
***
*** Next the Unix signal mechanism is effectively disabled to stop
*** nasties from happening. In addition an alarm signal is set to go
*** off at regular intervals, aborting any blocked link I/O. 
***
*** The routine resetlnk() in sun/linklib.c initialises the link
*** hardware. It determines which links are available and stores
*** this data in link_table. All the links are set to unused if they
*** appear to exist but cannot be opened, or free if they can be
*** opened succesfully - in the latter case the link is actually
*** free_link'ed, to allow other programs access to it while Hydra
*** is running. After resetlnk() all the connections are set to -1,
*** indicating that nobody owns the link, and the debug connections
*** are also initialised.
***
*** create_socket() installs the program as a daemon, which can be
*** accessed by clients. It sets my_socket to a value which can
*** be used to wait for incoming connections. Then the daemon detaches
*** itself from the current process group, i.e. it turns itself into
*** a true daemon. If this succeeds
*** the daemon can print out a success message, and enter its
*** main loop. At present there is no way to exit the main loop,
*** or to restart the daemon, but this may prove useful in the
*** future.
**/
int main(argc, argv)
int argc;
char *argv[];
{ int  i;
  char *curr_arg;
  int  return_code;
  int childpid;

  if ((return_code = setjmp(exit_jmpbuf)) ne 0) goto endpoint;
  printf("Helios Link Daemon - Hydra. %s%s",SccsId1, SccsId5);

  for (i=1; i<argc; i++)
    { curr_arg = argv[i];
      if (curr_arg[0] eq '-')
       if ((curr_arg[1] eq 'C') || (curr_arg[1] eq 'c'))
        { if (curr_arg[2] ne '\0')
           configname = &(curr_arg[2]);
          elif (++i < argc)
           configname = argv[i];
        }
    }

/*@@@@@@ 16.05.90 */
  if (!read_config(configname)) {
	  printf ("usage : hydra [ -c <pathname of configuration file>]\n");
	  goto endpoint;
  }

  connection_delay = get_int_config("connection_delay");
  if (connection_delay eq Invalid_config)
   connection_delay = 10;  /* 10 second default */

  initialise_signals();

  resetlnk();

  for (i = 0; i < number_of_links; i++)
   link_table[i].connection = -1;

  for (i = 0; i < Max_debug_connections; i++)
   debug_table[i].flags = Debugtab_Free;

  create_socket();

  printf("Hydra: running on %d link%s.\n", number_of_links,
	 (number_of_links != 1) ? "s" : "");

  switch(fork())
	{
	case 0:		/* child */
#if (TR5 || i486V4 || HP9000)
		setpgrp();	/* new session */
#else
		setpgrp(getpid(), 0);	/* new session */
#endif
		setuid(geteuid());	/* run as set-uid bit says */
		setgid(getegid());	/* run as set-gid bit says */
		break;

	case -1:	/* can't fork */
		printf("Hydra : can't fork daemon, continuing\n");
		break;

	default:
		exit(0);
	}

  main_loop();

  if (family_type eq AF_UNIX)
    unlink(socket_name);

  /* Release all links here */

endpoint:
  tidy_config();

  return(return_code);
}
/*}}}*/
/*{{{  signal handling */

/**
*** Signal handling. Some signals will cause an exit. The timer signal is
*** used to abort blocked link I/O.
**/
PRIVATE void exit_interrupt()
{ Special_Exit = 1;
}

PRIVATE void alarm_handler()
{
}

PRIVATE void initialise_signals()
{
#ifdef   SIGHUP
  signal(SIGHUP   , func(exit_interrupt));
#endif
#if (SM90)
#else
#ifdef   SIGINT
  signal(SIGINT   , func(exit_interrupt));
#endif
#endif
#ifdef   SIGQUIT
/*  signal(SIGQUIT  , func(exit_interrupt));   leave a back door for safety */
/* kill -3 hydra will give a core dump */
#endif  
#ifdef   SIGILL
  signal(SIGILL   , SIG_IGN);
#endif
#ifdef   SIGTRAP
  signal(SIGTRAP  , SIG_IGN);
#endif
#ifdef   SIGEMT
  signal(SIGEMT   , SIG_IGN);
#endif
#ifdef   SIGFPE
  signal(SIGFPE   , SIG_IGN);
#endif
#ifdef   SIGBUS
  signal(SIGBUS   , SIG_IGN);
#endif
#if 0
				/* leave this one open */
#ifdef   SIGSEGV
  signal(SIGSEGV  , SIG_IGN);
#endif
#endif
#ifdef   SIGKILL
  signal(SIGKILL  , func(exit_interrupt));
#endif
#ifdef   SIGSYS
  signal(SIGSYS   , SIG_IGN);
#endif
#ifdef   SIGPIPE
  signal(SIGPIPE  , SIG_IGN);
#endif
#ifdef   SIGALRM
#if (SM90 || TR5)
#else
  signal(SIGALRM  , func(alarm_handler));
  alarm(2);   /* force an alarm signal every couple of seconds, this */
              /* unblocks any blocking I/O */
#endif
#endif
#ifdef   SIGTERM
  signal(SIGTERM  , func(exit_interrupt));
#endif
#ifdef   SIGURG
  signal(SIGURG   , SIG_IGN);
#endif
#ifdef   SIGIO
  signal(SIGIO    , SIG_IGN);
#endif
#ifdef   SIGUSR1
  signal(SIGUSR1  , SIG_IGN);
#endif
#ifdef   SIGUSR2
  signal(SIGUSR2  , SIG_IGN);
#endif
#ifdef   SIGABRT
  signal(SIGABRT  , SIG_IGN);
#endif
#ifdef   SIGSTOP
  signal(SIGSTOP  , func(exit_interrupt));
#endif
#ifdef   SIGTSTP
  signal(SIGTSTP  , func(exit_interrupt));
#endif
#ifdef   SIGCONT
  signal(SIGCONT  , SIG_IGN);
#endif
#ifdef   SIGCHLD
  signal(SIGCHLD  , SIG_IGN);
#endif
#ifdef   SIGTTIN
  signal(SIGTTIN  , SIG_IGN);
#endif
#ifdef   SIGTTOU
  signal(SIGTTOU  , SIG_IGN);
#endif
#ifdef   SIGXCPU
  signal(SIGXCPU  , SIG_IGN);
#endif
#ifdef   SIGXFSZ
  signal(SIGXFSZ  , SIG_IGN);
#endif
#ifdef   SIGVTALRM
  signal(SIGVTALRM, SIG_IGN);
#endif
#ifdef   SIGPROG
  signal(SIGPROF  , SIG_IGN);
#endif
#ifdef   SIGWINCH
  signal(SIGWINCH , SIG_IGN);
#endif
#ifdef   SIGLOST
  signal(SIGLOST  , SIG_IGN);
#endif
}
/*}}}*/
/*{{{  create the daemon's socket */

/**
*** This routine creates a socket on which the link daemon waits for
*** incoming requests. The socket may be a Unix one or an internet
*** one, and is a TCP/IP stream socket.
**/
PRIVATE void create_socket()
{
  char *family_name = get_config("family_name");
  int family_type = AF_UNIX;

  socket_name = get_config("socket_name");

  if (family_name eq (char *) NULL)
   family_name = "AF_UNIX";

  if (!mystrcmp(family_name, "AF_UNIX"))
   family_type = AF_UNIX;
  elif(!mystrcmp(family_name, "AF_INET"))
   family_type = AF_INET;
  else
   { printf("Hydra : unknown family type %s in configuration file\n",
            family_name);
     longjmp(exit_jmpbuf, 1);
   }

  my_socket = socket(family_type, SOCK_STREAM, 0);
  if (my_socket < 0)
   { perror("Hydra : failed to create socket");
     longjmp(exit_jmpbuf, 1);
   }

  if (family_type eq AF_UNIX)
   { struct sockaddr_un addr;
     addr.sun_family = AF_UNIX;
     strcpy(addr.sun_path,
            (socket_name eq (char *) NULL) ? "hydra.skt" : socket_name);
     if (bind(my_socket, &addr, 
          strlen(addr.sun_path) + sizeof(addr.sun_family) ) eq -1)
      { perror("Hydra : failed to bind socket");
        longjmp(exit_jmpbuf, 1);
      }     
   }
  else
   { struct sockaddr_in addr;
     struct servent     *sp;

     sp = getservbyname("hydra", "tcp");
     if (sp eq NULL)
      { printf("Hydra has not been allocated a socket port on this machine.\n");
        printf("Please edit the file /etc/services\n");
        longjmp(exit_jmpbuf, 1);
      }

     bzero((char *) &addr, sizeof(struct sockaddr_in));
     addr.sin_addr.s_addr   = INADDR_ANY;
     addr.sin_port   = sp->s_port;
     if (bind(my_socket, &addr, sizeof(struct sockaddr_in)) eq -1)
      { perror("Hydra : failed to bind socket");
        longjmp(exit_jmpbuf, 1);
      }
   }


  setsockopt(my_socket, SOL_SOCKET, SO_REUSEADDR, 10, 0);
  
  if (listen(my_socket, 5) ne 0)
   { perror("Hydra : failed to listen on socket");
     longjmp(exit_jmpbuf, 1);
   }
}
/*}}}*/
/*{{{  main loop */
/**
*** This is the main loop of the link daemon. It waits for new connections,
*** data ready on any of the links currently in use, requests from any of
*** the I/O Servers currently connected, or requests from Hydramon. Life is
*** made rather complicated by the fact that not all link interfaces support
*** select and that not all systems support microsecond timeouts.
***
*** The first job is to examine all possible link devices. Links that are not
*** currently in use by Hydra or that should never be used by Hydra are
*** ignored. Also if the I/O Server has been informed already that data
*** is available then there is no point in testing this link again until the
*** I/O Server has sent an appropriate request. If the link supports select()
*** then the appropriate file descriptor is added to the select() mask.
*** Otherwise the select() timeout is reduced to allow polling and the link
*** is checked for data.
***
*** In addition to the links it is necessary to check the sockets from all
*** connected I/O Servers, the socket used to accept new connections, and
*** any debug connections from Hydramon. All of these are supported by
*** select().
***
*** Once the select() has returned it is possible to check which sources of
*** data are ready and invoke appropriate handlers.
**/

PRIVATE void fn( accept_connection, (void));
PRIVATE void fn( accept_debug_connection, ( WORD, socket_msg *));
PRIVATE void fn( from_debug, (int));
PRIVATE void fn( from_transputer, (int));
PRIVATE void fn( from_server, (int));
PRIVATE void fn( message_from_transputer, (int));
PRIVATE void fn( message_from_server, (int));
PRIVATE jmp_buf again;

PRIVATE void main_loop()
{ fd_set rd_mask;
  int    i;
  int    max_fd;
  struct timeval select_time;

  setjmp(again);

  forever
   { FD_ZERO(&rd_mask);
     max_fd = -1;

     select_time.tv_sec  = 0;
     select_time.tv_usec = 500000;   /* half a second delay */

     for (i = 0; i < number_of_links; i++)
      if (!(link_table[i].flags & (Link_flags_free | Link_flags_unused)))
       {
         unless(link_table[i].flags & Link_flags_datareadysent)
          {
            if (link_table[i].flags & Link_flags_not_selectable)
             {
               select_time.tv_usec = 1000;   /* need to poll the link */
               current_link = i;
               if (rdrdy())
                {
                  if (link_table[i].flags & Link_flags_messagemode)
                   message_from_transputer(i);
                  else
                   from_transputer(i);
                }
             }
            else
             { FD_SET(link_table[i].fildes, &rd_mask);
               if (link_table[i].fildes > max_fd) max_fd = link_table[i].fildes;
             }
          }

	 FD_SET(link_table[i].connection, &rd_mask);
	 if (link_table[i].connection > max_fd) max_fd=link_table[i].connection;
       }

#if SM90
     select_time.tv_sec = 1;
#endif

     FD_SET(my_socket, &rd_mask);
     if (my_socket > max_fd) max_fd = my_socket;

     for (i = 0; i < Max_debug_connections; i++)
      if (!(debug_table[i].flags & Debugtab_Free))
       { FD_SET(debug_table[i].fildes, &rd_mask);
         if (debug_table[i].fildes > max_fd) max_fd = debug_table[i].fildes;
       }

     i = select(max_fd+1, &rd_mask, NULL, NULL, &select_time);
#if (debug > 2)
     printf("Hydra : select returned %d\n", i);
#endif

#if (TR5)	/* le select n'a pas d'effet sur rd_mask su TR5 */
     if ( i == 0 )FD_ZERO(&rd_mask);	/* timeout select case */
#endif

     if (Special_Exit) return;
     if (i < 0)
      { if (errno ne EINTR) perror("Hydra : select failed");
        continue;
      }

     if (FD_ISSET(my_socket, &rd_mask))
         accept_connection();

     for (i = 0; i < Max_debug_connections; i++)
      if (!(debug_table[i].flags & Debugtab_Free))
       if (FD_ISSET(debug_table[i].fildes, &rd_mask))
         from_debug(i);
        
     for (i = 0; i < number_of_links; i++)
      if (!(link_table[i].flags & (Link_flags_free | Link_flags_unused)))
       {
  	  unless(link_table[i].flags & Link_flags_not_selectable)
           if (FD_ISSET(link_table[i].fildes, &rd_mask))
            {
              if (link_table[i].flags & Link_flags_messagemode)
               message_from_transputer(i);
              else
               from_transputer(i);
            }

         if (FD_ISSET(link_table[i].connection, &rd_mask))
	  {
	    if (link_table[i].flags & Link_flags_messagemode)
	     message_from_server(i);
	    else
             from_server(i);
          }
       }
   }     
}
/*}}}*/
/*{{{  accept new connection */

/**
*** This routine is called when the main select() indicates that some
*** new client is attempting to connect to the daemon. First there is
*** an accept() call, which should never fail because we know that
*** something is trying to connect. Next there is a read of a socket
*** message. This structure is defined in the header structs.h, and
*** contains lots of info. First, the request may be a debug connection
*** rather than an I/O Server connection, which is handled by a
*** separate routine. Note that the data transferred in socket_msg uses
*** the transputer's byte ordering, i.e. little-endian, which will have
*** to be swapped on 68000 and sparc machines using the normal swap()
*** macro. If the request is not a debug connection it comes from an
*** I/O Server, and the fun really starts.
***
*** The bootstrap phase of a transputer is very link-intensive. It
*** involves the nucleus, posix library, C library, init, network
*** server, task force manager, shell, and possibly a couple of other
*** programs. This will be noticeable by other users, because their
*** response time will increase. To avoid the worst of the problems
*** Hydra will only accept new connections every few seconds, the
*** exact amount being determined by the entry connection_delay in
*** the configuration file hydra.con . The I/O Server contains code to
*** print out suitable delay messages, and to retry a number of times.
***
*** Once past this hurdle, the request may be for any link. The routine
*** looks for a free link and tries to open it. If this succeeds the
*** link is now owned by that person. The link state is modified to
*** reflect this, and the connection table is filled in with the
*** owner's name, location, etc. A suitable reply message is generated.
*** If none of the links are currently available, an error message is
*** returned.
***
*** The alternative is that the request is for a specific link. If this
*** link is available, fine. Otherwise an error message is generated.
***
*** Note that if no link is available the connection is closed.
**/

PRIVATE void accept_connection()
{ int fil;
  struct sockaddr new_sockaddr;
  int temp, i;
  socket_msg con;
  WORD now = time((time_t *) NULL);

  temp = sizeof(struct sockaddr);

#if (debug > 0)
  printf("Hydra : accepting connection\n");
#endif
 
  fil = accept(my_socket, &new_sockaddr, &temp);
  if (fil < 0)
   { perror("Hydra : failed to accept connection on socket");
     return;
   }

  if (read(fil, (BYTE * ) &con, sizeof(socket_msg))
        < sizeof(socket_msg))
   { perror("Hydra : failed to read connection packet");
     shutdown(fil, 2);
     close(fil);
     return;
   }

  temp = swap(con.fnrc);

  if (temp eq Debug_Connection)
   { accept_debug_connection( fil, &con);
     return;
   }

  if ((now - last_connection) < connection_delay)
   { con.fnrc = swap(Hydra_Busy);
#if (debug > 0)
     printf("Hydra : busy, %d seconds since last connection\n",
            now - last_connection);
#endif
     if (write(fil, (BYTE *) &con, sizeof(socket_msg))
         < sizeof(socket_msg))
       perror("Hydra : failed to reply to Server");
     shutdown(fil, 2);
     close(fil);
     return;
   }

  if (temp eq Any_Link)
   {
#if (debug > 0)
     printf("Hydra : connecting to any link\n");
#endif 
     for (i = 0; i < number_of_links; i++)
      if (link_table[i].flags & Link_flags_free)
       { if ((*open_link_fn)(i) eq 0) continue;  /* not available */
#if (debug > 0)
         printf("Hydra : connected to link %d\n", i);
#endif
         con.fnrc = swap(i);
         if (write(fil, (BYTE *) &con, sizeof(socket_msg))
              < sizeof(socket_msg))
          { perror("Hydra : failed to reply to Server");
            shutdown(fil, 2);
            close(fil);
            return;
          }
         link_table[i].flags &= ~(Link_flags_free | Link_flags_uninitialised |
                                  Link_flags_firsttime);
         link_table[i].state = Link_Reset;
         link_table[i].connection = fil;
         memcpy((BYTE *) &(con_table[i]), (BYTE *) &con,
          sizeof(socket_msg));
         last_connection = now;
         return;
       }

#if (debug > 0)
     printf("Hydra : no link available\n");
#endif
     con.fnrc = swap(Link_Unavailable);
     if (write(fil, (BYTE *) &con, sizeof(socket_msg)) 
         < sizeof(socket_msg))
      perror("Hydra : failed to reply to Server");
     shutdown(fil, 2);
     close(fil);
     return;
   }
       
  if ((temp < 0) || (temp > number_of_links))
   { con.fnrc = swap(Invalid_Link);
#if (debug > 0)
     printf("Hydra : invalid link %d requested\n", temp);
#endif
     if (write(fil, (BYTE *) &con, sizeof(socket_msg))
          < sizeof(socket_msg))
      perror("Hydra : failed to reply to server");
     shutdown(fil, 2);
     close(fil);
     return;
   }

  if (link_table[temp].flags & Link_flags_free)
   { if (open_link_fn(temp) eq 0)
      goto fail;
#if (debug > 0)
     printf("Hydra : connected to link %d as requested\n", temp);
#endif
     if (write(fil, (BYTE *) &con, sizeof(socket_msg)) 
         < sizeof(socket_msg))
      { perror("Hydra : failed to reply to server");
        shutdown(fil, 2);
        close(fil);
        return;
      }
     memcpy((BYTE *) &(con_table[temp]), (BYTE *) &con, 
            sizeof(socket_msg));
     link_table[temp].flags &= ~(Link_flags_free | Link_flags_uninitialised |
                                 Link_flags_firsttime);
     link_table[temp].connection = fil;
     last_connection = now;
     return;
   }

fail:
#if (debug > 0)
  printf("Hydra : requested link %d unavailable\n", temp);
#endif
  con.fnrc = swap(Link_Unavailable);
  if (write(fil, (BYTE *) &con, sizeof(socket_msg)) 
      < sizeof(socket_msg))
   perror("Hydra : failed to reply to server");
  shutdown(fil, 2);
  close(fil); 
}

/**
*** This routine is called from accept_connection() above, if the
*** new connection is a debugging one from Hydramon. If a slot is
*** available in the debugging table, fine.
**/
PRIVATE void accept_debug_connection(fildes, con)
WORD fildes;
socket_msg *con;
{ int i;

#if (debug > 0)
  printf("Hydra : accepting debug connection\n");
#endif

  for (i = 0; i < Max_debug_connections; i++)
   if (debug_table[i].flags & Debugtab_Free)
    { con->fnrc  = swap(1);
      con->extra = swap(number_of_links);
      if (write(fildes, (BYTE *) con, sizeof(socket_msg))
          < sizeof(socket_msg))
       { perror("Hydra : failed to reply to hydramon");
         shutdown(fildes, 2);
         close(fildes);
         return;
       }
      debug_table[i].flags &= ~Debugtab_Free;
      debug_table[i].fildes = fildes;
      return;
    }

#if (debug > 0)
  printf("Hydra : all debug connections used\n");
#endif
  con->fnrc  = swap(Link_Unavailable);
  if (write(fildes, (BYTE *) con, sizeof(socket_msg))
      < sizeof(socket_msg))
    perror("Hydra : failed to reply to hydramon");
  shutdown(fildes, 2);
  close(fildes);
}
/*}}}*/
/*{{{  new protocol between root processor and I/O Server */

/**
*** If the root processor is trying to send some data then the I/O Server
*** should be informed. Hydra reads either a byte or a word from the link,
*** depending on the hardware, and includes this in the message. This avoids
*** problems with certain device drivers and improves the latency.
**/

PRIVATE void from_transputer(link)
int link;
{ Hydra_Message message;

  current_link = link;

  if (link_table[link].flags & Link_flags_word)
   { 
     if (fetch_block(4, message.Extra.Buf, TIMEOUT_VALUE))
     	return;
     link_table[link].last_send = *((int *) message.Extra.Buf);
#if (Debug > 1)
     printf("Hydra: sending DataReadyWord\n");
#endif
     message.FnRc	= swap(Hydra_DataReadyWord);
   }
  else
   {
     if (byte_from_link(message.Extra.Buf))
     	return;
     link_table[link].last_send = message.Extra.Buf[0];
#if (Debug > 1)
     printf("Hydra: sending DataReadyByte\n");
#endif
     message.FnRc	= swap(Hydra_DataReadyByte);
   }

  socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));

  link_table[link].flags |= Link_flags_datareadysent;

#if (Debug > 2)
  { struct timeval xyz;
    gettimeofday(&xyz, NULL);
    printf("Hydra: sent dataready at %d.%06d\n", xyz.tv_sec, xyz.tv_usec);
  }
  message.FnRc	= swap(Hydra_Nop);
  socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
#endif
}

/**
*** The I/O Server can send a number of different requests for interacting
*** with the link device. 
**/

PRIVATE void from_server(link)
int link;
{ Hydra_Message message;
  int		size;
  
  current_link = link;

  socket_read(link, (BYTE *) &message, sizeof(Hydra_Message));
  message.FnRc	= swap(message.FnRc);
  size		= swap(message.Extra.Size);

#if (debug > 1)
  printf("hydra: got request %x, size %d, flags & sent %x \n", message.FnRc, size, link_table[link].flags & Link_flags_datareadysent);
#endif

  switch(message.FnRc)
   {
   	case Hydra_ResetRequest :
   		reset_processor();
   		message.FnRc = swap(Hydra_ResetAck);
   		socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		link_table[link].flags &= ~Link_flags_datareadysent;
   		break;

   	case Hydra_AnalyseRequest :
   		analyse_processor();
   		message.FnRc = swap(Hydra_AnalyseAck);
   		socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		link_table[link].flags &= ~Link_flags_datareadysent;
   		break;

   	case Hydra_ReadRequest :
			/* If a byte/word has been sent already, allow for this.	*/
		if (link_table[link].flags & Link_flags_datareadysent)
			size -= (link_table[link].flags & Link_flags_word) ? 4 : 1;

			/* Is there anything still to read ?				*/
		if (size > 0)
		{
			/* Yes, try to read it.						*/
			if (fetch_block(size, big_buffer, TIMEOUT_VALUE))
			{
				message.FnRc = swap(Hydra_Broken);
				socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
			}
			else
			{
				message.FnRc = swap(Hydra_ReadAck);
				socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
				socket_write(link, (BYTE *) big_buffer, size);
			}
		}
			/* No, the I/O Server has already received the required		*/
			/* amount of data.						*/
		else
		{
			message.FnRc = swap(Hydra_ReadAck);
			socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		}
		link_table[link].flags &= ~Link_flags_datareadysent;
		break;

	case Hydra_WriteRequest :
		socket_read(link, big_buffer, size);
		if (send_block(size, big_buffer, TIMEOUT_VALUE))
			message.FnRc = swap(Hydra_Broken);
		else
			message.FnRc = swap(Hydra_WriteAck);
		socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		break;

	case Hydra_Done :
		shutdown(link_table[link].connection, 2);
		close(link_table[link].connection);
		link_table[link].connection = -1;
		free_link(link);
		link_table[link].flags |= (Link_flags_free + Link_flags_uninitialised);
		link_table[link].state = Link_Reset;
		link_table[link].flags &= ~Link_flags_datareadysent;
		return;

	case Hydra_WriteByte :
		if (byte_to_link(message.Extra.Buf[0]))
			message.FnRc = swap(Hydra_Broken);
		else
			message.FnRc = swap(Hydra_WriteAck);
		socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		break;
		
	case Hydra_WriteWord :
		if (send_block(4, message.Extra.Buf, TIMEOUT_VALUE))
			message.FnRc = swap(Hydra_Broken);
		else
			message.FnRc = swap(Hydra_WriteAck);
		socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		break;

	case Hydra_ReadByte :
			/* If a byte has been sent already, just clear the flag		*/
		if ((link_table[link].flags & Link_flags_datareadysent) eq 0)
		{
			if (byte_from_link(message.Extra.Buf))
				message.FnRc = swap(Hydra_Broken);
			else
				message.FnRc = swap(Hydra_ReadAck);
			socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		}
		link_table[link].flags &= ~Link_flags_datareadysent;
		break;

	case Hydra_ReadWord :
			/* Read word : this is complicated because it may not be	*/
			/* a word-based link. e.g. transputer peek and poke. Also Hydra	*/
			/* and the I/O Server may have different byte orderings.	*/
		if ((link_table[link].flags & Link_flags_word) &&
		    (link_table[link].flags & Link_flags_datareadysent))
		{
			/* The word has been sent already, no-op			*/
		}
		else
		{
			if (link_table[link].flags & Link_flags_datareadysent)
			{
					/* One byte already sent, three to go		*/
				if (fetch_block(3, &(message.Extra.Buf[1]), TIMEOUT_VALUE))
					message.FnRc	= swap(Hydra_Broken);
				else
					message.FnRc	= swap(Hydra_ReadAck);
			}
			else
			{
					/* nothing sent, four to go			*/
				if (fetch_block(4, message.Extra.Buf, TIMEOUT_VALUE))
					message.FnRc	= swap(Hydra_Broken);
				else
					message.FnRc	= swap(Hydra_ReadAck);
			}
			socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		}
		link_table[link].flags &= ~Link_flags_datareadysent;
		break;				

		/* Switch from new protocol to old message passing mode	*/
	case Hydra_MessageMode :
		link_table[link].flags |= Link_flags_messagemode;
		if (message.Extra.Size)	/* I/O Server's C40HalfDuplex flag	*/
			link_table[link].flags |= Link_flags_halfduplex;
		message.FnRc	= swap(Hydra_MessageAck);
		socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
		link_table[link].state = Link_Running;
		if (link_table[link].flags & Link_flags_datareadysent)
			message_from_transputer(link);
		break;
					
	default :
		printf("Hydra: unexpected request 0x%08x from I/O Server on link %d\n",
			message.FnRc, link);
		socket_broken(link);
		link_table[link].flags &= ~Link_flags_datareadysent;
   }

	/* If the request was a write request and the datareadysent flag is set	*/
	/* then the I/O Server will have received a DataReady packet and the	*/
	/* write acknowledgement packet. It is now necessary to send another	*/
	/* packet to wake up the select(). Sadly this means that if the I/O	*/
	/* Server is sending a message while the root processor is trying to	*/
	/* send one as well then there could be four extra socket operations.	*/
	/* Sigh.								*/
	if (link_table[link].flags & Link_flags_datareadysent)
	{
		message.FnRc = swap(Hydra_Nop);
		socket_write(link, (BYTE *) &message, sizeof(Hydra_Message));
	}
}
/*}}}*/
/*{{{  message protocol between root processor and I/O Server */
/**
*** This code copes with full Helios messages going to and from the link.
*** It has the intelligence needed to cope with particular protocol bytes
*** etc. This makes it more efficient than the higher level protocol:
*** a message from the root processor to the I/O Server is handled by a
*** single socket write rather than four separate request/reply pairs.
*** The code is rather convoluted because of the need to handle both
*** byte- and word-based links.
**/

static void message_from_transputer(link)
int link;
{
	int	 protocol_word;
	bool	 word_link;
	int	*int_ptr	= (int *) big_buffer;
	MCB	 mcb;
	int	 size;
	
	if (link_table[link].flags & Link_flags_word)
		word_link = TRUE;
	else
		word_link = FALSE;
		
	if (link_table[link].flags & Link_flags_datareadysent)
	{
		/* one byte/word has been read from the link already.	*/
		link_table[link].flags &= ~Link_flags_datareadysent;
		protocol_word	= link_table[link].last_send;
	}
	else
	{
		/* fetch a byte/word from the link.			*/
		if (word_link)
			fetch_block(4, &protocol_word, TIMEOUT_VALUE);
		else
		{
			byte_from_link(big_buffer);
			protocol_word	= ((int)big_buffer[0]) & 0x000000FF;
		}
	}

		/* store the protocol byte/word in the buffer		*/
	if (word_link)
	{
		*((int *) big_buffer)	= protocol_word;
		protocol_word		= swap(protocol_word);
	}
	else
		big_buffer[3]	= protocol_word;

	switch(protocol_word)
	{
	case	Proto_Write :
			/* Store the poked value in the link table for	*/
			/* subsequent peeks, but do not pass it on to	*/
			/* the I/O Server.				*/
		if (fetch_block(8, &(big_buffer[4]), TIMEOUT_VALUE)) goto fail;
		link_table[link].last_send	= *((int *)&(big_buffer[8]));
		break;

	case	Proto_Read :
			/* Get the address and ignore it. Return the inverse	*/
			/* of the last value poked.				*/
		if (fetch_block(4, &(big_buffer[4]), TIMEOUT_VALUE)) goto fail;
		link_table[link].last_send = ~link_table[link].last_send;
		if (send_block(4, &(link_table[link].last_send), TIMEOUT_VALUE)) goto fail;
		break;			

	case	Proto_Msg :
/*{{{  receive message */
			if (link_table[link].flags & Link_flags_halfduplex)
			{
				if (word_link)
				{
					protocol_word	= swap(Proto_Go);
					if (send_block(4, &protocol_word, TIMEOUT_VALUE)) goto fail;
				}
				else
					if (byte_to_link(Proto_Go)) goto fail;
			}

			if (fetch_block(16, &(big_buffer[4]), TIMEOUT_VALUE)) goto fail;
				/* Work out the MCB values			*/
			{
				int	*x	= (int *) &mcb;
				*x++ = swap(int_ptr[1]);
				*x++ = swap(int_ptr[2]);
				*x++ = swap(int_ptr[3]);
				*x++ = swap(int_ptr[4]);
			}
#if (debug > 1)
			printf("Hydra: message from root processor on site %d, FnRc %x\n", link, mcb.MsgHdr.FnRc);
			printf("     : dsize %d, csize %d, flags 0x%02x, dest 0x%08x, reply 0x%08x\n",
				mcb.MsgHdr.DataSize, mcb.MsgHdr.ContSize, mcb.MsgHdr.Flags, mcb.MsgHdr.Dest, mcb.MsgHdr.Reply);
#endif
			/* Sort out the locations of the control and data vectors.	*/
		mcb.Control	= (int *) &(big_buffer[20]);
		size		= mcb.MsgHdr.ContSize * 4;
		mcb.Data	= (byte *) &(big_buffer[20 + size]);
		if (size > 0)
		 	if (fetch_block(size, mcb.Control, TIMEOUT_VALUE)) goto fail;
		size		= mcb.MsgHdr.DataSize;
		if (word_link)
		{
			size += (mcb.MsgHdr.Flags & MsgHdr_Flags_bytealign);
			size  = (size + 3) & ~3;
		}
		if (fetch_block(size, mcb.Data, TIMEOUT_VALUE)) goto fail;

		size += 16 + (mcb.MsgHdr.ContSize * 4);

		if (word_link)
			socket_write(link, big_buffer, size + 4);
		else
			socket_write(link, &(big_buffer[3]), size + 1);
/*}}}*/
		break;

	case	Proto_Info :
		if (word_link)
		{
			if (fetch_block(8, big_buffer, TIMEOUT_VALUE)) goto fail;
		}
		else
		{
			if (fetch_block(11, big_buffer, TIMEOUT_VALUE)) goto fail;
		}
		
		int_ptr[0] = swap(0xF0F0F0F0);
		int_ptr[1] = swap(0x00000100);
		int_ptr[2] = swap(0x00000001);
		if (send_block(12, big_buffer, TIMEOUT_VALUE)) goto fail;
		break;

	default:
		/* Ignore any junk bytes.				*/
		break;
	}

	return;	
fail:
#if 0
	  fprintf(stderr, "Hydra: communication failure from site %d, disconnecting user.\n", link);
	  socket_broken(link);
#else
	/* Do nothing, leave it for the user to sort things out.	*/
#if (debug > 1)
	  fprintf(stderr, "Hydra: communication failure from site %d.\n", link);
#endif	
	return;
#endif
}

static void message_from_server(link)
{
	bool	word_link;
	int	protocol_word;
	MCB	mcb;
	int	size;
	
	if (link_table[link].flags & Link_flags_word)
		word_link	= TRUE;
	else
		word_link	= FALSE;

	if (word_link)
	{
		socket_read(link, big_buffer, 4);
		protocol_word = swap(*((int *) big_buffer));
	}
	else
	{
		socket_read(link, &(big_buffer[3]), 1);
		protocol_word = ((int)big_buffer[3]) & 0x00FF;
	}

	switch(protocol_word)
	{
	case	Proto_RemoteReset :
		reset_processor();
		link_table[link].state	= Link_Reset;
		link_table[link].flags &= ~Link_flags_messagemode;
		break;

	case	Proto_RemoteAnalyse :
		analyse_processor();
		link_table[link].state	= Link_Reset;
		link_table[link].flags &= ~Link_flags_messagemode;
		break;

	case	Proto_Close :
		shutdown(link_table[link].connection, 2);
		close(link_table[link].connection);
		link_table[link].connection = -1;
		free_link(link);
		link_table[link].flags |= (Link_flags_free + Link_flags_uninitialised);
		link_table[link].state = Link_Reset;
		link_table[link].flags &= ~(Link_flags_datareadysent | Link_flags_messagemode);
		return;

	case	Proto_Go :
			/* Half duplex protocol support, already handled by Hydra	*/
		break;

	case	Proto_Msg :
/*{{{  receive message */
		socket_read(link, &(big_buffer[4]), 16);
		{	/* Work out the MCB values.				*/
			int	*x		= (int *) &mcb;
			int	*int_ptr	= (int *) big_buffer;
			*x++ = swap(int_ptr[1]);
			*x++ = swap(int_ptr[2]);
			*x++ = swap(int_ptr[3]);
			*x++ = swap(int_ptr[4]);
		}
#if (debug > 1)
			printf("Hydra: message to root processor on site %d, FnRc %x\n", link, mcb.MsgHdr.FnRc);
			printf("     : dsize %d, csize %d, flags 0x%02x, dest 0x%08x, reply 0x%08x\n",
				mcb.MsgHdr.DataSize, mcb.MsgHdr.ContSize, mcb.MsgHdr.Flags, mcb.MsgHdr.Dest, mcb.MsgHdr.Reply);
#endif
			/* Sort out the locations of the control and data vectors.	*/
		mcb.Control	= (int *) &(big_buffer[20]);
		size		= mcb.MsgHdr.ContSize * 4;
		mcb.Data	= (byte *) &(big_buffer[20 + size]);
		if (size > 0)
		 	socket_read(link, mcb.Control, size);
		size		= mcb.MsgHdr.DataSize;
		if (word_link)
		{
			size += (mcb.MsgHdr.Flags & MsgHdr_Flags_bytealign);
			size  = (size + 3) & ~3;
		}
		socket_read(link, mcb.Data, size);

		size += 16 + (mcb.MsgHdr.ContSize * 4);

		if (word_link)
		{
			if (send_block(size + 4, big_buffer, TIMEOUT_VALUE)) goto fail;
		}
		else
		{
			if (send_block(size + 1,  &(big_buffer[3]), TIMEOUT_VALUE)) goto fail;
		}
/*}}}*/
		break;

	default:
		/* Ignore any junk bytes.				*/
		break;
	}

	return;
fail:
#if 0
	fprintf(stderr, "Hydra: communication failure to site %d, disconnecting user.\n", link);
	socket_broken(link);
#else
	/* Do nothing, leave it for the user to sort things out.	*/
#if (debug > 1)
	  fprintf(stderr, "Hydra: communication failure to site %d.\n", link);
#endif	
	return;
#endif
}

/*}}}*/
/*{{{  debug protocol for use with hydramon */
/**
*** This routine deals with requests coming from a debug connection.
*** The structure debug_msg, described in structs.h, is used for the
*** incoming requests. The structure socket_msg is used for the reply.
*** The requests may be :
***   Close, finish this debugging session
***   Disconnect, abort an I/O Server on a particular link, i.e. change
***    a link from used to free mode
***   Use, try to change a link from unused mode to free mode
***   Free, try to change a link from free to used mode.
**/
PRIVATE void from_debug(no)
int no;
{ debug_msg  msg;
  socket_msg reply;
  int fildes = debug_table[no].fildes;
  int link;

#if (debug  > 0)
  printf("Hydra : message from hydramon\n");
#endif

  if (read(fildes, (BYTE *) &msg, sizeof(debug_msg))
      < sizeof(debug_msg))
   { perror("Hydra : failed to read hydramon request");
     shutdown(fildes, 2);
     close(fildes);
     debug_table[no].flags |= Debugtab_Free;
     return;
   }

  if (swap(msg.fnrc) eq Debug_Close)
   { shutdown(fildes, 2);
     close(fildes);
     debug_table[no].flags |= Debugtab_Free;
     return;
   }

  link = swap(msg.link);
  if ((link < 0) || (link >= number_of_links))
   { reply.fnrc = swap(Invalid_Link);
     if (write(fildes, (BYTE *) &reply, sizeof(socket_msg))
         < sizeof(socket_msg))
      { perror("Hydra : failed to reply to hydramon request");
        shutdown(fildes, 2);
        close(fildes);
        debug_table[no].flags |= Debugtab_Free;
      }
     return;
   }

/**
*** Disconnect : only possible if the link is not free and in use,
*** the processor is reset, the connection is closed which should abort
*** the I/O Server, the link is freed, and the link flags are set.
**/
  if (swap(msg.fnrc) eq Debug_Disconnect)
   {
     if (!(link_table[link].flags & (Link_flags_free | Link_flags_unused) ))
      { current_link = link;
        reset_processor();
        shutdown(link_table[link].connection, 2);
        close(link_table[link].connection);
        link_table[link].connection = -1;
        free_link(link);
        link_table[link].flags |= (Link_flags_free | Link_flags_uninitialised);
        link_table[link].state = Link_Reset;
        link_table[link].connection = -1;
      }
     return;
   }

/**
*** Use request, only possible if the link is currently unused, it
*** involves attempting to open the link. If that fails the link
*** remains unused. Otherwise the link is set to free.
**/
  if (swap(msg.fnrc) eq Debug_Use)
   { if (link_table[link].flags & Link_flags_unused)
      { if (open_link(link))
         { free_link(link);
           link_table[link].flags &= ~(Link_flags_unused |
                                       Link_flags_firsttime);
           link_table[link].flags |= (Link_flags_free |
                                      Link_flags_uninitialised);
           link_table[link].state = Link_Reset;
           link_table[link].connection = -1;
         }
      }
     return;
   }

/**
*** Free : this is only allowed if the link is currently free. If it is
*** unused Free is a no-op, if it is currently in use Free is not allowed.
**/
  if (swap(msg.fnrc) eq Debug_Free)
   { if (link_table[link].flags & Link_flags_unused)
      return;   /* no-op */
     if (!(link_table[link].flags & Link_flags_free))
      return;   /* should disconnect first */
     link_table[link].flags &= ~Link_flags_free;
     link_table[link].flags |= Link_flags_unused;
     return;
   }

/**
*** BLV - addition, 25.2.93, allow hydramon to terminate Hydra
**/
   
  if (swap(msg.fnrc) eq Debug_Exit)
   exit(0);

/**
*** Send back info on the link.
**/
  memcpy((BYTE *) &reply, (BYTE *) &(con_table[link]), sizeof(socket_msg));
  strncpy(reply.linkname, link_table[link].link_name, 31);
  reply.linkname[31]= '\0';
  reply.fnrc = swap(link_table[link].state);
  reply.extra = swap(link_table[link].flags);
  if (write(fildes, (BYTE *) &reply, sizeof(socket_msg))
      < sizeof(socket_msg))
   { perror("Hydra : failed to reply to hydramon request");
     shutdown(fildes, 2);
     close(fildes);
     debug_table[no].flags |= Debug_Free;
   }
}
/*}}}*/
/*{{{  hydra.con handling */

/*------------------------------------------------------------------------
--                                                                      --
-- Configuration file support                                           --
--                                                                      --
------------------------------------------------------------------------*/

/**
*** Here is a copy of the configuration file support, normally held
*** in module server.c. Reading in the configuration file also needs
*** the linked list support, further down. Finally there are some
*** utilities such as swap(), ServerDebug(), and socket I/O routines.
*** All of this is very boring.
**/

                        /* This is the list used to hold the configuration. */
PRIVATE List config_hdr;
typedef struct { Node node;
                 char name[1];         /* space for byte '\0' */
} config;
PRIVATE int config_initialised = 0;

PRIVATE BYTE misc_buffer1[512];

PRIVATE int read_config(config_name)
char *config_name;
{ FILE   *conf;
  register char   *buff = (char *) &(misc_buffer1[0]);
  register int    length;
  config *tempnode;
  char   *temp;
  int    error=0;

  InitList(&config_hdr);

  config_initialised++;                /* There may be memory to be freed */

                                             /* open the configuration file */
  conf = fopen(config_name, "r");
  if (conf eq NULL)
    {
      printf("Hydra : unable to open configuration file %s\r\n", config_name);
      return(0);
    }

                                      /* and read it in, one line at a time */
  while(fgets(buff, 255, conf) ne NULL)
     { while (isspace(*buff)) buff++;
       length = strlen(buff);
                        /* fgets() leaves a newline character in the buffer */
       if ((buff[length-1] eq '\n') || (buff[length-1] eq '\r'))
         buff[--length] = '\0';
       if (length eq 0) continue;     /* blank line */
       if (buff[0] eq '#') continue;  /* comment */

       tempnode = (config *) malloc(sizeof(config) + length);
       if (tempnode eq (config *) NULL)
         { printf("Hydra : insufficient memory on host machine for configuration.\r\n");
           fclose(conf);
           return(0); 
         }
       strcpy(tempnode->name, buff);
       AddTail((Node *) tempnode, &config_hdr);
       buff = &(misc_buffer1[0]);
     }

  fclose(conf);

  temp = get_config("HOST");           /* There must be an entry for HOST */
  if (temp eq NULL)
    { printf("Hydra : error in configuration file, missing entry for HOST\r\n");
      error = 1;
    }

  temp = get_config("BOX");                         /* And an entry for BOX */
  if (temp eq NULL)
    { printf("Hydra : error in configuration file : missing entry for BOX.\r\n");
      error = 1;
    }

  if (error)
    { printf("\nPlease edit the configuration file %s.\r\n", config_name);
      return(0); 
    }

  return(1);
}

PRIVATE void tidy_config()
{ if (config_initialised) FreeList(&config_hdr);
}

        /* The following code allows the server to examine the   */
        /* configuration file. For example, to get the entry for */
        /* HOST, use a call get_config("host"). If there is      */
        /* an entry HOST=XXX get_config() returns a pointer to   */
        /* XXX. The function is fairly easy to implement using a */
        /* list Wander.                                          */
        /* If no entry is found the routine returns NULL.        */
PRIVATE char *test_name(node, name)
config *node;
char   *name;
{ register char *config_name = &(node->name[0]);

                                  /* compare name and config_name */
  while ((*name ne '\0') && (*config_name ne '\0'))
   { if ( ToUpper(*name) ne ToUpper(*config_name) )
       return(FALSE);
     name++; config_name++;
   }
                    /* succeeded ? */
  while (isspace(*config_name)) config_name++;

  if ((*name eq '\0') && (*config_name eq '\0')) return(config_name);

  if ((*name eq '\0') && (*config_name++ eq '='))
    {   while (isspace(*config_name)) config_name++;
        return(config_name);
    }
  else
    return(FALSE);
}

char *get_config(str)
char *str;
{ word result = Wander(&config_hdr, (WordFnPtr) func(test_name), str);
  if (result eq FALSE)
    return(NULL);
  else
    return((char *) result);
}

WORD get_int_config(str)
char *str;
{ register char *result = get_config(str);
  WORD base = 10L, value = 0L, sign = 1L;
  WORD temp;

  if (result eq NULL)
    return(Invalid_config);

  while (isspace(*result)) result++;
  if (*result eq '-') { sign = -1L; result++; }
  if (*result eq '0')
    { result++;
      if (*result eq 'x' || *result eq 'X')
        { result++; base = 16L; }
      else
       base = 8L;
    }
  if (*result eq '-') { sign = -1L; result++; }


#if (UNIX || PC)
  while (isxdigit(*result))    /* Use this routine if it is available */
#else
  while ( isdigit(*result) || ('a' <= *result && *result <= 'f') ||
          ('A' <= *result && *result <= 'F'))
#endif
   { 
     switch (*result)
      { case '0' : case '1' : case '2' : case '3' : case '4' :
        case '5' : case '6' : case '7' : case '8' : case '9' :
                      temp = (WORD) (*result - '0'); break;

        case 'a' : case 'b' : case 'c' : case 'd' : case 'e' :
        case 'f' :    temp = 10L + (WORD) (*result - 'a'); break;

        case 'A' : case 'B' : case 'C' : case 'D' : case 'E' :
        case 'F' :    temp = 10L + (WORD) (*result - 'A'); break;
      }

     if (temp >= base) break;
     value = (base * value) + temp;
     result++;
   }

 return(value * sign);
}
/*}}}*/
/*{{{  utilities */

/*------------------------------------------------------------------------
--                                                                      --
--  Lists                                                               --
--                                                                      --
--      Usual linked list library, but containing only the              --
--      functions which I can be bothered to use.                       --
------------------------------------------------------------------------*/

/* create and initialise a list header, returning 0 to indicate failure */
List *MakeHeader()
{ List *newptr;

  newptr = (List *) malloc( sizeof(List) );
  if (newptr ne NULL)
    InitList(newptr);

  return(newptr);
}

/* initialise a list header to the empty list */
void InitList(listptr)
List *listptr;
{ listptr->head  = (Node *) &(listptr->earth);
  listptr->earth = NULL;
  listptr->tail  = (Node *) listptr;
} 

/* add a node to the beginning of the list */
Node *AddHead(node, header)
Node *node;
List *header;
{ node->next = header->head;
  node->prev = (Node *)header;
  header->head = node;
  (node->next)->prev = node;
  return(node);
}

Node *AddTail(node, header)
Node *node;
List *header;
{ node->prev = header->tail;
  header->tail = node;
  node->next = (Node *) &(header->earth);
  (node->prev)->next = node;
  return(node);
}

Node *listRemove(node)
Node *node;
{ (node->prev)->next = node->next;
  (node->next)->prev = node->prev;
  return(node);
}

Node *NextNode(node)
Node *node;
{ return(node->next);
}

word TstList(header)
List *header;
{ if ((header->head)->next eq NULL) return(FALSE);
  return(TRUE);
}

#if (ANSI_prototypes && !AMIGA)
#if (RS6000 || HP9000)
void WalkList(List *list, VoidFnPtr fun, ...)
#else
void WalkList(list, fun, ...)
List *list;
VoidFnPtr fun;
#endif
{ Node *node, *node2;
  WORD arg1, arg2;
  va_list args;

  va_start(args, fun);
  arg1 = va_arg(args, WORD);
  arg2 = va_arg(args, WORD);
  va_end(args);

  for (node=list->head; node->next ne NULL; node=node2)
    { node2 = node->next;
      (*fun)(node, arg1, arg2);
    }
}

#if (RS6000 || HP9000)
WORD Wander(List *list, WordFnPtr fun, ...)
#else
word Wander(list, fun, ...)
List *list;
WordFnPtr fun;
#endif
{ Node *node, *node2;
  word result, arg1, arg2;
  va_list args;

  va_start(args, fun);
  arg1 = va_arg(args, WORD);
  arg2 = va_arg(args, WORD);
  va_end(args);

  result = FALSE;

  for (node=list->head; (node->next ne NULL) && !result;
       node = node2)
    { node2 = node->next;
      result = (*fun)(node, arg1, arg2);
    }

  return(result);
}
#else
void WalkList(list, fun, arg1, arg2)
List *list;
VoidFnPtr fun;
WORD arg1, arg2;
{ Node *node, *node2;

  for (node=list->head; node->next ne NULL; node=node2)
    { node2 = node->next;
      (*fun)(node, arg1, arg2);
    }
}

word Wander(list, fun, arg1, arg2)
List *list;
WordFnPtr fun;
WORD arg1, arg2;
{ Node *node, *node2;
  word result;
  result = FALSE;

  for (node=list->head; (node->next ne NULL) && !result;
       node = node2)
    { node2 = node->next;
      result = (*fun)(node, arg1, arg2);
    }

  return(result);
}

#endif /* ANSI_prototypes */

                /* This routine just frees every node in the list */
void FreeList(list)
List *list;
{ Node *node, *node2;

  for (node = list->head; node->next ne NULL; node = node2)
    { node2 = node->next;
      free(Remove(node));
    }
}

                          /* this routine is needed by the debugger */
void PreInsert(next, node)
Node *next, *node;
{ node->next = next;
  node->prev = next->prev;
  next->prev = node;
  node->prev->next = node;
}

          /* This routine is used to maintain the order of nodes in WaitingCo */
          /* It puts the node just after the list node given                  */
void PostInsert(node, before)
Node *node, *before;
{ node->next       = before->next;
  node->prev       = before;
  before->next     = node;
  node->next->prev = node;
}

          /* This routine returns the number of nodes in a list. */
WORD ListLength(header)
List *header;
{ Node *node;
  WORD result = 0L;

  for (node = header->head; node->next ne (Node *) NULL; node = node->next)
    result++;

  return(result);
}


/*-------------------------------------------------------------------------
--                                                                       --
--   The usual utilities                                                 --
--                                                                       --
-------------------------------------------------------------------------*/

int ToUpper(x)
int x;
{ return(islower(x) ? toupper(x) : x);
}

word mystrcmp(ms1, ms2)
char *ms1, *ms2;
{ register char *s1 = ms1, *s2 = ms2; 
  for (;;)
   { if (*s1 eq '\0')
       return((*s2 eq '\0') ? 0L : -1L);
     elif (*s2 eq '\0')
       return(1L);
     elif(ToUpper(*s1) < ToUpper(*s2))
       return(-1L);
     elif(ToUpper(*s1) > ToUpper(*s2))
       return(1L);
     else
       { s1++; s2++; }
   }
}

#if swapping_needed
#if (ST || TRIPOS || SUN3 || SUN4 || SM90 || TR5 || RS6000 || HP9000)
                  /* for the 68000's + SPARC's byte ordering */
                  /* on the Amiga it is written in assembler */
word swap(a)
word a;
{ register word b = 0;
  int i;

  if (a eq 0L) return(0L);

  for (i=0; i<4; i++)
    { b <<= 8; b |= (a & 0xFF); a >>= 8; }

  return(b);
}
#endif     /* 68000 + SPARC */
#endif

#if ANSI_prototypes

#if (RS6000 || HP9000)
void ServerDebug(char *text, ...)
#else
void ServerDebug(text, ...)
char *text;
#endif
{
  va_list args;

  va_start(args, text);

  printf("Hydra : ");
  vprintf(text, args);

  va_end(args);
}

#else

void ServerDebug(text, a, b, c, d, e)
char *text;
int a, b, c, d, e;
{ printf("Hydra : ");
  printf(text, a, b, c, d, e); putchar('\n');
}

#endif /* ANSI_prototypes */

/**
*** writing to and reading from sockets. I know at all times how much data to
*** read from a socket, and the other side knows how much I am writing. Hence
*** the following code guarantees delivery of that amount of data,
*** and who cares about the socket's buffering.
**/

void socket_broken(link)
int link;
{ current_link = link;
  reset_processor();
  free_link(link);
  link_table[link].flags |= Link_flags_free;
  link_table[link].state =  Link_Reset;
  close(link_table[link].connection); 
  link_table[link].connection = -1;
  printf("Hydra : I/O Server on link %d has been disconnected.\n", link);
  longjmp(again, 1);
}

void socket_write(link, buf, amount)
int link;
BYTE *buf;
int amount;
{ int written = 0;
  int signals = 0;
  int fildes = link_table[link].connection;
  
  while (written < amount)
   { int x = write(fildes, &(buf[written]), amount - written);
     if (x <= 0)
      { if ((errno eq EINTR) && (signals < 5))
         { signals++; continue; }
        socket_broken(link);
        return;
      }
     written += x;
   }
}

void socket_read(link, buf, amount)
int link;
BYTE *buf;
int  amount;
{ int read_so_far = 0;
  int signals = 0;
  int fildes = link_table[link].connection;
  
  while (read_so_far < amount)
   { int x = read(fildes, &(buf[read_so_far]), amount - read_so_far);
     if (x <= 0)
      { if ((errno eq EINTR) && (signals < 5))
         { signals++; continue; }
        socket_broken(link);
        return;
      }
     read_so_far += x;
   }
}
/*}}}*/

@


1.17
log
@The VC40.c support code needs stubs for bootstrap and bootsize
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.16 1993/03/23 15:15:08 bart Exp bart $ */
d104 1
@


1.16
log
@Huge changes to allow Hydra to work with C40 boards
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.15 1993/02/25 15:08:07 bart Exp $ */
d102 2
@


1.15
log
@Repeat of revision 1.12, that bug fix had been lost somehow
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.14 1993/02/09 14:06:58 bart Exp $ */
d22 1
d30 2
a31 1
*** 2 -> full debugging, for people who are desperate
d42 2
a43 1
#if (ARMBSD)
d100 2
d110 3
a112 1
*** but less information is needed.
d129 1
a129 1
*** Here is a buffer for holding messages. 128K is a bit excessive,
d134 1
a134 1
BYTE big_buffer[128 * 1024]; 
d176 2
a178 1

d185 1
a185 1
*** Next the Unix signal mechanism is, effectively, disabled to stop
d201 3
a203 1
*** be used to wait for incoming connections. If this succeeds
d253 2
a254 2
  printf("Hydra : running on %d link%s.\n", number_of_links,
		(number_of_links != 1) ? "s" : "");
d288 2
d411 2
d477 2
d484 2
a485 1

d487 5
a491 5
*** This is the main loop of the link daemon. In theory its job is to
*** select on all open links, all normal connections from I/O Servers, and
*** all debug connections, and call appropriate handler routines.  The
*** situation is complicated by the fact that some link devices do not
*** support select...
d493 8
a500 8
*** The code is as follows : for every link currently in use, i.e. neither
*** free nor unused, if the link is selectable add it to the current
*** select mask, otherwise poll it and call a handler routine; if the link
*** is not selectable use a small link timeout; add the connection from the
*** corresponding I/O Server to the select mask; add the socket on which
*** Hydra is waiting for incoming requests; and add any debugging
*** connections. Do a select() with the read mask generated and with an
*** appropriate timeout. Then handle any data from any of the sources.
d502 7
a508 8
*** In theory there is a problem with links-not-selectable, if Helios
*** tries to write to a file and the I/O Server is handling a file read
*** request, because the I/O Server will be trying to send data and
*** cannot receive an incoming message. It only applies to large messages
*** because the sockets will buffer small ones. The problem is avoided
*** for selectable links because the I/O Server is handled before the
*** link. So far nobody has managed to make this happen, so it does not
*** appear to be serious.
d516 2
a517 1

d531 1
a531 3
#if SM90
     select_time.tv_sec  = 1;
#else     
a532 1
#endif
d537 25
a561 4
       { if (link_table[i].flags & Link_flags_not_selectable)
          { current_link = i;
            if (rdrdy())
             from_transputer(i); 
d563 1
a563 3
             select_time.tv_sec  = 1;
#else     
             select_time.tv_sec  = 0;
a564 19
            select_time.tv_usec = 1000;   /* need to poll the link */
          }
/*@@@@@@ 16.05.90 */
/*
 * compiler switch  for heuristic reasons to prevent
 * select on parsytec links.
 */
#ifndef PARSY
         else
          { FD_SET(link_table[i].fildes, &rd_mask);
            if (link_table[i].fildes > max_fd) max_fd = link_table[i].fildes;
          }
#endif
/*@@@@@@ 16.05.90 */
	 if(link_table[i].connection >= NULL) {
		 FD_SET(link_table[i].connection, &rd_mask);
		 if (link_table[i].connection > max_fd) max_fd=link_table[i].connection;
	 }
        }
d576 1
a576 1
#if (debug > 1)
d599 19
a617 12
      {
/*@@@@@@ 16.05.90 */
	 if(link_table[i].connection >= NULL) {
	      if (FD_ISSET(link_table[i].connection, &rd_mask))
		   from_server(i);
	 }
/*@@@@@@ 16.05.90 */
#ifndef PARSY
        if (FD_ISSET(link_table[i].fildes, &rd_mask))
           from_transputer(i);
#endif
      }
d620 2
d683 1
d704 1
d724 1
d745 1
d758 1
d772 1
d793 1
d818 1
d834 1
d837 2
d841 4
a844 13
*** These routines cope with data coming from the transputer. If the
*** transputer is currently reset or is in the middle of a bootstrap,
*** something strange is going on and the transputer is reset. If the
*** transputer is running it is quite likely to want to send some data.
*** It will send a single protocol byte, possibly followed by some other
*** stuff. Peek and poke requests are handled by sending
*** the data to the I/O Server and, for a peek, getting back the reply.
*** Messages involve reading in the entire message and sending it on
*** to the I/O Server. This is done in routine get_msg_from_trannie below.
*** There is support for the debugging protol as well, but that is currently
*** unimplemented. Nasty protocols such as Reconfigure are just passed on
*** to the I/O Server. This leaves the Info protocol, which is handled
*** locally.
a845 3
PRIVATE void fn( get_data_from_trannie, (int));
PRIVATE void fn( get_msg_from_trannie, (int));
PRIVATE void fn( get_dbg_from_trannie, (int));
d849 1
a849 1
{ current_link = link;
d851 1
a851 5
  switch(link_table[link].state)
   { case Link_Reset   :  /* in these two states the transputer should never */
     case Link_Booting :  /* send any data. Something is wrong so I reset it */
                         reset_processor();
                         return;                         
d853 9
a861 6
     case Link_Running : get_data_from_trannie(link);
                         return;

     default : printf("Hydra : the link device is in an unexpected state.\n");
               link_table[link].state = Link_Reset;
               reset_processor();
d863 7
a869 9
}

PRIVATE void get_data_from_trannie(link)
int link;
/*@@@@@@ 16.05.90 int does not work on a sun4 Mr. Bart Veer*/
#if TR5
{ unsigned int protocol = 0;
#else
{ unsigned char protocol = 0;
d871 1
a871 8
  UBYTE buf[20];

  if (byte_from_link(&protocol))
   { printf("Hydra : error on link %d, failed to receive protocol byte.\n",
            link);
/*@@@@@@ 16.05.90 */
     socket_broken(link);
     return;
d874 1
a874 4
#if TR5
  protocol = swap (protocol);
#endif
  buf[0] = protocol;
d876 9
a884 2
#if (debug > 0)
  printf("Hydra : protocol byte 0x%02x from link %d\n", protocol, link);
a885 41

  switch(protocol)
   { case Proto_Write : fetch_block(8, &(buf[1]), TIMEOUT_VALUE);
                        socket_write(link, buf, 9);
                        return;

     case Proto_Read : fetch_block(4, &(buf[1]), TIMEOUT_VALUE);
                       socket_write(link, buf, 5);
                       socket_read(link, buf, 4);
                       send_block(4, buf, TIMEOUT_VALUE);
                       return;

     case Proto_Msg  : get_msg_from_trannie(link);
                       return;

     case Proto_Null :       /* the following are single-byte transactions */
     case Proto_Term :
     case Proto_Reconfigure :
     case Proto_SecurityCheck :
     case Proto_Reset :
                        socket_write(link, buf, 1);
                        return;

     case Proto_Info : { int *x = (int *) &(buf[0]);
                         fetch_block(11, &(buf[1]), TIMEOUT_VALUE);
                         *x++ = swap(0xF0F0F0F0L);
                         *x++ = swap(0x00000100L);
                         *x   = swap(0x00000001L);
                         send_block(12, buf, TIMEOUT_VALUE);
                         return;
                       }

     case Proto_Debug : get_dbg_from_trannie(link);
                        return;

     default : printf("Hydra : unexpected byte 0x%2x from link %d.\n",
                      protocol, link);
               socket_broken(link); 
               return;
   }

d889 2
a890 20
*** This code deals with getting data from the I/O Server. At the moment
*** the link can be in one of three states : reset, booting, and running.
*** In reset state the processor can be peeked and poked, i.e. the
*** I/O Server is running in debug mode. The transputer can also be
*** reset and analysed remotely, and the connection can be closed. Finally,
*** a bootstrap can be initiated. Bootstrapping involves a separate routine
*** do_bootstrap() below. The bootstrap code is quite complicated, in that
*** it must support different processors with different bootstrap
*** mechanisms.
***
*** On the transputer bootstrapping involves going via an intermediate
*** utility nboot.i, which accepts requests from the I/O Server. These
*** requests allow remote debugging, clearing memory, and so on. One
*** of the requests may be to accept a system image, continueing the
*** bootstrap mechanism to get a running system.
***
*** Once the processor has read the system image it is up and running, and
*** it can be sent messages from the I/O Server. In theory the I/O Server
*** is also allowed to peek and poke, and to send info requests, but these
*** are unlikely in practice.
a892 4
PRIVATE void fn( do_bootstrap, (int));
PRIVATE void fn( get_msg_from_server, (int));
PRIVATE void fn( get_dbg_from_server, (int));

d895 3
a897 3
{ UBYTE buf[256];
  int  temp;

d900 3
a902 11
  switch(link_table[link].state)
   { case Link_Reset: 
             socket_read(link, buf, 1);
#if (debug > 0)
             printf("Hydra : reset byte 0x%2x from server, link %d\n",
                    buf[0], link);
#endif
             switch(buf[0])
              { case Proto_Write : socket_read(link, &(buf[1]), 8);
                                   send_block(9, buf, TIMEOUT_VALUE);
                                   return;
d904 2
a905 35
                case Proto_Read : socket_read(link, &(buf[1]), 4);
                                  send_block(5, buf, TIMEOUT_VALUE);
                                  fetch_block(4, buf, TIMEOUT_VALUE);
                                  socket_write(link, buf, 4);
                                  return;

                case Proto_RemoteReset :
                                  reset_processor();
                                  return;

                case Proto_RemoteAnalyse :
                                  analyse_processor();
                                  return;

                case Proto_Close :
                                  close(link_table[link].connection);
                                  link_table[link].connection = -1;
                                  free_link(link);
                                  link_table[link].flags |=
                                  (Link_flags_free | Link_flags_uninitialised);
                   		  link_table[link].state = Link_Reset;
                                  return;

                case Proto_Boot :
                                  do_bootstrap(link);
                                  return;

                default : return;
              }

     case Link_Booting :   /* nboot.i has been sent to the trannie */
                socket_read(link, buf, 1);
#if (debug > 0)
                printf("Hydra : booting byte 0x%2x from server, link %d\n",
                        buf[0], link);
a906 6
                switch(buf[0])
                 { case 0 :  /* remote debugging */
                   case 1 :
                   case 2 :
                   case 3 : byte_to_link(buf[0]);
                            return;
d908 8
a915 4
                   case 4 :    /* bootstrap */
                            byte_to_link(4);
                            do_bootstrap(link);
                            return;
d917 6
a922 5
                   case 5 :   /* clear memory */
                            socket_read(link, &(buf[1]), 4);
                            send_block(5, buf, TIMEOUT_VALUE);
                            byte_from_link(&temp);
                            return;
d924 4
a927 5
                   case 6 :   /* worm */
                            byte_to_link(6);
                            fetch_block(27 * 4, buf, TIMEOUT_VALUE);
                            socket_write(link, buf, 27 * 4);
                            return;
d929 25
a953 4
                   case Proto_RemoteReset :
                            reset_processor();
                            link_table[link].state = Link_Reset;
                            return;
d955 8
a962 4
                   case Proto_RemoteAnalyse :
                            analyse_processor();
                            link_table[link].state = Link_Reset;
                            return;
d964 9
a972 15
                   case Proto_Close :
                            close(link_table[link].connection);
                            link_table[link].connection = -1;
                            free_link(link);
                            link_table[link].flags |=
                             (Link_flags_free | Link_flags_uninitialised);
                            link_table[link].state = Link_Reset;
                            return;
                   default :
                             printf("Hydra : unexpected bootstrap byte 0x%2x\n",
                                    buf[0]);
                             printf("      : from server %d\n", link);
                             socket_broken(link);
                             return;
                 }                                     
d974 15
d990 12
a1001 11
     case Link_Running :    /* Helios is up and running */
                socket_read(link, buf, 1);
#if (debug > 0)
                printf("Hydra : protocol byte 0x%2x from server %d\n",
                        buf[0], link);
#endif
                switch(buf[0])
                 { case Proto_Write :
                             socket_read(link, &(buf[1]), 8);
                             send_block(9, buf, TIMEOUT_VALUE);
                             return;
d1003 31
a1033 6
                   case Proto_Read :
                             socket_read(link, &(buf[1]), 4); 
                             send_block(5, buf, TIMEOUT_VALUE);
                             fetch_block(4, buf, TIMEOUT_VALUE);
                             socket_write(link, buf, 4);
                             return;
d1035 18
a1052 3
                   case Proto_Msg :
                             get_msg_from_server(link);
                             return;
d1054 12
a1065 38
                   case Proto_Info :
                             socket_read(link, &(buf[1]), 11);
                             send_block(12, buf, TIMEOUT_VALUE);
                             fetch_block(12, buf, TIMEOUT_VALUE);
                             socket_write(link, buf, 12);
                             return;

                   case Proto_Debug :
                             get_dbg_from_server(link);
                             return;

                   case Proto_RemoteReset :
                             reset_processor();
                             link_table[link].state = Link_Reset;
                             return;

                   case Proto_RemoteAnalyse :
                             analyse_processor();
                             link_table[link].state = Link_Reset;
                             return;

                   case Proto_Close :
                             close(link_table[link].connection);
                             link_table[link].connection = -1;
                             free_link(link);
                             link_table[link].flags |=
                              (Link_flags_free | Link_flags_uninitialised);
                             link_table[link].state = Link_Reset;
                             return;

                   default :
                             printf("Hydra : unexpected protocol byte 0x%2x\n",
                                    buf[0]);
                             printf("      : from server %d\n", link);
                             socket_broken(link);
                             return;
                 }
   }
d1067 2
a1068 1

d1070 7
a1076 13
*** This routine deals with processor bootstrap. The I/O Server will have
*** sent a Proto_Boot byte to start the process, followed by a 4-byte
*** integer defining the bootstrap mode. Essentially there may be up to
*** three stages : the bootstrap utility nboot.i; the system image; and
*** the configuration. In between the bootstrap utility and the system
*** image there may be many other protocol bytes, as nboot.i is also
*** used by the debugger.
***
*** This routine is called when the link is reset and the bootstrap starts
*** up, and when the I/O Server sends nboot.i a byte 4 to initiate the
*** system image load. In the former case the link state is reset, in the
*** latter case the link state is booting. The bootstrap mode is held in
*** the ready field of the link table, which is not used inside Hydra.
d1078 2
a1079 1
PRIVATE void do_bootstrap(link)
d1081 29
a1109 2
{ WORD  x;
  UBYTE buf[256];
d1111 8
a1118 2
  if (link_table[link].state eq Link_Booting)
   goto read_image;
d1120 9
a1128 2
  socket_read(link, (BYTE *) &x, 4);
  link_table[link].ready = swap(x);
d1130 7
a1136 8
  if (link_table[link].ready & B_Send_Bootstrap)
   {
     socket_read(link, &(buf[0]), 1);  /* the boot size */
     socket_read(link, &(buf[1]), (int) buf[0]); /* the bootstrap program */
     send_block((int) buf[0] + 1, buf, TIMEOUT_VALUE);
     link_table[link].state = Link_Booting;
     return;
   }
d1138 12
a1149 3
read_image:
  unless(link_table[link].ready & B_Send_Image)
   goto read_conf;
d1151 27
a1177 5
  socket_read(link, (BYTE *) &x, 4);   /* size of system image */
  memcpy(big_buffer, (BYTE *) &x, 4);  /* put at start of buffer */
  x = swap(x);
  socket_read(link, &(big_buffer[4]), x - 4);  /* rest of system */
  send_block(x, big_buffer, TIMEOUT_VALUE);
d1179 1
a1179 3
read_conf:
  unless(link_table[link].ready & B_Send_Config)
    goto boot_done;
d1181 6
a1186 8
  socket_read(link, (BYTE *) &x, 4);   /* size of configuration */
  memcpy(big_buffer, (BYTE *) &x, 4);
  x = swap(x);
  socket_read(link, &(big_buffer[4]), x);
  send_block(x+4, big_buffer, TIMEOUT_VALUE);
boot_done:
  link_table[link].state = Link_Running;
}
d1188 15
a1202 13
/**
*** Here are the messages handling routines. The message has to be
*** read, either from a link or from a socket, in chunks because the
*** size is not known until the message header has been read. The
*** whole message is placed into a single big buffer, and sent down the
*** link or down the socket in one go. Note that messages are sent in
*** transputer format at all times, so swapping tends to be necessary.
**/
PRIVATE void get_msg_from_server(link)
int link;
{ 
  MCB mcb;
  int amount = 17;
d1204 4
a1207 2
  big_buffer[3] = 2;
  socket_read(link, &(big_buffer[4]), 16);  /* alignment... */
d1209 5
a1213 8
#if swapping_needed
  { int *p1, *p2;
    p1 = (int *) &mcb; p2 = (int *) &(big_buffer[4]);
    *p1++ = swap(*p2++);
    *p1++ = swap(*p2++);
    *p1++ = swap(*p2++);
    *p1   = swap(*p2);
  }
d1215 5
a1219 1
  memcpy((BYTE *) &mcb, &(big_buffer[4]), 4 /*16*/);
d1221 1
d1223 11
a1233 5
  if (mcb.MsgHdr.ContSize > 0)
   { int x = 4 * mcb.MsgHdr.ContSize;
     socket_read(link, &(big_buffer[3 + amount]), x);
     amount += x;
   }
d1235 10
a1244 5
  if (mcb.MsgHdr.DataSize > 0)
   { int x = mcb.MsgHdr.DataSize;
     socket_read(link, &(big_buffer[3 + amount]), x);
     amount += x;
   }
d1246 7
a1252 6
#if (debug > 0)
   printf("Hydra : message from server %d, dsize %d, csize %d, flags 0x%2x\n",
          link, mcb.MsgHdr.DataSize, mcb.MsgHdr.ContSize, mcb.MsgHdr.Flags);
   printf("      : dest %8x, reply %8x, fnrc %8x\n", mcb.MsgHdr.Dest,
          mcb.MsgHdr.Reply, mcb.MsgHdr.FnRc);
#endif
d1254 5
a1258 5
  if (send_block(amount, &(big_buffer[3]), TIMEOUT_VALUE))
   { printf("Hydra : failed to send whole message down link %d\n", link);
     socket_broken(link);
   }
}
d1260 9
a1268 4
PRIVATE void get_msg_from_trannie(link)
int link;
{ MCB mcb;
  int amount = 17;
d1270 3
a1272 6
  big_buffer[3] = 2;
  if (fetch_block(16, &(big_buffer[4]), TIMEOUT_VALUE))
   { printf("Hydra : failed to receive message header from link %d\n", link);
     socket_broken(link);
     return;
   }
d1274 15
a1288 10
#if swapping_needed
  { int *p1, *p2;
    p1 = (int *) &mcb; p2 = (int *) &(big_buffer[4]);
    *p1++ = swap(*p2++);
    *p1++ = swap(*p2++);
    *p1++ = swap(*p2++);
    *p1++ = swap(*p2++);
  }
#else
  memcpy((BYTE *) &mcb, &(big_buffer[4]), 4 /*16*/);
d1290 13
d1304 1
a1304 6
#if (debug > 0)
   printf("Hydra : message from trannie %d, dsize %d, csize %d, flags 0x%2x\n",
          link, mcb.MsgHdr.DataSize, mcb.MsgHdr.ContSize, mcb.MsgHdr.Flags);
   printf("      : dest %8x, reply %8x, fnrc %8x\n", mcb.MsgHdr.Dest,
          mcb.MsgHdr.Reply, mcb.MsgHdr.FnRc);
#endif
d1306 10
a1315 2
  if (mcb.MsgHdr.ContSize > 0)
   { int x = 4 * mcb.MsgHdr.ContSize;
d1317 4
a1320 6
#if (debug > 0)
     if (x > 64)
      { printf("Hydra : invalid control size");
        forever sleep(30);
      }
#endif
d1322 11
a1332 16
     if (fetch_block(x, &(big_buffer[3 + amount]), TIMEOUT_VALUE))
      { printf("Hydra : failed to receive control vector from link %d\n", link);
        socket_broken(link);
        return;
      }
     amount += x;
   }

  if (mcb.MsgHdr.DataSize > 0)
   { int x = mcb.MsgHdr.DataSize;

#if (debug > 0)
     if (x > 128)
      { printf("Invalid data size : link %d\n", link);
        forever sleep(30);
      }
a1333 9

     if (fetch_block(x, &(big_buffer[3 + amount]), TIMEOUT_VALUE))
      { printf("Hydra : failed to receive data vector from link %d\n");
        socket_broken(link);
        return;
      }
     amount += mcb.MsgHdr.DataSize;
   }
  socket_write(link, &(big_buffer[3]), amount);
d1336 2
a1338 13
*** At present the debugging protocol is not supported.
**/
PRIVATE void get_dbg_from_server(link)
int link;
{ use(link)
}

PRIVATE void get_dbg_from_trannie(link)
int link;
{ use(link)
}

/**
d1363 1
d1370 2
a1371 1
   { close(fildes);
d1382 1
d1399 1
d1445 7
a1454 1
/*@@@@@@ 16.05.90 for safety reasons */
d1462 1
d1467 2
d1648 2
a1650 1

a1932 1
/*@@@@@@ 16.05.90 If you dont do this, hydra will crash in select.*/
d1942 2
a1943 1
{ int written = 0, i = 0;
d1945 2
a1946 2

  while ((written < amount) && (i++ < 100))
d1948 6
a1953 1
     if (x <= 0) socket_broken(link);
d1955 1
a1955 3
   } 

  if (written < amount) socket_broken(link); 
d1962 2
a1963 1
{ int read_so_far = 0, i = 0;
d1965 9
a1973 4

  while ((read_so_far < amount) && (i++ < 100))
   { int x= read(fildes, &(buf[read_so_far]), amount - read_so_far);
     if (x <= 0) socket_broken(link);
d1975 3
a1977 1
   } 
a1978 3
  if (read_so_far < amount) socket_broken(link);

}
@


1.14
log
@Added HP9000 support
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.13 1993/02/05 15:02:50 bart Exp $ */
d1880 1
@


1.13
log
@Now gives the right message if there is only one link device
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.11 1993/01/12 15:58:37 bart Exp $ */
d249 1
a249 1
#if (TR5 || i486V4)
d496 1
a496 1
PRIVATE void fn( accept_debug_connection, ( int, socket_msg *));
d1669 1
a1669 1
#if (RS6000)
d1691 1
a1691 1
#if (RS6000)
d1821 1
a1821 1
#if (ST || TRIPOS || SUN3 || SUN4 || SM90 || TR5 || RS6000)
d1841 1
a1841 1
#if (RS6000)
@


1.12
log
@If the socket to an I/O Server broke, e.g. because the I/O Server was
killed, then the link was not being released and the site became
unusable.
@
text
@d243 2
a244 1
  printf("Hydra : running on %d links.\n", number_of_links);
a1879 1
  free_link(link);
@


1.11
log
@ported to RS6000
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.10 1992/10/09 12:25:37 martyn Exp $ */
d1879 1
@


1.10
log
@added support for i486 System V.4
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.9 1992/06/22 11:40:38 martyn Exp $ */
d1668 3
d1674 1
d1690 3
d1696 1
d1820 1
a1820 1
#if (ST || TRIPOS || SUN3 || SUN4 || SM90 || TR5)
d1840 3
d1845 1
@


1.9
log
@allow SIGSEGV signal through.
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.8 1992/03/06 11:52:58 martyn Exp martyn $ */
d248 1
a248 1
#if TR5
@


1.8
log
@new version from Telmat to include TR5000
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.7 1991/10/02 15:54:55 martyn Exp $ */
d320 2
d324 1
@


1.7
log
@slight bug if daemon failed to fork
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.6 1991/07/22 14:15:59 martyn Exp $ */
d248 3
d252 1
d333 1
a333 1
#if (SM90)
d562 4
d843 3
d847 1
d858 3
d1809 1
a1809 1
#if (ST || TRIPOS || SUN3 || SUN4 || SM90)
@


1.6
log
@latest mods from Telmat for signals and pipes on SM90
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.5 1991/06/06 10:08:46 martyn Exp martyn $ */
d255 1
@


1.5
log
@added code to detach hydra from controlling terminal.
also change real uid and gid to the effective uid and gid, so that
set-uid or set-gid bits on hydra binary work OK
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.4 90/11/27 15:07:13 alan Exp $ */
d290 2
d295 1
d328 2
d333 1
@


1.4
log
@merge with telmat
@
text
@d14 1
a14 1
/* RcsId: $Id: hydra.c,v 1.3 90/10/17 13:51:21 alan Exp Locker: alan $ */
d205 1
d244 15
@


1.3
log
@incorporate Parsytec changes
@
text
@d14 1
a14 1
/* RcsId: $Id$ */
d483 3
d487 1
d496 5
@


1.2
log
@added RcsId
@
text
@d50 2
d156 1
d159 1
d170 1
d220 5
a224 1
  if (!read_config(configname)) goto endpoint;
d490 1
a490 1
            if (rdrdy())		  /* JMP 29/06/90 test inverted ! */
d494 6
d504 6
a509 2
         FD_SET(link_table[i].connection, &rd_mask);
         if (link_table[i].connection > max_fd) max_fd=link_table[i].connection;
d541 8
a548 2
      { if (FD_ISSET(link_table[i].connection, &rd_mask))
           from_server(i);
d551 1
d802 2
a803 1
{ int protocol = 0;
d806 1
a806 1
  if (byte_from_link(&(buf[0])))
d809 2
d814 1
a814 1
  protocol = buf[0];
d821 1
a821 1
   { case Proto_Write : fetch_block(8, &(buf[1]), 1000);
d825 1
a825 1
     case Proto_Read : fetch_block(4, &(buf[1]), 1000);
d828 1
a828 1
                       send_block(4, buf, 1000);
d843 1
a843 1
                         fetch_block(11, &(buf[1]), 1000);
d847 1
a847 1
                         send_block(12, buf, 1000);
d905 1
a905 1
                                   send_block(9, buf, 1000);
d909 2
a910 2
                                  send_block(5, buf, 1000);
                                  fetch_block(4, buf, 1000);
d958 1
a958 1
                            send_block(5, buf, 1000);
d964 1
a964 1
                            fetch_block(27 * 4, buf, 1000);
d1004 1
a1004 1
                             send_block(9, buf, 1000);
d1009 2
a1010 2
                             send_block(5, buf, 1000);
                             fetch_block(4, buf, 1000);
d1020 2
a1021 2
                             send_block(12, buf, 1000);
                             fetch_block(12, buf, 1000);
d1088 1
a1088 1
     send_block((int) buf[0] + 1, buf, 1000);
d1101 1
a1101 1
  send_block(x, big_buffer, 1000);
d1111 1
a1111 1
  send_block(x+4, big_buffer, 1000);
d1164 1
a1164 1
  if (send_block(amount, &(big_buffer[3]), 1000))
d1176 1
a1176 1
  if (fetch_block(16, &(big_buffer[4]), 16))
d1211 1
a1211 1
     if (fetch_block(x, &(big_buffer[3 + amount]), 1000))
d1229 1
a1229 1
     if (fetch_block(x, &(big_buffer[3 + amount]), 1000))
d1358 3
a1360 1
  strncpy(reply.linkname, link_table[link].link_name, 15);
d1820 2
@


1.1
log
@Initial revision
@
text
@d14 2
a15 1
/* SccsId: 3.9 29/6/90   Copyright (C) 1989, Perihelion Software Ltd.       */
@
