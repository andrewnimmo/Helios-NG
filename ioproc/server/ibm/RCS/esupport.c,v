head	1.9;
access;
symbols
	Helios_1_3_1:1.9
	Helios_C40_1_3_Official_Release:1.9
	Helios-C40:1.9
	Alenia_release:1.8
	Helios1_3:1.8
	C40_Field_Test_2:1.8
	C40_Field_Test_R1:1.6
	Helios13_beta:1.6
	Helios1_2_2:1.2
	Helios1_2_2Beta:1.2
	Helios1_2_1:1.2;
locks; strict;
comment	@ * @;


1.9
date	93.01.21.14.40.37;	author paul;	state Exp;
branches;
next	1.8;

1.8
date	92.09.06.13.14.24;	author craig;	state Exp;
branches;
next	1.7;

1.7
date	92.07.29.16.13.56;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	92.06.19.09.47.31;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	92.06.13.14.18.50;	author craig;	state Exp;
branches;
next	1.4;

1.4
date	92.05.12.14.52.40;	author craig;	state Exp;
branches;
next	1.3;

1.3
date	92.05.04.19.24.04;	author craig;	state Exp;
branches;
next	1.2;

1.2
date	90.11.01.14.15.01;	author alan;	state Exp;
branches;
next	1.1;

1.1
date	90.10.17.12.18.11;	author alan;	state Exp;
branches;
next	;


desc
@ethernet support
@


1.9
log
@updated for ARM port + MSC v6.0 compatibility
@
text
@/****************************************************************
*                                                               *
*                           HELIOS                              *
*                                                               *
*       Copyright (C) 1990, Perihelion Software Limited         *
*                       All Rights Reserved                     *
*                                                               *
*****************************************************************

File        : esupport.c
Description : support routines for driving nic chip
              #included in ether.c

RcsId: $Id: esupport.c,v 1.8 1992/09/06 13:14:24 craig Exp $

*****************************************************************
* Author: Alan Cosslett                              April 1990 *
****************************************************************/

#ifdef OLD_ETHER
#include "defs8390.h"
#include "defs583.h"

PRIVATE unsigned int nicbase;		/* actual addres of 8360 chip */
#define eb nicbase			/* alias of above	      */

#define BT_UNKNOWN 0
#define BT_WESTERN_DIGITAL 1
#define BT_DLINK 2
#endif /* OLD_ETHER */

#ifndef OLD_ETHER

#if _MSC_VER <= 600
#define	_segread segread
#define _REGS	REGS
#define _SREGS	SREGS
#endif

/*
-- ===========================================================================
-- Support for Clarkson Packet Drivers
-- crf: May 1992
-- ===========================================================================
*/

#include "etherdef.h"

/*
-- packet driver s/w interrupt
*/
PRIVATE SHORT pkt_int_no = -1 ;	
/*
-- associates access to packet type
*/
PRIVATE	SHORT drvr_handle [NUM_HANDLES] = { -1, -1 } ;
#if !MSWINDOWS
/*
-- table of packet buffers
*/
PRIVATE byte ether_pkt_table [MAX_PKT_TABLE] [MAXETHERPKT] ;
#else /* MSWINDOWS */
/*
-- crf: simply to maintain uniformity
*/
#define ether_pkt_table	DOS_data->rx_buffer
#endif /* MSWINDOWS */
/*
-- packet length vector
*/
PRIVATE SHORT ether_pkt_len [MAX_PKT_TABLE] ;
/*
-- index into packet buffer table
*/
PRIVATE SHORT pkt_index = 0 ;

/*
-- Data used by receiver routine 
-- packet received - incremented by receiver routine, decremented when packet consumed
*/
SHORT pkt_rcvd = 0 ;
#if !MSWINDOWS
/*
-- pointer to packet buffer table
*/
byte* pkt_table = ether_pkt_table [0] ;
#endif /* !MSWINDOWS */
/*
-- pointer to packet length vector
*/
SHORT *pkt_len = ether_pkt_len ;
/*
-- rx errors (set by receiver routine)
*/
SHORT pkt_too_long = 0 ;
#ifdef ETHER_DEBUG
SHORT pkt_overflow = 0 ;
#endif /* ETHER_DEBUG */

/* 
-- Errors returned from packet driver 
*/
PRIVATE SHORT drvr_err = 0 ;
PRIVATE byte *Drvr_Err_Code [NUM_ERR_CODES] =
{
"No error",							/* NO_ERROR		0 */
"Invalid handle number",					/* BAD_HANDLE		1 */
"No interfaces of specified class found",			/* NO_CLASS		2 */
"No interfaces of specified type found",			/* NO_TYPE		3 */
"No interfaces of specified number found",			/* NO_NUMBER		4 */
"Bad packet type specified",					/* BAD_TYPE		5 */
"Interface does not support multicast",				/* NO_MULTICAST		6 */
"Packet driver cannot terminate",				/* CANT_TERMINATE	7 */
"Invalid receiver mode was specified",				/* BAD_MODE		8 */
"Operation failed - insufficient space",			/* NO_SPACE		9 */
"Type previously accessed and not released",			/* TYPE_INUSE		10 */
"Command out of range or not implemented",			/* BAD_COMMAND		11 */
"Packet couldn't be sent (usually hardware error)",		/* CANT_SEND		12 */
"Hardware address couldn't be changed (> 1 handle open)",	/* CANT_SET		13 */
"Hardware address has bad length or format",			/* BAD_ADDRESS		14 */
"Couldn't reset interface (> 1 handle open)"			/* CANT_RESET		15 */
} ;

/*
-- Ethertypes
*/
PRIVATE USHORT ether_type [NUM_HANDLES] = { ETHERTYPE_ARP , ETHERTYPE_IP } ;

#ifdef ETHER_STATS
typedef struct Ether_Stats
{
	UWORD pkts_in ;
	UWORD pkts_out ;
	UWORD bytes_in ;
	UWORD bytes_out ;
	UWORD errors_in ;
	UWORD errors_out ;
	UWORD pkts_lost ;
} Ether_Stats ;
#endif /* ETHER_STATS */

#define TEST_ERROR			\
	if (regs.x.cflag)		\
	{				\
		drvr_err = regs.h.dh ;	\
		return -1 ;		\
	}


/*
-- ===========================================================================
-- Routines that interact directly with the packet drivers
-- ===========================================================================
*/

PRIVATE SHORT drvr_info (SHORT, 
#ifdef ETHER_DEBUG
			SHORT, SHORT *, SHORT *, byte *,
#endif /* ETHER_DEBUG */
			SHORT *, SHORT *, SHORT *) ;

/*
-- assembler receiver routine
-- activated by packet driver when packet comes in
*/
extern void receiver (void) ;
PRIVATE SHORT access_type (SHORT, SHORT, SHORT, SHORT, byte *, USHORT,
			void (*) (void)) ;

PRIVATE SHORT get_address (SHORT, SHORT, byte *, SHORT) ;
PRIVATE SHORT release_type (SHORT, SHORT) ;
PRIVATE SHORT send_pkt (SHORT, byte *, USHORT) ;

#ifdef ETHER_STATS
PRIVATE SHORT get_stats (SHORT, SHORT, Ether_Stats *) ;
#endif /* ETHER_STATS */

/*
-- ===========================================================================
-- Support routines
-- ===========================================================================
*/
PRIVATE SHORT locate_pkt_drvr (USHORT) ;
PRIVATE bool clarksonp (void) ;
PRIVATE bool fail (byte *, ...) ;
PRIVATE void notify (byte *, ...) ;
PRIVATE bool notify_error (byte *, ...) ;
PRIVATE void notify_rx_error (void) ;
PRIVATE void release_all (SHORT, SHORT *) ;
#ifdef ETHER_STATS
PRIVATE void show_ether_statistics (SHORT, SHORT) ;
#endif /* ETHER_STATS */

#if MSWINDOWS
#include "..\windows\win_ether.c"
#endif /* MSWINDOWS */

/*
-- ===========================================================================
-- Routines that interact directly with the packet drivers
-- ===========================================================================
*/

PRIVATE SHORT drvr_info (SHORT int_no, 
#ifdef ETHER_DEBUG
			SHORT handle, SHORT *version, SHORT *drvr_funct,
			byte *if_name, 
#endif /* ETHER_DEBUG */
			SHORT *if_class, SHORT *if_type, SHORT *if_number)
{
	union _REGS regs;
	struct _SREGS sregs ;
#ifdef ETHER_DEBUG
#if !MSWINDOWS
	byte *name_ptr ;
#endif /* !MSWINDOWS */
#endif /* ETHER_DEBUG */

#if _MSC_VER <= 600
	segread (&sregs) ;
#else
	_segread (&sregs) ;
#endif
#ifdef ETHER_DEBUG
	regs.x.bx = handle ;
#endif /* ETHER_DEBUG */
	regs.h.ah = DRIVER_INFO ;
	regs.h.al = 0xff ;
#if _MSC_VER <= 600
	int86x (int_no, &regs, &regs, &sregs) ;
#else
	_int86x (int_no, &regs, &regs, &sregs) ;
#endif
	TEST_ERROR
	*if_class   = regs.h.ch ;
	*if_type    = regs.x.dx ;
	*if_number  = regs.h.cl ;
#ifdef ETHER_DEBUG
	*version  = regs.x.bx ;
	*drvr_funct = regs.h.al ;
#if !MSWINDOWS
	FP_SEG (name_ptr) = sregs.ds ;
	FP_OFF (name_ptr) = regs.x.si ;
	if (strlen (name_ptr) >= IFACE_NAME_LEN)
		name_ptr [IFACE_NAME_LEN] = '\0' ;
	strncpy (if_name, name_ptr, strlen (name_ptr) + 1) ;
#else /* MSWINDOWS */
/*
-- crf: I am not going to bother messing around with descriptors, etc. to get
-- the interface name ... I am only interested in the name for debugging 
-- purposes (i.e. if ETHER_DEBUG is defined).
*/
	strcpy (if_name, "Unknown") ;
#endif /* MSWINDOWS */

#endif /* ETHER_DEBUG */
	return 0 ;
}

/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT access_type (SHORT int_no,
			SHORT if_class, SHORT if_type, SHORT if_number,
			byte *buffer, USHORT buf_len,
			void (*receiver) (void))
{
	union _REGS regs ;
	struct _SREGS sregs ;
	
	_segread (&sregs) ;

#if !MSWINDOWS
	sregs.es  = FP_SEG (receiver) ;
	regs.x.di = FP_OFF (receiver) ;
#else /* MSWINDOWS */
	if (alloc_real_callback (receiver, 
				&DOS_data->callback_regs,
				&SEG_real_callback, &OFF_real_callback) < 0)
		RETURN_ERROR ("Failed to allocate real mode callback address") ;
	sregs.es  = SEG_real_callback ;
	regs.x.di = OFF_real_callback ;
#endif /* MSWINDOWS */

#if !MSWINDOWS
	sregs.ds  = FP_SEG (buffer) ;
	regs.x.si = FP_OFF (buffer) ;
#else /* MSWINDOWS */
{
	byte *temp_ptr = DOS_data->access_type_buffer ;
	memcpy (temp_ptr, buffer, buf_len) ;
	sregs.ds = wSegment ;
	regs.x.si = FP_OFF (temp_ptr) ;
}
#endif /* MSWINDOWS */

	regs.h.dl = (UBYTE) if_number ;
	regs.x.cx = buf_len ;
	regs.x.bx = if_type ;
	regs.h.ah = ACCESS_TYPE ;
	regs.h.al = (UBYTE) if_class ;
#if !MSWINDOWS
#if _MSC_VER <= 600
	int86x (int_no, &regs, &regs, &sregs) ;
#else
	_int86x (int_no, &regs, &regs, &sregs) ;
#endif
	TEST_ERROR
	return regs.x.ax ;
#else /* MSWINDOWS */
	SIMULATE_INT (int_no)
	return (USHORT) DOS_data->real_int_regs._ax ;
#endif /* MSWINDOWS */
}

/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT get_address (SHORT int_no, SHORT handle, 
			byte *buffer, SHORT buf_len)
{
	union _REGS regs ;
	struct _SREGS sregs ;
#if MSWINDOWS
	byte *addr_ptr = DOS_data->address_buffer ;
#endif /* MSWINDOWS */

	_segread (&sregs) ;
#if !MSWINDOWS
	sregs.es  = FP_SEG (buffer) ;
	regs.x.di = FP_OFF (buffer) ;
#else /* MSWINDOWS */
	sregs.es = wSegment ;
	regs.x.di = FP_OFF (addr_ptr) ;
#endif /* MSWINDOWS */

	regs.x.cx = buf_len ;
	regs.x.bx = handle ;
	regs.h.ah = GET_ADDRESS ;
#if !MSWINDOWS
#if _MSC_VER <= 600
	int86x (int_no, &regs, &regs, &sregs) ;
#else
	_int86x (int_no, &regs, &regs, &sregs) ;
#endif
	TEST_ERROR
	return (regs.x.cx) ;
#else /* MSWINDOWS */
	SIMULATE_INT (int_no)
	memcpy (buffer, addr_ptr, buf_len) ;
	return (USHORT) DOS_data->real_int_regs._ax ;
#endif /* MSWINDOWS */
}

/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT release_type (SHORT int_no, SHORT handle)
{
	union _REGS regs ;
	regs.x.bx = handle ;
	regs.h.ah = RELEASE_TYPE ;
#if _MSC_VER <= 600
	int86 (int_no, &regs, &regs) ;
#else
	_int86 (int_no, &regs, &regs) ;
#endif
	TEST_ERROR
	return 0 ;
}

/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT send_pkt (SHORT int_no, byte *buffer, USHORT buf_len)
{
	union _REGS regs ;
	struct _SREGS sregs ;

	_segread (&sregs) ;
#if !MSWINDOWS
	sregs.ds = FP_SEG (buffer) ;
	regs.x.si = FP_OFF (buffer) ;
#else /* MSWINDOWS */
{
	byte *temp_ptr = DOS_data->tx_buffer ;
	memcpy (temp_ptr, buffer, buf_len) ;
	sregs.ds = wSegment ;
	regs.x.si = FP_OFF (temp_ptr) ;
}
#endif /* MSWINDOWS */

#ifdef DRIVER_BUG
	sregs.es = FP_SEG (buffer) ;
#endif

	regs.x.cx = buf_len ;
	regs.h.ah = SEND_PKT ;
#if !MSWINDOWS
#if _MSC_VER <= 600
	int86x (int_no, &regs, &regs, &sregs) ;
#else
	_int86x (int_no, &regs, &regs, &sregs) ;
#endif
	TEST_ERROR
#else /* MSWINDOWS */
	SIMULATE_INT (int_no)
#endif /* MSWINDOWS */
	return 0 ;
}

/*
------------------------------------------------------------------------------
*/

#ifdef ETHER_STATS
PRIVATE SHORT get_stats (SHORT int_no, SHORT handle, Ether_Stats *stats)
{
	Ether_Stats *stats_ptr ;
	union _REGS regs ;
	struct _SREGS sregs ;
#if MSWINDOWS
	USHORT selector ;
#endif /* MSWINDOWS */

	_segread (&sregs) ;
	regs.h.ah = GET_STATISTICS ;
	regs.x.bx = handle ;
	
#if !MSWINDOWS
#if _MSC_VER <= 600
	int86x (int_no, &regs, &regs, &sregs) ;
#else
	_int86x (int_no, &regs, &regs, &sregs) ;
#endif
	TEST_ERROR

	FP_SEG (stats_ptr) = sregs.ds ;
	FP_OFF (stats_ptr) = regs.x.si ;
#else /* MSWINDOWS */
	SIMULATE_INT (int_no)
	{
/*
-- crf: more efficient to allocate and free the descriptor once (i.e. before
-- and after locating the packet driver). I'm doing it this for the sake of
-- keeping all the DPMI related stuff together.
*/
		if (allocate_descriptor (&selector) < 0)
			RETURN_ERROR ("Failed to allocate descriptor") ;

		if (init_selector (selector, 
					DOS_data->real_int_regs._ds,
					(USHORT) DOS_data->real_int_regs._si) < 0)
			RETURN_ERROR ("Failed to initialize selector") ;

		FP_SEG (stats_ptr) = selector ;
		FP_OFF (stats_ptr) = 0 ;
}
#endif /* MSWINDOWS */

	memcpy (stats, stats_ptr, sizeof (Ether_Stats)) ;
	
#if !MSWINDOWS
	return regs.x.ax ;
#else /* MSWINDOWS */
	if (free_descriptor (&selector) < 0)
		(void) notify_error ("Warning: failed to release descriptor") ;
	return (USHORT) DOS_data->real_int_regs._ax ;
#endif /* MSWINDOWS */
}
#endif /* ETHER_STATS */

/*
-- ===========================================================================
-- Support routines
-- ===========================================================================
*/

#define CHECK_SIGNATURE	(!strncmp ((byte *) (drvr_vec + 3) , DRVR_SIG, strlen (DRVR_SIG))) ;

PRIVATE SHORT locate_pkt_drvr (USHORT int_no)
{
	word drvr_vec ;

#if !MSWINDOWS
	drvr_vec = (word) _dos_getvect (int_no) ;
	return CHECK_SIGNATURE ;
#else /* MSWINDOWS */
	USHORT base_selector ;
	SHORT result ;

	if (allocate_descriptor (&base_selector) < 0)
		RETURN_ERROR ("Failed to allocate descriptor") ;

	drvr_vec = DPMI_getvect (int_no, base_selector) ;
	if (drvr_vec < 0)
		return (-1) ;

	result = CHECK_SIGNATURE ;
	
	if (free_descriptor (&base_selector) < 0)
		(void) notify_error ("Warning: failed to release descriptor") ;

	return (result) ;
#endif /* MSWINDOWS */
}

/*
------------------------------------------------------------------------------
*/

PRIVATE bool clarksonp ()
{
	SHORT located = 0 ;

#if MSWINDOWS
	if (allocate_dos_memory (&DOS_data, &wSelector, &wSegment) < 0)
		return (fail ("Failed to allocate DOS memory")) ;
#endif /* MSWINDOWS */

	if (pkt_int_no == -1)
	{
#ifdef ETHER_DEBUG
		notify ("searching for pkt drvr") ;
#endif /* ETHER_DEBUG */
		pkt_int_no = MIN_PKT_INT ;
		while (pkt_int_no <= MAX_PKT_INT)
		{		
			located = locate_pkt_drvr (pkt_int_no) ;
			if (located)
				break ;
			pkt_int_no ++ ;
		}
		if (!located)
			return (fail ("%s in range 0x%x-0x%x", CANT_LOCATE, MIN_PKT_INT, MAX_PKT_INT)) ;
	}
	else
	{
		if ((pkt_int_no < MIN_PKT_INT) || (pkt_int_no > MAX_PKT_INT))
			return (fail ("Invalid %s (0x%x) - must be in range 0x%x-0x%x", HOST_PKT_INT, pkt_int_no, MIN_PKT_INT, MAX_PKT_INT)) ;
		located = locate_pkt_drvr (pkt_int_no) ;
		if (!located)
			return (fail ("%s at 0x%x (%d)", CANT_LOCATE, pkt_int_no, pkt_int_no)) ;
	}
#if MSWINDOWS
	if (located < 0)
/*
-- crf: if this happens, the cause of the error and the error code should have
-- been displayed already.
*/
		return (fail (CANT_LOCATE)) ;
#endif /* MSWINDOWS */

#ifdef ETHER_DEBUG
	notify ("Located packet driver at 0x%x (%d)", pkt_int_no, pkt_int_no) ;
#endif /* ETHER_DEBUG */

	{
		SHORT iface_class, iface_type, iface_number ;
#ifdef ETHER_DEBUG
		SHORT version ;
		byte iface_name [IFACE_NAME_LEN] ;
		SHORT drvr_funct ;
#endif /* ETHER_DEBUG */

		if (drvr_info (pkt_int_no, 
#ifdef ETHER_DEBUG
				drvr_handle[0], &version, &drvr_funct,
				(byte *) &iface_name,
#endif /* ETHER_DEBUG */
				&iface_class, &iface_type, &iface_number) < 0)
			return (fail ("Failed to get interface information")) ;

#ifdef ETHER_DEBUG
		notify ("version = 0x%x (%d)", version, version) ;
		notify ("iface_class = 0x%x (%d)", iface_class, iface_class) ;
		notify ("iface_type = 0x%x (%d)", iface_type, iface_type) ;
		notify ("iface_number = 0x%x (%d)", iface_number, iface_number) ;
		notify ("drvr_funct = 0x%x (%d)", drvr_funct, drvr_funct) ;
		notify ("iface_name = %s", iface_name) ;			
#endif /* ETHER_DEBUG */

		{
			SHORT i ;
			for (i = 0 ; i < NUM_HANDLES ; i ++)
			{	
				USHORT pkt_type = ether_type [i] ;
				drvr_handle[i] = access_type (pkt_int_no, 
						iface_class, iface_type, iface_number,
						(byte *) &pkt_type, PKT_TYPE_LEN, 
						receiver) ;
				if (drvr_handle[i] < 0)
					return (fail ("Failed to initiate access to packet type")) ;
#ifdef ETHER_DEBUG
				notify ("drvr_handle [%d] = 0x%x (%d)", i, drvr_handle[i], drvr_handle[i]) ;
#endif /* ETHER_DEBUG */
			}
		}
	}

	{
		SHORT addr_len ;
		addr_len = get_address (pkt_int_no, drvr_handle[0], etheraddr, sizeof (etheraddr)) ;
		if (addr_len < 0)
			return (fail ("Failed to get Ethernet address")) ;
		notify ("Ethernet address  %02x:%02x:%02x:%02x:%02x:%02x",
			etheraddr[0],etheraddr[1],etheraddr[2],etheraddr[3],etheraddr[4],etheraddr[5]) ;
	}
	return (true) ;
}

/*
------------------------------------------------------------------------------
*/

#include <stdarg.h>

PRIVATE bool fail (byte *format, ...)
{
	va_list args;
	byte msg [256] ;

	va_start (args, format);
	vsprintf (msg, format, args) ;    
	va_end (args);
	(void) notify_error (msg) ;
	release_all (pkt_int_no, drvr_handle) ;
	return (false) ;
}

/*
------------------------------------------------------------------------------
*/

PRIVATE void notify (byte *format, ...)
{
	va_list args;
	byte msg [256] ;
	va_start (args, format);
	vsprintf (msg, format, args) ;    
	ServerDebug ("/ether: %s", msg) ;
	va_end (args);
}

/*
------------------------------------------------------------------------------
*/

PRIVATE bool notify_error (byte *format, ...)
{
	va_list args;
	byte msg [256] ;

	va_start (args, format);
	vsprintf (msg, format, args) ;    
	va_end (args);
	notify (msg) ;
	if (drvr_err > 0)
	{
		if (drvr_err < NUM_ERR_CODES)
			notify ("Error %d: %s", drvr_err, Drvr_Err_Code [drvr_err]) ;
		else
			notify ("Unknown error code: 0x%x", drvr_err) ;
		drvr_err = 0 ;
	}
#if MSWINDOWS
	if (DPMI_err > 0)
	{
		notify ("DPMI error: 0x4%x", DPMI_err) ;
		DPMI_err = 0 ;
	}
#endif /* MSWINDOWS */
	return (false) ;
}

/*
------------------------------------------------------------------------------
*/

PRIVATE void notify_rx_error ()
{
	if (pkt_too_long)
	{
		notify ("RX error - bad packet size (%d bytes) - packet discarded", pkt_too_long) ;
		pkt_too_long = 0 ;
	}
#ifdef ETHER_DEBUG
	if (pkt_overflow)
	{
		notify ("Buffer overflow - packet discarded") ; 
		pkt_overflow = 0 ;
	}
#endif /* ETHER_DEBUG */
}

/*
------------------------------------------------------------------------------
*/

PRIVATE void release_all (SHORT int_no, SHORT *handle)
{
	SHORT i ;
	for (i = 0 ; i < NUM_HANDLES ; i ++)
	{
		SHORT curr_handle = handle [i] ;
		if (curr_handle != -1)
		{
			if (release_type (int_no, curr_handle) < 0)
				(void) notify_error ("Failed to release access to packet type") ;
#ifdef ETHER_DEBUG
			else
				notify ("released handle: 0x%x (%d)", curr_handle, curr_handle) ;
#endif /* ETHER_DEBUG */
		}
	}
#if MSWINDOWS
	release_DPMI_resources (&wSelector, 
				&SEG_real_callback, &OFF_real_callback) ;
#endif /* MSWINDOWS */
}

/*
------------------------------------------------------------------------------
*/

#ifdef ETHER_STATS
PRIVATE void show_ether_statistics (SHORT int_no, SHORT handle)
{
	Ether_Stats stats ;
	if (get_stats (int_no, handle, &stats) < 0)
	{
		(void) notify_error ("Failed to get statistics") ;
		return ;
	}
	notify ("Statistics") ;
	notify ("pkts in    = %d", stats.pkts_in) ;
	notify ("pkts out   = %d", stats.pkts_out) ;
	notify ("bytes in   = %d", stats.bytes_in) ;
	notify ("bytes out  = %d", stats.bytes_out) ;
	notify ("errors in  = %d", stats.errors_in) ;
	notify ("errors out = %d", stats.errors_out) ;
	notify ("pkts lost  = %d", stats.pkts_lost) ;
}
#endif /* ETHER_STATS */

/*
-- ===========================================================================
-- Unused routines
-- ===========================================================================
*/

#if 0

PRIVATE SHORT reset_interface (SHORT int_no, SHORT handle)
{
/*
-- crf: careful with this ...
*/
	union _REGS regs ;
	regs.x.bx = handle ;
	regs.h.ah = RESET_INTERFACE ;
#if _MSC_VER <= 600
	int86 (int_no, &regs, &regs) ;
#else
	_int86 (int_no, &regs, &regs) ;
#endif
	TEST_ERROR
	return 0 ;
}

/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT terminate (SHORT int_no, SHORT handle)
{
	union _REGS regs ;
	regs.x.bx = handle ;
	regs.h.ah = TERMINATE ;
#if _MSC_VER <= 600
	int86 (int_no, &regs, &regs) ;
#else
	_int86 (int_no, &regs, &regs) ;
#endif
	TEST_ERROR
	return 0 ;
}
#endif /* 0 (unused) */

/*
-- ===========================================================================
-- End of Support for Clarkson Packet Drivers
-- ===========================================================================
*/

#endif /* !OLD_ETHER */

#ifdef OLD_ETHER
PRIVATE UBYTE   StartIndex;
PRIVATE UBYTE   StopIndex;
PRIVATE UBYTE   NextPkt;
PRIVATE UBYTE*  StartPtr;
PRIVATE UBYTE*  StopPtr;
PRIVATE UBYTE   TxTimeout;
PRIVATE UBYTE   TxPktNo;
PRIVATE UBYTE*  TxPktPtr;
PRIVATE bool    TxAvail;
PRIVATE bool    Overflow;
PRIVATE bool    Overrun;
PRIVATE bool    Underrun;
PRIVATE bool    ResetMe;

/* the statistics */


PRIVATE USHORT prx_no = 0;      /* pkts received                */
PRIVATE USHORT ptx_no = 0;      /* pkts transmitted             */
PRIVATE USHORT rxe_no = 0;      /* pkts received with errors    */
PRIVATE USHORT txe_no = 0;      /* pkts transmitted with errors */
PRIVATE USHORT ovw_no = 0;      /* number of buffer overflows   */
PRIVATE USHORT cnt_no = 0;      /* number of counter overflows  */
PRIVATE USHORT col_no = 0;      /* number of collisions         */
PRIVATE USHORT abt_no = 0;      /* number of aborts             */
PRIVATE USHORT crs_no = 0;      /* number of carrier sense lost */
PRIVATE USHORT fu_no = 0;       /* number of fifo underruns     */
PRIVATE USHORT cdh_no = 0;      /* number of cd heartbeats      */
PRIVATE USHORT owc_no = 0;      /* number of out of window errs */
PRIVATE USHORT crc_no = 0;      /* number of crc errors         */
PRIVATE USHORT fae_no = 0;      /* number of frame alignment errs */
PRIVATE USHORT fo_no = 0;       /* number of fifo overruns      */
PRIVATE USHORT mpa_no = 0;      /* number of missed pkts        */
PRIVATE USHORT tap_no = 0;      /* number of thrown away pkts   */
PRIVATE USHORT int_no = 0;      /* number of times interrupted  */

/* function prototypes */

PRIVATE bool etherboardp();		/* do we have a board */
PRIVATE int getboardtype();		/* returns type of board */
PRIVATE bool westerndigp();		/* check for wesetrn dig board */
PRIVATE bool dlinkp();			/* check for dlink board */
PRIVATE void dlinkaddr();		/* find the board address */
#endif /* OLD_ETHER */

PRIVATE void tidyboard(void);		
#ifdef OLD_ETHER
PRIVATE bool SendTxPkt();
PRIVATE SHORT GeEtRxPkt();
#else /* !OLD_ETHER */
PRIVATE bool SendTxPkt(byte*, USHORT) ;
PRIVATE SHORT GetRxPkt (UBYTE*, word) ;
#endif /* !OLD_ETHER */

#ifdef OLD_ETHER
#ifdef ETHERINTS
PRIVATE void init_int_vector();
PRIVATE void restore_int_vector();
#endif

PRIVATE void HandleError();
PRIVATE void rxerror();
PRIVATE void txerror();
PRIVATE void resetboard();
PRIVATE bool RxAvail();

PUBLIC void ether_something();

#ifdef ETHERINTS
extern void set_einterrupts();
extern void restore_einterrupts();
#endif

typedef struct PktStatus
{
  UBYTE RStatus;
  UBYTE psNextPkt;
  UBYTE psRBCR0;
  UBYTE psRBCR1;
} PktStatus;

/* routine to check the board to see if its there       */
/* and if it is initialise the word                     */

PRIVATE bool etherboardp()
{
  int i;

  if (getboardtype() == BT_UNKNOWN) return false; 

  StartIndex = (UBYTE)8+TxPktNo;
  StopIndex  = (UBYTE)0x20+TxPktNo;
  TxTimeout  = 0;
  StartPtr   = &((UBYTE*)ethermem)[StartIndex<<8];  
  StopPtr    = &((UBYTE*)ethermem)[StopIndex<<8];
  TxAvail    = true;
  
  ResetMe = false;
  Overrun = false;
  Underrun = false;
  Overflow = false;

  /* make sure the board is stopped */
  /* probably do not need           */
  
  outp(eb+CR,0x21);
  outp(eb+IMR,0);

 /* initialise the board just as it says in the docs */

  outp(eb+CR,0x21);             /* Stage 1 - Stop The Board             */
  outp(eb+DCR,0x48);            /* Stage 2 - Set Data Config Register   */
  outp(eb+RBCR0,0);             /* Stage 3 - Clear Remote Byte Counts   */
  outp(eb+RBCR1,0);             /* Stage 3 - Clear Remote Byte Counts   */

  outp(eb+RCR,etherrcr);        /* Stage 4 - Set the receive confi reg  */
  outp(eb+TCR,4);               /* Stage 5 - put nic in loopback mode 2 */
  outp(eb+BNRY,StartIndex);     /* Stage 6 - init boundary ptr          */
  outp(eb+PSTART,StartIndex);   /* Stage 6 - init page start ptr        */
  outp(eb+PSTOP,StopIndex);     /* Stage 6 - init page stop ptr         */
  outp(eb+ISR,0xFF);            /* Stage 7 - clear interrupt status     */
  outp(eb+IMR,0);               /* Stage 8 - no interrupts              */
  outp(eb+CR,0x61);             /* Stage 9 - set to page 1              */

  for (i = 0; i < 6; i++)
  {
    outp(eb+PAR0+i,etheraddr[i]); /* Stage 9 - set ether net address    */      
    outp(eb+MAR0+i,ethermult[i]); /* Stage 9 - set multicast address    */
  }

  outp(eb+MAR6,ethermult[6]);   /* Stage 9 - set multicast address    */
  outp(eb+MAR7,ethermult[7]);   /* Stage 9 - set multicast address    */

  outp(eb+CURR,StartIndex+1);   /* Stage 9 initialise current pointer */
  
  NextPkt = StartIndex+1;       /* Stage 9 initialise next packet     */

  StopIndex--;                  /* make life easier for later         */

  outp(eb+CR,0x22);             /* Stage 10 - start the nic           */
  outp(eb+TCR,0);               /* Stage 11 - out of loopback mode    */   

  /* if we are a dlink board we can get the address now */
    
  if (ethertype == BT_DLINK) dlinkaddr(); 

  return true;
 
}
#endif /* OLD_ETHER */ 

PRIVATE void tidyboard()
{
#ifdef OLD_ETHER
  if (ethertype == BT_DLINK) outp(etherbase+0x1F,0);	 
  if (ethertype == BT_WESTERN_DIGITAL) outp(etherbase,0);
#else /* !OLD_ETHER */
#ifdef ETHER_STATS
  show_ether_statistics (pkt_int_no, drvr_handle [0]) ;
#endif /* ETHER_STATS */
  release_all (pkt_int_no, drvr_handle) ;
#endif /* !OLD_ETHER */
}

/* SendTxPkt - send a pkt to the net - if we can  */
/* N.B. the chip SHOULD interrupt when the pkt has */
/* gone causing the interrupt routine to set TxAvail */
/* However this cannot be relied on so we also set */
/* up TxTimeout as a failsafe and assume the packet has */
/* gone if this ever reaches zero. I use two variable TxTimeout */
/* and TxAvail so we do not have problems of the interrupt routine */
/* changing things half way through this routine and hence TxTimeout */
/* getting set to -1. This could be worked around. */

PRIVATE bool SendTxPkt(buff,len)
byte*  buff;
USHORT len;
{
#ifdef OLD_ETHER

#ifdef ETHERDEBUG	
  ServerDebug("/ether - ptx %d prx %d int %d %2x",ptx_no,prx_no,int_no,inp(eb+ISR));
  ServerDebug("/ether - chucked %d overruns %d  underruns %d overflows %d",
               tap_no,fo_no,fu_no,ovw_no);
#endif

  if (TxAvail || (TxTimeout == 0))
  {
    memcpy(TxPktPtr,buff,len);

    if (len <= 64) len = 64;
     
    outp(eb+TPSR,TxPktNo);  /* set up transmit page start */

    outp(eb+TBCR0,len % 0xFF);  /* set lower byte of length  */
    outp(eb+TBCR1,len / 0xFF);  /* set higher byte of length */
    outp(eb+CR,0x26);		/* transmit it		     */
    TxTimeout = 0xFF;		/* Kludge -- Set a timeout   */
    return true;		
  }
  else
  { 
    TxTimeout--;		/* dec the timeout           */
    return false;
  }

#else /* !OLD_ETHER */
#ifdef ETHER_DEBUG
  notify ("tx: pkt len = %d", len) ;
#endif /* ETHER_DEBUG */
  if (send_pkt (pkt_int_no, buff, len) < 0)
    return (notify_error ("Failed to send packet")) ;
  return (true) ;
#endif /* !OLD_ETHER */
}

#ifdef OLD_ETHER 
/* routine to set up interrupt stuff */
#ifdef ETHERINT
PRIVATE void init_int_vector()
{
  /* set up the interrupt vector */

  int level = etherlevel + 8;		/* plus 8 for some reason */
  
  byte mask = inp(0x21);		/* read old mask	 */
  outp(0x21, mask & ~(1 << etherlevel));/* set our level	 */
  set_einterrupts(level);		/* set our handler       */
  
  /* outp(eb+IMR,0x3f);  NO INTS ! turn on board ints    */
}

/* restore interrupts to how they were */

PRIVATE void restore_int_vector()
{
  byte mask = inp(0x21);		/* get int mask */
  outp(eb+CR,0x21);			/* stop the board */
  outp(eb+IMR,0);			/* stop board interrupting */
  restore_einterrupts(etherlevel+8);	/* put back old handler  */
  outp(0x21, mask | (1 << etherlevel)); /* turn of etherlevel interrupts   */
}

#endif

/* now for the interrupt routine */

void ether_something()
{
  /* ok we may or may not have been interrupted */

  byte status = (byte)inp(eb+ISR);    /* get in status */
  outp(eb+ISR,status);          /* and stop the ints */
  outp(eb+IMR,0);
  
  int_no ++;
  
/*  outp(0x20,0x20);               MAGIC to Enable lower interrups ? */

  if (status & (OVW|RXE|TXE|CNT)) HandleError(status);

  if (status & PTX) 		/* we have transmitted a pkt */
  {
    ptx_no++;
    TxAvail = true;
  }

  /*  if (status & PRX) RxAvail = true; */
  /* outp(eb+IMR,0x3f);	 */
}

/* increment some stats and set ResetMe flag if ness */

PRIVATE void HandleError(status)
byte status;
{
  if (status & RXE) rxerror(status);
  if (status & TXE) txerror(status);
  if (status & OVW) 
  { 
    Overflow = true;
    ResetMe = true;
    ovw_no ++;
  }
  if (status & CNT) cnt_no++;
}

/* handle recption errors */

PRIVATE void rxerror(status)
byte status;
{
  rxe_no ++;
  
 if (status & CRC) crc_no ++;
 if (status & FAE) fae_no ++;
 if (status & FO)  
 {
   fo_no ++;
   Overrun = true;
   ResetMe = true;
 }   

 if (status & MPA) mpa_no++;

}

/* handle transmission errors */

PRIVATE void txerror(status)
byte status;
{
  txe_no ++;
  
  TxAvail = true;		/* ok to send more pkts */

  if (status & COL) col_no++;
  if (status & ABT) abt_no++;
  if (status & CRS) crs_no++;
  if (status & FU)  
  {
    fu_no ++;
    Underrun = true;
    ResetMe  = true;
  }

  if (status & CDH) cdh_no ++;
  if (status & OWC) owc_no ++;
} 

/* reset the board - do this for Ring buffer overflows
   fifo underruns and overruns (these last two should
   not really happen) but occasionally do on the amiga */

PRIVATE void resetboard()
{
  UBYTE status;
  SHORT res = 0;

#ifdef ETHERINTS
  _disable();				/* stop ints screwing us */
#endif

  outp(eb+IMR,0);	
  outp(eb+CR,0x21);			/* start reset */
  outp(eb+RBCR0,0);
  outp(eb+RBCR1,0);

  /* wait for board to reset */

  do 	
  {
    status = (UBYTE)inp(eb+ISR);
    outp(eb+ISR,status);
  } while ((status & 0x80) == 0);

  outp(eb+TCR,2);			/* loop back mode */
  outp(eb+CR,0x22);			/* start the board */
  
  /* remove pkts from the ring */
  /* the reason we have the while loop is so we can use break */

  while (RxAvail())
  { 

    PktStatus* psp =(PktStatus*)(&((UBYTE*)ethermem)[NextPkt<<8]);
    unless (psp->RStatus & 1) break;
    tap_no ++;

    NextPkt = psp->psNextPkt;
     
    if (NextPkt == StartIndex)
    {
      outp(eb+BNRY,StopIndex);
    }
    else
    {
      outp(eb+BNRY,NextPkt-1);
    }

  }
  
  outp(eb+ISR,0xFF); 			/* clear interrupt status */

  ResetMe = Overflow = Underrun = Overrun = false;

#ifdef ETHERINTS
  _enable();
#endif
  
  outp(eb+TCR,0);
  outp(eb+IMR,0x3f);

}

/* see if we have a packet available to read */
/* have to disable as interrupt handler might change page */

PRIVATE bool RxAvail()
{
  bool res;
 
#ifdef ETHERINTS
  _disable();				
#endif

  outp(eb+CR,0x62);
  res = (NextPkt != (UBYTE)inp(eb+CURR));
  outp(eb+CR,0x22);

#ifdef ETHERINTS  
  _enable();  
#endif

  return res;
}
#endif /* OLD_ETHER */

/* GetRxPkt - gets a packet from the ring buffer 
   must only be called if there is one there 
   check with RxAvail */

PRIVATE SHORT GetRxPkt(buff,maxsize)
UBYTE* buff;
word maxsize;
{ 
#ifdef OLD_ETHER
  PktStatus * ps = (PktStatus*) (&((UBYTE*)ethermem)[NextPkt<<8]);

  UBYTE* from = ((UBYTE*)ps)+4;
  SHORT  len  = 0;

  /* check for duff packet */
  /* shoulkd never happen if RCR is set up correctly */

  unless (ps->RStatus & 1)
  {
        
#ifdef ETHERDEBUG
    ServerDebug("/ether - byte %2x ",ps->RStatus);
    ServerDebug("/ether - byte %2x ",ps->psNextPkt);
    ServerDebug("/ether - byte %2x ",ps->psRBCR0); 
    ServerDebug("/ether - byte %2x ",ps->psRBCR1);
#endif    

    Server_errno = EC_Error +SS_IOProc + EG_Broken + EO_Medium;
    return 0;
  } 

  len = *((SHORT*)(&ps->psRBCR0));		/* length of packet */
 
  if (((word)len) > maxsize) 
  {
    len = (SHORT) maxsize;
  }
  
  if (from + len  <= StopPtr)			/* check for wrap */
  {
    memcpy(buff,from,len);			/* easy case */
  }
  else
  {
    SHORT len1;					/* harder case */
    memcpy(buff,from,len1 = (SHORT) (StopPtr-from));
    memcpy(buff+len1,StartPtr,len-len1);
  }
  
  NextPkt = ps->psNextPkt;			/* on to next */
  
  if (NextPkt == StartIndex)			
  {
    outp(eb+BNRY,StopIndex);			/* special case if wrap */
  } 
  else
  {
    outp(eb+BNRY,NextPkt -1);			/* else easy */
  }
  
  prx_no++;                                     /* gather stats */

#else /* !OLD_ETHER */

  SHORT  len  = 0;
/*
-- crf: clear interrupt enable flag (necessary ?)
*/
  _asm
    cli
  len = pkt_len [pkt_index]  ;

#ifdef ETHER_DEBUG
  notify ("rx: pkt len = %d  index = %d", len, pkt_index) ;
#endif /* ETHER_DEBUG */

  if ((word) len > maxsize) 
    len = (SHORT) maxsize;
  memcpy (buff, ether_pkt_table [pkt_index], len) ;
  pkt_index = ++pkt_index % MAX_PKT_TABLE ;
  pkt_rcvd -- ;

/*
-- crf: restore interrupt enable flag (necessary ?)
*/
  _asm
    sti

#endif /* !OLD_ETHER */  
  Server_errno = 0 ;				/* all ok */
  return len ;					/* and home */
}

#ifdef OLD_ETHER
/****************************************************************
*
* getboardtype - get and initialise board if pos - return type
*
****************************************************************/

PRIVATE int getboardtype()
{
  switch (ethertype) 
  {
    case BT_WESTERN_DIGITAL: 
	 if (westerndigp()) return ethertype; 
         break; 
    case BT_DLINK:
         if (dlinkp()) return ethertype;
         break;
    default:
	 if (westerndigp()) return ethertype; 
         if (dlinkp()) return ethertype;
         break;
  }
  return ethertype = BT_UNKNOWN;
}


/****************************************************************
*
* westerndigp - see if board is western digitals 
*
****************************************************************/

PRIVATE bool westerndigp()
{
  int i;
  UBYTE cs = 0;
  unsigned int etherport = etherbase; 

  /* set up default values for some variable if ness */

  if (etherbase == 0xFF) etherport = 0x280;

  nicbase = etherport + 0x10;


  for ( i = 0; i < 8; i++)
  {
    cs += (etheraddr[i] = (UBYTE) inp(etherport+i+0x08)); 
  }

  /* unless checksum is 0xFF board is not Western Digital */

  unless (cs == 0xFF) 
  {
#ifdef ETHERDEBUG
    ServerDebug("/ether - checksum %2X",cs);	
#endif  
    return false;
  }

  if (etherbase == 0xFF) etherbase = 0x280;
  if (ethermem  == -1)   ethermem = 0xD0000000;
  if (etherlevel == -1) etherlevel = 3;

  /* ok we have a board lets initialise it */

  outp(etherbase,(int)( ((ethermem >> 25) & ~0x80) | 0x40));
  
  TxPktNo    = 0;
  TxPktPtr   = (UBYTE*)ethermem;

#ifdef ETHERDEBUG
  ServerDebug("/ether - I am a Western Digital Board");
#endif
  ethertype = BT_WESTERN_DIGITAL;
  return true;
}

PRIVATE bool dlinkp()
{
  int i;
									   
  UBYTE * memptr;
  UBYTE * memptr1;
  unsigned int port;

  /* set up default values for some variable if ness */
  
  if (ethermem  == -1) 
  {
    memptr = (UBYTE*) 0xD0000000;
  }
  else 
  {
    memptr = (UBYTE*) ethermem;
  }

  memptr += 0x2000;
  memptr1 = memptr + (8*1024);		/* top of magic 8K  */	
  port = (memptr[0]&0xFE)*16;

  /* check that port is a valid value */

  unless ((port >= 0x100) && 
          (port <= 0x3E0) &&
	  ((port % 0x20) == 0)) 
  {
#ifdef ETHERDEBUG
  ServerDebug("/ether - port %2x invalid",port);
#endif
    return false;
  }

  /* lets go and see if the magic memory has the board address in it */

  memptr += 17;

  while (memptr < memptr1)
  {
    unless (((unsigned int)(memptr[0]&0xFE)*16) == port) 
    {
#ifdef ETHERDEBUG
      ServerDebug("/ether - ports differ");
#endif
      return false;
    }
    memptr += 17;  
  }

  /* seems likely that this is the board */

  /* ok we have a board lets initialise it */
  
  etherbase = port;
  if (ethermem  == -1) ethermem = 0xD0000000;
  if (etherlevel == -1) etherlevel = 3;
  nicbase = etherbase;
  
  outp(etherbase+0x1F,0xFF);  		/* enable board memory */
  

  /*  zero the address for now  */

  for ( i = 0; i < 8; i++)
  {
    etheraddr[i] = ethermult[i] = 0;
  }
 
  
  TxPktNo    = 32;
  TxPktPtr   = (UBYTE*)(ethermem+0x2000);

#ifdef ETHERDEBUG
  ServerDebug("/ether - I am a DLINK Board");
#endif  

  ethertype = BT_DLINK;

  return true;
}

PRIVATE void dlinkaddr()
{
 int count;
 	 
 /* ok lets try and find that address */
 
 outp(eb+RSAR0,0);
 outp(eb+RSAR1,0);
 
 outp(eb+RBCR0,6);
 outp(eb+RBCR1,0);
 
 /* now go and start things off */
 
 outp(eb+CR,0x0A);  /* remote read */
 
 /* wait for completion */
 
 for(count = 0; count < 2000; count ++)
 {
   if (inp(eb+ISR) & 0x40) break;  	
 }
 
 unless (count <= 2000) 
 {
   ServerDebug("/ether - Cannot Get Board Address");	
 }
 
 for (count = 0; count < 6; count ++)
 {
   etheraddr[count] = (UBYTE)inp(etherbase+0x10);	
 }
 
  outp(eb,0x62);
  
  for (count = 0; count < 6; count++)
  {
    outp(eb+PAR0+count,etheraddr[count]);
  }
  
  outp(eb,0x22);

}
#endif /* OLD_ETHER */

/****************************************************************
*                                                               *
*                          End Of File                          *
*                                                               *
*       Copyright (C) 1990, Perihelion Software Limited         *
*                       All Rights Reserved                     *
*                                                               *
****************************************************************/
@


1.8
log
@Cleaned up ... 1. Changed REGS to _REGS, SREGS to _SREGS 2. Fixed up
refernces to receiver()
@
text
@d14 1
a14 1
RcsId: $Id: esupport.c,v 1.13 1992/09/06 12:11:54 craig Exp $
d34 6
d219 3
d223 1
d229 3
d233 1
d304 3
d308 1
d343 3
d347 1
d366 3
d370 1
d404 3
d408 1
d435 3
d439 1
d766 3
d770 1
d784 3
d788 1
@


1.7
log
@patches to compile under Microsoft C 7.0
@
text
@d14 1
a14 1
RcsId: $Id: esupport.c,v 1.6 1992/06/19 09:47:31 bart Exp $
d162 1
a162 1
			SHORT (*) (void)) ;
d205 2
a206 2
	union REGS regs;
	struct SREGS sregs ;
d253 1
a253 1
			SHORT (*receiver) (void))
d255 2
a256 2
	union REGS regs ;
	struct SREGS sregs ;
d306 2
a307 2
	union REGS regs ;
	struct SREGS sregs ;
d341 1
a341 1
	union REGS regs ;
d355 2
a356 2
	union REGS regs ;
	struct SREGS sregs ;
d394 2
a395 2
	union REGS regs ;
	struct SREGS sregs ;
d561 1
a561 1
						&receiver) ;
d729 1
a729 1
	union REGS regs ;
d743 1
a743 1
	union REGS regs ;
@


1.6
log
@Major upgrade to V3.91:
 1) C40 support
 2) now runs under Helios and under Windows
@
text
@d14 1
a14 1
RcsId: $Id: esupport.c,v 1.5 1992/06/14 14:49:40 craig Exp $
d213 1
a213 1
	segread (&sregs) ;
d219 1
a219 1
	int86x (int_no, &regs, &regs, &sregs) ;
d258 1
a258 1
	segread (&sregs) ;
d290 1
a290 1
	int86x (int_no, &regs, &regs, &sregs) ;
d312 1
a312 1
	segread (&sregs) ;
d325 1
a325 1
	int86x (int_no, &regs, &regs, &sregs) ;
d344 1
a344 1
	int86 (int_no, &regs, &regs) ;
d358 1
a358 1
	segread (&sregs) ;
d378 1
a378 1
	int86x (int_no, &regs, &regs, &sregs) ;
d400 1
a400 1
	segread (&sregs) ;
d405 1
a405 1
	int86x (int_no, &regs, &regs, &sregs) ;
d732 1
a732 1
	int86 (int_no, &regs, &regs) ;
d746 1
a746 1
	int86 (int_no, &regs, &regs) ;
@


1.5
log
@get_stats() - was testing for interrupt error in the wrong place
@
text
@d14 1
a14 1
RcsId: $Id: esupport.c,v 1.4 1992/05/12 14:52:40 craig Exp craig $
d51 1
d55 2
a56 1
PRIVATE BYTE ether_pkt_table [MAX_PKT_TABLE] [MAXETHERPKT] ;
d58 5
d75 2
a76 1
PUBLIC SHORT pkt_rcvd = 0 ;
d80 2
a81 1
PUBLIC BYTE* pkt_table = ether_pkt_table [0] ;
d85 1
a85 1
PUBLIC SHORT *pkt_len = ether_pkt_len ;
d89 1
a89 1
PUBLIC SHORT pkt_too_long = 0 ;
d91 1
a91 1
PUBLIC SHORT pkt_overflow = 0 ;
d98 1
a98 1
PRIVATE BYTE *Drvr_Err_Code [NUM_ERR_CODES] =
d143 1
d152 1
a152 1
			SHORT, SHORT *, SHORT *, BYTE *,
d161 1
a161 1
PRIVATE SHORT access_type (SHORT, SHORT, SHORT, SHORT, BYTE *, USHORT,
d164 1
a164 1
PRIVATE SHORT get_address (SHORT, SHORT, BYTE *, SHORT) ;
d166 1
a166 1
PRIVATE SHORT send_pkt (SHORT, BYTE *, USHORT) ;
d179 3
a181 2
PRIVATE bool fail (BYTE *, ...) ;
PRIVATE void notify (BYTE *, ...) ;
d188 4
d201 1
a201 1
			BYTE *if_name, 
d208 3
a210 1
	BYTE *name_ptr ;
d227 1
d233 9
d252 1
a252 1
			BYTE *buffer, USHORT buf_len,
d257 2
d260 13
a272 2
	segread (&sregs) ;
	regs.h.dl = (UBYTE) if_number ;
d275 10
a285 2
	sregs.es  = FP_SEG (receiver) ;
	regs.x.di = FP_OFF (receiver) ;
d289 1
d293 4
d304 1
a304 1
			BYTE *buffer, SHORT buf_len)
d308 3
d313 1
d316 5
d324 1
d328 5
d353 1
a353 1
PRIVATE SHORT send_pkt (SHORT int_no, BYTE *buffer, USHORT buf_len)
d359 1
d361 10
d374 1
a374 1
	regs.x.si = FP_OFF (buffer) ;
d377 1
d380 3
d396 3
d404 1
d410 21
d433 1
d435 5
d449 2
d453 1
a453 1
	WORD drvr_vec ;
d455 21
a475 2
	drvr_vec = (WORD) _dos_getvect (int_no) ;
	return (!strncmp ((BYTE *) (drvr_vec + 3) , DRVR_SIG, strlen (DRVR_SIG))) ;
d484 1
a484 1
	bool located = FALSE ;
d486 5
d515 9
d532 1
a532 1
		BYTE iface_name [IFACE_NAME_LEN] ;
d539 1
a539 1
				(BYTE *) &iface_name,
d560 1
a560 1
						(BYTE *) &pkt_type, PKT_TYPE_LEN, 
d579 1
a579 1
	return (TRUE) ;
d588 1
a588 1
PRIVATE bool fail (BYTE *format, ...)
d591 1
a591 1
	BYTE msg [256] ;
d596 1
a596 9
	notify (msg) ;
	if (drvr_err > 0)
	{
		if (drvr_err < NUM_ERR_CODES)
			notify ("Error %d: %s", drvr_err, Drvr_Err_Code [drvr_err]) ;
		else
			notify ("Unknown error code: 0x%x", drvr_err) ;
		drvr_err = 0 ;
	}
d598 1
a598 1
	return (FALSE) ;
d605 1
a605 1
PRIVATE void notify (BYTE *format, ...)
d608 1
a608 1
	BYTE msg [256] ;
d619 31
d679 1
a679 1
				(void) fail ("Failed to release access to packet type") ;
d686 4
d702 1
a702 1
		(void) fail ("Failed to get statistics") ;
d811 2
a812 2
PRIVATE bool SendTxPkt(BYTE*, USHORT) ;
PRIVATE SHORT GetRxPkt (UBYTE*, WORD) ;
d849 1
a849 1
  if (getboardtype() == BT_UNKNOWN) return FALSE; 
d856 1
a856 1
  TxAvail    = TRUE;
d858 4
a861 4
  ResetMe = FALSE;
  Overrun = FALSE;
  Underrun = FALSE;
  Overflow = FALSE;
d907 1
a907 1
  return TRUE;
d936 1
a936 1
BYTE*  buff;
d959 1
a959 1
    return TRUE;		
d964 1
a964 1
    return FALSE;
d972 2
a973 2
    return (fail ("Failed to send packet")) ;
  return (TRUE) ;
d986 1
a986 1
  BYTE mask = inp(0x21);		/* read old mask	 */
d997 1
a997 1
  BYTE mask = inp(0x21);		/* get int mask */
d1012 1
a1012 1
  BYTE status = (BYTE)inp(eb+ISR);    /* get in status */
d1025 1
a1025 1
    TxAvail = TRUE;
d1028 1
a1028 1
  /*  if (status & PRX) RxAvail = TRUE; */
d1035 1
a1035 1
BYTE status;
d1041 2
a1042 2
    Overflow = TRUE;
    ResetMe = TRUE;
d1051 1
a1051 1
BYTE status;
d1060 2
a1061 2
   Overrun = TRUE;
   ResetMe = TRUE;
d1071 1
a1071 1
BYTE status;
d1075 1
a1075 1
  TxAvail = TRUE;		/* ok to send more pkts */
d1083 2
a1084 2
    Underrun = TRUE;
    ResetMe  = TRUE;
d1145 1
a1145 1
  ResetMe = Overflow = Underrun = Overrun = FALSE;
d1185 1
a1185 1
WORD maxsize;
d1212 1
a1212 1
  if (((WORD)len) > maxsize) 
d1255 1
a1255 1
  if ((WORD) len > maxsize) 
d1329 1
a1329 1
    return FALSE;
d1347 1
a1347 1
  return TRUE;
d1382 1
a1382 1
    return FALSE;
d1396 1
a1396 1
      return FALSE;
d1430 1
a1430 1
  return TRUE;
@


1.4
log
@1. Minor changes to formatting of messages displayed
2. No longer displays "Located packet driver at ..."
@
text
@d14 1
a14 1
RcsId: $Id: esupport.c,v 1.3 1992/05/04 19:24:04 craig Exp craig $
d319 1
a324 1
	TEST_ERROR
@


1.3
log
@Added support for Clarkson pkt drivers (compile with /DOLD_ETHER for
original code)
@
text
@d14 1
a14 1
RcsId: $Id: esupport.c,v 1.2 1990/11/01 14:15:01 alan Exp craig $
d365 1
a365 1
			return (fail ("%s in range 0x%x - 0x%x", CANT_LOCATE, MIN_PKT_INT, MAX_PKT_INT)) ;
d375 1
a375 1
/*#ifdef ETHER_DEBUG*/
d377 1
a377 1
/*#endif*/ /* ETHER_DEBUG */
d427 1
a427 2
/*#ifdef ETHER_DEBUG*/
		notify ("Ethernet Address: %02x:%02x:%02x:%02x:%02x:%02x",
a428 1
/*#endif*/ /* ETHER_DEBUG */
d1069 1
a1069 1
-- crf: XXX
d1086 1
a1086 1
-- crf: XXX
@


1.2
log
@fixed bug in westerndigp (initialise etherport to etherbase)
@
text
@d14 1
a14 1
RcsId: $Id: esupport.c,v 1.1 90/10/17 12:18:11 alan Exp Locker: alan $
d20 1
d30 1
d32 555
a600 1

d630 1
d632 2
a633 1
PRIVATE void tidyboard();		
d636 4
d641 1
a666 1
 
d736 1
d740 1
d743 6
d765 2
d792 9
d802 2
a803 1
 
d1003 1
d1013 1
d1066 30
a1095 3
  
  Server_errno = 0;				/* all ok */
  return len;					/* and home */
d1098 1
d1302 1
a1311 1

@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
RcsId: $Id$
d522 1
a522 1
  unsigned int etherport; 
@
