head	1.20;
access;
symbols
	Helios_1_3_1:1.19
	Helios_C40_1_3_Official_Release:1.14
	Helios-C40:1.14
	Alenia_release:1.12
	Helios1_3:1.12
	C40_Field_Test_2:1.12
	C40_Field_Test_R1:1.9
	Helios13_beta:1.9
	Helios1_2_2:1.6
	Helios1_2_2Beta:1.6
	Helios1_2_1:1.2;
locks; strict;


1.20
date	93.12.01.17.34.17;	author bart;	state Exp;
branches;
next	1.19;

1.19
date	93.11.02.16.58.40;	author bart;	state Exp;
branches;
next	1.18;

1.18
date	93.10.26.14.28.23;	author bart;	state Exp;
branches;
next	1.17;

1.17
date	93.10.20.16.55.18;	author bart;	state Exp;
branches;
next	1.16;

1.16
date	93.10.13.17.42.36;	author bart;	state Exp;
branches;
next	1.15;

1.15
date	93.09.29.11.14.02;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	93.03.10.15.33.53;	author bart;	state Exp;
branches;
next	1.13;

1.13
date	93.02.03.11.40.11;	author nick;	state Exp;
branches;
next	1.12;

1.12
date	92.08.10.14.12.15;	author bart;	state Exp;
branches;
next	1.11;

1.11
date	92.07.29.16.13.56;	author bart;	state Exp;
branches;
next	1.10;

1.10
date	92.07.20.14.14.02;	author paul;	state Exp;
branches;
next	1.9;

1.9
date	92.06.19.10.07.53;	author bart;	state Exp;
branches;
next	1.8;

1.8
date	92.05.12.14.44.12;	author craig;	state Exp;
branches;
next	1.7;

1.7
date	92.05.04.19.24.41;	author craig;	state Exp;
branches;
next	1.6;

1.6
date	91.08.15.14.17.31;	author al;	state Exp;
branches;
next	1.5;

1.5
date	91.08.02.12.58.51;	author al;	state Exp;
branches;
next	1.4;

1.4
date	91.07.26.16.41.35;	author al;	state Exp;
branches;
next	1.3;

1.3
date	91.06.04.11.26.23;	author alan;	state Exp;
branches;
next	1.2;

1.2
date	91.04.02.12.18.18;	author alan;	state Exp;
branches;
next	1.1;

1.1
date	90.10.18.11.23.49;	author alan;	state Exp;
branches;
next	;


desc
@local assembler code
@


1.20
log
@The RS232 code has been rewritten in C to allow for better support
of the vy86pid board.
@
text
@;*---------------------------------------------------------------------------*;
;--                        HELIOS PC  I/O SYSTEM                            --;
;--                        =====================                            --;
;--                                                                         --;
;--             Copyright (C) 1987, Perihelion Software Ltd.                --;
;--               All Rights Reserved.                                      --;
;--                                                                         --;
;--                                                                         --;
;--                                                                         --;
;-- MODULE NAME: PCASM.ASM                                                  --;
;--                                                                         --;
;-- AUTHOR : BLV                                                            --;
;-- DATE : 30/5/88                                                          --;
;-----------------------------------------------------------------------------;
;-- RcsId: $Id: pcasm.cpp,v 1.19 1993/11/02 16:58:40 bart Exp $	--;
;-- Copyright (C) 1988, Perihelion Software Ltd.   			    --;
;
; BLV - Please note that if this file is compiled for Windows then it needs
; masm 5.0 or later.

;------------------------------------------------------------------------------
; This file is passed through the C preprocessor, to eliminate unnecessary
; options. For example, the rs232 support in this module is eliminated if
; it is not currently compiled into the I/O Server.
;------------------------------------------------------------------------------
#include "../defines.h"

;==============================================================================
;   Some manifests to keep the world tidy
;==============================================================================
arg1	EQU	 6
arg2	EQU	 8
arg3	EQU	10
arg4	EQU	12
arg5	EQU	14
arg6	EQU	16

;==============================================================================
;    And some macros
;==============================================================================
int_push	MACRO
	push	bp
	push	ds
	push	es
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	ENDM

int_pop		MACRO
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	es
	pop	ds
	pop	bp
	ENDM

pushall	MACRO
	push	bp
	mov	bp,sp
	push	ds
	push	es
	push	si
	push	di
	ENDM

popall	MACRO
	pop	di
	pop	si
	pop	es
	pop	ds
	pop	bp
	ENDM

; DPMI support
RealModeRegs	STRUC
	r_DI		DW	0	; used to return buffer
	r_DI_E		DW	0	; not relevant
	r_ESI		DD	0	; not relevant
	r_EBP		DD	0	; not relevant
	r_RESERVED	DD	0	; reserved, should be zero
	r_EBX		DD	0	; not relevant
	r_EDX		DD	0	; not relevant
	r_CX		DW	0	; contains size
	r_CX_E		DW	0	; not relevant
	r_AX		DW	0	; 0 or 1, as per Clarkson spec
	r_AX_E		DW	0	; not relevant
	r_FLAGS		DW	0	; not relevant
	r_ES		DW	0	; used to return buffer
	r_DS		DW	0	; not relevant
	r_FS		DW	0	; not relevant
	r_GS		DW	0	; not relevant
	r_IP		DW	0	; update to simulate return
	r_CS		DW	0	; update to simulate return
	r_SP		DW	0	; update to simulate return
	r_SS		DW	0	; not relevant
RealModeRegs	ENDS

;==============================================================================
; External functions are declared outside the code segment, as recommended in
; the linker documentation. This avoids fixup overflow errors.
;==============================================================================
#if (mouse_supported && !MSWINDOWS)
EXTRN	_mouse_something:FAR
#endif
#if keyboard_supported
EXTRN	_keyboard_something:FAR
#endif
#if RS232_supported
EXTRN	_RS232_InterruptHandler:FAR
#if (MSWINDOWS)
EXTRN	GlobalDosAlloc:FAR, GlobalDosFree:FAR
#endif
#endif

#if  !(use_own_memory_management)
#define _get_mem	_malloc
#define _free_mem	_free
#endif
EXTRN	_get_mem:FAR, _free_mem:FAR

;==============================================================================
; Static data for the default data segment, all variables should end up here
; eventually to cope with protected mode operation. External variables in the
; default data segment should also be declared here
;==============================================================================

DGROUP  GROUP _DATA
        ASSUME ds:DGROUP
_DATA  SEGMENT WORD PUBLIC 'DATA'

#if (Ether_supported)
EXTRN	_pkt_rcvd 	: WORD	; incremented when packet received
EXTRN	_pkt_len  	: DWORD	; packet length vector
EXTRN	_pkt_too_long  	: WORD	; error flag (will contain pkt length)

#if (!MSWINDOWS)
EXTRN	_pkt_table	: DWORD	; packet buffer vector
#else
EXTRN   _pkt_table_segment : WORD	; segment for packet buffer
#endif

	; ethernet local data
rcvr_index      dw 0            ; index into packet buffer

#endif

		; Space for the coroutine library variables
PUBLIC	_CurrentCo
_CurrentCo	DW	0
		DW	0
RootCo		DW	0
		DW	0
func		DW	0	; to store function addresses during
		DW	0	; coroutine switch

		; The Windows version of the coroutine library is very nasty.
		; There is no legal way of switching stacks, as Windows keeps
		; track of stack base and limit and checks these during
		; all calls. Hence it is necessary to copy the stack into a
		; buffer on main()'s stackframe with every coroutine switch.
		; This is also necessary with Microsoft C 7.0
		;
		; coroutine_buf is set to point at this buffer by main()
PUBLIC	_coroutine_buf
_coroutine_buf		DD	0

		; Similar support for an interrupt stack
PUBLIC	_interrupt_buf
_interrupt_buf		DD	0

		; Space to save current SS:SP when switching to interrupt stack
interrupt_save_ss	DW	0
interrupt_save_sp	DW	0

PUBLIC _version_number		; needed for incompatibility problems,
_version_number	DW	0	; particularly with the rawdisk device

		; These variables are used to exchange error information,
		; they may be set by the DOS critical error handler.
#if floppies_available
PUBLIC _floppy_errno
_floppy_errno		DW	0
#endif
#if Centronics_supported
PUBLIC _Centronics_errno
_Centronics_errno	DW	0
#endif
#if Printer_supported
PUBLIC _Printer_errno
_Printer_errno		DW	0
#endif

		; These variables are used to save old interrupt vectors,
		; as the I/O Server traps and ignores certain interrupts. 
zero_off	DW	0
zero_seg	DW	0
overflow_off	DW	0
overflow_seg	DW	0
prtscrn_off	DW	0
prtscrn_seg	DW	0

#if keyboard_supported
seg_keyint	DW	0	; space to save yet another interrupt vector
off_keyint	DW	0
#endif

#if !MSWINDOWS
PUBLIC _vbios_attr
_vbios_x	DB	0		; for the video bios interface
_vbios_y	DB	0
video_mode	DB	0
_vbios_attr	DB	default_attr
#endif

#if gem_supported
		; junk for GEM, not really needed anymore
PUBLIC _mouse_x, _mouse_y, _button_state ; external variables for GEM
PUBLIC _mouse_changed, _button_changed, _cursor_changed
PUBLIC _syscursor

_syscursor	DD 0
_mouse_x	DW 0
_mouse_y	DW 0
_button_state	DW 0
_mouse_changed	DW 0
_button_changed	DW 0
_cursor_changed	DW 0
#endif

#if Rawdisk_supported
transfer_buffer	DB	0,0,0,0,0,0,0,0,0,0	; 10 byte buffer
#endif

	; Link I/O variables
PUBLIC _link_base, _link_read, _link_write, _link_in_status
PUBLIC _link_out_status
PUBLIC _link_reset, _link_analyse
PUBLIC _control_write
PUBLIC	_dma_request, _int_enable, _dma_channel
PUBLIC _reset_timeout, _analyse_timeout
  
control_mask    	DB 0        	; last value written to control reg.
_link_base		DW	0150H
_link_read		DW	0150H
_link_write		DW	0151H
_link_in_status		DW	0152H 
_link_out_status	DW	0153H
_link_reset		DW	0160H
_link_analyse		DW	0161H
_dma_request		DW	0162H
_int_enable		DW	0163H
_dma_channel		DW	0
_control_write		DW	0104H
_reset_timeout		DW	8000
_analyse_timeout	DW	4000

	; DOS DEV Data Areas
_dos_handle		DW	0	; handle to the link name
_dos_status		DW	0	; last link statistic read
			DW 	0
_dos_dev_word		DW	0	; Dos function command area
			DW	0

; TMS320C40 specific variables
PUBLIC _hunt_timeout, _hunt_hiperf_seg
_hunt_hiperf_seg	DW	0d000H	; default to 0xc0000
_hunt_fifo_size		DW	04000H	; 16k fifo
_hunt_timeout		DW	157H	; bit7 = 1 == timeout on fifo transfer

_tdb_wordsaved		DW	0	; false = word buffer not in use
_tdb_wordbuffer1	DW	0	; used to store blocking 16 bit word
_tdb_wordbuffer2	DW	0	; used to store blocking 2nd 16 bit word
_tdb_bytesaved		DW	0	; false = byte buffer not in use
_tdb_bytebuffer		DB	0	; used to store extra byte read.

_DATA  ENDS

;==============================================================================
; Code segment. To cope with running in protected mode, mainly for Windows,
; all variables that used to be in the code segment are now in the data
; segment.
;==============================================================================

CODE    SEGMENT WORD public 'CODE'
        ASSUME cs:CODE

#if !(MSWINDOWS)        
;==============================================================================
;   int critic_error(void)						    --;
; 									    --;
;   This routine is called when a critical error is called, e.g. when there --
;   is no floppy in the drive.   
;==============================================================================
_critic_error	PROC FAR
	test	ah,80h			; check top bit, disk error
	jne	endcrit			; not a disk error

	mov	ax,0002h
	cmp	di,00h			; write protected
	je	setcrit
	mov	al,01h			; default error

setcrit:	
	push	dx
	push	ds
	mov	dx,DGROUP
	mov	ds,dx
	mov	_floppy_errno,ax
	pop	ds
	pop	dx

endcrit:
	mov	al,3		; fail the system call

	iret

_critic_error	ENDP
#endif

;==============================================================================
;   void dummy_interrupt(void)
;
;   This routine is installed as the interrupt handler for certain exceptions,
;   divide-by-0, overflow, and print-screen
;==============================================================================
_dummy_interrupt	PROC	FAR
	iret
_dummy_interrupt	ENDP

_divzero	PROC	FAR
	sti
	int_push

	mov	dx,seg warn
	mov	ds,dx
	mov	dx,offset warn
	mov	ah,9
	int	21H

	int_pop
	iret
_divzero	ENDP

warn	db	'*** Internal error : Divide by zero detected.',0dh, 0ah, '$'

;=============================================================================;
; void set_interrupts(void)
;
; Set some of the interrupts:
;     1) the critical error interrupt which normally puts Abort, Retry, Cancel
;	 on the screen. Ineffective under Windows.
;     2) the divide-by-zero and overflow internal interrupts, to stop runtime
;	 unwanted exits from the server
;     3) the print-screen interrupt, which could be very unpleasant.
;        Also ineffective under Windows.
;
; void restore_interrupts(void)
;
; undo the damage done by set_interrupts
;=============================================================================;
PUBLIC _set_interrupts, _restore_interrupts
_set_interrupts PROC FAR
	pushall

	push	ds		; save the default data segment

	mov	ah,030H		; obtain the MSdos version number
	mov	al,0H
	int	21H
	xor	ah,ah
	pop	ds
	push	ds
	mov	_version_number,ax

#if !(MSWINDOWS)
	mov	ah,025h		; function 25 - set interrupt vector
	mov	al,024h		; interrupt vector for critical error
	mov	dx,seg _critic_error	; this will be restored by MSdos
	mov	ds,dx			; so I do not need to save the old
	mov	dx,offset _critic_error	; vector
	int	21h

	pop	ds
	push	ds
	mov	ah,035h		; save the old interrupt vector for print
	mov	al,005h		; screen
	int	21h
	pop	ds
	push	ds
	mov	prtscrn_off,bx
	mov	prtscrn_seg,es

	mov	ah,025h
	mov	al,005h		; interrupt vector for print screen
	mov	dx,seg	_dummy_interrupt
	mov	ds,dx
	mov	dx,offset _dummy_interrupt
	int	21h
#endif

	pop	ds
	push	ds
	mov	ah,035h		; save the old interrupt vector for divide by
	mov	al,000h		; zero
	int	21h
	pop	ds
	push	ds
	mov	zero_off,bx
	mov	zero_seg,es

	mov	ah,025h		; install my own interrupt vector
	mov	al,000h		
 	mov	dx,seg	_divzero
	mov	ds,dx
	mov	dx,offset _divzero
	int	21h

	pop	ds
	push	ds
	mov	ah,035h		; save the old interrupt vector for overflow
	mov	al,004h
	int	21h
	pop	ds
	push	ds
	mov	overflow_off,bx
	mov	overflow_seg,es

	mov	ah,025h
	mov	al,004h		; interrupt vector for overflow
	mov	dx,seg	_dummy_interrupt
	mov	ds,dx
	mov	dx,offset _dummy_interrupt
	int	21h

	pop	ds

	popall
	ret

_set_interrupts ENDP

_restore_interrupts	PROC	FAR
	pushall

	push	ds		; save default data segment
	mov	ax,zero_seg
	mov	dx,zero_off
	mov	ds,ax
	mov	ah,025H
	mov	al,000H
	int	21h

	pop	ds
	push	ds
	mov	ax,overflow_seg
	mov	dx,overflow_off
	mov	ds,ax
	mov	ah,025H
	mov	al,004H
	int	21h

#if !(MSWINDOWS)
	pop	ds
	push	ds
	mov	ax,prtscrn_seg
	mov	dx,prtscrn_off
	mov	ds,ax
	mov	ah,025H
	mov	al,005H
	int	21h
#endif

	pop	ds
	popall
	ret
_restore_interrupts	ENDP

;==============================================================================
;   int keyboard_rtn(void)
; 
;   perform an int 21 with function 06 (direct console I/O		    --;
;   returns 0 if no key waiting, otherwise the key. for the extended codes  --;
;   I read both keys and put non-zero in top byte			    --;
; 
;==============================================================================

PUBLIC _keyboard_rtn

_keyboard_rtn PROC FAR
	pushall

	mov	ah,6		; the function number
	mov	dl,0ffh		; parameter for read
	int	21h		; DOS call
	jz	nokey

	mov	ah,0		; clear top byte
	test	al,-1		; check for byte 0 (extended key)
	jne	endx
	mov	ah,6		; get another key
	mov	dl,0ffh
	int	21h
	mov	ah,080h
	jmp	short endx
nokey:
	mov	ax,0
endx:
	popall
	ret

_keyboard_rtn	ENDP

;------------------------------------------------------------------------------
; Interface to the mouse device via int 33
;------------------------------------------------------------------------------

#if (mouse_supported && !MSWINDOWS)
mouse_trap	EQU	33H

PUBLIC _reset_mouse, _enable_mouse, _disable_mouse, _set_mouse_resolution

_reset_mouse	PROC	FAR
	pushall

	mov	ah,35h		; check that the interrupt routine is not NULL
	mov	al,mouse_trap
	int	21h
	mov	ax,es
	or	ax,bx
	je	resetm_end

	mov	ax,0
	int	mouse_trap	; this leaves 0 in ax if not installed
	
resetm_end:
	popall
	ret
_reset_mouse	ENDP

_enable_mouse	PROC	FAR
	pushall

	mov	ax,19
	mov	dx,1000h
	int	mouse_trap

	mov	ax,12		; enable mouse_event as an event_handler
	mov	cx,07fh
	mov	dx,seg mouse_event
	mov	es,dx
	mov	dx,offset mouse_event
	int	mouse_trap
	
	popall
	ret
_enable_mouse	ENDP

_disable_mouse	PROC	FAR
	pushall

	mov	ax,12		; disable all events
	mov	cx,0
	int	mouse_trap

	popall
	ret
_disable_mouse	ENDP

_set_mouse_resolution	PROC	FAR
	pushall

	mov	ax,0fh			; fn for set mouse resolution
	mov	cx,arg1[bp]	; x resolution
	mov	dx,cx		 ; y resolution = 2 * x
;	add	dx,cx
	int mouse_trap

	popall
	ret
_set_mouse_resolution	ENDP
	
mouse_event	PROC	FAR
	int_push

	push	bx			; buttons
        mov 	ax,11		
	int	mouse_trap		
        push    dx			; y
        push    cx			; x
	mov	ax,DGROUP
	mov	ds,ax
	call	_mouse_something
	add	sp,6

	int_pop
	ret
mouse_event	ENDP

#endif

;------------------------------------------------------------------------------
; Interface to the keyboard interrupt routine
;------------------------------------------------------------------------------

#if keyboard_supported
PUBLIC _enable_keyboard, _disable_keyboard

_enable_keyboard	PROC	FAR
	pushall

	mov	ax,3509H	; save the old keyboard interrupt vector
	int	21h
	mov	seg_keyint,es
	mov	off_keyint,bx

	mov	ax,seg keyboard_int
	mov	dx,offset keyboard_int
	mov	ds,ax
	mov	ax,2509h	; and install my own
	int	21h

	popall
	ret
_enable_keyboard	ENDP

_disable_keyboard	PROC	FAR
	pushall

	mov	dx,off_keyint
	mov	ax,seg_keyint	; restore the old interrupt vector
	mov	ds,ax
	mov	ax,2509h
	int	21h
	
	popall
	ret
_disable_keyboard	ENDP

eoi	EQU	20h
pictrl	EQU	20h
picmsk	EQU	21h
kb_data	EQU	60h
kb_ctl	EQU	61h

keyboard_int		PROC	FAR
	int_push

	mov	dx,DGROUP		; restore the data segment
	mov	ds,dx

	xor ah,ah			; get the scan code
	in	al,kb_data
	push	ax			; put code on stack for C routine

	mov	al,eoi
	out	pictrl,al

	call	FAR PTR _keyboard_something	; process and buffer the key
	pop	ax

	int_pop
	iret
keyboard_int		ENDP
#endif

;------------------------------------------------------------------------------
; Interface to the BIOS video routines
;------------------------------------------------------------------------------

#if !MSWINDOWS
video_trap	EQU	10H
set_video	EQU	 0 
set_cursortype	EQU	 1
move_cursor	EQU      2
read_cursor	EQU	 3
read_pen	EQU	 4
select_page	EQU	 5
scroll_up	EQU	 6
scroll_down	EQU	 7
read_char	EQU	 8
write_charattr	EQU	 9
write_char	EQU	10
set_palette	EQU	11
write_pixel	EQU	12
read_pixel	EQU	13
write_text	EQU	14
get_mode	EQU	15
set_palreg	EQU	16
write_string	EQU	19
default_video	EQU	2	; 80*25 black and white text
default_attr	EQU	7	; normal plain video
default_page	EQU	0

PUBLIC _vbios_init, _vbios_tidy
PUBLIC _vbios_cls, _vbios_movecursor, _vbios_outputch
PUBLIC _vbios_scroll, _vbios_bell


; void vbios_init(void)
; This is currently a no-op
_vbios_init	PROC	FAR
	ret
_vbios_init	ENDP

; void vbios_tidy(void)
; This is currently a no-op
_vbios_tidy	PROC	FAR
	ret
_vbios_tidy	ENDP

; void vbios_cls(void)
; _vbios_cls clears the screen using Initialise_window, and moves the cursor
; to the top-left corner
_vbios_cls	PROC	FAR
	pushall
	mov	ah,scroll_up
	mov	al,0
	mov	bh,_vbios_attr
	mov	cx,0	    	; top left
	mov	dx,184FH	; bottom right
	int	video_trap
	mov	ah,move_cursor
	mov	bh,default_page
	mov	dh,0
	mov	dl,0
	mov	_vbios_x,dl
	mov	_vbios_y,dh
	int	video_trap
	popall
	ret	
_vbios_cls	ENDP

; void vbios_movecursor(int y, int x)
_vbios_movecursor	PROC	FAR
	pushall
	mov	ah,move_cursor
	mov	bh,default_page
	mov	dh,arg1[bp]
	mov	dl,arg2[bp]
	mov	_vbios_x,dl
	mov	_vbios_y,dh
	int	video_trap
	popall
	ret
	
_vbios_movecursor	ENDP

; void vbios_outputch(int x)
; This call outputs a single character at the current position with the
; current attributes, without moving the cursor. This means lots of calls
; to vbios_movecursor, at least until I optimise it.
_vbios_outputch	PROC	FAR
	pushall
	mov	ax,arg1[bp]
	mov	ah,write_charattr
	mov	bh,default_page
	mov	bl,_vbios_attr
	mov	cx,1
	int	video_trap
	mov	dl,_vbios_x
	cmp	dl,79
	je	output_end
	add	dl,1
	mov	_vbios_x, dl
	mov	dh,_vbios_y
	mov	ah,move_cursor
	mov	bh,default_page
	int	video_trap

output_end:
	popall
	ret
_vbios_outputch	ENDP

; void vbios_scroll(void)
; scroll up one line
_vbios_scroll	PROC	FAR
	pushall
	mov	ah,scroll_up
	mov	al,1		; scroll up a single line
	mov	bh,_vbios_attr
	mov	cx,0	    	; top left
	mov	dx,184FH	; bottom right
	int	video_trap
	popall
	ret
_vbios_scroll	ENDP

; void vbios_bell(void)	
; Ring ring !!!
_vbios_bell	PROC	FAR
	pushall
	mov	ah,write_text
	mov	bh,default_page
	mov	al,7		; bell character
	int	video_trap
	popall
	ret
_vbios_bell	ENDP

#endif /* MSWINDOWS */

;------------------------------------------------------------------------------
;-- GEM VDI vectors
;------------------------------------------------------------------------------

#if gem_supported
PUBLIC _mousemove_vector, _mousebutton_vector, _cursorchange_vector

	; N.B. These are interrupt routines 
_mousemove_vector PROC FAR
	push	dx
	push	ds
	mov	dx,DGROUP
	mov	ds,dx
	mov _mouse_x,bx
	mov _mouse_y,cx
	mov _mouse_changed, 1
	pop	ds
	pop	dx
	ret
_mousemove_vector ENDP

_mousebutton_vector PROC FAR
	push	dx
	push	ds
	mov	dx,DGROUP
	mov	ds,dx
	mov	_button_state,ax
	mov	_button_changed,1
	pop	ds
	pop	dx
	ret
_mousebutton_vector ENDP

_cursorchange_vector PROC FAR
	int_push
	mov	dx,DGROUP
	mov	ds,dx
	mov	_mouse_x,bx
	mov	_mouse_y,cx
	mov	_cursor_changed,1
	xor si,si
	call _syscursor[si]
	int_pop
	ret
_cursorchange_vector ENDP

#endif

;-----------------------------------------------------------------------------;
;-- WORD call_a_trap(MCB *mcb)                                              --;
;--                                                                         --;
;-- Activate trap 0x60, with the mcb in dx. It should                    --;
;-- return a reply in dx:ax in less than two seconds, or else...            --;
;--                                                                         --;
;-----------------------------------------------------------------------------;

#if interaction_supported
PUBLIC _call_a_trap

_call_a_trap	PROC	FAR
	pushall
	mov	dx,arg2[bp]		; extract the mcb
	mov	ds,dx
	mov	dx,arg1[bp]
        int	60H
	popall
	ret
_call_a_trap	ENDP
#endif

;-----------------------------------------------------------------------------;
;--                                                                         --;
;-- RS232 support                                                           --;
;--                                                                         --;
;-----------------------------------------------------------------------------;

#if RS232_supported 

PUBLIC _RS232_interrupt

#if (MSWINDOWS && 1)

_RS232_interrupt	PROC FAR
; ==============================================================================
; -- DPMI real mode callback
; -- Under Windows the interrupt routine is invoked via DPMI callbacks and
; -- must perform a DPMI return.
; -- ENTRY:
; --	DS:SI = real mode SS:SP
; --	ES:DI = real mode call structure
; -- EXIT:
; --	ES:DI = real mode call structure
; -- refer DPMI spec. V1.0 pp. 34-38
; ==============================================================================

; The callback function is passed a real mode register data structure.
;	cs:ip	must be filled in with return address on stack
	
	; Install the return value in the RealModeRegs structure
	; See DPMI spec., example on page 38
	cld
	lodsw
	mov	es:[di.r_IP], ax
	lodsw
	mov	es:[di.r_CS], ax
	add	es:[di.r_SP], 6
	
	; Preserve es:di across the C call
	push	es
	push	di

	; Switch to default data segment to access I/O Server's statics
	mov	ax, DGROUP
	mov	ds, ax

	; Store SS:SP prior to switching to interrupt stack
	mov	ds:interrupt_save_sp, sp
	mov	ds:interrupt_save_ss, ss

	; Switch to the interrupt stack
	les	di,ds:_interrupt_buf
	mov	sp,di
	mov	di,es
	mov	ss,di

	; We are now in a standard C world, with SS == DS == default data segment
	; The actual interrupt can now be handled entirely in C	
	call	FAR PTR _RS232_InterruptHandler

	; Restore the stack, and return back to DPMI
	mov	sp,ds:interrupt_save_sp
	mov	ss,ds:interrupt_save_ss
	
	pop	di
	pop	es
	iret
_RS232_interrupt	ENDP

#else

; Under DOS the interrupt routine is a real interrupt handler and
; must perform an interrupt return.
_RS232_interrupt	PROC FAR
	int_push
	cld

	; Switch to default data segment to access I/O Server's statics
	mov	ax, DGROUP
	mov	ds, ax

	; Store SS:SP prior to switching to interrupt stack
	mov	ds:interrupt_save_sp, sp
	mov	ds:interrupt_save_ss, ss

	; Switch to the interrupt stack
	les	di,ds:_interrupt_buf
	mov	sp,di
	mov	di,es
	mov	ss,di

	; We are now in a standard C world, with SS == DS == default data segment
	; The actual interrupt can now be handled entirely in C	
	call	FAR PTR _RS232_InterruptHandler

	; Restore the stack, and return from interrupt
	mov	sp,ds:interrupt_save_sp
	mov	ss,ds:interrupt_save_ss
	
	int_pop
	sti	; This appears to be needed
	iret
_RS232_interrupt	ENDP
#endif

#endif

;==============================================================================
; 
;  Raw disk support
;
;==============================================================================

#if Rawdisk_supported
PUBLIC _disk_read, _disk_write

read_int	EQU	025h
write_int	EQU	026h

;==============================================================================
; _disk_read(int drive, int no_sects, WORD first_sec, byte *buf)
;==============================================================================

_disk_read	PROC	FAR
	pushall

	mov	ax,arg1[bp]	; drive id, 0 = A, 1 = B etc.
	cmp	ax,2
	jne	rdrive_ok
	mov	ax,0310H
	jmp	short readdone

rdrive_ok:	
	mov	bx,_version_number
	cmp	bx,4
	jge	msdos4_read

	mov	cx,arg2[bp]	; no_sects to read
	mov	dx,arg3[bp]	; starting sector	; low 2 bytes
	mov	bx,arg6[bp]	; segment of buffer
	mov	ds,bx
	mov	bx,arg5[bp]	; offset of buffer
	int	read_int	; do the read

	jc	read_error	; carry flag set if error, with code in ax
	xor	ax,ax		; no error so return 0
read_error:
	add	sp,2		; as per instructions
	jmp	short readdone

msdos4_read:
	mov	cx,-1
	mov	bx,DGROUP
	mov	ds,bx
	mov	si,offset dgroup:transfer_buffer
	mov	bx,arg3[bp]	; first sector, low 2 bytes
	mov	[si],bx
	mov	bx,arg4[bp]	; first sector, high bytes
	mov	[si+2],bx
	mov	bx,arg2[bp]	; number of sectors
	mov	[si+4],bx
	mov	bx,arg5[bp]	; offset of buffer
	mov	[si+6],bx
	mov	bx,arg6[bp]	; segment of buffer
	mov	[si+8],bx
	mov	bx,si		; bx now contains structure
	int	read_int	; do the read

	jc	read_error2	; carry flag set if error, with code in ax
	xor	ax,ax		; no error so return 0
read_error2:
	add	sp,2		; as per instructions

readdone:
	popall
	ret
_disk_read	ENDP

;==============================================================================
; _disk_write(int drive, int no_sects, WORD first_sec, byte *buf)
;==============================================================================

_disk_write	PROC	FAR
	pushall

	mov	ax,arg1[bp]	; drive id
	cmp	ax,2
	jne	wdrive_ok
	mov	ax,0310H
	jmp	short writedone

wdrive_ok:
	mov	bx,_version_number
	cmp	bx,4
	jge	msdos4_write

	mov	cx,arg2[bp]	; no_sects
	mov	dx,arg3[bp]	; first_sector
	mov	bx,arg6[bp]	; segment of buffer
	mov	ds,bx
	mov	bx,arg5[bp]	; offset of buffer

	cmp	al,2		; check that we are not writing to disk C
	jne	write_safe
	mov	ax,0300h	; write protect error
	jmp	short write_error
write_safe:

	int	write_int

	jc	write_error	; carry set if error, with error code in ax
	xor	ax,ax
write_error:
	add	sp,2
	jmp	short writedone

msdos4_write:
	mov	cx,-1
	mov	bx,DGROUP
	mov	ds,bx
	mov	si,offset dgroup:transfer_buffer
	mov	bx,arg3[bp]	; first sector, low 2 bytes
	mov	[si],bx
	mov	bx,arg4[bp]	; first sector, high bytes
	mov	[si+2],bx
	mov	bx,arg2[bp]	; number of sectors
	mov	[si+4],bx
	mov	bx,arg5[bp]	; offset of buffer
	mov	[si+6],bx
	mov	bx,arg6[bp]	; segment of buffer
	mov	[si+8],bx
	mov	bx,si		; bx now contains structure
	int	write_int	; do the read

	jc	write_error2	; carry flag set if error, with code in ax
	xor	ax,ax		; no error so return 0
write_error2:
	add	sp,2		; as per instructions

writedone:
	popall
	ret
_disk_write	ENDP

#endif
 
;-----------------------------------------------------------------------------
; The coroutine library. This comes in two flavours. The standard version for
; DOS is a fairly straight-forward implementation. Unfortunately it does not
; work for Windows because Windows does not support multiple stacks. In
; particular Windows appears to keep track of the stack base and limit
; for every program running under it, and if a program calls into Windows
; these are checked. Coroutines would result in unrecoverable application
; errors.
;
; With Microsoft C 7.0 some of the C library routines appear to have built-in
; stack checking. Hence the same problems occur.
;
; To get around this I have implemented an alternative version of the
; coroutine library. This assumes that there is a suitably large buffer
; on the stackframe of main(). Whenever a child coroutine is activated
; its stack is copied from the usual place into this buffer. When the
; coroutine suspends the buffer is copied back onto the stack. Paul Beskeen
; is responsible for thinking of this hack.
;
; BLV, 12.5.92
;-----------------------------------------------------------------------------
 
PUBLIC  _InitCo, _CreateCo, _CallCo, _WaitCo, _DeleteCo
  
; Co-routine data structure
; longword *co_sp       stack pointer for this routine
; longword *co_base	base address of the coroutine
; longword *co_parent   parent coroutine
; longword *co_func     initial entry point to coroutine
; int      co_size      size of stack allocated to routine
; int      magic        magic number to check for overflow
;
; All longwords are saved as offset:segment
; It is assumed that all pointers are long pointers.
 
co_sp           EQU 0
co_base		EQU 4
co_parent       EQU 8
co_func         EQU 12
co_size         EQU 16
co_magic        EQU 18
co_SIZEOF       EQU 20
magic_value     EQU 07654h 
NULL            EQU 0
 

;==============================================================================
; coroutine = CreateCo(function, size)
;  long *function
;  long size
;
; Creates and adds a co-routine with the required stacksize and start function.
;  Size is given in bytes.
;==============================================================================
_CreateCo PROC FAR
        push    bp                      ; save bp
        mov     bp,sp                   ; stack frame ptr
        push    ds                      ; save segment registers
	push	di
	push	si
 
        mov     cx,arg3[bp]                ; lower 16 bits of size
 
        add     cx,co_SIZEOF            ; add length of coroutine structure
        push    cx
        call    _get_mem		; get required amount of stack
	pop	cx
	sub	cx,co_SIZEOF		; restore stack size

        test    ax,-1                   ; NULL ptr ?
        jne     gotmem
        test    dx,-1 
        jne     gotmem

	pop	si
	pop	di
	pop	ds
	pop	bp 
        ret

gotmem:
        mov     bx,ds                   ; avoid corrupting ds
 
        mov     es,dx
        mov     di,ax
        lds     si,DWORD PTR _CurrentCo
					; es:di = new coroutine (also dx:ax)
					; si = current coroutine (parent)
 
        mov     es:co_size[di],cx       ; size of coroutine stack

	add	ax,co_SIZEOF		; base of coroutine stack
	mov	es:co_base[di],ax
	mov	es:co_base[di+2],dx

        mov     es:co_parent[di],si
        mov     es:co_parent[di+2],ds   ; parent = current coroutine

	mov	ax,magic_value
	mov	es:co_magic[di],ax

        mov     ax,arg1[bp]
        mov     dx,arg2[bp]
        mov     es:co_func[di],ax       ;
        mov     es:co_func[di+2],dx     ; coroutine entry point
 
		; At this point it is necessary to make the new coroutine
		; current, setting up the stack frame appropriately.
		; es:di = new coroutine, si = old coroutine,
		; cx = stacksize, bx = default ds
	call	FAR PTR save_stack

        mov     co_sp[si],sp		; save the stack pointer for the old
        mov     co_sp[si+2],ss		; coroutine
 
		; Update currentCo
        mov     ds,bx			; restore ds
        mov     _CurrentCo,di
        mov     _CurrentCo+2,es	; make new coroutine current

		; The coroutine base address is determined by _coroutine_buf
	les	di, DWORD PTR _coroutine_buf
	add	cx,di			; go to top of stack
	push	es			; use the stack to switch the stack.
	cli
	pop	ss
	mov	sp,cx
	sti

		; This call to WaitCo will cause the parent coroutine to be
		; reactivated, with es:di as the result. This should be the
		; coroutine base address, still held in CurrentCo
	les	di, DWORD PTR _CurrentCo
        push    es
        push    di
 
cocoenter:  call    FAR PTR _WaitCo         ; Waitco back to parent
        add     sp,4
 
		; At this point the parent coroutine has been reactivated
		; and has done a StartCo on the newly-created coroutine.
		; dx:ax, the result of the WaitCo(), correspond to the
		; argument of the StartCo. This code now uses the
		; function passed to CreateCo, held in the coroutine
		; structure, and calls it. The coroutine is now up and running
        push    dx                      ; Parameter for coroutine entry
        push    ax			; == result of WaitCo
        les     di,DWORD PTR _CurrentCo

        mov     dx,es:co_func[di]       ; Entry point offset
	mov	func,dx
	mov	dx,es:co_func+2[di]	; Entry point segment
	mov	func+2,dx		; into CS memory
	lea	bx,func
	call    DWORD PTR [bx]
        jmp     short cocoenter                   ; loop forever
_CreateCo ENDP
 
	; Routine to copy the stack from coroutine_buf to the save
	; space associated with the coroutine. If the current coroutine
	; is the root coroutine then this is a no-op
	; N.B. no assumptions should be made about register values, although
	; the current stack is usable
save_stack PROC FAR
	push	ds
	push	es
	push	di
	push	si
	push	cx
	push	dx
	push	ax

	mov	dx, DGROUP	; restore default data segment
	mov	ds,dx
	les	di,DWORD PTR RootCo
	lds	si,DWORD PTR _CurrentCo

	mov	ax,ds
	mov	cx,es
	cmp	ax,cx		; if (CurrentCo eq RootCo) skip the save
	jne	must_save
	cmp	di,si
	je	skip_save
must_save:

	mov	cx,co_size[si]		; get size from CurrentCo
	les	di,co_base[si]		; and stack base into es:di
	mov	ds,dx			; restore data segment again
	lds	si,_coroutine_buf	; si is now the coroutine buffer

	add	di,cx			; es:di := top of stack buffer
	add	si,cx			; ds:si := top of current stack
	mov	cx,si			; cx	:= offset within current stack
	sub	cx,sp			; cx    := amount of stack used
	sub	di,cx			; es:di := target stack pointer
	sub	si,cx			; ds:si := current stack pointer

	rep	movsb			; this does the copy

skip_save:
	pop	ax
	pop	dx
	pop	cx
	pop	si
	pop	di
	pop	es
	pop	ds
	ret
save_stack ENDP

;==============================================================================
; Result = CallCo( coroutine,arg)
; int *coroutine
; long arg
;
; Starts up a coroutine that was just created or did a WaitCo to return an arg.
;==============================================================================
_CallCo PROC FAR
        push    bp
        mov     bp,sp
        push    ds
	push	di
	push	si
 
        les     di,arg1[bp]			; new coroutine
        lds     si,DWORD PTR _CurrentCo	; current coroutine
                                       
        mov     es:co_parent[di],si
        mov     es:co_parent[di+2],ds   ; adopt the coroutine

        mov     ax,arg3[bp]               ; argument
        mov     dx,arg4[bp]
 
		; At this point we assume
		; si = parent coroutine
		; es:di = daughter coroutine
		; dx:ax = argument
coenter:
	push	ax			; check for coroutine stack overflow
	mov	ax,co_magic[si]	; on current and new coroutine
	cmp	ax,magic_value
	jne	coroutines_crashed
	mov	ax,es:co_magic[di]
	cmp	ax,magic_value
	jne	coroutines_crashed
	pop	ax

	call	FAR PTR save_stack

        mov     co_sp[si],sp		; now save the stack pointer
        mov     co_sp[si+2],ss

	cli				; critical section
        mov     sp,es:co_sp[di]         ; switch to new daughter stack
        mov     ss,es:co_sp[di+2]
	sti
		; N.B. we are now running in the WaitCo() stackframe,
		; not in CallCo() !!!!
		;
		; For Windows coroutines things are somewhat confused
		; now. The stack has been switched, probably into the
		; coroutine buffer. Interrupts can be handled safely.
		; However, the contents of the stack has not yet been
		; copied into the buffer. I do not believe this to be
		; a problem until I re-enter the user code.

	push	dx			; restore default data segment
	mov	dx,DGROUP
	mov	ds,dx
	pop	dx

        mov     _CurrentCo,di	; update current coroutine
        mov     _CurrentCo+2,es
 
		; unless (CurrentCo eq RootCo), it is now necessary to
		; copy the whole stack into coroutine_buf.
		; N.B. dx:ax must be preserved without using the stack, as
		; the whole stack is about to be overwritten
	les	di, DWORD PTR RootCo
	lds	si, DWORD PTR _CurrentCo
	mov	bx, ds
	mov	cx, es
	cmp	bx,cx
	jne	must_restore
	cmp	di,si
	je	skip_restore

must_restore:
	mov	cx,co_size[si]	; get size from CurrentCo
	les	di,co_base[si]	; and stack bas into es:di
	mov	bx,DGROUP		; restore data segment again
	mov	ds,bx
	lds	si,_coroutine_buf	; si is now the coroutine buffer

	push	es			; source and dest are the wrong
	push	ds			; way around, whoops
	pop	es
	pop	ds
	push	si
	push	di
	pop	si
	pop	di

	add	di,cx			; es:di := top of current stack
	add	si,cx			; ds:si := top of stack buffer
	mov	cx,di			; cx	:= offset of current stack
	sub	cx,sp			; cx    := amount of stack used
	sub	di,cx			; es:di := current stack pointer
	sub	si,cx			; ds:si := stack buffer

	rep	movsb			; this does the copy
skip_restore:

	pop	si
	pop	di
        pop     ds
        pop     bp			; restore registers of daughter
	ret				; enter daughter
_CallCo ENDP
 
 
;==============================================================================
; coroutines_crashed
;
; a magic number is maintained in the coroutine structure, which will get
; zapped if the coroutine stack overflows. If that happens the coroutine
; library will jump here where I try to exit.
;==============================================================================

coroutines_crashed:
	mov	dx,seg cowarn
	mov	ds,dx
	mov	dx,offset cowarn
	mov	ah,9
	int	21H
	mov	dx,seg cowarn2
	mov	ds,dx
	mov	dx,offset cowarn2
	mov	ah,9
	int	21h

	mov	ah,04ch
	mov	al,100
	int	21h

cowarn	db	'*** Internal error : coroutine stack overflow detected.',0dh, 0ah, '$'
cowarn2 db	'***                : attempting to exit safely.',0dh, 0ah, '$'

;==============================================================================
; Arg = WaitCo( arg)
; long arg;
;
; Returns control back to the parent with required argument/return code in ax.
; Arg will eventually be returned when the coroutine doing the WaitCo is called
; again with CallCo_(coroutine,ARG)
;==============================================================================
_WaitCo PROC FAR
        push    bp
        mov     bp,sp
        push    ds
	push	di
	push	si
 
	lds     si,DWORD PTR _CurrentCo ; si = current coroutine
        les     di,co_parent[si]        ; es:di = parent coroutine
 
        mov     ax,arg1[bp]             ;
        mov     dx,arg2[bp]             ; ax/bx = argument
 
        jmp     coenter
_WaitCo ENDP

;==============================================================================
; success = DeleteCo_( coroutine )
; int *coroutine
;
; Deletes the stack area being used by a coroutine that is no longer needed.
;==============================================================================
_DeleteCo PROC FAR
	pushall
 
        mov     bx,arg1[bp]
        mov     cx,arg2[bp]		; cx:bx is now the coroutine

        test    bx,-1                   ; coroutine passed = NULL ptr ?
        jne     valptr
        test    cx,-1                   ; coroutine passed = NULL ptr ?
        je      deletefail              ; YES -> failed  (invalid arg)
valptr:
	mov	es,cx
	mov	di,bx
	mov	ax,es:co_magic[di]
	cmp	ax,magic_value
	je	deleteok
	jmp	coroutines_crashed

deleteok:
	xor	ax,ax
	mov	es:co_magic[di],ax	; prevent coroutines from being deleted twice

        push    cx
        push    bx                      ; coroutine to delete
        call    _free_mem
        add     sp,4
 
deletefail:
	popall
        ret
 
_DeleteCo ENDP
 
 
;=============================================================================
; Success = InitCo_()
;
; Initialises a root co-routine that never goes away. It corresponds directly
; to the main level of the program and is really just a list header for all
; the other co-routines that get started.
;=============================================================================
_InitCo PROC FAR
        push    es
	push	di

        mov     cx,co_SIZEOF
        push    cx
        call    _get_mem		; get required amount of stack
        add     sp,2
        test    ax,-1			; NULL ptr ?
        jne     gotok
        test    dx,-1			; NULL ptr ?
        je      initfail		; YES -> failed
 
gotok:
        mov     _CurrentCo,ax
        mov     _CurrentCo+2,dx	; current coroutine
	mov	RootCo,ax
	mov	RootCo+2,dx
 
	les	di,DWORD PTR _CurrentCo	; es:di = current coroutine
                                        
        mov     es:co_parent[di],ax
        mov     es:co_parent+2[di],dx      ; I'm my own parent
	mov	ax,magic_value
	mov	es:co_magic[di],ax
 					; stackbase is not required
					; stack pointer etc. will be set up
					; when switching
        mov     ax,-1
        mov     dx,-1                   ; return success

initfail:
 	pop	di
        pop     es
        ret
 
_InitCo ENDP
 

;*---------------------------------------------------------------------------*;
;--                                                                         --;
;-- MODULE NAME: link.asm                                                   --;
;--                                                                         --;
;-- AUTHOR : B. Veer (based on original code by C. Grimsdale)		    --;
;-- DATE : 10/4/88                                                          --;
;-- UPDATES: 15/7/91 A. Schuilenburg (Handle DOS Devs)                      --;
;                    TMB16 board excluded in word mode                      --;
;--									    --;
;-----------------------------------------------------------------------------;

;
; All the public data. First the routines that are the same for all
; transputer hardware. 
        PUBLIC _fetch_block, _send_block, _byte_to_link
	PUBLIC _byte_from_link, _rdrdy, _wrrdy
; Next routines specific to particular bits of hardware, B004 and Meiko boards
        PUBLIC _b004_reset, _b004_analyse, _b004_init_link	
	PUBLIC _mk026_reset, _mk026_analyse, _mk026_init_link
	PUBLIC _dma_init, _dma_send, _dma_fetch
; Routines specific to DOS
        PUBLIC _dos_fetch_block, _dos_send_block, _dos_byte_to_link
	PUBLIC _dos_byte_from_link, _dos_rdrdy, _dos_wrrdy
	PUBLIC _dos_reset, _dos_init_link, _dos_close_link
	PUBLIC _tmb16_mode

; TMS320C40 HARDWARE
;
; All the public data. First the routines that are the same for all
; TMS320C40 hardware. 
	PUBLIC _tim40_fetch_block, _tim40_send_block, _tim40_byte_to_link
	PUBLIC _tim40_byte_from_link, _tim40_rdrdy, _tim40_wrrdy

; Next routines specific to particular bits of hardware: TIM-40 boards
	PUBLIC _tim40_reset, _tim40_init_link

; Hunt board also has hi-speed fifo interface for large transfers that can
; be used at the same time as the simple TIM-40 interface.
	PUBLIC _hunt_fetch_block, _hunt_send_block

; Transtec TDB416 board has an 8bit TIM-40 std interface and a 16 bit
; high speed interface. The high speed interface is simply a 16bit
; version of the TIM-40 standard 8 bit interface and can be used
; interchangebly with it.

	PUBLIC _tdb_wrrdy, _tdb_rdrdy, _tdb_fetch_block, _tdb_send_block

; @@@@@@ add dos device driver functions

DOSTimeout		EQU	2		; timeout flag only

reset_mask	EQU	1	; Mk026, reset = bit 0
analyse_mask	EQU	2	; Mk026 again
 
;  number of iterations for link timeout
D500Msec	EQU    6500 
 
 
Bit0               EQU 1
Bit1               EQU 2
Bit2               EQU 4
Bit3               EQU 8
Bit7               EQU 0080H

/* The following allows us to cope with TIM-40 boards requiring Bit7 to go */
/* Hi-Lo (Hunt) and boards that want bit 0 to go Lo-Hi (Transtec) */
TIM40_ASRT_RESET   EQU 00fH	; assert reset
TIM40_RELS_RESET   EQU 0f0H	; release reset

 
SUCCESS            EQU 0
FAIL               EQU 1


;==============================================================================
; success = rdrdy ()
; int success;
;
; Check link for data, If byte ready return TRUE else return FALSE.
;
;==============================================================================
; Note, this macro preserves nothing, if you wish to keep, then save it
GetDOSstatus	MACRO
	mov	ax, 4402h		;status function
	mov	bx, _dos_handle	;handle to device driver
	mov	cx, 4			;size of data
	mov	dx, offset dgroup:_dos_status
	int	21h
	mov	ax, _dos_status	;macro gives result in ax
ENDM

_rdrdy    PROC FAR
	mov     dx,_link_in_status   ; input status register
        in      al, dx                  ; Read status
        and     al, Bit0                ; Test bit zero
        ret
_rdrdy	    ENDP 		 

_dos_rdrdy    PROC FAR
	push	ds
	GetDOSstatus			; status in AX
	pop	ds
	and	al, Bit3		; ready to read ?
        ret
_dos_rdrdy	    ENDP 		 


;==============================================================================
; success = wrrdy ()
; int success;
;
; Check link for output status, If ready to Tx return TRUE else return FALSE.
;
;==============================================================================
_wrrdy    PROC FAR
        mov     dx,_link_out_status ; output status register
        in      al,dx                  ; Read status
        and     al,Bit0                ; Test bit zero
        ret
_wrrdy	    ENDP 		 

_dos_wrrdy    PROC FAR
	push	ds
	GetDOSstatus			; status in AX
	pop	ds
	and	al, Bit2		; ready to write ?
        ret
_dos_wrrdy	    ENDP 		 

 
;==============================================================================
; success = byte_to_link (x)
; int success;
; int x;  lower 8 bits output
;
; Output the given byte down the link. Return SUCCESS if the byte is output,
; else FAIL if the link adaptor is not ready after 500 Msec.
;
;==============================================================================
_byte_to_link   PROC FAR
        push    bp                      ; C stack manipulation
        mov     bp, sp

	mov	bx,0100H
l21:
        mov     cx,D500Msec
l1:
        mov     dx, _link_out_status	; inner loop, 65000 iterations
        in      al, dx
        and     al, Bit0
        jnz     l2
        loop    l1

	dec	bx		; outer loop, 256 iterations
	cmp	bx,0
	jne	l21

        mov     ax,FAIL
        jmp     short l3
l2:
        mov     ax,arg1[bp]
        mov     dx,_link_write
        out     dx,al
        mov     ax,SUCCESS
l3:
        pop     bp
        ret
 
_byte_to_link   ENDP

_dos_byte_to_link   PROC FAR
        push    bp                      ; C stack manipulation
        mov     bp, sp
	push	ds

	mov	bx,0100H
dl21:
        mov     cx,D500Msec
dl1:
	push	bx		; keep these two
	push	cx		;	"
	GetDOSstatus		; status in AX
	pop	cx		; and restore
	pop	bx		;	"
	and	al, Bit2	; ready to write ?
        jnz     dl2
        loop    dl1

	dec	bx		; outer loop, 256 iterations
	cmp	bx,0
	jne	dl21

db2lerror:
        mov     ax,FAIL
        jmp     short dl3
dl2:
	mov	bx, _dos_handle	; handle to device driver
	push	ss
	pop	ds
	lea	dx, arg1[bp]		; address of data
	mov	cx, 1			; only 1 byte
	mov	ah, 40h			; write data
	int 	21h
	jc	db2lerror		; carry set on error
	mov	ax,SUCCESS
dl3:
	pop	ds
        pop     bp
        ret

_dos_byte_to_link   ENDP


;==============================================================================
; success = byte_from_link (x)
; int success;
; char *x;
;
; Read a single byte from the link. Returns SUCCESS, or FAIL if the link
; timedout after 500Msec.
;
;==============================================================================
_byte_from_link   PROC FAR
        push    bp                      ; C stack manipulation
        mov     bp, sp
        push    si
        push    ds

	mov	bx,0100H
l20:
        mov     cx,D500Msec
l4:
        mov     dx,_link_in_status	; inner loop, 65000 iterations
        in      al,dx
        and     al,Bit0
        jnz     l5
        loop    l4

	dec	bx			; outer loop, 256 iterations
    	cmp	bx,0
	jne	l20

        mov     ax,FAIL
        jmp     short l6
l5:
        mov     dx,_link_read
        in      al,dx
        lds     si,[bp+arg1]
        mov     [si],al
        mov     ax,SUCCESS
l6:                                       ; read byte within 500 Msec.
        pop     ds 
        pop     si
        pop     bp
        ret
 
_byte_from_link   ENDP

_dos_byte_from_link   PROC FAR
        push    bp                      ; C stack manipulation
        mov     bp, sp
        push    si
        push    ds

	mov	bx,0100H
dl20:
        mov     cx,D500Msec
dl4:
	push 	bx			; save
	push	cx			;  "
	GetDOSstatus
	pop 	cx			; restore
	pop	bx			;    "
	and	al, Bit3		; Anything to read ?
        jnz     dl5
        loop    dl4

	dec	bx			; outer loop, 256 iterations
    	cmp	bx,0
	jne	dl20

db4lerror:
        mov     ax,FAIL
        jmp     short dl6
dl5:
	mov	bx, _dos_handle	; handle to device driver
	lds	dx,[bp+arg1]		; dx is address of data
	mov	cx, 1			; only 1 byte
	mov	ah, 3Fh			; read data
	int 	21h
	jc	db4lerror		; carry set on error
	mov	ax,SUCCESS

dl6:                                       ; read byte within 500 Msec.
        pop     ds 
        pop     si
        pop     bp
        ret

_dos_byte_from_link   ENDP

 
;==============================================================================
; success = send_block (count, data, timeout)
; int success;
; int count
; char *data;
; int timeout;
;
; Output the given data block down the link. Return SUCCESS if the block  is
; output, else FAIL if the link adaptor is not ready within timeout.
;
; N.B ASSUME long pointers
;==============================================================================
_send_block PROC FAR
        push    bp                      ; C stack manipulation
        mov     bp, sp
        push    si
        push    ds

        mov     bx,arg4[bp]
l22:
	mov	cx,D500Msec
l7:
        mov     dx,_link_out_status  ; wait "timeout" loops for linkout ready
        in      al,dx
        and     al,Bit0
        jnz     l8
        loop    l7

	dec	bx
	cmp	bx,0
	jne	l22

        mov     ax,arg1[bp]             ; amount of data failed to write
        jmp     short l12notime

l8:
	mov	bx,arg4[bp]		; get timeout
	push	bx			; save for later

        xchg    ah,dl                   ; store lower byte of link_out_stat in ah
        mov     dx,_link_write       ; I can now xchg ah,dl to switch from
                                        ; status port to write port
        mov     cx,arg1[bp]             ; amount of data to write
        lds     si,arg2[bp]             ; and the buffer
l9:
        mov     bx,cx                   ; store count remaining
        xchg    ah,dl                   ; check link out status
l101:
        mov     cx,D500Msec
l10:
        in      al,dx
        and     al,Bit0
        jz      l11
        xchg    ah,dl                   ; switch to link_write
	lodsb				; get next byte
        out     dx,al                   ; and output it
        mov     cx,bx                   ; restore count remaining
        loop    l9                      ; and loop for next byte
	mov	ax,SUCCESS		; finished
	jmp	short l12

l11:
        loop    l10
	pop	cx			; recall timeout
	dec	cx
	push	cx			; keep for later
	cmp	cx,0			; timed out?
	jnz	l101			; nope
        mov     ax,bx                   ; return count remaining
l12:
	pop	cx			; restore stack, kicking off timeout 
l12notime:
        pop     ds
        pop     si
        pop     bp
 
        ret
 
_send_block   ENDP

_dos_send_block PROC FAR
        push    bp                      ; C stack manipulation
        mov     bp, sp
        push    si
        push    ds

        mov     bx,arg4[bp]	; wait "timeout" loops for linkout ready
dl22:
	mov	cx,D500Msec	
dl7:
	push	bx		; keep these two
	push	cx		;	"
	GetDOSstatus		; status in AX
	pop	cx		; and restore
	pop	bx		;	"
	and	al, Bit2	; ready to write ?
        jnz     dl8
        loop    dl7

	dec	bx
	cmp	bx,0
	jne	dl22

dlsfail:
        mov     ax,arg1[bp]             ; amount of data failed to write
        jmp     short dl10

dl8:
	mov	bx, _dos_handle	; handle to device driver
        mov     cx, arg1[bp]            ; amount of data to write
	lds     dx, arg2[bp]            ; and dx is the buffer address
	mov	ah, 40h			; write data
	int 	21h
	jc	dlsfail			; carry set on failure
	mov	ax,SUCCESS
dl10:
        pop     ds
        pop     si
        pop     bp
        ret

_dos_send_block   ENDP


;==============================================================================
; success = fetch_block (count, data, timeout)
; int success;
; char *data;
; int timeout;
;
; Read the required no. of bytes into the given buffer. Return SUCCESS if the
; block is input without error, else FAIL if the link adaptor is not ready
; within timeout.
;
; N.B ASSUME long pointers
;==============================================================================
_fetch_block PROC FAR
        push    bp                      ; C stack manipulation
        mov     bp, sp
	push	di
        push    es

        mov     bx,arg4[bp]
l23:
	mov	cx,D500Msec
l13:
        mov     dx,_link_in_status   ; wait "timeout" loops for linkout ready
        in      al,dx
        and     al,Bit0
        jnz     l14
        loop    l13

	dec	bx
	cmp	bx,0
	jne	l23

        mov     ax,arg1[bp]             ; amount of data failed to write
        jmp     short l18
l14:
        xchg    ah,dl                   ; store lower byte of link_out_stat in ah
        mov     dx,_link_read        ; I can now xchg ah,dl to switch from
                                        ; status port to write port
        mov     cx,arg1[bp]             ; amount of data to write
        les     di,arg2[bp]             ; and the buffer
l15:
        mov     bx,cx                   ; store count remaining
        xchg    ah,dl                   ; check link out status
        mov     cx,D500Msec
l16:
        in      al,dx
        and     al,Bit0
        jz      l17
        xchg    ah,dl                   ; switch to link_write
        in      al,dx                   ; get byte
	stosb
        mov     cx,bx                   ; restore count remaining
	loop    l15                     ; and loop for next byte
        mov     ax,SUCCESS              ; finished
	jmp	short l18

l17:
        loop    l16
        mov     ax,bx                   ; return count remaining
l18:
        pop     es
        pop     di
        pop     bp
 
        ret
  
_fetch_block   ENDP

_dos_fetch_block PROC FAR
        push    bp                      ; C stack manipulation
        mov     bp, sp
	push	di
        push    ds

        mov     bx,arg4[bp]
dl23:
	mov	cx,D500Msec
dl13:
	push	bx
	push	cx
	GetDOSstatus			; ready to receive ?
	pop	cx
	pop	bx
        and     al,Bit3
        jnz     dl14
        loop    dl13

	dec	bx
	cmp	bx,0
	jne	dl23

dlffail:
        mov     ax,arg1[bp]             ; amount of data failed to read
        jmp     short dl16
dl14:
	mov	bx, _dos_handle	; handle to device driver
        mov     cx,arg1[bp]             ; amount of data to read
	lds     dx,arg2[bp]             ; and the buffer address
	mov	ah, 3Fh			; read data
	int 	21h
	jc	dlffail			; carry set on failure
	mov	ax,SUCCESS
dl16:
        pop     ds
        pop     di
        pop     bp
        ret

_dos_fetch_block   ENDP

 
;=============================================================================
; void dos_reset ()
;
; Reset root Transputer through dos device
;
;=============================================================================
_dos_reset   PROC FAR
	push	ds			; keep ds
	mov	ax, _dos_handle	; get current handle
	cmp	ax, 0			; is it set ? 
	jnz	dos_open
	pop	ds			; oops, not open, failed
	ret	

dos_open :
	; put into binary mode
	mov	dx, 0020h
	mov	bx, _dos_handle
	mov	ax, 4401h
	int	21h

	; reset Transputer
	mov	bx, _dos_handle
	mov	cx, 4			; 0 bytes
	mov	dx, offset dgroup:_dos_dev_word
	mov	ax, 0			; load reset instruction
	mov	[_dos_dev_word + 0], ax	;	"
	mov	ax, 0			;	"
	mov	[_dos_dev_word + 2], ax	;	"
	mov	ax, 4403h		; dos fn 44-03	(device ctrl write)
	int 	21h

	pop 	ds			; Restore ds
	ret

_dos_reset   ENDP

_tmb16_mode	PROC FAR
	push	bp			; C stack manipulation
	mov	bp, sp
	push	ds

	mov	bx, _dos_handle
	mov	cx, 4			; 0 bytes
	mov	dx, offset dgroup:_dos_dev_word
	mov	ax, arg1[bp]		; load mode data	(low byte 1st)
	mov	[_dos_dev_word + 0], ax	;	"
	mov	ax, arg2[bp]		;	" (high byte)
	mov	[_dos_dev_word + 2], ax	;	"
	mov	ax, 4403h		; dos fn 44-03	(device ctrl write)
	int 	21h

	pop	ds
	pop	bp
	ret
_tmb16_mode	ENDP

_dos_init_link	PROC FAR
	push	bp			; C stack manipulation
	mov	bp, sp
	push	si
	push	ds			; keep ds
	mov	ax, _dos_handle	; get current handle
	cmp	ax, 0			; is it set ? 
	jnz	dos_link_exit			; already open

	mov	dx, arg1[bp]	; Get ptr to name
	mov	ds, arg2[bp]	;	"	
	mov	al, 2			; open for i/o
	mov	ah, 3Dh			; open file
	int 	21h
	jc	no_dev
	mov	_dos_handle, ax	; store handle
	
	mov	bx, ax			; ensure not a file
	mov	ax, 4400h		; IOCTL call, fn 0
	int	21h
	test	dl, 80h
	jz	no_dev

	pop	ds
	push	ds
	call	_dos_reset		; reset the transputer as well
	mov	ax, SUCCESS
	jmp	short dos_link_exit

no_dev :
	mov	ax, FAIL

dos_link_exit :	
	pop	ds
	pop	si
	pop	bp
	ret
	
_dos_init_link	ENDP

_dos_close_link	PROC FAR
	mov	bx, _dos_handle	; get current handle
	cmp	bx, 0			; is it set ? 
	jz	dos_close_exit		; not open

	mov	ax, 3E00h			; close file
	int	21h
	mov	_dos_handle, 0	; reset handle

dos_close_exit:
	ret

_dos_close_link	ENDP

;=============================================================================
; void b004_reset ()
;
; Reset root Transputer on a B004 board
;
;=============================================================================
_b004_reset   PROC FAR
 
        mov     dx, _link_reset         ; address of reset reg.
        mov     al, 1                   ; assert reset
        out     dx,al
        mov     cx, _reset_timeout        ; wait ? Msec
waitr:
        loop    waitr
        xor     al, 1                   ; release reset
        out     dx,al

	mov	cx,_reset_timeout	
wait10:
	loop	wait10

        ret
 
_b004_reset   ENDP
 
;=============================================================================
; void b004_analyse ()
;
; Analyse root Transputer
;
;=============================================================================
_b004_analyse   PROC FAR
        mov     dx, _link_analyse       ; address of analyse register
        mov     al, 1                   ; assert analyse
        out     dx,al
        mov     cx, _analyse_timeout    ; wait ? Msec
waita:
        loop    waita
 
        mov     dx, _link_reset         ; assert reset
        out     dx,al
        mov     cx, _reset_timeout      ; wait ? Msec
waitrs:
        loop    waitrs
 
        xor     al,1                    ; release reset
        out     dx,al

	mov	cx,_reset_timeout
waitmore:
	loop	waitmore

        mov     dx, _link_analyse
        out     dx,al

	mov	cx,_reset_timeout
wait11:
	loop	wait11
        ret
_b004_analyse ENDP
 
;=============================================================================
; void b004_init_link()
;
; This forces the analyse line down, instead of leaving it floating
;
;=============================================================================
_b004_init_link	PROC	FAR
	mov	dx, _link_analyse
	xor	ax,ax
	out	dx, al
	mov	dx,_link_in_status	; disable link interrupts
	out	dx,al
	ret
_b004_init_link	ENDP
	
;=============================================================================
; void mk026_reset ()
;
; Reset root Transputer on a Meiko board
;
;=============================================================================
_mk026_reset   PROC FAR
 
        mov     dx, _control_write      ; address of control reg.
        mov     al, control_mask        ; current control mask
        or      al, reset_mask          ; assert reset
        out     dx,al
        mov     cx, _reset_timeout      ; wait ? Msec
mkwaitr:
        loop    mkwaitr
        xor     al,reset_mask           ; release reset
        out     dx,al
        mov     control_mask,al
 
        mov	cx,D500MSec             ; the Meiko surface has to drain
mkwait2:                                ; the National Grid before it kicks
        loop    mkwait2                 ; off
        ret
 
_mk026_reset   ENDP
 
 
;=============================================================================
; void mk026_analyse ()
;
; Analyse root Transputer on a Meiko board
;
;=============================================================================
_mk026_analyse   PROC FAR
 
        mov     dx, _control_write      ; address of control reg.
        mov     al, control_mask        ; current control mask
        or      al, analyse_mask        ; assert analyse
        out     dx,al
        mov     cx, _analyse_timeout    ; wait ? Msec
mkwaita:
        loop    mkwaita
 
        or      al, reset_mask          ; assert reset
        out     dx,al
        mov     cx, _reset_timeout      ; wait ? Msec
mkwaitrs:
        loop    mkwaitrs
 
        xor     al,reset_mask           ; release reset
        out     dx,al
        xor     al,analyse_mask         ; release analyse
        out     dx,al
        mov     control_mask,al

        ret
_mk026_analyse ENDP
 
 
 
;=============================================================================
; void mk026_init_link ()
;
; Initialise the link Interface on a B004 board
;
;=============================================================================
_mk026_init_link PROC FAR
 
        mov     dx, _control_write      ; address of control reg.
        mov     al, 00H                 ; Disable DMA & soft/hard error int.
        mov     control_mask,al         ; initialise control mask
        out     dx,al                   ; output to control register

	mov	dx,_link_in_status	; disable link interrupts
	out	dx,al
 
        call    _mk026_reset            ; reset the root Transputer
 
        ret
 
_mk026_init_link ENDP

;==============================================================================
; dma_init()                       - disable DMA interrupts
; dma_send(count, page, offset)    - transmit data
; dma_receive(count, page, offset) - receive data
;
; These routines are based on the documentation in the B008 manual. All the
; really nasty address manipulation is done in pclocal.c, because it is far
; too unpleasant to implement in assembler
;==============================================================================

dma_mastctrl	EQU	0dH
dma_pagebase	EQU	080H
dma_base	EQU	0
dma_status	EQU	08H
dma_command	EQU	08H
dma_mode	EQU	0bH
dma_allmask	EQU	0fH

_dma_init	PROC FAR
	mov	dx,_int_enable	; disable all interrupts
	xor	ax,ax			; dma is handled by polling
	out	dx,al			; to avoid interrupts clashing
	ret
_dma_init	ENDP
 
_dma_send	PROC FAR
	push	bp
	mov	bp,sp
	
	xor	ax,ax
	out	dma_mastctrl,al	; reset the DMAC

	mov	ax,_dma_channel	; set up the DMA page
	mov	dx,082H
	cmp	ax,3			; channel 3 uses 082H
	je	send_gotpage
	dec	dx			; channel 2 uses 081H
	cmp	ax,2
	je	send_gotpage
	mov	dx,083H			; channels 0 and 1 use 083H	
send_gotpage:	
	mov	ax,arg2[bp]
	out	dx,al

	mov	dx,_dma_channel	; now for the transfer base
	add	dx,dx			; at offsets 0, 2, 4, and 6
	add	dx,dma_base
	mov	ax,arg3[bp]
	out	dx,al			; low byte
	mov	al,ah
	out	dx,al			; middle byte

	inc	dx			; count follows after base register
	mov	ax,arg1[bp]
	dec	ax
	out	dx,al			; low byte of count
	mov	al,ah
	out	dx,al

	mov	ax,_dma_channel	; dma mode
	add	ax,08H			; -> trannie
	out	dma_mode,al

	xor	al,al			; dma command is 0
	out	dma_command,al
	out	dma_allmask,al		; that finishes the DMAC
					; now for the board itself
 	mov	dx,_link_in_status
	mov	ax,2
	out	dx,al
	mov	dx,_link_out_status
	out	dx,al

	mov	dx,_dma_request
	xor	ax,ax
	out	dx,al			; force write

	mov	cx,_dma_channel	; prepare to poll for DMA completion
	mov	ax,1			; which bit to check...
	shl	ax,cl
	mov	ah,al
	mov	dx,dma_status		; in which register...

	mov	bx,10			; couple of seconds delay
send_outer:
	mov	cx,65000
send_inner:
	in	al,dx
	and	al,ah
	jne	dmasend_finished
	loop	send_inner
	dec	bx
	cmp	bx,0
	jne	send_outer

dmasend_finished:
	xor	ax,ax		; reset DMA
	out	dma_mastctrl,al
	mov	dx,_link_in_status	; reset C012
	out	dx,al
	mov	dx,_link_out_status
	out	dx,al

	mov	ax,bx		; contains success/failure
	pop	bp			
	ret
_dma_send ENDP

_dma_fetch	PROC FAR
	push	bp
	mov	bp,sp
	
	xor	ax,ax
	out	dma_mastctrl,al	; reset the DMAC

	mov	ax,_dma_channel	; set up the DMA page
	mov	dx,082H
	cmp	ax,3			; channel 3 uses 082H
	je	fetch_gotpage
	dec	dx			; channel 2 uses 081H
	cmp	ax,2
	je	fetch_gotpage
	mov	dx,083H			; channels 0 and 1 use 083H	
fetch_gotpage:	
	mov	ax,arg2[bp]
	out	dx,al

	mov	dx,_dma_channel	; now for the transfer base
	add	dx,dx			; at offsets 0, 2, 4, and 6
	add	dx,dma_base
	mov	ax,arg3[bp]
	out	dx,al			; low byte
	mov	al,ah
	out	dx,al			; middle byte

	inc	dx			; count follows after base register
	mov	ax,arg1[bp]
	dec	ax
	out	dx,al			; low byte of count
	mov	al,ah
	out	dx,al

	mov	ax,_dma_channel	; dma mode
	add	ax,04H			; <- trannie
	out	dma_mode,al

	xor	al,al			; dma command is 0
	out	dma_command,al
	out	dma_allmask,al		; that finishes the DMAC
					; now for the board itself
 	mov	dx,_link_in_status
	mov	ax,2
	out	dx,al
	mov	dx,_link_out_status
	out	dx,al

	mov	dx,_dma_request
	mov	ax,1
	out	dx,al			; force read

	mov	cx,_dma_channel	; prepare to poll for DMA completion
	mov	ax,1			; which bit to check...
	shl	ax,cl
	mov	ah,al
	mov	dx,dma_status		; in which register...

	mov	bx,10			; couple of seconds delay
fetch_outer:
	mov	cx,65000
fetch_inner:
	in	al,dx
	and	al,ah
	jne	dmafetch_finished
	loop	fetch_inner
	dec	bx
	cmp	bx,0
	jne	fetch_outer
dmafetch_finished:
	xor	ax,ax			; reset DMA
	out	dma_mastctrl,al
	mov	dx,_link_in_status	; reset C012
	out	dx,al
	mov	dx,_link_out_status
	out	dx,al

	mov	ax,bx
	pop	bp			
	ret
_dma_fetch ENDP

;==============================================================================
; TMS320C40 specfic link functions

;==============================================================================
; TIM-40 standard link interface support

;==============================================================================
; success = rdrdy ()
; int success;
;
; Check link for data, If byte ready return TRUE else return FALSE.
;
;==============================================================================
_tim40_rdrdy    PROC FAR
	mov     dx,_link_in_status   ; input status register
	in      al, dx                  ; Read status
	and     al, Bit7                ; Test bit seven
	ret
_tim40_rdrdy	    ENDP 		 


;==============================================================================
; success = wrrdy ()
; int success;
;
; Check link for output status, If ready to Tx return TRUE else return FALSE.
;
;==============================================================================
_tim40_wrrdy    PROC FAR
	mov     dx,_link_out_status ; output status register
	in      al,dx                  ; Read status
	and     al,Bit7                ; Test bit seven
	ret
_tim40_wrrdy	    ENDP 		 


;==============================================================================
; success = byte_from_link (x)
; int success;
; char *x;
;
; Read a single byte from the link. Returns SUCCESS, or FAIL if the link
; timedout after 500Msec.
;
;==============================================================================
_tim40_byte_from_link   PROC FAR
	push    bp                      ; C stack manipulation
	mov     bp, sp
	push    si
	push    ds

	mov	bx,0100H
t40l20:
	mov     cx,D500Msec
t40l4:
	mov     dx,_link_in_status	; inner loop, 65000 iterations
	in      al,dx
	and     al,Bit7
	jnz     t40l5
	loop    t40l4

	dec	bx			; outer loop, 256 iterations
    	cmp	bx,0
	jne	t40l20

	mov     ax,FAIL
	jmp     short t40l6
t40l5:
	mov     dx,_link_read
	in      al,dx
	lds     si,[bp+arg1]
	mov     ds:[si],al
	mov     ax,SUCCESS
t40l6:                                       ; read byte within 500 Msec.
	pop     ds 
	pop     si
	pop     bp
	ret
 
_tim40_byte_from_link   ENDP

 
;==============================================================================
; success = byte_to_link (x)
; int success;
; int x;  lower 8 bits output
;
; Output the given byte down the link. Return SUCCESS if the byte is output,
; else FAIL if the link adaptor is not ready after 500 Msec.
;
;==============================================================================
_tim40_byte_to_link   PROC FAR
	push    bp                      ; C stack manipulation
	mov     bp, sp

	mov	bx,0100H
t40l21:
	mov     cx,D500Msec
t40l1:
	mov     dx, _link_out_status	; inner loop, 65000 iterations
	in      al, dx
	and     al, Bit7
	jnz     t40l2
	loop    t40l1

       	dec	bx			; outer loop, 256 iterations
	cmp	bx,0
	jne	t40l21

	mov     ax,FAIL
	jmp     short t40l3
t40l2:
	mov     ax,arg1[bp]
	mov     dx,_link_write
	out     dx,al
	mov     ax,SUCCESS
t40l3:
	pop     bp
	ret
 
_tim40_byte_to_link   ENDP

;==============================================================================
; success = fetch_block (count, data, timeout)
; int success;
; char *data;
; int timeout;
;
; Read the required no. of bytes into the given buffer. Return SUCCESS if the
; block is input without error, else FAIL if the link adaptor is not ready
; within timeout.
;
; N.B ASSUME long pointers
;==============================================================================
_tim40_fetch_block PROC FAR
	push    bp                      ; C stack manipulation
	mov     bp, sp
	push	di
	push    es

	mov     bx,arg4[bp]
t40l23:
	mov	cx,D500Msec
t40l13:
	mov     dx,_link_in_status   ; wait "timeout" loops for linkout ready
	in      al,dx
	and     al,Bit7
	jnz     t40l14
	loop    t40l13

	dec	bx
	cmp	bx,0
	jne	t40l23

	mov     ax,arg1[bp]             ; amount of data failed to write
	jmp     short t40l18
t40l14:
	mov     cx,arg1[bp]             ; amount of data to write
	les     di,arg2[bp]             ; and the buffer
	xchg    ah,dl                   ; store lower byte of link_out_stat in ah
	mov     dx,_link_read           ; I can now xchg ah,dl to switch from
	                                ; status port to write port
t40l15:
	mov     bx,cx                   ; store count remaining
	xchg    ah,dl                   ; check link out status
	mov     cx,D500Msec
t40l16:
	in      al,dx
	and     al,Bit7
	jz      t40l17
	xchg    ah,dl                   ; switch to link_write
	in      al,dx                   ; get byte
	stosb
	mov     cx,bx                   ; restore count remaining
	loop    t40l15                     ; and loop for next byte
	mov     ax,SUCCESS              ; finished
	jmp	short t40l18

t40l17:
	loop    t40l16
	mov     ax,bx                   ; return count remaining
t40l18:
	pop     es
	pop     di
	pop     bp
 
	ret
  
_tim40_fetch_block   ENDP

 
;==============================================================================
; success = send_block (count, data, timeout)
; int success;
; int count
; char *data;
; int timeout;
;
; Output the given data block down the link. Return SUCCESS if the block  is
; output, else FAIL if the link adaptor is not ready within timeout.
;
; N.B ASSUME long pointers
;==============================================================================
_tim40_send_block PROC FAR
	push    bp                      ; C stack manipulation
	mov     bp, sp
	push    si
	push    ds

	mov     bx,arg4[bp]
t40l22:
	mov	cx,D500Msec
t40l7:
	mov     dx,_link_out_status  ; wait "timeout" loops for linkout ready
	in      al,dx
	and     al,Bit7
	jnz     t40l8
	loop    t40l7

	dec	bx
	cmp	bx,0
	jne	t40l22

	mov     ax,arg1[bp]             ; amount of data failed to write
	jmp     short t40l12notime

t40l8:
	mov	bx,arg4[bp]		; get timeout
	push	bx			; save for later

	xchg    ah,dl                   ; store lower byte of link_out_stat in ah
	mov     dx,_link_write          ; I can now xchg ah,dl to switch from
	                                ; status port to write port
	mov     cx,arg1[bp]             ; amount of data to write
	lds     si,arg2[bp]             ; and the buffer
t40l9:
	mov     bx,cx                   ; store count remaining
	xchg    ah,dl                   ; check link out status
t40l101:
	mov     cx,D500Msec
t40l10:
	in      al,dx
	and     al,Bit7
	jz      t40l11
	xchg    ah,dl                   ; switch to link_write
	lodsb				; get next byte
	out     dx,al                   ; and output it
	mov     cx,bx                   ; restore count remaining
	loop    t40l9                   ; and loop for next byte
	mov	ax,SUCCESS		; finished
	jmp	short t40l12

t40l11:
	loop    t40l10
	pop	cx			; recall timeout
	dec	cx
	push	cx			; keep for later
	cmp	cx,0			; timed out?
	jnz	t40l101			; nope
	mov     ax,bx                   ; return count remaining
t40l12:
	pop	cx			; restore stack, kicking off timeout 
t40l12notime:
	pop     ds
	pop     si
	pop     bp
 
	ret
 
_tim40_send_block   ENDP

;=============================================================================
; void tim40_reset ()
;
; Reset root 'C40
;
;=============================================================================
_tim40_reset   PROC FAR
 
	mov     dx, _link_reset      ; address of reset reg.
/*	mov     al, 0	                ; assert reset */
	mov     al, TIM40_ASRT_RESET    ; assert reset
	out     dx,al
	mov     cx, _reset_timeout	; wait ? Msec
t40waitr:
	loop    t40waitr
/*	mov	al, Bit7                ; release reset */
	mov	al, TIM40_RELS_RESET    ; release reset
	out     dx,al

	mov	cx,_reset_timeout	
t40wait10:
	loop	t40wait10

	ret
 
_tim40_reset   ENDP
 
;=============================================================================
; void tim40_init_link()
;
; Presently does nothing
;
;=============================================================================
_tim40_init_link	PROC	FAR
	ret
_tim40_init_link	ENDP


;==============================================================================
; Hunt HEPC2 high performance interface support

;==============================================================================
; success = fetch_block (count, data, timeout)
; int success;
; far char *data;
; int timeout;
;
; Read the required no. of bytes into the given buffer. Return SUCCESS if the
; block is input without error, else FAIL if the link adaptor is not ready
; within timeout.
;
; N.B ASSUME long pointers
;==============================================================================
;
; The hunt board implements a 16k fifo. All reads from this area of memory
; read from the link. The IORDY line is used to throttle the transfer so you
; don't have to poll status bits. The benefit of this design is that the 8086
; REP MOVSB instructions can be used to move the data at bus speed. A status
; register simply notes if the entire transfer timed out or succeeded.
;
;
;
_hunt_fetch_block PROC FAR
	pushall				; save all regs and bp = args

	mov	cx,arg1[bp]             ; get amount of data to read
	les	di,arg2[bp]             ; get the buffer to read into
					; into ES:DI
	mov	bx,_hunt_fifo_size
	mov	dx,_hunt_timeout
	mov	si,_hunt_hiperf_seg
	mov	ds,si

	; ignore timeout argument - this is fixed in the hardware

hunt_reset_src:

	; the hiperf memory is only 16k in size, so separate
	; reads into up to 4 chunks
	cmp	cx, bx			; _hunt_fifo_size
	ja	hunt_rd_chunk

	xor	si,si			; zero offset for fifo
	rep	movsb			; move up to fifo_size (16k) of data

	xor	ax,ax			; check if transfer timed out
	in      al,dx			; (bit 7 = 1 == timed out)
	and     al,Bit7			; will return TRUE/FALSE indication

hunt_read_fail:
	popall				; restore all PCS caller saves regs
 
	ret

hunt_rd_chunk:
	mov	ax, bx			; temporary for _hunt_fifo_size
	sub	cx, ax			; cx reduced by fifo size
	xchg	ax, cx			; ax = remaining count of chars

	xor	si,si			; zero offset for fifo
	rep	movsb			; move fifo size (16k) of data

	xchg	ax, cx			; cx = remaining count of chars

	; @@@@@@ the following could be removed and the timeout only
	; checked at the end of the complete transfer.
	xor	ax,ax			; check if transfer timed out
	in      al,dx			; (bit 7 = 1 == timed out)
	and     al,Bit7			; will return TRUE/FALSE indication

	jz	hunt_reset_src		; reset si to start of fifo and repeat

	xchg	ax, cx			; ret remaining count of chars to read
					; not accurate, so only used as an
					; indication
	jmp	short hunt_read_fail

_hunt_fetch_block   ENDP


;==============================================================================
; int success = send_block (count, data, timeout)
; int count
; far char *data;
; int timeout;
;
; Output the given data block down the link. Return SUCCESS if the block  is
; output, else FAIL if the link adaptor is not ready within timeout.
;
; N.B ASSUME long pointers
;==============================================================================
; See notes above about the Hunt Eng fifo.
; Writing to any address in the fifo sends that data down the link to a C40.
;

_hunt_send_block PROC FAR
	pushall				; save all regs and bp = args

	mov	cx,arg1[bp]             ; get amount of data to write
	mov	di,_hunt_hiperf_seg	; es:00 == fifo
	mov	es,di
	mov	bx,_hunt_fifo_size
	mov	dx,_hunt_timeout

	lds	si,arg2[bp]             ; get the buffer to read from
					; into DS:SI
	; ignore timeout argument - this is fixed in the hardware

hunt_reset_dst:

	; the hiperf memory is only 16k in size, so separate
	; writes into up to 4 chunks
	cmp	cx, bx
	ja	hunt_wr_chunk

	xor	di,di			; zero offset for fifo
	rep	movsb			; move up to fifo_size (16k) of data

	xor	ax,ax			; check if transfer timed out
	in      al,dx			; (bit 7 = 1 == timed out)
	and     al,Bit7			; will return TRUE/FALSE indication

hunt_write_fail:
	popall				; restore all PCS caller saves regs
 
	ret

hunt_wr_chunk:
	mov	ax,bx			; ax == temporary for fifo size
	sub	cx, ax			; cx reduced by fifo size
	xchg	ax, cx			; bx = remaining count of chars

	xor	di,di			; zero offset of fifo
	rep	movsb			; move fifo size (16k) of data

	xchg	ax, cx			; cx = remaining count of chars

	; @@@@@@ the following could be removed and the timeout only
	; checked at the end of the complete transfer.
	xor	ax,ax			; check if transfer timed out
	in      al,dx			; (bit 7 = 1 == timed out)
	and     al,Bit7			; will return TRUE/FALSE indication

	jz	hunt_reset_dst		; reset di to start of fifo and repeat

	xchg	ax, cx			; ret remaining count of chars to read
					; not accurate, so only used as an
					; indication
	jmp	short hunt_write_fail
_hunt_send_block   ENDP


;==============================================================================
; Transtec TDB416 board (16bit interface) support

; Transtec TDB416 board has an 8bit TIM-40 std interface and a 16 bit
; high speed interface. The high speed interface is simply a 16bit
; version of the TIM-40 standard 8 bit interface and can be used
; interchangebly with it. The board has a design problem in that it only has
; 16 bit latches. This means that if the C40 asynchronously sends a word
; during a PC write, that it will grab the token send 2 bytes and then
; hang the interface until that word is read. The Helios half duplex protocol
; guarantees that only one word will be sent before the PC signals that it
; is ready to receive a full message. To get around this problem, if we ever
; timeout on a write, we immediately try to read a word of data and then
; attempt to continue writing. The read ready and read routines always
; check the buffer we stored the word away in before checking the link
; directly. Another problem associated with the board is that of non word
; (16 bit) reads. A read request may read a byte multiple, rather than a
; word multiple amount of data. In this case, the next byte must also be read
; and stored away as the board can only cope with word reads on word boundaries.
; The saved word then being provided to the next read. The only case where
; a non word aligned read will take place is for reading the padding bytes and
; then the next data block. All other reads will be 32 bit word multiples.

;==============================================================================
; success = rdrdy ()
; int success;
;
; Check link for data, If byte ready return TRUE else return FALSE.
;
;==============================================================================
_tdb_rdrdy    PROC FAR
	mov     ax,_tdb_wordsaved	; check if word is in buffer
	cmp	ax, 0			; if so return true
	jne	word_avail
					; otherwise, check the link
	mov     dx,_link_in_status   ; input (16bit) status register
	in      ax, dx                  ; Read status
	and     ax, Bit7                ; Test bit seven
word_avail:
	ret
_tdb_rdrdy	    ENDP 		 


;==============================================================================
; success = wrrdy ()
; int success;
;
; Check link for output status, If ready to Tx return TRUE else return FALSE.
;
;==============================================================================
_tdb_wrrdy    PROC FAR
	mov     dx,_link_out_status ; (16bit) output status register
	in      ax,dx                  ; Read status
	and     ax,Bit7                ; Test bit seven
	ret
_tdb_wrrdy	    ENDP 		 


;==============================================================================
; success = fetch_block (count, data, timeout)
; int success;
; char *data;
; int timeout;
;
; Read the required no. of bytes into the given buffer. Return SUCCESS if the
; block is input without error, else FAIL if the link adaptor is not ready
; within timeout.
;
; N.B ASSUME long pointers
;==============================================================================
_tdb_fetch_block PROC FAR
	push    bp                      ; C stack manipulation
	mov     bp, sp
	push	di
	push    es

	mov     bx,arg4[bp]		; get timeout

	; check if last read routine had to read non byte multiple
	; and therfore saved extra byte read into buffer
	mov	dx,_tdb_bytesaved
	cmp	dx, 0
	jz	tdb_checkword

	; pseudo read byte previously read from link
	mov     cx,arg1[bp]             ; amount of data to write
	sub	cx, 1
	les     di,arg2[bp]             ; the buffer to write

	mov	al,_tdb_bytebuffer	; get saved data
	stosb

	mov	ax, 0
	mov	_tdb_bytesaved, ax	; note empty byte buffer

	shr	cx,1			; convert to 16bit word count
	jnc	tdbl15			; ignore initial timeout - we have
					; already started reading data
	mov	ax, 1
	mov	_tdb_bytesaved, ax	; note we should fill byte buffer

	; no write can take place between non byte multiple reads
	; (only non word multiple case is reading padding bytes)
	jz	tdbl15			; ignore initial timeout - we have
					; already started reading data

tdb_checkword:
	; check if write routine had to read blocking word into buffer
	mov	dx,_tdb_wordsaved
	cmp	dx, 0
	jz	tdbl23

	; pseudo read 2 16bit words previously read from link to unblock
	; the last write
	mov     cx,arg1[bp]             ; amount of data to write
	shr	cx,1			; convert to 16bit word count

	jnc	not_byte_mult		; check for byte mult read request.
	mov	ax, 1
	mov	_tdb_bytesaved, ax	; note we should fill byte buffer

not_byte_mult:
	les     di,arg2[bp]             ; the buffer to write

	sub	cx,2
	mov	ax,_tdb_wordbuffer1	; get saved data
	stosw
	mov	ax,_tdb_wordbuffer2	; get saved data 2nd 16bit word
	stosw
	mov	ax, 0
	mov	_tdb_wordsaved, ax	; note empty word buffer

	cmp	cx, 0
	jz	readcomplete

	jmp	short tdbl15		; ignore initial timeout - we have
					; already started reading data

tdbl23:
	mov	cx,D500Msec
tdbl13:
	mov     dx,_link_in_status   ; wait "timeout" loops for linkout ready
	in      ax,dx
	and     ax,Bit7
	jnz     tdbl14
	loop    tdbl13

	dec	bx
	cmp	bx, 0
	jne	tdbl23

	mov     ax,arg1[bp]             ; amount of data failed to write
	jmp     short tdbl18

tdbl14:
	les     di,arg2[bp]             ; the buffer to write
	mov     cx,arg1[bp]             ; amount of data to write
	shr	cx,1			; convert to 16bit word count

	jnc	tdbl15			; check for byte mult read request.
	mov	ax, 1
	mov	_tdb_bytesaved, ax	; note we should fill byte buffer

	cmp	cx, 0			; if only one byte requested.
	jz	tryreadbytes		; just read it and dummy

tdbl15:
	mov     bx,cx                   ; store count remaining
	mov     cx,D500Msec
	mov     dx,_link_in_status	; check link in status
tdbl16:
	in      ax,dx
	and     ax,Bit7
	jz      tdbl17
	mov     dx,_link_read
	in      ax,dx                   ; get 16bit word 
	stosw
	mov     cx,bx                   ; restore count remaining
	loop    tdbl15                  ; and loop for next 16bit word
readcomplete:

	mov	dx,_tdb_bytesaved
	cmp	dx, 0
	jz	tdb_wordmultok

	; must read extra word for non word multiple data
tryreadbytes:
	mov     cx,D500Msec
	mov     dx,_link_in_status	; check link in status
	in      ax,dx
	and     ax,Bit7
	jz      nobyteread
	mov     dx,_link_read
	in      ax,dx                   ; get 16bit word 
	; one byte to data buffer, one byte to save buffer to be read later
	stosb				; lower order byte to buffer
	mov	_tdb_bytebuffer, ah	; higher order byte to save

tdb_wordmultok:
	mov     ax,SUCCESS              ; finished
	jmp	short tdbl18

nobyteread:
	loop    tryreadbytes
	mov     ax,1			; return count remaining
	jmp	short tdbl18			; fail

tdbl17:
	loop    tdbl16
	mov     ax,bx                   ; return count remaining
	shl	ax,1			; adjust from word to byte count
tdbl18:
	pop     es
	pop     di
	pop     bp
 
	ret
  
_tdb_fetch_block   ENDP

 
;==============================================================================
; success = send_block (count, data, timeout)
; int success;
; int count
; char *data;
; int timeout;
;
; *Warning*: This function assumes that transfer requests will always be for
; an even number of bytes.
;
; Output the given data block down the link. Return SUCCESS if the block  is
; output, else FAIL if the link adaptor is not ready within timeout.
;
; N.B ASSUME long pointers
;==============================================================================
_tdb_send_block PROC FAR
	push    bp                      ; C stack manipulation
	mov     bp, sp
	push    di
	push	es

	mov     bx,arg4[bp]
tdbl22:
	mov	cx,D500Msec
tdbl7:
	mov     dx,_link_out_status  ; wait "timeout" loops for linkout ready
	in      ax,dx
	and     ax,Bit7
	jnz     tdbl8
	loop    tdbl7

	dec	bx
	cmp	bx, 0
	jne	tdbl22

	mov     ax,arg1[bp]             ; amount of data failed to write
	jmp     short tdbl12notime

	; some data available
tdbl8:

	mov	bx,arg4[bp]		; get timeout
	push	bx			; save for later

	mov     cx,arg1[bp]             ; amount of data to write
	shr	cx,1			; convert to 16 bit word count
	les     di,arg2[bp]             ; and the buffer

tdbl9:
	mov     bx,cx                   ; store count remaining
tdbl101:
	mov     dx,_link_out_status	; check link tx status
	mov     cx,D500Msec
tdbl10:
	in      ax,dx			; 16 bit status reg
	and     ax,Bit7
	jz	tdbl11

	mov     dx,_link_write
	mov	ax,es:[di]		; get next 16 bit word
	add	di,2
	out     dx,ax                   ; and output it
	mov     cx,bx                   ; restore count remaining
	loop    tdbl9                   ; and loop for next word
	mov	ax,SUCCESS		; finished
	jmp	short tdbl12

tdbl11:
	loop    tdbl10

	; check link for word coming in - it will block our write if
	; it is present and is not immediately read.
	mov     dx,_link_in_status
	in      ax,dx
	and     ax,Bit7
	jz	tdbnord

	mov     _tdb_wordsaved, ax
	mov     dx, _link_read
	in	ax,dx
	mov	_tdb_wordbuffer1, ax	; read first 16bits of blocking word

	mov	cx,D500Msec
	mov     dx,_link_in_status
tdbtryrd:
	in      ax,dx
	and     ax,Bit7
	jnz	tdbrd2
	loop	tdbtryrd		; if we have one 16 bit word
					; the another must come soon.
tdbnord:
	pop	cx			; recall timeout
	dec	cx
	push	cx			; keep for later
	cmp	cx, 0			; timed out?
	jnz	tdbl101			; nope
	mov     ax,bx                   ; return count remaining
	shl	ax,1			; adjust from word to byte count

tdbl12:
	pop	cx			; restore stack, kicking off timeout 
tdbl12notime:
	pop	es
	pop     di
	pop     bp
 
	ret
 
tdbrd2:
	mov     dx,_link_read
	in	ax,dx			; read remaining 16bits of blocking word
	mov	_tdb_wordbuffer2, ax
	jmp	tdbl101			; try to write again

_tdb_send_block   ENDP


#if Ether_supported
; ==============================================================================
; -- Support for Clarkson Packet Drivers
; -- crf: May 1992
; ==============================================================================
; The following note was extracted from packet_d.109 ("PC/TCP Version 1.09 
; Packet Driver Specification") :
; "When a packet is received, receiver is called twice by the packet driver.
; The first time it is called to request a buffer from the application to
; copy the packet into. AX == 0 on this call. The application should return
; a pointer to the buffer in ES:DI. If the application has no buffers, it
; may return 0:0 in ES:DI, and the driver should throw away the packet and
; not perform the second call.
; ...
; On the second call, AX == 1. This call indicates that the copy has been
; completed, and the application may do as it wishes with the buffer. The
; buffer that the packet was copied into is pointed to by SI."
; ------------------------------------------------------------------------------
; There is some useful example code supplied with the Clarkson sources. An
; example receiver routine is given in pktall.asm. The routine that actually 
; calls the receiver can be found in head.asm.
; ------------------------------------------------------------------------------
#define MAXETHERPKT		1514		/* maximum size of packet */
#define MAX_PKT_TABLE		8		/* size of buffer table   */

#if !(MSWINDOWS)
	/* Keep in step with ether.c !!!                                  */
PUBLIC _receiver
_receiver PROC FAR

	push ds
	push dx
	mov dx, DGROUP	; default data segment
	mov ds, dx

	;======================================================================
	;Which call is this ? If 1st (AX == 0), return pointer to buffer in
	;ES:DI. If second (AX == 1), the packet has been copied into the 
	;buffer
	;======================================================================
	cmp ax, 0
	je assign_buffer

	;======================================================================
	;2nd call (AX == 1)
	;Packet has been copied into buffer
	;Increment index (with wrap around) and packet count
	;======================================================================
	inc rcvr_index
	cmp rcvr_index, MAX_PKT_TABLE
	jne got_pkt
	mov rcvr_index, 0
got_pkt:
	inc _pkt_rcvd
	jmp short done

	;======================================================================
	;1st call (AX == 0)
	;Enter with CX == packet length
	;Return pointer to buffer in ES:DI
	;======================================================================
assign_buffer:
	cmp _pkt_rcvd, MAX_PKT_TABLE	; Check for buffer overflow
	je short discard_pkt

	cmp cx, MAXETHERPKT		; Check if packet will fit into buffer
	jle ok_2
	mov _pkt_too_long, cx
	jmp short discard_pkt

ok_2:
	push bx				; Put packet length into pkt_len vector
	mov bx, rcvr_index
	shl bx, 1
	les di, _pkt_len
	mov es:[di+bx], cx
	pop bx

	les di, _pkt_table		; Set pointer to buffer in ES:DI
	push ax
	mov ax, MAXETHERPKT
	mul rcvr_index
	add di, ax	
	pop ax

	jmp short done

discard_pkt:
	xor di, di		; Error - return 0:0 in ES:DI
	xor dx, dx		; (pkt driver will throw packet away ...)
	mov es, dx

done:
	pop dx
	pop ds
	ret

_receiver	ENDP
#else /* MSWINDOWS */

; ==============================================================================
; -- DPMI real mode callback
; -- ENTRY:
; --	DS:SI = real mode SS:SP
; --	ES:DI = real mode call structure
; -- EXIT:
; --	ES:DI = real mode call structure
; -- refer DPMI spec. V1.0 pp. 34-38
; ==============================================================================

; The callback function is passed a real mode register data structure.
; Fortunately most of the fields can be ignored. The important ones are:
;	ax	0 or 1, as per the Clarkson spec
;	cx	size of packet
;	es:di	buffer for the new packet
;	cs:ip	must be filled in with return address on stack
; Note that the data structure tends to use the full 32 bit registers EDI,
; EAX etc. The packet driver works in terms of 16 bits, so the extensions
; are irrelevant.
	
PUBLIC _receiver
_receiver PROC FAR

	; Install the return value in the RealModeRegs structure
	; See DPMI spec., example on page 38
	cld
	lodsw
	mov	es:[di.r_IP], ax
	lodsw
	mov	es:[di.r_CS], ax
	add	es:[di.r_SP], 4
	
	; Switch to default data segment to access I/O Server's statics
	mov	dx, DGROUP
	mov	ds, dx

	; Extract the AX and CX values from the structure
	mov	ax, es:[di.r_AX]
	mov	cx, es:[di.r_CX]
	cmp	ax,0
	je	assign_buffer

	; 2nd call from Clarkson driver, packet has been copied into buffer
	; increment index (with wrap around) and packet count
	inc	rcvr_index
	cmp	rcvr_index, MAX_PKT_TABLE
	jne	got_pkt
	mov	rcvr_index, 0
got_pkt:
	inc	_pkt_rcvd
	jmp	short done

	; 1st call, cx == packet length, return buffer pointer in es:di
assign_buffer:
	cmp	_pkt_rcvd, MAX_PKT_TABLE	; Check for buffer overflow
	je	short discard_pkt

	cmp	cx, MAXETHERPKT		; Check if packet will fit into buffer
	jle	ok_2
	mov	_pkt_too_long, cx
	jmp	short discard_pkt

ok_2:
	; pkt_len[rcvr_index] = size (cx)
	mov bx, rcvr_index
	shl bx, 1			; short -> byte indexing
	lds si, _pkt_len		; do not corrupt es:di !
	mov ds:[si+bx], cx
	mov dx, DGROUP			; instead use ds:si and restore ds
	mov ds, dx
	
	; set up ES:DI in the realregs structure
	; ES == segment of packet buffer (not selector!)
	; DI == correct offset
	mov	ax, _pkt_table_segment
	mov	es:[di.r_ES], ax
	mov	ax, MAXETHERPKT
	mul	rcvr_index
	mov	es:[di.r_DI], ax

	jmp short done

discard_pkt:
	xor	ax,ax
	mov	es:[di.r_ES], ax
	mov	es:[di.r_DI], ax

done:
	iret

_receiver	ENDP
#endif /* MSWINDOWS */


#endif /* Ether_supported */

CODE    ENDS

        END
 
@


1.19
log
@Some of the interrupt vector manipulation was unnecessary under Windows
and was causing problems.
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.18 1993/10/26 14:28:23 bart Exp $	--;
d82 24
d117 1
a117 2
EXTRN	_RS232_gotcha:FAR, _RS232_sendcha:FAR
EXTRN	_RS232_error:FAR, _RS232_modem:FAR
d175 8
a191 4
#if RS232_supported
PUBLIC _RS232_errno
_RS232_errno		DW	0
#endif
a237 53
#if RS232_supported
PUBLIC _Com1_base
_Com1_base		DW	0	; this table is filled in once I
Com2_base		DW	0	; know how many serial ports I have
Com3_base		DW	0
Com4_base		DW	0
Com5_base		DW	0
Com6_base		DW	0
Com7_base		DW	0
Com8_base		DW	0

	; Space to save the line control registers, baud rates, 
	; interrupt enable reg, and modem control register
Com1_LCR		DB	0,0,0,0,0
Com2_LCR		DB	0,0,0,0,0
Com3_LCR		DB	0,0,0,0,0
Com4_LCR		DB	0,0,0,0,0
Com5_LCR		DB	0,0,0,0,0
Com6_LCR		DB	0,0,0,0,0
Com7_LCR		DB	0,0,0,0,0
Com8_LCR		DB	0,0,0,0,0

	; Space to save the old interrupt vectors
Com1_seg		DW	0
Com1_off		DW	0
Com2_seg		DW	0
Com2_off		DW	0

	; And space to save the old 8259 interrupts mask
Mask_8259		DB	0

PUBLIC	_rs232_lsr,_rs232_iir,_rs232_ier,_rs232_lcr,_rs232_mcr
PUBLIC	_rs232_msr,_rs232_mask

_rs232_lsr	DW	0
_rs232_iir	DW	0
_rs232_ier	DW	0
_rs232_lcr	DW	0
_rs232_mcr	DW	0
_rs232_msr	DW	0
_rs232_mask	DW	0

#if (MSWINDOWS)
	; Under windows it is necessary to install a callback rather than
	; a normal interrupt handler
rs232_callback_seg	DW	0
rs232_callback_off	DW	0
rs232_callback_buf_seg	DW	0	; segment and selector for the
rs232_callback_buf_sel	DW	0	; real mode buffer
#endif

#endif

a887 4
; Functions called from the outside world
PUBLIC _RS232_enable_interrupts, _RS232_disable_interrupts
PUBLIC _RS232_setattrib, _RS232_setDTR, _RS232_setRTS
PUBLIC _RS232_writech, _rs232_check
d889 1
a889 4
; Manifests
; First, the 8250 UARTs
COM2_int		EQU	000BH	; interrupt vector for Com2
COM1_int		EQU	000CH	; and for Com1
d891 1
a891 10
tx_reg			EQU	0	; offsets for accessing a com port
rx_reg			EQU	0
baud_low		EQU	0
baud_high		EQU	1
interrupt_enable	EQU	1
interrupt_flags		EQU	2
line_control		EQU	3
modem_control		EQU	4
line_status		EQU	5
modem_status		EQU	6
d893 12
a904 9
; Flags in the line control register
DLAB			EQU	0080h	; Divisor Latch Access Bit
SetBreak		EQU	0040h	; Set_break bit
StickParity		EQU	0020h
EvenParity		EQU	0010h
ParityEnable		EQU	0008h
StopBits		EQU	0004h
WordLength1		EQU	0002h
WordLength0		EQU	0001h
d906 15
a920 9
; and the line status register
TSRE			EQU	0040h
THRE			EQU	0020h
BreakInterrupt		EQU	0010h
FramingError		EQU	0008h
ParityError		EQU	0004h
OverrunError		EQU	0002h
DataReady		EQU	0001h
LineError		EQU	BreakInterrupt+FramingError+ParityError+OverrunError
d922 3
a924 6
; and the interrupt enable register
ModemStatus		EQU	0008h
ReceiveLine		EQU	0004h
HoldingEmpty		EQU	0002h
DataAvailable		EQU	0001h
AllInterrupts		EQU	ModemStatus + ReceiveLine + HoldingEmpty + DataAvailable
d926 3
a928 145
; and the interrupt identification register
InterruptPending	EQU	0001h
LineState_int		EQU	0006h
DataReady_int		EQU	0004h
THREempty_int		EQU	0002h
ModemStatus_int		EQU	0000h

; and the modem control register
Loopx			EQU	0010h
Out2			EQU	0008h
Out1			EQU	0004h
RTS			EQU	0002h
DTR			EQU	0001h

; Then the interrupt controller
MASK8259		EQU	0021H	; the 8259 interrupt mask
CTRL8259		EQU	0020H	; the 8259 interrupt contrl

EOI			EQU	0020H	; 8259 end-of-interrupt command

RS232_MAX	EQU	7	; maximum number of rs232 ports supported


_rs232_check	PROC	FAR
	pushall
	xor	ax,ax
	mov	dx,03f9h
	in	al,dx
	mov	_rs232_ier,ax
	inc	dx
	in	al,dx
	mov	_rs232_iir,ax
	inc	dx
	in	al,dx
	mov	_rs232_lcr,ax
	inc	dx
	in	al,dx
	mov	_rs232_mcr,ax
	inc	dx
	in	al,dx
	mov	_rs232_lsr,ax
	inc	dx
	in	al,dx
	mov	_rs232_msr,ax
	in	al,MASK8259
	mov	_rs232_mask,ax

	popall
	ret
_rs232_check	ENDP
 
;============================================================================;
; void serial_interrupt(void)
;
; This is the interrupt handler for the serial port.
;============================================================================;

_serial_interrupt	PROC	FAR

	int_push

	mov	ax,DGROUP
	mov	ds,ax

	mov	cx,0		; check each valid port until I find the
int_loop:			; one that generated the interrupt
	mov	si,offset dgroup:_Com1_base
	add	si,cx
	add	si,cx
	mov	bx,0[si]	; extract the port address
	cmp	bx,0		; is it a valid port ?
	je	go_endloop

	mov	dx,interrupt_flags	; check the port's interrupt flags
	add	dx,bx
	mov	ah,0
	in	al,dx
	test	al,InterruptPending	; did this port generate the interrupt ?
	jne	go_endloop		; bit is clear if so

	cmp	ax,LineState_int
	jne	TryDataReady		; there is a line state error
	mov	dx,line_status		; get the line status register
	add	dx,bx
	in	al,dx
	push	cx			; save it

	push	ax			; second argument = LSR
	push	cx			; first argument is port identifier
	call	FAR PTR _RS232_error
	add	sp,4			; restore the stack

	pop	cx
	jmp	short int_loop		; and check the port again, just in case


TryDataReady:
	cmp	ax,DataReady_int
	jne	TryTHREempty
	mov	dx,line_status		; get hold of the line status
	add	dx,bx
	in	al,dx
	test	ax,DataReady		; is there really some data ?
	je	int_endloop		; obviously not
	mov	dx,rx_reg		; Yes, so get the data
	add	dx,bx
	in	al,dx
	push	cx

	push	ax			; the byte received
	push	cx			; the port identifier
	call	FAR PTR _RS232_gotcha
	add	sp,4

	pop	cx
GoBack:
	jmp	short int_loop

go_endloop:
	jmp	short int_endloop

TryTHREempty:
	cmp	ax,THREempty_int
	jne	TryModemStatus
	push	cx

	push	cx
	call	FAR PTR _RS232_sendcha
	add	sp,2

	pop	cx
	jmp	short int_loop

TryModemStatus:
	cmp	ax,ModemStatus_int
	jne	int_endloop		; no idea what it is
	mov	dx,modem_status		; extract the modem status register
	add	dx,bx
	in	al,dx
	push	cx

	push	ax
	push	cx
	call	FAR PTR _RS232_modem
	add	sp,4
d930 5
a934 2
	pop	cx
	jmp	int_loop
d936 3
a938 4
int_endloop:
	add	cx,1		; check the next port
	cmp	cx,RS232_MAX
	jne	GoBack
d940 6
a945 6
				; all the ports have now been checked
	mov	al,EOI		; tell the 8259 the interrupt has been handled
	out	CTRL8259,al

	int_pop
	sti
d947 1
a947 1
_serial_interrupt	ENDP
a948 51
;============================================================================;
; void RS232_enable_interrupts(int)
;
; Enable interrupts for Com1 and/or Com2 depending on the argument
;============================================================================;
_RS232_enable_interrupts PROC	FAR

	pushall

#if 1 || !(MSWINDOWS)
	mov	al,COM1_int	; fetch and save the old interrupt vectors
	mov	ah,035h
	int	21h
	mov	Com1_off,bx
	mov	bx,es
	mov	Com1_seg,bx
	mov	al,COM2_int
	mov	ah,035h
	int	21h
	mov	Com2_off,bx
	mov	bx,es
	mov	Com2_seg,bx

				; Now install my own interrupt vector
	mov	ax,arg1[bp]
	and	al,001h
	jz	try_com2

	push	ds
	mov	al,COM1_int	; interrupt vector for Com1
	mov	ah,025h		; function 25 - set interrupt vector
	mov	dx,seg _serial_interrupt
	mov	ds,dx
	mov	dx,offset _serial_interrupt
	int	21h
	pop	ds

try_com2:
	mov	ax,arg1[bp]
	and al,002h
	jz	 ints_done

	push	ds
	mov	al,COM2_int	; interrupt vector for Com2
	mov	ah,025h		; function 25 - set interrupt vector
	mov	dx,seg _serial_interrupt
	mov	ds,dx
	mov	dx,offset _serial_interrupt
	int	21h
	pop	ds

a949 2
	; Under Windows, all this is rather complicated. Everything has to
	; go via DPMI. For simplicity, errors are ignored
d951 5
a955 7
	; Step 1, save the interrupt vectors for com1_int and com2_int
	; These calls are guaranteed to succeed
	mov	ax,0200h
	mov	bl,COM1_int
	int	031h
	mov	Com1_off,dx
	mov	Com1_seg,cx
d957 3
a959 5
	mov	ax,0200h
	mov	bl,COM2_int
	int	031h
	mov	Com2_off,dx
	mov	Com2_seg,cx
d961 3
a963 10
	; Step 2, allocate a dos memory block for the callback
	xor	ax,ax
	push	ax
	mov	ax,032h
	push	ax
	call	GlobalDosAlloc
	cmp	ax,0
	jne	got_buffer
	popall		; (jumps out of distance problems... )
	ret
d965 5
a969 3
got_buffer:
	mov	rs232_callback_buf_seg, dx
	mov	rs232_callback_buf_sel, ax
d971 3
a973 12
	; Step 3, allocate a callback function
	mov	ax,0303h	; allocate real mode callback address
	mov	dx,rs232_callback_buf_sel
	mov	es,dx
	xor	di,di
	mov	dx,seg _serial_interrupt
	mov	ds,dx
	mov	si,offset _serial_interrupt
	int	031h
	jnc	got_callback
	popall
	ret
d975 3
a977 82
got_callback:
	mov	bx,DGROUP	; restore DGROUP
	mov	ds,bx
	mov	rs232_callback_seg,cx
	mov	rs232_callback_off,dx

	; Step 4, install the callback as the interrupt handler
	mov	ax,arg1[bp]
	and	al,001h
	jz	try_com2
	mov	ax,0201h
	mov	bl,COM1_int
	mov	cx,rs232_callback_seg
	mov	dx,rs232_callback_off
	int	031h

try_com2:
	mov	ax,arg1[bp]
	and	al,002h
	jz	ints_done
	mov	ax,0201h
	mov	bl,COM2_int
	mov	cx,rs232_callback_seg
	mov	dx,rs232_callback_off
	int	031h

#endif

ints_done:

	; For each connected com port, save the state of the line control
	; registers and the baud rates, set the modem control registers,
	; and enable interrupts
	mov	cx,0
enable_loop:
	mov	si,offset dgroup:_Com1_base
	add	si,cx		; get to the right entry in the table
	add	si,cx
	mov	bx,0[si]	; get the port address
	cmp	bx,0		; is it a known port ?
	je	enable_endloop
				; I have got a port at address [bx]
	mov	ax,cx		; find the address of the save table
	add	ax,ax		; ax = 2 * cx
	add	ax,ax	        ; ax = 4 * cx
	add	ax,cx		; ax = 5 * cx
	mov	si,offset dgroup:Com1_LCR
	add	si,ax

	mov	ax,0
	mov	dx,line_control	; fetch the line control register
	add	dx,bx
	in	al,dx
	mov	0[si],al	; and save it
	or	al,DLAB		; set the DLAB so that I can access baud rates
	out	dx,al
	mov	dx,baud_low	; now get the baud rates
	add	dx,bx
	in	al,dx
	mov	1[si],al
	mov	dx,baud_high
	add	dx,bx
	in	al,dx
	mov	2[si],al
	mov	dx,line_control	; restore the line control register
	add	dx,bx
	mov	al,0[si]
	and	al,07fh
	out	dx,al
	mov	dx,interrupt_enable	; and save the interrupt enable and
	add	dx,bx			; modem_control registers
	in	al,dx
	mov	3[si],al
	mov	dx,modem_control
	add	dx,bx
	in	al,dx
	mov	4[si],al

	mov	dx,modem_control	; Enable interrupts, but leave RTS
	add	dx,bx			; and DTR low
	mov	al,Out2
	out	dx,al
d979 4
a982 105
	mov	dx,interrupt_enable	; Enable all the interrupts
	add	dx,bx
	mov	al,AllInterrupts
	out	dx,al
	jmp	short enable_continue

enable_back:
	jmp	short enable_loop

enable_continue:
	mov	dx,rx_reg		; reset the interrupts
	add	dx,bx
	in	al,dx
	mov	dx,interrupt_flags
	add	dx,bx
	in	al,dx
	mov	dx,modem_status
	add	dx,bx
	in	al,dx
	mov	dx,line_status
	add	dx,bx
	in	al,dx

enable_endloop:
	add	cx,1		; try next port
	cmp	cx,RS232_MAX
	jne	enable_back

	mov	dx,MASK8259	; now enable the serial line interrupts
	in	al,dx
	mov	Mask_8259,al	; save it
	and	al,0E7h		; mask off IRQ4 and IRQ3
	out	dx,al
	mov	al,EOI
	out	CTRL8259,al

	popall
	ret

_RS232_enable_interrupts	ENDP

;============================================================================;
; void RS232_disable_interrupts
;
; This is called when the server exits
;============================================================================;
_RS232_disable_interrupts	PROC	FAR

	pushall

	mov	dx,MASK8259	; first disable the serial line interrupts
	mov	al,Mask_8259	; restore it
	out	dx,al

#if 1 || !(MSWINDOWS)
	push	ds
	mov	dx,Com1_off	; restore the old interrupt vectors
	mov	ax,Com1_seg
	mov	ds,ax
	mov	ah,025h
	mov	al,COM1_int
	int	21h
	pop	ds

	push	ds
	mov	dx,Com2_off
	mov	ax,Com2_seg
	mov	ds,ax
	mov	ah,025h
	mov	al,COM2_int
	int	21h
	pop	ds
#else
	; In a protected system, all this has to be done via DPMI calls
	; Step 1, restore the default interrupt handlers
	mov	ax,0201h
	mov	bl,COM1_int
	mov	cx,Com1_seg
	mov	dx,Com1_off
	int	031h

	mov	ax,0201h
	mov	bl,COM2_int
	mov	cx,Com2_seg
	mov	dx,Com2_off
	int	031h

	; Step 2, release the callback function and buffer. Note that
	; if either of these is NULL then the initialisation did not work,
	; and the chips have not been fiddled with.
	
	; If a callback buffer was allocated, release it
	mov	dx,rs232_callback_buf_sel
	cmp	dx,0
	je	disable_done
	push	dx
	call	GlobalDosFree

	; ditto for the callback function
	mov	cx,rs232_callback_seg
	cmp	cx,0
	je	disable_done
	mov	dx,rs232_callback_off
	mov	ax,0304h
	int	031h
a984 197
	mov	cx,0		; loop counter for restoring ports
disable_loop:
	mov	si,offset dgroup:_Com1_base
	add	si,cx		; get to right offset in table
	add	si,cx
	mov	bx,0[si]	; get the port
	cmp	bx,0		; is it valid ?
	je	disable_endloop

	mov	ax,cx		; get hold of the save table
	add	ax,ax					      
	add	ax,ax
	add	ax,cx
	mov	si,offset dgroup:Com1_LCR
	add	si,ax
	mov	al,DLAB		; set the baud rates, by forcing DLAB bit
	mov	dx,line_control	; in the line control register
	add	dx,bx
	out	dx,al
	mov	dx,baud_low	; first the low baud byte
	add	dx,bx
	mov	al,1[si]
	out	dx,al
	mov	dx,baud_high	; then the high baud byte
	add	dx,bx
	mov	al,2[si]
	out	dx,al
	mov	dx,line_control	; and restore the line control register
	add	dx,bx
	mov	al,0[si]
	out	dx,al
	mov	dx,interrupt_enable	; and the other registers
	add	dx,bx
	mov	al,3[si]
	out	dx,al
	mov	dx,modem_control
	add	dx,bx
	mov	al,4[si]
	out	dx,al

disable_endloop:
	add	cx,1		; try next port
	cmp	cx,RS232_MAX
	jne	disable_loop

disable_done:
	popall
	ret

	
_RS232_disable_interrupts	ENDP

;============================================================================;
; void RS232_setattrib(port, baud_high, baud_low, line_control)
;
; This sets the 8250's control registers
;============================================================================;
_RS232_setattrib	PROC	FAR

	pushall

	mov	bx,arg1[bp]	; extract the port
	add	bx,bx		; and turn it into the address via the table
	mov	si,offset dgroup:_Com1_base
	add	si,bx
	mov	bx,0[si]

	mov	dx,line_control	; set the DLAB so that I can fiddle the baud
	add	dx,bx		; rates
	mov	al,DLAB
	out	dx,al
	mov	dx,baud_high	; now set the baud rates
	add	dx,bx
	mov	al,arg2[bp]
	out	dx,al
	mov	dx,baud_low
	add	dx,bx
	mov	al,arg3[bp]
	out	dx,al
	mov	dx,line_control	; and finally the line control register
	add	dx,bx
	mov	al,arg4[bp]
	out	dx,al

	popall
	ret
_RS232_setattrib	ENDP


;============================================================================;
; void RS232_writech(int port, int ch)
;
; This moves the character given to the transmit register of the specified
; port
;============================================================================;
_RS232_writech		PROC	FAR

	pushall

	mov	bx,arg1[bp]	; extract the port
	add	bx,bx		; and turn it into the address via the table
	mov	si,offset dgroup:_Com1_base
	add	si,bx
	mov	bx,0[si]

	mov	dx,tx_reg	; get hold of the transmit register
	add	dx,bx
	mov	al,arg2[bp]	; and put the byte into it
	out	dx,al

	popall
	ret
_RS232_writech		ENDP


;============================================================================;
; int RS232_setDTR(int port, int MCR)
;
; This sets the modem control registers of the given port, and returns the
; modem status register
;============================================================================;
_RS232_setDTR	PROC	FAR

	pushall

	mov	bx,arg1[bp]	; extract the port
	add	bx,bx		; and turn it into the address via the table
	mov	si,offset dgroup:_Com1_base
	add	si,bx
	mov	bx,0[si]

	mov	dx,modem_control	; get hold of the MCR
	add	dx,bx
	in	al,dx	  	; get the current value
	mov	cl,arg2[bp]	; check the argument
	cmp	cl,0
	je	DTR_clear
	or	al,01h
	jmp	short DTR_write
DTR_clear:
	and	al,0fEh

DTR_write:
	or	al,Out2		; always leave Out2 high, to enable interrupts
	out	dx,al

	mov	dx,modem_status
	add	dx,bx
	xor	ax,ax
	in	al,dx
	
	popall
	ret

_RS232_setDTR	ENDP

;============================================================================;
; int RS232_setCTS(int port, int MCR)
;
; This sets the modem control registers of the given port, and returns the
; modem status register
;============================================================================;
_RS232_setRTS	PROC	FAR

	pushall

	mov	bx,arg1[bp]	; extract the port
	add	bx,bx		; and turn it into the address via the table
	mov	si,offset _Com1_base
	add	si,bx
	mov	bx,0[si]

	mov	dx,modem_control	; get hold of the MCR
	add	dx,bx
	in	al,dx	  	; get the current value
	mov	cl,arg2[bp]	; check the argument
	cmp	cl,0
	je	RTS_clear
	or	al,02h
	jmp	short RTS_write
RTS_clear:
	and	al,0fdh

RTS_write:
	or	al,Out2		; always leave Out2 high, to enable interrupts
	out	dx,al

	mov	dx,modem_status
	add	dx,bx
	xor	ax,ax
	in	al,dx
	
	popall
	ret

_RS232_setRTS	ENDP

a3499 23

RealModeRegs	STRUC
	r_DI		DW	0	; used to return buffer
	r_DI_E		DW	0	; not relevant
	r_ESI		DD	0	; not relevant
	r_EBP		DD	0	; not relevant
	r_RESERVED	DD	0	; reserved, should be zero
	r_EBX		DD	0	; not relevant
	r_EDX		DD	0	; not relevant
	r_CX		DW	0	; contains size
	r_CX_E		DW	0	; not relevant
	r_AX		DW	0	; 0 or 1, as per Clarkson spec
	r_AX_E		DW	0	; not relevant
	r_FLAGS		DW	0	; not relevant
	r_ES		DW	0	; used to return buffer
	r_DS		DW	0	; not relevant
	r_FS		DW	0	; not relevant
	r_GS		DW	0	; not relevant
	r_IP		DW	0	; update to simulate return
	r_CS		DW	0	; update to simulate return
	r_SP		DW	0	; update to simulate return
	r_SS		DW	0	; not relevant
RealModeRegs	ENDS
@


1.18
log
@It appears that, on some machines, an int21 call was corrupting the
ds register. Hence some updates of the static data area were failing.
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.17 1993/10/20 16:55:18 bart Exp $	--;
d321 1
d352 1
d385 1
a385 1
;	 on the screen
d388 2
a389 1
;     3) the print-screen interrupt, which could be very unpleasant
d409 1
d419 18
a469 8
	push	ds
	mov	ah,035h		; save the old interrupt vector for print
	mov	al,005h		; screen
	int	21h
	pop	ds
	push	ds
	mov	prtscrn_off,bx
	mov	prtscrn_seg,es
a470 9
	mov	ah,025h
	mov	al,005h		; interrupt vector for print screen
	mov	dx,seg	_dummy_interrupt
	mov	ds,dx
	mov	dx,offset _dummy_interrupt
	int	21h

	pop	ds

d496 1
d505 1
@


1.17
log
@Fixed a bug which stopped the new ethernet code working in Windows
standard mode.
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.16 1993/10/13 17:42:36 bart Exp $	--;
d396 2
d402 2
a405 2
	push	ds		; save the default data segment

d418 2
d435 2
d452 2
@


1.16
log
@1) the Windows DPMI callback has been rewritten in assembler to
   avoid possible problems with the C compiler.
2) various jumps have been converted to short jumps to eliminate
   warnings generated by the assembler
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.15 1993/09/29 11:14:02 bart Exp $	--;
d4149 1
a4149 1
	; Extract the AX value from the structure
d4151 1
@


1.15
log
@Cleaned up the ethernet support code, to try and get it working
properly under Windows
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.14 1993/03/10 15:33:53 bart Exp $	--;
a105 4
#if (Ether_supported && MSWINDOWS)
EXTRN	_DPMI_callback:FAR
#endif

d116 1
a116 1
#if (Ether_supported && !MSWINDOWS)
a118 1
EXTRN	_pkt_table	: DWORD	; packet buffer vector
d121 6
d523 1
a523 1
	jmp	endx
d1040 1
a1040 1
	jmp	int_loop		; and check the port again, just in case
d1063 1
a1063 1
	jmp	int_loop
d1066 1
a1066 1
	jmp	int_endloop
d1078 1
a1078 1
	jmp	int_loop
d1294 1
a1294 1
	jmp	enable_continue
d1297 1
a1297 1
	jmp	enable_loop
d1535 1
a1535 1
	jmp	DTR_write
d1576 1
a1576 1
	jmp	RTS_write
d1619 1
a1619 1
	jmp	readdone
d1637 1
a1637 1
	jmp	readdone
d1678 1
a1678 1
	jmp	writedone
d1694 1
a1694 1
	jmp	write_error
d1703 1
a1703 1
	jmp	writedone
d1890 1
a1890 1
        jmp     cocoenter                   ; loop forever
d2351 1
a2351 1
        jmp     l3
d2387 1
a2387 1
        jmp     dl3
d2436 1
a2436 1
        jmp     l6
d2476 1
a2476 1
        jmp     dl6
d2528 1
a2528 1
        jmp     l12notime
d2554 1
a2554 1
	jmp	l12
a2563 1
        jmp     l12
d2600 1
a2600 1
        jmp     dl10
d2652 1
a2652 1
        jmp     l18
d2673 1
a2673 1
	jmp	l18
d2712 1
a2712 1
        jmp     dl16
d2814 1
a2814 1
	jmp	dos_link_exit
d3255 1
a3255 1
	jmp     t40l6
d3299 1
a3299 1
	jmp     t40l3
d3344 1
a3344 1
	jmp     t40l18
d3365 1
a3365 1
	jmp	t40l18
d3413 1
a3413 1
	jmp     t40l12notime
d3439 1
a3439 1
	jmp	t40l12
a3448 1
	jmp     t40l12
d3575 1
a3575 1
	jmp	hunt_read_fail
d3648 1
a3648 1
	jmp	hunt_write_fail
d3787 1
a3787 1
	jmp	tdbl15			; ignore initial timeout - we have
d3804 1
a3804 1
	jmp     tdbl18
d3852 1
a3852 1
	jmp	tdbl18
d3857 1
a3857 1
	jmp	tdbl18			; fail
d3909 1
a3909 1
	jmp     tdbl12notime
d3938 1
a3938 1
	jmp	tdbl12
a3990 5

PUBLIC _receiver

_receiver PROC FAR

d4012 2
d4017 2
a4018 2
#define MAXETHERPKT		1514		/* maximum size of packet */
#define MAX_PKT_TABLE		8		/* size of buffer table   */
d4087 1
d4100 81
a4180 3
	push ds
	push dx
	mov dx, DGROUP	; default data segment
d4182 9
d4192 8
a4199 9
	push es	
	push di
	push si
	call FAR PTR _DPMI_callback
	pop si
	pop di
	pop es
	pop dx
	pop ds
d4202 1
a4204 1
_receiver	ENDP
@


1.14
log
@The spirit40 support has been moved to a separate module because it
needed the .286 option, which I did not want in the standard assembler
file.
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.13 1993/02/03 11:40:11 nick Exp $	--;
d106 1
a106 6
#if Ether_supported
#if OLD_ETHER
EXTRN	_ether_something:FAR
#else
#include "etherdef.h"
#if MSWINDOWS
a107 1
#endif /* MSWINDOWS */
a108 1
#endif
d120 1
a120 3
#if Ether_supported
#if (!OLD_ETHER && !MSWINDOWS)
	; data declared in esupport.c
a124 3
#ifdef ETHER_DEBUG
EXTRN	_pkt_overflow	: WORD	; error flag
#endif /* ETHER_DEBUG */
a128 1
#endif /* (!OLD_ETHER && !MSWINDOWS) */
a3991 8
#if OLD_ETHER
;==============================================================================
;   Ethernet support
;==============================================================================
 
; External functions called
PUBLIC _set_einterrupts, _restore_einterrupts
; And public variables
a3992 67

ether_off	DW	0	; to save the system interrupt vectors
ether_seg	DW	0


;=============================================================================;
; void set_einterrupts(void)
;
; Set ethernet interrupt
;
; void restore_einterrupts(void)
;
; undo the damage done by set_interrupts
;=============================================================================;

_set_einterrupts PROC FAR
	pushall

	mov	ax,arg1[BP]	; get interrupt level
	mov	ah,035h		; save the old interrupt vector for divide by
	int	21h
	mov	cs:ether_off,bx
	mov	cs:ether_seg,es

	mov	ax,arg1[BP]	; get interrupt level
	mov	ah,025h		; install my own interrupt vector

 	mov	dx,seg	ether_int
	mov	ds,dx
	mov	dx,offset ether_int
	int	21h

	popall
	ret

_set_einterrupts ENDP

_restore_einterrupts	PROC	FAR
	pushall

	mov	ax,arg1[BP];
	mov	ah,025H
	mov	dx,cs:ether_seg
	mov	ds,dx
	mov	dx,cs:ether_off
	int	21h

	popall
	
	ret
_restore_einterrupts	ENDP


ether_int		PROC	FAR
	int_push

	mov	dx,DGROUP	; restore the data segment
	mov	ds,dx

	call	FAR PTR _ether_something	; process and buffer the key

	int_pop
	iret
ether_int		ENDP

#else /* !OLD_ETHER */

a4017 8
; Warning - this is my first hack at MicroSoft Assembler. Treat this code with
; some suspicion. I have adopted the Microsoft conventions regarding segment
; names (_DATA) and the GROUP directive (DGROUP). For more information on these
; conventions, refer to Advanced MSDOS Programming (2nd Ed. 1988), pp 39-40 and
; the MS-DOS Encyclopedia (1988), pp. 718-721. Some information pertaining to
; the use of EXTRN can be found in 8086-8088 Architecture & Programming (1985),
; pp. 34-35, pp. 75-77.
; ------------------------------------------------------------------------------
d4019 5
a4023 3
;	======================================================================
;	Save registers
;	======================================================================
d4026 1
a4026 5

;	======================================================================
;	Get default data segment
;	======================================================================
	mov dx, DGROUP
d4029 5
a4033 7
#if !MSWINDOWS

;	======================================================================
;	Which call is this ? If 1st (AX == 0), return pointer to buffer in
;	ES:DI. If second (AX == 1), the packet has been copied into the 
;	buffer
;	======================================================================
d4037 5
a4041 8
;	======================================================================
;	2nd call (AX == 1)
;	Packet has been copied into buffer
;	======================================================================

;	======================================================================
;	Increment index (with wrap around) and packet count
;	======================================================================
d4050 5
a4054 6
;	======================================================================
;	1st call (AX == 0)
;	Enter with CX == packet length
;	Return pointer to buffer in ES:DI
;	======================================================================

d4056 2
d4059 1
a4059 15
;	======================================================================
;	Check for buffer overflow
;	======================================================================
	cmp _pkt_rcvd, MAX_PKT_TABLE
	jne ok_1
#ifdef ETHER_DEBUG
	mov _pkt_overflow, 1
#endif /* ETHER_DEBUG */
	jmp short discard_pkt

ok_1:
;	======================================================================
;	Check if packet will fit into buffer
;	======================================================================
	cmp cx, MAXETHERPKT
d4065 1
a4065 4
;	======================================================================
;	Put packet length into pkt_len vector
;	======================================================================
	push bx
d4072 1
a4072 4
;	======================================================================
;	Set pointer to buffer in ES:DI
;	======================================================================
	les di, _pkt_table
a4080 4
;	======================================================================
;	Error - return 0:0 in ES:DI
;	(pkt driver will throw packet away ...)
;	======================================================================
d4082 2
a4083 2
	xor di, di
	xor dx, dx
a4085 3
;	======================================================================
;	Restore registers and return
;	======================================================================
d4103 5
a4122 1
#endif /* !OLD_ETHER */
@


1.13
log
@Assembler upload and download functions added for SPIRIT40 board.
These require at least a 286 to work, so a .286 directive has been
added. All of this is protected by SPIRIT40 conditionals.
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.12 1992/08/10 14:12:15 bart Exp $	--;
a20 4
#ifdef SPIRIT40
.286
#endif

a4002 126
#ifdef SPIRIT40
;
;       ----------------------------------------------
;                      asm_dl_data
;       ----------------------------------------------
;       Calling sequence from 'C' source:
;
;       asm_dl_data(DATA PORT ADDRESS, COUNT, ARRAY)
;
;          unsigned   DATA PORT ADDRESS
;          unsigned   COUNT
;          long      *ARRAY
;       ----------------------------------------------
;
;       [BP+8]   =   DATA PORT ADDRESS
;       [BP+10]  =   COUNT : No of 16 bit data to download.
;       [BP+12]  =   ARRAY offset
;       [BP+14]  =   ARRAY segment
;
;
	PUBLIC  _asm_dl_data

;
_asm_dl_data    PROC   FAR
;
; --------------- save registers on stack ---------------
;
        PUSH    BP              ;; save BP 
        PUSH    DS              ;; save DS
        MOV     BP,SP           ;; point BP at top of stack
                                ;   [BP+0] = old DS
                                ;   [BP+2] = old BP
                                ;   [BP+4] = offset of return address
                                ;   [BP+6] = segment of return address
        PUSH    SI              ;; save SI
        PUSH    DX              ;; save DX
;
; --- get DATA PORT ADDRESS, COUNT and ARRAY address -------------
;
        MOV     DX,[BP+8]       ;; data port address of SPIRIT-40 port.
        MOV     CX,[BP+10]      ;; get count from the stack 
        OR      CX,CX           ;;
;
        JZ      DLLONG_OVER     ;;
        MOV     BX,[BP+14]      ;; get array segment address 
        MOV     DS,BX           ;; load it in DS
        MOV     SI,[BP+12]      ;; get array offset address

        CLD                     ;; set direction flag for auto 
                                ;   increment of index register
;
; --- do continuous write ---------------------------------------
;
        REP     OUTSW           ;; continuous write of COUNT words
;
; ------------- restore saved registers from stack -------------
;
DLLONG_OVER:
        POP     DX              ;; restore DX
        POP     SI              ;; restore SI
        POP     DS              ;; restore DS
        POP     BP              ;; restore BP
        RET                     ;; return
;
_asm_dl_data      ENDP
;
; ****************** end of asm_dl_data() *******************
;
;
;       ----------------------------------------------
;                      asm_ul_data
;       ----------------------------------------------
;       Calling sequence from 'C' source:
;
;       asm_ul_data(DATA PORT ADDRESS, COUNT, ARRAY)
;
;          unsigned   DATA PORT ADDRESS
;          unsigned   COUNT
;          long      *ARRAY
;       ----------------------------------------------
;       stack structure same as asm_dl_data()
;
	PUBLIC  _asm_ul_data
;
_asm_ul_data     PROC  FAR
;
; --------------- save registers on stack ---------------
;
        PUSH    BP              ;; save BP 
        PUSH    ES              ;; save ES
        MOV     BP,SP           ;; point BP at top of stack
        PUSH    DI              ;; save DI
        PUSH    DX              ;; save DX
;
; ---- GET DATA PORT ADDRESS, COUNT and ARRAY address -------------
;
        MOV     DX,[BP+8]       ;; get data port address.
        MOV     CX,[BP+10]      ;; get count from the stack 
        OR      CX,CX           ;;
;
        JZ      ULLONG_OVER     ;;
        MOV     BX,[BP+14]      ;; get array segment address 
        MOV     ES,BX           ;; load it in ES
        MOV     DI,[BP+12]      ;; get array offset address
;
        CLD                     ;; set direction flag for auto 
                                ;; increment of index register
;
; --- do continuous read -------
;
        REP     INSW           ;; continuous read of COUNT words
;
; ------------- restore saved registers from stack -------------
;
ULLONG_OVER:
        POP     DX              ;; restore DX
        POP     DI              ;; restore DI
        POP     ES              ;; restore ES
        POP     BP              ;; restore BP
        RET                     ;; return
;
_asm_ul_data      ENDP
;
; ****************** end of asm_ul_data() *******************

#endif
@


1.12
log
@Optimised the stack copying code to only copy the bits of the stack that
are in use, rather than the entire stack.
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.10 1992/07/20 14:14:02 paul Exp $	--;
d21 4
d1887 1
a1887 1
enter:  call    FAR PTR _WaitCo         ; Waitco back to parent
d1906 1
a1906 1
        jmp     enter                   ; loop forever
d4007 126
@


1.11
log
@patches to compile under Microsoft C 7.0
@
text
@d1860 1
a1860 1
        mov     co_sp[si+2],ss	; coroutine
d1932 2
a1933 2
	mov	cx,co_size[si]	; get size from CurrentCo
	les	di,co_base[si]	; and stack base into es:di
d1937 7
d2050 7
a2068 24
; Arg = WaitCo( arg)
; long arg;
;
; Returns control back to the parent with required argument/return code in ax.
; Arg will eventually be returned when the coroutine doing the WaitCo is called
; again with CallCo_(coroutine,ARG)
;==============================================================================
_WaitCo PROC FAR
        push    bp
        mov     bp,sp
        push    ds
	push	di
	push	si
 
	lds     si,DWORD PTR _CurrentCo ; si = current coroutine
        les     di,co_parent[si]        ; es:di = parent coroutine
 
        mov     ax,arg1[bp]             ;
        mov     dx,arg2[bp]             ; ax/bx = argument
 
        jmp     coenter
_WaitCo ENDP

;==============================================================================
d2094 24
@


1.10
log
@fixed for non word multiple reads on transtec board
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.9 1992/06/19 10:07:53 bart Exp $	--;
a105 2
EXTRN   STKHQQ:WORD

d152 1
a152 1
#if (MSWINDOWS)
d158 1
a162 1
#endif
d1756 3
a1856 2
		; In Windows it may be necessary to save the stack
#if MSWINDOWS
d1858 1
a1858 1
#endif
d1867 1
a1867 11
		; For non-Windows coroutines, es:(di + cx) should be the
		; top of the stack.
#if (!MSWINDOWS)
	add	cx,di			; go to top of stack
	cli				; disable interrupts
        mov     ss,_CurrentCo+2	; new coroutine segment
        mov     sp,cx                   ; offset of end of area
	sti				; reenable
#else
		; For Windows, the coroutine base address is determined
		; by _coroutine_buf
a1874 1
#endif
a1904 1
#if (MSWINDOWS)
a1948 2
#endif
  
a1986 2
		; For Windows, save the current stack
#if (MSWINDOWS)
a1987 1
#endif
a2013 1
#if (MSWINDOWS)
d2045 1
a2045 1
#endif
a2155 2
	mov	STKHQQ,0		; This allows the C library to work
					; somehow...
@


1.9
log
@Major upgrade for V3.91 :
 1) C40 support
 2) now compiles under Windows
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.8 1992/06/18 19:49:00 craig Exp $	--;
d321 2
a2239 3
; @@@@@@ if 'in' instruction sets the flags then we can optimise for TIM40 in
; read/write_block by jumping on flag directly without first masking.
;
d2255 1
a2255 10
; interchangebly with it. The board has a design problem in that it only has
; 16 bit latches. This means that if the C40 asynchronously sends a word
; during a PC write, that it will grab the token send 2 bytes and then
; hang the interface until that word is read. The Helios half duplex protocol
; guarantees that only one word will be sent before the PC signals that it
; is ready to receive a full message. To get around this problem, if we ever
; timeout on a write, we immediately try to read a word of data and then
; attempt to continue writing. The read ready and read routines always
; check the buffer we stored the word away in before checking the link
; directly.
d3688 7
a3694 1
; directly.
a3736 3
; *Warning*: This function assumes that transfer requests will always be for
; an even number of bytes.
;
d3751 29
d3789 6
d3828 1
d3831 7
a3837 1
	les     di,arg2[bp]             ; the buffer to write
d3842 1
a3842 1
	mov     dx,_link_in_status   ; check link in status
d3853 19
d3874 5
@


1.8
log
@Minor change (duplicated comment)
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.7 1992/05/04 19:24:41 craig Exp craig $ --;
d17 3
d23 2
a24 1
; options.
a30 1

d39 1
a39 1
;    And some macros mainly for debugging
d83 2
a84 2
; Externals are declared outside the code segment, as recommended in the link
; documentation. This avoids fixup overflow errors.
d86 1
a86 1
#if mouse_supported
d95 2
a97 4
#if Ether_supported
#ifdef OLD_ETHER
EXTRN	_ether_something:FAR
#endif /* OLD_ETHER */
d99 5
a103 1
#if  use_own_memory_management
d105 1
a105 1
#endif
d108 4
a111 10

#ifndef OLD_ETHER
; ==============================================================================
; -- Support for Clarkson Packet Drivers
; -- crf: May 1992
; ==============================================================================
; Receiver Subroutine
; ===================
; Refer to notes given with PROC _receiver.

d113 5
d119 5
a123 1
DGROUP	group _DATA
d125 3
a127 2
_DATA	SEGMENT WORD PUBLIC 'DATA'
	ASSUME ds:_DATA
d129 3
a131 1
; data declared in esupport.c
d140 2
a141 2
; local data
rcvr_index	dw 0		; index into packet buffer
d143 2
a144 1
_DATA	ENDS
d146 19
a164 1
#endif /* !OLD_ETHER */
d166 2
d169 2
a170 20
CODE    SEGMENT WORD public 'CODE'
        ASSUME cs:CODE

;==============================================================================
; Storage for the default data segment register, which I must set in my
; interrupt routines. Also, an integer to hold the MSdos version number
;==============================================================================
PUBLIC _version_number

data_segment	DW	0
_version_number	DW	0
		
;==============================================================================
;   The simple interrupt-handling stuff
;==============================================================================
  
; External functions called
PUBLIC _set_interrupts, _restore_interrupts
; And public variables

d188 3
a190 1
zero_off	DW	0	; to save the system interrupt vectors
d197 127
d325 9
d349 7
a355 1
	mov	cs:_floppy_errno,ax
d404 1
a404 1

a407 3
	mov	ax,ds		; store the default data segment
	mov	cs:data_segment,ax

d412 1
a412 1
	mov	cs:_version_number,ax
d414 2
d423 2
d428 2
a429 2
	mov	cs:zero_off,bx
	mov	cs:zero_seg,es
d438 2
d443 2
a444 2
	mov	cs:overflow_off,bx
	mov	cs:overflow_seg,es
d453 2
d458 2
a459 2
	mov	cs:prtscrn_off,bx
	mov	cs:prtscrn_seg,es
d468 2
d478 4
a483 3
	mov	dx,cs:zero_seg
	mov	ds,dx
	mov	dx,cs:zero_off
d486 5
a492 3
	mov	dx,cs:overflow_seg
	mov	ds,dx
	mov	dx,cs:overflow_off
d495 5
a501 3
	mov	dx,cs:prtscrn_seg
	mov	ds,dx
	mov	dx,cs:prtscrn_off
d504 1
d548 1
a548 1
#if mouse_supported
d621 1
a621 1
	mov	ax,cs:data_segment
a637 2
seg_keyint	DW	0
off_keyint	DW	0
d644 2
a645 2
	mov	cs:seg_keyint,es
	mov	cs:off_keyint,bx
d647 3
a650 3
	mov	dx,seg keyboard_int
	mov	ds,dx
	mov	dx,offset keyboard_int
d660 3
a662 3
	mov	dx,cs:seg_keyint	; restore the old interrupt vector
	mov	ds,dx
	mov	dx,cs:off_keyint
d679 1
a679 1
	mov	dx,cs:data_segment	; restore the data segment
d684 1
a684 1
	push	ax	; put code on stack for C routine
d701 1
a727 1
PUBLIC _vbios_attr
a728 4
_vbios_x	DB	0
_vbios_y	DB	0
video_mode	DB	0
_vbios_attr	DB	default_attr
d749 1
a749 1
	mov	bh,cs:_vbios_attr
d757 2
a758 2
	mov	cs:_vbios_x,dl
	mov	cs:_vbios_y,dh
d771 2
a772 2
	mov	cs:_vbios_x,dl
	mov	cs:_vbios_y,dh
d788 1
a788 1
	mov	bl,cs:_vbios_attr
d791 1
a791 1
	mov	dl,cs:_vbios_x
d795 2
a796 2
	mov	cs:_vbios_x, dl
	mov	dh,cs:_vbios_y
d812 1
a812 1
	mov	bh,cs:_vbios_attr
d832 2
a838 1
; junk for GEM
d840 2
a841 13
PUBLIC _mouse_x, _mouse_y, _button_state ; external variables for GEM
PUBLIC _mouse_changed, _button_changed, _cursor_changed
PUBLIC _syscursor
;
; Here is some storage for the above variables, with default values
_syscursor	DD 0
_mouse_x	DW 0
_mouse_y	DW 0
_button_state	DW 0
_mouse_changed	DW 0
_button_changed	DW 0
_cursor_changed	DW 0
 
d843 9
a851 4

	mov cs:_mouse_x,bx
	mov cs:_mouse_y,cx
	mov cs:_mouse_changed, 1
a852 1

d856 8
a863 3

	mov	cs:_button_state,ax
	mov	cs:_button_changed,1
a864 1

a867 1

d869 5
a873 5
	
	mov	cs:_mouse_x,bx
	mov	cs:_mouse_y,cx
	mov	cs:_cursor_changed,1
 
d875 1
a875 2
	call cs:_syscursor[si]

a877 1

d885 1
a885 1
;-- Activate trap 0x60, with the mcb in ds:dx. It should                    --;
a893 1

a894 1

a897 1
       
a898 1

a900 1

d914 1
a914 1
PUBLIC _RS232_writech
a980 11
; External variables, may be set by the outside world
PUBLIC _RS232Base_vec
_RS232Base_vec:
Com1_base		DW	0	; this table is filled in once I
Com2_base		DW	0	; know how many serial ports I have
Com3_base		DW	0
Com4_base		DW	0
Com5_base		DW	0
Com6_base		DW	0
Com7_base		DW	0
Com8_base		DW	0
a981 32
; Space to save the line control registers, baud rates, interrupt enable reg,
; and modem control register
ComLCR:
Com1_LCR		DB	0,0,0,0,0
Com2_LCR		DB	0,0,0,0,0
Com3_LCR		DB	0,0,0,0,0
Com4_LCR		DB	0,0,0,0,0
Com5_LCR		DB	0,0,0,0,0
Com6_LCR		DB	0,0,0,0,0
Com7_LCR		DB	0,0,0,0,0
Com8_LCR		DB	0,0,0,0,0

; Space to save the old interrupt vectors
Com1_seg		DW	0
Com1_off		DW	0
Com2_seg		DW	0
Com2_off		DW	0

; And space to save the old 8259 interrupts mask
Mask_8259		DB	0

PUBLIC	_rs232_check,_rs232_lsr,_rs232_iir,_rs232_ier,_rs232_lcr,_rs232_mcr
PUBLIC	_rs232_msr,_rs232_mask

_rs232_lsr	DW	0
_rs232_iir	DW	0
_rs232_ier	DW	0
_rs232_lcr	DW	0
_rs232_mcr	DW	0
_rs232_msr	DW	0
_rs232_mask	DW	0

a982 1

a983 1

d987 1
a987 1
	mov	cs:_rs232_ier,ax
d990 1
a990 1
	mov	cs:_rs232_iir,ax
d993 1
a993 1
	mov	cs:_rs232_lcr,ax
d996 1
a996 1
	mov	cs:_rs232_mcr,ax
d999 1
a999 1
	mov	cs:_rs232_lsr,ax
d1002 1
a1002 1
	mov	cs:_rs232_msr,ax
d1004 1
a1004 1
	mov	cs:_rs232_mask,ax
a1007 1

d1020 1
a1020 1
	mov	ax,cs:data_segment
d1025 1
a1025 1
	mov	si,offset _RS232Base_Vec
d1028 1
a1028 1
	mov	bx,cs:0[si]	; extract the port address
d1131 1
d1135 1
a1135 1
	mov	cs:Com1_off,bx
d1137 1
a1137 1
	mov	cs:Com1_seg,bx
d1141 1
a1141 1
	mov	cs:Com2_off,bx
d1143 1
a1143 1
	mov	cs:Com2_seg,bx
d1148 1
a1148 1
 jz  try_com2
d1150 1
d1157 1
d1164 1
d1171 1
d1173 74
d1254 1
a1254 1
	mov	si,offset _RS232Base_vec
d1257 1
a1257 1
	mov	bx,cs:0[si]	; get the port address
d1265 1
a1265 1
	mov	si,offset ComLCR
d1272 1
a1272 1
	mov	cs:0[si],al	; and save it
d1278 1
a1278 1
	mov	cs:1[si],al
d1282 1
a1282 1
	mov	cs:2[si],al
d1285 1
a1285 1
	mov	al,cs:0[si]
d1291 1
a1291 1
	mov	cs:3[si],al
d1295 1
a1295 1
	mov	cs:4[si],al
d1332 1
a1332 1
	mov	cs:Mask_8259,al	; save it
d1356 5
a1360 3
	mov	dx,cs:Com1_seg	; restore the old interrupt vectors
	mov	ds,dx
	mov	dx,cs:Com1_off
d1364 6
a1369 3
	mov	dx,cs:Com2_seg
	mov	ds,dx
	mov	dx,cs:Com2_off
d1373 9
d1383 26
d1411 1
a1411 1
	mov	si,offset _RS232Base_vec
d1414 1
a1414 1
	mov	bx,cs:0[si]	; get the port
d1422 1
a1422 1
	mov	si,offset ComLCR
d1430 1
a1430 1
	mov	al,cs:1[si]
d1434 1
a1434 1
	mov	al,cs:2[si]
d1438 1
a1438 1
	mov	al,cs:0[si]
d1442 1
a1442 1
	mov	al,cs:3[si]
d1446 1
a1446 1
	mov	al,cs:4[si]
d1454 1
d1472 1
a1472 1
	mov	si,offset _RS232Base_vec
d1474 1
a1474 1
	mov	bx,cs:0[si]
d1510 1
a1510 1
	mov	si,offset _RS232Base_vec
d1512 1
a1512 1
	mov	bx,cs:0[si]
d1536 1
a1536 1
	mov	si,offset _RS232Base_vec
d1538 1
a1538 1
	mov	bx,cs:0[si]
d1577 1
a1577 1
	mov	si,offset _RS232Base_vec
d1579 1
a1579 1
	mov	bx,cs:0[si]
a1623 2
transfer_buffer	DB	0,0,0,0,0,0,0,0,0,0	; 10 byte buffer

d1634 1
a1634 1
	mov	bx,cs:_version_number
d1653 1
a1653 1
	mov	bx,cs
d1655 1
a1655 1
	mov	si,offset transfer_buffer
d1657 1
a1657 1
	mov	ds:[si],bx
d1659 1
a1659 1
	mov	ds:[si+2],bx
d1661 1
a1661 1
	mov	ds:[si+4],bx
d1663 1
a1663 1
	mov	ds:[si+6],bx
d1665 2
a1666 2
	mov	ds:[si+8],bx
	mov	bx,si		; ds:bx now contains structure
d1693 1
a1693 1
	mov	bx,cs:_version_number
d1719 1
a1719 1
	mov	bx,cs
d1721 1
a1721 1
	mov	si,offset transfer_buffer
d1723 1
a1723 1
	mov	ds:[si],bx
d1725 1
a1725 1
	mov	ds:[si+2],bx
d1727 1
a1727 1
	mov	ds:[si+4],bx
d1729 1
a1729 1
	mov	ds:[si+6],bx
d1731 2
a1732 2
	mov	ds:[si+8],bx
	mov	bx,si		; ds:bx now contains structure
d1747 18
a1764 10
;-----------------------------------------------------------------------------;
;--                                                                         --;
;-- MODULE NAME: COLIB.ASM                                                  --;
;-- ENTRY POINTS:                                                           --;
;--              InitCo_, CreateCo_,Callco_, WaitCo_, DeleteCo_, ResumeCo_  --;
;--                                                                         --;
;-- AUTHOR : C.Grimsdale                                                    --;
;-- DATE : 29/11/87                                                         --;
;-- UPDATES:                                                                --;
;-----------------------------------------------------------------------------;
a1766 12
; PUBLIC _ResumeCo
PUBLIC  _CurrentCo
 
 
; Define local Data  N.B IT IS SUPPOSED TO BE IN THE CODE SEGMENT
; -----------------
 
_CurrentCo       DW 0    ; current coroutine
                 DW 0
func             DW 0	 ; to store function addresses during coroutine switch
		 DW 0

d1770 1
d1776 2
a1777 2
;   All longwords are saved as offset:segment
;   It is assumed that all pointers are long pointers.
d1780 6
a1785 5
co_parent       EQU 4
co_func         EQU 8
co_size         EQU 12
co_magic        EQU 14
co_SIZEOF       EQU 16
a1798 1
 
a1803 1
        push    ss
d1809 1
a1809 1
        call    _get_mem               ; get required amount of stack
d1811 1
d1815 9
a1823 3
        test    dx,-1                   ; NULL ptr ?
        je      createfail              ; YES -> failed
 
d1828 4
a1831 3
        mov     di,ax                   ; new coroutine address
        lds     si,DWORD PTR cs:_CurrentCo
                                        ; current coroutine
d1833 6
a1838 2
        mov     es:co_size[di],cx       ; size of coroutine
 
d1844 1
a1844 1
 
d1850 10
a1859 2
        mov     cs:_CurrentCo,di
        mov     cs:_CurrentCo+2,es       ; make new coroutine current
d1861 4
a1864 7
        mov     ds:co_sp[si],sp
        mov     ds:co_sp[si+2],ss          ; save current sp
 
        mov     ds,bx                   ; restore ds
 
	add	cx,di
	sub	cx,co_SIZEOF            ; leave some space
d1866 4
d1871 1
a1871 1
        mov     ss,cs:_CurrentCo+2      ; new coroutine segment
d1874 18
a1892 3
        push    es                      ; new coroutine segment
        push    di                      ; new coroutine offset
 
d1896 6
d1903 3
a1905 3
        push    ax
        les     di,DWORD PTR cs:_CurrentCo
                                        ; setup data segment
d1907 1
a1907 1
	mov	cs:func,dx
d1909 3
a1911 3
	mov	cs:func+2,dx		; into CS memory
	lea	bx,cs:func
	call    DWORD PTR cs:[bx]
d1913 1
d1915 39
a1953 2
createfail:
	pop	ss
d1956 1
d1958 5
a1962 7
	pop	bp 
        ret
 
_CreateCo ENDP
 
 
 
a1975 1
        push    ss
d1977 3
a1979 5
        les     di,arg1[bp]               ; new coroutine
 
        lds     si,DWORD PTR cs:_CurrentCo

                                       ; current coroutine
a1982 1

d1986 4
a1989 4
; At this point we assume
; ds:si = parent coroutine
; es:di = daughter coroutine
; dx:ax = argument
d1992 1
a1992 1
	mov	ax,ds:co_magic[si]	; on current and new coroutine
d2000 4
a2003 2
        mov     co_sp[si],sp
        mov     co_sp[si+2],ss          ; save current coroutine stack
d2005 3
d2012 17
d2030 27
a2056 4
        mov     cs:_CurrentCo,di         ; update current coroutine
        mov     cs:_CurrentCo+2,es
 
        pop     ss
d2059 6
d2066 2
a2067 4
        pop     bp                      ; restore registers of daughter
 
        ret                             ; enter daughter
 
d2077 1
a2077 1
; again with CallCo_(coroutine,ARG) or ResumeCo_(coroutine,ARG).
a2084 1
        push    ss
d2086 1
a2086 2

        lds     si,DWORD PTR cs:_CurrentCo ; ds:si = current coroutine
a2092 1
 
a2093 2
 
 
d2132 2
a2133 1
        mov     cx,arg2[bp]
a2161 1
 
d2170 5
a2174 3
        push    ds
	push	si
	mov	STKHQQ,0
d2177 1
a2177 1
        call    _get_mem               ; get required amount of stack
d2179 1
a2179 1
        test    ax,-1                   ; NULL ptr ?
d2181 2
a2182 2
        test    dx,-1                   ; NULL ptr ?
        je      initfail                ; YES -> failed
d2185 4
a2188 2
        mov     cs:_CurrentCo,ax
        mov     cs:_CurrentCo+2,dx       ; current coroutine
d2190 4
a2193 7
	mov	si,ax
	mov	ds,dx
                                        ; ds:si = current coroutine
 
        mov     co_parent[si],ax
        mov     co_parent+2[si],dx      ; I'm my own parent

d2195 4
a2198 2
	mov	co_magic[si],ax
 
d2203 2
a2204 3
 	pop	si
        pop     ds
 
d2235 2
d2238 7
a2244 8
; Finally, various variables which specify the current configuration
; such as the link addresses and timeouts.
	PUBLIC _link_base, _link_read, _link_write, _link_in_status
	PUBLIC _link_out_status
	PUBLIC _link_reset, _link_analyse
	PUBLIC _control_write
	PUBLIC	_dma_request, _int_enable, _dma_channel
	PUBLIC _reset_timeout, _analyse_timeout
d2246 2
a2247 15
  
control_mask    	DB 0        	; last value written to control reg.
_link_base		DW	0150H
_link_read		DW	0150H
_link_write		DW	0151H
_link_in_status		DW	0152H 
_link_out_status	DW	0153H
_link_reset		DW	0160H
_link_analyse		DW	0161H
_dma_request		DW	0162H
_int_enable		DW	0163H
_dma_channel		DW	0
_control_write		DW	0104H
_reset_timeout		DW	8000
_analyse_timeout	DW	4000
d2249 3
a2251 6
; DOS DEV Data Areas
_dos_handle		DW	0	; handle to the link name
_dos_status		DW	0	; last link statistic read
			DW 	0
_dos_dev_word		DW	0	; Dos function command area
			DW	0
d2253 18
d2284 7
a2290 2
C_DATA_READY       EQU 1
C_TEST             EQU 3
a2291 1
 
d2306 1
a2306 1
	mov	bx, cs:_dos_handle	;handle to device driver
d2308 1
a2308 3
	lea	dx, cs:_dos_status
	push 	cs
	pop	ds			;offset is ds:dx
d2310 1
a2310 1
	mov	ax, cs:_dos_status	;macro gives result in ax
d2314 1
a2314 1
	mov     dx,cs:_link_in_status   ; input status register
d2337 1
a2337 1
        mov     dx,cs:_link_out_status ; output status register
d2369 1
a2369 1
        mov     dx, cs:_link_out_status	; inner loop, 65000 iterations
d2383 1
a2383 1
        mov     dx,cs:_link_write
d2418 1
a2422 1
	mov	bx, cs:_dos_handle	; handle to device driver
d2454 1
a2454 1
        mov     dx,cs:_link_in_status	; inner loop, 65000 iterations
d2467 1
a2467 1
        mov     dx,cs:_link_read
d2470 1
a2470 1
        mov     ds:[si],al
d2507 2
a2508 1
	lds	dx,[bp+arg1]		; ds:dx is address of data
a2509 1
	mov	bx, cs:_dos_handle	; handle to device driver
d2546 1
a2546 1
        mov     dx,cs:_link_out_status  ; wait "timeout" loops for linkout ready
d2563 3
a2567 3
        xchg    ah,dl                   ; store lower byte of link_out_stat in ah
        mov     dx,cs:_link_write       ; I can now xchg ah,dl to switch from
                                        ; status port to write port
d2633 1
d2635 1
a2635 2
	lds     dx, arg2[bp]            ; and ds:dx is the buffer address
	mov	bx, cs:_dos_handle	; handle to device driver
d2671 1
a2671 1
        mov     dx,cs:_link_in_status   ; wait "timeout" loops for linkout ready
d2684 3
a2688 3
        xchg    ah,dl                   ; store lower byte of link_out_stat in ah
        mov     dx,cs:_link_read        ; I can now xchg ah,dl to switch from
                                        ; status port to write port
d2744 1
a2746 1
	mov	bx, cs:_dos_handle	; handle to device driver
d2768 1
a2768 1
	mov	ax, cs:_dos_handle	; get current handle
d2777 1
a2777 1
	mov	bx, cs:_dos_handle
d2782 1
a2782 1
	mov	bx, cs:_dos_handle
d2784 1
a2784 3
	mov	dx, offset cs:_dos_dev_word
	push	cs
	pop	ds			; ds=cs
d2802 1
a2802 1
	mov	bx, cs:_dos_handle
d2804 1
a2804 3
	mov	dx, offset cs:_dos_dev_word
	push	cs
	pop	ds			; ds=cs
d2822 1
a2822 1
	mov	ax, cs:_dos_handle	; get current handle
d2840 2
d2858 1
a2858 1
	mov	bx, cs:_dos_handle	; get current handle
d2864 1
a2864 1
	mov	cs:_dos_handle, 0	; reset handle
d2879 1
a2879 1
        mov     dx, cs:_link_reset         ; address of reset reg.
d2882 1
a2882 1
        mov     cx, cs:_reset_timeout        ; wait ? Msec
d2888 1
a2888 1
	mov	cx,cs:_reset_timeout	
d2903 1
a2903 1
        mov     dx, cs:_link_analyse       ; address of analyse register
d2906 1
a2906 1
        mov     cx, cs:_analyse_timeout    ; wait ? Msec
d2910 1
a2910 1
        mov     dx, cs:_link_reset         ; assert reset
d2912 1
a2912 1
        mov     cx, cs:_reset_timeout      ; wait ? Msec
d2919 1
a2919 1
	mov	cx,cs:_reset_timeout
d2923 1
a2923 1
        mov     dx, cs:_link_analyse
d2926 1
a2926 1
	mov	cx,cs:_reset_timeout
d2939 1
a2939 1
	mov	dx, cs:_link_analyse
d2942 1
a2942 1
	mov	dx,cs:_link_in_status	; disable link interrupts
d2955 2
a2956 2
        mov     dx, cs:_control_write      ; address of control reg.
        mov     al, cs:control_mask        ; current control mask
d2959 1
a2959 1
        mov     cx, cs:_reset_timeout      ; wait ? Msec
d2964 1
a2964 1
        mov     cs:control_mask,al
d2982 2
a2983 2
        mov     dx, cs:_control_write      ; address of control reg.
        mov     al, cs:control_mask        ; current control mask
d2992 1
a2992 1
        mov     cx, cs:_reset_timeout      ; wait ? Msec
d3000 1
a3000 1
        mov     cs:control_mask,al
d3015 1
a3015 1
        mov     dx, cs:_control_write      ; address of control reg.
d3017 1
a3017 1
        mov     cs:control_mask,al         ; initialise control mask
d3020 1
a3020 1
	mov	dx,cs:_link_in_status	; disable link interrupts
d3048 1
a3048 1
	mov	dx,cs:_int_enable	; disable all interrupts
d3061 1
a3061 1
	mov	ax,cs:_dma_channel	; set up the DMA page
d3073 1
a3073 1
	mov	dx,cs:_dma_channel	; now for the transfer base
d3088 1
a3088 1
	mov	ax,cs:_dma_channel	; dma mode
d3096 1
a3096 1
 	mov	dx,cs:_link_in_status
d3099 1
a3099 1
	mov	dx,cs:_link_out_status
d3102 1
a3102 1
	mov	dx,cs:_dma_request
d3106 1
a3106 1
	mov	cx,cs:_dma_channel	; prepare to poll for DMA completion
d3127 1
a3127 1
	mov	dx,cs:_link_in_status	; reset C012
d3129 1
a3129 1
	mov	dx,cs:_link_out_status
d3144 1
a3144 1
	mov	ax,cs:_dma_channel	; set up the DMA page
d3156 1
a3156 1
	mov	dx,cs:_dma_channel	; now for the transfer base
d3171 1
a3171 1
	mov	ax,cs:_dma_channel	; dma mode
d3179 1
a3179 1
 	mov	dx,cs:_link_in_status
d3182 1
a3182 1
	mov	dx,cs:_link_out_status
d3185 1
a3185 1
	mov	dx,cs:_dma_request
d3189 1
a3189 1
	mov	cx,cs:_dma_channel	; prepare to poll for DMA completion
d3209 1
a3209 1
	mov	dx,cs:_link_in_status	; reset C012
d3211 1
a3211 1
	mov	dx,cs:_link_out_status
d3219 2
d3222 730
d3953 1
a3953 1
#ifdef OLD_ETHER
a3979 3
	mov	ax,ds		; store the default data segment
	mov	cs:data_segment,ax

d4018 1
a4018 1
	mov	dx,cs:data_segment	; restore the data segment
d4048 1
a4048 1
; buffer that the packet was copied into is pointed to by DS:SI."
d4072 1
a4072 5
#if 0
	mov dx, seg _pkt_rcvd	 ; testing ... (identical)
#else
	mov dx, _DATA
#endif
d4075 2
a4134 3
#if 0
	mov _pkt_len [bx], cx	; old ...
#else
a4136 1
#endif
d4167 25
@


1.7
log
@Added support for Clarkson pkt drivers (compile with /DOLD_ETHER for
original code)
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.6 1991/08/15 14:17:31 al Exp craig $ --;
a108 2
; Receiver Subroutine
; ===================
@


1.6
log
@Moved #ifdef TMB16 so that if option appears, always goes in byte mode
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.4 1991/07/26 16:41:35 al Exp $ --;
d94 1
d96 1
d103 36
d2876 1
d2953 150
a3108 1

@


1.5
log
@TMB16 board will not work under Helios 1.X.  Code #ifdef'ed out for now.
@
text
@a1853 1
#ifdef TMB16
a1854 1
#endif
a2413 1
#ifdef TMB16
a2434 1
#endif
@


1.4
log
@Added support for DOS drivers and tmb16 board
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.3 1991/06/04 11:26:23 alan Exp $ --;
d1836 2
a1837 1
;-- UPDATES: 15/7/91 A. Schuilenburg (Handle DOS Devs and TMB16 board)      --;
d1850 1
a1850 1
; Routines specific to DOS and TMB16
d1854 1
d1856 1
d2416 1
d2438 1
@


1.3
log
@add relative mouse - fix probs if no printers
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.2 1991/04/02 12:18:18 alan Exp $ --;
d1836 1
a1836 1
;-- UPDATES:                                                                --;
d1849 5
d1880 9
d1897 3
d1915 12
d1933 10
a1942 1
 
d1956 9
a1965 1
 
d2006 4
d2011 38
d2093 44
a2149 1

d2171 1
a2171 1
        jmp     l12
d2210 1
d2218 45
a2262 1
 
d2330 43
a2373 1
 
d2375 113
a2510 1
 
@


1.2
log
@make send_boot try harder to succeed
@
text
@d15 1
a15 1
;-- RcsId: $Id: pcasm.cpp,v 1.1 90/10/18 11:23:49 alan Exp $ --;
a344 1
PUBLIC _set_mouse_coords
d409 5
a413 3
	push	dx
	push	cx
	push	bx
a422 11
_set_mouse_coords	PROC	FAR
	pushall

	mov	ax,4
	mov	cx,arg1[bp]
	mov	dx,arg2[bp]
	int	mouse_trap

	popall
	ret
_set_mouse_coords	ENDP
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
;-- RcsId: $Id$ --;
d2053 3
d2064 1
d2080 5
d2088 1
@
