head	1.7;
access;
symbols
	Helios_1_3_1:1.7
	Helios_C40_1_3_Official_Release:1.4
	Helios-C40:1.4
	Alenia_release:1.4
	Helios1_3:1.4
	C40_Field_Test_2:1.4
	C40_Field_Test_R1:1.4
	Helios13_beta:1.4
	Helios1_2_2:1.2
	Helios1_2_2Beta:1.1
	Helios1_2_1:1.1;
locks; strict;
comment	@ * @;


1.7
date	93.10.20.16.53.29;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	93.10.13.17.36.29;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	93.09.29.10.59.03;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	92.06.19.09.47.31;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	92.05.04.19.22.04;	author craig;	state Exp;
branches;
next	1.2;

1.2
date	91.11.22.18.06.03;	author martyn;	state Exp;
branches;
next	1.1;

1.1
date	90.10.17.12.18.36;	author alan;	state Exp;
branches;
next	;


desc
@generic /ether code
@


1.7
log
@I have rewritten the code which searches for the packet driver under
Windows, to try and get it running on Jon's machine.
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--          H E L I O S   I N P U T / O U T P U T   S E R V E R         --
--          ---------------------------------------------------         --
--                                                                      --
--               Copyright (C) 1987, Perihelion Software Ltd.           --
--                          All Rights Reserved.                        --
--                                                                      --
--  ether.c                                                             --
--                                                                      --
--  Author:   AC April 90                                               --
--                                                                      --
------------------------------------------------------------------------*/

/* RcsId: $Id: ether.c,v 1.6 1993/10/13 17:36:29 bart Exp $ */
/* Copyright (C) 1987, Perihelion Software Ltd. 			*/

#include "helios.h"
/*{{{  Description */
/*
The original ethernet code was written by Alan Cosslett. It worked by
directly accessing the ethernet hardware, and only supported a small
number of boards. At the time this was the best that could be achieved.

After a while a de facto standard for accessing PC ethernet hardware
emerged, in the form of Clarkson packet drivers. This allows application
software, usually in the form of TCP/IP protocol stacks or networks such
as Novell, to support all ethernet cards. The ethernet support was
switched over to use these packet drivers.

A bit later on the I/O Server was ported to Windows. This caused serious
problems because the packet driver interface is provided by a TSR,
working only in 8086 mode, whereas the Windows I/O Server would usually
run in Windows 386 enhanced mode. Windows provides something called DPMI,
DOS Protected Mode Interface, as a way for Windows applications to
interface to TSR's etc. Therefore code was added to use these DPMI services.

The basic ethernet facilities used within this module are as follows:

1) check whether a Clarkson packet driver is loaded. The driver interface
species that a certain signature will be present at a particular offset.
The packet driver is access via traps and is normally loaded somewhere
in the range 0x60 to 0x80.

2) obtain the ethernet address from the Clarkson driver. Every ethernet
board in the world has a unique address.

3) send ethernet packets out of the board. The contents of the packets
is of no concern, since that is handled by the TCP/IP software running
in the Helios network.

4) receive certain types of ethernet packet. The I/O Server is not
interested in all possible ethernet packets, for example those used by
Novell. It should only receive IP and ARP packets.

5) shut down the ethernet support when the I/O Server exits.

The way incoming packets are handled is fairly complicated, especially
when running under Windows. Essentially the I/O Server must provide a
callback function when it opens the Clarkson packet driver. When a
packet is received this callback will be invoked, usually from inside an
interrupt routine. The callback will save the packet in a circular
buffer, where the I/O Server's usual polling loop can detect it and send
it off to the Helios network. The callback function is written in assembler,
in module pcasm.cpp. In DOS mode it does all the work itself. Under Windows
it invokes a C routine to do the work.

*/
/*}}}*/
/*{{{  Manifests, structures and statics */
	/* These must be kept in step with pcasm.cpp			*/
#define MAXETHERPKT		1514	/* maximum packet size		*/
#define MAX_PKT_TABLE		8	/* size of buffer table		*/
#define LEN_ETHER_ADDR		8	/* length of ethernet address	*/


	/* This defines the types of ethernet packets this code has	*/
	/* to support. N.B. swapped because of network byte ordering.	*/
#define PKT_TYPE_LEN		2
#define	ETHERTYPE_IP		0x0008	/* IP protocol			*/
#define ETHERTYPE_ARP		0x0608	/* Addr. resolution protocol	*/

	/* During initialisation this is filled in with the hardware	*/
	/* ethernet address.						*/
PRIVATE unsigned char etheraddr[LEN_ETHER_ADDR];

	/* The table of packet drivers. Under DOS this can be allocated	*/
	/* statically, at the cost of using up a large chunk of default	*/
	/* data space. pcasm.cpp needs a pointer rather than an array.	*/
	/* Under Windows the buffer has to be in the DOS memory area	*/
	/* and allocated specifically.					*/
#if !MSWINDOWS
PRIVATE byte  ether_pkt_table[MAX_PKT_TABLE][MAXETHERPKT];
        byte *pkt_table = ether_pkt_table[0];
#else
#define ether_pkt_table	DOS_data->rx_buffer
#endif /* MSWINDOWS */

	/* This contains the lengths of the various packets currently	*/
	/* buffered.							*/
PRIVATE SHORT  ether_pkt_len[MAX_PKT_TABLE];
        SHORT *pkt_len = ether_pkt_len;

	/* Circular buffer management. Index for the next full slot,	*/
	/* and count of the number of packets received.	pcasm.cpp has	*/
	/* its own counter for the next free slot. Also an error flag.	*/
PRIVATE SHORT pkt_index = 0;
SHORT pkt_rcvd		= 0;
SHORT pkt_too_long	= 0;

	/* The assembler callback function.				*/
extern	void receiver(void);
/*}}}*/
/*{{{  DPMI support for Windows */
#if MSWINDOWS
/*{{{  Manifests, structures and statics */
/*
   DPMI Int 31H functions
*/
#define DPMI_INT		0x31

#define ALLOCATE_LDT_DESCRIPTORS	0x0000
#define FREE_LDT_DESCRIPTOR		0x0001
#define SET_SEGMENT_BASE_ADDRESS	0x0007
#define SET_SEGMENT_LIMIT		0x0008
#define GET_REAL_INT_VECTOR		0x0200
#define SIMULATE_REAL_INT		0x0300
#define ALLOC_REAL_CALLBACK		0x0303
#define FREE_REAL_CALLBACK		0x0304
#define GET_VERSION			0x0400

typedef struct {
	UWORD  _di, _si, _bp ;	
	UWORD  _reserved ;	
	UWORD  _bx, _dx, _cx, _ax ;	
	USHORT _flags ;
	USHORT _es, _ds, _fs, _gs ;
	USHORT _ip, _cs ;
	USHORT _sp, _ss ;
} real_reg_struct ;

	/* The Clarkson packet driver and the I/O Server need to	*/
	/* exchange data via DOS memory, including but not limited to	*/
	/* the circular buffer for incoming packets. A single buffer	*/
	/* is allocated to hold all of this data.			*/
typedef struct {
	byte            rx_buffer [MAX_PKT_TABLE] [MAXETHERPKT];  /* must be 1st */
	byte            access_type_buffer [PKT_TYPE_LEN] ;
	byte            address_buffer [LEN_ETHER_ADDR] ;
	real_reg_struct callback_regs ;
	real_reg_struct real_int_regs ;
	byte            tx_buffer [MAXETHERPKT] ;
} DOS_data_struct ;

PRIVATE DOS_data_struct *DOS_data	= NULL;
PRIVATE USHORT pkt_table_selector = 0 ;
        USHORT pkt_table_segment = 0 ;   /* accessed by pcasm.cpp */

PRIVATE USHORT SEG_real_callback = 0 ;
PRIVATE USHORT OFF_real_callback = 0 ;

PRIVATE SHORT DPMI_err = 0 ;
#define TEST_DPMI_ERROR							\
	if (regs.x.cflag)						\
	{								\
		DPMI_err = regs.x.ax ;  				\
		return -1 ;						\
	}

#define SIMULATE_INT(interrupt_no)					\
	if (simulate_real_mode_int (interrupt_no,			\
				&DOS_data->real_int_regs,		\
				regs, sregs) < 0)			\
		{							\
			ServerDebug("/ether: failed to simulate real mode interrupt"); \
			return(-1);					\
		}
/*}}}*/
/*{{{  DPMI resources */
/*
 * The I/O Server allocates two lots of resources which must be freed.
 * 1) a region of DOS memory accessible to both the I/O Server and the
 *    packet driver. All the various bits of data are held in one big
 *    data structure.
 * 2) a DPMI callback. This is a function address in DOS memory provided
 *    by DPMI which can be given to the Clarkson packet driver. This
 *    function will invoke a callback within the I/O Server.
 */
static bool allocate_dpmi_resources(void)
{
	UWORD		 dMem;
	union _REGS	 regs;
	struct _SREGS	 sregs;
	byte		*tempptr;
	
	dMem			= GlobalDosAlloc(sizeof(DOS_data_struct));
	if (dMem == 0) return(false);
	pkt_table_segment	= HIWORD(dMem);
	pkt_table_selector	= LOWORD(dMem);
	FP_SEG(DOS_data)	= pkt_table_selector;
	FP_OFF(DOS_data)	= 0;
	
	_segread(&sregs);
	regs.x.ax	= ALLOC_REAL_CALLBACK;
	tempptr		= (byte *) &receiver;
	sregs.ds	= FP_SEG(tempptr);
	regs.x.si	= FP_OFF(tempptr);
	tempptr		= (byte *) &(DOS_data->callback_regs);
	sregs.es	= FP_SEG(tempptr);
	regs.x.di	= FP_OFF(tempptr);

	_int86x (DPMI_INT, &regs, &regs, &sregs) ;
	if (regs.x.cflag) { DPMI_err = regs.x.ax ; return(false); }

	SEG_real_callback = regs.x.cx ;
	OFF_real_callback = regs.x.dx ;
}

static void free_dpmi_resources(void)
{
	union	_REGS	regs;
	struct	_SREGS	sregs;
		
	if (SEG_real_callback != 0)
	{
		_segread(&sregs);
		regs.x.ax = FREE_REAL_CALLBACK ;
		regs.x.cx = SEG_real_callback ;
		regs.x.dx = OFF_real_callback ;
		_int86x (DPMI_INT, &regs, &regs, &sregs) ;
		if (regs.x.cflag)
			ServerDebug("Failed to free callback");
		SEG_real_callback	= 0;
		OFF_real_callback	= 0;
	}

	if (DOS_data ne NULL)
		GlobalDosFree(pkt_table_selector);

}
/*}}}*/
/*{{{  set_up_real_mode() */

/*
------------------------------------------------------------------------------
*/

PRIVATE void set_up_real_mode_int (SHORT int_no, real_reg_struct *real_regs,
			union _REGS regs, struct _SREGS sregs)
{
	real_regs->_di = regs.x.di ;
	real_regs->_si = regs.x.si ;
	real_regs->_bp = 0 ;
	real_regs->_reserved = 0 ;
	real_regs->_bx = regs.x.bx ;
	real_regs->_dx = regs.x.dx ;
	real_regs->_cx = regs.x.cx ;
	real_regs->_ax = regs.x.ax ;
	{
		USHORT temp_flags ;
		_asm
		{
			push ax
			pushf
			pop ax
			mov temp_flags, ax
			pop ax
		}
		real_regs->_flags = temp_flags ;
	}
	real_regs->_es = sregs.es ;
	real_regs->_ds = sregs.ds ;
	real_regs->_fs = 0 ;
	real_regs->_gs = 0 ;
/*
-- DPMI spec. V1.0 p. 87
-- CS:IP not used
*/
	real_regs->_ip = 0 ;
	real_regs->_cs = 0 ;

/*
-- DPMI spec. V1.0 p. 87
-- if SS:SP = 0, DPMI host will provide real mode stack
*/
	real_regs->_sp = 0 ;
	real_regs->_ss = 0 ;
}
/*}}}*/
/*{{{  simulate_real_mode_int() */
/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT simulate_real_mode_int (USHORT int_no, 
				real_reg_struct *real_regs,
				union _REGS regs, struct _SREGS sregs)
{
	set_up_real_mode_int (int_no, real_regs, regs, sregs) ;

	sregs.es = FP_SEG (real_regs) ;
	regs.x.di = FP_OFF (real_regs) ;

	regs.x.ax = SIMULATE_REAL_INT ;
	regs.h.bl = (UBYTE) int_no ;
	regs.h.bh = 0 ;
	regs.x.cx = 0 ;

/*
-- crf: this is a bit dodgy - only necessary when ds = wSegment
   blv, 13.10.93 this is necessary, but why ?
*/
	sregs.ds = pkt_table_selector ;

	_int86x (DPMI_INT, &regs, &regs, &sregs) ;
	TEST_DPMI_ERROR
	return (0) ;
}
/*}}}*/
/*{{{  dpmi_locate_pkt_drvr() */
	/* This code uses DPMI services to examine the specified	*/
	/* interrupt number and see if the Clarkson packet driver	*/
	/* identifier is present at that interrupt.			*/
PRIVATE bool dpmi_locate_pkt_drvr(int int_no, char *signature)
{
	union	_REGS	 regs;
	UWORD		 real_interrupt_address;
	USHORT		 selector;
	bool		 result	= FALSE;
	byte		*temp_ptr;
	
	regs.x.ax	= GET_REAL_INT_VECTOR;
	regs.h.bl	= (UBYTE) int_no;
	_int86(DPMI_INT, &regs, &regs);

	real_interrupt_address	 = (UWORD) regs.x.cx;
	real_interrupt_address	*= 16L;
	real_interrupt_address	+= (UWORD) regs.x.dx;

	regs.x.ax	= ALLOCATE_LDT_DESCRIPTORS;
	regs.x.cx	= 1;
	_int86(DPMI_INT, &regs, &regs);
	if (regs.x.cflag)
		return(FALSE);
	selector	= regs.x.ax;

	regs.x.ax	= SET_SEGMENT_BASE_ADDRESS;
	regs.x.bx	= selector;
	regs.x.cx	= HIWORD(real_interrupt_address);
	regs.x.dx	= LOWORD(real_interrupt_address);
	_int86(DPMI_INT, &regs, &regs);
	if (regs.x.cflag)
		goto done;

	regs.x.ax	= SET_SEGMENT_LIMIT;
	regs.x.bx	= selector;
	regs.x.cx	= 0;
	regs.x.dx	= 12;
	_int86(DPMI_INT, &regs, &regs);
	if (regs.x.cflag)
		goto done;

	FP_OFF(temp_ptr)	= 0;
	FP_SEG(temp_ptr)	= selector;
	if (strncmp(&(temp_ptr[3]), signature, strlen(signature)) == 0)
		result = TRUE;

done:
	regs.x.ax	= FREE_LDT_DESCRIPTOR;
	regs.x.bx	= selector;
	_int86(DPMI_INT, &regs, &regs);
	if (regs.x.cflag)
		ServerDebug("/ether: warning, failed to release DPMI descriptor");

	return(result);
}
/*}}}*/
#endif /* MSWINDOWS */
/*}}}*/
/*{{{  Packet driver routines */
/*{{{  Packet driver structures, manifests, etc. */
	/* Clarkson packet drivers should be loaded somewhere in the	*/
	/* range 0x60-0x80. The user can specify the address explicitly,*/
	/* otherwise the I/O Server will search this range for a	*/
	/* defined signature.						*/
#define	MIN_PKT_INT		0x60
#define	MAX_PKT_INT		0x80
#define DRVR_SIG		"PKT DRVR"

	/* These are the operations supported by packet drivers.	*/
#define	DRIVER_INFO		 1
#define	ACCESS_TYPE		 2
#define	RELEASE_TYPE		 3
#define	SEND_PKT		 4
#define	TERMINATE		 5
#define	GET_ADDRESS		 6
#define	RESET_INTERFACE		 7
#define GET_PARAMETERS		10
#define AS_SEND_PKT		11
#define	SET_RCV_MODE		20
#define	GET_RCV_MODE		21
#define	SET_MULTICAST_LIST	22
#define	GET_MULTICAST_LIST	23
#define	GET_STATISTICS		24
#define SET_ADDRESS		25

	/* The software interrupt number is variable.			*/
PRIVATE SHORT pkt_int_no	= -1 ;

	/* Two handles are needed, one for IP packets and one for ARP	*/
	/* packets.							*/
PRIVATE SHORT	IP_handle	= -1;
PRIVATE SHORT	ARP_handle	= -1;

	/* Error handling.						*/
PRIVATE SHORT drvr_err = 0 ;

#define TEST_ERROR			\
	if (regs.x.cflag)		\
	{				\
		drvr_err = regs.h.dh ;	\
		return -1 ;		\
	}
/*}}}*/
/*{{{  Error handling */
#define NUM_ERR_CODES		16
PRIVATE byte *Drvr_Err_Code [NUM_ERR_CODES] =
{
"No error",							/* NO_ERROR		0 */
"Invalid handle number",					/* BAD_HANDLE		1 */
"No interfaces of specified class found",			/* NO_CLASS		2 */
"No interfaces of specified type found",			/* NO_TYPE		3 */
"No interfaces of specified number found",			/* NO_NUMBER		4 */
"Bad packet type specified",					/* BAD_TYPE		5 */
"Interface does not support multicast",				/* NO_MULTICAST		6 */
"Packet driver cannot terminate",				/* CANT_TERMINATE	7 */
"Invalid receiver mode was specified",				/* BAD_MODE		8 */
"Operation failed - insufficient space",			/* NO_SPACE		9 */
"Type previously accessed and not released",			/* TYPE_INUSE		10 */
"Command out of range or not implemented",			/* BAD_COMMAND		11 */
"Packet couldn't be sent (usually hardware error)",		/* CANT_SEND		12 */
"Hardware address couldn't be changed (> 1 handle open)",	/* CANT_SET		13 */
"Hardware address has bad length or format",			/* BAD_ADDRESS		14 */
"Couldn't reset interface (> 1 handle open)"			/* CANT_RESET		15 */
} ;

static char *clarkson_error()
{
	if ((drvr_err < 0) || (drvr_err >= NUM_ERR_CODES))
		return("unknown error");
	else
		return(Drvr_Err_Code[drvr_err]);
}
/*}}}*/
/*{{{  drvr_info() */
PRIVATE SHORT drvr_info (SHORT int_no,
	SHORT *if_class, SHORT *if_type, SHORT *if_number)
{
	union _REGS regs;
	struct _SREGS sregs ;

	_segread (&sregs) ;

	regs.h.ah = DRIVER_INFO ;
	regs.h.al = 0xff ;
	regs.x.bx = 0;
	_int86x (int_no, &regs, &regs, &sregs) ;

	TEST_ERROR
	*if_class   = regs.h.ch ;
	*if_type    = regs.x.dx ;
	*if_number  = regs.h.cl ;
	return 0 ;
}
/*}}}*/
/*{{{  access_type() */
PRIVATE SHORT access_type (SHORT int_no,
			SHORT if_class, SHORT if_type, SHORT if_number,
			SHORT type)
{
	union _REGS	 regs ;
	struct _SREGS	 sregs ;
	byte		*temp_ptr;	

	_segread (&sregs) ;

#if !MSWINDOWS
	temp_ptr	= (byte *) &receiver;
	sregs.es	= FP_SEG (temp_ptr);
	regs.x.di	= FP_OFF (temp_ptr);
	temp_ptr	= (byte *) &type;
	sregs.ds	= FP_SEG (temp_ptr);	/* type of ethernet packet	*/
	regs.x.si	= FP_OFF (temp_ptr);
#else /* MSWINDOWS */
	sregs.es 	= SEG_real_callback ;
	regs.x.di	= OFF_real_callback ;
	temp_ptr	= DOS_data->access_type_buffer ;
	memcpy (temp_ptr, &type, sizeof(SHORT)) ;
	sregs.ds	= pkt_table_segment ;
	regs.x.si	= FP_OFF (temp_ptr) ;
#endif /* MSWINDOWS */

	regs.h.dl	= (UBYTE) if_number ;
	regs.x.cx	= sizeof(SHORT);
	regs.x.bx	= if_type ;
	regs.h.ah	= ACCESS_TYPE ;
	regs.h.al	= (UBYTE) if_class ;

#if !MSWINDOWS
	_int86x (int_no, &regs, &regs, &sregs) ;
	TEST_ERROR
	return regs.x.ax ;
#else /* MSWINDOWS */
	SIMULATE_INT (int_no)
	return (USHORT) DOS_data->real_int_regs._ax ;
#endif /* MSWINDOWS */
}
/*}}}*/
/*{{{  get_address() */
PRIVATE SHORT get_address (SHORT int_no, SHORT handle, 
			byte *buffer, SHORT buf_len)
{
	union _REGS regs ;
	struct _SREGS sregs ;
	byte *addr_ptr;

	_segread (&sregs) ;

	regs.x.cx = buf_len ;
	regs.x.bx = handle ;
	regs.h.ah = GET_ADDRESS ;

#if !MSWINDOWS
	sregs.es	= FP_SEG (buffer) ;
	regs.x.di	= FP_OFF (buffer) ;
	_int86x (int_no, &regs, &regs, &sregs) ;
	TEST_ERROR
	return (regs.x.cx) ;
#else /* MSWINDOWS */
	addr_ptr	= DOS_data->address_buffer ;
	sregs.es	= pkt_table_segment;
	regs.x.di	= FP_OFF (addr_ptr) ;
	SIMULATE_INT (int_no)
	memcpy (buffer, addr_ptr, buf_len) ;
	return (USHORT) DOS_data->real_int_regs._cx;
#endif /* MSWINDOWS */
}
/*}}}*/
/*{{{  release_type() */
PRIVATE SHORT release_type (SHORT int_no, SHORT handle)
{
	union  _REGS	regs;
	
	regs.x.bx = handle ;
	regs.h.ah = RELEASE_TYPE ;
	_int86(int_no, &regs, &regs) ;
	TEST_ERROR
	return 0 ;
}
/*}}}*/
/*{{{  clean_up() */
static void clean_up(void)
{
	if ((ARP_handle ne -1) && release_type(pkt_int_no, ARP_handle))
		ServerDebug("/ether: failed to release access to ARP packets, %s", clarkson_error());

	if ((IP_handle ne -1) && release_type(pkt_int_no, IP_handle))
		ServerDebug("/ether: failed to release access to IP packets, %s", clarkson_error());

#if MSWINDOWS
	free_dpmi_resources();
#endif /* MSWINDOWS */
}
/*}}}*/
/*{{{  send_pkt() */
PRIVATE SHORT send_pkt (SHORT int_no, byte *buffer, USHORT buf_len)
{
	union _REGS regs ;
	struct _SREGS sregs ;
	byte *temp_ptr;

	_segread (&sregs) ;
	regs.x.cx = buf_len ;
	regs.h.ah = SEND_PKT ;

#if !MSWINDOWS
	sregs.ds = FP_SEG (buffer) ;
	regs.x.si = FP_OFF (buffer) ;
	_int86x (int_no, &regs, &regs, &sregs) ;
	TEST_ERROR
#else /* MSWINDOWS */
	temp_ptr = DOS_data->tx_buffer ;
	memcpy (temp_ptr, buffer, buf_len) ;
	sregs.ds = pkt_table_segment;
	regs.x.si = FP_OFF (temp_ptr) ;
	SIMULATE_INT (int_no)
#endif /* MSWINDOWS */
	return 0 ;
}
/*}}}*/
/*{{{  locate_pkt_drvr() */
#if MSWINDOWS
	/* Under Windows this is a very complicated operation, since	*/
	/* the packet driver code is not directly accessible.		*/
PRIVATE bool locate_pkt_drvr(USHORT int_no)
{
	return(dpmi_locate_pkt_drvr(int_no, DRVR_SIG));
}
#else
	
PRIVATE bool locate_pkt_drvr (USHORT int_no)
{
	word drvr_vec = (word) _dos_getvect (int_no) ;
	if (strncmp((byte *) (drvr_vec + 3), DRVR_SIG, strlen(DRVR_SIG)) == 0)
		return(TRUE);
	else
		return(FALSE);
}
#endif
/*}}}*/
/*{{{  clarksonp() */
PRIVATE bool clarksonp ()
{
	SHORT located = 0 ;
	SHORT addr_len ;
	SHORT iface_class, iface_type, iface_number;
	word  temp;

#if MSWINDOWS
	unless(allocate_dpmi_resources())
	{
		ServerDebug("/ether: failed to initialise DPMI support");
		return(FALSE);
	}
#endif

	/* Has the user specified a packet interrupt number ?	*/
	temp = get_int_config("packet_int");
	if (temp eq Invalid_config)
		pkt_int_no = -1;
	else
		pkt_int_no = (int) temp;

	/* If the user has specified an address, check it.		*/
	if (pkt_int_no != -1)
	{
		if ((pkt_int_no < MIN_PKT_INT) || (pkt_int_no > MAX_PKT_INT))
		{
			ServerDebug("/ether: Invalid packet (0x%x) - must be in range 0x%x-0x%x", pkt_int_no, MIN_PKT_INT, MAX_PKT_INT);
			return(false);
		}
		located = locate_pkt_drvr (pkt_int_no) ;
		if (!located)
		{
			ServerDebug("/ether: failed to locate packet driver at 0x%x (%d)",
					pkt_int_no, pkt_int_no);
			return(false);
		}
	}
	else	/* otherwise search through the valid range of numbers.	*/
	{
		for (pkt_int_no = MIN_PKT_INT;pkt_int_no <= MAX_PKT_INT; pkt_int_no++)
		{		
			located = locate_pkt_drvr (pkt_int_no) ;
			if (located)
				break ;
		}
		if (!located)
		{
			ServerDebug("/ether: failed to locate packet driver in range 0x%x-0x%x",
					MIN_PKT_INT, MAX_PKT_INT);
			return(false);
		}
	}

	if (drvr_info (pkt_int_no, &iface_class, &iface_type, &iface_number) < 0)
	{
		ServerDebug("/ether: failed to get interface information");
		return(false);
	}

	IP_handle = access_type(pkt_int_no, iface_class, iface_type, iface_number,
				ETHERTYPE_IP);
	if (IP_handle < 0)
	{
		ServerDebug("/ether: failed to initiate access to IP packets");
		return(false);
	}

	ARP_handle	= access_type(pkt_int_no, iface_class, iface_type, iface_number,
				ETHERTYPE_ARP);
	if (ARP_handle < 0)
	{
		clean_up();
		ServerDebug("/ether: failed to initiate access to ARP packets");
		return(false);
	}			

	addr_len = get_address (pkt_int_no, IP_handle, etheraddr, sizeof (etheraddr)) ;
	if (addr_len < 0)
	{
		clean_up();
		ServerDebug("/ether: failed to get Ethernet address");
		return(false);
	}

	return (true) ;
}
/*}}}*/
/*}}}*/
/*{{{  I/O Server routines */
/*{{{  Interface specification and statics */
	/* GetAttributes() on an ethernet stream should return a 	*/
	/* NetInfo structure containing the ethernet address.		*/
typedef struct NetInfo
{
        word Mask;
        word Mode;
        word State;
        byte Addr[LEN_ETHER_ADDR];
} NetInfo;

#define NetInfo_Mask_Mode   1
#define NetInfo_Mask_State  2
#define NetInfo_Mask_Addr   4 

	/* When sending out packets and the interface or the ether is	*/
	/* busy the write code will suspend and loop. Therefore the	*/
	/* packet has to be stored somewhere safe. A static buffer	*/
	/* suffices if the packets are being sent from the pc-ether.d	*/
	/* ethernet driver which will only send one packet at a time.	*/
PRIVATE byte etherbuff[MAXETHERPKT];

	/* Is the ethernet supported ?					*/
PRIVATE bool ethernet = false;
/*}}}*/
/*{{{  Initialisation and tidying up */
/*
 * Messing about with packet drivers, DPMI, etc. should be done only
 * on program start-up and exit, not on every reboot.
 */
void initialise_ethernet(void)
{
  unless(get_config("ETHERNET"))
   return;

  unless(clarksonp()) 
   return;

  ethernet = true;
}

void tidy_ethernet(void)
{
  if (ethernet)
   clean_up();
}
/*}}}*/
/*{{{  Ether_TestFun() */
void Ether_Testfun(result)
word* result;
{
  if (ethernet)
   { *result = 1L;
     ServerDebug("/ether: Ethernet address  %02x:%02x:%02x:%02x:%02x:%02x",
	etheraddr[0],etheraddr[1],etheraddr[2],etheraddr[3],etheraddr[4],etheraddr[5]);
   }
  else
   *result = 0L;

}
/*}}}*/
/*{{{  Ether_GetAttr() */
void Ether_GetAttr(Conode *myco)
{
  NetInfo* nip = (NetInfo*)(mcb->Data);

  nip->Mode = 0L;
  nip->State = 0L;
  memcpy(&nip->Addr[0],&etheraddr[0],8);
  
  mcb->MsgHdr.Dest = 0L;

  Request_Return(0L,0L,(word)sizeof(NetInfo));
  use(myco)
}
/*}}}*/
/*{{{  Ether_Open() */
void Ether_Open(myco)
Conode *myco;
{
  if ((((mcb->Control)[OpenMode_off] & 0x0F) ne O_WriteOnly)&&
      (((mcb->Control)[OpenMode_off] & 0x0F) ne O_ReadOnly))
  {
    Request_Return(EC_Error + SS_IOProc + EG_WrongFn +
                   EO_Server, 0L, 0L);
    return;
  }

  NewStream(Type_File, Flags_Closeable, NULL, Ether_Handlers);
  use(myco)
}
/*}}}*/
/*{{{  Ether_Close() */
void Ether_Close(myco)
Conode *myco;
{
  if (mcb->MsgHdr.Reply ne 0L)
    Request_Return(ReplyOK, 0L, 0L);
  Seppuku();
  use(myco)
}
/*}}}*/
/*{{{  Ether_Write() */
void Ether_Write(myco)
Conode* myco;
{
  word reply_port = mcb->MsgHdr.Reply;
  word asked      = (mcb->Control)[WriteSize_off];
  word actual     = mcb->MsgHdr.DataSize;
  word time_interval = divlong(mcb->Control[WriteTimeout_off], time_unit);

  /* Ethernet has a limit of 1514 bytes on a pkt */

  if (asked > MAXETHERPKT)
  {
    Request_Return(EC_Error + SS_IOProc + EG_WrongSize +
                  EO_Message, 0L,0L);
    ServerDebug("/ether: TX error - bad packet size (%d bytes)", asked);
    return;
  }

  /*
   *  if asked = 0 return immediately
   */

  if (asked == 0)
  {
    mcb->Control[Reply1_off] = 0L;
    Request_Return(WriteRc_Done, 1L, 0L);
    return;
  }

  /*
   *  if there is any data it is the easy case 
   *  with the total write < 512 bytes       
   */


  myco->timelimit = Now + time_interval;

  unless (actual > 0) 
  {

    /*
     *  ok so we must have > 512 to transmit
     *  so ask the othe side to send it
     */


     mcb->Control[Reply1_off] = MAXETHERPKT;
     mcb->Control[Reply2_off] = MAXETHERPKT;
 
     mcb->MsgHdr.Flags = MsgHdr_Flags_preserve;
  
     Request_Return(WriteRc_Sizes, 2L, 0L);

     myco->timelimit = Now + time_interval;

     Suspend();
  
     if (myco->type eq CoSuicide) Seppuku();
    
     if(myco->type eq CoTimeout) 
     {
       Request_Return(EC_Warn | SS_IOProc | EG_Timeout | EO_Message, 0L, 0L); 
       return;
     }  
     actual = mcb->MsgHdr.DataSize;
  }

  if (send_pkt(pkt_int_no, mcb->Data, (USHORT) actual) < 0) 
  {
    memcpy(etherbuff,mcb->Data,(size_t)actual);
    
    AddTail(Remove(&(myco->node)),PollingCo);

    forever
    {
      myco->type = CoReady;
 
      Suspend();

      if (myco->type eq CoSuicide) Seppuku();
    
      if (myco->type eq CoTimeout) 
      {
        actual = 0;
        break;
      }  

      if (send_pkt(pkt_int_no, etherbuff, (USHORT) actual) >= 0) break;
    }

    PostInsert(Remove(&(myco->node)), Heliosnode);
  }

  mcb->MsgHdr.Reply = reply_port;
  mcb->Control[Reply1_off] = actual;
  Request_Return(WriteRc_Done,1L,0L); 

  return;
}
/*}}}*/
/*{{{  Ether_Read() */
/*{{{  GetRxPkt() - check circular buffer for data */
/* GetRxPkt - gets a packet from the ring buffer 
   must only be called if there is one there 
   check with RxAvail */

PRIVATE SHORT GetRxPkt(buff,maxsize)
UBYTE* buff;
word maxsize;
{ 

  SHORT  len  = 0;

  _asm
    cli

  len = pkt_len [pkt_index]  ;

  if ((word) len > maxsize) 
    len = (SHORT) maxsize;
  memcpy (buff, ether_pkt_table [pkt_index], len) ;
  pkt_index = ++pkt_index % MAX_PKT_TABLE ;
  pkt_rcvd -- ;

  _asm
    sti

  Server_errno = 0 ;				/* all ok */
  return len ;					/* and home */
}
/*}}}*/

void Ether_Read(myco)
Conode* myco;
{
  word time_interval = divlong(mcb->Control[ReadTimeout_off],time_unit);
  word got;
  word toget = (mcb->Control)[ReadSize_off];
  
  Port reply_port = mcb->MsgHdr.Reply;

  AddTail(Remove(&(myco->node)),PollingCo);
  myco->timelimit = Now + time_interval;
  
  forever
  {
    if (pkt_too_long)
	{
		ServerDebug("/ether: RX error - bad packet size (%d bytes) - packet discarded", pkt_too_long) ;
		pkt_too_long = 0 ;
	}

    if (pkt_rcvd)
    {
      got = GetRxPkt(mcb->Data,toget);
      break;
    }

    myco->type = CoReady;

    Suspend();

    if (myco->type eq CoTimeout)
    {
      got = 0L;
      break;
    }

    if (myco->type eq CoSuicide)
    {
      Seppuku();
    }
  }

  PostInsert(Remove(&(myco->node)),Heliosnode);

  mcb->MsgHdr.Reply = reply_port;
  mcb->MsgHdr.Dest  = 0L;

  if (Server_errno == 0) Server_errno = ReadRc_EOD;

  Request_Return(Server_errno,0L,got);
}  
/*}}}*/
/*}}}*/
@


1.6
log
@The DPMI callback is now implemented entirely in assembler to
avoid possible problems with the C compiler. This has involved
various other changes. NOTE: there was a major bug in the C
version, the callback return address was not being set up sensibly.
@
text
@d15 1
a15 1
/* RcsId: $Id: ether.c,v 1.5 1993/09/29 10:59:03 bart Exp $ */
a118 7
   The Windows kernel provides the following DPMI functions that were
   previously invoked via interrupts :
   ALLOCATE_DESCRIPTOR	0x0000		AllocSelector()		
   FREE_DESCRIPTOR	0x0001		FreeSelector()
   SET_SEGMENT_BASE	0x0007		SelSelectorBase()
   SET_SEGMENT_LIMIT	0x0008		SetSelectorLimit()
  The others are implemented via int86x(0x31)
d122 9
a130 5
#define GET_REAL_INT_VECTOR	0x0200
#define SIMULATE_REAL_INT	0x0300
#define ALLOC_REAL_CALLBACK	0x0303
#define FREE_REAL_CALLBACK	0x0304
#define GET_VERSION		0x0400
a158 3
PRIVATE USHORT SEG_real_int_handler = 0 ;
PRIVATE USHORT OFF_real_int_handler = 0 ;

a241 172
/*{{{  allocate_descriptor() */

/*
------------------------------------------------------------------------------
*/

USHORT wDataSelector ;

PRIVATE SHORT allocate_descriptor (USHORT *selector)
{
/*
-- crf: 30/08/92
-- Note: AllocSelector(uSelector) - according to SDK Programmer's Reference 
-- Vol 2: Functions p. 11, if uSelector is zero, the function returns a new,
-- uninitialized selector. Hence, I would expect to allocate a new selector
-- as follows: *selector = AllocSelector(0). This does in fact appear to 
-- allocate a new selector; however, there are problems associated with 
-- setting the selector limit (GetSelectorLimit() always returns 0 after
-- limit has been set). I have therefore followed the strategy used in the
-- Tdosmem.c example (refer windev/samples/tdosmem) where AllocSelector() is
-- used to create a copy of an existing selector.
*/
	wDataSelector = HIWORD ((DWORD) (USHORT *) &wDataSelector) ;
	*selector = AllocSelector (wDataSelector) ;
	if (*selector == 0)
		return (-1) ;	
	return (0) ;
}
/*}}}*/
/*{{{  free_descriptor() */

/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT free_descriptor (USHORT *selector)
{
	if (*selector)
	{
		if (FreeSelector (*selector) != 0)
			return (-1) ;
	}
	return (0) ;
}
/*}}}*/
/*{{{  set_segment_base_addr() */

/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT set_segment_base_addr (USHORT selector, 
				USHORT real_seg, USHORT real_off)
{
	UWORD linear_base_addr = (real_seg << 4) + real_off ;
	if (SetSelectorBase (selector, linear_base_addr) == 0)
		return (-1) ;
/*
-- crf: check that it worked ...
*/
	if (GetSelectorBase (selector) != linear_base_addr)
		return (-1) ;
	return (0) ;
}
/*}}}*/
/*{{{  set_segment_limit() */

/*
------------------------------------------------------------------------------
*/

#define SEG_LIMIT	0xFFFF

PRIVATE SHORT set_segment_limit (USHORT selector)
{

/*
-- crf: should not really be setting the segment limit like this ...
-- DPMI spec. V1.0 p. 63 : "Client programs must use the LSL instruction to
-- *query* the limit for a descriptor"
*/
	SetSelectorLimit (selector, SEG_LIMIT) ;
	{
/*
-- crf: check that it worked ...
*/
		UWORD limit ;
		limit = GetSelectorLimit (selector) ;
		if (limit != SEG_LIMIT)
			return (-1) ;
	}		
	return (0) ;
}
/*}}}*/
/*{{{  get_real_int_vector() */

/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT get_real_int_vector (USHORT int_no,
				USHORT *seg_int_handler, 
				USHORT *off_int_handler)
{
	union _REGS regs;
	struct _SREGS sregs ;

	_segread (&sregs) ;

	regs.x.ax = GET_REAL_INT_VECTOR ;
	regs.h.bl = (UBYTE) int_no ;
	_int86x (DPMI_INT, &regs, &regs, &sregs) ;
	TEST_DPMI_ERROR
/*
-- CX:DX = segment:offset of real mode interrupt handler
*/	
	*seg_int_handler = regs.x.cx ;
	*off_int_handler = regs.x.dx ;
	return (0) ;
}
/*}}}*/
/*{{{  init_selector() */
/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT init_selector (USHORT selector,
			USHORT real_seg, USHORT real_off)
{
	if (set_segment_base_addr (selector, real_seg, real_off) < 0)
	{
		ServerDebug("/ether: Failed to set segment base address") ;
		return(-1);
	}
	if (set_segment_limit (selector) < 0)
	{
		ServerDebug("/ether: Failed to set segment limit") ;
		return(-1);
	}

	return 0 ;
}
/*}}}*/
/*{{{  DPMI_getvect() */
/*
------------------------------------------------------------------------------
*/

PRIVATE word DPMI_getvect (USHORT int_no, USHORT selector)
{
	void *vec_ptr ;

	if (get_real_int_vector (int_no, &SEG_real_int_handler, 
				&OFF_real_int_handler) < 0)
	{
		ServerDebug("/ether: Failed to get real mode interrupt vector") ;
		return(-1);
	}

	if (init_selector (selector, 
			SEG_real_int_handler, OFF_real_int_handler) < 0)
	{
		ServerDebug("/ether: Failed to initialize selector") ;
		return(-1);
	}

	FP_SEG (vec_ptr) = selector ;
	FP_OFF (vec_ptr) = 0 ;

	return (word) (vec_ptr) ;
}
/*}}}*/
d311 1
d320 58
d602 9
a610 2
#define CHECK_SIGNATURE	((strncmp ((byte *) (drvr_vec + 3) , DRVR_SIG, strlen (DRVR_SIG)) == 0) ? TRUE : FALSE) 

d613 5
a617 26
	word drvr_vec ;

#if !MSWINDOWS
	drvr_vec = (word) _dos_getvect (int_no) ;
	return CHECK_SIGNATURE ;
#else /* MSWINDOWS */
	USHORT base_selector ;
	SHORT result ;

	if (allocate_descriptor (&base_selector) < 0)
	{
		ServerDebug("Failed to allocate descriptor") ;
		return(-1);
	}

	drvr_vec = DPMI_getvect (int_no, base_selector) ;
	if (drvr_vec < 0)
		return (-1) ;

	result = CHECK_SIGNATURE ;
	
	if (free_descriptor (&base_selector) < 0)
		ServerDebug("/ether: Warning: failed to release descriptor") ;

	return (result) ;
#endif /* MSWINDOWS */
d619 1
d907 1
a907 1
    
a965 1

@


1.5
log
@Major reorganisation of the ethernet code to try and get it working
properly under Windows
@
text
@d15 1
a15 1
/* RcsId: $Id: ether.c,v 1.4 1992/06/19 09:47:31 bart Exp $ */
d150 1
a155 1
	byte            rx_buffer [MAX_PKT_TABLE] [MAXETHERPKT] ;
d159 2
a160 2
PRIVATE USHORT wSegment = 0 ;
PRIVATE USHORT wSelector = 0 ;
d204 3
a206 3
	wSegment		= HIWORD(dMem);
	wSelector		= LOWORD(dMem);
	FP_SEG(DOS_data)	= wSelector;
d208 1
a208 1

d211 1
a211 1
	tempptr = (byte *) &receiver;
d244 1
a244 1
		GlobalDosFree(wSelector);
d490 1
a490 1
	sregs.ds = wSelector ;
a496 106
/*{{{  DPMI_callback() */
/*
------------------------------------------------------------------------------
*/

PRIVATE SHORT rcvr_index = 0 ;

/*
-- crf: this routine is fundamentally equivalent to PROC receiver in pcasm.cpp
*/

void DPMI_callback ()
{
	real_reg_struct *real_regs = &DOS_data->callback_regs ;

/*
-- DPMI spec. v1.0 p. 36
-- set proper address for resumption of real mode execution
*/
	real_regs->_cs = SEG_real_int_handler ;
	real_regs->_ip = OFF_real_int_handler ;

/*
;	======================================================================
;	Which call is this ? If 1st (AX == 0), return pointer to buffer in
;	ES:DI. If second (AX == 1), the packet has been copied into the 
;	buffer
;	======================================================================
*/
	if (real_regs->_ax == 0)
	{
/*
;	======================================================================
;	1st call (AX == 0)
;	Enter with CX == packet length
;	Return pointer to buffer in ES:DI
;	======================================================================

;	======================================================================
;	Check for buffer overflow
;	======================================================================
*/
		if (pkt_rcvd == MAX_PKT_TABLE)
		{
			goto discard_pkt ;
		}

/*
;	======================================================================
;	Check if packet will fit into buffer
;	======================================================================
*/
		if ((SHORT) real_regs->_cx > MAXETHERPKT)
		{
			pkt_too_long = (SHORT) real_regs->_cx ;
			goto discard_pkt ;
		}

/*
;	======================================================================
;	Put packet length into pkt_len vector
;	======================================================================
*/
		pkt_len [rcvr_index] = (SHORT) real_regs->_cx ;

/*
;	======================================================================
;	Set pointer to buffer in ES:DI
;	======================================================================
*/
		{
			byte *rx_ptr = DOS_data->rx_buffer [rcvr_index] ;
			real_regs->_es = wSegment ;
			real_regs->_di = FP_OFF (rx_ptr) ;
		}
	}
	else
	{
/*
;	======================================================================
;	2nd call (AX == 1)
;	Packet has been copied into buffer
;	======================================================================

;	======================================================================
;	Increment index (with wrap around) and packet count
;	======================================================================
*/
		rcvr_index = ++rcvr_index % MAX_PKT_TABLE ;
		pkt_rcvd ++ ;
	}

	return ;

/*
;	======================================================================
;	Error - return 0:0 in ES:DI
;	(pkt driver will throw packet away ...)
;	======================================================================
*/

discard_pkt:
		real_regs->_es = 0 ;
		real_regs->_di = 0 ;
}
/*}}}*/
d618 1
a618 1
	sregs.ds	= wSegment ;
d660 1
a660 1
	sregs.es	= wSegment ;
d713 1
a713 1
	sregs.ds = wSegment ;
@


1.4
log
@Major upgrade to V3.91:
 1) C40 support
 2) now runs under Helios and under Windows
@
text
@d15 1
a15 1
/* RcsId: $Id: ether.c,v 1.3 1992/06/14 14:47:30 craig Exp $ */
d19 5
d25 5
a29 5
#ifdef OLD_ETHER
#define MAXETHERPKT 1514
#else /* !OLD_ETHER */
#define LEN_ETHER_ADDR	8
#endif /* !OLD_ETHER */
d31 36
a66 6
PRIVATE bool     ethernet = false;      /* do we have ethernet */       
#ifdef OLD_ETHER
PRIVATE unsigned int etherbase;         /* ether io port     */
PRIVATE long ethermem;                  /* ether ram address */
PRIVATE int      ethersize;             /* size of ether ram */
#endif /* OLD_ETHER */
d68 7
a74 5
#ifdef OLD_ETHER
PRIVATE unsigned char etheraddr[8];             /* ether net addr    */
#else /* !OLD_ETHER */
PRIVATE unsigned char etheraddr[LEN_ETHER_ADDR];	/* ether net addr    */
#endif /* !OLD_ETHER */
a75 7
#ifdef OLD_ETHER
PRIVATE unsigned char ethermult[8];             /* multicast address */
PRIVATE unsigned char etherrcr;         /* ether receive config */
PRIVATE int      etherlevel;            /* ether interrupt level */     
PRIVATE int ethertype;			/* what type of board    */
PRIVATE byte etherbuff[MAXETHERPKT];           /* place to store a mess */
#endif /* OLD_ETHER */
d77 5
a81 1
#include "esupport.c"
d83 3
a85 3
#ifndef OLD_ETHER
PRIVATE byte etherbuff[MAXETHERPKT];           /* place to store a mess */
#endif /* !OLD_ETHER */
d87 866
a957 3
#ifdef OLD_ETHER
        byte Addr[8];
#else /* !OLD_ETHER */
a958 1
#endif /* !OLD_ETHER */
d965 6
a970 1
PRIVATE NetInfo mynetinfo;
d972 9
a980 2
void Ether_InitServer(myco)
Conode *myco;
d982 7
a988 2
	/* BLV - all the work has been moved to testfun */
  use(myco)
d991 1
a991 1
void Ether_TidyServer(Conode *myco)
d993 2
a994 3
  /* if (ethernet) restore_int_vector(); */
  tidyboard();
  use(myco)
d996 2
a997 1

d1000 6
a1005 9
{ word temp;
  char *board;
  
  if (!get_config("ETHERNET"))
   { *result = 0L; return; }

#ifdef OLD_ETHER
  if ((temp = get_int_config("ETHERBASE")) == Invalid_config)
   etherbase = 0xFF;
d1007 1
a1007 1
   etherbase = (unsigned int) temp;
a1008 61
  if ((ethermem = get_int_config("ETHERMEM")) == Invalid_config)
   ethermem = -1;

  if ((temp = get_int_config("ETHERRCR")) == Invalid_config)
   etherrcr = 0x04;	/* default is accept broadcast */
  else 
   etherrcr = (unsigned char) temp;

  if ((temp = get_int_config("ETHERLEVEL")) == Invalid_config)
   etherlevel = -1;
  else
   etherlevel = (int) temp;
#else /* !OLD_ETHER */
  if ((temp = get_int_config (HOST_PKT_INT)) == Invalid_config)
    pkt_int_no = -1 ;
  else
    pkt_int_no = (int) temp;
#endif /* !OLD_ETHER */

#ifdef OLD_ETHER
  board = get_config("ETHERTYPE");
  if (board eq (char *)NULL)
   ethertype = -1;
  elif (!mystrcmp(board, "WD8003E"))
   ethertype = BT_WESTERN_DIGITAL;
  elif (!mystrcmp(board, "DLINK"))
   ethertype = BT_DLINK;
  else
   { ServerDebug("I/O Server : unknown ethernet board %s", board);
     ServerDebug("           : supported boards are WD8003E and DLINK");
     ethertype = -1;
   }
#endif /* OLD_ETHER */

#ifdef OLD_ETHER
  if (!etherboardp()) 
#else /* !OLD_ETHER */
  if (!clarksonp()) 
#endif /* !OLD_ETHER */
   { *result = 0L;
#ifdef OLD_ETHER
     ServerDebug("I/O Server : /ether device not found");
     ServerDebug("I/O Server : base %x, mem %lx, etherrcr %d, level %d, type %d",
             etherbase, ethermem, etherrcr, etherlevel, ethertype);
#endif /* OLD_ETHER */
     return;
   }

#ifdef OLD_ETHER     
#ifdef ETHERDEBUG    	
      ServerDebug("/ether - Ethernet found at %04x %8lx", etherbase, ethermem);
      ServerDebug("/ether - RCR %02x INTLEV %d", etherrcr, etherlevel);
      ServerDebug("/ether - Address %02x%02x%02x%02x%02x%02x\n",  
                   etheraddr[0], etheraddr[1],  etheraddr[2],        
                   etheraddr[3], etheraddr[4], etheraddr[5]);        
#endif                   
/*      init_int_vector(); */
#endif /* OLD_ETHER */

  ethernet = true;
  *result  = 1L;
d1010 2
a1011 1

d1025 2
a1026 7

void Ether_SetAttr(Conode *myco)
{
  Request_Return(EC_Error + SS_IOProc + EG_WrongFn + EO_Server, 0L, 0L);
  use(myco)
}

d1041 2
a1042 2


d1051 2
a1052 2


d1067 1
a1067 5
#ifdef OLD_ETHER
    ServerDebug("/ether - write Bad pkt Size");
#else /* !OLD_ETHER */
    notify ("TX error - bad packet size (%d bytes)", asked);
#endif /* !OLD_ETHER */
d1120 1
a1120 10
#ifdef OLD_ETHER
  ether_something();
#endif /* OLD_ETHER */

#ifdef OLD_ETHER
  unless (SendTxPkt(mcb->Data,actual)) 
#else /* !OLD_ETHER */
  unless (SendTxPkt(mcb->Data, (USHORT) actual)) 
#endif /* !OLD_ETHER */

d1140 1
a1140 9
#ifdef OLD_ETHER
      ether_something();						/* poll int handler */
#endif /* OLD_ETHER */

#ifdef OLD_ETHER
      if (SendTxPkt(etherbuff,actual)) break;
#else /* !OLD_ETHER */
      if (SendTxPkt(etherbuff, (USHORT) actual)) break;
#endif /* !OLD_ETHER */
d1152 6
d1159 4
d1164 21
d1199 5
a1204 3
#ifdef OLD_ETHER
	ether_something();
#endif /* OLD_ETHER */
a1205 13
#ifdef OLD_ETHER
    if (RxAvail())
#else /* !OLD_ETHER */
/*
-- crf: not by any means the best way to handle rx errors. However, sufficient
-- for our needs.
*/
    if (pkt_too_long
#ifdef ETHER_DEBUG
			|| pkt_overflow
#endif /* ETHER_DEBUG */
)
	notify_rx_error () ;
a1206 1
#endif /* !OLD_ETHER */
a1211 4
#ifdef OLD_ETHER
    if (ResetMe) resetboard();
#endif /* OLD_ETHER */

d1236 3
a1238 3
  
}

@


1.3
log
@Added support for Clarkson pkt drivers (compile with /DOLD_ETHER for
original code)
@
text
@d15 1
a15 1
/* RcsId: $Id: ether.c,v 1.2 1991/11/22 18:06:03 martyn Exp craig $ */
d22 3
a24 1
#endif /* OLD_ETHER */
d26 1
a26 1
PRIVATE bool     ethernet = FALSE;      /* do we have ethernet */       
d32 2
d35 4
d44 1
a44 1
PRIVATE BYTE etherbuff[MAXETHERPKT];           /* place to store a mess */
d50 1
a50 1
PRIVATE BYTE etherbuff[MAXETHERPKT];           /* place to store a mess */
d58 1
d60 3
d86 2
a87 2
WORD* result;
{ WORD temp;
d158 1
a158 1
  ethernet = TRUE;
d172 1
a172 1
  Request_Return(0L,0L,(WORD)sizeof(NetInfo));
d333 3
a335 3
  WORD time_interval = divlong(mcb->Control[ReadTimeout_off],time_unit);
  WORD got;
  WORD toget = (mcb->Control)[ReadSize_off];
@


1.2
log
@changed MAXETHERPKT from 1500 to 1514 for nfs !
@
text
@d15 1
a15 1
/* RcsId: $Id: ether.c,v 1.1 1990/10/17 12:18:36 alan Exp martyn $ */
d20 1
d22 1
d25 1
d29 1
d31 1
d37 1
d41 4
d81 1
d99 6
d106 1
d119 1
d121 1
d123 3
d127 1
d129 1
a129 1
ServerDebug("I/O Server : base %x, mem %lx, etherrcr %d, level %d, type %d",
d131 1
d134 2
a135 1
     
d144 1
d210 1
d212 3
d266 2
d269 3
a271 1
  
d273 4
d295 2
d298 3
d302 3
d332 2
d335 3
d339 13
d357 1
d359 1
a387 2


@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
/* RcsId: $Id$ */
d20 2
d31 1
a31 1
PRIVATE BYTE etherbuff[1500];           /* place to store a mess */
a46 2
#define MAXETHERPKT 1500

d177 1
a177 1
  /* Ethernet has a limit of 1500 bytes on a pkt */
@
