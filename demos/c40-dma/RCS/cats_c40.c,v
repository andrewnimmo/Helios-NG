head	1.4;
access;
symbols;
locks; strict;
comment	@ * @;


1.4
date	93.11.26.09.55.46;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	93.08.26.08.28.48;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	93.08.20.09.34.50;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	93.08.20.09.22.40;	author nickc;	state Exp;
branches;
next	;


desc
@Source file for the C40 DMA code
@


1.4
log
@New Version from Ken
@
text
@/*
    CATS_C40.C Direct, low level C40 routines for Helios v1.3x
    Copyright (C) 1993  Ken Blackler, JET Joint Undertaking

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
    
    The author can be contacted by EMail as: kb@@jet.uk
    or at:
    
    		Ken Blackler
    		JET Joint Undertaking
    		Abingdon
    		Oxfordshire
    		England
    		OX14 3EA
    
*/


                                                                             /*
ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍJET Joint UndertakingÍÍÍÍÍÍÍÍÍÍÍ»
º                                                                            º
º                  MODULE: cats_c40.c                                        º
º                                                                            º
º                 PURPOSE: General purpose low-level C40 specific routines   º
º                                                                            º
º    MODIFICATION HISTORY:                                                   º
º                                                                            º
º    Version        Date       Author    Comments                            º
º    -------     -----------   ------    --------                            º
º      1.0      10-Dec-1992 K.Blackler  Original Issue                       º
º      1.01     24-Aug-1993 K.Blackler  Sorted out includes                  º
º      1.1      24-Aug-1993 K.Blackler  Implement DMA snchronization on xCRDYº
º                                                                            º
º         Without this change, when the DMA processor writes to a COM port   º
º         that has a full FIFO it stops and waits until it isn't full        º
º         NO DMA TRANSFERS TAKE PLACE ON ANY CHANNEL SO LONG AS THAT         º
º         FIFO IS FULL.                                                      º         
º         By synch'ing COM port accesses to the COM port ready lines the DMA º
º         doesn't even try and write until it gets the xCRDY interrupt.      º
º         This enables the processor to communicate via its other links and  º
º         stops Helios thinking the processor has locked up. Yuck.           º
º                                                                            º
º      1.2      24-Oct-1993 K.Blackler  Change to using Helios's MP_xxxxxxx  º
º                                       functions 'cause direct C pointers   º
º                                       don't work with my large >32Mb C40.  º
º     **** Second public release version 22/11/1993 ****                     º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍkb@@jet.ukÍÍÍÍÍ¼ */

#include "catsutil.h"
#include "cats_c40.h"

#include <stdio.h>
#include <stdlib.h>
#include <syslib.h>
#include <process.h>
#include <config.h>
#include <link.h>
#include <nonansi.h>

#if defined(_DEBUG_C40)
#define C40_SIMPLE_RW_TIMEOUT 10000
#endif


static const char ModuleName[]="CATS_C40 Module";
                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄJET Joint UndertakingÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: MachineInfo                                       ³
³                                                                            ³
³                 PURPOSE: Gets the cluster and name of the current processor³
³                          pCluster and pName must be at least NameLength    ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0       5-May-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
void MachineInfo(char *pCluster,char *pName)
{
 char pMachineName[NameMax*2+3];
 char *pString;
 MachineName(pMachineName);
 
 ASSERT(pMachineName[0]==c_dirchar);
 
 pString=pMachineName+1; /* Skip the initial '/' */
 if (pCluster!=NULL)
   {
     pString+=splitname(pCluster,c_dirchar,pString);
   }
 else
   {
     while ( (*pString!='/') && *pString )
       pString++;
   }
 if (pName!=NULL)
   {
     splitname(pName,c_dirchar,pString);
   }
}


                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄJET Joint UndertakingÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40MemoryDump                                     ³
³                                                                            ³
³                 PURPOSE: Displays the contents of memory                   ³
³                                                                            ³
³                          The routine uses machine pointers to refer        ³
³                          to any location in memory, the contents of        ³
³                          which are displayed in both hexadecimal and       ³
³                          character form.                                   ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0       3-Nov-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
void C40MemoryDump(C40ADDRESS SourceAddress,int nWords)
{
  int i,j,k;
  union
    {
      WORD32 wData;
      char   cData[4];
    } Data;
  
  for (i=0; i<nWords; i+=5)
    {
      printf("%08lX ",SourceAddress+i);
      for (j=i; j<i+5; j++)
        {
          if (j>nWords)
            {
              printf(".. .. .. .. ");
            }
          else
            {
		          Data.wData=MP_GetWord(SourceAddress,j);
		          for (k=1; k<4; k++)
		            {
		              printf("%02x ",((int)Data.cData[k])&0xff);
		            }
		        }
		    }   
		    
      putchar('\"');  
      for (j=i; j<i+5; j++)
        {
          if (j>nWords)
            {
              printf("....");
            }
					else
					  {
		          Data.wData=MP_GetWord(SourceAddress,j);
			        for (k=1; k<4; k++)
			          {
					        (Data.cData[k]<' ') ? putchar('.') : putchar(Data.cData[k]);
			          }
					  }            
        }
      putchar('\"'); putchar('\n');
    }
}



static LinkInfo saveLinkConf[6];  /* NLinks LinkConf structs  */

                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄJET Joint UndertakingÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: AllocateLink                                      ³
³                                                                            ³
³                 PURPOSE: Sets a specified link to dumb mode                ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      16-Mar-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

BOOL AllocateLink(C40COMPORT nComPort)
{
  LinkConf newconf;

  if (nComPort>c40com5)
    {
      ModuleMessage(ModuleName,"ERROR - Attempted to Allocate and Invalid comport");
      ASSERT(FALSE);
      return(FALSE);
    }
  /* First save the current link configuration */
  LinkData(nComPort,&saveLinkConf[nComPort]);

#if defined(_DEBUG_C40)
  printf("%s\tAllocating COM port #%d",ModuleName,nComPort);
#endif
  newconf.Id = nComPort;
  newconf.Mode = Link_Mode_Dumb;
  newconf.State = Link_State_Dumb;
  if (Configure(newconf)!=0)
    {
      return(FALSE);
    }

  while (AllocLink(nComPort)==0)
    {
#if defined(_DEBUG_C40)
      printf("\\\b/\b-\b");
#else
      ;        
#endif
    }
#if defined(_DEBUG_C40)
      printf(": Done\n");
#endif      
  return(TRUE);
}
                                                                              /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄJET Joint UndertakingÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: DeAllocateLink                                    ³
³                                                                            ³
³                 PURPOSE: Returns a link from dump to active mode           ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      16-Mar-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

BOOL DeAllocateLink(C40COMPORT nComPort)
{
  LinkConf oldconf;

#if defined(_DEBUG_C40)
  printf("%s\tDeAllocating COM port #%d\n",ModuleName,nComPort);
#endif

  if (FreeLink(nComPort)!=0) return(FALSE);

  /* Now restore the old link configuration */
  
  oldconf.Id =    nComPort;
  oldconf.Mode =  saveLinkConf[nComPort].Mode;
  oldconf.State = saveLinkConf[nComPort].State;
  
  if (Configure(oldconf)!=0) return(FALSE);

return(TRUE);
}

                                                                              /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄJET Joint UndertakingÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40GetDIE                                         ³
³                                                                            ³
³                 PURPOSE: Returns the DMA Interrupt Enable register         ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      16-Mar-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
/* Helios uses R0 as the first parameter AND the return value */
static UNIFIEDDIE C40GetDIE(long dummy) /* dummy gives me a way to get at register R0 */
{
  long DIE;
                             
  _word(0x8000016);   /* LDI DIE,R0 */
  DIE=dummy;          /* Which is magically now DIE, given a favourable optimizer! */
  return *((UNIFIEDDIE *)&DIE);
}

                                                                              /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄJET Joint UndertakingÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40SetDIE                                         ³
³                                                                            ³
³                 PURPOSE: Sets the DMA Interrupt Enable register            ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      16-Mar-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
static void C40SetDIE(UNIFIEDDIE newDIE)
{
  _word(0x8160000);   /* LDI R0,DIE */

#if defined(_DEBUG_C40)
  printf("%s - Setting DIE Register: %lx\n",ModuleName,newDIE);
#endif
}

                                                                              /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄJET Joint UndertakingÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40GetIIE                                         ³
³                                                                            ³
³                 PURPOSE: Returns the Interrupt Enable register             ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      16-Mar-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
static IIE C40GetIIE(long dummy) /* dummy gives me a way to get at register R0 */
{
  long iie;
                             
  _word(0x8000017);   /* LDI IIE,R0 */
  iie=dummy;          /* Which is magically now IIE, given a favourable optimizer! */
  return *((IIE *)&iie);
}

                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40CreateUnifinedModeTransferExC40                ³
³                                                                            ³
³                 PURPOSE: Sets up a complex unified DMA transfer            ³
³                          The buffer is specified as a C40ADDRESS           ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0       3-Nov-1993 K.Blackler  Modification of routine              ³
³                                       C40CreateUnifinedModeTransferEx      ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
void C40CreateUnifiedModeTransferExC40(int fDirection,PUNIFIEDCHANNELCONTROL pControl,C40ADDRESS pBuffer,
	                                     int nBytes,unsigned idCom, word wPriority,
	                                     BOOL bInterrupt, word wCarryOn,int nSkip)
{
  ASSERT(idCom<6);
  
  ASSERT( (nBytes & BIN_11) == 0); /* Check no one tries to send bytes..... */
  ASSERT( ( nSkip & BIN_11) == 0);
  
  pControl->TransferCounter         = nBytes/4;
  pControl->LinkPointer             = NULL;

  if (fDirection==AT_TO_COMPORT)
    { 
      pControl->SourceAddress           = pBuffer;
      pControl->SourceAddressIndex      = nSkip/4;
      pControl->DestinationAddress      = C40_COMPORT_BASEADDRESS+2 + idCom * 0x10L;
      pControl->DestinationAddressIndex = 0;  /* A single address so no inc. */
      pControl->ControlReg.bSourceSynch=FALSE;
      pControl->ControlReg.bDestinationSynch=TRUE; /* Don't write until the COM port is ready */
    }
  else /* from the COM port */
    {
      pControl->SourceAddress           = C40_COMPORT_BASEADDRESS+1 + idCom * 0x10L;
      pControl->SourceAddressIndex      = 0;  /* A single address so no inc. */
      pControl->DestinationAddress      = pBuffer; 
      pControl->DestinationAddressIndex = nSkip/4;
      pControl->ControlReg.bSourceSynch=TRUE; /* Don't read until the COM port is ready */
      pControl->ControlReg.bDestinationSynch=FALSE;
    }

  pControl->ControlReg.Priority = (int)wPriority&BIN_11;

  pControl->ControlReg.TransferMode = (int)wCarryOn&BIN_11; /* What to do after this transfer is over */

  pControl->ControlReg.bIntOnFinish=bInterrupt;


  pControl->ControlReg.bAutoInitStatic=FALSE;
  pControl->ControlReg.bAutoInitSynch=FALSE; /* Don't need this,init from memory */

  pControl->ControlReg.bReadBitReversed=FALSE;
  pControl->ControlReg.bWriteBitReversed=FALSE;

  pControl->ControlReg.bSplitMode=FALSE;
  pControl->ControlReg.bStart=DMA_START_START;
  pControl->ControlReg.bFixedPriority=FALSE;


}
                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40CreateUnifinedModeTransferEx                   ³
³                                                                            ³
³                 PURPOSE: Sets up a complex unified DMA transfer            ³
³                          The buffer is specified as a C pointer            ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      21-Sep-1993 K.Blackler  Modification of routine              ³
³                                       C40CreateUnifinedModeTransfer        ³
³      1.1      24-Oct-1993 K.Blackler  Change to using MP_ fuctions         ³
³      1.2       3-Nov-1993 K.Blackler  Use C40ADDRESS routine above -       ³
³                                       getting deeper all the time!         ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
void C40CreateUnifiedModeTransferEx(int fDirection,PUNIFIEDCHANNELCONTROL pControl,void *pBuffer,
                                    int nBytes,unsigned idCom, word wPriority,
                                    BOOL bInterrupt, word wCarryOn,int nSkip)
{
  C40CreateUnifiedModeTransferExC40(fDirection,pControl,C40WordAddress(pBuffer),
	                                  nBytes,idCom, wPriority,
	                                  bInterrupt, wCarryOn,nSkip);
}
                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40CreateUnifinedModeTransfer                     ³
³                                                                            ³
³                 PURPOSE: Sets up a unified DMA transfer                    ³
³                          The buffer increment defaults to a word           ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      09-Mar-1993 K.Blackler  Original Issue                       ³
³      1.1      24-Aug-1993 K.Blackler  Implement DMA snchronization on xCRDY³
³      1.2      21-Sep-1993 K.Blackler  Use Extended routine above           ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */


void C40CreateUnifiedModeTransfer(int fDirection,PUNIFIEDCHANNELCONTROL pControl,
                                  void *pBuffer,int nBytes,unsigned idCom,
                                  word wPriority, BOOL bInterrupt, word wCarryOn)
{
  C40CreateUnifiedModeTransferEx(fDirection,pControl,pBuffer,nBytes,idCom,
                                 wPriority, bInterrupt, wCarryOn,4);
}

                                                                              /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40SetUnifiedTransferLink                         ³
³                                                                            ³
³                 PURPOSE: Links two DMA transfers so the engine goes from   ³
³                          one to the other automatically                    ³
³                          A null link makes the transfer non-initiailising  ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      09-Mar-1993 K.Blackler  Original Issue                       ³
³      1.1      22-Sep-1993 K.Blackler  Make a NULL link change prevent the  ³
³                                       transfer from auto initialising      ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

void C40SetUnifiedTransferLink(PUNIFIEDCHANNELCONTROL pControl,
                               PUNIFIEDCHANNELCONTROL pNextControl)
{
  if (pNextControl!=NULL)
    pControl->LinkPointer=C40WordAddress(pNextControl);
  else
    { /* Will simply stop after this one */
      pControl->ControlReg.TransferMode = DMA_MODE_STOPNOAUTOINIT; 
      pControl->LinkPointer=C40WordAddress(NULL);
    }
}

                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40StartLinkedTransfers                           ³
³                                                                            ³
³                 PURPOSE: Starts the linked list of transfers               ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      09-Mar-1993 K.Blackler  Original Issue                       ³
³      1.1      24-Aug-1993 K.Blackler  Implement DMA snchronization on xCRDY³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */


void C40StartLinkedTransfers(C40COMPORT DMAChanNo,
                             PUNIFIEDCHANNELCONTROL pLinkedControlList)
{
  union
    {
      UNIFIEDDMACONTROLREG DMAcontrolReg;
      WORD32 Overlay;
    } ControlRegister;

  UNIFIEDDIE DIE;

  ASSERT (DMAChanNo >=0 && DMAChanNo<=5);

  ControlRegister.Overlay=MP_GetWord(C40_DMA_BASEADDRESS, (word)DMAChanNo * 0x10);

  /* First set the control Register so that this DMA is stopped */
  ControlRegister.DMAcontrolReg.bStart         = DMA_START_RESET;
                           
  MP_PutWord(C40_DMA_BASEADDRESS, (word)DMAChanNo * 0x10, ControlRegister.Overlay);

  /* Now set it up to a good starting point so it settles down.... */

  ControlRegister.DMAcontrolReg.bSplitMode        = FALSE;
  ControlRegister.DMAcontrolReg.bFixedPriority    = FALSE;
  ControlRegister.DMAcontrolReg.Priority          = DMA_PRIORITY_TODMA;  /*Get it finished*/

  ControlRegister.DMAcontrolReg.TransferMode      = DMA_MODE_STOPNOAUTOINIT;
  ControlRegister.DMAcontrolReg.bSourceSynch      = TRUE; /* Just to prevent any lock ups*/
  ControlRegister.DMAcontrolReg.bDestinationSynch = TRUE;
  ControlRegister.DMAcontrolReg.bAutoInitStatic   = FALSE;
  ControlRegister.DMAcontrolReg.bAutoInitSynch    = FALSE;
  ControlRegister.DMAcontrolReg.bWriteBitReversed = FALSE;
  ControlRegister.DMAcontrolReg.bReadBitReversed  = FALSE;
  ControlRegister.DMAcontrolReg.bIntOnFinish      = FALSE;
  ControlRegister.DMAcontrolReg.sTransferFinished = 0;
  ControlRegister.DMAcontrolReg.bStart            = DMA_START_RESET;
  ControlRegister.DMAcontrolReg.sStatus           = 0;

  MP_PutWord(C40_DMA_BASEADDRESS, (word)DMAChanNo * 0x10, ControlRegister.Overlay);

  DIE=C40GetDIE(0);
  
  switch(DMAChanNo) /* Enable the DMA (non-vectored) xCRDY interrupt. Note that */
    {               /* I do both here, 'cause I don't want to have to check the */
      case 0:       /* direction of all the transfers. Don't see any problems...*/
        DIE.DMA0Write=UDIE_ENABLE_COMPORTREADY;
        DIE.DMA0Read=UDIE_ENABLE_COMPORTREADY;
        break;
      case 1:
        DIE.DMA1Write=UDIE_ENABLE_COMPORTREADY;
        DIE.DMA1Read=UDIE_ENABLE_COMPORTREADY;
        break;
      case 2:
        DIE.DMA2Write=UDIE_ENABLE_COMPORTREADY;
        DIE.DMA2Read=UDIE_ENABLE_COMPORTREADY;
        break;
      case 3:
        DIE.DMA3Write=UDIE_ENABLE_COMPORTREADY;
        DIE.DMA3Read=UDIE_ENABLE_COMPORTREADY;
        break;
      case 4:
        DIE.DMA4Write=UDIE_ENABLE_COMPORTREADY;
        DIE.DMA4Read=UDIE_ENABLE_COMPORTREADY;
        break;
      case 5:
        DIE.DMA5Write=UDIE_ENABLE_COMPORTREADY;
        DIE.DMA5Read=UDIE_ENABLE_COMPORTREADY;
        break;
    }

  C40SetDIE(DIE); /* Enable the DMA interrupts now */
  

  /* Now 'manually' enter all the values for the first transfer */
  ControlRegister.DMAcontrolReg=pLinkedControlList[0].ControlReg;
  
  /*
  1: pLinkedControlList[0].SourceAddress;
  2: pLinkedControlList[0].SourceAddressIndex;
  3: pLinkedControlList[0].TransferCounter;
  4: pLinkedControlList[0].DestinationAddress;
  5: pLinkedControlList[0].DestinationAddressIndex;
  6: pLinkedControlList[0].LinkPointer;
  */
  MP_PutData(C40_DMA_BASEADDRESS+1, (word)DMAChanNo * 0x10, &(pLinkedControlList[0].SourceAddress),6);

  /* Start the transfer */
  ControlRegister.DMAcontrolReg.bStart = DMA_START_START;

  MP_PutWord(C40_DMA_BASEADDRESS, (word)DMAChanNo * 0x10, ControlRegister.Overlay); /* And here they are started */
  return;
}
                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40StopLinkedTransfers                            ³
³                                                                            ³
³                 PURPOSE: Stops the DMA engine dead                         ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      09-Mar-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

void C40StopLinkedTransfers(C40COMPORT DMAChanNo)
{
  union
    {
      UNIFIEDDMACONTROLREG DMAcontrolReg;
      WORD32 Overlay;
    } ControlRegister;
  
  ASSERT (DMAChanNo >=0 && DMAChanNo<=5);
      
  ControlRegister.Overlay=MP_GetWord(C40_DMA_BASEADDRESS, (word)DMAChanNo * 0x10);
  
  /* Now set the control Register so that this DMA is stopped */
  ControlRegister.DMAcontrolReg.bStart         = DMA_START_RESET;

  MP_PutWord(C40_DMA_BASEADDRESS, (word)DMAChanNo * 0x10,ControlRegister.Overlay);

  return;
}

                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40IsDMABusy                                      ³
³                                                                            ³
³                 PURPOSE: Checks to see if the DMA channel is busy          ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      13-Mar-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

word C40IsDMABusy(int DMAChanNo)
{
  WORD32 Counter;
  
  ASSERT (DMAChanNo>=0 && DMAChanNo<=5);
  Counter=MP_GetWord(C40_DMA_BASEADDRESS+3, (word)DMAChanNo * 0x10);

  return(Counter);
}
                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40IsThereSpaceToWrite                            ³
³                                                                            ³
³                 PURPOSE: Checks to see if the comport has space in its     ³
³                          output FIFO so a simple write doesn't hang the    ³
³                          processor until the FIFO empties...               ³
³                          Useful for a low level, non-blocking message      ³
³                          protocol between the C40 and external hardware.   ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      17-Aug-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

int C40IsThereSpaceToWrite(int nComPort)
{
  union
    {
      COMPORTCONTROLREG ControlReg;
      WORD32 Overlay;
    } ControlRegister;

  ASSERT (nComPort>=0 && nComPort<=5);

  ControlRegister.Overlay=MP_GetWord(C40_COMPORT_BASEADDRESS, (word)nComPort * 0x10);
  
  return (ControlRegister.ControlReg.OutputLevel);
}

                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40IsThereDataToRead                              ³
³                                                                            ³
³                 PURPOSE: Checks to see if the com port has data waiting    ³
³                          in the input FIFO. Useful for a low level         ³
³                          non-blocking protocol between external hardware   ³
³                          abd the C40.                                      ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      25-May-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

int C40IsThereDataToRead(int nComPort)
{
  union
    {
      COMPORTCONTROLREG ControlReg;
      WORD32 Overlay;
    } ControlRegister;

  ASSERT (nComPort>=0 && nComPort<=5);

  ControlRegister.Overlay=MP_GetWord(C40_COMPORT_BASEADDRESS, (word)nComPort * 0x10);
  
  return (ControlRegister.ControlReg.InputLevel);
}


                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40SimpleWrite                                    ³
³                                                                            ³
³                 PURPOSE: Performs a very simple blocking write to a        ³
³                          COM port.                                         ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      25-May-1993 K.Blackler  Original Issue                       ³
³      2.0      29-Jun-1993 K.Blackler  Implement a proper DMA transfer      ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */

void C40SimpleWrite(int nCommPort, void *pBuffer, unsigned nWords)
{
#if defined(_DEBUG_C40)
  int iTimeout=C40_SIMPLE_RW_TIMEOUT;
#endif
  static UNIFIEDCHANNELCONTROL TransferControl;

  ASSERT (nCommPort>=0 && nCommPort<=5);

  C40CreateUnifiedModeTransfer(AT_TO_COMPORT,&TransferControl,(void *)pBuffer,
  														 nWords*4,nCommPort,DMA_PRIORITY_EQUAL,FALSE,DMA_MODE_STOPNOAUTOINIT);

  C40StartLinkedTransfers(nCommPort,&TransferControl);
  
#if defined(_DEBUG_C40)
  printf("%s - Comport still busy",ModuleName);
#endif
  while(C40IsDMABusy(nCommPort))
    {
#if defined(_DEBUG_C40)
      if (--iTimeout==0) break;
      printf("\\\b/\b-\b");
#endif
      IdleTillInterrupt();
    } 
#if defined(_DEBUG_C40)
 if (iTimeout==0)
   {
 		 printf("\r%s - Comport timed out. ",ModuleName);
 		 ASSERT(FALSE);
   }
 else
   {  
 		 printf("\r%s - Comport finished.  ",ModuleName);
   }
#endif
}
                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40SimpleRead                                     ³
³                                                                            ³
³                 PURPOSE: Performs a very simple blocking read from a       ³
³                          COM port.                                         ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      25-May-1993 K.Blackler  Original Issue                       ³
³      2.0      29-Jun-1993 K.Blackler  Implement a proper DMA transfer      ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
void C40SimpleRead(int nCommPort, void *pBuffer, unsigned nWords)
{
#if defined(_DEBUG_C40)
  int iTimeout=C40_SIMPLE_RW_TIMEOUT;
#endif
  static UNIFIEDCHANNELCONTROL TransferControl;

  ASSERT (nCommPort>=0 && nCommPort<=5);

  C40CreateUnifiedModeTransfer(AT_FROM_COMPORT,
                               &TransferControl,
                               pBuffer,nWords*4,
                               nCommPort,
                               DMA_PRIORITY_EQUAL,
                               DMA_NOINTERRUPT_ON_COMPLETE,
                               DMA_MODE_STOPNOAUTOINIT);
                               
  C40SetUnifiedTransferLink(&TransferControl,NULL); /* A null link also prevents auto-initialisation */
  C40StartLinkedTransfers(nCommPort,&TransferControl);
  
#if defined(_DEBUG_C40)
  printf("%s - Comport still busy",ModuleName);
#endif
  while(C40IsDMABusy(nCommPort))
    {
#if defined(_DEBUG_C40)
      if (--iTimeout==0) break;
      printf("\\\b/\b-\b");
#endif
      IdleTillInterrupt();
    } 
#if defined(_DEBUG_C40)
 if (iTimeout==0)
   {
 		 printf("\r%s - Comport timed out. ",ModuleName);
 		 ASSERT(FALSE);
   }
 else
   {  
 		 printf("\r%s - Comport finished.  ",ModuleName);
   }
#endif
}

                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: C40ResetComport                                   ³
³                                                                            ³
³                 PURPOSE: Clears out the contents of a comport FIFO         ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      16-Nov-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
void C40ResetComport(int nComPort)
{
  static JunkBuffer[8];
  int nWords=C40IsThereDataToRead(nComPort);

  if (nWords==15) nWords=8;
  
  if (nWords>0)
    {
      C40SimpleRead(nComPort, JunkBuffer, nWords);
      nWords=C40IsThereDataToRead(nComPort); /* Now clear out the other processor's output FIFO */
		  if (nWords==15) nWords=8;
		  
		  if (nWords>0)
		    {
		      C40SimpleRead(nComPort, JunkBuffer, nWords);
		    }
    }

}






















                                                                             /*
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³                                                                            ³
³               PROCEDURE: Various debug routines                            ³
³                                                                            ³
³                 PURPOSE: These are varios routines written when testing    ³
³                          the above.....                                    ³
³                          Useful for seeing what is happening.              ³
³                                                                            ³
³    MODIFICATION HISTORY:                                                   ³
³                                                                            ³
³    Version        Date       Author    Comments                            ³
³    -------     -----------   ------    --------                            ³
³      1.0      24-Oct-1993 K.Blackler  Original Issue                       ³
³                                                                            ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ */
void C40ShowComportControlReg(C40COMPORT nComport)
{
  COMPORTCONTROLREG ControlReg;
  
  MP_GetData(&ControlReg,C40_COMPORT_BASEADDRESS,(word)nComport * 0x10, wordsizeof(COMPORTCONTROLREG));
  
  printf("COMPORT CONTROL REGISTER CONTENTS[%d]\n",nComport);
  printf("\n"
         "\t    PortDirection:%d\n",ControlReg.PortDirection);
  printf("\t InputChannelHalt:%d\n",ControlReg.InputChannelHalt);
  printf("\tOutputChannelHalt:%d\n",ControlReg.OutputChannelHalt);
  printf("\t       InputLevel:%d\n",ControlReg.InputLevel);
  printf("\t      OutputLevel:%d\n",ControlReg.OutputLevel);
}

void C40ShowDMAControlReg(C40COMPORT nComport)
{            
  CHANNELREGISTER ControlRegisters;
  UNIFIEDDMACONTROLREG ControlReg;
  
  MP_GetData(&ControlRegisters,C40_DMA_BASEADDRESS, (word)nComport * 0x10, wordsizeof(CHANNELREGISTER));
  
  ControlReg=ControlRegisters.ControlRegister.UnifiedControlReg;

  printf("DMA CONTROL REGISTER CONTENTS[%d]\n",nComport);
  printf("\n"
         "\t          Priority %d",ControlReg.Priority);
  printf("\t      TransferMode %d",ControlReg.TransferMode);
  printf("\t      bSourceSynch %d\n",ControlReg.bSourceSynch);
  printf("\t bDestinationSynch %d",ControlReg.bDestinationSynch);
  printf("\t   bAutoInitStatic %d",ControlReg.bAutoInitStatic);
  printf("\t    bAutoInitSynch %d\n",ControlReg.bAutoInitSynch);
  printf("\t  bReadBitReversed %d",ControlReg.bReadBitReversed);
  printf("\t bWriteBitReversed %d",ControlReg.bWriteBitReversed);
  printf("\t        bSplitMode %d\n",ControlReg.bSplitMode);
  printf("\t      bIntOnFinish %d",ControlReg.bIntOnFinish);
  printf("\t sTransferFinished %d",ControlReg.sTransferFinished);
  printf("\t            bStart %d\n",ControlReg.bStart);
  printf("\t           sStatus %d",ControlReg.sStatus);
  printf("\t    bFixedPriority %d\n",ControlReg.bFixedPriority);
  
  printf("\n\t           SourceAddress %lx",ControlRegisters.SourceAddress);
  printf("\t      SourceAddressIndex %d\n",ControlRegisters.SourceAddressIndex);
  printf("\t         TransferCounter %d",ControlRegisters.TransferCounter);
  printf("\t      DestinationAddress %lx\n",ControlRegisters.DestinationAddress);
  printf("\t DestinationAddressIndex %d",ControlRegisters.DestinationAddressIndex);
  printf("\t             LinkPointer %lx\n",ControlRegisters.LinkPointer);
  printf("\t      AuxTransferCounter %d",ControlRegisters.AuxTransferCounter);
  printf("\t          AuxLinkPointer %lx\n",ControlRegisters.AuxLinkPointer);
}

void C40ShowIIERegister(void)
{
  IIE iie=C40GetIIE(0);
  WORD32 wordiie=*(WORD32 *)&iie;

  printf("INTERRUPT ENABLE REGISTER CONTENTS: %lx\n",wordiie);
}


@


1.3
log
@New version from Ken Blackler
@
text
@d1 32
a32 1
                                                                              /*
d49 1
a49 2
º         What isn't so obvious from the manual, is that this means          º
º         that NO DMA TRANSFERS TAKE PLACE ON ANY CHANNEL SO LONG AS THAT    º
d56 4
a59 1
º         Now tested with all COM Ports                                      º
d73 6
a78 3
volatile word JunkBuffer;  /* The contents of this buffer are */
                           /* UNDEFINED AT ALL TIMES!         */
                           
d118 72
d205 1
a205 1
BOOL AllocateLink(int nComPort)
d209 12
d230 10
a239 1
        ;
d257 1
a257 1
BOOL DeAllocateLink(int nComPort)
d259 1
a259 1
LinkConf newconf;
d261 3
a263 1
if (FreeLink(nComPort)!=0) return(FALSE);
d265 1
a265 3
newconf.Id = nComPort;
newconf.Mode = Link_Mode_Intelligent;
newconf.State = Link_State_Running;
d267 7
a273 1
if (Configure(newconf)!=0) return(FALSE);
d278 14
d297 3
a299 3
 	_word(0x8000016); 	/* LDI DIE,R0	*/
 	DIE=dummy;          /* Which is magically now DIE, given a favourable optimizer! */
 	return *((UNIFIEDDIE *)&DIE);
d302 14
d318 28
a345 1
 	_word(0x8160000); 	/* LDI R0,DIE	*/
d351 1
a351 1
³               PROCEDURE: C40CreateUnifinedModeTransfer                     ³
d353 2
a354 1
³                 PURPOSE: Sets up a unified DMA transfer                    ³
d360 2
a361 2
³      1.0      09-Mar-1993 K.Blackler  Original Issue                       ³
³      1.1      24-Aug-1993 K.Blackler  Implement DMA snchronization on xCRDY³
d364 3
a366 3


void C40CreateUnifiedModeTransfer(int fDirection,PUNIFIEDCHANNELCONTROL pControl,void *pBuffer,int nBytes,unsigned idCom, word wPriority, BOOL bInterrupt, BOOL bCarryOn)
d370 3
d377 4
a380 4
    {
      pControl->SourceAddress           = C40Address(pBuffer);
      pControl->SourceAddressIndex      = 1;
      pControl->DestinationAddress      = 0x00100042L + idCom * 0x10L;
d382 2
a383 2
		  pControl->ControlReg.bSourceSynch=FALSE;
		  pControl->ControlReg.bDestinationSynch=TRUE; /* Don't write until the COM port is ready */
d387 1
a387 1
      pControl->SourceAddress           = 0x00100041L + idCom * 0x10L;
d389 4
a392 4
      pControl->DestinationAddress      = C40Address(pBuffer);
      pControl->DestinationAddressIndex = 1;
		  pControl->ControlReg.bSourceSynch=TRUE; /* Don't read until the COM port is ready */
		  pControl->ControlReg.bDestinationSynch=FALSE;
d397 1
a397 8
  if (bCarryOn)
    {
      pControl->ControlReg.TransferMode = DMA_MODE_AUTOINIT; /* Carry on to next transfer */
    }
  else
    {
      pControl->ControlReg.TransferMode = DMA_MODE_AUTOINITANDSTOP; /* Will be restarted by interrupt routine */
    }
d399 1
a399 8
  if (bInterrupt)
    {
      pControl->ControlReg.bIntOnFinish=TRUE;
    }
  else
    {
      pControl->ControlReg.bIntOnFinish=FALSE;
    }
d403 1
a403 1
  pControl->ControlReg.bAutoInitSynch=FALSE; /* Don't seem to need this */
d412 53
d474 1
d481 2
d486 2
a487 1
void C40SetUnifiedTransferLink(PUNIFIEDCHANNELCONTROL pControl,PUNIFIEDCHANNELCONTROL pNextControl)
d489 7
a495 1
  pControl->LinkPointer=C40Address(pNextControl);
a497 2


d515 2
a516 1
void C40StartLinkedTransfers(int DMAChanNo,PUNIFIEDCHANNELCONTROL pLinkedControlList)
d518 6
a523 2
  volatile UNIFIEDCHANNELCONTROL *pChannelRegister;
  UNIFIEDDMACONTROLREG DMAcontrolReg;
d528 1
a528 3
  pChannelRegister=(UNIFIEDCHANNELCONTROL *)C40CAddress(0x001000A0 + (word)DMAChanNo*0x10);

  DMAcontrolReg=pChannelRegister->ControlReg;
d531 3
a533 2
  DMAcontrolReg.bStart         = DMA_START_RESET;
  pChannelRegister->ControlReg=DMAcontrolReg;
d537 15
a551 15
  DMAcontrolReg.bSplitMode        = FALSE;
  DMAcontrolReg.bFixedPriority    = FALSE;
  DMAcontrolReg.Priority          = DMA_PRIORITY_TODMA;/*DMA_PRIORITY_EQUAL;*/

  DMAcontrolReg.TransferMode      = DMA_MODE_STOPBUTNOAUTOINIT;
  DMAcontrolReg.bSourceSynch      = FALSE;
  DMAcontrolReg.bDestinationSynch = FALSE;
  DMAcontrolReg.bAutoInitStatic   = FALSE;
  DMAcontrolReg.bAutoInitSynch    = FALSE;
  DMAcontrolReg.bWriteBitReversed = FALSE;
  DMAcontrolReg.bReadBitReversed  = FALSE;
  DMAcontrolReg.bIntOnFinish      = FALSE;
  DMAcontrolReg.sTransferFinished = 0;
  DMAcontrolReg.bStart            = DMA_START_RESET;
  DMAcontrolReg.sStatus           = 0;
d553 1
a553 1
  pChannelRegister->ControlReg=DMAcontrolReg;
d589 11
a599 10
  DMAcontrolReg=pLinkedControlList[0].ControlReg;
  DMAcontrolReg.bStart = DMA_START_RESET;

  pChannelRegister->SourceAddress      = pLinkedControlList[0].SourceAddress;
  pChannelRegister->SourceAddressIndex = pLinkedControlList[0].SourceAddressIndex;
  pChannelRegister->TransferCounter    = pLinkedControlList[0].TransferCounter;
  pChannelRegister->DestinationAddress = pLinkedControlList[0].DestinationAddress;
  pChannelRegister->DestinationAddressIndex = pLinkedControlList[0].DestinationAddressIndex;
  pChannelRegister->LinkPointer = pLinkedControlList[0].LinkPointer;

d602 1
a602 2
  DMAcontrolReg.bStart = DMA_START_START;
  pChannelRegister->ControlReg=DMAcontrolReg; /* And here they are started */
d604 1
a606 2


d622 1
a622 1
void C40StopLinkedTransfers(int DMAChanNo)
d624 6
a629 3
  volatile UNIFIEDCHANNELCONTROL *pChannelRegister;
  UNIFIEDDMACONTROLREG DMAcontrolReg;

d631 5
d637 1
a637 1
  pChannelRegister=(UNIFIEDCHANNELCONTROL *)C40CAddress(0x001000A0 + (word)DMAChanNo*0x10);
a638 6
  DMAcontrolReg=pChannelRegister->ControlReg;

  /* Now set the control Register so that this DMA is stopped */
  DMAcontrolReg.bStart         = DMA_START_RESET;
  pChannelRegister->ControlReg=DMAcontrolReg;

d659 1
a659 1
  volatile word *pCounter;
d662 1
d664 1
a664 2
  pCounter=(word *)C40CAddress(0x01000a3 + 0x10 * (word)DMAChanNo);
  return(*pCounter);
d672 4
a675 1
³                          output FIFO.                                      ³
d685 1
a685 1
int C40IsThereSpaceToWrite(int nCommPort)
d687 5
a691 1
  volatile COMPORTCONTROLREG *pComPortControlRegister;
d693 1
a693 1
  ASSERT (nCommPort>=0 && nCommPort<=5);
d695 3
a697 3
  pComPortControlRegister=(COMPORTCONTROLREG *)C40CAddress(0x00100040 + (word)nCommPort*0x10);

  return (pComPortControlRegister->OutputLevel);
d706 3
d718 1
a718 1
int C40IsThereDataToRead(int nCommPort)
d720 5
a724 1
  volatile COMPORTCONTROLREG *pComPortControlRegister;
d726 1
a726 1
  ASSERT (nCommPort>=0 && nCommPort<=5);
d728 3
a730 3
  pComPortControlRegister=(COMPORTCONTROLREG *)C40CAddress(0x00100040 + (word)nCommPort*0x10);

  return (pComPortControlRegister->InputLevel);
d739 2
a740 1
³                 PURPOSE: Performs a very simple write to a comm port       ³
d751 1
a751 1
void C40SimpleWrite(int nCommPort, word *pBuffer, size_t nWords)
d753 3
d760 2
a761 1
  C40CreateUnifiedModeTransfer(AT_TO_COMPORT,&TransferControl,(void *)pBuffer,nWords*4,nCommPort,DMA_PRIORITY_EQUAL,FALSE,FALSE);
a762 1
  /*C40SetUnifiedTransferLink(&TransferControl,&TransferControl);*/ /* Just in-case, link with self */
d765 3
d770 4
d776 11
d793 2
a794 1
³                 PURPOSE: Performs a very simple read from a comm port      ³
d804 1
a804 1
void C40SimpleRead(int nCommPort, word *pBuffer, size_t nWords)
d806 3
d813 9
a821 2
  C40CreateUnifiedModeTransfer(AT_FROM_COMPORT,&TransferControl,pBuffer,nWords*4,nCommPort,DMA_PRIORITY_EQUAL,FALSE,FALSE);
  /*C40SetUnifiedTransferLink(&TransferControl,&TransferControl);*/ /* Just in-case, link with self */
d824 3
d829 4
d835 142
d978 2
@


1.2
log
@added copyright message
@
text
@a0 4
/* NB/ This code is distributed under the terms of the GNU Public License,
   version2.  Please see the file COPYING for more details.
   This code was written by Ken Blackler at the JET project.
 */
d7 1
a7 3
º                          (general except that they are currently only      º
º                          tested on COM0/DMA0. Other ports will need some   º
º                          tweaking in the interrupt handler)                º
d13 12
a24 1
º      To Do!   August-1993 K.Blackler  Upgrade to work with all comports    º
d26 2
a27 1
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼ */
d29 2
a30 5
#if defined(NOTJET)
#include "cats-pub.h"
#else
#include "cats.h"
#endif
d143 14
d170 1
d175 1
a175 10
static void
C40CreateUnifiedModeTransfer(
			     int 			fDirection,
			     PUNIFIEDCHANNELCONTROL	pControl,
			     void *			pBuffer,
			     int			nBytes,
			     unsigned			idCom,
			     word			wPriority,
			     BOOL			bInterrupt,
			     BOOL			bCarryOn)
d178 3
a180 3

  pControl->TransferCounter         = nBytes / 4;
  pControl->LinkPointer             = C40Address( NULL );
d182 1
a182 1
  if (fDirection == AT_TO_COMPORT)
d188 2
d191 1
a191 1
  else
d197 2
a220 2
  pControl->ControlReg.bSourceSynch      = FALSE;
  pControl->ControlReg.bDestinationSynch = FALSE;
d222 2
a223 2
  pControl->ControlReg.bAutoInitStatic   = FALSE;
  pControl->ControlReg.bAutoInitSynch    = FALSE;
d225 2
a226 2
  pControl->ControlReg.bReadBitReversed  = FALSE;
  pControl->ControlReg.bWriteBitReversed = FALSE;
d228 3
a230 3
  pControl->ControlReg.bSplitMode        = FALSE;
  pControl->ControlReg.bStart            = DMA_START_START;
  pControl->ControlReg.bFixedPriority    = FALSE;
d269 1
d274 1
a274 4
static void
C40StartLinkedTransfers(
			int 			DMAChanNo,
			PUNIFIEDCHANNELCONTROL	pLinkedControlList )
d278 1
d310 33
d362 2
a363 1
                                                                            /*
d378 1
a378 2
static void
C40StopLinkedTransfers(int DMAChanNo)
a419 17

#if defined(NEVER)

BOOL C40IsDMABusy(word DMAChanNo)
{
  volatile UNIFIEDCHANNELCONTROL *pChannelRegister;

  ASSERT (DMAChanNo >=0 && DMAChanNo<=5);

  pChannelRegister=(UNIFIEDCHANNELCONTROL *)C40CAddress(0x01000A0 + DMAChanNo*0x10);

  
  return (pChannelRegister->TransferCounter);
  /*return (pChannelRegister->ControlReg.bStart==BIN_11);*/
}
#endif

@


1.1
log
@Initial revision
@
text
@d1 4
@
