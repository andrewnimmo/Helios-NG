head	1.15;
access;
symbols
	Helios_1_3_1:1.15
	Helios_C40_1_3_Official_Release:1.14
	Alenia_release:1.14
	C40_Field_Test_2:1.14
	C40_Field_Test_R1:1.12;
locks; strict;
comment	@-- @;


1.15
date	93.07.22.15.12.18;	author richardp;	state Exp;
branches;
next	1.14;

1.14
date	92.10.14.14.44.56;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	92.08.04.18.33.14;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	92.05.22.10.31.15;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	92.03.25.14.10.43;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	92.03.20.18.37.33;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	92.03.17.18.17.27;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	92.03.16.16.44.20;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	92.03.16.16.36.46;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	92.03.16.15.47.33;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	92.03.11.17.57.49;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	92.03.10.15.45.35;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	92.03.10.14.19.17;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	92.02.26.17.00.02;	author paul;	state Exp;
branches;
next	1.1;

1.1
date	92.02.26.09.49.17;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.15
log
@first full assembler version of maths library
@
text
@;  C40 assembler version of the maths library
;  Started life as 1.3 version in "C" with a assembler subroutines
;  converted to assembler using the -S option of the "C" compiler
;  generated by Norcroft Helios C40 C 350/350/stl/2/tla
;                               [May 12 1993, 16:55:02]
;  then foo'd bar by Richard Parker   July 1 - July 20 1993
;
;==================frexp===============================================
;
;     double frexp ( double x , int * expnt )
;     0.5 <= return value < 1 ,  x = (2^expnt) * return
;
.frexp:
.foo:
 ASH    -24, R0              ;  shift exponent to make an integer
 LSH3   -2 , R2 , AR5        ;  convert byte displacement to word one
 CMPI   -128 , R0            ;  e=-128 means number is zero
 Beq    frexp0               ;  so go to frexp(0) special code
 ADDI   1 , R0               ;  add 1 to exponent to get proper result
 BuD    R11                  ;  start going back to the caller
    STI    R0 , *+AR5(IR0)   ;  and put exponent where user suggested
    LDF    0.75 , R0         ;  set exponent to -1
    LDI    R1 , R0           ;  then just blat new signed mantissa=old
;          return takes effect here
;
;          special code for the case x = 0.0
frexp0:
 BuD    R11                  ;  start going back to the caller
    LDI    0 , R1            ;  clear a register to zero (integer)
    LDF    0.0 , R0          ;  set return to floating point zero
    STI    R1 , *+AR5(IR0)   ;  set exponent to zero
;          return takes effect here
;
;=====================================================================
;
;     RAP Sine and Cosine routines
;

 word  0x01490fda      ; -10   pi
 word  0x490fdaa2      ;  -9

 word  0xde5be6fe      ;  -8   1e-10

 word  0xef15777a      ;  -7   8.908910206761537356617e-6
 word  0x15777a5d      ;  -6   =  3217/1024 - pi

 word  0xfe22f983      ;  -5   1/pi
 word  0x22f9836f      ;  -4

 word  0x1d6e6b28      ;  -3   1e9

 word  0x00490fda      ;  -2   pi/2
 word  0x490fdaa2      ;  -1

contab:
 word  0xd7d00000      ;   0   r7

 word  0xdf309231      ;   1   r6    1/13!

 word  0xe6a8cdd5      ;   2   r5   -1/11!

 word  0xed38ef1d      ;   3   r4    1/9!
 word  0x38ef1d2a      ;   4

 word  0xf3aff2ff      ;   5   r3   -1/7!
 word  0xaff2ff30      ;   6

 word  0xf9088888      ;   7   r2    1/5!
 word  0x08888889      ;   8

 word  0xfdd55555      ;   9   r1   -1/3!
 word  0xd5555555      ;  10

;
;    double cos ( double x )
;
.cos:
 LDI    R11, AR2             ;  Save return address - we want to LAJ
 LAJ    cos0                 ;  set R11 to a known address
    LDF    1.0, R6           ;  set sign as +ve in case it is
    STI    R0 , *-\-AR6(1)    ;  reassemble the input argument by
    LDF    *AR6++(1), R0     ;  saving as int and restoring as Float
cos0:                        ;  (Now R11 points here - earlier LAJ)
 LDI    R1 , R0              ;  complete reassembly of input x
 ABSF   R0                   ;  Make input positive
 SUBI3  cos0-contab,R11,AR5  ;  adjust R11 so AR5 points to contab
 LDF    0.5, R7              ;  cosine is 0.5 * PI shifted from sine
 BuD    sinecos              ;  Then go calculate a basic sine
    LDF    *-AR5(10),R10     ;  Setting R10 = pi while we wait
    LDI    *-AR5(9),R10      ;  for the delayed branch to happen
    ADDF3  R0,R10,R1         ;  R1 is pi up on R0 for cosine
;
;    double sin ( double x )
;
.sin:
 LDI    R11, AR2             ;  save R11 so we can use LAJ
 LAJ    sin0                 ;  Set R11 to a know address (sin0)
    STI    R0 , *-\-AR6(1)    ;  Start reassembling the input x
    LDF    *AR6++(1), R0     ;  by putting int and getting float back
    LDI    R1 , R0           ;  complete reassembly of the input x
sin0:                        ;  label for LAJ above,  so R11 is set
 CMPF   0.0,R0               ;  check to see if x is negative
 BgeD   sin1                 ;  if not,  jump over the two NEGFs
    SUBI3  sin0-contab,R11,AR5 ; meanwhile adjust R11 to point to contab
    LDF    1.0, R6           ;  final answer is multiplied by R6
    LDF    0.0, R7           ;  sine is 0.0 * pi shifted from sine!
 NEGF   R0                   ;      negates x if it was negative
 NEGF   R6                   ;      and also negate answer at the end
sin1:                        ;  label for branching over NEGFs
 LDF    *-AR5(2),R10         ;  Setting R10 = pi/2
 LDI    *-AR5(1),R10         ;      full 40 bit accurate pi/2
 ADDF3  R0,R10,R1            ;      R1 is pi/2 up on R0 for sine
;                   then drop through into basic sine routine sinecos.
;
;    sine and cosine routines come together here
;    R0  the number we want the sine or cos of (+ve)
;    R1  (less accurately) the number we want the - cosine of (+ve)
;    R6  +1 or -1,  to multiply the answer by
;    R7  0.0 for sine or 0.5 for cosine
;   AR5  points to contab  (table of constants)
;
sinecos:                     ;
 LDF    *-AR5(3),R2          ;  Load 1e9 (1,000,000,000) int R2
 CMPF   R2 , R1              ;  check if R1 is bigger than that!
 Bge    retn0s               ;  if so,  return zero
 LDF    *-AR5(5) , R3        ;  Set R3 to 1/pi
 LDI    *-AR5(4) , R3        ;      reassembling the full 40 bit
 MPYF3  R1 , R3, R2          ;  multiply input by 1/pi
 FIX    R2 , R3              ;  convert that to an integer
 FLOAT  R3 , R2              ;  and re-float it
 AND    0x1, R3              ;  look to see if it is odd
 BeqD   L6F6                 ;  negate final answer if it is odd
 SUBF   R7, R2               ;  Shift Cosine so R2 integer/2
 ;
 ;    At this point,  we have an outstanding delayed branch which
 ;    determines whether the NEGF will be executed.  The R6 in the
 ;    following formula refers to the R6 at L6R6 - after this
 ;    NEGF has been executed or skipped.
 ;
 ;    R2 is an integer or half-integer
 ;    and we want to return  R6 * ( sine ( R0 - R2*PI )
 ;
 LDF    R2 , R3              ;  Make a copy of R2
 MPYF   3.1416015625, R3     ;  multiply by 3217/1024
;    prevous multiplication will be exact if R2 was < 500000 ish
 NEGF   R6                   ;  The delayed NEGF odd no of pi
L6F6:                        ;  label for branching round NEGF
 SUBF   R3 , R0              ;  R0 = R0 - ( R2 * 3217/1024)
 LDF    *-AR5(7),R3          ;  load up an accurate
 LDI    *-AR5(6),R3          ;  3217/1024 - pi
 MPYF   R3 , R2              ;  Multiply R2 by (3217/1024 - pi)
 ADDF   R2,R0                ;  and add that to R0 - R2 * 3217/1024
;                            ;  so now R0 has had R2 * PI taken from it
;
;    At this point,  we want to calculate the sine of R0,
;        which is in the range -pi/2 to pi/2,
;        and then return R6 times this to the user
;
 ABSF   R0,R1
 MPYF3  R1,R1,R1             ;  Square R0 to get x**2
 CMPF   *-AR5(8) , R1        ;  Compare x**2 to 1e-10
 Blt    sinecos3             ;  if less,  sin(x) = x
;
;   The formula used is
;
;
; sin(x) = x  -  x^3  +  x^5  -  x^7  +  x^9  -  x^11  +  x^13  -  x^15
;                ---     ---     ---     ---     ----     ----     ----
;                 3!      5!      7!      9!      11!      13!      15!
;  rewritten as
;
; sin(x) = x + x * boggle(x^2),   where
;
; boggle(y) = ((((((-1/15!*y+1/13!)*y-1/11!)*y+1/9!)*y-1/7!)
;                   *y+1/5!)*y-1/3!)*y
;
; R0 = x    and    R1 is x^2
;
;   First we calculate boggle(x^2)

 MPYF3  *AR5++(1),R1,R3      ; r7 = -1/15! = -1/130767368000

 ADDF   *AR5++(1),R3         ; r6 = 1/13! = 1/6227020800
 MPYF   R1,R3

 ADDF   *AR5++(1),R3         ; r5 = -1/11! = -1/39916800
 MPYF   R1,R3

 LDF    *AR5++(1),R2         ; r4 = 1/9! = 1/362880
 LDI    *AR5++(1),R2
 ADDF   R2,R3
 MPYF   R1,R3

 LDF    *AR5++(1),R2         ; r3 = -1/7!  = -1/5040
 LDI    *AR5++(1),R2
 ADDF   R2,R3
 MPYF   R1,R3

 LDF    *AR5++(1),R2         ; r2 = 1/5! = 1/120
 LDI    *AR5++(1),R2
 ADDF   R2,R3
 MPYF   R1,R3

 LDF    *AR5++(1),R2         ; r1 = -1/3! = -1/6
 LDI    *AR5++(1),R2
 ADDF   R2,R3
 MPYF   R1,R3                ;  so R3 is boggle(x^2)

 LDI    AR2, R11             ;  reload return address from stack
 BuD    R11                  ;  and start going back to caller
    MPYF3  R3,R0,R1          ;  R1 = x*boggle(x^2)
    ADDF   R1,R0             ;  R0 = x + x*boggle(x^2)
    MPYF   R6,R0             ;  change sign of answer if necessary
;             Return (BuD R11) takes effect here
;
sinecos3:                    ;  used for x < 1e-5 so sin(x) = x
 MPYF   R6,R0                ;  negate answer if necessary
 LDI    AR2, R11             ;  reload return address
 Bu     R11                  ;  and return to the caller
;
;=====================================================================
;
;    double exp ( double x )
;

exptab:

 word  0x0038aa3b            ;   0    1.44269504088...  1/log(2)
 word  0x38aa3b29            ;   1

 word  0xf3a17f7d            ;   2    -0.00021219444   log(2) - 355/512
 word  0xa17f7d1d            ;   3

 word  0xf00a9523            ;   4    0.000016520330   p2
 word  0x0a95237b            ;   5

 word  0xf8638723            ;   6    0.006943600015   p1
 word  0x6387237e            ;   7

 word  0xf501fccb            ;   8    0.000495862884   q2
 word  0x01fccb7f            ;   9

 word  0xfb638c73            ;  10    0.055553866696   q1
 word  0x638c738a            ;  11

 word  0xdd000000            ;  12    2 ^ -35

 word  0x06317217            ;  13    128 * log(2)
 word  0x317217f8            ;  14

exp9:                        ;  if x^2 < 2^-35,  we come here
 LDI    AR2 , R11            ;  restore the return address
 BuD    R11                  ;  Start returning to the user
    LDF    1.0 , R1          ;  with the value 1.0
    ADDF   R1 , R0           ;                     + x
    NOP                      ;  wait for delayed branch
.exp:
 LDI    R11, AR2             ;  save return address - we use LAJ
 LAJ    exp0                 ;  so get R11 pointing somewhere near here
 STI    R0 , *-\-AR6(1)       ;  convert the input double into a
 LDF    *AR6++(1), R0        ;  40 bit register - register 0
 LDI    R1 , R0              ;  complete the reassembly of input
exp0:                        ;  for LAJ - R11 points here now
 SUBI3  exp0-exptab,R11,AR5  ;  AR5 now points to exptab constants
 LDF    *+AR5(13),R10        ;  get maximum input that we can do
 LDI    *+AR5(14),R10        ;  as double
 CMPF   R10 , R0             ;  and look that our input is smaller
 Bgt    huerans              ;  return huge with ERANGE errno if not
 NEGF   R10                  ;  get -128 * log(2) = minimum input
 CMPF   R10 , R0             ;  and look that our input is smaller
 Blt    retn0s               ;  return 0.0 if so
 MPYF3  R0 , R0 , R7         ;  R7 = x^2  Square the number
 LDF    *+AR5(12),R10        ;  since we use different method for tiny nos
 CMPF   R10 , R7             ;  is input squared < 2^-35
 Blt    exp9                 ;  and return 1 + x if it is
 LDF    *AR5 , R10           ;
 LDI    *+AR5(1) , R10       ;  R10 = 1/log(2)
 MPYF   R10 , R0 , R1        ;  R1  = x/log2
 ADDF   0.5 , R1             ;  R1  = 0.5 + x/log2
 FIX    R1 , R2              ;  R2  = nearest integer to x/log2
 FLOAT  R2 , R1              ;  R1  = nearest integer to x/log2
 LDF    R1 , R7              ;  R7  = same
 MPYF   0.693359375 , R7     ;  R7  = integer * 355/512
 SUBF   R7 , R0              ;  subtract that off
 LDF    *+AR5(2) , R10       ;
 LDI    *+AR5(3) , R10       ;  R10 = log(2) - 355/512
 MPYF   R10 , R1             ;  multiply integer by that
 SUBF   R1 , R0              ;  R0 = g
;
;            so now input x has been decomposed as
;            R2 ( an integer )  and  R0 ( a float -0.35 < R0 < 0.35)
;            where     x  =  R2 * log(2) + R0
;            exp(x) is therefore  2^R2 * exp(R0)
;
 MPYF3  R0 , R0 , R1         ;  R1 = z = g*g
 LDF    *+AR5(4),R10         ;  p2
 LDI    *+AR5(5),R10
 MPYF3  R1 , R10 , R7        ;  p2*z
 LDF    *+AR5(6),R10         ;  p1
 LDI    *+AR5(7),R10
 ADDF   R10 , R7             ;  p2*z+p1
 MPYF   R1 , R7              ;  (p2*z+p1)*z
 ADDF   0.25 , R7
 MPYF   R0 , R7              ;  R7 = gp = ( (p2*z+p1)*z+0.25 )*g
 LDF    *+AR5(8),R10         ;  q2
 LDI    *+AR5(9),R10
 MPYF3  R1 , R10 , R3        ;  q2*z
 LDF    *+AR5(10),R10        ;  q1
 LDI    *+AR5(11),R10
 ADDF   R10 , R3             ;  q2*z+q1
 MPYF   R1 , R3              ;  (q2*z+q1)*z
 ADDF   0.5 , R3             ;  R3 = q = (q2*z+q1)*z+0.5
 SUBF   R7 , R3              ;  R3 = q-gp
 RCPF   R3 , R10             ;  R10 = 1/R3 + d
 MPYF3  R3 , R10, R6         ;  R6  = 1 + d.R3
 SUBRF  2.000000, R6         ;  R6  = 1 - d.R3
 MPYF   R6 , R10             ;  R10 = 1/R3 + e
 MPYF3  R3 , R10, R6         ;  R6  = 1 + e.R3
 SUBRF  2.000000, R6         ;  R6  = 1 - e.R3
 MPYF   R6 , R10             ;  R10 = 1/R3 + f
 MPYF3  R3 , R10, R6         ;  R6  = 1 + f.R3
 SUBRF  1.000000, R6         ;  R6  = -f.R3
 MPYF   R10, R6              ;  R6  = -f
 ADDF   R6 , R10             ;  R10 = 1/R3
 MPYF3  R10 , R7 , R0        ;  gp / (q-gp)
 ADDF   0.5 , R0
 ADDI   1 , R2
 LDI    R0 , R1
 STF    R0 , *-\-AR6(1)       ;  disassemble the input argument by
 LDI    *AR6++(1), R0        ;  saving as float and restoring as int
 LDI    AR2 , R11            ;  put return address back
;
;              and drop into ldexp
;
;=====================================================================
;
;    double ldexp ( double x , int N )
;          returns x * 2^N
;
.ldexp:
 ASH    -24, R0              ;  shift exponent to make an integer
 CMPI   -128 , R0            ;  e=-128 means number is zero
 Beq    retn0                ;  so return the value 0.0
 ADDI   R0 , R2              ;  add to the given exponent
 CMPI   -128, R2             ;  is the answer too small now ?
 Ble    retn0                ;  if so,  just return zero
 CMPI   127, R2              ;  has the result overflowed
 Bgt    ldexp1               ;  if so,  sort out the mess
 ASH    24 , R2              ;  Shift exponent back into place
 BuD    R11                  ;  start going back to the user
    STI    R2 , *-\-AR6(1)    ;  convert number to a float
    LDF    *AR6++(1), R0     ;  by storing I and loading F
    LDI    R1 , R0           ;  then put sign and mantissa back
;                 Return takes place here
retn0s:
 LDI    AR2,R11
retn0:
 LDF    0.0 , R0
 Bu     R11
ldexp1:
 ASH    -31,R1
 Beq    huedom
 Bu     nhedom
;=====================================================================
;
;    double log ( double x );

logtab:

 word  0xff3504f3            ;  0     0.70710678118   sqrt(0.5)
 word  0x3504f334            ;  1

 word  0xffb5df52            ;  2     a2  -0.7895611288749
 word  0xb5df5265            ;  3

 word  0x04031251            ;  4     a1    16.383943563
 word  0x03125101            ;  5

 word  0x06ffc007            ;  6     a0    -64.1249434237
 word  0xffc0076a            ;  7

 word  0x05f153fd            ;  8     b2    -35.667977739034
 word  0xf153fda5            ;  9

 word  0x081c041f            ; 10     b1    312.03222091924
 word  0x1c041fd1            ; 11

 word  0x09bfa00b            ; 12     b0   -769.49932108494
 word  0xbfa00b20            ; 13

 word  0xf3a17f7d            ; 14     -0.00021219444005
 word  0xa17f7d1d            ; 15     = log(2) - 355/512

 word  0xfe5e5bd8            ; 16     log   (e)
 word  0x5e5bd8aa            ; 17        10


.log10:
 LDI    R11, AR2             ;  save return address - we use LAJ
 LAJ    log10a               ;  so get R11 pointing somewhere near here
 STI    R0 , *-\-AR6(1)       ;      convert x into register 2
 LDF    *AR6++(1), R2        ;      by saving on stack and restoring
 LDI    R1 , R2              ;  R2 is x
log10a:                      ;  for LAJ - R11 points here now
 BuD    logs                 ;  common code between log and log10
 SUBI   log10a-logtab,R11,AR5;  AR5 now points to logtab constants
 LDF    *+AR5(16),R11        ;  log to base 10 so multiply by 0.434
 LDI    *+AR5(17),R11        ;

.log:
;
 LDI    R11, AR2             ;  save return address - we use LAJ
 LAJ    log0                 ;  so get R11 pointing somewhere near here
 STI    R0 , *-\-AR6(1)       ;      convert x into register 2
 LDF    *AR6++(1), R2        ;      by saving on stack and restoring
 LDI    R1 , R2              ;  R2 is x
log0:                        ;  for LAJ - R11 points here now
 SUBI3  log0-logtab,R11,AR5  ;  R11 now points to logtab constants
 LDF    1.0,R11              ;  log to base e so multiply by 1 at end
;
;     log and log10 come together here.
;     we want to return R11 * logn(R2).  AR5 points to logtab
;     return address is top of AR6 stack
;
logs:
 CMPF   0.0, R2              ;      is x less than zero
 Blt    nhedoms              ;      if so,  -huge,  EDOM
 ASH    -24, R0              ;  R0 is exponent of x
 CMPI   -128 , R0            ;      is x any sort of zero?
 Beq    nherans              ;      -huge , ERANGE if so
 ADDI   1  , R0              ;  R0 is n = frexp type exponent
 LDF    0.75 , R3            ;      set exponent of f to -1
 LDI    R1 , R3              ;  R3 is f with 1 > f >= 0.5
;                            ;    and x = R3 * 2^R0
 LDF    *AR5 , R10           ;
 LDI    *+AR5(1) , R10       ;  R10 = sqrt ( 0.5 )
 LDF    R3 , R2              ;  R2 = R3 = f
 CMPF   R10,R3               ;  check size of f
 Bgt    log1                 ;
;                            ;  1 > f > 1/r2
 SUBI   1 , R0               ;  n -= 1
 SUBF   0.5 , R2          ;  R2 is znum
 BuD    log2
    LDF    R2 , R3 
    MPYF   0.5 , R3
    ADDF   0.5 , R3          ;  R3 is zden
log1:
 SUBF   0.5 , R2
 SUBF   0.5 , R2             ;  R2 is znum
 MPYF   0.5 , R3
 ADDF   0.5 , R3             ;  R3 is zden
log2:
 RCPF   R3 , R10             ;  R10 = 1/R3 + d
 MPYF3  R3 , R10, R6         ;  R6  = 1 + d.R3
 SUBRF  2.000000, R6         ;  R6  = 1 - d.R3
 MPYF   R6 , R10             ;  R10 = 1/R3 + e
 MPYF3  R3 , R10, R6         ;  R6  = 1 + e.R3
 SUBRF  2.000000, R6         ;  R6  = 1 - e.R3
 MPYF   R6 , R10             ;  R10 = 1/R3 + f
 MPYF3  R3 , R10, R6         ;  R6  = 1 + f.R3
 SUBRF  1.000000, R6         ;  R6  = -f.R3
 MPYF   R10, R6              ;  R6  = -f
 ADDF   R6 , R10             ;  R10 = 1/R3
 MPYF   R10 , R2             ;  R2 is z
 MPYF3  R2 , R2 , R3         ;  R3 is w
 LDF    *+AR5(8),R10         ;  b2
 LDI    *+AR5(9),R10
 ADDF3  R3,R10,R1
 MPYF   R3,R1
 LDF    *+AR5(10),R10        ;  b1
 LDI    *+AR5(11),R10
 ADDF   R10,R1
 MPYF   R3,R1
 LDF    *+AR5(12),R10        ;  b0
 LDI    *+AR5(13),R10
 ADDF   R10,R1

 RCPF   R1 , R10             ;  R10 = 1/R1 + d
 MPYF3  R1 , R10, R6         ;  R6  = 1 + d.R1
 SUBRF  2.000000, R6         ;  R6  = 1 - d.R1
 MPYF   R6 , R10             ;  R10 = 1/R1 + e
 MPYF3  R1 , R10, R6         ;  R6  = 1 + e.R1
 SUBRF  2.000000, R6         ;  R6  = 1 - e.R1
 MPYF   R6 , R10             ;  R10 = 1/R1 + f
 MPYF3  R1 , R10, R6         ;  R6  = 1 + f.R1
 SUBRF  1.000000, R6         ;  R6  = -f.R1
 MPYF   R10, R6              ;  R6  = -f
 ADDF3  R6,R10,R7            ;  R10 = 1/R1

 LDF    *+AR5(2),R10         ;  a2
 LDI    *+AR5(3),R10
 MPYF3  R3,R10,R1
 LDF    *+AR5(4),R10         ;  a1
 LDI    *+AR5(5),R10
 ADDF   R10,R1
 MPYF   R3,R1
 LDF    *+AR5(6),R10         ;  a0
 LDI    *+AR5(7),R10
 ADDF   R10,R1
 MPYF   R1,R7
 MPYF   R3,R7
 MPYF   R2,R7
 ADDF   R7,R2
 FLOAT  R0
 LDF    R0,R1
 MPYF   0.693359375, R1
 LDF    *+AR5(14),R10        ;  -2.1219e-4 = log(2)-355/512
 LDI    *+AR5(15),R10
 MPYF   R10,R0
 ADDF   R2,R0
 ADDF   R1,R0
 MPYF   R11,R0
 LDI    AR2 , R11
 Bu     R11
;
;=====================================================================
;    double sqrt ( double x );
;
.sqrt:
 STI    R0 , *-\-AR6(1)       ;    Convert x from 2-register to
 LDF    *AR6++(1), R0        ;    1 register format by storing on stack
 LDI    R1 , R0              ;  R0 is x.  The number we wish to sqrt
 CMPF   0.0, R0              ;    If x <= 0 we take special action
 BleD   sqrt3

 RSQRF  R0,R1            ; So R1 is approx 1/r
 RCPF   R1,R2            ; R2 is approx r (call it r+d)
 MPYF   0.5,R1           ; R1 now approx 1/2r

 MPYF3  R2,R2,R3         ; R3 is (r+d)**2 = r**2 + 2rd
 SUBF   R0,R3            ; R3 is 2rd
 MPYF   R1,R3            ; R3 is d
 SUBF   R3,R2            ; R2 is a better r (call it r+d again)

 MPYF3  R2,R2,R3         ; R3 is (r+d)**2 = r**2 + 2rd
 SUBF   R0,R3            ; R3 is 2rd
 MPYF   R1,R3            ; R3 is d
 SUBF   R3,R2            ; R2 is a better r (call it r+d again)

 MPYF3  R2,R2,R3         ; R3 is (r+d)**2 = r**2 + 2rd
 SUBF   R0,R3            ; R3 is 2rd
 MPYF   R1,R3            ; R3 is d
 SUBF   R3,R2            ; R2 is a better r (call it r+d again)

 MPYF3  R2,R2,R3         ; R3 is (r+d)**2 = r**2 + 2rd
 SUBF   R0,R3            ; R3 is 2rd
 MPYF   R1,R3            ; R3 is d
 SUBF   R3,R2            ; R2 is final approx
 MPYF3  R2,R2,R3         ; R3 should be R0
 LDF    R2,R1            ; Get a copy of R2
 SUBI   1,R1             ; And make it a little smaller (it is +ve)
 LDFlt  R2,R1            ; If it was zero (now -1) DON'T DO IT
 BuD    R11
 CMPF   R0,R3            ; How is root^2 compared with input
 LDFgt  R1,R2
 LDF    R2,R0
;
sqrt3:
 CMPF   0.0 , R0
 Beq    R11
 Bu     nhedom
;       Return - hugeval set EDOM into errno
nhedoms:
 LDI    AR2,R11
nhedom:
 LDHI   0x7f00, RS
 STI    RS , *-\-AR6(1)
 LDF    *AR6++(1), R0
 LDHI   0x8000, R0
 OR     0x0001, R0
edom:
;    get 8 as return value in errno
 LDIu   8  , R1
ERRNOUT:
 LDA    AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI    *AR3, R3
 BuD    R11
    ADDI   RS , R3
    LSH3   -2 , R3 , AR2
    STI    R1 , *++AR2(IR0)
;       Return + hugeval set EDOM into errno
huedoms:
 LDI    AR2,R11
huedom:
 LDHI   0x7f00, RS
 STI    RS , *-\-AR6(1)
 LDF    *AR6++(1), R0
 LDHI   0x7fff, R0
 OR     0xffff, R0
 Bu     edom

nherans:
 LDI    AR2,R11
nheran:
 LDHI   0x7f00, RS
 STI    RS , *-\-AR6(1)
 LDF    *AR6++(1), R0
 LDHI   0x8000, R0
 OR     0x0001, R0
 Bu     eran
huerans:
 LDI    AR2,R11
hueran:
 LDHI   0x7f00, RS
 STI    RS , *-\-AR6(1)
 LDF    *AR6++(1), R0
 LDHI   0x7fff, R0
 OR     0xffff, R0
eran:
 LDIu   32 , R1
 Bu     ERRNOUT

;=====================================================================
;
.fabs:
 STI    R0 , *-\-AR6(1)       ;  reassemble the input parameter
 BuD    R11                  ;  Start returning to the user
 LDF    *AR6++(1), R0        ;  by storing int and loading float
 LDI    R1 , R0              ;  complete reassembly of input
 ABSF   R0                   ;  take absolute value
;
;=====================================================================

._invert:
;
;       double _invert( double number );
;
 STI    R0 , *-\-AR6(1)       ;  reassemble the input parameter
 LDF    *AR6++(1), R0        ;  by storing int and loading float
 LDI    R1 , R0              ;  complete reassembly of input
 RCPF   R0 , R10             ;  R10 = 1/R0 + d
 MPYF3  R0 , R10, R6         ;  R6  = 1 + d.R0
 SUBRF  2.000000, R6         ;  R6  = 1 - d.R0
 MPYF   R6 , R10             ;  R10 = 1/R0 + e
 MPYF3  R0 , R10, R6         ;  R6  = 1 + e.R0
 SUBRF  2.000000, R6         ;  R6  = 1 - e.R0
 MPYF   R6 , R10             ;  R10 = 1/R0 + f
 MPYF3  R0 , R10, R6         ;  R6  = 1 + f.R0
 BuD    R11                  ; start going back to the user
 SUBRF  1.000000, R6         ;  R6  = -f.R0
 MPYF   R10, R6              ;  R6  = -f
 ADDF3  R6,R10,R0            ;  R1 = 1/R0

;
;=====================================================================
;
;       double   fmod ( double x , double y )
;                 returns x mod y
;
.fmod:
 STI    R0 , *-\-AR6(1)       ;  reassemble the input argument by
 LDF    *AR6++(1), R0        ;  saving as int and restoring as Float
 LDI    R1 , R0              ;  complete reassembly of input x
 STI    R2 , *-\-AR6(1)       ;  reassemble the other input argument by
 LDF    *AR6++(1), R2        ;  saving as int and restoring as Float
 LDI    R3 , R2              ;  complete reassembly of input y
 ABSF   R2                   ;  make y positive
 Beq    retn0                ;  return 0 if y is zero
 LDI    0,R7
 CMPF   0.0,R0               ;  return 0 also if x is zero
 Beq    R11
 BgtD   fmod1
;                        calculate 1/y into R10
    RCPF   R2 , R10             ;  R10 = 1/R2 + d
    MPYF3  R2 , R10, R6         ;  R6  = 1 + d.R2
    SUBRF  2.000000, R6         ;  R6  = 1 - d.R2
 LDI    1,R7
 ABSF   R0
fmod1:
 MPYF   R6 , R10             ;  R10 = 1/R2 + e
 MPYF3  R2 , R10, R6         ;  R6  = 1 + e.R2
 SUBRF  2.000000, R6         ;  R6  = 1 - e.R2
 MPYF   R6 , R10             ;  R10 = 1/R2 + f
 MPYF3  R2 , R10, R6         ;  R6  = 1 + f.R2
 SUBRF  1.000000, R6         ;  R6  = -f.R2
 MPYF   R10, R6              ;  R6  = -f
 ADDF   R6 , R10             ;  R10 = 1/R2
;
 MPYF3  R0,R10,R1            ;  R1 is x/y
 FIX    R1,R10               ;  convert to an integer
 Bv     retn0                ;  return 0 if x/y bigger than 32 bits
 FLOAT  R10,R3               ;  Convert x/y back to floating point
 MPYF   R2 , R3              ;  and get multiple of y near x
 SUBF   R3,R0                ;  and subtract,  so R0 should be answer
 SUBF3  R2,R0,R3             ;  subtract y from retn (in case we want )
 CMPF   R2,R0                ;  if R0 >= y,
 LDFge  R3,R0                ;     use R0 - y
 ADDF3  R2,R0,R3             ;  add y to retn (in case we want it )
 CMPF   0.0,R0               ;  if R0 < 0,
 LDFlt  R3,R0                ;     use R0 + y
 BuD     R11                 ;  and return to user
    NEGF   R0,R3             ;  negate retn (in case we want it)
    CMPI   0,R7              ;  Was original input negative
    LDFne  R3,R0             ;     use negated value if so
;
;=====================================================================
;
.floor:
 STI    R0 , *-\-AR6(1)       ;  reassemble the input argument by
 LDF    *AR6++(1), R0        ;  saving as int and restoring as Float
 LDI    R1 , R0              ;  complete reassembly of input x
 FIX    R0,R1                ;  convert to integer rounding downwards
 Bv     R11                  ;  do nothing if that overflows
 FLOAT  R1,R0                ;  else convert it back to a float
 Bu     R11                  ;  and return to the user
;
;=====================================================================
;
;      double modf( double number, double * iptr );
;      returns fractional part of number,  putting integral
;      part into the double iptr.
;
.modf:
 LSH3   -2,R2,AR5
 STI    R0 , *-\-AR6(1)       ;  reassemble the input argument by
 LDF    *AR6++(1), R0        ;  saving as int and restoring as Float
 LDI    R1 , R0              ;  complete reassembly of input x
 FIX    R0,R1
 Bv     modf2
 FLOAT  R1,R2
 Bge    modf1
 CMPF   R2,R0
 LDFeq  0.0,R3
 LDFne  1.0,R3
 ADDF   R3,R2
modf1:
 BuD    R11
 STF    R2,*++AR5(IR0)
 STI    R2,*+AR5(1)
 SUBF   R2,R0
modf2:
 LDF    R2,R0
 Bu     modf1
;
;=====================================================================
;
.ceil:
 STI    R0 , *-\-AR6(1)       ;  reassemble the input argument by
 LDF    *AR6++(1), R0        ;  saving as int and restoring as Float
 LDI    R1 , R0              ;  complete reassembly of input x
 FIX    R0,R1
 Bv     R11
 FLOAT  R1,R2
 CMPF   R2,R0
 BuD    R11
    LDFeq  0.0,R1
    LDFne  1.0,R1
    ADDF3  R1,R2,R0
;
;=====================================================================
;=====================================================================
;*******************  End of Richard Parkers code   ******************
;=====================================================================
;=====================================================================
;
;    The following code has had a few minor changes made (by RAP)
;
._tancot:
 STI	R11, *-\-AR6(1)
 STI	BK , *-\-AR6(1)
 STI	DP , *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 LDI	R1 , R7 
 LDA	R2 , DP 
 LDF	R7 , R4 
 LDIu	8  , R1 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R2 
 ADDI	RS , R2 
 LDA	AR4, AR2
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( __huge_val ) ),
 ADDI	0  , AR2 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( __huge_val ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( __huge_val ) ) ),
 OR	0x0, RS  )
 LDI	*AR2, R0 
 ADDI	RS , R0 
 LDHI	0xff22, RS 
 OR	0xf983, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0x6e, R6 
 MPYF	R7 , R6 
 CMPF	0.0, R4 
 Bge	L4F20
 LDHI	0x1d91, RS 
 OR	0x94d8, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 CMPF	R4 , R7 
 Bgt	L6F20
L7F20:
 LSH3	-2 , R2 , AR1
 LSH3	-2 , R0 , AR0
 LDF	*++AR0(IR0), R6 
 BRD	L26F20
 STI	R1 , *++AR1(IR0)
 LDI	*++AR0(1), R6 
 NEGF	R6 
L6F20:
 BRD	L25F20
 SUBF	0.500000, R6 
 NOP
 NOP
L4F20:
 LDHI	0x1d6e, RS 
 OR	0x6b28, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 CMPF	R4 , R7 
 Bge	L7F20
 ADDF	0.500000, R6 
L25F20:
 FIX	R6 , BK 
 NEGF	R6 , R3 
 FIX	R3 
 NEGI	R3 
 LDIle	R3 , BK 
 FLOAT	BK , R6 
 LDF	R6 , R4 
 MPYF	1.570801, R4 
 SUBF	R4 , R7 
 LDHI	0xee15, RS 
 OR	0x777a, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x5d, R4 
 MPYF	R4 , R6 
 ADDF3	R6 , R7 , R4 
 ABSF   R4 , R0
 LDF	R0 , R6 
 LDHI	0xde5b, RS 
 OR	0xe6fe, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xcf, R7 
 CMPF	R7 , R6 
 Ble	L11F20
 MPYF3	R4 , R4 , R6 
 LDHI	0xf0ea, RS 
 OR	0x2a46, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x8b, R7 
 MPYF3	R7 , R6 , R5 
 LDHI	0xf760, RS 
 OR	0x7415, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x32, R7 
 ADDF	R5 , R7 
 MPYF3	R6 , R7 , R5 
 LDHI	0xfdf7, RS 
 OR	0x6a50, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xd6, R7 
 ADDF	R5 , R7 
 MPYF	R6 , R7 
 MPYF	R4 , R7 
 ADDF	R4 , R7 
 LDHI	0xeb05, RS 
 OR	0xbba7, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x84, R4 
 MPYF3	R4 , R6 , R5 
 LDHI	0xf4dc, RS 
 OR	0x84db, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x38, R4 
 ADDF	R5 , R4 
 MPYF3	R6 , R4 , R5 
 LDHI	0xfa52, RS 
 OR	0x3cf5, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xc, R4 
 ADDF	R5 , R4 
 MPYF	R6 , R4 
 LDHI	0xfe91, RS 
 OR	0xa7d, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0xc0, R5 
 BRD	L13F20
 ADDF	R5 , R4 
 MPYF	R4 , R6 
 ADDF	1.000000, R6 
L11F20:
 LDF	R4 , R7 
 LDF	1.000000, R6 
L13F20:
 CMPI	0  , DP 
 Beq	L14F20
 AND3	1  , BK , R0 
 Bne	L16F20
L17F20:
 RCPF	R7 , R11
 MPYF3	R7 , R11, R3 
 SUBRF	2.000000, R3 
 MPYF	R3 , R11
 MPYF3	R7 , R11, R3 
 SUBRF	2.000000, R3 
 MPYF	R3 , R11
 MPYF3	R7 , R11, R3 
 SUBRF	1.000000, R3 
 BRD	L26F20
 MPYF	R11, R3 
 ADDF	R3 , R11
 MPYF3	R6 , R11, R6 
L16F20:
 BRD	L21F20
 NEGF	R7 
 NOP
 NOP
L14F20:
 AND3	1  , BK , R0 
 Bne	L20F20
L21F20:
 RCPF	R6 , R11
 MPYF3	R6 , R11, R3 
 SUBRF	2.000000, R3 
 MPYF	R3 , R11
 MPYF3	R6 , R11, R3 
 SUBRF	2.000000, R3 
 MPYF	R3 , R11
 MPYF3	R6 , R11, R3 
 SUBRF	1.000000, R3 
 MPYF	R11, R3 
 ADDF	R3 , R11
 MPYF3	R7 , R11, R6 
L26F20:
 LDF	R6 , R0 
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*+AR6(2), R11
 BuD	R11
 LDI	*AR6++(1), DP 
 LDI	*AR6++(2), BK 
 NOP
L20F20:
 NEGF	R6 
 BR	L17F20
;
;
.tan:
 STI	R11, *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 LDI	R1 , R6 
 LDIu	0  , R3 
 STF	R6 , *-\-AR6(1)
 LAJ	._tancot
 LDI	*AR6++(1), R0 
 LDI	R6 , R1 
 LDI	R3 , R2 
 LDI	*AR6++(1), R11
 Bu	R11
;
;
._cot:
 STI	R11, *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 LDI	R1 , R4 
 ABSF   R4 , R0
 LDF	R0 , R6 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( __huge_val ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( __huge_val ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( __huge_val ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R0 
 ADDI	RS , R0 
 LSH3	-2 , R0 , AR2
 LDF	*++AR2(IR0), R7 
 LDI	*++AR2(1), R7 
 LDF	1.000000, R5 
 RCPF	R7 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R5 , R11, R5 
 CMPF	R5 , R6 
 Bge	L4F24
 LDIu	32 , R1 
 LDA	AR4, AR1
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR1 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI	*AR1, R0 
 ADDI	RS , R0 
 LSH3	-2 , R0 , AR2
 CMPF	0.0, R4 
 BgeD	L12F24
 STI	R1 , *++AR2(IR0)
 LDFge	R7 , R0 
 NOP
L7F24:
 BRD	L11F24
 NEGF	R7 , R6 
 NOP
 NOP
L4F24:
 LDIu	1  , R3 
 STF	R4 , *-\-AR6(1)
 LAJ	._tancot
 LDI	*AR6++(1), R0 
 LDI	R4 , R1 
 LDI	R3 , R2 
 LDF	R0 , R6 
L11F24:
 LDF	R6 , R0 
L12F24:
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*AR6++(1), R11
 Bu	R11
;
;
.atan:
 STI	R1 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 STI	AR7, *-\-AR6(1)
 LDA	AR6, AR7
 STI	R11, *-\-AR6(1)
 STI	DP , *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 LDF	*+AR7(1), R6 
 LDI	*+AR7(2), R6 
 SUBI	2  , AR6
 ABSF   R6 , R0
 LDF	R0 , R4 
 CMPF	1.000000, R4 
 Ble    L4F26
 LAJ    ._invert
 STF	R4 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R4 , R1 
 LDF    0.5,R3               ; set R3 to be 0.5
 LDHI   0x7fff,R3            ; prepare the (illicit) better return
 OR     0xfffe,R3            ; for atan
 MPYF   R3,R0                ; make a slightly smaller answer
 BRD	L6F26
 LDF    R0 , R4
 LDA	2  , DP 
 NOP
L4F26:
 LDA	0  , DP 
L6F26:
 LDHI	0xfe09, RS 
 OR	0x30a2, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0xf5, R6 
 CMPF	R6 , R4 
 Ble	L7F26
 LDHI	0xff3b, RS 
 OR	0x67ae, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0x86, R6 
 MPYF	R4 , R6 
 SUBF	0.500000, R6 
 SUBF	0.500000, R6 
 ADDF	R4 , R6 
 LDHI	0x5d, RS 
 OR	0xb3d7, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x43, R7 
 ADDF	R4 , R7 
 RCPF	R7 , R11
 MPYF3	R7 , R11, R4 
 SUBRF	2.000000, R4 
 MPYF	R4 , R11
 MPYF3	R7 , R11, R4 
 SUBRF	2.000000, R4 
 MPYF	R4 , R11
 MPYF3	R7 , R11, R4 
 SUBRF	1.000000, R4 
 MPYF	R11, R4 
 ADDF	R4 , R11
 MPYF3	R6 , R11, R4 
 ADDI	1  , DP 
L7F26:
 ABSF   R4 , R0
 LDF	R0 , R6 
 LDHI	0xde5b, RS 
 OR	0xe6fe, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xcf, R7 
 CMPF	R7 , R6 
 Ble	L9F26
 MPYF3	R4 , R4 , R6 
 LDHI	0xffa9, RS 
 OR	0x9429, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x32, R7 
 MPYF	R6 , R7 
 LDHI	0x3f8, RS 
 OR	0x1605, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0x1c, R5 
 ADDF	R5 , R7 
 MPYF3	R6 , R7 , R5 
 LDHI	0x4db, RS 
 OR	0xf402, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x31, R7 
 ADDF	R5 , R7 
 MPYF3	R6 , R7 , R5 
 LDHI	0x3a4, RS 
 OR	0xfacd, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x78, R7 
 ADDF	R5 , R7 
 MPYF	R6 , R7 
 STF	R7 , *AR6
 STI	R7 , *+AR6(1)
 LDHI	0x370, RS 
 OR	0x624f, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xa, R7 
 ADDF	R6 , R7 
 MPYF	R6 , R7 
 LDHI	0x56e, RS 
 OR	0x5051, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0x90, R5 
 ADDF	R5 , R7 
 MPYF3	R6 , R7 , R5 
 LDHI	0x62c, RS 
 OR	0x5090, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x20, R7 
 ADDF	R5 , R7 
 MPYF	R6 , R7 
 LDHI	0x524, RS 
 OR	0x43e5, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0xe6, R6 
 ADDF	R7 , R6 
 LDF	*AR6, R7 
 LDI	*+AR6(1), R7 
 RCPF	R6 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R7 , R11, R6 
 MPYF	R4 , R6 
 ADDF	R6 , R4 
L9F26:
 CMPI	1  , DP 
 Ble	L11F26
 NEGF	R4 
L11F26:
 LSH3	3  , DP , R1 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( 1, MODNUM ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( ___dataseg_math.c ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( ___dataseg_math.c ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R0 
 ADDI	RS , R0 
 ADDI3	R1 , R0 , AR2
 LSH	-2 , AR2
 LDF	*++AR2(IR0), R6 
 LDI	*+AR2(1), R6 
 ADDF	R6 , R4 
 LDF	*+AR7(1), R6 
 LDI	*+AR7(2), R6 
 CMPF	0.0, R6 
 Bge	L13F26
 BRD	L18F26
 NEGF	R4 , R6 
 LDF	R6 , R0 
 NOP
L13F26:
 LDF	R4 , R0 
L18F26:
 ADDI	2  , AR6
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*+AR6(1), R1 
 BuD	R1 
 LDI	*AR6++(2), DP 
 LDI	*AR7, AR7
 ADDI	3  , AR6
;
;
.asin:
 STI	R1 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 STI	AR7, *-\-AR6(1)
 LDA	AR6, AR7
 STI	R11, *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 LDF	*+AR7(1), R6 
 LDI	*+AR7(2), R6 
 SUBI	4  , AR6
 ABSF   R6 , R0
 LDF	R0 , R6 
 LDF	0.0, R7 
 CMPF	0.500000, R6 
 Ble	L4F28
 CMPF	1.000000, R6 
 Ble	L6F28
 LDIu	8  , R1 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R0 
 ADDI	RS , R0 
 BRD	L9F28
 LSH3	-2 , R0 , AR2
 LDF	R7 , R0 
 STI	R1 , *++AR2(IR0)
L6F28:
 LDHI	0xff49, RS 
 OR	0xfda, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xa2, R7 
 STF	R7 , *AR6
 STI	R7 , *+AR6(1)
 LDF	1.000000, R7 
 SUBF3	R6 , R7 , R6 
 LDF	R6 , R4 
 MPYF	0.500000, R4 
 LDI    0x1f,R10
 LAJ    .sqrt
 STF	R4 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R4 , R1 
 BRD	L8F28
 LDF	R0 , R6 
 MPYF	-2.000000, R6 
 NOP
L4F28:
 LDI    0x24,R10
 STF	R7 , *AR6
 STI	R7 , *+AR6(1)
 MPYF3	R6 , R6 , R4 
L8F28:
 LDHI	0xffe7, RS 
 OR	0xcec0, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xe5, R7 
 MPYF	R4 , R7 
 LDHI	0x139, RS 
 OR	0xf9e0, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0x54, R5 
 ADDF	R5 , R7 
 MPYF	R4 , R7 
 LDHI	0x1cf, RS 
 OR	0xe4e0, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0x35, R5 
 ADDF	R5 , R7 
 MPYF	R4 , R7 
 STF	R7 , *+AR6(2)
 STI	R7 , *+AR6(3)
 LDHI	0x3da, RS 
 OR	0xa87b, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 ADDF	R4 , R7 
 MPYF	R4 , R7 
 LDHI	0x446, RS 
 OR	0xeaf7, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0x6, R5 
 ADDF	R5 , R7 
 MPYF	R7 , R4 
 LDHI	0x4fb, RS 
 OR	0xeba8, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR     R10, R7
 ADDF	R4 , R7 
 LDF	*+AR7(1), R4 
 LDI	*+AR7(2), R4 
 CMPF	0.0, R4 
 Bge	L10F28
 LDF	*+AR6(2), R4 
 LDI	*+AR6(3), R4 
 MPYF	R6 , R4 
 RCPF	R7 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R4 , R11, R7 
 LDF	*AR6, R4 
 LDI	*+AR6(1), R4 
 ADDF	R4 , R6 
 ADDF	R7 , R6 
 LDF	*AR6, R7 
 BRD	L14F28
 LDI	*+AR6(1), R7 
 ADDF	R7 , R6 
 NEGF	R6 
L10F28:
 LDF	*+AR6(2), R4 
 LDI	*+AR6(3), R4 
 MPYF	R6 , R4 
 RCPF	R7 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R4 , R11, R7 
 LDF	*AR6, R4 
 LDI	*+AR6(1), R4 
 ADDF	R4 , R6 
 ADDF	R7 , R6 
 LDF	*AR6, R7 
 LDI	*+AR6(1), R7 
 ADDF	R7 , R6 
L14F28:
 LDF	R6 , R0 
L9F28:
 ADDI	4  , AR6
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*AR6++(1), R11
 BuD	R11
 LDI	*AR7, AR7
 ADDI	3  , AR6
 NOP
;
;
.acos:
 STI	R1 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 STI	AR7, *-\-AR6(1)
 LDA	AR6, AR7
 STI	R11, *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 LDF	*+AR7(1), R6 
 LDI	*+AR7(2), R6 
 SUBI	6  , AR6
 ABSF   R6 , R0
 LDF	R0 , R6 
 CMPF	0.500000, R6 
 Ble	L4F30
 LDF	0.0, R7 
 CMPF	1.000000, R6 
 Ble	L6F30
 LDIu	8  , R1 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R0 
 ADDI	RS , R0 
 BRD	L9F30
 LSH3	-2 , R0 , AR2
 LDF	R7 , R0 
 STI	R1 , *++AR2(IR0)
L6F30:
 LDHI	0x49, RS 
 OR	0xfda, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xa2, R4 
 STF	R4 , *+AR6(4)
 STI	R4 , *+AR6(5)
 STF	R7 , *+AR6(2)
 STI	R7 , *+AR6(3)
 LDF	1.000000, R7 
 SUBF3	R6 , R7 , R6 
 LDF	R6 , R4 
 MPYF	0.500000, R4 
 LAJ	.sqrt
 STF	R4 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R4 , R1 
 BRD	L8F30
 LDF	R0 , R6 
 MPYF	-2.000000, R6 
 NOP
L4F30:
 MPYF3	R6 , R6 , R4 
 LDHI	0xff49, RS 
 OR	0xfda, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xa2, R7 
 STF	R7 , *+AR6(4)
 STI	R7 , *+AR6(5)
 STF	R7 , *+AR6(2)
 STI	R7 , *+AR6(3)
L8F30:
 LDHI	0xffe7, RS 
 OR	0xcec0, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xe5, R7 
 MPYF	R4 , R7 
 LDHI	0x139, RS 
 OR	0xf9e0, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0x54, R5 
 ADDF	R5 , R7 
 MPYF	R4 , R7 
 LDHI	0x1cf, RS 
 OR	0xe4e0, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0x35, R5 
 ADDF	R5 , R7 
 MPYF	R4 , R7 
 STF	R7 , *AR6
 STI	R7 , *+AR6(1)
 LDHI	0x3da, RS 
 OR	0xa87b, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 ADDF	R4 , R7 
 MPYF3	R4 , R7 , R5 
 LDHI	0x446, RS 
 OR	0xeaf7, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x6, R7 
 ADDF	R5 , R7 
 MPYF	R7 , R4 
 LDHI	0x4fb, RS 
 OR	0xeba8, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR     0x1f, R7
 ADDF	R4 , R7 
 LDF	*+AR7(1), R4 
 LDI	*+AR7(2), R4 
 CMPF	0.0, R4 
 Bge	L10F30
 LDF	*AR6, R4 
 LDI	*+AR6(1), R4 
 MPYF	R6 , R4 
 RCPF	R7 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R4 , R11, R7 
 LDF	*+AR6(4), R4 
 LDI	*+AR6(5), R4 
 ADDF	R4 , R6 
 BRD	L14F30
 ADDF	R7 , R6 
 LDF	*+AR6(4), R7 
 LDI	*+AR6(5), R7 
L10F30:
 LDF	*AR6, R4 
 LDI	*+AR6(1), R4 
 MPYF	R6 , R4 
 RCPF	R7 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R7 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R4 , R11, R7 
 LDF	*+AR6(2), R4 
 LDI	*+AR6(3), R4 
 SUBF3	R6 , R4 , R6 
 SUBF	R7 , R6 
 LDF	*+AR6(2), R7 
 LDI	*+AR6(3), R7 
L14F30:
 ADDF	R7 , R6 
 LDF	R6 , R0 
L9F30:
 ADDI	6  , AR6
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*AR6++(1), R11
 BuD	R11
 LDI	*AR7, AR7
 ADDI	3  , AR6
 NOP
;
;
.pow:
 STI	R11, *-\-AR6(1)
 STI	BK , *-\-AR6(1)
 STI	DP , *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 LDI	R1 , R6 
 STI	R2 , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 LDI	R3 , R7 
 LDA	0  , AR1
 LDA	AR1, AR0
 SUBI	13 , AR6
 CMPF	1.000000, R7 
 Beq	L42F32
 LDA	8  , BK 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R10
 ADDI	RS , R10
 LDA	AR4, AR2
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( __huge_val ) ),
 ADDI	0  , AR2 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( __huge_val ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( __huge_val ) ) ),
 OR	0x0, RS  )
 LDI	*AR2, DP 
 ADDI	RS , DP 
 LDF	0.0, R4 
 STF	R4 , *+AR6(11)
 STI	R4 , *+AR6(12)
 CMPF	0.0, R6 
 Bgt	L6F32
 CMPF	0.0, R6 
 Bne	L8F32
 CMPF	0.0, R7 
 Bgt	L10F32
L11F32:
 BRD	L40F32
 LSH3	-2 , R10, AR5
 STI	BK , *++AR5(IR0)
 NOP
L10F32:
 BRD	L42F32
 LDF	*+AR6(11), R6 
 LDI	*+AR6(12), R6 
 NOP
L8F32:
 LDHI	0x1e80, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 CMPF	R4 , R7 
 Blt	L11F32
 LDHI	0x1e7f, RS 
 OR	0xffff, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xfe, R4 
 CMPF	R4 , R7 
 Bgt	L11F32
 FIX	R7 , R0 
 NEGF	R7 , R11
 FIX	R11
 NEGI	R11
 LDIle	R11, R0 
 FLOAT	R0 , R4 
 CMPF	R7 , R4 
 Bne	L11F32
 NEGF	R6 
 AND3	1  , R0 , AR0
L6F32:
 CMPF	2.000000, R7 
 Bne	L17F32
 LDHI	0x422d, RS 
 OR	0x78eb, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xc6, R4 
 CMPF	R4 , R6 
 Bge	L17F32
 BRD	L42F32
 MPYF	R6 , R6 
 NOP
 NOP
L17F32:
 ADDI3	2  , AR6, R3 
 SUBI	IR0, R3 
 LSH	2  , R3 
 STF	R6 , *-\-AR6(1)
 LAJ	.frexp
 LDI	*AR6++(1), R0 
 LDI	R6 , R1 
 LDI	R3 , R2 
 LDF	R0 , R6 
 LDI	AR1, R1 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( 1, MODNUM ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( ___dataseg_math.c ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( ___dataseg_math.c ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R0 
 ADDI	32 , RS 
 ADDI	RS , R0 
 LSH3	-2 , R0 , AR2
 ADDI	16 , AR2
 LDF	*++AR2(IR0), R4 
 LDI	*++AR2(1), R4 
 CMPF	R6 , R4 
 LDIge	BK , R1 
L20F32:
 ADDI3	4  , R1 , R2 
 LSH3	3  , R2 , R3 
 ADDI3	R3 , R0 , AR5
 LSH	-2 , AR5
 LDF	*++AR5(IR0), R4 
 LDI	*+AR5(1), R4 
 CMPF	R6 , R4 
 LDIge	R2 , R1 
L22F32:
 ADDI3	2  , R1 , R2 
 LSH3	3  , R2 , R3 
 ADDI3	R3 , R0 , AR3
 LSH	-2 , AR3
 LDF	*++AR3(IR0), R4 
 LDI	*+AR3(1), R4 
 CMPF	R6 , R4 
 LDIge	R2 , R1 
L24F32:
 ADDI3	1  , R1 , R2 
 LSH	3  , R2 
 ADDI3	R2 , R0 , AR2
 LSH	-2 , AR2
 LDF	*++AR2(IR0), R4 
 LDI	*+AR2(1), R4 
 STF	R4 , *+AR6(9)
 STI	R4 , *+AR6(10)
 SUBF3	R4 , R6 , R5 
 LDI	R1 , R2 
 Bgt	L26F32
 ADDI	1  , R2 
L26F32:
 LDA	AR4, AR5
 ASH	-1 , R2 
 LSH3	3  , R2 , R3 
patchinstr( PATCHC40MASK16ADD, shift ( 1, MODNUM ),
 ADDI	0  , AR5 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( ___dataseg_math.c ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( ___dataseg_math.c ) ) ),
 OR	0x0, RS  )
 LDI	*AR5, R2 
 ADDI	168, RS 
 ADDI	RS , R2 
 ADDI3	R3 , R2 , AR3
 LSH	-2 , AR3
 LDF	*++AR3(IR0), R4 
 LDI	*+AR3(1), R4 
 SUBF3	R4 , R5 , R4 
 LDF	R4 , R5 
 LDF	R6 , R4 
 MPYF	0.500000, R4 
 LDF	*+AR6(9), R6 
 LDI	*+AR6(10), R6 
 MPYF	0.500000, R6 
 ADDF	R4 , R6 
 LDF	R5 , R4 
 LDI	R9 , RE 
 RCPF	R6 , R11
 MPYF3	R6 , R11, R9 
 SUBRF	2.000000, R9 
 MPYF	R9 , R11
 MPYF3	R6 , R11, R9 
 SUBRF	2.000000, R9 
 MPYF	R9 , R11
 MPYF3	R6 , R11, R9 
 SUBRF	1.000000, R9 
 MPYF	R11, R9 
 ADDF	R9 , R11
 MPYF3	R4 , R11, R6 
 LDI	RE , R9 
 STF	R6 , *+AR6(7)
 STI	R6 , *+AR6(8)
 MPYF	R6 , R6 
 LDHI	0xf463, RS 
 OR	0xc7ee, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xda, R4 
 MPYF3	R4 , R6 , R5 
 LDHI	0xf712, RS 
 OR	0x4921, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x71, R4 
 ADDF	R5 , R4 
 MPYF3	R6 , R4 , R5 
 LDHI	0xf94c, RS 
 OR	0xcccc, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xcd, R4 
 ADDF	R5 , R4 
 MPYF	R6 , R4 
 LDHI	0xfc2a, RS 
 OR	0xaaaa, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0xab, R5 
 ADDF	R5 , R4 
 MPYF	R4 , R6 
 LDF	*+AR6(7), R4 
 LDI	*+AR6(8), R4 
 MPYF	R6 , R4 
 LDHI	0xfe62, RS 
 OR	0xa8ec, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0xa5, R6 
 LDF	R6 , R5 
 MPYF	R4 , R6 
 ADDF	R4 , R6 
 STF	R6 , *+AR6(5)
 STI	R6 , *+AR6(6)
 LDF	*+AR6(7), R4 
 LDI	*+AR6(8), R4 
 MPYF3	R4 , R5 , R6 
 LDF	*+AR6(5), R4 
 LDI	*+AR6(6), R4 
 ADDF	R4 , R6 
 LDF	*+AR6(7), R4 
 LDI	*+AR6(8), R4 
 ADDF	R4 , R6 
 STF	R6 , *AR6
 STI	R6 , *+AR6(1)
 LDI	*+AR6(2), R2 
 LSH	4  , R2 
 SUBI3	R1 , R2 , R1 
 SUBI	1  , R1 
 FLOAT	R1 , R6 
 MPYF	0.062500, R6 
 LDF	R7 , R4 
 MPYF	16.000000, R4 
 FIX	R4 , R1 
 NEGF	R4 , R11
 FIX	R11
 NEGI	R11
 LDIle	R11, R1 
 FLOAT	R1 , R4 
 MPYF	0.062500, R4 
 LDF	R4 , R5 
 SUBF3	R4 , R7 , R4 
 STF	R4 , *+AR6(3)
 STI	R4 , *+AR6(4)
 LDF	*AR6, R4 
 LDI	*+AR6(1), R4 
 MPYF	R4 , R7 
 LDF	*+AR6(3), R4 
 LDI	*+AR6(4), R4 
 MPYF	R6 , R4 
 ADDF	R7 , R4 
 LDF	R4 , R7 
 MPYF	16.000000, R7 
 FIX	R7 , R1 
 NEGF	R7 , R11
 FIX	R11
 NEGI	R11
 LDIle	R11, R1 
 FLOAT	R1 , R7 
 MPYF	0.062500, R7 
 SUBF	R7 , R4 
 MPYF	R5 , R6 
 ADDF	R6 , R7 
 LDF	R7 , R6 
 MPYF	16.000000, R6 
 FIX	R6 , R1 
 NEGF	R6 , R11
 FIX	R11
 NEGI	R11
 LDIle	R11, R1 
 FLOAT	R1 , R6 
 MPYF	0.062500, R6 
 SUBF	R6 , R7 
 ADDF	R7 , R4 
 LDF	R4 , R7 
 MPYF	16.000000, R7 
 FIX	R7 , R1 
 NEGF	R7 , R11
 FIX	R11
 NEGI	R11
 LDIle	R11, R1 
 FLOAT	R1 , R7 
 MPYF	0.062500, R7 
 ADDF	R7 , R6 
 MPYF	16.000000, R6 
 FIX	R6 , R1 
 NEGF	R6 , R11
 FIX	R11
 NEGI	R11
 LDIle	R11, R1 
 LDI	R1 , R2 
 SUBF3	R7 , R4 , R6 
 LDA	32 , BK 
 CMPI	0xffffc020, R2 
 Blt	L44F32
 CMPF	0.0, R6 
 Ble	L30F32
 ADDI	1  , R1 
 SUBF	0.062500, R6 
L30F32:
 CMPI	0  , R1 
 LDIge	1  , R2 
L33F32:
 LDIlt	AR1, R2 
L34F32:
 LDI	R1 , R3 
 Bgt	L35F32
 ADDI	15 , R3 
L35F32:
 ASH	-4 , R3 
 ADDI3	R2 , R3 , AR1
 LSH3	4  , AR1, R2 
 SUBI3	R1 , R2 , R1 
 LDHI	0xef7a, RS 
 OR	0x76ef, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x1d, R7 
 MPYF	R6 , R7 
 LDHI	0xf321, RS 
 OR	0x7bd7, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x2, R4 
 ADDF	R4 , R7 
 MPYF3	R6 , R7 , R4 
 LDHI	0xf62e, RS 
 OR	0xc3f0, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xc7, R7 
 ADDF	R4 , R7 
 MPYF	R6 , R7 
 LDHI	0xf91d, RS 
 OR	0x955b, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x71, R4 
 ADDF	R4 , R7 
 MPYF3	R6 , R7 , R4 
 LDHI	0xfb63, RS 
 OR	0x5846, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xb8, R7 
 ADDF	R4 , R7 
 MPYF	R6 , R7 
 LDHI	0xfd75, RS 
 OR	0xfdef, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xfc, R4 
 ADDF	R4 , R7 
 MPYF3	R6 , R7 , R4 
 LDHI	0xff31, RS 
 OR	0x7217, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xf8, R7 
 ADDF	R4 , R7 
 MPYF	R6 , R7 
 LSH	3  , R1 
 ADDI3	R1 , R0 , AR2
 LSH	-2 , AR2
 LDF	*++AR2(IR0), R6 
 LDI	*+AR2(1), R6 
 MPYF	R6 , R7 
 ADDF	R7 , R6 
 ADDI3	2  , AR6, R3 
 SUBI	IR0, R3 
 LSH	2  , R3 
 STF	R6 , *-\-AR6(1)
 LAJ	.frexp
 LDI	*AR6++(1), R0 
 LDI	R6 , R1 
 LDI	R3 , R2 
 LDF	R0 , R6 
 LDI	*+AR6(2), R0 
 ADDI	R0 , AR1
 CMPI	0x401, AR1
 Blt	L37F32
 LSH3	-2 , R10, AR5
 CMPI	0  , AR0
 BeqD	L39F32
 STI	BK , *++AR5(IR0)
 NOP
 NOP
L40F32:
 BRD	L47F32
 LSH3	-2 , DP , AR3
 LDF	*++AR3(IR0), R6 
 LDI	*++AR3(1), R6 
L39F32:
 BRD	L42F32
 LSH3	-2 , DP , AR2
 LDF	*++AR2(IR0), R6 
 LDI	*++AR2(1), R6 
L37F32:
 CMPI	0xfffffc02, AR1
 Bgt	L43F32
L44F32:
 LSH3	-2 , R10, AR5
 STI	BK , *++AR5(IR0)
 BR	L10F32
L43F32:
 LDI	AR1, R3 
 STF	R6 , *-\-AR6(1)
 LAJ	.ldexp
 LDI	*AR6++(1), R0 
 LDI	R6 , R1 
 LDI	R3 , R2 
 LDF	R0 , R6 
 CMPI	0  , AR0
 Beq	L42F32
L47F32:
 NEGF	R6 
L42F32:
 LDF	R6 , R0 
 ADDI	13 , AR6
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*+AR6(2), R11
 BuD	R11
 LDI	*AR6++(1), DP 
 LDI	*AR6++(2), BK 
 NOP
;
;
.atan2:
 STI	R11, *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 LDI	R1 , R4 
 STI	R2 , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 LDI	R3 , R5 
 CMPF	0.0, R5 
 Bne	L4F34
 CMPF	0.0, R4 
 Bne	L4F34
 LDIu	8  , R1 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R0 
 ADDI	RS , R0 
 LSH3	-2 , R0 , AR2
 LDA	AR4, AR1
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( __huge_val ) ),
 ADDI	0  , AR1 )
 STI	R1 , *++AR2(IR0)
 LDI	*AR1, R0 
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( __huge_val ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( __huge_val ) ) ),
 OR	0x0, RS  )
 ADDI	RS , R0 
 LSH3	-2 , R0 , AR2
 BRD	L21F34
 LDF	*++AR2(IR0), R6 
 LDI	*++AR2(1), R6 
 NEGF	R6 
L4F34:
 ABSF   R5 , R0
 LDF	R0 , R7 
 SUBI	2  , AR6
 STF	R7 , *AR6
 STI	R7 , *+AR6(1)
 ABSF   R4 , R0
 LDF	R0 , R6 
 LDF	*AR6, R7 
 LDI	*+AR6(1), R7 
 ADDI	2  , AR6
 CMPF	R6 , R7 
 Bge	L7F34
 RCPF	R4 , R11
 MPYF3	R4 , R11, R6 
 SUBRF	2.000000, R6 
 MPYF	R6 , R11
 MPYF3	R4 , R11, R6 
 SUBRF	2.000000, R6 
 MPYF	R6 , R11
 MPYF3	R4 , R11, R6 
 SUBRF	1.000000, R6 
 MPYF	R11, R6 
 ADDF	R6 , R11
 MPYF3	R5 , R11, R6 
 ABSF   R6 , R0
 LDF	R0 , R6 
 LDHI	0xbd3c, RS 
 OR	0xe508, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x65, R7 
 CMPF	R7 , R6 
 Bge	L7F34
 CMPF	0.0, R4 
 Bge	L11F34
 LDHI	0xb6, RS 
 OR	0xf025, RS 
 BRD	L21F34
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0x5e, R6 
L11F34:
 LDHI	0x49, RS 
 OR	0xfda, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0xa2, R6 
L21F34:
 LDF	R6 , R0 
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*AR6++(1), R11
 Bu	R11
L7F34:
 RCPF	R5 , R11
 MPYF3	R5 , R11, R6 
 SUBRF	2.000000, R6 
 MPYF	R6 , R11
 MPYF3	R5 , R11, R6 
 SUBRF	2.000000, R6 
 MPYF	R6 , R11
 MPYF3	R5 , R11, R6 
 SUBRF	1.000000, R6 
 MPYF	R11, R6 
 ADDF	R6 , R11
 MPYF3	R4 , R11, R6 
 LAJ	.atan
 STF	R6 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R6 , R1 
 LDF	R0 , R4 
 CMPF	0.0, R5 
 Bge	L14F34
 LDHI	0x149, RS 
 OR	0xfda, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0xa2, R6 
 CMPF	0.0, R4 
 Ble	L16F34
 BRD	L14F34
 SUBF	R6 , R4 
 NOP
 NOP
L16F34:
 ADDF	R6 , R4 
L14F34:
 LDF	R4 , R0 
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*AR6++(1), R11
 Bu	R11
;
;
.sinh:
 STI	R11, *-\-AR6(1)
 STI	DP , *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 LDI	R1 , R7 
 SUBI	2  , AR6
 CMPF	0.0, R7 
 Bge	L4F38
 BRD	L6F38
 NEGF	R7 , R6 
 LDA	1  , DP 
 NOP
L4F38:
 LDF	R7 , R6 
 LDA	0  , DP 
L6F38:
 CMPF	1.000000, R6 
 Ble	L7F38
 LDHI	0xff31, RS 
 OR	0x7300, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 SUBF	R7 , R6 
 LDHI	0x931, RS 
 OR	0x7217, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xf8, R7 
 CMPF	R7 , R6 
 Ble	L9F38
 LDIu	32 , R1 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R0 
 ADDI	RS , R0 
 LSH3	-2 , R0 , AR2
 LDA	AR4, AR1
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( __huge_val ) ),
 ADDI	0  , AR1 )
 STI	R1 , *++AR2(IR0)
 LDI	*AR1, R0 
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( __huge_val ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( __huge_val ) ) ),
 OR	0x0, RS  )
 ADDI	RS , R0 
 CMPI	0  , DP 
 Beq	L11F38
 BRD	L17F38
 LSH3	-2 , R0 , AR2
 LDF	*++AR2(IR0), R6 
 LDI	*++AR2(1), R6 
L11F38:
 BRD	L26F38
 LSH3	-2 , R0 , AR0
 LDF	*++AR0(IR0), R6 
 LDI	*++AR0(1), R6 
L9F38:
 LAJ	.exp
 STF	R6 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R6 , R1 
 LDF	R0 , R6 
 LDHI	0x2115, RS 
 OR	0x2f9, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 CMPF	R7 , R6 
 Bge	L14F38
 LDHI	0xfd7f, RS 
 OR	0xfe2f, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xf1, R7 
 RCPF	R6 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R7 , R11, R7 
 SUBF	R7 , R6 
L14F38:
 LDHI	0xef68, RS 
 OR	0x897, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0x58, R7 
 MPYF	R6 , R7 
 ADDF	R7 , R6 
 CMPI	0  , DP 
 Beq	L26F38
L17F38:
 BRD	L26F38
 NEGF	R6 
 NOP
 NOP
L7F38:
 LDHI	0xde5b, RS 
 OR	0xe6fe, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xcf, R4 
 CMPF	R4 , R6 
 Bgt	L20F38
 BRD	L25F38
 LDF	R7 , R0 
 NOP
 NOP
L20F38:
 MPYF3	R7 , R7 , R6 
 LDHI	0xffb5, RS 
 OR	0xd8c2, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x3d, R4 
 MPYF	R6 , R4 
 LDHI	0x7dc, RS 
 OR	0x3df4, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0xe4, R5 
 ADDF	R5 , R4 
 MPYF3	R6 , R4 , R5 
 LDHI	0xdcb, RS 
 OR	0x51ea, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x4b, R4 
 ADDF	R5 , R4 
 MPYF3	R6 , R4 , R5 
 LDHI	0x12d4, RS 
 OR	0x3765, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x4d, R4 
 ADDF	R5 , R4 
 MPYF	R6 , R4 
 STF	R4 , *AR6
 STI	R4 , *+AR6(1)
 LDHI	0x8f5, RS 
 OR	0x21e3, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xf2, R4 
 ADDF	R6 , R4 
 MPYF	R6 , R4 
 LDHI	0xf0d, RS 
 OR	0x42b9, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0x1e, R5 
 ADDF	R5 , R4 
 MPYF	R6 , R4 
 LDHI	0x15ff, RS 
 OR	0x298b, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0xfa, R6 
 ADDF	R4 , R6 
 LDF	*AR6, R4 
 LDI	*+AR6(1), R4 
 RCPF	R6 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R6 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R4 , R11, R6 
 MPYF	R7 , R6 
 ADDF	R7 , R6 
L26F38:
 LDF	R6 , R0 
L25F38:
 ADDI	2  , AR6
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*+AR6(1), R1 
 BuD	R1 
 LDI	*AR6++(2), DP 
 NOP
 NOP
;
;
.cosh:
 STI	R11, *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 LDI	R1 , R4 
 CMPF	0.0, R4 
 Bge	L4F40
 NEGF	R4 
L4F40:
 CMPF	1.000000, R4 
 Ble	L6F40
 LDHI	0xff31, RS 
 OR	0x7300, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 SUBF	R6 , R4 
 LDHI	0x931, RS 
 OR	0x7217, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0xf8, R6 
 CMPF	R6 , R4 
 Ble	L8F40
 LDIu	32 , R1 
 LDA	AR4, AR3
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( _errno ) ),
 ADDI	0  , AR3 )
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( _errno ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( _errno ) ) ),
 OR	0x0, RS  )
 LDI	*AR3, R0 
 ADDI	RS , R0 
 LSH3	-2 , R0 , AR2
 LDA	AR4, AR1
patchinstr( PATCHC40MASK16ADD, shift ( -2, DATAMODULE ( __huge_val ) ),
 ADDI	0  , AR1 )
 STI	R1 , *++AR2(IR0)
 LDI	*AR1, R0 
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( __huge_val ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( __huge_val ) ) ),
 OR	0x0, RS  )
 ADDI	RS , R0 
 BRD	L14F40
 LSH3	-2 , R0 , AR2
 LDF	*++AR2(IR0), R6 
 LDI	*++AR2(1), R6 
L8F40:
 LAJ	.exp
 STF	R4 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R4 , R1 
 LDF	R0 , R4 
 LDHI	0x2115, RS 
 OR	0x2f9, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 CMPF	R6 , R4 
 Bge	L10F40
 LDHI	0xfd7f, RS 
 OR	0xfe2f, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 OR	0xf1, R6 
 RCPF	R4 , R11
 MPYF3	R4 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R4 , R11, R2 
 SUBRF	2.000000, R2 
 MPYF	R2 , R11
 MPYF3	R4 , R11, R2 
 SUBRF	1.000000, R2 
 MPYF	R11, R2 
 ADDF	R2 , R11
 MPYF3	R6 , R11, R6 
 ADDF	R6 , R4 
L10F40:
 LDHI	0xef68, RS 
 OR	0x897, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 BRD	L14F40
 OR	0x58, R6 
 MPYF	R4 , R6 
 ADDF	R4 , R6 
L6F40:
 LAJ	.exp
 STF	R4 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R4 , R1 
 LDF    R0 , R4
 LAJ    ._invert
 STF	R4 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R4 , R1 
 ADDF3	R4 , R0 , R6 
 MPYF	0.500000, R6 
L14F40:
 LDF	R6 , R0 
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDI	*AR6++(1), R11
 Bu	R11
;
;
.tanh:
 STI	R11, *-\-AR6(1)
 STI	DP , *-\-AR6(1)
 STI	R5 , *-\-AR6(1)
 STF	R5 , *-\-AR6(1)
 STI	R4 , *-\-AR6(1)
 STF	R4 , *-\-AR6(1)
 STI	R0 , *-\-AR6(1)
 LDF	*AR6++(1), R6 
 LDI	R1 , R6 
 LDF	1.000000, R4 
 SUBI	2  , AR6
 CMPF	0.0, R6 
 Bge	L4F42
 CMPF	-27.000000, R6 
 Bge	L6F42
 BRD	L21F42
 LDF	-1.000000, R6 
 NOP
 NOP
L6F42:
 BRD	L8F42
 NEGF	R6 
 LDA	1  , DP 
 NOP
L4F42:
 CMPF	27.000000, R6 
 Ble	L9F42
 BRD	L16F42
 LDF	R4 , R0 
 NOP
 NOP
L9F42:
 LDA	0  , DP 
L8F42:
 LDHI	0xff0c, RS 
 OR	0x9f53, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xd5, R7 
 CMPF	R7 , R6 
 Ble	L11F42
 MPYF	2.000000, R6 
 LAJ	.exp
 STF	R6 , *-\-AR6(1)
 LDI	*AR6++(1), R0 
 LDI	R6 , R1 
 LDF	R0 , R7 
 ADDF	1.000000, R7 
 LDF	2.000000, R6 
 RCPF	R7 , R11
 MPYF3	R7 , R11, R0 
 SUBRF	2.000000, R0 
 MPYF	R0 , R11
 MPYF3	R7 , R11, R0 
 SUBRF	2.000000, R0 
 MPYF	R0 , R11
 MPYF3	R7 , R11, R0 
 SUBRF	1.000000, R0 
 MPYF	R11, R0 
 ADDF	R0 , R11
 MPYF3	R6 , R11, R6 
 CMPI	0  , DP 
 Beq	L14F42
 BRD	L21F42
 SUBF	1.000000, R6 
 NOP
 NOP
L14F42:
 BRD	L21F42
 SUBF3	R6 , R4 , R6 
 NOP
 NOP
L11F42:
 MPYF3	R6 , R6 , R7 
 LDHI	0xff89, RS 
 OR	0x1eb9, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x88, R4 
 MPYF	R7 , R4 
 LDHI	0x6b9, RS 
 OR	0x8c52, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0xf2, R5 
 ADDF	R5 , R4 
 MPYF	R7 , R4 
 LDHI	0xab6, RS 
 OR	0x52d1, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R5 
 OR	0xb2, R5 
 ADDF	R5 , R4 
 MPYF	R7 , R4 
 STF	R4 , *AR6
 STI	R4 , *+AR6(1)
 LDHI	0x661, RS 
 OR	0x7d4f, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0xf, R4 
 ADDF	R7 , R4 
 MPYF3	R7 , R4 , R5 
 LDHI	0xb0b, RS 
 OR	0x9c5a, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R4 
 OR	0x68, R4 
 ADDF	R5 , R4 
 MPYF	R7 , R4 
 LDHI	0xc17, RS 
 OR	0x41e2, RS 
 STI	RS , *-\-AR6(1)
 LDF	*AR6++(1), R7 
 OR	0xba, R7 
 ADDF	R4 , R7 
 LDF	*AR6, R4 
 LDI	*+AR6(1), R4 
 RCPF	R7 , R11
 MPYF3	R7 , R11, R0 
 SUBRF	2.000000, R0 
 MPYF	R0 , R11
 MPYF3	R7 , R11, R0 
 SUBRF	2.000000, R0 
 MPYF	R0 , R11
 MPYF3	R7 , R11, R0 
 SUBRF	1.000000, R0 
 MPYF	R11, R0 
 ADDF	R0 , R11
 MPYF3	R4 , R11, R7 
 MPYF	R6 , R7 
 ADDF	R7 , R6 
 CMPI	0  , DP 
 Beq	L21F42
 NEGF	R6 
L21F42:
 LDF	R6 , R0 
L16F42:
 ADDI	2  , AR6
 LDF	*AR6++(1), R4 
 LDI	*AR6++(1), R4 
 LDF	*AR6++(1), R5 
 LDI	*AR6++(1), R5 
 LDI	*+AR6(1), R6 
 BuD	R6 
 LDI	*AR6++(2), DP 
 NOP
 NOP
;
;
; Data / Function Table Initialisation
;       align 128
        init
;
;
 CMPI	0  , R0 
 Bne	R11
L2F49:
 LDA	AR4, AR5
patchinstr( PATCHC40MASK16ADD, shift ( 1, MODNUM ),
 ADDI	0  , AR5 )
 LDA	*AR5, AR5
patchinstr( PATCHC40MASK16ADD, shift ( -16, DATASYMB ( ___dataseg_math.c ) ),
 LDHI	0x0, RS  )
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB ( ___dataseg_math.c ) ) ),
 OR	0x0, RS  )
 ADDI	RS , AR5
 LSH	-2 , AR5
 ADDI	IR0, AR5
 LDI	R11, R6 
 LAJ	4	; <fetching PC>
 LDI	22 , AR0
 ADDI	R11, AR0
 NOP
 LDIu	4  , RC 
 RPTBD	L4F49
 LDI	*AR0++(1), R1 
 STI	R1 , *AR5++(2)
 LDI	*AR0++(1), R1 
L4F49:
 LDI	*AR0++(1), R1   || STI	R1 , *AR5++(1)
 LDIu	29 , RC 
 RPTBD	L5F49
 STI	R1 , *AR5++(3)
 LDI	*AR0++(1), R1 
 NOP
L5F49:
 LDI	*AR0++(1), R1   || STI	R1 , *AR5++(1)
 LDIu	14 , RC 
 RPTBD	L6F49
 STI	R1 , *AR5++(2)
 LDI	*AR0++(1), R1 
 NOP
L6F49:
 LDI	*AR0++(1), R1   || STI	R1 , *AR5++(1)
 BuD	R6 
 STI	R1 , *AR5++(1)
 NOP
 NOP
L3F49:
 word	0x80000000
 word	0xff060a91
 word	0x060a91c1
 word	0x00490fda
 word	0x490fdaa2
 word	0x00060a91
 word	0x060a91c1
 word	0xff75257d
 word	0x75257d15
 word	0xff6ac0c6
 word	0x6ac0c6e8
 word	0xff60ccde
 word	0x60ccdeec
 word	0xff5744fc
 word	0x5744fccb
 word	0xff4e248c
 word	0x4e248c15
 word	0xff45672a
 word	0x45672a11
 word	0xff3d08a3
 word	0x3d08a39f
 word	0xff3504f3
 word	0x3504f334
 word	0xff2d583e
 word	0x2d583eea
 word	0xff25fed6
 word	0x25fed6aa
 word	0xff1ef532
 word	0x1ef53261
 word	0xff1837f0
 word	0x1837f052
 word	0xff11c3d3
 word	0x11c3d374
 word	0xff0b95c1
 word	0x0b95c1e4
 word	0xff05aac3
 word	0x05aac368
 word	0xff000000
 word	0xc98b1ee7
 word	0x8b1ee743
 word	0xc808832c
 word	0x08832c4b
 word	0xc763e235
 word	0x63e23584
 word	0xc8df5440
 word	0xdf544090
 word	0xc9319260
 word	0x3192602a
 word	0xc856d048
 word	0x56d04890
 word	0xc94d83bd
 word	0x4d83bdb6
 word	0xc9453172
 word	0x45317257
;
data   ___dataseg_math.c, 232
;
export    .frexp
ref       _frexp
export    .ldexp
ref       _ldexp
export    .errno
ref       _errno
export    ._huge_val
ref       __huge_val
export    .fabs
ref       _fabs
export    .sin
ref       _sin
export    .cos
ref       _cos
export    .exp
ref       _exp
export    .log
ref       _log
export    .log10
ref       _log10
export    .sqrt
ref       _sqrt
export    ._sqrt
ref       __sqrt
export    .tan
ref       _tan
export    ._cot
ref       __cot
export    .atan
ref       _atan
export    ._invert
ref       __invert
export    .asin
ref       _asin
export    .acos
ref       _acos
export    .pow
ref       _pow
export    .atan2
ref       _atan2
export    .sinh
ref       _sinh
export    .cosh
ref       _cosh
export    .tanh
ref       _tanh
export    .fmod
ref       _fmod
export    .modf
ref       _modf
export    .floor
ref       _floor
export    .ceil
ref       _ceil
;
;
; END

@


1.14
log
@fixed for compilation with the new assembler
@
text
@d1 626
d628 3
a630 1
; maths.a - assembly language support for the C maths library
d632 1
a632 7
; NB/ The code in this file is based on that provided by Texas
; Instruments in their source file 'rts.src'.  This file is
; ONLY available to purchasers of Texas Instrument's C40 C compiler.
; The source is used here with permission from Texas Instruments
; with the privisos that
;	a. The Copyright message appears as below
;	b. The source is NOT redistributed to third parties.
d634 78
a711 2
; Copyright (c) 1991 Texas Instruments Incorporated
;   All Rights Reserved
d713 1
a713 1
; Modificatins to the Texas source are:
d715 3
a717 14
; Copyright (c) 1992 by Perihelion Software Limited
;   All Rights Reserved
;
;
; $Id: maths.a,v 1.13 1992/08/04 18:33:14 nickc Exp nickc $
;

_include 'c40.m
_include 'basic.m

;
; NB/ This file is NOT a helios module.
; It must be linked with fpstart.o and modend.o to
; form a Helios resident library
a718 9

_if _defp 'STAND_ALONE
[
_include 'module.m

	StartModule maths -1 1
]


d720 2095
a2814 79
;      double modf( double number, double * iptr );
;
; Upon Entry:
;	R_A1	value to convert (high part)
;	R_A2	value to convert (low  part)
;	R_A3	pointer to location to place integer part of number
;	R_LR	return address
;
; Upon Exit
;	R_A1	fractional part of number (high and low parts)
;
; Corrupts
;	R_FT2, R_FT1, R_ATMP, ST
;
; Purpose
;	Splits an FP number into a fractional and an integer part.
;
	LSH	-2,	       R_A3, R_ATMP	; convert pointer to word addressing
	Beq	 R_LR				; if the pointer is NULL, return
	STI	 R_A1,    *\-\-R_USP(1)		; save high of FP number
	LDF	*R_USP++(1),   R_A1		; load back as FP number
	LDI	 R_A2,	       R_A1		; load in low part
        FIX	 R_A1,	       R_FT2		; convert FP number to integer
	LDFv	 R_A1,	       R_FT2		; but if overflow occured
	Bv	 R_LR				; load original number and skip to end
	FLOAT	 R_FT2				; convert integer value back into FP
        Bge	 result				; if the number was positive we are OK
	CMPF     R_FT2,	       R_A1		; otherwise see if the number has a fractional part
	LDFeq	 0.0,          R_FT1		; no - we are OK		
	LDFne	 1.0,          R_FT1		; yes - we must add one to integer part	
	ADDF	 R_FT1,	       R_FT2		; perform the addition
result:
        BuD	 R_LR				; return (delayed)
	   STF   R_FT2,	    *++R_ATMP( R_BASE )	; save integer part in memory (high part of FP number)
	   STI   R_FT2,	     *+R_ATMP( 1 )	; save integer part in memory (low  part of FP number)
	   SUBF  R_FT2,	       R_A1result	; subtract integer part to leave fractional part
;
; end of _modf
;

._sqrt:
;      double _sqrt( double number );
;
; Upon Entry:
;	R_A1	value to convert (high part)
;	R_A2	value to convert (low  part)
;	R_LR	return address
;
; Upon Exit
;	R_A1	non-negative square root of the number (high and low part)
;
; Corrupts
;	R_T1, R_FT1, R_FT2, ST
;
; Purpose
;	Returns the non-negative square root of the non-negative input
;	Performs no range checking
;
	STI	  R_A1,	   *\-\-R_USP(1)	; save high part as integer
	LDF	 *R_USP++(1),	R_A1		; load back as an FP number
	LDI	  R_A2,		R_A1		; load in low part
	LDF	  R_A1,		R_T1		; save a copy
        RSQRF	  R_A1,		R_FT1		; R_FT1 = x[0] = (estimate of) 1/sqrt(x)
        MPYF	  0.5,		R_A1		; R_A1 = x / 2	

	MPYF3	  R_FT1,	R_FT1,	R_FT2	; R_FT2 = x[0] * x[0]
	MPYF	  R_A1,		R_FT2		; R_FT2 = (x/2) * x[0] * x[0]
	SUBRF	  1.5,		R_FT2		; R_FT2 = 1.5 - (x/2) * x[0] * x[0]
	MPYF	  R_FT2,	R_FT1		; x[1] = x[0] * (1.5 - x/2 * x[0] * x[0])
	RND	  R_FT1				; round up

	MPYF3	  R_FT1,	R_FT1,	R_FT2	; R_FT2 = x[1] * x[1]
	MPYF	  R_A1,		R_FT2		; R_FT2 = (x/2) * x[1] * x[1]
	SUBRF	  1.5,		R_FT2		; R_FT2 = 1.5 - (x/2) * x[1] * x[1]
	MPYF	  R_FT2,	R_FT1		; x[2]  = x[1] * (1.5 - x/2 * x[1] * x[1])
	RND	  R_FT1				; round before multiplying

	MPYF3     R_FT1,	R_T1,	R_A1	; sqrt(x) = x * 1/sqrt(x)
	Bu	  R_LR				; return (delayed)
a2815 1
; end of _sqrt
d2817 1
a2817 139

._invert:
;      	double _invert( double number );
;
; Upon Entry:
;	R_A1	value to convert (high part)
;	R_A2	value to convert (low  part)
;	R11	return address
;
; Upon Exit
;	R_A1	1.0 / number (high and low parts)
;
; Corrupts
;	R_FT2, R_FT1, ST
;
; Purpose
;	Calculates the inverse of its argument
;	Does NOT trap overflow, underflow or 0
;
	STI	  R_A1,	   *\-\-R_USP(1)	; save number as integer
	LDF	 *R_USP++(1),	R_A1		; load back as an FP number
	LDI	  R_A2,		R_A1		; load in low part
	RCPF	  R_A1,  	R_FT2		; R_FT2 = x[0] = estimate of 1/number
        MPYF3	  R_A1,		R_FT2,	R_FT1	; R_FT1 = number * x[0]
        SUBRF	  2.0,		R_FT1		; R_FT1 = 2.0 - number * x[0]		
        MPYF	  R_FT1,	R_FT2		; R_FT2 = x[1] = x[0] * (2.0 - number * x[0])
	BuD	  R_LR				; return (delayed)
           MPYF3  R_FT2,	R_A1,	R_FT1	; R_FT1 = number * x[1]
           SUBRF  2.0,		R_FT1		; R_FT1 = 2.0 - number * x[1]		
           MPYF3  R_FT1,	R_FT2,	R_A1	; R_A1 = x[2] = x[1] * (2.0 - number * x[1])
;
; end of _invert 
;

.__ddivide:
;
; XXX - WARNING: This code is a copy of that found in /hsrc/cmds/cc/clib/C40/fpmaths.a
; XXX -          Keep the two files up to date
;
;      double __ddivide( double denominator, double numerator );
;
; Upon Entry:
;	R_A1	denominator (high part)
;	R_A2	denominator (low  part)
;	R_A3	numerator   (high part)
;	R_A4	numerator   (low  part)
;	R_LR	return address
;
; Upon Exit
;	R_A1	(numerator / denominator) (high and low part)
;
; Corrupts
;	R_FT2, R_FT1, ST
;
; Purpose
;	Performs a floating point division
;
;	This routine is based on the reciprocal instruction
;	in the C40 instruction set.  This gives us 16 bits of
;	accuracy, and so it is followed by 2 iterations of the
;	Newton-Raphson formula
;
;		g' = g * ( 2 - dg )
;
;	where
;		d 		(denominator)
;		g = 1 / d	(guess)
;
;	This gives us 32 bits of accuracy, so we can now multiply
;	the numerator by the result, to give us the number we want.
;	It may not be totally accuracte, but it is fast.
;
;	Note the code ignores error conditions such as denominator == 0.0
;	
	STI	  R_A1,	   *\-\-R_USP(1)	; save denominator
	LDF	 *R_USP++(1),	R_A1		; load back as FP number
	LDI	  R_A2,		R_A1		; load in remianing bits
	RCPF	  R_A1,		R_FT2		; R_FT2 = first approximation (g)
						;        First Newton-Raphson iteration
	MPYF3	  R_FT2,	R_A1,   R_FT1	; R_FT1 = gd
	SUBRF	  2.0,		R_FT1		; R_FT1 = 2 - gd
	MPYF	  R_FT1,	R_FT2		; R_FT2 = y * (2 - gd)
						;        Second Newton-Raphson iteration
	MPYF3	  R_FT2,	R_A1,   R_FT1	; R_FT1 = gd
	SUBRF	  2.0,		R_FT1		; R_FT1 = 2 - gd
	MPYF	  R_FT1,	R_FT2		; R_FT2 = y * (2 - gd)
	RND	  R_FT2,	R_FT2		; round result since we are going to multiply
	STI	  R_A3,	   *\-\-R_USP(1)	; save high part of numerator
	BuD	  R_LR				; return (delayed)
	   LDF	 *R_USP++(1),	R_A3		; load back as FP number
	   LDI	  R_A4,		R_A3		; load low part back in
	   MPYF3  R_FT2,	R_A3,	R_A1	; perform mutliplication, ie result = a * (1 / b)
;
; end of __ddivide
;

_if _defp 'STAND_ALONE
[
init
	CMPI	2,    		R_A1		; are we initialising function table ?
	Bne	R_LR				; nope ? then return 
	LDI	R_LR, 		R_ADDR1		; save return address
	LAJ	4				; get PC into R_LR
	LDI	R_MT, 		R_ATMP		; get module table pointer into temporary register
patchinstr
(
PATCHC40MASK16ADD, shift ( 1 , modnum ), 
	ADDI	1,		R_ATMP		; add in our module number
)
	LDI	*R_ATMP,	R_ATMP		; get pointer to function table
					; fake link-and-jump takes place now
here:
	LDI	R_LR,		R_TMP1		; save link register
	SUBI	here - .modf,	R_LR		; load address of modf routine
	STI	R_LR,		*R_ATMP++(1)	; save in function table

	LDI	R_TMP1,		R_LR		; get hold of PC again
	SUBI	here - ._sqrt,	R_LR		; load address of _sqrt routine
	STI	R_LR,		*R_ATMP++(1)	; save in function table

	BuD	R_ADDR1				; return (delayed)

	LDI	R_TMP1,		R_LR		; get hold of PC again
	SUBI	here - ._invert, R_LR		; load address of _invert routine
	STI	R_LR,		*R_ATMP++(1)	; save in function table

					; return takes place now

codetable _modf
export    _modf

codetable __sqrt
export    __sqrt

codetable __invert
export    __invert

EndModule
]
a2818 1
-- end of maths.a
@


1.13
log
@fixed _sqrt
@
text
@d21 1
a21 1
; $Id: maths.a,v 1.12 1992/05/22 10:31:15 nickc Exp nickc $
d70 2
a71 2
	LDFeq	 0x8000,       R_FT1		; no - we are OK				0x8000 = 0.0
	LDFne	 0x0000,       R_FT1		; yes - we must add one to integer part		0x0000 = 1.0
d105 1
a105 1
        MPYF	  0xF000,	R_A1		; R_A1 = x / 2				0xf000 => 0.5
d109 1
a109 1
	SUBRF	  0x0400,	R_FT2		; R_FT2 = 1.5 - (x/2) * x[0] * x[0]	0x0400 => 1.5
d115 1
a115 1
	SUBRF	  0x0400, 	R_FT2		; R_FT2 = 1.5 - (x/2) * x[1] * x[1]	0x0400 => 1.5
d134 1
a134 1
;	R_A1	1 / number (high and low parts)
d148 1
a148 1
        SUBRF	  0x1000,	R_FT1		; R_FT1 = 2.0 - number * x[0]		0x1000 => 2.0
d152 1
a152 1
           SUBRF  0x1000,	R_FT1		; R_FT1 = 2.0 - number * x[1]		0x1000 => 2.0
d204 1
a204 1
	SUBRF	  0x1000, 	R_FT1		; R_FT1 = 2 - gd			; 0x1000 = 2.0
d208 1
a208 1
	SUBRF	  0x1000, 	R_FT1		; R_FT1 = 2 - gd			; 0x1000 = 2.0
@


1.12
log
@minor cosmetic changes
@
text
@d21 1
a21 1
; $Id: maths.a,v 1.11 1992/03/25 14:10:43 nickc Exp nickc $
d103 1
a103 1
	LDI	  R_A1,		R_T1		; save a copy
d106 1
d112 1
d116 5
a120 4
	BuD	  R_LR				; return (delayed)
	   MPYF	  R_FT2,	R_FT1		; x[2]  = x[1] * (1.5 - x/2 * x[1] * x[1])
	   RND	  R_FT1				; round before multiplying
	   MPYF3  R_FT1,	R_T1,	R_A1	; sqrt(x) = x * 1/sqrt(x)
@


1.11
log
@added __ddivide from fpmaths.a in clib
@
text
@d21 1
a21 1
; $Id: maths.a,v 1.10 1992/03/20 18:37:33 nickc Exp nickc $
d59 14
a72 17
	LSH	-2,		R_A3, R_ATMP	; convert pointer to word addressing
	Beq	R_LR				; if the pointer is NULL, return

	STI	R_A1,		*\-\-R_USP(1)	; save high of FP number
	LDF	*R_USP++(1),	R_A1		; load back as FP number
	LDI	R_A2,		R_A1		; load in low part

        FIX	R_A1,		R_FT2		; convert FP number to integer
	LDFv	R_A1,		R_FT2		; but if overflow occured
	Bv	R_LR				; load original number and skip to end

	FLOAT	R_FT2				; convert integer value back into FP
        Bge	result				; if the number was positive we are OK
	CMPF    R_FT2,		R_A1		; otherwise see if the number has a fractional part
	LDFeq	0x8000,		R_FT1		; no - we are OK				0x8000 = 0.0
	LDFne	0x0000,		R_FT1		; yes - we must add one to integer part		0x0000 = 1.0
	ADDF	R_FT1,		R_FT2		; perform the addition
d74 4
a77 5
        BuD	R_LR				; return (delayed)
	STF     R_FT2,	*++R_ATMP( R_BASE )	; save integer part in memory (high part of FP number)
	STI     R_FT2,	*+R_ATMP( 1 )		; save integer part in memory (low  part of FP number)
	SUBF    R_FT2,	R_A1result		; subtract integer part to leave fractional part
					; return takes place now
d100 18
a117 23
	STI	R_A1,		*\-\-R_USP(1)	; save high part as integer
	LDF	*R_USP++(1),	R_A1		; load back as an FP number
	LDI	R_A2,		R_A1		; load in low part
	LDI	R_A1,		R_T1

        RSQRF	R_A1,		R_FT1		; R_FT1 = x[0] = (estimate of) 1/sqrt(x)
        MPYF	0xF000,		R_A1		; R_A1 = x / 2				0xf000 => 0.5

	MPYF3	R_FT1,		R_FT1,	R_FT2	; R_FT2 = x[0] * x[0]
	MPYF	R_A1,		R_FT2		; R_FT2 = (x/2) * x[0] * x[0]
	SUBRF	0x0400,		R_FT2		; R_FT2 = 1.5 - (x/2) * x[0] * x[0]	0x0400 => 1.5
	MPYF	R_FT2,		R_FT1		; x[1] = x[0] * (1.5 - x/2 * x[0] * x[0])

	RND	R_FT1				; round up
	MPYF3	R_FT1,		R_FT1,	R_FT2	; R_FT2 = x[1] * x[1]
	MPYF	R_A1,		R_FT2		; R_FT2 = (x/2) * x[1] * x[1]
	SUBRF	0x0400, 	R_FT2		; R_FT2 = 1.5 - (x/2) * x[1] * x[1]	0x0400 => 1.5
	BuD	R_LR				; return (delayed)
	MPYF	R_FT2,		R_FT1		; x[2]  = x[1] * (1.5 - x/2 * x[1] * x[1])

	RND	R_FT1				; round before multiplying
	MPYF3	R_FT1,		R_T1,	R_A1	; sqrt(x) = x * 1/sqrt(x)
					; return takes place now
d140 11
a150 16
	STI	R_A1,		*\-\-R_USP(1)	; save number as integer
	LDF	*R_USP++(1),	R_A1		; load back as an FP number
	LDI	R_A2,		R_A1		; load in low part

	RCPF	R_A1,  		R_FT2		; R_FT2 = x[0] = estimate of 1/number

        MPYF3	R_A1,		R_FT2,	R_FT1	; R_FT1 = number * x[0]
        SUBRF	0x1000,		R_FT1		; R_FT1 = 2.0 - number * x[0]		0x1000 => 2.0
        MPYF	R_FT1,		R_FT2		; R_FT2 = x[1] = x[0] * (2.0 - number * x[0])
 
	BuD	R_LR				; return (delayed)

        MPYF3	R_FT2,		R_A1,	R_FT1	; R_FT1 = number * x[1]
        SUBRF	0x1000,		R_FT1		; R_FT1 = 2.0 - number * x[1]		0x1000 => 2.0
        MPYF3	R_FT1,		R_FT2,	R_A1	; R_A1 = x[2] = x[1] * (2.0 - number * x[1])
					; return takes place now
d195 4
a198 5
	STI	R_A1,		*\-\-R_USP(1)	; save denominator
	LDF	*R_USP++(1),	R_A1		; load back as FP number
	LDI	R_A2,		R_A1		; load in remianing bits

	RCPF	R_A1,		R_FT2		; R_FT2 = first approximation (g)
d200 3
a202 3
	MPYF3	R_FT2,		R_A1, R_FT1	; R_FT1 = gd
	SUBRF	0x1000, 	R_FT1		; R_FT1 = 2 - gd			; 0x1000 = 2.0
	MPYF	R_FT1,		R_FT2		; R_FT2 = y * (2 - gd)
d204 9
a212 13
	MPYF3	R_FT2,		R_A1, R_FT1	; R_FT1 = gd
	SUBRF	0x1000, 	R_FT1		; R_FT1 = 2 - gd			; 0x1000 = 2.0
	MPYF	R_FT1,		R_FT2		; R_FT2 = y * (2 - gd)

	RND	R_FT2,		R_FT2		; round result since we are going to multiply

	STI	R_A3,		*\-\-R_USP(1)	; save high part of numerator
	BuD	R_LR				; return (delayed)
	LDF	*R_USP++(1),	R_A3		; load back as FP number
	LDI	R_A4,		R_A3		; load low part back in

	MPYF3	R_FT2,		R_A3,	R_A1	; perform mutliplication, ie result = a * (1 / b)
					; return takes place now
@


1.10
log
@updated to work with new register naming scheme
@
text
@d21 1
a21 1
; $Id: maths.a,v 1.6 1992/03/16 15:47:33 nickc Exp nickc $
d82 3
a85 1

d127 3
d165 47
d213 22
@


1.9
log
@cosmetic improvements
@
text
@d54 1
a54 1
;	R_T1, R_T2, R_ATMP, ST
d66 2
a67 2
        FIX	R_A1,		R_T1		; convert FP number to integer
	LDFv	R_A1,		R_T1		; but if overflow occured
d70 1
a70 1
	FLOAT	R_T1				; convert integer value back into FP
d72 4
a75 4
	CMPF    R_T1,		R_A1		; otherwise see if the number has a fractional part
	LDFeq	0x8000,		R_T2		; no - we are OK				0x8000 = 0.0
	LDFne	0x0000,		R_T2		; yes - we must add one to integer part		0x0000 = 1.0
	ADDF	R_T2,		R_T1		; perform the addition
d78 3
a80 3
	STF     R_T1,	*++R_ATMP( R_BASE )	; save integer part in memory (high part of FP number)
	STI     R_T1,	*+R_ATMP( 1 )		; save integer part in memory (low  part of FP number)
	SUBF    R_T1,	R_A1result		; subtract integer part to leave fractional part
d96 1
a96 1
;	R_T1, R_T2, R_T3, ST
d107 1
a107 1
        RSQRF	R_A1,		R_T2		; R_T2 = x[0] = (estimate of) 1/sqrt(x)
d110 9
a118 9
	MPYF3	R_T2,		R_T2,	R_T3	; R_T3 = x[0] * x[0]
	MPYF	R_A1,		R_T3		; R_T3 = (x/2) * x[0] * x[0]
	SUBRF	0x0400,		R_T3		; R_T3 = 1.5 - (x/2) * x[0] * x[0]	0x0400 => 1.5
	MPYF	R_T3,		R_T2		; x[1] = x[0] * (1.5 - x/2 * x[0] * x[0])

	RND	R_T2				; round up
	MPYF3	R_T2,		R_T2,	R_T3	; R_T3 = x[1] * x[1]
	MPYF	R_A1,		R_T3		; R_T3 = (x/2) * x[1] * x[1]
	SUBRF	0x0400, 	R_T3		; R_T3 = 1.5 - (x/2) * x[1] * x[1]	0x0400 => 1.5
d120 1
a120 1
	MPYF	R_T3,		R_T2		; x[2]  = x[1] * (1.5 - x/2 * x[1] * x[1])
d122 2
a123 2
	RND	R_T2				; round before multiplying
	MPYF3	R_T2,		R_T1,	R_A1	; sqrt(x) = x * 1/sqrt(x)
d138 1
a138 1
;	R_T1, R_T2, ST
d148 1
a148 1
	RCPF	R_A1,  		R_T1		; R_T1 = x[0] = estimate of 1/number
d150 3
a152 3
        MPYF3	R_A1,		R_T1,	R_T2	; R_T2 = number * x[0]
        SUBRF	0x1000,		R_T2		; R_T2 = 2.0 - number * x[0]		0x1000 => 2.0
        MPYF	R_T2,		R_T1		; R_T1 = x[1] = x[0] * (2.0 - number * x[0])
d156 3
a158 3
        MPYF3	R_T1,		R_A1,	R_T2	; R_T2 = number * x[1]
        SUBRF	0x1000,		R_T2		; R_T2 = 2.0 - number * x[1]		0x1000 => 2.0
        MPYF3	R_T2,		R_T1,	R_A1	; R_A1 = x[2] = x[1] * (2.0 - number * x[1])
@


1.8
log
@minor cosmetic changes
@
text
@d105 1
a106 1
	LDF	R_A1,		R_T1		; R_T1 = x
d110 1
a110 1
	MPYF	R_T2,		R_T2,	R_T3	; R_T3 = x[0] * x[0]
d115 3
a117 3
	RND     R_T2
	MPYF	R_T2,		R_T2,	R_T3	; R_T3 = x[1] * x[1]
	MPYF	R_A2,		R_T3		; R_T3 = (x/2) * x[1] * x[1]
d122 2
a123 2
	RND     R_T2				; round before multiplying
	MPYF    R_T2,		R_T1,	R_A1	; sqrt(x) = x * 1/sqrt(x)
d148 1
a148 1
	RCPF    R_A1,  		R_T1		; R_T1 = x[0] = estimate of 1/number
d150 3
a152 3
        MPYF    R_T1,		R_A1,	R_T2	; R_T2 = number * x[0]
        SUBRF   0x1000,		R_T2		; R_T2 = 2.0 - number * x[0]		0x1000 => 2.0
        MPYF    R_T2,		R_T1		; R_T1 = x[1] = x[0] * (2.0 - v * x[0])
d156 3
a158 3
        MPYF    R_T1,		R_A1,	R_T2	; R_T2 = number * x[1]
        SUBRF   0x1000,		R_T2		; R_T2 = 2.0 - number * x[1]		0x1000 => 2.0
        MPYF    R_T2,		R_T1,	R_A1	; R_A1 = x[2] = x[1] * (2.0 - number * x[1])
@


1.7
log
@changed double ordering to big endian
@
text
@d102 3
a104 3
	STI	R_A1,	*\-\-R_USP(1)	; save high part as integer
	LDF	*R_USP++(1),	R_A1	; load back as an FP number
	LDI	R_A2,		R_A1	; load in low part
d106 3
a108 3
	LDF	R_A1,	R_T1		; R_T1 = x
        RSQRF	R_A1,	R_T2		; R_T2 = x[0] = (estimate of) 1/sqrt(x)
        MPYF	0xF000,	R_A1		; R_A1 = x / 2				0xf000 => 0.5
d110 4
a113 4
	MPYF	R_T2,	R_T2,  R_T3	; R_T3 = x[0] * x[0]
	MPYF	R_A1,	R_T3		; R_T3 = (x/2) * x[0] * x[0]
	SUBRF	0x0400,	R_T3		; R_T3 = 1.5 - (x/2) * x[0] * x[0]	0x0400 => 1.5
	MPYF	R_T3,	R_T2		; x[1] = x[0] * (1.5 - x/2 * x[0] * x[0])
d116 5
a120 5
	MPYF	R_T2,	R_T2,  R_T3	; R_T3 = x[1] * x[1]
	MPYF	R_A2,	R_T3		; R_T3 = (x/2) * x[1] * x[1]
	SUBRF	0x0400, R_T3		; R_T3 = 1.5 - (x/2) * x[1] * x[1]	0x0400 => 1.5
	BuD	R_LR		; return (delayed)
	MPYF	R_T3,	R_T2		; x[2]  = x[1] * (1.5 - x/2 * x[1] * x[1])
d122 3
a124 3
	RND     R_T2			; round before multiplying
	MPYF    R_T2,	R_T1,  R_A1	; sqrt(x) = x * 1/sqrt(x)
				; return takes place now
d144 3
a146 3
	STI	R_A1,	*\-\-R_USP(1)	; save number as integer
	LDF	*R_USP++(1),	R_A1	; load back as an FP number
	LDI	R_A2,		R_A1	; load in low part
d148 1
a148 1
	RCPF    R_A1,  R_T1		; R_T1 = x[0] = estimate of 1/number
d150 3
a152 3
        MPYF    R_T1,	R_A1, R_T2	; R_T2 = number * x[0]
        SUBRF   0x1000,	R_T2		; R_T2 = 2.0 - number * x[0]		0x1000 => 2.0
        MPYF    R_T2,	R_T1		; R_T1 = x[1] = x[0] * (2.0 - v * x[0])
d154 1
a154 1
	BuD	R11		; return (delayed)
d156 4
a159 4
        MPYF    R_T1,	R_A1, R_T2	; R_T2 = number * x[1]
        SUBRF   0x1000,	R_T2		; R_T2 = 2.0 - number * x[1]		0x1000 => 2.0
        MPYF    R_T2,	R_T1,  R_A1	; R_A1 = x[2] = x[1] * (2.0 - number * x[1])
				; return takes place now
d165 1
a165 1
	CMPI	2,    R_A1			; are we initialising function table ?
d167 1
a167 1
	LDI	R_LR, R_ADDR1			; save return address
d169 1
a169 1
	LDI	R_MT, R_ATMP			; get module table pointer into temporary register
d173 1
a173 1
	ADDI	1, R_ATMP			; add in our module number
d175 1
a175 1
	LDI	*R_ATMP, R_ATMP			; get pointer to function table
d178 3
a180 3
	LDI	R_LR, RS			; save link register
	SUBI	here - .modf, R_LR		; load address of modf routine
	STI	R_LR, *R_ATMP++(1)		; save in function table
d182 3
a184 3
	LDI	RS, R_LR			; get hold of PC again
	SUBI	here - ._sqrt, R_LR		; load address of _sqrt routine
	STI	R_LR, *R_ATMP++(1)		; save in function table
d186 1
a186 1
	BuD	R_ADDR1			; return (delayed)
d188 1
a188 1
	LDI	RS, R_LR			; get hold of PC again
d190 1
a190 1
	STI	R_LR, *R_ATMP++(1)		; save in function table
@


1.6
log
@fixed to cope with arguments being in two registers
@
text
@d21 1
a21 1
; $Id: maths.a,v 1.5 1992/03/11 17:57:49 nickc Exp nickc $
d45 2
a46 2
;	R_A1	value to convert (low part)
;	R_A2	value to convert (high part)
d59 1
a59 1
	LSH	-2,	R_A3, R_ATMP		; convert pointer to word addressing
d62 3
a64 3
	STI	R_A2,	*\-\-R_USP(1)		; save high of FP number
	LDF	*R_USP++(1),	R_A2		; load back as FP number
	LDI	R_A1,		R_A2		; load in low part
d66 2
a67 2
        FIX	R_A2,	R_T1			; convert FP number to integer
	LDFv	R_A2,	R_T1			; but if overflow occured
d72 4
a75 4
	CMPF    R_T1,	R_A2			; otherwise see if the number has a fractional part
	LDFeq	0x8000,	R_T2			; no - we are OK				0x8000 = 0.0
	LDFne	0x0000,	R_T2			; yes - we must add one to integer part		0x0000 = 1.0
	ADDF	R_T2,	R_T1			; perform the addition
d88 2
a89 2
;	R_A1	value to convert (low  part)
;	R_A2	value to convert (high part)
d102 3
a104 3
	STI	R_A2,	*\-\-R_USP(1)	; save high part as integer
	LDF	*R_USP++(1),	R_A2	; load back as an FP number
	LDI	R_A1,		R_A1	; load in low part
d106 3
a108 3
	LDF	R_A2,	R_T1		; R_T1 = x
        RSQRF	R_A2,	R_T2		; R_T2 = x[0] = (estimate of) 1/sqrt(x)
        MPYF	0xF000,	R_A2		; R_A2 = x / 2				0xf000 => 0.5
d111 1
a111 1
	MPYF	R_A2,	R_T3		; R_T3 = (x/2) * x[0] * x[0]
d130 2
a131 2
;	R_A1	value to convert (low  part)
;	R_A2	value to convert (high part)
d144 3
a146 3
	STI	R_A2,	*\-\-R_USP(1)	; save number as integer
	LDF	*R_USP++(1),	R_A2	; load back as an FP number
	LDI	R_A1,		R_A2	; load in low part
d148 1
a148 1
	RCPF    R_A2,  R_T1		; R_T1 = x[0] = estimate of 1/number
d150 1
a150 1
        MPYF    R_T1,	R_A2, R_T2	; R_T2 = number * x[0]
d156 1
a156 1
        MPYF    R_T1,	R_A2, R_T2	; R_T2 = number * x[1]
@


1.5
log
@removed module stuff
@
text
@d21 1
a21 1
; $Id: maths.a,v 1.4 1992/03/10 15:45:35 nickc Exp nickc $
d45 3
a47 2
;	R_FA1	value to convert
;	R_FA2	pointer to location to place integer part of number
d51 1
a51 1
;	R_FA1	fractional part of number
d59 1
a59 1
	LSH	-2,	R_FA2, R_ATMP		; convert pointer to word addressing
d62 6
a67 2
        FIX	R_FA1,	R_T1			; convert FP number to integer
	LDFv	R_FA1,	R_T1			; but if overflow occured
d72 1
a72 1
	CMPF    R_T1,	R_FA1			; otherwise see if the number has a fractional part
d80 1
a80 1
	SUBF    R_T1,	R_FA1			; subtract integer part to leave fractional part
d88 2
a89 1
;	R_FA1	value to convert
d93 1
a93 1
;	R_FA1	non-negative square root of the number
d102 3
a104 3
	LDF	R_FA1,  R_T1		; R_T1  = x
        RSQRF	R_FA1,  R_T2		; R_T2  = x[0] = (estimate of) 1/sqrt(x)
        MPYF	0xF000,	R_FA1		; R_FA1 = x / 2				0xf000 => 0.5
d106 3
a108 4
	MPYF	R_T2,	R_T2,  R_T3	; R_T3  = x[0] * x[0]
	MPYF	R_FA1,  R_T3		; R_T3  = (x/2) * x[0] * x[0]
	SUBRF	0x0400, R_T3		; R_T3  = 1.5 - (x/2) * x[0] * x[0]	0x0400 => 1.5
	MPYF	R_T3,	R_T2		; x[1]  = x[0] * (1.5 - x/2 * x[0] * x[0])
d110 5
d116 4
a119 4
	MPYF	R_T2,	R_T2,  R_T3	; R_T3  = x[1] * x[1]
	MPYF	R_FA1,  R_T3		; R_T3  = (x/2) * x[1] * x[1]
	SUBRF	0x0400, R_T3		; R_T3  = 1.5 - (x/2) * x[1] * x[1]	0x0400 => 1.5
	Bud	R11		; return (delayed)
d123 1
a123 1
	MPYF    R_T2,	R_T1,  R_FA1	; sqrt(x) = x * 1/sqrt(x)
d130 2
a131 1
;	R_FA1	value to convert
d135 1
a135 1
;	R_FA1	1 / number
d144 3
a146 1
	RCPF    R_FA1,  R_T1		; R_T1  = x[0] = estimate of 1/number
d148 5
a152 3
        MPYF    R_T1,	R_FA1, R_T2	; R_T2  = number * x[0]
        SUBRF   0x1000,	R_T2		; R_T2  = 2.0 - number * x[0]		0x1000 => 2.0
        MPYF    R_T2,	R_T1		; R_T1  = x[1] = x[0] * (2.0 - v * x[0])
d156 3
a158 3
        MPYF    R_T1,	R_FA1, R_T2	; R_T2  = number * x[1]
        SUBRF   0x1000,	R_T2		; R_T2  = 2.0 - number * x[1]		0x1000 => 2.0
        MPYF    R_T2,	R_T1,  R_FA1	; R_FA1 = x[2] = x[1] * (2.0 - number * x[1])
@


1.4
log
@fixed bug in modf()
@
text
@d21 1
a21 1
; $Id: maths.a,v 1.2 1992/02/26 17:00:02 paul Exp $
a26 4

_include 'module.m
StartModule maths -1 1

d33 7
d147 2
d189 1
@


1.3
log
@updated to use register naming scheme and fixed minor bug in modf()
@
text
@d70 2
a71 1
	STF     R_T1,	*+R_ATMP( R_BASE )	; save integer part in memory
a72 1
	NOP					; padding
@


1.2
log
@removed unecessary exports
@
text
@d2 1
a2 1
; math.a - assembly language support for the C maths library
d15 1
a15 1
; Modificatins to the Texas source are
d21 1
a21 1
; $Id: maths.a,v 1.1 1992/02/26 09:49:17 nickc Exp $
d27 4
d42 3
a44 3
;	R0	value to convert
;	R2	pointer to location to store integer part of number
;	R11	return address
d47 1
a47 1
;	R0	fractional part of number
d50 1
a50 1
;	R8, R9, AR5, ST
d55 2
a56 2
	LSH	-2, R2, AR5	; convert pointer to word addressing
	Beq	R11		; if the pointer is NULL, return
d58 10
a67 10
        FIX	R0, R8		; convert FP number to integer
	LDFv	R8, R0		; but if overflow occured
	Bv	R11		; load original number and skip to end

	FLOAT	R8		; convert integer value back into FP
        Bge	result		; if the number was positive we are OK
	CMPF    R8, R0		; otherwise see if the number has a fractional part
	LDFeq	0x8000, R9	; no - we are OK				0x8000 = 0.0
	LDFne	0x0000, R9	; yes - we must add one to integer part		0x0000 = 1.0
	ADDF	R9,  R8		; perform the addition
d69 5
a73 5
        BuD	R11		; return (delayed)
	STF     R8, *+AR5(IR0)  ; save integer part in memory
	SUBF    R8, R0		; subtract integer part to leave fractional part
	NOP			; padding
			; return takes place now
d80 2
a81 2
;	R0	value to convert
;	R11	return address
d84 1
a84 1
;	R0	non-negative square root of the number
d87 1
a87 1
;	R8, R9, R10, ST
d93 13
a105 13
	LDF	R0,  R8		; save x
        RSQRF	R0,  R9		; R9 = x[0] = estimate of 1/sqrt(x)
        MPYF	0xF000, R0	; R0 = x/2				0xf000 => 0.5

	MPYF	R9,  R9, R10	; R10 = x[0] * x[0]
	MPYF	R0,  R10	; R10 = (x/2) * x[0] * x[0]
	SUBRF	0x0400, R10	; R10 = 1.5 - (x/2) * x[0] * x[0]	0x0400 => 1.5
	MPYF	R10, R9		; x[1] = x[0] * (1.5 - x/2 * x[0] * x[0])

	RND     R9
	MPYF	R9,  R9, R10	; R10 = x[1] * x[1]
	MPYF	R0,  R10	; R10 = (x/2) * x[1] * x[1]
	SUBRF	0x0400, R10	; R10 = 1.5 - (x/2) * x[1] * x[1]	0x0400 => 1.5
d107 1
a107 1
	MPYF	R10, R9		; x[2] = x[1] * (1.5 - x/2 * x[1] * x[1])
d109 3
a111 3
	RND     R9
	MPYF    R9,  R8, R0	; sqrt(x) = x * sqrt(1/x)
			; return takes place now
d117 1
a117 1
;	R0	value to convert
d121 1
a121 1
;	R0	1 / number
d124 1
a124 1
;	R8, R9, ST
d128 1
d130 1
a130 1
	RCPF    R0,  R8		; R8 = x[0] = estimate of 1/number
d132 3
a134 3
        MPYF    R8,  R0, R9	; R9 = number * x[0]
        SUBRF   0x1000, R9	; R9 = 2.0 - number * x[0]		0x1000 => 2.0
        MPYF    R9,  R8		; R8 = x[1] = x[0] * (2.0 - v * x[0])
d138 44
a181 4
        MPYF    R8,  R0, R9	; R9 = number * x[1]
        SUBRF   0x1000, R9	; R9 = 2.0 - number * x[1]		0x1000 => 2.0
        MPYF    R9,  R8, R0	; R0 = x[2] = x[1] * (2.0 - number * x[1])
			; return takes place now
d183 1
@


1.1
log
@fixed to run through Paul's assembler
@
text
@d21 1
a21 1
; $Id$
d139 1
a139 12
;
; export the routines
;

codetable _modf
export    _modf

codetable __sqrt
export    __sqrt

codetable __invert
export    __invert
@
