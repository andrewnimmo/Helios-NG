head	1.7;
access;
symbols
	Helios_1_3_1:1.7;
locks
	tony:1.7; strict;
comment	@-- @;


1.7
date	93.09.17.16.04.11;	author paul;	state Exp;
branches;
next	1.6;

1.6
date	93.08.18.18.28.40;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	93.08.18.17.44.37;	author paul;	state Exp;
branches;
next	1.4;

1.4
date	93.08.18.15.44.05;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	93.08.17.09.48.46;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	93.06.17.19.13.20;	author paul;	state Exp;
branches;
next	1.1;

1.1
date	93.06.14.16.27.29;	author paul;	state Exp;
branches;
next	;


desc
@C40 ROM bootstrap code.
@


1.7
log
@fixes for config size - now correctly specified in terms of bytes and
initial C stack is now set to dispatch stack to fix addressibility
problems if RAM is loacated higher than the first quadrant of memory.
@
text
@-- File:	c40rombt.a
-- Subsystem:	'C40 Helios executive
-- Author:	P.A.Beskeen
-- Date:	June '93
--
-- Description: 'C40 specific ROM boot code.
--
--		This code is used to bootstrap a Helios system held in ROM.
--
--		The bootstrap and nucleus to be booted may reside in any form
--		of ROM/EPROM/FLASH/EEPROM at any C40 boot address. The nucleus
--		may be copied from ROM or some other type of storage media into
--		faster/addressable RAM memory. All Helios-C40 code is completely
--		position independent.
--
--		The code here is very similar to the communications link
--		bootstrap 'c40boot.a'. The design of the (version 1.3.1 and
--		later) Helios-C40 nucleus supports both ROM and link booting.
--		Furthermore, existing link booted nuclei can be ROMmed and
--		any ROMed nuclei can be transmitted down a link to boot
--		processors configured to boot from link.
--
--		The different phases of the bootstrap are:
--
--		1)	C40 CPU boot loader execution and memory control
--			register initialisation.
--
--		2)	System specific CPU and memory initialisation.
--
--		3)	System self test if required.
--
--		4)	Helios memory map setup, including copy of nucleus
--			from ROM (or other storage media) to RAM if required.
--
--		5)	Initialisation of Helios kernel's internal copy of the
--			IDROM structure.
--
--		6)	Initialisation of Helios kernel's internal copy of the
--			Config structure.
--
--		7)	Setup of minimal C PCS (Procedure Call Standard)
--			environment and jump to the Helios kernel's entry
--			point.
--
--		To configure this bootstrap for your board, the ROM_BASE
--		should point at the location of the ROM on its address bus.
--		You may also wish to copy the ROMed nucleus into RAM for more
--		speed by uncommenting the COPY_ROM_TO_RAM option, and if
--		your data RAM on the local bus is below 0x402ff000 uncomment
--		the ONCHIP_RAM_WITHIN_ADDRESSABILITY option. You will also
--		have to update the GBCR and LBCR words in the C40 boot loader
--		header to the appropriate values for your memory system.
--		You should also look at the ROMmed IDROM and Config structures
--		defined at the file. You may wish to customise some of these
--		for you board.
--
--		Note that this file must be linked using ld's -i option to
--		suppress the generation of the normal Helios image header.
--
--
-- RcsId: $Id: c40rombt.a,v 1.6 1993/08/18 18:28:40 paul Exp $
--
-- (C) Copyright 1993 Perihelion Software Ltd.
--
-- 
-- RcsLog: $Log: c40rombt.a,v $
-- Revision 1.6  1993/08/18  18:28:40  paul
-- fixed IACK address
--
-- Revision 1.5  1993/08/18  17:44:37  paul
-- Cleaned up comments some more.
--
-- Revision 1.4  1993/08/18  15:44:05  paul
-- Added example IDROM and changed Config init to copy static ROMed config
-- structure. Bootstrap now supports C40 CPU bootloader (but also requires
-- use of the -i option to the linker). Cleaned up comments. Added the CPU
-- cache initialisation I had forgotten earlier!
--
-- Revision 1.3  1993/08/17  09:48:46  paul
-- updated comments
--
-- Revision 1.2  1993/06/17  19:13:20  paul
-- updated with new Config struct initialisation
--
-- Revision 1.1  1993/06/14  16:27:29  paul
-- Initial revision
--


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- Bootstrap Constants and Options.
	--
	-- You may wish to select different values for the following constants
	-- and options.

	-- Possible base addresses for ROM on a C40 are 0x00300000, 0x40000000,
	-- 0x60000000, 0x80000000, 0xa0000000 and 0xc0000000. This MUST be
	-- changed to reflect the base address in your system.

	_def	'ROM_BASE	0x60000000

	_def	'ROM_NUC_BASE	[(ROM_BASE + (BootstrapEnd - BootstrapStart) / 4)]

	-- You may choose to copy the entire nucleus into RAM for faster
	-- execution, or to get full 32bit memory access if the ROM is not
	-- 32bit. The downside is that you will use up more RAM.
	-- _def	'COPY_ROM_TO_RAM	TRUE	-- Copy nucleus into faster RAM.

	-- If the main RAM block and on-chip RAM are within C addressability
	-- range of one other (4GB), then set this option. i.e. data RAM does
	-- not exceed 0x402ff000.
	-- _def 'ONCHIP_RAM_WITHIN_ADDRESSABILITY TRUE


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- AMPP macro include files.

	include basic.m
	include c40.m
	include tim40.m
	include c40mmap.m
	include ../gexec.m
	include module.m
	include config.m
	include root.m
	include link.m


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- 1) C40 CPU boot loader execution and memory control register
	--    initialisation.
	--
	-- The bootstrap code may either be encapsulated by the standard C40
	-- CPU bootstrap header and copied in its entirety by the boot loader
	-- into RAM, or jumped to from a simple boot program loaded by the C40's
	-- boot loader. For a description of the C40 boot loader see section
	-- 13.2, page 13-5: "Boot Loader Description and External ROM
	-- Interfacing" of the TMS320C40 User Guide. This example boot loader
	-- header causes the entire bootstrap to be copied to the onchip RAM
	-- and executed there. It therefore expects to be located at the
	-- start of the ROM image on one of the 6 standard C40 ROM bootstrap
	-- boundaries.

BootstrapStart:

	-- C40 CPU boot loader header:

	-- ROM width.
	word	32		-- 32 bit ROM (16 = 16 bit ROM, 8 = 8 bit ROM).

	-- Bus controller registers.
	-- The following bus controller register contents should hold the
	-- values required to initialise your boards memory subsystem.
	word	0x3e39fff0	-- GBCR
	word	0x3e39fff0	-- LBCR

	-- Size of bootstrap to copy in words.
	word	(BootstrapCopyEnd - BootstrapEntryPoint) / 4

	word	0x2ffc00	-- load address - onchip ram block 1.


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- 2) System specific CPU and memory initialisation.
	--
	-- Any futher memory initialisation, such as possibly setting up the
	-- timers for DRAM refresh should be done at this point. This will
	-- enable us to start using the external RAM. The on-chip C40
	-- boot loader will already have initialised the GBCR and LBCR memory
	-- controller registers. Any system specific hardware initialisation
	-- should also be done at this point.

BootstrapEntryPoint:

	-- Enable C40 cache.
	or	ST_CE, st

	-- The bootstrap uses data in an 'IDROM' to initialise the C40 from
	-- and which it then copies into a private kernel structure. An IDROM
	-- is a structure used to define a C40 board's characteristics such as
	-- memory size and location. The Helios nucleus refers to the IDROM in
	-- order to adapt to the environment in which it finds itself running.
	--
	-- The IDROM used by the bootstrap is defined at the end of this file.

	-- Load address of ROMed copy of boards IDROM.
	ldabs32_unsafe BoardIDROM ar5

	-- Load base addr of C40's internal periperal map.
	ldperimap ar0

	-- Timer 1 is not used by Helios and may be used as required by the
	-- user/hardware. For example it may be used for the boards DRAM
	-- refresh.
	ldi	*+ar5(IDROM.TIMER1_PERIOD), r0
	sti	r0, *+ar0(timer1_period)

	ldi	*+ar5(IDROM.TIMER1_CTRL.w_offset), r0
	-- Timer1 actually in upper 16 bits of word.
	lsh	-IDROM.TIMER1_CTRL.shift, r0

	-- Set the timer to run on when a JTAG halt is in effect,
	-- this ensures that DRAM refresh continues.
	ldhi	((tcr_dbgcont1 | tcr_dbgcont2) >> 16) & 0xffff, r1
	or	r1, r0
	sti	r0, *+ar0(timer1_control)

	-- Timer 2 is dedicated to Helios, it is used for timekeeping and
	-- timeslicing. Its period register should be initialised to provide
	-- an accurate 1mS period for this hardware's particular clock speed.
	ldi	*+ar5(IDROM.TIMER0_PERIOD), r0
	sti	r0, *+ar0(timer0_period)


	----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- 3) System self test if required.
	--
	-- Any system self test code should be inserted at this point.



	----------------------------------------------------------------------
	----------------------------------------------------------------------
	-- 4) Helios memory map setup, including copy of nucleus from ROM
	--    (or other storage media) to RAM if required.
	--
	-- The Helios memory map:
	--
	--	     Hi addr.
	--
	--	------------------
	--	Trace Vector		Set up by Helios.
	--	------------------
	--
	--	Poss. second strobe
	--	memory block.
	--
	--	------------------	Memory pools as set up by Helios.
	--	Poss. dummy block	Used to stitch together noncontigous
	--	------------------	strobe 0/1 if both contain RAM.
	--
	--	Main Memory Pool
	--
	--	------------------
	--	Config vector		Initialised by ROM bootstrap.
	--	------------------
	--	Kernel Root
	--	------------------
	--	Interrupt vectors       256 bytes (must be 2kb boundary aligned).
	--	------------------
	--	System Stack (1kb)
	--	------------------
	--	ExecRoot (1kb)		Contains IDROM initialised by bootstrap.
	--	------------------
	--	Copied Nucleus		(Only if copied into RAM from flash/ROM/disk)
	--	------------------	< Base of local/global bus strobe 0/1
	--
	--	     Lo addr.
	--

	-----------------------------------------------------------------------
	-- Set base of RAM. Helios holds the main system structures just above
	-- this point, such as the ExecRoot, system stack, interrupt vector
	-- table, kernel root, Config structure and C addressable user RAM.
	-- It may be located on the local or global bus and either stobe
	-- on these busses.
	--
	-- The nucleus location is completely independent of this and may
	-- be located on any strobe on either bus.
	--
	-- The Helios C address base is the base address to which all C byte
	-- addresses are added to get a machine address. The IR0 register
	-- (referred to by the R_BASE alias) is dedicated to hold this value.
	-- The C address base is usually set to the start of RAM, but if the
	-- last word of this RAM is within byte addressability range of the
	-- on-chip RAM, then the C address base should be set to the start of
	-- the on-chip RAM. This allows on-chip RAM to be directly accessable
	-- from C.

	-- For example, if system RAM is located on strobe 0 of the local bus:
	ldi	*+ar5(IDROM.LBASE0), ar1

	_test _defp 'ONCHIP_RAM_WITHIN_ADDRESSABILITY [
		ldhi	0x002f, R_BASE	-- Set C address base to on-chip RAM
		or	0xf000, R_BASE	-- both this and the RAM can be
					-- addressable from C. (i.e. are
					-- within 4 gigabytes of each other).
	][
		ldi	ar1, R_BASE	-- otherwise set it at base of RAM.
	]

	-----------------------------------------------------------------------
	-- If the nucleus needs to be copied from slow ROM, or the boot sector
	-- of a disk, to RAM, then it should be copied at this point. If the
	-- nucleus is to be copied to the same strobe and bus that we are
	-- using for the system data, then the ExecRoot's position should be set
	-- to the next free location after the nucleus. If the nucleus is placed
	-- on another bus/strobe, then the RAM used to hold the nucleus should
	-- NOT be included in the IDROM. Otherwise Helios will attempt to use
	-- this memory as workspace! The following code assumes a 32 bit wide
	-- ROM. If you wish to copy non 32 bit wide ROM to RAM in order to be
	-- able to execute it, then you will have to re-work this code.

	_test _defp 'COPY_ROM_TO_RAM [
CopyNuc:
		-- Get address of nucleus in ROM.
		ldi32	ROM_NUC_BASE ar3

		ldi	*ar3, r0	-- read # bytes of image to copy
		ldi	ar1, ar4	-- ar1 points to nucleus load area

		sti	r0, *ar4++	-- save size as part of image
		lsh	-2, r0		-- / sizeof(word) - convert to # words
		subi	3, r0		-- initialise for rpts
					-- -1 size, -2 rpts and || correction
		-- Copy nucleus image
		ldi	*ar3++, r1	-- initialise r1 for parallel loop
		rpts	r0		-- loops r0 + 1
			ldi	*ar3++, r1 || sti	r1, *ar4++
		sti	r1, *ar4++	-- store final value

		-- Setup address of ExecRoot to follow nucleus.
		-- Otherwise we will use the base of RAM.
		-- tvtp and ivtp must lie on a 512 word (2k) boundary.
		addi	512-1, ar4
		andn	512-1, ar4

		-- GetExecRoot macro and function loads this address from tvtp
		ldpe	ar4, tvtp

		-- Save start address of nucleus in ExecRoot.
		-- Nucleus location is held as a word pointer on C40
		sti	ar1, *+ar4(ExecRoot.Nucleus)
		ldi	ar4, ar1	-- following code expects ar1 = ExecRoot
	][
		-- Set address of ExecRoot.
		-- This is held in the tvtp expansion register.
		-- tvtp and ivtp must lie on a 512 word (2k) boundary.

		-- GetExecRoot macro and function loads this address from tvtp
		ldpe	ar1, tvtp

		-- Save address of nucleus in ExecRoot.
		-- Nucleus location is held as a word pointer on C40
		ldi32	ROM_NUC_BASE ar2
		sti	ar2, *+ar1(ExecRoot.Nucleus)
	]

	-- Save standard address base in nucleus.
	sti	R_BASE,	*+ar1(ExecRoot.CAddressBase)

	-- Set default HW_Config sent to bootstrap when booting other
	-- processors down a link (a copy of HW_Config is sent to bootstrap
	-- booted down a link). In link booted systems the HW_Config word
	-- determines what bus/strobe to load the nucleus to. Use the
	-- HW_NucleusXXXXXXX flags in config.m if you  wish to set the default
	-- nucleus load address for CPU's booted from this processor.
	stik	0, *+ar1(ExecRoot.HWConfig)

	-- Position system stack pointer directly after ExecRoot.
	-- ExecRoot and SSP are nominally 1kb in size each. (system stack
	-- builds upwards) .sizeof defined in terms of bytes so / 4 to get
	-- words.
	ldi	ar1, R_SSP
	addi	ExecRoot.sizeof / 4, R_SSP

	-- Align interrupt vectors to 0x200 word boundary after ExecRoot
	-- and system stack.
	ldi	R_SSP, ar3
	addi	0x200-1, ar3
	andn	0x200-1, ar3
	ldpe	ar3, ivtp	-- set interrupt vector position

	addi	0x40, ar3	-- add size of interrupt vector table
				-- to give kernel root position

	-- The Kernel root struct is located directly after the interrupt
	-- vector table.
	ldi	ar3, r0
	C40CAddress r0				-- Convert to BPTR.
	sti	r0, *+ar1(ExecRoot.KernelRoot)	-- Save in ExecRoot.


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- 5) Initialisation of Helios kernel's internal copy of the IDROM
	--    structure.
	--
	-- The TIM-40 standard IDROM is a structure that characterises the
	-- C40 hardware of this particular board. Helios-C40 uses the IDROM
	-- to configure itself to the hardware environment in which it finds
	-- itself executing. The IDROM is held in an internal Helios structure
	-- for reference by the nucleus during initialisation and execution.
	--
	-- On entry to this code fragment:
	--	AR1 = ExecRoot
	--	AR5 = Address of ROMed copy of IDROM

	-- Get address of kernel's internal copy of the IDROM structure.
	addi	ExecRoot.ID_ROM, ar1, ar4

	-- Get size of IDROM.
	ldi	IDROM.sizeof / 4, r0

	-- Copy IDROM into ExecRoot structure
IDROM_Copy:
	ldi	*ar5++, r1
	sti	r1, *ar4++
	subi	1, r0
	bnz	IDROM_Copy


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- 6) Initialisation of Helios kernel's internal copy of the Config
	--    structure.
	--
	-- Config is a Helios specific structure used to define information
	-- required to initialise the Helios nucleus for this particular
	-- environment.
	--
	-- See near the end of this file for the example config structure.
	--
	-- On entry to this code fragment:
	--	AR3 = WPTR to kernel Root structure.

	-- Get address of the kernel's internal copy of the Config structure.
	-- This is held directly after the Root structure. As AR3 holds the
	-- address of the kernel Root, simply add its size to get Config's
	-- address (.sizeof returns byte size, hence the divide by four).
	addi	Root.sizeof / 4, ar3

	-- Load address of ROMed copy of Config.
	ldabs32_unsafe	BoardConfig ar5

	-- Get size of Config structure and convert to # words.
	lsh	-2, *+ar5(Config.ImageSize), r0

	-- Copy Config into internal position.
Config_Copy:
	ldi	*ar5++, r1
	sti	r1, *ar3++
	subi	1, r0
	bnz	Config_Copy


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- 7) Setup of minimal C PCS (Procedure Call Standard) environment and
	--    jump to the Helios kernel's entry point.
	--
	-- The kernel entry point's prototype is:
	-- 	void KStart(Channel bootlink, word *nucbase)
	--
	-- In a ROM booted system the 'bootlink' parameter is -1 to denote
	-- a ROM bootstrap sequence, as apposed to a link bootstrap. The
	-- nucbase is the address of the nucleus.
	--
	-- On entry to this code fragment:
	--	AR1 = ExecRoot

	-----------------------------------------------------------------------
	-- Setup C PCS.

	-- Setup initial C stack.
	_test _false [
		-- This is a FALLING stack from top of internal RAM.
		ldhi	0x30, R_USP	-- 0x002f ffff
		subi	1, R_USP
	][
		-- Falling stack using the dispatch stack for initialisation.
		-- This relies on the initial kernel thread NEVER blocking
		-- and interrupts NOT being enabled until a new C addressable
		-- stack has allocated from an initialised memory system.
		ldi	ExecRoot.DispatchStack + DISPATCHSTACKSIZE - 1, R_USP
		addi	ar1, R_USP
	]

	-- C PCS defines that registers set the flags.
	or	ST_SET_COND, R_ST

	-- No need to set up Module table pointer as this is not required by
	-- KStart.
	
	-----------------------------------------------------------------------
	-- Construct arguments to KStart().

	-- Bootlink is -1 to signify ROM booted system.
	ldi	-1, R_A1			-- bootlink is arg 1

	ldi	*+ar1(ExecRoot.Nucleus), R_A2	-- Nucleus base is arg 2

	-----------------------------------------------------------------------
	-- Jump into nucleus's kernel module (kmodule).
	-- jmp addr = *(GetNucBase() + 1) + (GetNucBase() + 1) + sizeof(Module)

	-- Get pointer to nucleus from arg 2 and increment to point at kernel
	-- slot in nucleus contents table.
	addi	1, R_A2, ar2

	-- Convert kernel slot RPTR (self relative pointer) to address of
	-- kernel's module.
	ldi	*ar2, ar1	-- Get kernel RPTR - byte offset to kernel.
	lsh	-2, ar1		-- Convert byte offset to number of words,
	addi	ar2, ar1	-- and add in address of kernel RPTR.

	-- Step over module header (.sizeof in terms of bytes).
	addi	Module.sizeof / 4, ar1

	-- Jump to kernel entry point.
	b	ar1		-- "My god... its full of stars"


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- ROMed copy of IDROM structure.
	--
	-- The following data defines the boards 'IDROM' structure. The IDROM
	-- is a standard defined by Texas Instruments and used by Helios-C40 to 
	-- adapt to the environment in which it find itself running. The
	-- document "TIM-40 TMS320C4x Module Specification" defines the
	-- standard and is available from TI. For a quick description of the
	-- following items, refer to the Helios example I/O Server configuration
	-- file "template.con" on the Helios-C40 distribution disk/tape. Its
	-- structure is also defined in "/hsrc/include/ampp/tim40.m".

BoardIDROM:
	-- Miscellaneous items. The following 7 items do not need to be set
	-- as they are not used by Helios.
	word	IDROM.sizeof / 4	-- SIZE - defined in words.
	short	0xfffe		-- MAN_ID - manufacturers ID.
	byte	0		-- CPU_ID (0 = C40).
	byte	49		-- CPU_CLK (49 = 40Mhz, 39 = 50Mhz, 29 = 60Mhz)
	short	0		-- MODEL_NO - board type ID/
	byte	0		-- REV_LVL - board revison level.
	byte	0		-- RESERVED.

	-- Memory bank location and size. These values must be set for your
	-- board. The following example contents define 2 blocks of memory,
	-- local strobe 0 and global strobe 0, starting at addresses 0x300000
	-- and 0x80000000 respectively, both blocks containing 4MB's of RAM.
	-- ONLY RAM memory should be included in these descriptions, NOT ROM
	-- Helios initialises its memory pool bounds from these values.
	word	0x80000000	-- GBASE0.
	word	-1		-- GBASE1 (-1 = no memory).
	word	0x00300000	-- LBASE0.
	word	-1		-- LBASE1 (-1 = no memory).

	-- The following memory bank sizes are defined in terms of number of
	-- words, NOT bytes.
	word	0x00100000	-- GSIZE0 (4MB's).
	word	0		-- GSIZE1.
	word	0x00100000	-- LSIZE0 (4MB's).
	word	0		-- LSIZE1.

	word	0800		-- FSIZE (just onchip RAM).

	-- Speed of memory - not used by Helios.
	byte	0x22		-- WAIT_G.
	byte	0x22		-- WAIT_L.
	byte	0x55		-- PWAIT_G.
	byte	0x55		-- PWAIT_L.

	-- Timer values - TIMER0_PERIOD must be set for accurate Helios clock.
	word	0x2710		-- TIMER0_PERIOD (40Mhz 0x2710, 50Mhz 0x30d4).
	word	0x80		-- TIMER1_PERIOD (DRAM refresh frequency).
	short	0x2c2		-- TIMER0_CTRL.
	short	0		-- TIMER1_CTRL (Can be used for DRAM refresh).

	-- Memory control registers - These are actually set by the CPU
	-- boot loader header.
	word	0x3e39fff0	-- GBCR.
	word	0x3e39fff0	-- LBCR.

	-- Not used by Helios.
	word	1		-- AINIT_SIZE.

BoardIDROMEnd:


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- ROMed copy of Config structure.
	--
	-- Config is a Helios specific structure used to define information
	-- required to initialise the Helios nucleus for this particular
	-- board's environment. Its structure is defined in the include file
	-- '/hsrc/include/ampp/config.m' in the Helios source include directory.
	--
	-- The size of the Config structure passed should be placed within its
	-- own ImageSize element. The size is not fixed as the number of links
	-- defined may be non-standard (and therefore more LinkConf structures
	-- than normal used), or the names of the processor and I/O Server
	-- may not be the same as the defaults (and therefore added to the end
	-- of the Config structure). This use of ImageSize is only valid
	-- during bootstrap and Helios initialisation, the kernel will alter
	-- it at a later point.

BoardConfig:
		-- Size of the initial port table (and further increments)
	word	1024		-- PortTabSize

		-- Number of times booted this session - immaterial
	word	1		-- Incarnation

		-- Obsolete - Helios kernel now sets this value.
	word	0		-- LoadBase

		-- Set size of Config. If you increase the number of links
		-- from 6 (for example to provide a pseudo link implemented
		-- with shared memory), or require a processor name other
		-- than the default /00, then this size will change. size
		-- is defined in terms of bytes.
	word	BoardConfigEnd - BoardConfig * 4	-- ImageSize in bytes

		-- Current time to initialise Helios's internal clock and
		-- date from. This is a Unix style date stamp defined as
		-- seconds since 1970 GMT. You may wish to initialise this
		-- value from an RTC if your system supports one.
	word	0		-- Date			-- current system date

		-- The first program in the system to be executed. The number
		-- refers to the order of modules in the nucleus. Always
		-- the ProcMan!
	word	6		-- FirstProg

		-- Size of memory (Default specified by kernel if 0). This is
		-- an anacronism, the memory sizes should be always be defined
		-- in the IDROM structure. This should always be zero.
	word	0		-- MemSize

		-- Set Config flags:
		--	Root_Flags_rootnode:	This is the root processor in a
		--				network.
		--	Root_Flags_ROM:		The nucleus is ROMmed in this
		--				node.
		--
		-- If either of these flags is set, then the 'init' program
		-- will be run as the final phase of the nucleus's
		-- initialisation.
	word	Root_Flags_rootnode | Root_Flags_ROM	-- Flags

		-- reserved (spare) slot
	word	0		-- Spare

		-- Setup the processors name and possibly non-existent I/O
		-- Server. These two RPTRs (self relative pointers) can be
		-- -1 to signify /00 and /IO as acceptable defaults. If other
		-- names are required, then these should be appended to the
		-- end of the structure, and the two RPTRs changed to point at
		-- these names. If the defaults are not used then the size
		-- should be updated accordingly (in Config.ImageSize).
		-- Config.ParentName (/IO) is ignored if Link.Flags.Parent
		-- is not set in any LinkConf (see below).
	word	-1		-- MyName
	word	-1		-- ParentName

		-- Number of communication ports attached to the system. If
		-- this changes ImageSize and the following link configuration
		-- initialisation should be updated accordingly.
	word	6		-- NLinks

		-------------------------------------------------------------
		-- Setup the link configuration information. The LinkConf
		-- and Config structures and flags are defined in the ampp
		-- header file '/hsrc/include/ampp/link.m'.
		--
		-- For each link set:
		--
		--	The Flags to define various properties of the link.
		--
		--	The following flags should usually only be set if an
		--	I/O Server is expected to be found at the other end of
		--	the link - rare for embedded ROM booted systems.
		--
		--	Link.Flags.Parent	If this nucleus was booted down
		--				a link, then this flag indicates
		--				which link (NEVER set in ROM
		--				booted systems).
		--	Link.Flags.ioproc	Indicates an I/O Server is
		--				present at the other end of the
		--				the link.
		--	Link.Flags.debug	Indicates debugging link down
		--				which IOdebug()s can be sent.
		--	Link.Flags.HalfDuplex	If link is connected to a 
		--				hard/software combination that
		--				cannot cope with full-duplex
		--				comms port operation, use
		--				Helios's half-duplex protocol
		--				(most PC's running MSDOG).
		--
		--	The Mode defining a links use:
		--
		--	Link.Mode.Null		Link is not connected.
		--	Link.Mode.Dumb		Link is connected, but should
		--				not be used by Helios. Users
		--				should call the AllocLink() fn
		--				to gain access to this link.
		--	Link.Mode.Intelligent	Connected to other processors
		--				and will be used for Helios
		--				message passing.
		--	Link.Mode.Special	Link is non-standard comms port
		--				interface (probably a pseudo
		--				link implemented in shared mem).
		--				This requires a custom nucleus
		--				that understands its i/f type
		--				incorporated into Link.State.
		--
		--	The State defining the current status of a link.
		--
		--	Link.State.Null		The Link is not connected.
		--	Link.State.Dead		Link is connected, but not
		--				currently in use by Helios.
		--	Link.State.Running	Live network link - a processor
		--				on the otherside of the link is
		--				is expecting Helios protocols
		--				down this link.
		--
		--	The ID of the link (0..NLinks - 1)
		--

		-- The SetLinkConf macro simplifies setting a links 
		-- configuration info.

		_def	'SetLinkConf['id 'flags 'mode 'state] [

			_def 'TMPCONF [
				( (flags) << LinkConf.Flags.shift |
				mode     << LinkConf.Mode.shift |
				state    << LinkConf.State.shift |
				id       << LinkConf.Id.shift )
			]
			word	TMPCONF

			_undef 'TMPCONF
		]

		-- Examples:
		--
		-- To setup link 0 as completely unconnected:
		--
		--	SetLinkConf 0 0 Link.Mode.Null Link.State.Null
		--
		-- To setup link 1 as connected to an external device, or
		-- another processor, but not to be used for Helios message
		-- passing:
		--
		--	SetLinkConf 1 0 Link.Mode.Dumb Link.State.Dead
		--
		-- To setup link 2 as connected to another processor running
		-- Helios, though which Helios messages may be passed:
		--
		--	SetLinkConf 2 0 Link.Mode.Intelligent Link.State.Dead
		-- 
		-- To setup link 3 as connected to a waiting I/O Server:
		--
		--	SetLinkConf 3 [Link.Flags.ioproc | Link.Flags.debug]
		--		Link.Mode.Intelligent Link.State.Dead
		--
		-- Set each links configuration info. The link Id's must be
		-- set in assending order.
		--	    Id	Flags		Mode		State

		SetLinkConf 0	0		Link.Mode.Null	Link.State.Null

		SetLinkConf 1	0		Link.Mode.Null	Link.State.Null

		SetLinkConf 2	0		Link.Mode.Null	Link.State.Null

		SetLinkConf 3	0		Link.Mode.Null	Link.State.Null

		SetLinkConf 4	0		Link.Mode.Null	Link.State.Null

		SetLinkConf 5	0		Link.Mode.Null	Link.State.Null

		-- Extra pseudo link definitions go here.

MyName:
		-- If processor name need to be changed from "/00", then
		-- place text here.

		align
BoardConfigEnd:

BootstrapCopyEnd:


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- C40 CPU boot loader tail.

	word	0		-- 0 size block causes bootloader to stop.
	word	0		-- IVTP - actually setup in Helios init.
	word	0		-- TVTP - actually setup in Helios init.
	word	0x00300000	-- End of boot IACK address (start of RAM).

BootstrapEnd:


	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- End of c40rombt.a
@


1.6
log
@fixed IACK address
@
text
@d61 1
a61 1
-- RcsId: $Id: c40rombt.a,v 1.5 1993/08/18 17:44:37 paul Exp $
d67 3
d470 13
a482 3
	-- Set initial C stack, this is a FALLING stack from top of on-chip RAM.
	ldhi	0x30, R_USP	-- 0x002f ffff
	subi	1, R_USP
d619 1
a619 1
	word	BoardConfigEnd - BoardConfig		-- ImageSize
@


1.5
log
@Cleaned up comments some more.
@
text
@d55 1
a55 1
--		values.
d61 1
a61 1
-- RcsId: $Id: c40rombt.a,v 1.4 1993/08/18 15:44:05 paul Exp paul $
d67 3
d787 1
a787 1
	word	0x3000000	-- End of boot IACK address (start of RAM).
@


1.4
log
@Added example IDROM and changed Config init to copy static ROMed config
structure. Bootstrap now supports C40 CPU bootloader (but also requires
use of the -i option to the linker). Cleaned up comments. Added the CPU
cache initialisation I had forgotten earlier!
@
text
@a8 4
--		The nucleus to be booted may reside in ROM/EPROM/FLASH/EEPROM
--		at any address, or be copied from ROM or other storage media
--		into faster/addressable RAM memory. The Helios nucleus's code
--		is completely position independent.
d10 6
d17 5
a21 6
--		based bootstrap code 'c40boot.a'. The design of these two types
--		of bootstrap allows any (post version 1.3) Helios-C40 nucleus
--		to support both ROM and link bootstrap. i.e. any normally link
--		booted nucleus can be ROMmed and any ROM based nucleus can be
--		copied down a link to boot a processor configured to boot from
--		link.
a44 1
--
d50 6
a55 1
--		the ONCHIP_RAM_WITHIN_ADDRESSABILITY option.
d61 1
a61 1
-- RcsId: $Id: c40rombt.a,v 1.3 1993/08/17 09:48:46 paul Exp paul $
d67 6
d143 3
a145 1
	-- C40 CPU boot loader header.
d147 4
d153 2
a154 1
				-- Size of bootstrap to copy in words:
d156 1
@


1.3
log
@updated comments
@
text
@a0 8
-- ToDo:
--	IDROM example init code.
--	Check use of HW_Config for hi loaded systems - How does loader
--	know where to load code?
--	ROM position to be relative (end of this image) as well as absolute.
--	Initial entry to bootstrap from C40 ROM bootloader
--
--
a21 5
--		For the following code, ROM_NUC_BASE should be set to the ROM
--		address of the start of nucleus and ROM_IDROM/ROM_CONFIG
--		should be set to the address of the IDROM and Config structures
--		if they are held in ROM and not contructed by hand.
--
d24 2
a25 2
--		1)	C40 on-chip ROM bootloader execution and memory
--			control register initialisation.
d45 12
a56 1
-- RcsId: $Id: c40rombt.a,v 1.2 1993/06/17 19:13:20 paul Exp paul $
d62 3
d71 1
a71 1
--
d73 6
d80 3
a82 4
-- Example ROM address definitions.
_def	'ROM_IDROM	[0x40000000]
_def	'ROM_CONFIG	[(ROM_IDROM + (IDROM.sizeof / 4))]
_def	'ROM_NUC_BASE	[(ROM_CONFIG + (Config.sizeof / 4))]
d84 1
d86 1
a86 3
-- Select options.
_def	'ROMED_COPY_OF_IDROM	TRUE	-- Copy of IDROM held in ROM.
--_def	'ROMED_COPY_OF_CONFIG	TRUE	-- Copy of Config held in ROM.
d88 4
a91 3
-- _def	'COPY_ROM_TO_RAM	TRUE	-- Copy nucleus into faster RAM.
-- RAM and on-chip RAM are within C addressability range of each other (4GB).
-- _def 'ONCHIP_RAM_WITHIN_ADDRESSABILITY TRUE
d93 4
a97 9
include basic.m
include c40.m
include tim40.m
include c40mmap.m
include ../gexec.m
include module.m
include config.m
include root.m
include link.m
d101 11
a111 9
	-- 1) C40 on-chip ROM bootloader execution and memory control
	--    register initialisation.
	--
	-- This bootstrap code may either be encapsulated by the standard C40
	-- ROM bootstrap header and copied in its entirety by the bootloader
	-- into RAM, or jumped to from a simple boot program loaded by the C40's
	-- bootloader. For a description of the C40 boot loader see section
	-- 13.2, page 13-5: "Boot Loader Description and External ROM
	-- Interfacing" of the TMS320C40 User Guide.
d116 23
a138 3
	-- Helios-C40 Bootstrap entry point.

BootstrapEntryPoint:
a139 17
	-----------------------------------------------------------------------
	-- For the purposes of this example code, AR5 is set to point at a copy
	-- of the IDROM structure in ROM. If you are going to create this
	-- structure on the fly, then substitute relevant values whenever the
	-- IDROM is accessed via AR5.
	-- The structure of an IDROM is defined in the include file tim40.m
	-- and described in the C40 consortium TIM-40 specification document.
	-- This structure is used to initialise the C40 from and then
	-- copied into a Helios kernel structure for later reference.

	_if _defp 'ROMED_COPY_OF_IDROM [
		-- load address of ROMed copy of IDROM
		ldhi	ROM_IDROM >> 16, ar5		-- hi 16 bits
		or	ROM_IDROM & 0xffff, ar5		-- lo 16 bits
	]
	-- Otherwise, replace all following references to AR5/IDROM with
	-- hardcoded values.
d148 1
a148 1
	-- bootloader will already have initialised the GBCR and LBCR memory
d152 16
a167 1
InitC40:
d172 2
a173 3
	-- user/hardware.

	-- Setup timer 1 as this may be needed for DRAM refresh.
d180 1
d201 1
d205 1
a205 1
	--    or other storage media) to RAM if required.
d242 4
a245 4
	-- Set base of RAM. This point and above is used to hold the main
	-- system structures, such as the ExecRoot, system stack, interrupt
	-- vector table, kernel root, Config structure and C addressable user
	-- RAM. It may be located on the local or global bus and either stobe
d276 2
a277 2
	-- using for the system, then the Execroot's position should be set to
	-- the next free location after the nucleus. If the nucleus is placed
d280 3
a282 2
	-- this memory as workspace! (The following code assumes a 32 bit wide
	-- ROM). 
d286 2
a287 3
		-- Get address of nucleus in (flash) ROM.
		ldhi	ROM_NUC_BASE >> 16, ar3		-- hi 16 bits
		or	ROM_NUC_BASE & 0xffff, ar3	-- lo 16 bits
a295 1

d325 1
a325 2
		ldhi	ROM_NUC_BASE >> 16, ar2		-- hi 16 bits
		or	ROM_NUC_BASE & 0xffff, ar2	-- lo 16 bits
d333 5
a337 5
	-- processors down a link (normally a copy of HW_Config sent to us
	-- if we were booted down a link).
	-- In link booted systems the HW_Config word determines the default
	-- bus/strobe to load the nucleus at - can be overridden by boot
	-- program.
d340 4
a343 4
	-- Position system stack pointer directly after execroot.
	-- Execroot and SSP are nominally 1kb in size each.
	-- (system stack builds upwards)
	-- .sizeof defined in terms of bytes.
d347 1
a347 1
	-- Align interrupt vectors to 0x200 word boundary after execroot
d361 1
a361 1
	sti	r0, *+ar1(ExecRoot.KernelRoot)	-- Save in execroot.
a374 3
	-- This structure may be held as preinitialised structure in ROM, or
	-- constructed 'on the fly' at this point.
	--
d377 1
d379 1
a379 1
	-- Get address of internal IDROM structure.
d381 10
a390 3
	
	_test _defp 'ROMED_COPY_OF_IDROM [
		-- If IDROM is held in ROM copy it to its standard position. 
a391 17
		-- Get address of ROMed copy of IDROM.
		ldhi	ROM_IDROM >> 16, ar5		-- hi 16 bits
		or	ROM_IDROM & 0xffff, ar5		-- lo 16 bits

		-- Get size of IDROM.
		ldi	IDROM.sizeof / 4, r0

		-- Copy IDROM into ExecRoot structure
	IDROM_Copy:
		ldi	*ar5++, r1
		sti	r1, *ar4++
		subi	1, r0
		bnz	IDROM_Copy
	][
		-- Otherwise, add code here to initialise the IDROM structure
		-- in the ExecRoot.
	]
d398 158
a555 1
	-- Config is a Helios specific structure and used to define information
d557 1
a557 1
	-- environment. Its structure is defined in the include file
a567 32
	--
	-- On entry to this code fragment:
	--	AR3 = WPTR to kernel Root structure.

	-- Get the Config structures internal address. Config is held directly
	-- after the kernel Root structure. As ar3 holds the address
	-- of the kernel Root, simply add its size to get Config's address
	-- (.sizeof returns byte size, hence the divide by four).
	addi	Root.sizeof / 4, ar3

	_test _defp 'ROMED_COPY_OF_CONFIG [
		-- If Config structure is held in ROM, copy it to its
		-- standard internal position (don't forget to set
		-- Config.ImageSize to the size of the structure).

		-- Load address of ROMed copy of Config.
		ldhi	ROM_CONFIG >> 16, ar5		-- hi 16 bits
		or	ROM_CONFIG & 0xffff, ar5	-- lo 16 bits

		-- Get size of Config structure.
		ldi	*+ar5(Config.ImageSize), r0

		-- Copy Config into internal position.
	Config_Copy:
		ldi	*ar5++, r1
		sti	r1, *ar3++
		subi	1, r0
		bnz	Config_Copy
	][
		-- Otherwise, use the code here to initialise the nucleus's
		-- internal Config structure - usually the initialisation
		-- values do not need to be changed.
d569 1
d571 1
a571 2
		ldi	1024, r0
		sti	r0, *+ar3(Config.PortTabSize)
d574 1
a574 1
		stik	1, *+ar3(Config.Incarnation)
d577 1
a577 1
		-- stik	0, *+ar3(Config.LoadBase)
d582 3
a584 3
		-- than the default /00, then this size will have to change.
		ldi	Config.sizeof, r0
		sti	r0, *+ar3(Config.ImageSize)
d588 3
a590 2
		-- seconds since 1970 GMT.
		stik	0, *+ar3(Config.Date)
d595 1
a595 1
		stik	6, *+ar3(Config.FirstProg)
d600 1
a600 1
		stik	0, *+ar3(Config.MemSize)
d611 1
a611 2
		ldi	Root_Flags_rootnode | Root_Flags_ROM, r0
		sti	r0, *+ar3(Config.Flags)
d613 2
a614 2
		-- Reserved location.
		stik	0, *+ar3(Config.Spare)
d625 2
a626 2
		stik	-1, *+ar3(Config.MyName)	-- Default to /00.
		stik	-1, *+ar3(Config.ParentName)	-- Default to /IO.
d631 1
a631 1
		stik	6, *+ar3(Config.NLinks)
d703 1
a703 3
			ldhi	(TMPCONF >> 16), r0
			or	(TMPCONF & 0xffff), r0
			sti	r0, *+ar3(Config.LinkConf0 + LinkConf.sizeof * id)
d729 3
a731 2

		-- Set each links configuration info.
d745 2
a746 1
	]
d748 3
a750 14
	-----------------------------------------------------------------------
	-----------------------------------------------------------------------
	-- 7) Setup of minimal C PCS (Procedure Call Standard) environment and
	--    jump to the Helios kernel's entry point.
	--
	-- The kernel entry point's prototype is:
	-- 	void KStart(Channel bootlink, word *nucbase)
	--
	-- In a ROM booted system the 'bootlink' parameter is -1 to denote
	-- a ROM bootstrap sequence, as apposed to a link bootstrap. The
	-- nucbase is the address of the nucleus.
	--
	-- On entry to this code fragment:
	--	AR1 = execroot
d752 2
a753 2
	-----------------------------------------------------------------------
	-- Setup C PCS.
d755 1
a755 3
	-- Set initial C stack, this is a FALLING stack from top of on-chip RAM.
	ldhi	0x30, R_USP	-- 0x002f ffff
	subi	1, R_USP
a756 2
	-- C PCS defines that registers set the flags.
	or	ST_SET_COND, R_ST
a757 3
	-- No need to set up Module table pointer as this is not required by
	-- KStart.
	
a758 7
	-- Construct arguments to KStart().

	-- Bootlink is -1 to signify ROM booted system.
	ldi	-1, R_A1			-- bootlink is arg 1

	ldi	*+ar1(ExecRoot.Nucleus), R_A2	-- Nucleus base is arg 2

d760 1
a760 12
	-- Jump into nucleus's kernel module (kmodule).
	-- jmp addr = *(GetNucBase() + 1) + (GetNucBase() + 1) + sizeof(Module)

	-- Get pointer to nucleus from arg 2 and increment to point at kernel
	-- slot in nucleus contents table.
	addi	1, R_A2, ar2

	-- Convert kernel slot RPTR (self relative pointer) to address of
	-- kernel's module.
	ldi	*ar2, ar1	-- Get kernel RPTR - byte offset to kernel.
	lsh	-2, ar1		-- Convert byte offset to number of words,
	addi	ar2, ar1	-- and add in address of kernel RPTR.
d762 4
a765 2
	-- Step over module header (.sizeof in terms of bytes).
	addi	Module.sizeof / 4, ar1
d767 1
a767 2
	-- Jump to kernel entry point.
	b	ar1		-- "My god... its full of stars"
d770 1
@


1.2
log
@updated with new Config struct initialisation
@
text
@d3 2
d58 1
a58 1
-- RcsId: $Id: c40rombt.a,v 1.1 1993/06/14 16:27:29 paul Exp paul $
d64 3
d108 1
a108 1
	-- Interfacing" of the TM320C40 User Guide.
d139 6
a144 5
	-- Any futher memory controller initialisation, such as possibly
	-- setting up the timers for DRAM refresh should be done at this point.
	-- This will enable us to start using the external RAM.
	-- The on-chip C40 bootloader will already have initialised the
	-- GBCR and LBCR memory controller registers.
d150 2
a151 3
	-- setup timer 0 for a 1mS period, but do not start it
	ldi	*+ar5(IDROM.TIMER0_PERIOD), r0
	sti	r0, *+ar0(timer0_period)
d153 1
a153 1
	-- setup timer 1 as this may be needed for DRAM refresh
d158 1
a158 1
	-- Timer1 actually in upper 16 bits of word
d160 1
a160 1
	-- set the timer to run on when a JTAG halt is in effect
d166 6
d222 1
a222 1
	-- vector table, kernel root, config structure and C addressable user
d229 8
a236 5
	-- The C address base (The IR0 register referred to by the R_BASE alias)
	-- is usually set to the same base as the RAM, but if this RAM is
	-- within C addressability range of the on-chip RAM, then the C address
	-- base should be set to the on-chip RAM. This will allow on-chip RAM
	-- to be directly accessable from C.
d252 8
a259 8
	-- of a disk, to SRAM or RAM, then it should be copied at this point.
	-- If the nucleus is to be copied to the same strobe and bus that we
	-- are using for the system, then the Execroot's position should be
	-- set to the next free location after the nucleus. If the nucleus
	-- is placed on another bus/strobe, then the RAM used to hold the
	-- nucleus should NOT be included in the IDROM. Otherwise Helios will
	-- attempt to use this memory as workspace! (The following code assumes
	-- a 32 bit wide ROM). 
d349 5
a353 4
	-- Helios-C40 uses the TIM-40 standard IDROM to configure itself to
	-- the hardware environment in which it finds itself executing.
	-- The IDROM is held in an internal Helios structure for reference by
	-- the nucleus during initialisation and execution.
d390 4
a393 4
	-- The Config structure is defined in the include file ampp/config.m
	-- in the Helios source include directory. Example config structure
	-- initialisation can be found in the I/O Server sources. Look at the
	-- function build_config() in /hsrc/ioproc/server/tload.c.
d402 1
a402 1
	-- this at a later point.
d414 1
a414 1
		-- If config structure is held in ROM, copy it to its
d553 1
a553 1
		--				is excpecting Helios protocols
@


1.1
log
@Initial revision
@
text
@d1 6
d15 4
a18 3
--		The Helios nucleus to be booted may reside in ROM/FLASH EPROM
--		at any address, or be copied from ROM/flash EEPROM or other
--		storage media into faster/addressable RAM memory.
d33 14
a46 1
-- RcsId: $Id$
d48 10
d61 3
a63 1
-- RcsLog: $Log$
d65 1
d76 1
a76 1
_def	'ROMED_COPY_OF_CONFIG	TRUE	-- Copy of Config held in ROM.
d91 1
d93 1
a93 1

d95 4
a98 1
	-- The following code may either be encapsulated by the standard C40
d105 1
a106 4
	-- Any system initialisation and/or self test code should be inserted
	-- at this point.


d109 1
d127 1
a127 1
	-- otherwise, replace all following references to AR5/IDROM with
d131 2
a132 1
	-- Initialise processor and memory
d163 10
a172 1
	-- Setup Helios-C40 memory map.
d174 1
d206 1
a207 1

d209 5
a213 4
	-- Set RAMbase. This is used to hold the ExecRoot, system stack,
	-- interrupt vector table, kernel root, config structure and C
	-- addressable user RAM. It may be located on the local or global bus
	-- and either stobe on these busses.
d237 10
a246 5
	-- If the nucleus needs to be copied from slow flash EPROM or normal
	-- ROM, or the boot sector of a disk, to SRAM or RAM, then it should
	-- be copied at this point. The Execroot's position should then be
	-- set to the next free location after the nucleus (code assumes
	-- 32 bit ROM).
d329 2
d332 3
d342 6
a355 3
		-- Get address of internal IDROM structure.
		addi	ExecRoot.ID_ROM, ar1, ar4

d371 4
a374 2
	-- Initialise internal copy of config structure

d379 12
d392 4
a395 4
	-- Get config structures internal address. Config is held directly
	-- after the Kernel Root structure. ar3 still holds the address
	-- of the kernel root, so simply add its size to get config's
	-- address.
d400 2
a401 1
		-- standard internal position.
d403 1
a403 1
		-- Load address of ROMed copy of config.
d407 2
a408 2
		-- Get size of Config structure 
		ldi	Config.sizeof / 4, r0
d410 1
a410 1
		-- Copy config into internal position
d417 179
a595 2
		-- Otherwise, add code here to initialise the nucleus's
		-- internal config structure
d597 1
d601 3
a603 2
	-- Initialise minimal C PCS conformant world and jump to the Helios-C40
	-- kernel's entry point.
d605 2
a606 2
	-- The kernel prototype is:
	-- 	void Kstart(Channel bootlink, word *nucbase)
d615 4
a618 3
CallKStart:
	-- Setup initial C stack, this is a FALLING stack from top of
	-- internal RAM.
d622 1
a622 1
	-- All registers set the flags.
d626 1
a626 1
	-- the kernel.
d628 2
a629 1
	-- Setup arguments to KStart().
a634 1
	ldi	R_A2, ar2
d636 2
a637 1
	-- Jump to initial kernel module (kmodule)
d640 9
a648 5
	-- Point at kernel slot.
	addi	1, ar2

	-- Convert kernel rptr to address of kernel.
	ldi	*ar2, ar1	-- get kernel rptr - offset to kernel
a649 3
	lsh	-2, ar1		-- convert to number of words
	addi	ar2, ar1	-- add in address of rptr

d654 1
a654 2
	b	ar1

a658 1

@
