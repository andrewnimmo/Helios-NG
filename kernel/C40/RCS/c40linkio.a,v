head	1.19;
access;
symbols
	Helios_1_3_1:1.18
	Helios_C40_1_3_Official_Release:1.18
	Alenia_release:1.13
	C40_Field_Test_2:1.8
	C40_Field_Test_R1:1.5;
locks; strict;
comment	@-- @;


1.19
date	93.11.26.10.31.32;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	93.05.10.11.36.27;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	93.02.25.10.22.34;	author paul;	state Exp;
branches;
next	1.16;

1.16
date	93.01.26.10.09.50;	author paul;	state Exp;
branches;
next	1.15;

1.15
date	93.01.25.09.06.57;	author paul;	state Exp;
branches;
next	1.14;

1.14
date	92.12.17.14.23.20;	author paul;	state Exp;
branches;
next	1.13;

1.13
date	92.12.17.11.42.16;	author paul;	state Exp;
branches;
next	1.12;

1.12
date	92.11.23.10.10.27;	author paul;	state Exp;
branches;
next	1.11;

1.11
date	92.11.20.15.43.46;	author paul;	state Exp;
branches;
next	1.10;

1.10
date	92.11.18.14.39.49;	author paul;	state Exp;
branches;
next	1.9;

1.9
date	92.11.12.20.54.42;	author paul;	state Exp;
branches;
next	1.8;

1.8
date	92.09.25.09.38.13;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	92.09.22.15.59.19;	author paul;	state Exp;
branches;
next	1.6;

1.6
date	92.09.21.10.34.10;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	92.06.30.19.26.05;	author paul;	state Exp;
branches;
next	1.4;

1.4
date	92.06.19.18.25.46;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	92.06.15.13.42.19;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	92.05.14.08.21.38;	author paul;	state Exp;
branches;
next	1.1;

1.1
date	92.04.21.09.54.56;	author paul;	state Exp;
branches;
next	;


desc
@alpha version
@


1.19
log
@fixed bug in TxHasCompletedOK: code
@
text
@-- File:	c40linkio.a
-- Subsystem:	'C40 Helios executive
-- Author:	P.A.Beskeen
-- Date:	Feb '92
--
-- Description: 'C40 specific low level link I/O functions
--
--		These functions implement the lowest level link I/O routines.
--		Both the blocking and DMA variants.
--
--
-- RcsId: $Id: c40linkio.a,v 1.18 1993/05/10 11:36:27 nickc Exp nickc $
--
-- (C) Copyright 1992 Perihelion Software Ltd.
-- 
-- RcsLog: $Log: c40linkio.a,v $
-- Revision 1.18  1993/05/10  11:36:27  nickc
-- re-enabled fix for lost interrupts (whereby when AbortRX is called because of timeout, it detectes whether an interrupt is lost, and if so, recovers from it).
--
-- Revision 1.17  1993/02/25  10:22:34  paul
-- fixed up small typos in source
--
-- Revision 1.16  1993/01/26  10:09:50  paul
-- Fixed LinkTx/Rx lost interrupt silicon problem with a work around. Now
-- checks Tx completion in Rx interrupts and vis-versa. Also reduced the
-- dispatch latency when resuming Rx/Tx threads
--
-- Revision 1.15  1993/01/25  09:06:57  paul
-- minor improvements plus IR0 (R_BASE) saveing and restoring
--
-- Revision 1.14  1992/12/17  14:23:20  paul
-- minor fix to cope with non zero ir0
--
-- Revision 1.13  1992/12/17  11:42:16  paul
-- added fixup for lost end of Tx DMA interrupt.
-- Changed DMA priority to be equal with CPU
--
-- Revision 1.12  1992/11/23  10:10:27  paul
-- converted all link tx/rx call to take word addresses and word size arguments
--
-- Revision 1.11  1992/11/20  15:43:46  paul
-- address base reg IR0 is now defined to be a constant, user code must
-- not change its value.
-- interrupt routines now assume that IR0 is correct
--
-- Revision 1.10  1992/11/18  14:39:49  paul
-- fixed up interrupt handlers to stop assuming IR0 is 0, instead they assume
-- >> GetExecRoot (tvtp) is synonymous with the std C address base
--
-- Revision 1.9  1992/11/12  20:54:42  paul
-- made C40Word/CAddress compatible with IR0 != 0
--
-- Revision 1.8  1992/09/25  09:38:13  paul
-- now uses gexec.m and fixed an error in the interrupt driven link code.
--
-- Revision 1.7  1992/09/22  15:59:19  paul
-- updated comment
--
-- Revision 1.6  1992/09/21  10:34:10  paul
-- fixed problem with DMA overrun on Hema DSP1 boards, these boards are so
-- quick that the reset of the DMA engines is still taking place after
-- the next instruction, if the next instr. was loading the count reg. then
-- the reg is instead zeroed. Re-ordered instructions to avoid this problem.
--
-- Revision 1.5  1992/06/30  19:26:05  paul
-- remove dbg
--
-- Revision 1.4  1992/06/19  18:25:46  paul
-- added note of threads status when it is re-scheduled
--
-- Revision 1.3  1992/06/15  13:42:19  paul
-- various minor fixes
--
-- Revision 1.2  1992/05/14  08:21:38  paul
-- pretty much near as dammit must be robust and clean now version
--
-- Revision 1.1  1992/04/21  09:54:56  paul
-- Initial revision
--
--

include ../gexec.m	-- Executive manifests
include c40mmap.m
include c40intr.m
include link.m
include root.m


-- The C40 has a bug where the act of reading a link FIFO by hand makes
-- the CPU hang when a new start value is written to the DMA control reg
-- for the associated split mode link. This situation can only be resolved by
-- resetting the DMA engines each time you use them. This problem currently
-- only seems to manifest itself on Rx DMA.
_def 'readfifo 1	-- fix problem as I do read FIFO directly

_def 'writefifo 1	-- The fix does not seem to be required for writing
			-- directly to the fifo, but for safety do reset of DMA
			-- engines before Tx use.

			-- Two ways of recovering from (Aleged) C40 silicon
			-- problem where Tx interrupts are sometimes 'lost'
			-- on heavily bi-directional loaded comms links.
_def 'C40BUG_LostIntr1 1
			-- Recover from lost Tx interrupt when link times-out
			-- in AbortLinkTx (causes 10 sec delay on link comms).

_def 'C40BUG_LostIntr2 1
			-- Recover from lost Tx interrupt by detecting
			-- outstanding comms. and DMA engine count = 0.
			-- causes small overhead on each end of DMA
			-- transaction.


-- Std DMA control settings
-- dcr_dmapri: DMA priority is higher than CPU
-- dcr_syncmode:  both source and dest sync (as specified by die reg)
-- dcr_splitmode: use split mode (primary channel = Tx, aux chan = Rx)
-- dcr_tranmode: transfers are terminated by count reg == zero
-- dcr_tcc : send end of DMA interrupt to CPU

_test _defp 'CPUHASHIGHERPRI [
_def    'set_control            [(dcr_syncmodeM | dcr_splitmode |
                                dcr_tranmode[0b01] | dcr_tcc |
                                dcr_auxtranmode[0b01] | dcr_auxtcc)]
][
-- Equal priority between CPU and DMA (alternate accesses)
_def    'set_control            [(dcr_dmapri[0b01] | dcr_syncmodeM |
                                dcr_splitmode |
                                dcr_tranmode[0b01] | dcr_tcc |
                                dcr_auxtranmode[0b01] | dcr_auxtcc)]
]

-- reset both primary and auxiliary channel
_def    'resetboth_control      [(set_control | dcr_start[0b00] |
                                dcr_auxstart[0b00])]

-- start both channels
_def    'goboth_control         [(set_control | dcr_start[0b11] |
                                dcr_auxstart[0b11])]

_test _true [
-- STOP ON EITHER DMA READ or WRITE boundary

-- halt both primary and auxiliary channel immediately
_def    'haltboth_control       [(set_control | dcr_start[0b01] |
                                dcr_auxstart[0b01])]


-- go on primary channel and halt auxiliary
_def    'gohalt_control         [(set_control | dcr_start[0b11] |
                                dcr_auxstart[0b01])]


-- go on primary channel and reset auxiliary
_def    'goreset_control	[(set_control | dcr_start[0b11] |
                                dcr_auxstart[0b00])]


-- reset primary channel and go on auxiliary
_def    'resetgo_control        [(set_control | dcr_start[0b00] |
                                dcr_auxstart[0b11])]

-- reset primary channel and halt auxiliary immediately
_def    'resethalt_control      [(set_control | dcr_start[0b00] |
                                dcr_auxstart[0b01])]


-- halt primary and reset auxiliary channel
_def    'haltreset_control      [(set_control | dcr_start[0b01] |
                                dcr_auxstart[0b00])]

-- halt primary and go on auxiliary channel
_def    'haltgo_control         [(set_control | dcr_start[0b01] |
                                dcr_auxstart[0b11])]
][
-- STOP ON TRANSFER BOUNDARY, NOT DMA READ or WRITE boundary

-- halt both primary and auxiliary channel immediately
_def    'haltboth_control       [(set_control | dcr_start[0b10] |
                                dcr_auxstart[0b10])]


-- go on primary channel and halt auxiliary
_def    'gohalt_control         [(set_control | dcr_start[0b11] |
                                dcr_auxstart[0b10])]


-- go on primary channel and reset auxiliary
_def    'goreset_control	[(set_control | dcr_start[0b11] |
                                dcr_auxstart[0b00])]


-- reset primary channel and go on auxiliary
_def    'resetgo_control        [(set_control | dcr_start[0b00] |
                                dcr_auxstart[0b11])]

-- reset primary channel and halt auxiliary immediately
_def    'resethalt_control      [(set_control | dcr_start[0b00] |
                                dcr_auxstart[0b10])]


-- halt primary and reset auxiliary channel
_def    'haltreset_control      [(set_control | dcr_start[0b10] |
                                dcr_auxstart[0b00])]

-- halt primary and go on auxiliary channel
_def    'haltgo_control         [(set_control | dcr_start[0b10] |
                                dcr_auxstart[0b11])]
]


_def    'hi_resetboth_control   [(resetboth_control >> 16)]
_def    'lo_resetboth_control   [(resetboth_control & 0xffff)]
_def    'hi_haltboth_control    [(haltboth_control >> 16)]
_def    'lo_haltboth_control    [(haltboth_control & 0xffff)]
_def    'hi_goboth_control      [(goboth_control >> 16)]
_def    'lo_goboth_control      [(goboth_control & 0xffff)]

_def    'hi_gohalt_control      [(gohalt_control >> 16)]
_def    'lo_gohalt_control      [(gohalt_control & 0xffff)]
_def    'hi_goreset_control	[(goreset_control >> 16)]
_def    'lo_goreset_control	[(goreset_control & 0xffff)]

_def    'hi_haltgo_control      [(haltgo_control >> 16)]
_def    'lo_haltgo_control      [(haltgo_control & 0xffff)]
_def    'hi_haltreset_control   [(haltreset_control >> 16)]
_def    'lo_haltreset_control   [(haltreset_control & 0xffff)]

_def    'hi_resetgo_control     [(resetgo_control >> 16)]
_def    'lo_resetgo_control     [(resetgo_control & 0xffff)]
_def    'hi_resethalt_control	[(resethalt_control >> 16)]
_def    'lo_resethalt_control	[(resethalt_control & 0xffff)]




-- void _LinkTx(word size, Channel link, void *buf);
--
-- Simple blocking link reception function. This is used to send a bogus Info
-- message when debugging early versions of the kernel, and to write bytes
-- to the link if there is space for all of them in the link FIFO.
--
-- size: number of words to send
-- link: WPTR to the link control register
-- buf: WPTR to buffer holding data
--
-- Called from C so must be PCS conformant

._LinkTx:
        addi    2, R_A2, R_ATMP         -- link tx addr

	ldi	R_A3, R_ADDR1  		 -- MPtr data buffer

        subi    2, R_A1                 -- adjust for loop
        bn      OneWordTx

        ldi     *R_ADDR1++, R_A2
        rpts R_A1
                sti     R_A2, *R_ATMP || ldi *R_ADDR1++, R_A2
        sti     R_A2, *R_ATMP

        bu      R_LR

OneWordTx:
        bud     R_LR
                ldi     *R_ADDR1++, R_A2
                sti     R_A2, *R_ATMP
                nop


-- void _LinkRx(word size, Channel link, MPtr buf);
--
-- Simple blocking link reception function. This is used to get config vector
-- in kernel startup, and to read bytes from the link if they are all in the
-- link FIFO already.
--
-- size: number of words to read
-- link: WPTR to the link control register
-- buf: WPTR to buffer to hold the data
--
-- Called from C so must be PCS conformant

._LinkRx:
        addi    1, R_A2, R_ATMP         -- link rx addr

	ldi	R_A3, R_ADDR1		-- data buffer

        subi    2, R_A1                 -- adjust for loop
        bn      OneWordRx

        ldi     *R_ATMP, R_A2
        rpts R_A1
                sti     R_A2, *R_ADDR1++ || ldi *R_ATMP, R_A2
        sti     R_A2, *R_ADDR1++

        bu      R_LR

OneWordRx:
        bud     R_LR
                ldi     *R_ATMP, R_A2
                sti     R_A2, *R_ADDR1++
                nop


-- int RxFIFOSpace(Channel x)
--
-- Returns number of BYTES available to read in link's input FIFO.
-- By judicous shifting and masking, we get a byte result from a word
-- quantified bitfield in the link control register.
--
-- x: WPTR to links CPCR
--
-- Called from C so must be PCS conformant

.RxFIFOSpace:
        ldi     R_A1, R_ATMP
        lsh     -7, *+R_ATMP(0), R_A2           -- shift and mask to get byte
        bud     R_LR
                and     0b011100, R_A2, R_A1    -- result from word quantified
                tstb    0b100000, R_A2          -- if full, we actually have 8
                ldinz   32, R_A1                -- words in fifo


-- int TxFIFOSpace(Channel x)
--
-- Returns number of free BYTES in link's output FIFO.
-- By judicous shifting and masking, we get a byte result from a word
-- quantified bitfield in the link control register.
--
-- x: WPTR to links CPCR
--
-- Called from C so must be PCS conformant

.TxFIFOSpace:
        ldi     R_A1, R_ATMP
        lsh     -3, *+R_ATMP(0), R_A2
        and     0b011100, R_A2, R_A1    -- mask byte size
        bud     R_LR
                subri   32, R_A1                -- 32 - bytes used = bytes unused
                tstb    0b100000, R_A2          -- if completely full however
                ldinz   0, R_A1                 -- return no bytes avail.


_if _false [
-- Sets up a handler for input fifo full interrupt on link 3
-- If this hits then we will have serious problems with IOServer

.LinkFIFOTest:
        -- get address of fifo handler
        ldabs16 LinkFIFOOverflow R_A1

        -- Setup end of DMA interrupt handler into the correct intr. vector
        -- get hold of interrupt vector base

        ldep    ivtp, R_ATMP
	addi	iv_icfull3, R_ATMP

	bud	R_LR
		sti	R_A1, *R_ATMP
                ldi     IIE_EICFULL3, R_A1
                or      R_A1, iie       -- enable interrupt

LinkFIFOOverflow:
	push	ar1
        ldi     IIE_EICFULL3, ar1
        andn	ar1, iie       -- enable interrupt
	int	0x66ffffff
	pop	ar1
	retiu
]


_test _defp 'LINKDMA [
-- void InitLinkDMA(word DMAEng)
--
-- Sets up link and DMA engine for channel x. The same numbered link and DMA
-- engine must be used together in order to syncronise their acivities with the
-- ICRDY/OCRDY signals. The DMA engine is set up for split mode use, the
-- Primary channel being used for Tx and the Aux channel for Rx. Other Items
-- that remain static such as the index and interrupt handler are initialised
-- at this point.
--
-- Called from C so must be PCS conformant.

.InitLinkDMA:
        -- move DMA control reg to address reg for indirection
        ldi     R_A1, R_ADDR1

        -- Set up DMA control registers
        -- reset DMA engine
        stik    0, *+R_ADDR1(dma_control)

        -- zero count registers
        stik    0, *+R_ADDR1(dma_count)
        stik    0, *+R_ADDR1(dma_auxcount)

        -- indexes is always 1
        stik    1, *+R_ADDR1(dma_srcindex)
        stik    1, *+R_ADDR1(dma_dstindex)

        -- Setup end of DMA interrupt handler into the correct intr. vector
        -- get hold of interrupt vector base
        ldep    ivtp, R_A3
                
        -- convert cpcr WPTR to dma channel number
        lsh     -4, R_ADDR1, R_ADDR2
        and     0xf, R_ADDR2
        subi    0xa, R_ADDR2            -- R_ADDR2 == dma chan number

        -- add in interrupt vector base
        addi    R_A3, R_ADDR2, R_ADDR3  -- R_ADDR3 == (after +ivdmaint0) =
                                        --              DMA channel intr vector

        -- get address of this channels handler
        ldabs16 LinkDMAIntrHandler0 R_A4 -- abs addr of interrupt handler 0
        mpyi    6, R_ADDR2, R_A3                -- chan * 6 instructions
        addi    R_A3, R_A4                      -- index to correct handler

        -- store link DMA interrupt handler into interrupt vector.
        sti     R_A4, *+R_ADDR3(iv_dmaint0)


        -- Enable OCRDY write and ICRDY read sync in the DIE reg.
        -- This  automatically syncronises the DMA reads and writes to link
        -- write and read ready interrupt/line
        -- R_ADDR2 == DMA channel number
        cmpi    1, R_ADDR2
        bhi     hi_die

        -- Two bit die masking
        bz      chan_zero
        -- DMA channel 1
        bud     end_die_mask
                andn    0b11110000, die -- set ICRDY/OCRDY DMA sync interrupt
                or      0b01010000, die
                nop
chan_zero:
        -- DMA channel 0
        bud     end_die_mask
                andn    0b1111, die     -- set ICRDY/OCRDY DMA sync interrupt
                or      0b0101, die
                nop


        _def    'dma_diemask    [0b0011111100000000]
        _def    'dma_dieIOCRDY  [0b0000100100000000]

hi_die: -- Three bit die masking for channels 2-5
        ldi     dma_diemask, R_A3
        subi    2, R_ADDR2, R_A4        -- convert DMA channel to shift for mask
        mpyi    6, R_A4                 -- (chan - 2) * 6 = shift amount
        lsh     R_A4, R_A3              -- shift mask
        andn    R_A3, die               -- mask out old DMA channel intr enable

        ldi     dma_dieIOCRDY, R_A3
        lsh     R_A4, R_A3
        or      R_A3, die               -- set new DMA chan. intr enable I/OCRDY
end_die_mask:
        -- Enable the end of DMA interupts in IIE
        -- These interrupts signal the link DMA interrupt handler to resume the
        -- thread that requested the LinkTx/Rx when the DMA transfer completes.

        _def    'edmaint0       [0b0000001000000000]

        bud     R_LR
                ldhi    edmaint0, R_A3

                lsh     R_ADDR2, R_A3   -- shift to set end of DMA intr
                or      R_A3, iie       -- for this DMA channel



-- void _AbortLinkTx(LinkInfo *link, word linkId)
--
-- Abort the split mode primary channel DMA transfer immediately
-- (but without affecting the other channel)
--
-- Called from C so must be PCS complient

._AbortLinkTx:
        -- get word address of link info
	-- C40WordAddress R_A1, R_ADDR1
	lsh	-2, R_A1, R_ADDR1
	addi	R_BASE, R_ADDR1

        -- shift comms port to ctrl reg field
        lsh     15, R_A2, R_A4

        -- get WPTR to DMA control reg for this link.
        ldi     *+R_ADDR1(Link.DMAEng), R_ADDR2

	_if _defp 'C40BUG_LostIntr1 [
		-- This has been put in as a fix to a (unconfirmed) silicon
		-- problem where the end of DMA interrupt is lost for Tx comms
		-- on heavily bi-directionally loaded links.

		cmpi	0, *+R_ADDR2(dma_count)
		beq	TxHasCompletedOK
	]
        -- check to see if the other channel is transmitting
       	cmpi    0, *+R_ADDR1(Link.RxThread)
        beq     resetboth

	-- If the Rx channel is still operating, we must take care not to
	-- simply overwrite its channel start value and either stop or restart
        -- it at the wrong time.

        ldhi    hi_resethalt_control, R_A1
        or      lo_resethalt_control, R_A1

        -- this Halts all DMA transfers on either read or write boundary
        -- and resets the auxiliary channel
        sti     R_A1, *+R_ADDR2(dma_control)
		nop     -- Give time for last transfer to complete
		nop     -- before the halt takes effect. This should be
		nop     -- for a minimum of 9 cycles in case we are writing to

		nop     -- dynamic RAM and miss the current page
		nop
		nop

		nop
		nop
		nop

        -- Rx side has now been halted and Tx side reset
HaltedRx:
        -- see if the Rx side had just completed anyway
        ldi     *+R_ADDR2(dma_auxcount), R_A2
        bz      R_LR            -- yes Tx has completed

        -- no so re-start Rx channel
        ldhi    hi_resetgo_control, R_A1
        bud     R_LR
                or      lo_resetgo_control, R_A1

                -- insert comms port into its control reg field
                or      R_A4, R_A1

                -- this re-starts the Rx DMA transfer
                sti     R_A1, *+R_ADDR2(dma_control)


_if _defp 'C40BUG_LostIntr1 [
        -- This code emulates and End of Tx DMA interrupt.
	--
	-- This has been put in as a fix to a (possibly hardware) problem
	-- where the end of DMA interrupt is lost for Tx comms on heavily
	-- Tx&Rx loaded links.
	--
	-- Entered with:
	--	R_A1 = LinkInfo * (BPTR)
	--	R_ADDR1 = LinkInfo * (WPTR)
	--	R_A2 = Link Id
	-- Should be PCS conformant, interrupts are disabled throughout.

TxHasCompletedOK:
        GetExecRoot R_ADDR2             -- get hold of Executive root structure

        -- set XRoot->HighestPri to HIGHPRI (LinkTx/Rx thread always high pri)
        stik	HIGHPRI, *+R_ADDR2(ExecRoot.HighestAvailPri)

        -- R_ATMP = (WPTR) *LinkInfo
        ldi     *+R_ADDR1(Link.TxThread), R_ATMP -- R_ATMP = BPTR to SaveState
        stik    0, *+R_ADDR1(Link.TxThread)      -- link->TxThread == NULL
        -- C40WordAddress  R_ADDR1
	lsh3	-2,  R_ATMP, R_ADDR1		 -- R_ADDR1 = WPTR to SaveState
	addi	R_BASE, R_ADDR1

        stik    0, *+R_ADDR1(SaveState.next)      -- SaveState->next = NULL
	stik	THREAD_RUNNABLE, *+R_ADDR1(SaveState.status)

        -- Add SaveState (Rx/TxThread) to high priority Q
        -- R_ADDR1 = xroot->queue[0].tail (WPTR)
        -- C40WordAddress  *+ar1(ExecRoot.Queue0.tail), R_ADDR1
        lsh	-2, *+R_ADDR2(ExecRoot.Queue0.tail), R_ADDR1
	addi	R_BASE, R_ADDR1

	bud	R_LR
        	-- xroot->queue[0].tail = SaveState
	        sti     R_ATMP, *+R_ADDR2(ExecRoot.Queue0.tail)
        	-- xroot->queue[0].tail->next=SaveState
	        sti     R_ATMP, *+R_ADDR1(SaveState.next)
		-- Note AbortLinkTx to return NULL
		ldi	0, R_A1
]

resetboth:
        bud     R_LR
                ldhi    hi_resetboth_control, R_A1
                or      lo_resetboth_control, R_A1

                -- Resets both the primary and auxiliary channel
                sti     R_A1, *+R_ADDR2(dma_control)


-- void _AbortLinkRx(Linkinfo *link, word linkId)
--
-- Abort the split mode auxiliary channel DMA transfer immediately
-- (but without affecting the other channel)
--
-- Called from C so must be PCS complient

._AbortLinkRx:
        -- get word address of link info
	-- C40WordAddress R_A1, R_ADDR1
	lsh	-2, R_A1, R_ADDR1
	addi	R_BASE, R_ADDR1

        -- shift comms port to ctrl reg field
        lsh     15, R_A2,  R_A4

        -- get WPTR to DMA control reg for this link.
        ldi     *+R_ADDR1(Link.DMAEng), R_ADDR2

        -- check to see if the other channel is transmitting
        cmpi    0, *+R_ADDR1(Link.TxThread)
        beq     resetboth

        -- If the Tx channel is still operating, we must take care not to
        -- simply overwrite its channel start value and either stop or restart
        -- it at the wrong time.

        ldhi    hi_haltreset_control, R_A1
        or      lo_haltreset_control, R_A1

        -- this Halts all DMA transfers on either read or write boundary
        -- and resets the auxiliary channel
        sti     R_A1, *+R_ADDR2(dma_control)

		nop     -- Give time for last transfer to complete
		nop     -- before the halt takes effect. This should be
		nop     -- for a minimum of 9 cycles in case we are writing to

		nop     -- dynamic RAM and miss the current page
		nop
		nop

		nop
		nop
		nop


        -- Tx side has now been halted and Rx side reset
HaltedTx:
        -- see if the Tx side had just completed anyway
        ldi     *+R_ADDR2(dma_count), R_A2
        bz      R_LR            -- yes Tx has completed

        -- no so re-start Tx channel
        ldhi    hi_goreset_control, R_A1
        bud     R_LR
                or      lo_goreset_control, R_A1

                -- insert comms port into its control reg field
                or      R_A4, R_A1

                -- this re-starts the Tx DMA transfer
                sti     R_A1, *+R_ADDR2(dma_control)



-- void __LinkTx(LinkInfo *link, word linkId, word size, MPtr buf)
--
-- Sets up and starts a DMA transfer to a link using the primary channel of
-- a split mode DMA engine. C40 version requires word address pointer and
-- size is specified in words.

--
-- The sometimes odd ordering of these instructions is designed not to stall the
-- pipeline - so be careful about changing the order.
--
-- Called from C so must be PCS conformant

.__LinkTx:
        -- get word address of link info
	-- C40WordAddress R_A1, R_ADDR1
	lsh	-2, R_A1, R_ADDR1
	addi	R_BASE, R_ADDR1

        -- get WPTR to DMA control reg for this link.
        ldi     *+R_ADDR1(Link.DMAEng), R_ADDR2

        -- shift comms port to ctrl reg field
        lsh     15, R_A2

_if _not _defp 'writefifo [
        -- load primary channel count register with word version of byte count
        sti     R_A3, *+R_ADDR2(dma_count)
]

        -- store word pointer to source data into DMA source address reg
        sti     R_A4, *+R_ADDR2(dma_srcaddr)

        cmpi    0, *+R_ADDR2(dma_auxcount)      -- if other split channel
        bne     CarefulTxStart                  -- is operating take care

_test _defp 'writefifo [
        -- if we write the link fifo (._LinkTx) by hand we have to reset the
        -- DMA channel every time we use it (C40 bug).

        -- reset both channels (_reset_both_control equivalent)
        stik    0, *+R_ADDR2(dma_control)

SimpleTxStart:
        -- neither split channel is operating if we reach this point

        -- load std values to set in DMA control reg
        -- this value includes primary channel transfer initialisation
        -- and reset for the aux chan

        ldhi    hi_goreset_control, R_A1
        or      lo_goreset_control, R_A1

        -- load prim channel count register with word version of byte count
        -- must be done after a reset as reset zeros count
	-- note also the distance from the reset - required as SRAM systems
	-- (e.g. Hema DSP1) can load count before reset takes effect
        sti     R_A3, *+R_ADDR2(dma_count)
][
SimpleTxStart:
        -- neither split channel is operating if we reach this point

        ldhi    hi_gohalt_control, R_A1
        or      lo_gohalt_control, R_A1
]

        bud     R_LR
                -- insert comms port into control reg values
                or      R_A2, R_A1
		-- disable interrupts so thread will definitely be suspended
		-- before a quick DMA interrupt resumes it!
		AllIntsOff
                -- store Tx attributes in control reg
                -- THIS STARTS THE DMA TRANSFER
                sti     R_A1, *+R_ADDR2(dma_control)

CarefulTxStart:
        -- Rx channel is operating, so we must take care not to simply overwrite
        -- its channel start value and either stop or restart it at the
        -- wrong time.

_test _defp 'writefifo [
        ldhi    hi_resethalt_control, R_A1
        or      lo_resethalt_control, R_A1
][
        ldhi    hi_haltboth_control, R_A1
        or      lo_haltboth_control, R_A1
]
        -- this Halts all DMA transfers on either read or write boundary
        sti     R_A1, *+R_ADDR2(dma_control)
        -- previous write will have been lost if CPU and DMA write at the same
        -- time - however as the DMA engine will only have been writing a halt
        -- code to the start field we dont care (this is what we were trying to
        -- do anyway).
        sti     R_A1, *+R_ADDR2(dma_control)

                nop     -- Give time for last transfer to complete
                nop     -- before the halt takes effect. This should be
                nop     -- for a minimum of 9 cycles in case we are writing to

                nop     -- v. slow dynamic RAM and miss the current page
                nop	-- This is extremely conservative and should never
                nop	-- actually need to be this long.

                nop
                nop
                nop

haltedRx:
        -- If Rx side was operating, it has now been halted.

_if _defp 'writefifo [
        -- Reset also resets the count, so we delay setting it until now.
        -- load prim channel count register with word version of byte count
        sti     R_A3, *+R_ADDR2(dma_count)
]

        -- see if the Rx side had just completed anyway
        cmpi    0, *+R_ADDR2(dma_auxcount)
        beq     SimpleTxStart   -- yes Rx has completed - so just start Tx

        -- no start Tx and re-start Rx

        -- load std values to set in DMA control reg
        -- this value includes primary channel transfer initialisation
        -- and auxilary channel transfer re-start
        ldhi    hi_goboth_control, R_A1
	or      lo_goboth_control, R_A1
        bud     R_LR
                -- insert comms port into its control reg field
                or      R_A2, R_A1
		-- disable interrupts so thread will definitely be suspended
		-- before a quick DMA interrupt resumes it!
		AllIntsOff
                -- this starts the Tx and restarts the Rx DMA transfer
                sti     R_A1, *+R_ADDR2(dma_control)



-- void __LinkRx(LinkInfo *link, word linkId, word size, MPtr buf)
--
-- Sets up and starts a DMA transfer from a link using the auxilary channel of
-- a split mode DMA engine. C40 version requires word address pointer and
-- size is specified in words.
--
-- Called from C so must be PCS conformant

.__LinkRx:
        -- get word address of link info
	-- C40WordAddress R_A1, R_ADDR1
	lsh	-2, R_A1, R_ADDR1
	addi	R_BASE, R_ADDR1

        -- get WPTR to DMA control reg for this link.
        ldi     *+R_ADDR1(Link.DMAEng), R_ADDR2

        -- shift comms port to ctrl reg field
        lsh     15, R_A2

_if _not _defp 'readfifo [
        -- load aux channel count register with word version of byte count
        sti     R_A3, *+R_ADDR2(dma_auxcount)
]

        -- store word pointer to destination for  data into DMA reg
        sti     R_A4, *+R_ADDR2(dma_dstaddr)

        cmpi    0, *+R_ADDR2(dma_count)         -- if other split channel
        bne     CarefulRxStart                  -- is operating take care

_test _defp 'readfifo [
        -- if we read the link fifo (._LinkRx) by hand we have to reset the
        -- DMA channel every time we use it (C40 bug).

        -- reset both channels (_reset_both_control equivalent)
        stik    0, *+R_ADDR2(dma_control)

SimpleRxStart:
        -- neither split channel is operating if we reach this point
        -- load std values to set in DMA control reg
        -- this value includes auxiliary channel transfer initialisation
        -- and primary channel reset.
        ldhi    hi_resetgo_control, R_A1
	or      lo_resetgo_control, R_A1

        -- load aux channel count register with word version of byte count
        -- must be done after a reset as reset zeros count
	-- note also the distance from the reset - required as SRAM systems
	-- (e.g. Hema DSP1) can load count before reset takes effect
        sti     R_A3, *+R_ADDR2(dma_auxcount)

][
SimpleRxStart:
        -- neither split channel is operating if we reach this point
        ldhi    hi_haltgo_control, R_A1
	or      lo_haltgo_control, R_A1
]
        bud     R_LR
                -- insert comms port into control reg values
                or      R_A2, R_A1
		-- disable interrupts so thread will definitely be suspended
		-- before a quick DMA interrupt resumes it!
		AllIntsOff
                -- store Rx attributes in control reg
                -- THIS STARTS THE DMA TRANSFER
                sti     R_A1, *+R_ADDR2(dma_control)


CarefulRxStart:
        -- Tx channel is operating, so we must take care not to simply overwrite
        -- its channel start value and either stop or restart it at the
        -- wrong time.

_test _defp 'readfifo [
        ldhi    hi_haltreset_control, R_A1
        or      lo_haltreset_control, R_A1
][
        ldhi    hi_haltboth_control, R_A1   -- @@@@@@ try no resets
        or      lo_haltboth_control, R_A1
]
        -- this Halts all DMA transfers on either read or write boundary
        sti     R_A1, *+R_ADDR2(dma_control)
        -- previous write will have been lost if CPU and DMA write at the same
        -- time - however as the DMA engine will only have been writing a halt
        -- code to the start field we dont care (this is what we were trying to
        -- do anyway).
                nop     -- Give time for last transfer to complete
                nop     -- before the halt takes effect. This should be
                nop     -- for a minimum of 9 cycles in case we are writing to

                nop     -- v. slow dynamic RAM and miss the current page
                nop
                nop

                nop
                nop
                nop

haltedTx:
        -- If Tx side was running, is should now have been halted

_if _defp 'readfifo [
        -- Reset also resets the count, so we delay setting it until now.
        -- load aux channel count register with word version of byte count
        sti     R_A3, *+R_ADDR2(dma_auxcount)
]

        -- see if the Tx side had just completed anyway
        cmpi    0, *+R_ADDR2(dma_count)
        beq     SimpleRxStart   -- yes Tx has completed - so just start Rx

        -- no so start Rx and re-start Tx

        -- load std values to set in DMA control reg
        -- this value includes primary channel transfer initialisation
        -- and auxilary channel transfer re-start
        ldhi    hi_goboth_control, R_A1
	or      lo_goboth_control, R_A1
        bud     R_LR
                -- insert comms port into its control reg field
                or      R_A2, R_A1
		-- disable interrupts so thread will definitely be suspended
		-- before a quick DMA interrupt resumes it!
		AllIntsOff
                -- this starts the Rx and restarts the paused Tx DMA transfer
                sti     R_A1, *+R_ADDR2(dma_control)



-- LinkDMAIntrHandlerX
--
-- Handles the end of DMA interrupt for DMA to/from the links. It Resumes
-- the thread that was waiting for the transfer to complete.
--
-- The Tx/Rx side that actually completed is noted by the TCINT and AUXTCINT
-- flags in the DMA channel control register.
--
-- The interrupt is vectored through a stub that loads the correct DMA control
-- register, and then proceeds into the general handler. The control register
-- is used to ascertain which com port was being used and which direction
-- of transfer has completed. AUXTCFLAG = Rx complete, TCFLAG = Tx complete.

	-- Import allows us to branch into time-slice mechanism if current
	-- thread is lower priority that resumed LinkTx/Rx thread.
	import	extern_slice_now

-- End of DMA interrupt for DMA channel 0
LinkDMAIntrHandler0:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save users (possibly
						-- corrupted) C base addr reg
        bud     GenEDMAHandler
                push    ar0                     -- save reg we're about to trash
                ldhi    0x10, ar0               -- get address of this DMA
                or      dma0_control, ar0       -- channels control register

-- End of DMA interrupt for DMA channel 1
LinkDMAIntrHandler1:
        push    ST
	push	R_BASE
        bud     GenEDMAHandler
                push    ar0
                ldhi    0x10, ar0
                or      dma1_control, ar0

LinkDMAIntrHandler2:
        push    ST
	push	R_BASE
        bud     GenEDMAHandler
                push    ar0
                ldhi    0x10, ar0
                or      dma2_control, ar0

LinkDMAIntrHandler3:
        push    ST
	push	R_BASE
        bud     GenEDMAHandler
                push    ar0
                ldhi    0x10, ar0
                or      dma3_control,ar0

LinkDMAIntrHandler4:
        push    ST
	push	R_BASE
        bud     GenEDMAHandler
                push    ar0
                ldhi    0x10, ar0
                or      dma4_control, ar0

LinkDMAIntrHandler5:
        push    ST
	push	R_BASE
        push    ar0
        ldhi    0x10, ar0
        or      dma5_control, ar0


-- General end of DMA interrupt handler
--
-- Pseudo code:
--
-- void LinkTxRxResume(int comchan, int txrx) /* txrx: tx = 1, rx = 2 */
-- {
--      ExecRoot        *xroot = GetExecRoot();
--      RootStruct      *nroot = GetRoot();
--
--      SaveState       *ss;
--      ThreadQ         *q = &xroot->Queues[0];
--
--      if (txrx == 0)
--              return; /* spurious interrupt */
--
--      /* LinkTx/Rx is always high priority */
--      xroot->HighestAvailPri = 0;
--
--      if (txrx & 1) {
--              ss = nroot->Links[comchan]->TxThread;
--
--              if (ss != NULL) {
--                      nroot->Links[comchan]->TxThread = NULL;
--
--                      /* add thread to end of run Q for its priority */
--                      ss->next = NULL;
--                      q->tail = q->tail->next = ss;
--              }
--      }
--
--      if (txrx & 2) {
--              ss = nroot->Links[comchan]->RxThread;
--
--              if (ss == NULL)
--                      return;
--
--              nroot->Links[comchan]->RxThread = NULL;
--
--              /* add thread to end of run Q for its priority */
--              ss->next = NULL;
--              q->tail = q->tail->next = ss;
--      }
-- }
--
--
-- The slightly odd ordering of these instructions is an attempt to stop
-- stalling the instruction pipeline so often (difficult).

GenEDMAHandler:
        push    ar1                     -- Save rest of registers we will use
        push    ar2
	push	ar3

        or      ST_SET_COND, st         -- set cond codes for addr regs

        ldi     *ar0, ar1               -- load arguments
        lsh     -15, ar1, ar0           -- shift comport to base of ar0
        lsh     -20, ar1                -- shift interrupt flags to base of ar1

        GetExecRoot ar3                 -- get hold of Executive root structure

        and     0b11, ar1               -- ar1 = AUXTCINTFLAG | TCINTFLAG
	-- @@@@@@ should we check here as well for 'lost' end of DMA interrupts?
        bz      interrupt_return        -- spurious interrupt

	-- Get system C addess base
	ldi	*+ar3(ExecRoot.CAddressBase), R_BASE

        -- set XRoot->HighestPri to HIGHPRI (LinkTx/Rx thread always high pri)
        stik	HIGHPRI, *+ar3(ExecRoot.HighestAvailPri)

        -- ar2 = (WPTR)GetRoot()
	-- C40WordAddress  *+ar3(ExecRoot.KernelRoot), ar2
	lsh	-2, *+ar3(ExecRoot.KernelRoot), ar2
	addi	R_BASE, ar2

        cmpi    0b11, ar1
        beq     TxANDRxInterrupt

        -- get Root->Links
	-- C40WordAddress  *+ar2(Root.Links), ar2
	lsh	-2, *+ar2(Root.Links), ar2	-- ar2 = root->Links (WPTR)
	addi	R_BASE, ar2

        and     0b111, ar0              	-- clean up com port number
        tstb    0b10, ar1                       -- check for an Rx interrupt 
        bnzd    RxInterrupt
                -- get Root->Links[ar0]
                addi    ar0, ar2                -- ar2=(WPTR)&root->Links[cmprt]
-- two cycle pipeline register conflict delay here! (ar2)
                -- C40WordAddress  *+ar2(0), ar0   -- ar0=(WPTR)root->links[cmprt]
		lsh	-2, *+ar2(0), ar0	-- ar0=(WPTR)root->links[cmprt]
		addi	R_BASE, ar0


-- two cycle pipeline register conflict delay here! (ar0)

TxInterrupt:
        -- Reach here end of Tx DMA interrupt is detected
	--
	-- Entered with:
        --	ar0 = (WPTR) *LinkInfo
	--	ar3 = ExecRoot

_if _defp 'C40BUG_LostIntr2 [
	-- Is there an Rx side comms outstanding?
	cmpi	0, *+ar0(Link.RxThread)
	beq	NoLostRxInterrupt
	-- Check if DMA engine has completed.
	ldi	*+ar0(Link.DMAEng), ar2
	cmpi	0, *+ar2(dma_auxcount)
	-- Completed, so treat as combined Rx/Tx interrupt.
	beq	TxAndRxInterrupt2
NoLostRxInterrupt:
]
        ldi     *+ar0(Link.TxThread), ar2       -- ar2 = BPTR to SaveState
        stik    0, *+ar0(Link.TxThread)         -- link->TxThread == NULL
        -- C40WordAddress  ar2, ar0
	lsh	-2,  ar2, ar0			-- ar0 = WPTR to SaveState
        bZ      interrupt_return                -- null savestate (aborted xfer)
	addi	R_BASE, ar0

        stik    0, *+ar0(SaveState.next)        -- SaveState->next = NULL
	stik	THREAD_RUNNABLE, *+ar0(SaveState.status)

        -- Add SaveState (Rx/TxThread) to high priority Q
        -- ar0 = xroot->queue[0].tail (WPTR)
        -- C40WordAddress  *+ar3(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar3(ExecRoot.Queue0.tail), ar0
	addi	R_BASE, ar0

         -- xroot->queue[0].tail = SaveState
        sti     ar2, *+ar3(ExecRoot.Queue0.tail)

-- single cycle pipeline register conflict delay here! (ar0)

        -- xroot->queue[0].tail->next=SaveState
        sti     ar2, *+ar0(SaveState.next)

	-- If CurrentPri is not HIGHPRI, then we slice the currently
	-- interrupted thread and allow the new LinkRx high priority thread
	-- we have just resumed to run. The Extern_slice_now is imported from
	-- the timeslice mechanism in c40intr.a.
	ldi	*+ar3(ExecRoot.CurrentPri), ar1
	bnz	extern_slice_now

interrupt_return:
	pop	ar3                     -- pop old state off interrupt stack
        pop     ar2
        pop     ar1
        pop     ar0
	pop	R_BASE
        pop     st

        retiU                           -- return from interrupt

RxInterrupt:
        -- Reach here end of Rx DMA interrupt is detected
	--
	-- Entered with:
        --	ar0 = (WPTR) *LinkInfo
	--	ar3 = ExecRoot

_if _defp 'C40BUG_LostIntr2 [
	-- Is there an Tx side comms outstanding?
	cmpi	0, *+ar0(Link.TxThread)
	beq	NoLostTxInterrupt
	-- Check if DMA engine has completed.
	ldi	*+ar0(Link.DMAEng), ar2
	cmpi	0, *+ar2(dma_count)
	-- Completed, so treat as combined Rx/Tx interrupt.
	beq	TxAndRxInterrupt2
NoLostTxInterrupt:
]

        ldi     *+ar0(Link.RxThread), ar2       -- ar2 = BPTR to SaveState
        stik    0, *+ar0(Link.RxThread)         -- link->RxThread == NULL
        -- C40WordAddress  ar2, ar0             -- ar0 = WPTR to SaveState
        lsh	-2, ar2, ar0			-- ar0 = WPTR to SaveState
        bZ      interrupt_return                -- null savestate (aborted xfer)
	addi	R_BASE, ar0

        stik    0, *+ar0(SaveState.next)        -- SaveState->next = NULL
	stik	THREAD_RUNNABLE, *+ar0(SaveState.status)

        -- Add SaveState (Rx/TxThread) to high priority Q
        -- ar0 = xroot->queue[0].tail (WPTR)
        -- C40WordAddress  *+ar3(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar3(ExecRoot.Queue0.tail), ar0
	addi	R_BASE, ar0

        -- xroot->queue[0].tail = SaveState
        sti     ar2, *+ar3(ExecRoot.Queue0.tail)

-- single cycle pipeline register conflict delay here! (ar0)

        -- xroot->queue[0].tail->next=SaveState
        sti     ar2, *+ar0(SaveState.next)

	-- If CurrentPri is not HIGHPRI, then we slice the currently
	-- interrupted thread and allow the new LinkTx high priority thread
	-- we have just resumed to run. The Extern_slice_now is imported from
	-- the timeslice mechanism in c40intr.a.
	ldi	*+ar3(ExecRoot.CurrentPri), ar1
	bnz	extern_slice_now

	pop	ar3	                -- pop old state off interrupt stack
        pop     ar2
        pop     ar1
        pop     ar0
	pop	R_BASE
        pop     st

        retiU                           -- return from interrupt



TxANDRxInterrupt:
        -- If we reach here we have both an end of Rx and end of Tx interrupt.
        -- We must service both now as the act of reading the control register
        -- resets the interrupt flags.
	--
	-- Entered with:
	--	ar0 = contents of DMA control register
        --	ar2 = (WPTR) kernels root structure
	--	ar3 = ExecRoot

        -- Get Root->Links.
        -- C40WordAddress  *+ar2(Root.Links), ar2
        lsh	-2, *+ar2(Root.Links), ar2	-- ar2 = root->Links (WPTR)
	addi	R_BASE, ar2

        and     0b111, ar0                      -- clean up com port number

        -- get Root->Links[ar0]
        addi    ar0, ar2                        -- ar2=(WPTR)&root->Links[cmprt]

-- two cycle pipeline register conflict delay here! (ar2)

        -- C40WordAddress  *+ar2(0), ar0
        lsh	-2, *+ar2(0), ar0		-- ar0=(WPTR)root->links[cmprt]
	addi	R_BASE, ar0			-- ar0 = (WPTR) *LinkInfo


_if _defp 'C40BUG_LostIntr2 [
	-- Entered here if we have detected a 'lost' end of DMA interrupt.
	--
	-- Entered with:
	--	ar0 = (WPTR) *LinkInfo
	--	ar3 = ExecRoot
TxAndRxInterrupt2:
]

-- one cycle pipeline register conflict delay here! (ar0)

        ldi     *+ar0(Link.RxThread), ar2       -- ar2 = BPTR to Rx SaveState
        stik    0, *+ar0(Link.RxThread)         -- link->RxThread == NULL
        ldi     *+ar0(Link.TxThread), ar1       -- ar1 = BPTR to Tx SaveState
        stik    0, *+ar0(Link.TxThread)         -- link->TxThread == NULL

HandleRxSide:
	-- Add SaveState (RxThread) to high priority Q
        -- C40WordAddress  ar2, ar0
	lsh	-2, ar2, ar0			-- ar0 = WPTR to Rx SaveState
        bZ      HandleTxSide                    -- null savestate (aborted xfer)
	addi	R_BASE, ar0

        stik    0, *+ar0(SaveState.next)        -- SaveState->next = NULL
	stik	THREAD_RUNNABLE, *+ar0(SaveState.status)

        -- Point ar0 at thread Q tail for high priority threads.
        -- ar0 = xroot->queue[0].tail (WPTR)
        -- C40WordAddress  *+ar3(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar3(ExecRoot.Queue0.tail), ar0
	addi	R_BASE, ar0

        -- xroot->queue[0].tail = SaveState
        sti     ar2, *+ar3(ExecRoot.Queue0.tail)

-- single cycle pipeline register conflict delay here! (ar0)

        -- xroot->queue[0].tail->next=SaveState
        sti     ar2, *+ar0(SaveState.next)


HandleTxSide:
	-- Add SaveState (TxThread) to high priority Q
	-- ar3 = ExecRoot
	-- ar1 = BPTR to Tx SaveState

        -- C40WordAddress  ar1, ar0
        lsh	-2, ar1, ar0                    -- ar0 = WPTR to Tx SaveState
        bZ      TxAndRxReturn                   -- null savestate (aborted xfer)
	addi	R_BASE, ar0

        stik    0, *+ar0(SaveState.next)        -- SaveState->next = NULL
	stik	THREAD_RUNNABLE, *+ar0(SaveState.status)

        -- ar0 = xroot->queue[0].tail (WPTR)
        -- C40WordAddress  *+ar3(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar3(ExecRoot.Queue0.tail), ar0
	addi	R_BASE, ar0

        -- xroot->queue[0].tail = SaveState
        sti     ar1, *+ar3(ExecRoot.Queue0.tail)

-- single cycle pipeline register conflict delay here! (ar0)

        -- xroot->queue[0].tail->next=SaveState
        sti     ar1, *+ar0(SaveState.next)

	-- If CurrentPri is not HIGHPRI, then we slice the currently
	-- interrupted thread and allow the new LinkTx high priority thread
	-- we have just resumed to run. The Extern_slice_now is imported from
	-- the timeslice mechanism in c40intr.a.
	ldi	*+ar3(ExecRoot.CurrentPri), ar1
	bnz	extern_slice_now

TxAndRxReturn:
        pop     ar3                     -- pop old state off interrupt stack
        pop     ar2
        pop     ar1
        pop     ar0
	pop	R_BASE
        pop     st

        retiU                           -- return from interrupt



][ -- not LINKDMA

-- Interrupt driven __LinkTx/Rx code.

-- *** WARNING *** This link interrupt code has never been tested!!!

-- @@@@@@ This code could be substantially improved by using the fifo full/empty
-- interrupts when transfers are > fifo size and then swapping back to
-- interrupts for single words when the transfer amount < fifo size.
-- + using rpts(fifosize) to transfer data between memory and fifo.

-- @@@@@@ Note that interrupts could also be re-enabled immediately - if we
-- disabled the specific links rdy/full interrupt.

-- @@@@@@ another opt. is to either ld a reg with the correct lins interrupt mask
-- in the per link intr. handler, or to store this pre-calculated in the
-- LinkIn/OutStat structure.

-- @@@@@@ Note that this code will not work with latest systems that do not have
-- and address base of 0. The use of R_BASE and C40C/WordAddress macros will
-- have to updated to use the ExecRoot as an R_BASE equivalent. 

-- void InitLink(word channel)  -- channel == channel number
--
-- Sets up input and output interrupt handlers for given link channel
--
-- Called from C so must be PCS conformant.

.InitLink:
        -- Setup interrupt handler into the correct intr. vector
        -- get hold of interrupt vector base
        ldep    ivtp, R_ADDR1
        addi    iv_icfull0, R_ADDR1     -- get base of link intr vectors
        mpyi    4, R_A1, R_A2           -- get offset into link intr vectors
        addi    R_A2, R_ADDR1           -- points to this links intr vectors

        -- get address of this channels input handler
        ldabs16 LinkInputIntrHandler0 R_ADDR2 -- abs addr of interrupt handler 0
        mpyi    8, R_ADDR2              -- chan * 8 instructions

        -- store link DMA interrupt handler into interrupt vector.
        sti     R_ADDR2, *+R_ADDR1(iv_icrdy)

        -- get address of this channels output handler
        ldabs16 LinkOutputIntrHandler0 R_ADDR2 -- abs addr of interrupt handler 0
        mpyi    7, R_ADDR2              -- chan * 7 instructions

        -- store link DMA interrupt handler into interrupt vector.
        sti     R_ADDR2, *+R_ADDR1(iv_ocrdy)

        b       R_LR



-- void __LinkTx(LinkInfo *link, word linkId, word size, void *buf)
--
-- Sets up and starts a interrupt driven transfer to a link
--
-- The sometimes odd ordering of these instructions is designed not to stall the
-- pipeline - so be careful about changing the order.
--
-- Called from C so must be PCS conformant

.__LinkTx:
        -- get address of link out status structure
        GetExecRoot R_ADDR1
        addi    ExecRoot.LinkOutStat0, R_ADDR1
        mpyi    LinkReq.sizeof / 4, R_A2, R_A1
        addi    R_A1, R_ADDR1

        -- word address of data to transfer
        C40WordAddress R_A4

        -- convert byte to word count (guaranteed by caller to be a word multip)
        lsh     -2, R_A3

        -- save into link status struct
        sti     R_A4, *+R_ADDR1(LinkReq.Buf)
        sti     R_A3, *+R_ADDR1(LinkReq.Count)

        mpyi    4, R_A2         -- EOCRDY intr. enable bit = 1 >> link * 4 + 3
        addi    3, R_A2
        bud     R_LR
                ldi     1, R_A1
                lsh     R_A2, R_A1
                or      R_A1, IIE       -- enable link output ready interrupts


-- void __LinkRx(LinkInfo *link, word linkId, word size, void *buf)
--
-- Sets up and starts a DMA transfer from a link using the auxilary channel of
-- a split mode DMA engine.
--
-- Called from C so must be PCS conformant

.__LinkRx:
        -- get address of link in status structure
        GetExecRoot R_ADDR1
        addi    ExecRoot.LinkInStat0, R_ADDR1
        mpyi    LinkReq.sizeof / 4, R_A2, R_A1
        addi    R_A1, R_ADDR1

        -- word address of data to transfer
        C40WordAddress R_A4

        -- convert byte to word count (guaranteed by caller to be a word multip)
        lsh     -2, R_A3

        -- save into link status struct
        sti     R_A4, *+R_ADDR1(LinkReq.Buf)
        sti     R_A3, *+R_ADDR1(LinkReq.Count)

        mpyi    4, R_A2         -- EICRDY intr. enable bit = 1 >> link * 4 + 2
        addi    2, R_A2
        bud     R_LR
                ldi     1, R_A1
                lsh     R_A2, R_A1
                or      R_A1, IIE       -- enable link input ready interrupts



-- Link ready interrupt for input channel 0
LinkInputIntrHandler0:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenInputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port0_control, ar0      -- channels control register
                ldi     0, ar1                  -- link number

LinkInputIntrHandler1:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenInputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port1_control, ar0      -- channels control register
                ldi     1, ar1                  -- link number

LinkInputIntrHandler2:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenInputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port2_control, ar0      -- channels control register
                ldi     2, ar1                  -- link number

LinkInputIntrHandler3:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenInputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port3_control, ar0      -- channels control register
                ldi     3, ar1                  -- link number

LinkInputIntrHandler4:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenInputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port4_control, ar0      -- channels control register
                ldi     4, ar1                  -- link number

LinkInputIntrHandler5:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenInputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port5_control, ar0      -- channels control register
                ldi     5, ar1                 -- link number


-- Link ready interrupt for output channel 0
LinkOutputIntrHandler0:
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenOutputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port0_control, ar0      -- channels control register
                ldi     0, ar1                  -- link number

LinkOutputIntrHandler1:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenOutputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port1_control, ar0      -- channels control register
                ldi     1, ar1                  -- link number

LinkOutputIntrHandler2:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenOutputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port2_control, ar0      -- channels control register
                ldi     2, ar1                  -- link number

LinkOutputIntrHandler3:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenOutputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port3_control, ar0      -- channels control register
                ldi     3, ar1                  -- link number

LinkOutputIntrHandler4:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenOutputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port4_control, ar0      -- channels control register
                ldi     4, ar1                  -- link number

LinkOutputIntrHandler5:
        -- interrupt vectored to this point 
        push    ST                              -- MUST save ST here
	push	R_BASE				-- save user version of R_BASE
        push    ar0                             -- save reg we're about to trash
        push    ar1                             -- save reg we're about to trash
        bud     GenOutputHandler
                ldhi    0x10, ar0               -- get address of this link
                or      port5_control, ar0      -- channels control register
                ldi     5, ar1                  -- link number



-- General ICRDY interrupt handler
--
-- The slightly odd ordering of these instructions is an attempt to stop
-- stalling the instruction pipeline so often (difficult).

-- ar0 = link control reg address
-- ar1 = link number

GenInputHandler:
        -- Save rest of registers we will use
        --      ar0     -- link control reg addr
        --      ar1     -- link number
        push    ar2     -- count
        push    ar3     -- buffer
        push    ar4     -- tmp
        push    ar5     -- LinkReq struct addr

        or      ST_SET_COND, st         -- set cond codes for addr regs

        GetExecRoot ar2                 -- get hold of Executive root structure

	-- Get system C addess base
	ldi	*+ar2(ExecRoot.CAddressBase), R_BASE

        -- get address of LinkInStat struct for this input link into ar2
        addi    ExecRoot.LinkInStat0, ar2
        mpyi    LinkReq.sizeof / 4, ar1, ar5
        addi    ar2, ar5

        ldi     *+ar5(LinkReq.Count), ar2
_if _false [ -- used to check for spurious intr.
        bnz      NoSpuriousInIntr
	int	0x66ffffff
	b	SpuriousInIntr
NoSpuriousInIntr:
]
        ldi     *+ar5(LinkReq.Buf), ar3

InputLoop:
        ldi     *+ar0(port_input), ar4  -- read word from fifo and store in mem
        sti     ar4, *ar3++

        subi    1, ar2
        bz      GotEmAll                -- if we recieved all we need

        lsh     -cpcr_input_levelB, *+ar0(port_control), ar4
        bnz     InputLoop               -- if no more words in input fifo

NoMoreInput:
        -- save updated pointer and count
        sti     ar2, *+ar5(LinkReq.Count)
        sti     ar3, *+ar5(LinkReq.Buf)

SpuriousInIntr:
        pop     ar5                     -- pop old state off interrupt stack
        pop     ar4
        pop     ar3
        pop     ar2
        pop     ar1
        pop     ar0
	pop	R_BASE
        pop     st

        retiU                           -- return from interrupt


GotEmAll:
        -- mask out input ready interrupt from IIE reg (ar1 = link num)
        mpyi    4, ar1, ar3             -- EICRDY intr. enable bit = 1 >> link * 4 + 2
        addi    2, ar3
        ldi     1, ar2
        lsh     ar3, ar2
        andn    ar2, IIE        -- disable link input ready interrupts

_test _defp 'sstateinstatstruct [
	-- This code is only used if the savestate pointer has been saved
	-- in the LinkReq structure, rather than in the LinkInfo struct

        GetExecRoot ar1         -- get hold of Executive root structure

        ldi     *+ar5(LinkReq.Requestor), ar2   -- get save state

        -- C40WordAddress ar2, ar4
        lsh	-2, ar2, ar4			-- WPTR to save state
	addi	R_BASE, ar4

        -- set XRoot->HighestPri to HIGHPRI (LinkTx/Rx thread always high pri)
        stik	HIGHPRI, *+ar1(ExecRoot.HighestAvailPri)

-- @@@@@@ single cycle pipeline register conflict delay here! (ar4)

        stik    0, *+ar4(SaveState.next)        -- SaveState->next = NULL

        -- Add SaveState (Rx/TxThread) to high priority Q
        -- ar0 = xroot->queue[0].tail (WPTR)
        -- C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar1(ExecRoot.Queue0.tail), ar0
	addi	R_BASE, ar0

         -- xroot->queue[0].tail = SaveState
        sti     ar2, *+ar1(ExecRoot.Queue0.tail)

-- @@@@@@ single cycle pipeline register conflict delay here! (ar0)

        -- xroot->queue[0].tail->next=SaveState
        sti     ar2, *+ar0(SaveState.next)
][
        GetExecRoot ar2

        -- set XRoot->HighestPri to HIGHPRI (LinkTx/Rx thread always high pri)
        stik	HIGHPRI, *+ar2(ExecRoot.HighestAvailPri)

        -- ar3 = (WPTR)GetRoot()
        -- C40WordAddress  *+ar2(ExecRoot.KernelRoot), ar3
        lsh	-2, *+ar2(ExecRoot.KernelRoot), ar3
	addi	R_BASE, ar3

-- @@@@@@ two cycle pipeline register conflict delay here! (ar3)

        -- get Root->Links
        -- C40WordAddress  *+ar3(Root.Links), ar3
        lsh	-2, *+ar3(Root.Links), ar3	-- ar3 = root->Links (WPTR)
        addi	R_BASE, ar3

        -- get Root->Links[ar1]
        addi    ar1, ar3                -- ar3=(WPTR)&root->Links[cmprt]

-- @@@@@@ two cycle pipeline register conflict delay here! (ar3)

        -- C40WordAddress  *+ar3(0), ar0
        lsh	-2, *+ar3(0), ar0	-- ar0=(WPTR)root->links[cmprt]
	addi	R_BASE, ar0

        -- ar0 = (WPTR) *LinkInfo
        ldi     *+ar0(Link.RxThread), ar1       -- ar1 = BPTR to SaveState

_if _false [ -- used to check for duplicate resumes
        stik    0, *+ar0(Link.RxThread)         -- link->TxThread == NULL
        -- C40WordAddress  ar1, ar0
        lsh	-2, ar1, ar0                    -- ar0 = WPTR to SaveState
	addi	R_BASE, ar0
        bnz     OK_RxResume
        -- null savestate (aborted xfer)
        int     0x66ffffff                      -- JTAGHalt
OK_RxResume:
]
        stik    0, *+ar0(SaveState.next)        -- SaveState->next = NULL

        -- Add SaveState (Rx/TxThread) to high priority Q
        -- ar0 = xroot->queue[0].tail (WPTR)
        -- C40WordAddress  *+ar2(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar2(ExecRoot.Queue0.tail), ar0
	addi	R_BASE, ar0

        -- xroot->queue[0].tail = SaveState
        sti     ar1, *+ar2(ExecRoot.Queue0.tail)

-- single cycle pipeline register conflict delay here! (ar0)

        -- xroot->queue[0].tail->next=SaveState
        sti     ar1, *+ar0(SaveState.next)
]
        pop     ar5                     -- pop old state off interrupt stack
        pop     ar4
        pop     ar3
        pop     ar2
        pop     ar1
        pop     ar0
	pop	R_BASE
        pop     st

        retiU                           -- return from interrupt



-- General OCRDY interrupt handler
--
-- The slightly odd ordering of these instructions is an attempt to stop
-- stalling the instruction pipeline so often (difficult).

-- ar0 = link control reg address
-- ar1 = link number

GenOutputHandler:
        -- Save rest of registers we will use
        --      ar0     -- link control reg addr
        --      ar1     -- link number
        push    ar2     -- count
        push    ar3     -- buffer
        push    ar4     -- tmp
        push    ar5     -- LinkReq struct addr

        or      ST_SET_COND, st         -- set cond codes for addr regs

        GetExecRoot ar2                 -- get hold of Executive root structure

	-- Get system C addess base
	ldi	*+ar2(ExecRoot.CAddressBase), R_BASE

        -- get address of LinkOutStat struct for this input link into ar2
        addi    ExecRoot.LinkOutStat0, ar2
        mpyi    LinkReq.sizeof / 4, ar1, ar5
        addi    ar2, ar5

        ldi     *+ar5(LinkReq.Count), ar2

_if _false [ -- used to check for spurious intr.
        bnz      NoSpuriousOutIntr
	int	0x66ffffff
        b	SpuriousOutIntr
NoSpuriousOutIntr:
]
        ldi     *+ar5(LinkReq.Buf), ar3

OutputLoop:
        ldi     *ar3++, ar4     -- read word from memory and store in link fifo
        sti     ar4, *+ar0(port_output)

        subi    1, ar2
        bz      SentEmAll               -- if we have sent all we need

        -- test if the fifo still has more space in it.
        lsh     -cpcr_output_levelB, *+ar0(port_control), ar4
        and     0b1000, ar4     -- check last bit (notes full output fifo)
        bz      OutputLoop


        -- save updated pointer and count
        sti     ar2, *+ar5(LinkReq.Count)
        sti     ar3, *+ar5(LinkReq.Buf)

SpuriousOutIntr:
        pop     ar5                     -- pop old state off interrupt stack
        pop     ar4
        pop     ar3
        pop     ar2
        pop     ar1
        pop     ar0
	pop	R_BASE
        pop     st

        retiU                           -- return from interrupt


SentEmAll:
        -- mask out output ready interrupt from IIE reg (ar1 = link num)
        mpyi    4, ar1, ar3             -- EOCRDY intr. enable bit = 1 >> link * 4 + 3
        addi    3, ar3
        ldi     1, ar2
        lsh     ar3, ar2
        andn    ar2, IIE        -- disable link output ready interrupts

_test _defp 'sstateinstatstruct [
	-- This code is only used if the savestate pointer has been saved
	-- in the LinkReq structure, rather than in the LinkInfo struct

        GetExecRoot ar1                 -- get hold of Executive root structure

        -- Append SaveState to end of HIGHPRI run Q
        ldi     *+ar5(LinkReq.Requestor), ar2   -- get save state
        -- C40WordAddress ar2, ar4
        lsh	-2, ar2, ar4                 -- WPTR to save state
	addi	R_BASE, ar4

        -- set XRoot->HighestPri to HIGHPRI (LinkTx/Rx thread always high pri)
        stik	HIGHPRI, *+ar1(ExecRoot.HighestAvailPri)

-- @@@@@@ single cycle pipeline register conflict delay here! (ar4)

        stik    0, *+ar4(SaveState.next)        -- SaveState->next = NULL

        -- Add SaveState (Rx/TxThread) to high priority Q
        -- ar0 = xroot->queue[0].tail (WPTR)
        -- C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar1(ExecRoot.Queue0.tail), ar0
	addi	R_BASE, ar0

         -- xroot->queue[0].tail = SaveState
        sti     ar2, *+ar1(ExecRoot.Queue0.tail)

-- @@@@@@ single cycle pipeline register conflict delay here! (ar0)

        -- xroot->queue[0].tail->next=SaveState
        sti     ar2, *+ar0(SaveState.next)
][
        GetExecRoot ar2

        -- set XRoot->HighestPri to HIGHPRI (LinkTx/Rx thread always high pri)
        stik	HIGHPRI, *+ar2(ExecRoot.HighestAvailPri)

        -- ar3 = (WPTR)GetRoot()
        -- C40WordAddress  *+ar2(ExecRoot.KernelRoot), ar3
        lsh	-2, *+ar2(ExecRoot.KernelRoot), ar3
	addi	R_BASE, ar3

-- @@@@@@ two cycle pipeline register conflict delay here! (ar3)

        -- get Root->Links
        -- C40WordAddress  *+ar3(Root.Links), ar3
        lsh	-2, *+ar3(Root.Links), ar3	-- ar3 = root->Links (WPTR)
	addi	R_BASE, ar3

        -- get Root->Links[ar1]
        addi    ar1, ar3                -- ar3=(WPTR)&root->Links[cmprt]

-- @@@@@@ two cycle pipeline register conflict delay here! (ar3)

        -- C40WordAddress  *+ar3(0), ar0
        lsh	-2, *+ar3(0), ar0	-- ar0=(WPTR)root->links[cmprt]
	addi	R_BASE, ar0

        -- ar0 = (WPTR) *LinkInfo
        ldi     *+ar0(Link.TxThread), ar1       -- ar1 = BPTR to SaveState

_if _false [ -- used to check for duplicate resumes
        stik    0, *+ar0(Link.TxThread)         -- link->RxThread == NULL
        -- C40WordAddress  ar1, ar0
        lsh	-2, ar1, ar0                    -- ar0 = WPTR to SaveState
	addi	R_BASE, ar0

        bnz     OK_TxResume
        -- null savestate (aborted xfer)
        int     0x66ffffff                      -- JTAGHalt
OK_TxResume:
]
	stik	0, *+ar0(SaveState.next)	-- SaveState->next = NULL

	-- Add SaveState (Rx/TxThread) to high priority Q
	-- ar0 = xroot->queue[0].tail (WPTR)
	-- C40WordAddress	*+ar2(ExecRoot.Queue0.tail), ar0
	lsh	-2, *+ar2(ExecRoot.Queue0.tail), ar0
	addi	R_BASE, ar0

	-- xroot->queue[0].tail = SaveState
	sti	ar1, *+ar2(ExecRoot.Queue0.tail)

-- single cycle pipeline register conflict delay here! (ar0)

	-- xroot->queue[0].tail->next=SaveState
	sti	ar1, *+ar0(SaveState.next)
]
	pop	ar5			-- pop old state off interrupt stack
	pop	ar4
	pop	ar3
	pop	ar2
	pop	ar1
	pop	ar0
	pop	R_BASE
	pop	st

	retiU				-- return from interrupt


-- void _AbortLinkRx(Linkinfo *link, word linkId)
--
-- Abort the interrupt driven transfer immediately
--
-- Called from C so must be PCS complient

._AbortLinkRx:
	-- mask out input ready interrupt from IIE reg (ar1 = link num)
	mpyi	4, R_A2		-- EICRDY intr. enable bit = 1 >> link * 4 + 2
	addi	2, R_A2
	bud	R_LR
		ldi	1, R_A1
		lsh	R_A2, R_A1
		andn	R_A1, IIE	-- disable link output ready interrupts


-- void _AbortLinkTx(LinkInfo *link, word linkId)
--
-- Abort the interrupt driven transfer immediately
--
-- Called from C so must be PCS complient

._AbortLinkTx:
	-- mask out output ready interrupt from IIE reg (ar1 = link num)
	mpyi	4, R_A2		-- EOCRDY intr. enable bit = 1 >> link * 4 + 3
	addi	3, R_A2
	bud	R_LR
		ldi	1, R_A1
		lsh	R_A2, R_A1
		andn	R_A1, IIE	-- disable link output ready interrupts

]



-- end of c40linkio.a
@


1.18
log
@re-enabled fix for lost interrupts (whereby when AbortRX is called because of timeout, it detectes whether an interrupt is lost, and if so, recovers from it).
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.17 1993/02/25 10:22:34 paul Exp nickc $
d17 3
d567 1
a567 1
	lsh	-2,  R_ADDR1			 -- R_ADDR1 = WPTR to SaveState
@


1.17
log
@fixed up small typos in source
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.16 1993/01/26 10:09:50 paul Exp $
d17 3
d100 1
a100 1
-- _def 'C40BUG_LostIntr1 1
@


1.16
log
@Fixed LinkTx/Rx lost interrupt silicon problem with a work around. Now
checks Tx completion in Rx interrupts and vis-versa. Also reduced the
dispatch latency when resuming Rx/Tx threads
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.15 1993/01/25 09:06:57 paul Exp paul $
d17 5
d496 1
d1510 1
a1510 1
                ldi     50, ar1                 -- link number
@


1.15
log
@minor improvements plus IR0 (R_BASE) saveing and restoring
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.14 1992/12/17 14:23:20 paul Exp $
d17 3
d89 13
d481 10
a490 6
	-- This has been put in as a fix to a (possibly hardware) problem
	-- where the end of DMA interrupt is lost for Tx comms on heavily
	-- Tx&Rx loaded links. Only known to occur on Hema DSP1 cards
	-- currently.
	cmpi	0, *+R_ADDR2(dma_count)
	beq	TxHasCompletedOK
d492 2
a493 4
        -- check to see if the other channel is transmitting
        cmpi    0, *+R_ADDR1(Link.RxThread)
        -- If the Rx channel is still operating, we must take care not to
        -- simply overwrite its channel start value and either stop or restart
d532 1
d574 2
d932 4
d1050 1
d1086 17
a1102 2
        -- If we reach here it must be End of Tx interrupt
        -- ar0 = (WPTR) *LinkInfo
a1109 3
        -- point ar1 at thread Q tail for high priority threads
        GetExecRoot ar1

d1115 2
a1116 2
        -- C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar1(ExecRoot.Queue0.tail), ar0
d1120 1
a1120 1
        sti     ar2, *+ar1(ExecRoot.Queue0.tail)
d1127 6
a1132 3
	-- @@@@@@ could also check CurrentPri for != 0, if so we could call the
	-- Slice code. Thus reducing the dispatch latency for further LinkTx /
	-- LinkRX calls. (also for RXInterrupt and TxandRxInterrupts).
d1145 18
a1162 2
        -- If we reach here it must be End of Rx interrupt
        -- ar0 = (WPTR) *LinkInfo
a1169 3
        -- point ar1 at thread Q tail for high priority threads
        GetExecRoot ar1

d1175 2
a1176 2
        -- C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar1(ExecRoot.Queue0.tail), ar0
d1180 1
a1180 1
        sti     ar2, *+ar1(ExecRoot.Queue0.tail)
d1187 6
a1192 2
	-- @@@@@@ Should really call dispatch here if CurrentPri > 0
	-- to get better throughput on links.
d1231 10
d1298 7
@


1.14
log
@minor fix to cope with non zero ir0
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.13 1992/12/17 11:42:16 paul Exp $
d17 3
d55 1
a55 1
-- added not of threads status when it is re-scheduled
d389 1
a389 1
        mpyi    5, R_ADDR2, R_A3                -- chan * 5 instructions
d530 1
a530 1
        stik    0, *+R_ADDR2(ExecRoot.HighestAvailPri)
d915 2
d925 1
d933 1
d941 1
d949 1
d957 1
a1009 4
--
-- Note that as IR0 (The C Address base) may be corrupt when user code is
-- interrupted, ExecRoot is assumed to be the address base. Therefore interrupt
-- handlers should not use the C40Word/CAddress Macros.
a1010 1

d1016 2
d1027 3
d1031 1
a1031 1
        stik    0, *+ar3(ExecRoot.HighestAvailPri)
a1036 1
	--	addi	ar3, ar2		-- dont assume TVTP == IR0
a1044 1
	--	addi	ar3, ar2		-- dont assume TVTP == IR0
a1054 1
		--	addi	ar3, ar0	-- dont assume TVTP == IR0
d1066 1
a1067 2
	--	addi	ar3, ar0		-- dont assume TVTP == IR0
        bZ      interrupt_return                -- null savestate (aborted xfer)
a1079 1
	--	addi	ar3, ar0		-- dont assume TVTP == IR0
d1089 4
d1098 1
d1110 1
a1111 2
	--	addi	ar3, ar0		-- dont assume TVTP == IR0
        bZ      interrupt_return                -- null savestate (aborted xfer)
a1123 1
	--	addi	ar3, ar0		-- dont assume TVTP == IR0
d1140 1
d1148 3
a1150 3
        -- If we reach here we have both a end of Rx and end of Tx interrupt
        -- we must service both now as the act of reading the control register
        -- resets the flags!
d1152 4
a1155 1
        -- ar2 = (WPTR) kernels root structure
d1157 1
a1157 1
        -- get Root->Links
a1160 1
	--	addi	ar3, ar2		-- dont assume TVTP == IR0
d1171 1
a1171 3
	addi	R_BASE, ar0
	--	addi	ar3, ar0		-- dont assume TVTP == IR0
                                                -- ar0 = (WPTR) *LinkInfo
d1177 1
a1177 1
        ldi     *+ar0(Link.TxThread), ar3       -- ar3 = BPTR to Tx SaveState
d1180 2
a1181 4
        -- point ar1 at thread Q tail for high priority threads
        GetExecRoot ar1

HandleRxSide:   -- Add SaveState (RxThread) to high priority Q
d1184 1
a1186 3
	cmpi	0, ar2
        bZ      HandleTxSide                    -- null savestate (aborted xfer)

d1190 1
d1192 2
a1193 2
        -- C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar1(ExecRoot.Queue0.tail), ar0
d1197 1
a1197 1
        sti     ar2, *+ar1(ExecRoot.Queue0.tail)
d1207 2
a1208 2
	-- ar1 = ExecRoot
	-- ar3 = BPTR to Tx SaveState
d1210 3
a1212 2
        -- C40WordAddress  ar3, ar0
        lsh	-2, ar3, ar0                    -- ar0 = WPTR to Tx SaveState
a1213 2
	cmpi	0, ar3
        bZ      TxAndRxReturn                   -- null savestate (aborted xfer)
d1219 2
a1220 2
        -- C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
        lsh	-2, *+ar1(ExecRoot.Queue0.tail), ar0
d1224 1
a1224 1
        sti     ar3, *+ar1(ExecRoot.Queue0.tail)
d1229 1
a1229 1
        sti     ar3, *+ar0(SaveState.next)
d1236 1
d1281 1
a1281 1
        mpyi    7, R_ADDR2              -- chan * 7 instructions
d1368 1
d1379 1
d1390 1
d1401 1
d1412 1
d1423 1
d1435 1
d1446 1
d1457 1
d1468 1
d1479 1
d1490 1
d1521 3
d1560 1
d1587 1
a1587 1
        stik    0, *+ar1(ExecRoot.HighestAvailPri)
d1610 1
a1610 1
        stik    0, *+ar2(ExecRoot.HighestAvailPri)
d1668 1
d1696 3
d1738 1
d1765 1
a1765 1
        stik    0, *+ar1(ExecRoot.HighestAvailPri)
d1788 1
a1788 1
        stik    0, *+ar2(ExecRoot.HighestAvailPri)
d1847 1
@


1.13
log
@added fixup for lost end of Tx DMA interrupt.
Changed DMA priority to be equal with CPU
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.12 1992/11/23 10:10:27 paul Exp $
d17 4
d1142 1
a1142 1

d1168 1
a1168 1
        ldi     *+ar0(Link.TxThread), ar3       -- ar2 = BPTR to Tx SaveState
a1174 1

d1178 2
a1179 1
	--	addi	ar1, ar0		-- dont assume TVTP == IR0
a1181 2
-- one cycle pipeline register conflict delay here! (ar0)

a1188 1
	--	addi	ar1, ar0		-- dont assume TVTP == IR0
d1202 1
d1207 1
a1207 1
	--	addi	ar1, ar0		-- dont assume TVTP == IR0
a1216 1
	--	addi	ar1, ar0		-- dont assume TVTP == IR0
@


1.12
log
@converted all link tx/rx call to take word addresses and word size arguments
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.11 1992/11/20 15:43:46 paul Exp $
d17 3
d87 2
a88 3
_test _defp 'DMAHASHIGHERPRI [
_def    'set_control            [(dcr_dmapriM | dcr_syncmodeM |
                                dcr_splitmode |
d92 3
a94 1
_def    'set_control            [(dcr_syncmodeM | dcr_splitmode |
d107 3
d141 35
d458 7
a466 2
        beq     resetboth

d507 41
a1175 1

a1205 1

a1507 1

@


1.11
log
@address base reg IR0 is now defined to be a constant, user code must
not change its value.
interrupt routines now assume that IR0 is correct
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.10 1992/11/18 14:39:49 paul Exp paul $
d17 5
d167 1
a167 1
-- size: number of bytes to send (will always be word multiple)
d169 1
a169 1
-- buf: BPTR to buffer holding data
d176 1
a176 3
	-- C40WordAddress  R_A3, R_ADDR1   -- data buffer
	lsh	-2, R_A3, R_ADDR1
	addi	R_BASE, R_ADDR1
a177 1
        lsh     -2, R_A1                -- convert to number of words
d195 1
a195 1
-- void _LinkRx(word size, Channel link, void *buf);
d201 1
a201 1
-- size: number of bytes to read (will always be word multiple)
d203 1
a203 1
-- buf: BPTR to buffer to hold the data
d209 2
a210 4
	-- C40WordAddress  R_A3, R_ADDR1
	lsh	-2, R_A3, R_ADDR1	-- data buffer
	addi	R_BASE, R_ADDR1
        lsh     -2, R_A1                -- convert to number of words
d535 1
a535 1
-- void __LinkTx(LinkInfo *link, word linkId, word size, void *buf)
d538 3
a540 1
-- a split mode DMA engine.
a552 6
        -- get WPTR to source data
        C40WordAddress R_A4

        -- convert byte to word count (guaranteed by caller to be a word multip)
        lsh     -2, R_A3

d673 1
a673 1
-- void __LinkRx(LinkInfo *link, word linkId, word size, void *buf)
d676 2
a677 1
-- a split mode DMA engine.
a685 6

        -- get WPTR to destination for data
        C40WordAddress R_A4

        -- convert byte to word count (guaranteed by caller to be a word multip)
        lsh     -2, R_A3
@


1.10
log
@fixed up interrupt handlers to stop assuming IR0 is 0, instead they assume
>> GetExecRoot (tvtp) is synonymous with the std C address base
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.9 1992/11/12 20:54:42 paul Exp $
d17 4
d943 2
a944 2
	--addi	R_BASE, ar2
	addi	ar3, ar2			-- use ExecRoot as R_BASE
d952 2
a953 2
	-- addi	R_BASE, ar2
	addi	ar3, ar2			-- use ExecRoot as R_BASE
d963 2
a964 2
		-- addi	R_BASE, ar0
		addi	ar3, ar0		-- use ExecRoot as R_BASE
d976 2
a977 2
	-- addi	R_BASE, ar0
	addi	ar3, ar0			-- Use ExecRoot as R_BASE
d990 2
a991 2
	--addi	R_BASE, ar0
	addi	ar3, ar0			-- Use ExecRoot as base
d1017 2
a1018 2
	-- addi	R_BASE, ar0
	addi	ar3, ar0			-- Use ExecRoot as base
d1031 2
a1032 2
	--addi	R_BASE, ar0
	addi	ar3, ar0			-- Use ExecRoot as R_BASE
d1065 2
a1066 2
	-- addi	R_BASE, ar2
	addi	ar3, ar2			-- Use ExecRoot as R_BASE
d1077 2
a1078 2
	-- addi	R_BASE, ar0
	addi	ar3, ar0			-- Use ExecRoot as R_BASE
d1095 2
a1096 2
	--addi	R_BASE, ar0
	addi	ar1, ar0			-- Use ExecRoot as R_BASE
d1108 2
a1109 2
	-- addi	R_BASE, ar0
	addi	ar1, ar0			-- Use ExecRoot as R_BASE
d1126 2
a1127 2
	-- addi	R_BASE, ar0
	addi	ar1, ar0			-- Use ExecRoot as R_BASE
d1137 2
a1138 2
	-- addi	R_BASE, ar0
	addi	ar1, ar0			-- Use ExecRoot as R_BASE
@


1.9
log
@made C40Word/CAddress compatible with IR0 != 0
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.8 1992/09/25 09:38:13 paul Exp $
d17 3
d913 4
d918 1
d922 1
d928 1
a928 1
        GetExecRoot ar2                 -- get hold of Executive root structure
d934 1
a934 1
        stik    0, *+ar2(ExecRoot.HighestAvailPri)
d937 4
a940 3
	-- C40WordAddress  *+ar2(ExecRoot.KernelRoot), ar2
	lsh	-2, *+ar2(ExecRoot.KernelRoot), ar2
	addi	R_BASE, ar2
d948 2
a949 1
	addi	R_BASE, ar2
d959 3
a961 1
		addi	R_BASE, ar0
d972 2
a973 1
	addi	R_BASE, ar0
d986 2
a987 1
	addi	R_BASE, ar0
d998 2
a999 1
        pop     ar2                     -- pop old state off interrupt stack
d1013 2
a1014 1
	addi	R_BASE, ar0
d1027 2
a1028 1
	addi	R_BASE, ar0
d1038 5
a1042 1
        pop     ar2                     -- pop old state off interrupt stack
d1061 2
a1062 1
	addi	R_BASE, ar2
d1073 2
a1074 1
	addi	R_BASE, ar0
a1075 1
        push    ar3                             -- get an extra reg
d1091 2
a1092 1
	addi	R_BASE, ar0
d1104 2
a1105 1
	addi	R_BASE, ar0
d1116 4
a1119 1
HandleTxSide:   -- Add SaveState (TxThread) to high priority Q
d1122 2
a1123 1
	addi	R_BASE, ar0
d1133 2
a1134 1
	addi	R_BASE, ar0
d1145 2
a1146 2
        pop     ar3                     -- pop extra off stack
        pop     ar2                     -- pop old state off interrupt stack
d1172 4
@


1.8
log
@now uses gexec.m and fixed an error in the interrupt driven link code.
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.7 1992/09/22 15:59:19 paul Exp paul $
d17 3
d163 5
a167 1
        C40WordAddress  R_A3, R_ADDR1   -- data buffer
d200 3
a202 1
        C40WordAddress  R_A3, R_ADDR1   -- data buffer
d399 3
a401 1
        C40WordAddress R_A1, R_ADDR1
d471 3
a473 1
        C40WordAddress R_A1, R_ADDR1
d540 3
a542 1
        C40WordAddress R_A1, R_ADDR1
d679 3
a681 1
        C40WordAddress R_A1, R_ADDR1
d928 3
a930 1
        C40WordAddress  *+ar2(ExecRoot.KernelRoot), ar2
d936 3
a938 1
        C40WordAddress  *+ar2(Root.Links), ar2  -- ar2 = root->Links (WPTR)
d940 1
a942 1
                and     0b111, ar0              -- clean up com port number
d946 3
a948 1
                C40WordAddress  *+ar2(0), ar0   -- ar0=(WPTR)root->links[cmprt]
d957 3
a959 1
        C40WordAddress  ar2, ar0                -- ar0 = WPTR to SaveState
d970 3
a972 1
        C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
d995 3
a997 1
        C40WordAddress  ar2, ar0                -- ar0 = WPTR to SaveState
d1008 3
a1010 1
        C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
d1037 3
a1039 1
        C40WordAddress  *+ar2(Root.Links), ar2  -- ar2 = root->Links (WPTR)
d1048 3
a1050 1
        C40WordAddress  *+ar2(0), ar0           -- ar0=(WPTR)root->links[cmprt]
d1066 3
a1068 1
        C40WordAddress  ar2, ar0                -- ar0 = WPTR to Rx SaveState
d1078 3
a1080 1
        C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
d1092 3
a1094 1
        C40WordAddress  ar3, ar0                -- ar0 = WPTR to Tx SaveState
d1102 3
a1104 1
        C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
d1445 3
a1447 1
        C40WordAddress ar2, ar4                 -- WPTR to save state
d1458 3
a1460 1
        C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
d1476 3
a1478 1
        C40WordAddress  *+ar2(ExecRoot.KernelRoot), ar3
d1483 3
a1485 1
        C40WordAddress  *+ar3(Root.Links), ar3  -- ar3 = root->Links (WPTR)
d1492 3
a1494 1
        C40WordAddress  *+ar3(0), ar0   -- ar0=(WPTR)root->links[cmprt]
d1501 3
a1503 1
        C40WordAddress  ar1, ar0                -- ar0 = WPTR to SaveState
d1513 3
a1515 1
        C40WordAddress  *+ar2(ExecRoot.Queue0.tail), ar0
d1618 3
a1620 1
        C40WordAddress ar2, ar4                 -- WPTR to save state
d1631 3
a1633 1
        C40WordAddress  *+ar1(ExecRoot.Queue0.tail), ar0
d1649 3
a1651 1
        C40WordAddress  *+ar2(ExecRoot.KernelRoot), ar3
d1656 3
a1658 1
        C40WordAddress  *+ar3(Root.Links), ar3  -- ar3 = root->Links (WPTR)
d1665 3
a1667 1
        C40WordAddress  *+ar3(0), ar0   -- ar0=(WPTR)root->links[cmprt]
d1674 4
a1677 1
        C40WordAddress  ar1, ar0                -- ar0 = WPTR to SaveState
d1687 3
a1689 1
	C40WordAddress	*+ar2(ExecRoot.Queue0.tail), ar0
@


1.7
log
@updated comment
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.6 1992/09/21 10:34:10 paul Exp paul $
d17 3
d43 1
a43 2
include basic.m
include c40exec.m
d281 1
a281 1
_test _defp 'LinkDMA [
d1082 1
a1082 1
][ -- not LinkDMA
d1086 2
d1145 1
a1145 1
        mpyi    LinkReq.sizeof, R_A2, R_A1
d1177 1
a1177 1
        mpyi    LinkReq.sizeof, R_A2, R_A1
d1346 1
a1346 1
        mpyi    LinkReq.sizeof, ar1, ar5
d1503 1
a1503 1
        mpyi    LinkReq.sizeof, ar1, ar5
@


1.6
log
@fixed problem with DMA overrun on Hema DSP1 boards, these boards are so
quick that the reset of the DMA engines is still taking place after
the next instruction, if the next instr. was loading the count reg. then
the reg is instead zeroed. Re-ordered instructions to avoid this problem.
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.5 1992/06/30 19:26:05 paul Exp $
d17 6
d850 1
a850 1
--      ExecRoot        *xroot = ExecRoot();
@


1.5
log
@remove dbg
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.4 1992/06/19 18:25:46 paul Exp $
d17 3
d544 1
a544 1
_if _defp 'writefifo [
a550 5
        -- load prim channel count register with word version of byte count
        -- must be done after a reset as reset zeros count
        sti     R_A3, *+R_ADDR2(dma_count)
]

a557 1
_test _defp 'writefifo [
d560 6
d567 3
d573 1
d681 1
a681 1
_if _defp 'readfifo [
a687 5
        -- load aux channel count register with word version of byte count
        -- must be done after a reset as reset zeros count
        sti     R_A3, *+R_ADDR2(dma_auxcount)
]

d689 1
a692 1
_test _defp 'readfifo [
d695 7
d703 2
@


1.4
log
@added not of threads status when it is re-scheduled
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.3 1992/06/15 13:42:19 paul Exp $
d17 3
a147 8
_if _defp 'SYSDEB [
	ldhi	0x0010, R_ATMP
	or	0x0070, R_ATMP
	cmpi	R_A2, R_ATMP
	beq	chanok
	int	0x66ffffff
chanok:
]
a180 8
_if _defp 'SYSDEB [
	ldhi	0x0010, R_ATMP
	or	0x0070, R_ATMP
	cmpi	R_A2, R_ATMP
	beq	chanok2
	int	0x66ffffff
chanok2:
]
a312 3
_test _defp 'SYSDEB [ -- while debugging added to intr handlers
        mpyi    6, R_ADDR2, R_A3                -- chan * 6 instructions
][
a313 1
]
a783 3
_if _defp 'SYSDEB [
	int     0x66ffffff      -- JTAGHALT
]
a792 3
_if _defp 'SYSDEB [
	int     0x66ffffff      -- JTAGHALT
]
a799 3
_if _defp 'SYSDEB [
	int     0x66ffffff      -- JTAGHALT
]
a806 3
_if _defp 'SYSDEB [
        nop     -- int  0x66ffffff      -- JTAGHALT dummy
]
a813 3
_if _defp 'SYSDEB [
	int     0x66ffffff      -- JTAGHALT
]
a820 3
_if _defp 'SYSDEB [
	int     0x66ffffff      -- JTAGHALT
]
d1329 2
a1330 1
_if _defp 'SYSDEB [ -- @@@@@@ check for spurious intr.
d1424 2
a1425 1
_if _defp 'SYSDEB [ -- @@@@@@ check for duplicate resumes
d1486 2
a1487 1
_if _defp 'SYSDEB [ -- @@@@@@ check for spurious intr.
d1583 2
a1584 1
_if _defp 'SYSDEB [ -- @@@@@@ check for duplicate resumes
@


1.3
log
@various minor fixes
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.2 1992/05/14 08:21:38 paul Exp $
d17 3
d957 1
a957 2

-- single cycle pipeline register conflict delay here! (ar1)
d991 1
a991 2

-- single cycle pipeline register conflict delay here! (ar1)
d1054 1
d1074 1
a1074 2

-- single cycle pipeline register conflict delay here! (ar0)
@


1.2
log
@pretty much near as dammit must be robust and clean now version
@
text
@d12 1
a12 1
-- RcsId: $Id: c40linkio.a,v 1.1 1992/04/21 09:54:56 paul Exp $
d17 3
d52 1
d57 5
d251 29
d576 1
a576 2
        bud     R_LR
                or      lo_goreset_control, R_A1
d579 2
a581 2
                or      lo_gohalt_control, R_A1
]
d584 3
d615 3
a617 3
                nop     -- dynamic RAM and miss the current page
                nop
                nop
d642 1
a642 1

a643 2
                or      lo_goboth_control, R_A1

d646 3
a648 1

d706 1
a706 2
        bud     R_LR
                or      lo_resetgo_control, R_A1
d709 2
a711 2
                or      lo_haltgo_control, R_A1
]
d714 3
d742 3
a744 2
                nop     -- for a minimum of 8 cycles in case we are writing to
                nop     -- dynamic RAM and miss the current page
d747 1
d771 1
a772 1
                or      lo_goboth_control, R_A1
d775 3
a1084 7

        _if _true [
                -- actually count how many dual interrupts times happen
                ldi     *+ar1(ExecRoot.DMAInts), ar2
                addi    1, ar2
                sti     ar2, *+ar1(ExecRoot.DMAInts)
        ]
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
-- RcsId: $Id$
d16 3
a18 1
-- RcsLog: $Log$
d20 1
d30 11
d49 8
a56 22
_def	'set_control			[(dcr_dmapriM | dcr_syncmodeM |
					dcr_splitmode |
					dcr_tranmode[0b01] | dcr_tcc |
					dcr_auxtranmode[0b01] | dcr_auxtcc)]

_test _true [
-- start primary channel + reset aux
_def	'set_prim_control		[(set_control | dcr_start[0b11] |
					dcr_auxstart[0b00])]

-- start auxiliary channel + reset pri
_def	'set_aux_control		[(set_control | dcr_auxstart[0b11] |
					dcr_start[0b00])]
][
-- start primary channel + stop on aux
_def	'set_prim_control		[(set_control | dcr_start[0b11] |
					dcr_auxstart[0b10])]

-- start auxiliary channel + stop on pri
_def	'set_aux_control		[(set_control | dcr_auxstart[0b11] |
					dcr_start[0b10])]
]
d59 2
a60 42
_def	'set_both_control		[(set_control | dcr_start[0b11] |
					dcr_auxstart[0b11])]

-- halt immediately after current read/write
_def	'set_halt_control		[(set_control | dcr_start[0b01] |
					dcr_auxstart[0b01])]

_test _false [
-- reset primary channel and halt auxiliary
_def	'set_resetprim_control		[(set_control | dcr_start[0b00] |
					dcr_auxstart[0b10])]

-- reset auxiliary channel and halt primary 
_def	'set_resetaux_control		[(set_control | dcr_start[0b10] |
					dcr_auxstart[0b00])]
][
-- reset primary channel and halt auxiliary
_def	'set_resetprim_control		[(set_control | dcr_start[0b00] |
					dcr_auxstart[0b01])]

-- reset auxiliary channel and halt primary 
_def	'set_resetaux_control		[(set_control | dcr_start[0b01] |
					dcr_auxstart[0b00])]
]
-- reset both halt and primary and auxiliary channel
_def	'set_resetboth_control		[(set_control | dcr_start[0b00] |
					dcr_auxstart[0b00])]

_def	'hi_set_prim_control		[(set_prim_control >> 16)]
_def	'lo_set_prim_control		[(set_prim_control & 0xffff)]
_def	'hi_set_aux_control		[(set_aux_control >> 16)]
_def	'lo_set_aux_control		[(set_aux_control & 0xffff)]
_def	'hi_set_both_control		[(set_both_control >> 16)]
_def	'lo_set_both_control		[(set_both_control & 0xffff)]
_def	'hi_set_halt_control		[(set_halt_control >> 16)]
_def	'lo_set_halt_control		[(set_halt_control & 0xffff)]
_def	'hi_set_resetprim_control	[(set_resetprim_control >> 16)]
_def	'lo_set_resetprim_control	[(set_resetprim_control & 0xffff)]
_def	'hi_set_resetaux_control	[(set_resetaux_control >> 16)]
_def	'lo_set_resetaux_control	[(set_resetaux_control & 0xffff)]
_def	'hi_set_resetboth_control	[(set_resetboth_control >> 16)]
_def	'lo_set_resetboth_control	[(set_resetboth_control & 0xffff)]
d62 3
d67 3
a69 10
-- void InitLinkDMA(word DMAEng)
--
-- Sets up link and DMA engine for channel x. The same numbered link and DMA
-- engine must be used together in order to syncronise their acivities with the
-- ICRDY/OCRDY signals. The DMA engine is set up for split mode use, the
-- Primary channel being used for Tx and the Aux channel for Rx. Other Items
-- that remain static such as the index and interrupt handler are initialised
-- at this point.
--
-- Called from C so must be PCS conformant.
a70 3
.InitLinkDMA:
	-- move DMA control reg to address reg for indirection
	ldi	R_A1, R_ADDR1
d72 3
a74 16
	-- Set up DMA control registers
	-- reset DMA engine
_test _defp 'C40STIKBUG [
	ldi	0, R_TMP1
	sti	R_TMP1, *+R_ADDR1(dma_control)

	-- zero count registers
	sti	R_TMP1, *+R_ADDR1(dma_count)
	sti	R_TMP1, *+R_ADDR1(dma_auxcount)

	ldi	1, R_TMP1
	-- indexes is always 1
	sti	R_TMP1, *+R_ADDR1(dma_srcindex)
	sti	R_TMP1, *+R_ADDR1(dma_dstindex)
][
	stik	0, *+R_ADDR1(dma_control)
a75 30
	-- zero count registers
	stik	0, *+R_ADDR1(dma_count)
	stik	0, *+R_ADDR1(dma_auxcount)

	-- indexes is always 1
	stik	1, *+R_ADDR1(dma_srcindex)
	stik	1, *+R_ADDR1(dma_dstindex)
]

	-- Setup end of DMA interrupt handler into the correct intr. vector
	-- get hold of interrupt vector base
	ldep	ivtp, R_A3
		
	-- convert cpcr WPTR to dma channel number
	lsh	-4, R_ADDR1, R_ADDR2
	and	0xf, R_ADDR2
	subi	0xa, R_ADDR2		-- R_ADDR2 == dma chan number

	-- add in interrupt vector base
	addi	R_A3, R_ADDR2, R_ADDR3	-- R_ADDR3 == (after +ivdmaint0) =
					--		DMA channel intr vector

	-- get address of this channels handler
	ldabs16 LinkDMAIntrHandler0 R_A4 -- abs addr of interrupt handler 0
_test _true [ -- while debugging added
	mpyi	6, R_ADDR2, R_A3		-- chan * 5 instructions
][
	mpyi	5, R_ADDR2, R_A3		-- chan * 5 instructions
]
	addi	R_A3, R_A4			-- index to correct handler
d77 3
a79 2
	-- store link DMA interrupt handler into interrupt vector.
	sti	R_A4, *+R_ADDR3(iv_dmaint0)
d81 3
a84 20
	-- Enable OCRDY write and ICRDY read sync in the DIE reg.
	-- This  automatically syncronises the DMA reads and writes to link
	-- write and read ready interrupt/line
	-- R_ADDR2 == DMA channel number
	cmpi	1, R_ADDR2
	bhi	hi_die

	-- Two bit die masking
	bz	chan_zero
	-- DMA channel 1
	bud	end_die_mask
		andn	0b11110000, die	-- set ICRDY/OCRDY DMA sync interrupt
		or	0b01010000, die
		nop
chan_zero:
	-- DMA channel 0
	bud	end_die_mask
		andn	0b1111, die	-- set ICRDY/OCRDY DMA sync interrupt
		or	0b0101, die
		nop
d86 3
d90 3
a92 2
	_def	'dma_diemask	[0b0011111100000000]
	_def	'dma_dieIOCRDY	[0b0000100100000000]
a93 11
hi_die:	-- Three bit die masking for channels 2-5
	ldi	dma_diemask, R_A3
	subi	2, R_ADDR2, R_A4	-- convert DMA channel to shift for mask
	mpyi	6, R_A4			-- (chan - 2) * 6 = shift amount
	lsh	R_A4, R_A3		-- shift mask
	andn	R_A3, die		-- mask out old DMA channel intr enable

	ldi	dma_dieIOCRDY, R_A3
	lsh	R_A4, R_A3
	or	R_A3, die		-- set new DMA chan. intr enable I/OCRDY
end_die_mask:
d95 6
d102 4
a105 3
	-- Enable the end of DMA interupts in IIE
	-- These interrupts signal the link DMA interrupt handler to resume the
	-- thread that requested the LinkTx/Rx when the DMA transfer completes.
d107 4
a110 1
	_def	'edmaint0	[0b0000001000000000]
d112 4
a115 2
	bud	R_LR
		ldhi	edmaint0, R_A3
a116 2
		lsh	R_ADDR2, R_A3	-- shift to set end of DMA intr
		or	R_A3, iie	-- for this DMA channel
d128 1
a128 1
-- buf:	BPTR to buffer holding data
d133 18
a150 10
	addi	2, R_A2, R_ATMP		-- link tx addr
	C40WordAddress	R_A3, R_ADDR1	-- data buffer
	lsh	-2, R_A1		-- convert to number of words
	subi	2, R_A1			-- adjust for loop
	bn	OneWordTx

	ldi	*R_ADDR1++, R_A2
	rpts R_A1
		sti	R_A2, *R_ATMP || ldi *R_ADDR1++, R_A2
	sti	R_A2, *R_ATMP
d152 1
a152 1
	bu	R_LR
d155 4
a158 4
	bud	R_LR
		ldi	*R_ADDR1++, R_A2
		sti	R_A2, *R_ATMP
		nop
d169 1
a169 1
-- buf:	BPTR to buffer to hold the data
d174 19
a192 11
	addi	1, R_A2, R_ATMP		-- link rx addr
	C40WordAddress	R_A3, R_ADDR1	-- data buffer
	lsh	-2, R_A1		-- convert to number of words

	subi	2, R_A1			-- adjust for loop
	bn	OneWordRx

	ldi	*R_ATMP, R_A2
	rpts R_A1
		sti	R_A2, *R_ADDR1++ || ldi	*R_ATMP, R_A2
	sti	R_A2, *R_ADDR1++
d194 1
a194 1
	bu	R_LR
d197 4
a200 4
	bud	R_LR
		ldi	*R_ATMP, R_A2
		sti	R_A2, *R_ADDR1++
		nop
d214 7
a220 11
	ldi	R_A1, R_ATMP
	bud	R_LR
_test _true [ -- @@@@@@ Correct!
		lsh	-7, *+R_ATMP(0), R_A1	-- shift and mask to get byte
		and	0b11100, R_A1		-- result from word quantified
						-- bit field
][
		lsh	-7, *+R_ATMP(0), R_A1	-- shift and mask to get byte
		and	0b111100, R_A1		-- result from word quantified
						-- bit field
]
d233 54
a286 6
	ldi	R_A1, R_ATMP
	bud	R_LR
		lsh	-3, *+R_ATMP(0), R_A1
_test _true [ -- @@@@@@ Correct!
		and	0b11100, R_A1		-- mask byte size
		subri	28, R_A1		-- 28 - bytes used = bytes unused
d288 1
a288 2
		and	0b111100, R_A1		-- mask byte size
		subri	60, R_A1		-- 60 - bytes used = bytes unused
d290 47
d338 2
d341 5
d354 12
a365 2
	-- get word address of link info
	C40WordAddress R_A1, R_ADDR1
d367 3
a369 2
	-- shift comms port to ctrl reg field
	lsh	15, R_A2, R_A4
d371 2
a372 2
	-- get WPTR to DMA control reg for this link.
	ldi	*+R_ADDR1(Link.DMAEng), R_ADDR2
d374 9
a382 29
	-- check to see if the other channel is transmitting
	cmpi	0, *+R_ADDR1(Link.RxThread)
	beq	resetboth

	-- If the Rx channel is still operating, we must take care not to
	-- simply overwrite its channel start value and either stop or restart
	-- it at the wrong time.

	ldhi	hi_set_resetprim_control, R_A1
	or	lo_set_resetprim_control, R_A1

	-- this Halts all DMA transfers on either read or write boundary
	-- and resets the auxiliary channel
	sti	R_A1, *+R_ADDR2(dma_control)

_test _false [
	-- This involves reading control reg - so may reset interrupt flags!
HaltRx_wait:
	ldi	*+R_ADDR2(dma_control), R_A2
	lsh	-auxstatusB, R_A2
	and	0b11, R_A2
	bz	HaltedRx
	cmp	0b01, R_A2
	bne	HaltRx_wait	-- loop until Tx side halted
][
		nop	-- Give time for last transfer to complete
		nop	-- before the halt takes effect. This should be
		nop	-- for a minimum of 8 cycles in case we are writing to
		nop	-- dynamic RAM and miss the current page
d384 1
a387 1
]
d389 1
a389 1
	-- Rx side has now been halted and Tx side reset
d391 8
a398 3
	-- see if the Rx side had just completed anyway
	ldi	*+R_ADDR2(dma_auxcount), R_A2
	bz	R_LR		-- yes Tx has completed
d400 2
a401 7
	-- no so re-start Rx channel
	ldhi	hi_set_aux_control, R_A1
	bud	R_LR
		or	lo_set_aux_control, R_A1

		-- insert comms port into its control reg field
		or	R_A4, R_A1
d403 2
a404 2
		-- this re-starts the Rx DMA transfer
		sti	R_A1, *+R_ADDR2(dma_control)
d408 3
a410 3
	bud	R_LR
		ldhi	hi_set_resetboth_control, R_A1
		or	lo_set_resetboth_control, R_A1
d412 2
a413 2
		-- Resets both the primary and auxiliary channel
		sti	R_A1, *+R_ADDR2(dma_control)
d424 12
a435 2
	-- get word address of link info
	C40WordAddress R_A1, R_ADDR1
d437 3
a439 2
	-- shift comms port to ctrl reg field
	lsh	15, R_A2,  R_A4
d441 2
a442 2
	-- get WPTR to DMA control reg for this link.
	ldi	*+R_ADDR1(Link.DMAEng), R_ADDR2
d444 10
a453 29
	-- check to see if the other channel is transmitting
	cmpi	0, *+R_ADDR1(Link.TxThread)
	beq	resetboth

	-- If the Tx channel is still operating, we must take care not to
	-- simply overwrite its channel start value and either stop or restart
	-- it at the wrong time.

	ldhi	hi_set_resetaux_control, R_A1
	or	lo_set_resetaux_control, R_A1

	-- this Halts all DMA transfers on either read or write boundary
	-- and resets the auxiliary channel
	sti	R_A1, *+R_ADDR2(dma_control)

_test _false [
	-- This involves reading control reg - so may reset interrupt flags!
HaltTx_wait:
	ldi	*+R_ADDR2(dma_control), R_A2
	lsh	-statusB, R_A2
	and	0b11, R_A2
	bz	HaltedTx
	cmp	0b01, R_A2
	bne	HaltTx_wait	-- loop until Tx side halted
][
		nop	-- Give time for last transfer to complete
		nop	-- before the halt takes effect. This should be
		nop	-- for a minimum of 8 cycles in case we are writing to
		nop	-- dynamic RAM and miss the current page
d455 1
d459 1
a459 1
]
d461 1
a461 1
	-- Tx side has now been halted and Rx side reset
d463 8
a470 8
	-- see if the Tx side had just completed anyway
	ldi	*+R_ADDR2(dma_count), R_A2
	bz	R_LR		-- yes Tx has completed

	-- no so re-start Tx channel
	ldhi	hi_set_prim_control, R_A1
	bud	R_LR
		or	lo_set_prim_control, R_A1
d472 2
a473 2
		-- insert comms port into its control reg field
		or	R_A4, R_A1
d475 2
a476 2
		-- this re-starts the Tx DMA transfer
		sti	R_A1, *+R_ADDR2(dma_control)
a479 1
_test _not _defp 'ALLOCDMA [
d491 2
a492 2
	-- get word address of link info
	C40WordAddress R_A1, R_ADDR1
d494 2
a495 2
	-- get WPTR to source data
	C40WordAddress R_A4
d497 2
a498 2
	-- convert byte to word count (guaranteed by caller to be a word multip)
	lsh	-2, R_A3
d500 2
a501 19
	-- get WPTR to DMA control reg for this link.
	ldi	*+R_ADDR1(Link.DMAEng), R_ADDR2

	-- shift comms port to ctrl reg field
	lsh	15, R_A2

	-- store word pointer to source data into DMA source address reg
	sti	R_A4, *+R_ADDR2(dma_srcaddr)

_test _true [	-- two ways of determining if DMA has completed:
		-- Thread says interrupt not serviced yet, but DMA may
		-- have completed, count == 0 says DMA has completed.
		-- Q: Will reset stop interrupt being raised if it hits just
		-- at the wrong point with count == 0?
	cmpi	0, *+R_ADDR2(dma_auxcount)	-- if other split channel
][
	cmpi	0, *+R_ADDR1(Link.RxThread)	-- if other split channel
]
	bne	CarefulTxStart			-- is operating take care
d503 2
a504 5
SimpleTxStart:
	-- neither split channel is operating if we reach this point
_test _false [
	ldhi	hi_set_resetboth_control, R_A1
	or	lo_set_resetboth_control, R_A1
d506 4
a509 2
	-- insert comms port into control reg values
	or	R_A2, R_A1
d511 2
a512 20
	sti	R_A1, *+R_ADDR2(dma_control)
][
	_test _defp 'C40STIKBUG [
		-- reset both channels
		ldi	0, R_A1
		sti	R_A1, *+R_ADDR2(dma_control)
	][
		-- reset both channels
		stik	0, *+R_ADDR2(dma_control)
	]
]

	-- reset zeros count reg, so we must load it this point
	-- load primary channel count register with word version of byte count
	sti	R_A3, *+R_ADDR2(dma_count)

	-- load std values to set in DMA control reg
	-- this value includes primary channel transfer initialisation
	-- and reset for the aux chan
	ldhi	hi_set_prim_control, R_A1
d514 2
a515 2
	bud	R_LR
		or	lo_set_prim_control, R_A1
d517 11
a527 2
		-- insert comms port into control reg values
		or	R_A2, R_A1
d529 2
a530 3
		-- store Tx attributes in control reg
		-- THIS STARTS THE DMA TRANSFER
		sti	R_A1, *+R_ADDR2(dma_control)
d532 18
d552 7
a558 95
	-- Rx channel is operating, so we must take care not to simply overwrite
	-- its channel start value and either stop or restart it at the
	-- wrong time.
	ldhi	hi_set_resetprim_control, R_A1
	or	lo_set_resetprim_control, R_A1

	-- this Halts all DMA transfers on either read or write boundary
	sti	R_A1, *+R_ADDR2(dma_control)

	_test _false [ 			-- reads control reg and may therefore
					-- reset interrupt flags
	haltRx_wait:
		ldi	*+R_ADDR2(dma_control), R_A3
		-- @@@@@@ if we do use this, remeber to check the interrupt flags.
		lsh	-aux_statusB, R_A3
		and	0b11, R_A3
		bz	haltedRx
		cmp	0b01, R_A3
		bne	haltRx_wait	-- loop until Rx side halted
	][
		nop	-- Give time for last transfer to complete
		nop	-- before the halt takes effect. This should be
		nop	-- for a minimum of 9 cycles in case we are writing to
		nop	-- dynamic RAM and miss the current page
		nop
		nop
		nop
		nop
	]

	-- Reset also resets the count, so we must reinstate it.
	-- load primary channel count register with word version of byte count
	sti	R_A3, *+R_ADDR2(dma_count)

	-- Rx side has now been halted
haltedRx:
	-- see if the Rx side had just completed anyway
	ldi	*+R_ADDR2(dma_auxcount), R_A3
	bz	SimpleTxStart	-- yes Rx has completed - so just start Tx

	-- no start Tx and re-start Rx

	-- load std values to set in DMA control reg
	-- this value includes primary channel transfer initialisation
	-- and auxilary channel transfer re-start
	ldhi	hi_set_both_control, R_A1
	bud	R_LR
		or	lo_set_both_control, R_A1

		-- insert comms port into its control reg field
		or	R_A2, R_A1

		-- this starts the Tx and restarts the Rx DMA transfer
		sti	R_A1, *+R_ADDR2(dma_control)



-- void __LinkRx(LinkInfo *link, word linkId, word size, void *buf)
--
-- Sets up and starts a DMA transfer from a link using the auxilary channel of
-- a split mode DMA engine.
--
-- Called from C so must be PCS conformant

.__LinkRx:
_if _true [
	cmpi	0, R_A3
	bnz	okok
	int	0x66ffffff -- JTAGHalt
okok:
]
	-- get word address of link info
	C40WordAddress R_A1, R_ADDR1

	-- get WPTR to destination for data
	C40WordAddress R_A4

	-- convert byte to word count (guaranteed by caller to be a word multip)
	lsh	-2, R_A3

	-- get WPTR to DMA control reg for this link.
	ldi	*+R_ADDR1(Link.DMAEng), R_ADDR2

	-- shift comms port to ctrl reg field
	lsh	15, R_A2

	-- store word pointer to destination for  data into DMA reg
	sti	R_A4, *+R_ADDR2(dma_dstaddr)

_test _true [	-- two ways of determining if DMA has completed:
		-- Thread says interrupt not serviced yet, but DMA may
		-- have completed, count == 0 says DMA has completed.
		-- Q: Will reset stop interrupt being raised if it hits just
		-- at the wrong point with count == 0?
	cmpi	0, *+R_ADDR2(dma_count)		-- if other split channel
d560 2
a561 1
	cmpi	0, *+R_ADDR1(Link.TxThread)	-- if other split channel
d563 19
a581 1
	bne	CarefulRxStart			-- is operating take care
d583 2
a584 114
	-- load primary channel count register with word version of byte count
	sti	R_A3, *+R_ADDR2(dma_auxcount)

SimpleRxStart:
	-- neither split channel is operating if we reach this point
_test _false [
		ldhi	hi_set_resetboth_control, R_A1
		or	lo_set_resetboth_control, R_A1

		-- insert comms port into control reg values
		or	R_A2, R_A1

		-- reset both channels
		sti	R_A1, *+R_ADDR2(dma_control)
][
	_test _defp 'C40STIKBUG [
		-- reset both channels
		ldi	0, R_A1
		sti	R_A1, *+R_ADDR2(dma_control)
	][
		-- reset both channels
		stik	0, *+R_ADDR2(dma_control)
	]
]

	-- load primary channel count register with word version of byte count
	sti	R_A3, *+R_ADDR2(dma_auxcount)

	-- load std values to set in DMA control reg
	-- this value includes auxiliary channel transfer initialisation
	-- and primary channel reset.
	ldhi	hi_set_aux_control, R_A1
	bud	R_LR
		or	lo_set_aux_control, R_A1

		-- insert comms port into control reg values
		or	R_A2, R_A1

		-- store Rx attributes in control reg
		-- THIS STARTS THE DMA TRANSFER
		sti	R_A1, *+R_ADDR2(dma_control)


CarefulRxStart:
	-- Tx channel is operating, so we must take care not to simply overwrite
	-- its channel start value and either stop or restart it at the
	-- wrong time.

	-- reset aux (rx) and halt primary (tx)
	ldhi	hi_set_resetaux_control, R_A1
	or	lo_set_resetaux_control, R_A1

	-- this Halts all DMA transfers on either read or write boundary
	sti	R_A1, *+R_ADDR2(dma_control)

	_test _false [ 			-- reads control reg and may therefore
					-- reset interrupt flags
	haltTx_wait:
		ldi	*+R_ADDR2(dma_control), R_A3
		lsh	-statusB, R_A3
		and	0b11, R_A3
		bz	haltedTx
		cmp	0b01, R_A3
		bne	haltTx_wait	-- loop until Rx side halted
	][
		nop	-- Give time for last transfer to complete
		nop	-- before the halt takes effect. This should be
		nop	-- for a minimum of 8 cycles in case we are writing to
		nop	-- dynamic RAM and miss the current page
		nop
		nop
		nop
		nop
	]

	-- Reset also resets the count, so we must reinstate it.
	-- load primary channel count register with word version of byte count
	sti	R_A3, *+R_ADDR2(dma_auxcount)

	-- Rx side has now been halted
haltedTx:
	-- see if the Tx side had just completed anyway
	ldi	*+R_ADDR2(dma_count), R_A3
	bz	SimpleRxStart	-- yes Tx has completed - so just start Rx

	-- no so start Rx and re-start Tx

	-- load std values to set in DMA control reg
	-- this value includes primary channel transfer initialisation
	-- and auxilary channel transfer re-start
	ldhi	hi_set_both_control, R_A1
_test _true [
		or	lo_set_both_control, R_A1

		-- insert comms port into its control reg field
		or	R_A2, R_A1

		ldi	*+R_ADDR2(dma_control), R_A2 --dbg

		-- this starts the Rx and restarts the paused Tx DMA transfer
		sti	R_A1, *+R_ADDR2(dma_control)
	nop
	nop
	nop
	nop
	bu	R_LR


][
	bud	R_LR
		or	lo_set_both_control, R_A1

		-- insert comms port into its control reg field
		or	R_A2, R_A1
d586 4
a589 2
		-- this starts the Rx and restarts the paused Tx DMA transfer
		sti	R_A1, *+R_ADDR2(dma_control)
a590 17
][

-- *** NOW DEFUNCT ALLOCATED DMA LINK TX CODE ***
-- THIS HAD TO SET ALL POSSIBLE PARAMETERS ALWAYS AS PREVIOUS USERS MAY HAVE
-- CHANGED THEM. THIS CODE IS NOT SAFE FOR INDIVIDUAL USE OF THE SPLIT CHANNELS
-- AS IT CAN POSSIBLY OVERWRITE A STOP VALUE WITH THE OLD START VALUE WHEN THE
-- NEW CONTROL REG VALUE IS MASKED IN - SEE COMMENTS AT END OF FN
-- THE MAIN REASON FOR NOT USING THIS CODE IS DUE TO THE REQUIREMENT THAT
-- THE SAME NUMBERD LINK/DMA ENGINES MUST BE USED WITH EACH OTHER IF YOU WISH
-- TO SYNCRONISE THEIR ACIVITIES - ARG!
--
-- void LinkDMATx(word DMAEng, word comport, word size, void *buf)
--
-- Sets up and starts a DMA transfer to a link using the primary channel of
-- a split mode DMA engine.
--
-- Called from C so must be PCS conformant
d592 3
d596 1
a596 82
_def	'mask_prim	[dcr_tranmodeM]
_def	'mask_aux	[dcr_auxtranmodeM]
_def	'mask_both	[dcr_comportM]

_def	'set_both	[(dcr_dmapriM | dcr_syncmodeM | dcr_splitmode)]
_def	'set_prim	[(dcr_tranmode[0b01] | dcr_startM | dcr_tcc)]
_def	'set_aux	[(dcr_auxtranmode[0b01] | dcr_auxstartM | dcr_auxtcc)]

_def	'hi_mask_prim	[((mask_prim | mask_both) >> 16)]
_def	'lo_mask_prim	[((mask_prim | mask_both) & 0xffff)]
_def	'hi_set_prim	[((set_prim | set_both) >> 16)]
_def	'lo_set_prim	[((set_prim | set_both) & 0xffff)]

_def	'hi_mask_aux	[((mask_aux | mask_both) >> 16)]
_def	'lo_mask_aux	[((mask_aux |mask_both) & 0xffff)]
_def	'hi_set_aux	[((set_aux | set_both) >> 16)]
_def	'lo_set_aux	[((set_aux | set_both) & 0xffff)]


.LinkDMATx:
	-- move DMA control reg to address reg for indirection
	ldi	R_A1, R_ADDR1

	-- load primary channel count register with word version of byte count
	lsh	-2, R_A3	
	sti	R_A3, *+R_ADDR1(dma_count)

	-- load word pointer converted from byte pointer into source reg
	C40WordAddress R_A4
	sti	R_A4, *+R_ADDR1(dma_srcaddr)

	-- index is always 1
	_test _defp 'C40STIKBUG [
		ldi	1, R_A3
		sti	R_A3, *+R_ADDR1(dma_srcindex)
	][
		stik	1, *+R_ADDR1(dma_srcindex)
	]

	-- setup end of DMA interrupt handler into the correct intr. vector
	-- @@@@@@ can any of this be pre-computed?

	-- get hold of interrupt vector base
	ldep	ivtp, R_A3
		
	-- convert cpcr WPTR to dma channel number
	lsh	-4, R_ADDR1, R_ADDR2
	and	0xf, R_ADDR2
	subi	0xa, R_ADDR2		-- R_ADDR2 == dma chan number

	-- add in interrupt vector base
	addi	R_A3, R_ADDR2, R_ADDR3	-- R_ADDR3 == (after +ivdmaint0) =
					--		DMA channel intr vector

	-- get address of this channels handler
	ldabs16 LinkDMAIntrHandler0 R_A4 -- abs addr of interrupt handler 0
	mpyi	5, R_ADDR2, R_A3		-- chan * 5 instructions
	addi	R_A3, R_A4			-- index to correct handler

	-- store link DMA interrupt handler into interrupt vector.
	sti	R_A4, *+R_ADDR3(iv_dmaint0)


	-- Enable OCRDY write sync in DIE reg. This  automatically
	-- syncronises the DMA writes to link read ready interrupts
	-- R_ADDR2 == DMA channel number
	cmpi	1, R_ADDR2
	bhi	hi_die

	-- Two bit die masking
	bz	chan_zero
	-- DMA channel 1
	bud	end_die_mask
		andn	0b110000, die	-- set OCRDY DMA sync interrupt
		or	0b010000, die
		nop
chan_zero:
	-- DMA channel 0
	bud	end_die_mask
		andn	0b11, die	-- set OCRDY DMA sync interrupt
		or	1, die
		nop
d598 4
a601 2
	_def	'dma2_readmask	[0b0000011100000000]
	_def	'dma2_OCRDY	[0b0000000100000000]
d603 2
a604 11
hi_die:	-- Three bit die masking for channels 2-5
	ldi	dma2_readmask, R_A3
	subi	2, R_ADDR2, R_A4	-- convert DMA channel to shift for mask
	mpyi	6, R_A4			-- (chan - 2) * 6 = shift amount
	lsh	R_A4, R_A3		-- shift mask
	andn	R_A3, die		-- mask out old DMA channel intr enable

	ldi	dma2_OCRDY, R_A3
	lsh	R_A4, R_A3
	or	R_A3, die		-- set new DMA channel intr enable OCRDY
end_die_mask:
d606 2
d609 2
a610 3
	-- Enable the end of DMA interupts in IIE
	-- These interrupts signal the link DMA interrupt handler to resume the
	-- thread that requested the LinkTx as it will then have been completed
a611 1
	_def	'edmaint0	[0b0000001000000000]
a612 1
	ldhi	edmaint0, R_A3
d614 1
a614 36
	lsh	R_ADDR2, R_A3	-- shift to set end of DMA intr
	or	R_A3, iie	-- for this DMA channel


	-- Read in, mask and set the control register for this DMA channel

	-- shift comms port to ctrl reg field
	lsh	15, R_A2

	-- load value to mask out the primary channel parts of the control reg
	ldhi	hi_mask_prim, R_A3
	or	lo_mask_prim, R_A3

	-- load value to insert into DMA control register
	ldhi	hi_set_prim, R_A1
	or	lo_set_prim, R_A1
	-- insert comms port into control reg
	or	R_A2, R_A1

	-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	-- DANGER: The next four instructions MAY cause a aux chan start
	-- field stop value to be overwritten by an old (11) run value!
	-- Plus the read may reset the value of the auxtccint/tccint flag!
	-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	ldi	*+R_ADDR1(dma_control), R_A4
	andn	R_A3, R_A4
	or	R_A1, R_A4
	-- store Tx attributes in control reg
	-- THIS STARTS THE DMA TRANSFER
	sti	R_A4, *+R_ADDR1(dma_control)

	b	R_LR


-- void LinkDMARx(word DMAEng, word comport, word size, void *buf)
d621 3
a623 63
.LinkDMARx:
	-- move DMA control reg to address reg for indirection
	ldi	R_A1, R_ADDR1

	-- load aux channel count register with word version of byte count
	lsh	-2, R_A3	
	sti	R_A3, *+R_ADDR1(dma_auxcount)

	-- load word pointer converted from byte pointer into destination reg
	C40WordAddress R_A4
	sti	R_A4, *+R_ADDR1(dma_dstaddr)

	-- index is always 1
	_test _defp 'C40STIKBUG [
		ldi	1, R_A3
		sti	R_A3, *+R_ADDR1(dma_dstindex)
	][
		stik	1, *+R_ADDR1(dma_dstindex)
	]

	-- setup end of DMA interrupt handler into the correct intr. vector
	-- @@@@@@ can any of this be pre-computed?

	-- get hold of interrupt vector base
	ldep	ivtp, R_A3

	-- convert cpcr WPTR to dma channel number
	lsh	-4, R_ADDR1, R_ADDR2
	and	0xf, R_ADDR2
	subi	0xa, R_ADDR2		-- R_ADDR2 == dma chan number

	-- add in interrupt vector base
	addi	R_A3, R_ADDR2, R_ADDR3	-- R_ADDR3 == (after +ivdmaint0) =
					--		DMA channel intr vector

	-- get address of this channels handler
	ldabs16 LinkDMAIntrHandler0 R_A4 -- abs addr of interrupt handler 0
	mpyi	5, R_ADDR2, R_A3		-- chan * 5 instructions
	addi	R_A3, R_A4			-- index to correct handler

	-- store link DMA interrupt handler into interrupt vector.
	sti	R_A4, *+R_ADDR3(iv_dmaint0)


	-- Enable ICRDY write sync in DIE reg. This  automatically
	-- syncronises the link read ready iterrupts to DMA writes
	-- R_ADDR2 == DMA channel number
	cmpi	1, R_ADDR2
	bhi	hi_dieRx

	-- Two bit die masking
	bz	chan_zeroRx
	-- DMA channel 1
	bud	end_die_maskRx
		andn	0b110000, die	-- set ICRDY DMA sync interrupt
		or	0b010000, die
		nop
chan_zeroRx:
	-- DMA channel 0
	bud	end_die_maskRx
		andn	0b11, die	-- set ICRDY DMA sync interrupt
		or	1, die
		nop
d625 2
a626 2
	_def	'dma2_writemask	[0b0011100000000000]
	_def	'dma2_ICRDY	[0b0000100000000000]
d628 2
a629 6
hi_dieRx:	-- Three bit die masking for channels 2-5
	ldi	dma2_writemask, R_A3
	subi	2, R_ADDR2, R_A4	-- convert DMA channel to shift for mask
	mpyi	6, R_A4			-- (chan - 2) * 6 = shift amount
	lsh	R_A4, R_A3		-- shift the mask
	andn	R_A3, die		-- mask out old DMA channel intr enable
d631 2
a632 4
	ldi	dma2_ICRDY, R_A3
	lsh	R_A4, R_A3
	or	R_A3, die		-- set new DMA channel intr enable ICRDY
end_die_maskRx:
d634 2
d637 4
a640 3
	-- Enable the end of DMA interupts in IIE
	-- These interrupts signal the link DMA interrupt handler to resume the
	-- thread that requested the LinkRx as it will then have been completed
d642 2
a643 1
	ldhi	edmaint0, R_A3
d645 2
a646 2
	lsh	R_ADDR2, R_A3	-- shift to set end of DMA intr
	or	R_A3, iie	-- for this DMA channel
d648 11
d660 18
a677 1
	-- Read in, mask and set the control register for this DMA channel
a678 2
	-- shift comms port to ctrl reg field
	lsh	15, R_A2
d680 27
a706 3
	-- load value to mask out the primary channel parts of the control reg
	ldhi	hi_mask_aux, R_A3
	or	lo_mask_aux, R_A3
d708 2
a709 5
	-- load value to insert into DMA control register
	ldhi	hi_set_aux, R_A1
	or	lo_set_aux, R_A1
	-- insert comms port into control reg
	or	R_A2, R_A1
d711 5
a715 5
	-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	-- DANGER: The next four instructions MAY cause a aux chan start
	-- field stop value to be overwritten by an old (11) run value!
	-- Plus the read may reset the value of the auxtccint/tccint flag!
	-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
d717 16
a732 6
	ldi	*+R_ADDR1(dma_control), R_A4
	andn	R_A3, R_A4
	or	R_A1, R_A4
	-- store Tx attributes in control reg
	-- THIS STARTS THE DMA TRANSFER
	sti	R_A4, *+R_ADDR1(dma_control)
a733 2
	b	R_LR
]
d751 9
a759 7
int	0x66ffffff	-- JTAGHALT
	-- interrupt vectored to this point 
	push	ST				-- MUST save ST here
	bud	GenEDMAHandler
		push	ar0			-- save reg we're about to trash
		ldhi	0x10, ar0		-- get address of this DMA
		or	dma0_control, ar0	-- channels control register
d763 8
a770 6
int	0x66ffffff	-- JTAGHALT
	push	ST
	bud	GenEDMAHandler
		push	ar0
		ldhi	0x10, ar0
		or	dma1_control, ar0
d773 8
a780 6
int	0x66ffffff	-- JTAGHALT
	push	ST
	bud	GenEDMAHandler
		push	ar0
		ldhi	0x10, ar0
		or	dma2_control, ar0
d783 8
a790 6
	nop	-- int	0x66ffffff	-- JTAGHALT dummy
	push	ST
	bud	GenEDMAHandler
		push	ar0
		ldhi	0x10, ar0
		or	dma3_control,ar0
d793 8
a800 6
int	0x66ffffff	-- JTAGHALT
	push	ST
	bud	GenEDMAHandler
		push	ar0
		ldhi	0x10, ar0
		or	dma4_control, ar0
d803 7
a809 5
int	0x66ffffff	-- JTAGHALT
	push	ST
	push	ar0
	ldhi	0x10, ar0
	or	dma5_control, ar0
d818 2
a819 2
--	ExecRoot	*xroot = ExecRoot();
--	RootStruct	*nroot = GetRoot();
d821 2
a822 2
--	SaveState	*ss;
--	ThreadQ		*q = &xroot->Queues[0];
d824 2
a825 2
--	if (txrx == 0)
--		return;	/* spurious interrupt */
d827 2
a828 2
--	/* LinkTx/Rx is always high priority */
--	xroot->HighestAvailPri = 0;
d830 2
a831 2
--	if (txrx & 1) {
--		ss = nroot->Links[comchan]->TxThread;
d833 2
a834 2
--		if (ss != NULL) {
--			nroot->Links[comchan]->TxThread = NULL;
d836 5
a840 5
--			/* add thread to end of run Q for its priority */
--			ss->next = NULL;
--			q->tail = q->tail->next = ss;
--		}
--	}
d842 2
a843 2
--	if (txrx & 2) {
--		ss = nroot->Links[comchan]->RxThread;
d845 2
a846 2
--		if (ss == NULL)
--			return;
d848 1
a848 1
--		nroot->Links[comchan]->RxThread = NULL;
d850 4
a853 4
--		/* add thread to end of run Q for its priority */
--		ss->next = NULL;
--		q->tail = q->tail->next = ss;
--	}
d861 2
a862 2
	push	ar1			-- Save rest of registers we will use
	push	ar2
d864 3
a866 3
	ldi	*ar0, ar1		-- load arguments
	lsh	-15, ar1, ar0		-- shift comport to base of ar0
	lsh	-20, ar1		-- shift interrupt flags to base of ar1
d868 1
a868 1
	GetExecRoot ar2			-- get hold of Executive root structure
d870 2
a871 2
	and	0b11, ar1		-- ar1 = AUXTCINTFLAG | TCINTFLAG
	bz	interrupt_return	-- spurious interrupt
d873 2
a874 2
	-- set XRoot->HighestPri to HIGHPRI (LinkTx/Rx thread always high pri)
	stik	0, *+ar2(ExecRoot.HighestAvailPri)
d876 2
a877 2
	-- ar2 = (WPTR)GetRoot()
	C40WordAddress	*+ar2(ExecRoot.KernelRoot), ar2
d879 2
a880 2
	cmpi	0b11, ar1
	beq	TxANDRxInterrupt
d882 2
a883 2
	-- get Root->Links
	C40WordAddress	*+ar2(Root.Links), ar2	-- ar2 = root->Links (WPTR)
d885 5
a889 5
	tstb	0b10, ar1			-- check for an Rx interrupt 
	bnzd	RxInterrupt
		and	0b111, ar0		-- clean up com port number
		-- get Root->Links[ar0]
		addi	ar0, ar2		-- ar2=(WPTR)&root->Links[cmprt]
d891 1
a891 1
		C40WordAddress	*+ar2(0), ar0	-- ar0=(WPTR)root->links[cmprt]
d896 6
a901 6
	-- If we reach here it must be End of Tx interrupt
	-- ar0 = (WPTR) *LinkInfo
	ldi	*+ar0(Link.TxThread), ar2	-- ar2 = BPTR to SaveState
	stik	0, *+ar0(Link.TxThread)		-- link->TxThread == NULL
	C40WordAddress	ar2, ar0		-- ar0 = WPTR to SaveState
	bZ	interrupt_return		-- null savestate (aborted xfer)
d903 2
a904 2
	-- point ar1 at thread Q tail for high priority threads
	GetExecRoot ar1
d906 1
a906 1
	stik	0, *+ar0(SaveState.next)	-- SaveState->next = NULL
d910 3
a912 3
	-- Add SaveState (Rx/TxThread) to high priority Q
	-- ar0 = xroot->queue[0].tail (WPTR)
	C40WordAddress	*+ar1(ExecRoot.Queue0.tail), ar0
d914 2
a915 2
	 -- xroot->queue[0].tail = SaveState
	sti	ar2, *+ar1(ExecRoot.Queue0.tail)
d919 2
a920 2
	-- xroot->queue[0].tail->next=SaveState
	sti	ar2, *+ar0(SaveState.next)
d923 4
a926 4
	pop	ar2			-- pop old state off interrupt stack
	pop	ar1
	pop	ar0
	pop	st
d928 1
a928 1
	retiU				-- return from interrupt
d931 6
a936 6
	-- If we reach here it must be End of Rx interrupt
	-- ar0 = (WPTR) *LinkInfo
	ldi	*+ar0(Link.RxThread), ar2	-- ar2 = BPTR to SaveState
	stik	0, *+ar0(Link.RxThread)		-- link->RxThread == NULL
	C40WordAddress	ar2, ar0		-- ar0 = WPTR to SaveState
	bZ	interrupt_return		-- null savestate (aborted xfer)
d938 2
a939 2
	-- point ar1 at thread Q tail for high priority threads
	GetExecRoot ar1
d941 1
a941 1
	stik	0, *+ar0(SaveState.next)	-- SaveState->next = NULL
d945 3
a947 3
	-- Add SaveState (Rx/TxThread) to high priority Q
	-- ar0 = xroot->queue[0].tail (WPTR)
	C40WordAddress	*+ar1(ExecRoot.Queue0.tail), ar0
d949 2
a950 2
	-- xroot->queue[0].tail = SaveState
	sti	ar2, *+ar1(ExecRoot.Queue0.tail)
d954 2
a955 2
	-- xroot->queue[0].tail->next=SaveState
	sti	ar2, *+ar0(SaveState.next)
d957 4
a960 4
	pop	ar2			-- pop old state off interrupt stack
	pop	ar1
	pop	ar0
	pop	st
d962 1
a962 1
	retiU				-- return from interrupt
d967 3
a969 3
	-- If we reach here we have both a end of Rx and end of Tx interrupt
	-- we must service both now as the act of reading the control register
	-- resets the flags!
d971 1
a971 1
	-- ar2 = (WPTR) kernels root structure
d973 2
a974 2
	-- get Root->Links
	C40WordAddress	*+ar2(Root.Links), ar2	-- ar2 = root->Links (WPTR)
d976 1
a976 1
	and	0b111, ar0			-- clean up com port number
d978 2
a979 2
	-- get Root->Links[ar0]
	addi	ar0, ar2			-- ar2=(WPTR)&root->Links[cmprt]
d983 3
a985 3
	C40WordAddress	*+ar2(0), ar0		-- ar0=(WPTR)root->links[cmprt]
						-- ar0 = (WPTR) *LinkInfo
	push	ar3				-- get an extra reg
d989 4
a992 4
	ldi	*+ar0(Link.RxThread), ar2	-- ar2 = BPTR to Rx SaveState
	stik	0, *+ar0(Link.RxThread)		-- link->RxThread == NULL
	ldi	*+ar0(Link.TxThread), ar3	-- ar2 = BPTR to Tx SaveState
	stik	0, *+ar0(Link.TxThread)		-- link->TxThread == NULL
d994 2
a995 2
	-- point ar1 at thread Q tail for high priority threads
	GetExecRoot ar1
d997 1
a997 1
HandleRxSide:	-- Add SaveState (RxThread) to high priority Q
d999 1
a999 1
	C40WordAddress	ar2, ar0		-- ar0 = WPTR to Rx SaveState
d1001 1
a1001 1
	bZ	HandleTxSide			-- null savestate (aborted xfer)
d1005 22
a1026 1
	stik	0, *+ar0(SaveState.next)	-- SaveState->next = NULL
d1028 2
a1029 2
	-- ar0 = xroot->queue[0].tail (WPTR)
	C40WordAddress	*+ar1(ExecRoot.Queue0.tail), ar0
d1031 2
a1032 2
	-- xroot->queue[0].tail = SaveState
	sti	ar2, *+ar1(ExecRoot.Queue0.tail)
d1036 376
a1411 2
	-- xroot->queue[0].tail->next=SaveState
	sti	ar2, *+ar0(SaveState.next)
d1413 1
d1415 11
a1425 2
HandleTxSide:	-- Add SaveState (TxThread) to high priority Q
	C40WordAddress	ar3, ar0		-- ar0 = WPTR to Tx SaveState
d1427 3
a1429 1
	bZ	TxAndRxReturn			-- null savestate (aborted xfer)
d1431 2
a1432 1
	stik	0, *+ar0(SaveState.next)	-- SaveState->next = NULL
d1436 149
d1586 1
a1586 1
	C40WordAddress	*+ar1(ExecRoot.Queue0.tail), ar0
d1589 1
a1589 1
	sti	ar3, *+ar1(ExecRoot.Queue0.tail)
d1594 6
a1599 12
	sti	ar3, *+ar0(SaveState.next)

	_if _true [
		-- actually count how many dual interrupts times happen
		ldi	*+ar1(ExecRoot.DMAInts), ar2
		addi	1, ar2
		sti	ar2, *+ar1(ExecRoot.DMAInts)
	]

TxAndRxReturn:
	pop	ar3			-- pop extra off stack
	pop	ar2			-- pop old state off interrupt stack
d1605 34
@
