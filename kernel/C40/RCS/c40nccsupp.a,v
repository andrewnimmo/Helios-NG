head	1.32;
access;
symbols
	Helios_1_3_1:1.32
	Helios_C40_1_3_Official_Release:1.31
	Alenia_release:1.30
	C40_Field_Test_2:1.27
	C40_Field_Test_R1:1.16;
locks; strict;
comment	@-- @;


1.32
date	93.09.28.10.45.26;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	93.01.25.09.07.38;	author paul;	state Exp;
branches;
next	1.30;

1.30
date	92.12.04.17.45.44;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	92.11.12.20.54.42;	author paul;	state Exp;
branches;
next	1.28;

1.28
date	92.11.12.17.15.50;	author paul;	state Exp;
branches;
next	1.27;

1.27
date	92.09.25.09.37.18;	author paul;	state Exp;
branches;
next	1.26;

1.26
date	92.08.20.17.31.18;	author paul;	state Exp;
branches;
next	1.25;

1.25
date	92.08.18.09.55.16;	author paul;	state Exp;
branches;
next	1.24;

1.24
date	92.08.12.18.45.56;	author paul;	state Exp;
branches;
next	1.23;

1.23
date	92.08.06.12.25.14;	author paul;	state Exp;
branches;
next	1.22;

1.22
date	92.08.05.15.49.06;	author paul;	state Exp;
branches;
next	1.21;

1.21
date	92.08.05.10.32.46;	author paul;	state Exp;
branches;
next	1.20;

1.20
date	92.07.30.14.14.11;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	92.07.30.14.06.42;	author paul;	state Exp;
branches;
next	1.18;

1.18
date	92.07.21.08.10.52;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	92.07.17.15.31.03;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	92.07.01.09.09.13;	author paul;	state Exp;
branches;
next	1.15;

1.15
date	92.06.30.10.11.11;	author paul;	state Exp;
branches;
next	1.14;

1.14
date	92.06.13.14.28.16;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	92.06.12.11.12.36;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	92.06.10.13.38.15;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	92.05.20.16.59.32;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	92.05.20.08.19.02;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	92.05.19.16.35.03;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	92.04.28.08.13.37;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	92.04.27.17.15.52;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	92.04.10.16.52.49;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	92.04.10.16.38.32;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	92.04.08.09.50.29;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	92.04.08.09.48.58;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	92.04.08.09.39.46;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	92.04.08.09.36.30;	author nickc;	state Exp;
branches;
next	;


desc
@Assembler version of frequently used Clib and POSIX routines
@


1.32
log
@new improved version of C40CAddress()
@
text
@-- File:	c40nccsupp.a
-- Subsystem:	'C40 Helios executive
-- Author:	P.A.Beskeen / Nick Clifton
-- Date:	Aug '91
--
-- This file is Copyright (c) 1991, 1992 by Perihelion Software Ltd
-- All Rights Reserved
--
-- Description: `C40 Norcroft C support functions.
--
--		This file is used in conjunction with nccsupport.c
--		to provide the norcroft support functions. It also contains
--		the `C40 assembly language replacments for the C library string
--		functions that are required by the kernel - they are also
--		exported.
--
--		Implements:
--			__stack_overflow,
--			__stack_overflow1,
--			memcpy
--			memset
--			_backtrace
--			_DataToFuncConvert
--			C40WordAddress
--			_FuncToDataConvert
--			C40CAddress
--			_SetAddrBase
--			_GetAddrBase
--
--		This file should be kept up to date with respect to
--
--		/hsrc/util/C40/c40string.a
--		snake:/users/nickc/ncc/experimental/src/asm/strings.a & utils.a
--
-- RcsId: $Id: c40nccsupp.a,v 1.31 1993/01/25 09:07:38 paul Exp nickc $
--
-- (c) Copyright 1991, 1992 Perihelion Software Ltd.
--     All Rights Reserved
-- 
-- RcsLog: $Log: c40nccsupp.a,v $
-- Revision 1.31  1993/01/25  09:07:38  paul
-- increased deadmans handle to 256k in backtrace
--
-- Revision 1.30  1992/12/04  17:45:44  nickc
-- improved _backtrace to cope with missing function names, by returning module name
--
-- Revision 1.29  1992/11/12  20:54:42  paul
-- made C40Word/CAddress compatible with IR0 != 0
--
-- Revision 1.28  1992/11/12  17:15:50  paul
-- updated to support c40WordAddress and CAddress macros being converted to
-- function calls
--
-- Revision 1.27  1992/09/25  09:37:18  paul
-- changed to use gexec.m
--
-- Revision 1.26  1992/08/20  17:31:18  paul
-- added further checks as a bogus FP can make you access global mem
--
-- Revision 1.25  1992/08/18  09:55:16  paul
-- added GetAddrBase and SetAddrBase
--
-- Revision 1.24  1992/08/12  18:45:56  paul
-- fixed for C40WordAddress macro
--
-- Revision 1.23  1992/08/06  12:25:14  paul
-- fixed _backtrace for insanely large pointers
--
-- Revision 1.22  1992/08/05  15:49:06  paul
-- wierd tempory fix to get system out
--
-- Revision 1.21  1992/08/05  10:32:46  paul
-- fixed for insane frame pointers
--
-- Revision 1.20  1992/07/30  14:14:11  nickc
-- fixed more bugs
--
-- Revision 1.19  1992/07/30  14:06:42  paul
-- fixed bugs in _backtrace
--
-- Revision 1.18  1992/07/21  08:10:52  nickc
-- removed stack overflow function
--
-- Revision 1.17  1992/07/17  15:31:03  nickc
-- improved beyong recognition (honest)
--
-- Revision 1.16  1992/07/01  09:09:13  paul
-- added correct macro includes
--
-- Revision 1.15  1992/06/30  10:11:11  paul
-- cause a SIGSTAK signal on stack overflow
--
-- Revision 1.14  1992/06/13  14:28:16  nickc
-- fixed very small memcpys
--
-- Revision 1.13  1992/06/12  11:12:36  nickc
-- added _DataToFuncConvert and _FuncToDataConvert
--
-- Revision 1.12  1992/06/10  13:38:15  nickc
-- fixed bug copying non-aligned data
--
-- Revision 1.11  1992/05/20  16:59:32  nickc
-- changed to be  boolean so that pointer overruns can be detected
--
-- Revision 1.10  1992/05/20  08:19:02  nickc
-- fixed bug in _backtrace
--
-- Revision 1.9  1992/05/19  16:35:03  nickc
-- added _backtrace
--
-- Revision 1.8  1992/04/28  08:13:37  nickc
-- really fixed short word copies
--
-- Revision 1.7  1992/04/27  17:15:52  nickc
-- fixed bug in tail end of memcpy
--
-- Revision 1.6  1992/04/10  16:52:49  paul
-- fixed a small typo
--
-- Revision 1.5  1992/04/10  16:38:32  nickc
-- changed RPTS to RPTB
--
-- Revision 1.4  1992/04/08  09:50:29  nickc
-- added check for 0 length in memset
--
-- Revision 1.3  1992/04/08  09:48:58  nickc
-- fixed typo in previous delta
--
-- Revision 1.2  1992/04/08  09:39:46  nickc
-- added check for count == 0 in memcpy
--
-- Revision 1.1  1992/04/08  09:36:30  nickc
-- Initial revision
--
--

include ../gexec.m	-- Executive manifests
include c40.m
include c40mtab.m
include module.m
include root.m

-- NB/ We do not use the RPTS instruction in this code, even though it may
-- seem applicable, because it locks out interrupts, and we cannot afford
-- to loose interrupt latency in real-time applications

------------------------------------------------------------------------------
-- ncc support functions
------------------------------------------------------------------------------

_if _defp 'NEVER
[
	Function __stack_overflow

	-- Temporarily force SIGSTAK signal
	-- @@@@@@ update for automatic stack extension.
	GetStaticDataWord _Task_ R_ATMP
	ldi	R_ATMP, R_A1
	ldi	7, R_A2			-- SIGSTAK
	patchinstr (PATCHC40MASK24ADD,
		shift(-2, labelref(.CallException)),
		br	0)
]

	Function __stack_overflow_1

	-- Temporarily force SIGSTAK signal
	-- @@@@@@ update for automatic stack extension.
	GetStaticDataWord _Task_ R_ATMP
	ldi	R_ATMP, R_A1
	ldi	7, R_A2			-- SIGSTACK
	patchinstr (PATCHC40MASK24ADD,
		shift(-2, labelref(.CallException)),
		br	0)


------------------------------------------------------------------------------
-- string functions (mainly used by GetMsg()/PutMsg())
------------------------------------------------------------------------------

Function memset
--
--      void * memset( void * pointer, unsigned char val, unsigned long num_bytes );
--
-- Upon Entry:
--	R_A1	byte offset of an area of memory
--	R_A2	The value to place into the memory
--	R_A3	The number of bytes to place
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	The same byte pointer as passed in
--
-- Corrupts
--	R_A2, R_A3, R_T1, R_FT1, R_ADDR1, RC, RS, RE, ST
--
-- Purpose
--	Fills an area of memory with a specified value
--	Does NOT check for NULL pointers
--
	CMPI	 0,	  R_A3			-- Check for a count of zero
	Beq	 R_LR				-- and return if count is zero
	LSH	-2,       R_A1,     R_ADDR1	-- convert byte offset to word offset
	ADDI	 R_BASE,  R_ADDR1		-- add in base address register to our pointer
	MB1	 R_A2,    R_A2			-- copy bottom 8  bits of value into next 8 bits
	AND3	 3,       R_A1,     R_T1	-- get byte selector
	BeqD	 set.word_aligned		-- if the pointer is word aligned then shout for joy
	   LDIne	 *R_ADDR1,  R_FT1 	-- get word at start of string and advance pointer
	   MH1	 R_A2,    R_A2			-- copy bottom 16 bits of value into top 16 bits
	   CMPI	 2,       R_T1			-- check byte selector
	Beq	 set.byte_selector_2		-- if byte selector == 2
	Bgt	 set.byte_selector_3		-- if byte selector == 3
	SUBI	 1,       R_A3			-- decrement count
	Bn	 R_LR				-- nothing to do
	MB1	 R_A2,    R_FT1			-- no then merge in byte
set.byte_selector_2:
	SUBI	 1,       R_A3			-- decrement count
	Bn	 set.completed			-- have we run out ?
	MB2	 R_A2,    R_FT1			-- no, then merge in byte
set.byte_selector_3:
	SUBI	 1,       R_A3			-- decrement count
	Bn	 set.completed			-- have we run out ?
	MB3	 R_A2,    R_FT1			-- no, then merge in byte
	STI	 R_FT1,  *R_ADDR1++(1)		-- place resulting word and advance pointer
set.word_aligned:				-- pointer is now word aligned
	LSH	-2,       R_A3,     R_FT1	-- number of whole words to set
	BeqD	 set.almost_finished		-- no words left to to do
	   SUBI3 1,       R_FT1,    RC		-- load number of loops - 1
	   AND	 3,       R_A3			-- number of bytes remaining to place
	   LDHI	 0xFF00,  R_FT1			-- load mask
	RPTB	 set.block1			-- repeat next instruction
set.block1:
	STI	 R_A2,   *R_ADDR1++(1)		-- place word and advance pointer
set.almost_finished:
	BeqD	 R_LR				-- if none then return (delayed)
	   SUBI	 3,       R_A3			-- invert count
	   MPYI	 8,       R_A3			-- convert to bit selector
	   ASH	 R_A3,    R_FT1			-- adjust mask
	LDI	*R_ADDR1, R_T1			-- get word at destination
	AND	 R_FT1,   R_T1			-- mask out bytes to be set
	BuD	 R_LR				-- return (delayed)
	   ANDN	 R_FT1,   R_A2			-- mask out bytes in value word
	   OR	 R_A2,    R_T1			-- move the bytes into the destination word
	   STI	 R_T1,   *R_ADDR1		-- save word back into memory
set.completed:
	STI	 R_FT1,  *R_ADDR1		-- save result
	Bu	 R_LR				-- return 


Function memcpy
--
--      void * memcpy( void * dest, const void * source, unsigned long num_bytes );
--
-- Upon Entry:
--	R_A1	byte offset of the destination an area of memory
--	R_A2	byte offset of the source area of memory
--	R_A3	The number of bytes to copy from source to destination
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	Unchanged
--
-- Corrupts
--	R_T1, R_FT1, R_FT2, R_ADDR1, R_ADDR2, RC, RS, RE, ST
--
-- Purpose
--	Copies the contents of one area of memory to another area
--	Does NOT check for overlapping areas.
--	Does NOT check for NULL pointers
--
--	NB/ This function cannot be called _memcpy as this is an internal
--	function used by the compiler
--
	CMPI	 0,	  R_A3			-- Check for a count of zero
	Beq	 R_LR				-- and return if count is zero
	LSH3	-2,       R_A1,         R_ADDR1	-- convert dest to word offset
	XOR3	 R_A1,    R_A2,         R_T1	-- see if the two pointers are aligned
	AND	 3,       R_T1			-- but only check byte selectors
	BneD	 mcpy.not_aligned		-- if the pointers are not mutually aligned ...
	   LSH	-2,       R_A2,         R_ADDR2	-- convert source to word offset
	   ADDI	 R_BASE,  R_ADDR1		-- convert dest   to word pointer
	   ADDI	 R_BASE,  R_ADDR2		-- convert source to word pointer
	--
	-- pointers are mutually aligned
	--
	AND	 3,       R_A2			-- get byte selector
	Beq	 mcpy.word_aligned		-- pointers are word aligned
	SUBI	 3,       R_A2			-- invert byte selector (1 => -2,  2 => -1,  3 => 0)
	ADDI	 R_A2,    R_A3			-- decrement count of bytes to copy
	SUBI	 1,	  R_A3			-- decrement again
	Blt	 mcpy.very_small		-- copy with copying only fraction of word
	MPYI	 8,       R_A2			-- convert byte selector to bit selector
	LDHI	 0xFF00,  R_FT1			-- load mask
	ASH	 R_A2,    R_FT1			-- shift mask into position
	AND3	 R_FT1,  *R_ADDR2++(1), R_A2	-- mask out non-source bytes in source word
	ANDN3	 R_FT1,  *R_ADDR1,      R_T1	-- mask out source bytes in destination word
	OR	 R_A2,    R_T1			-- move source bytes into destination word
	STI	 R_T1,   *R_ADDR1++(1)		-- save word
mcpy.word_aligned:
	--
	-- the two pointers are word aligned
	--
	-- REG	CONTENTS ON ENTRY		USED AS
	--
	-- R_A1	   byte offset of destination	not changed
	-- R_A2 				word at source
	-- R_A3	   number of bytes to copy	number of bytes left to copy
	-- R_T1					bit selector
	-- R_FT1				byte mask
	-- R_TMP3				number of words to copy
	-- R_ADDR1 word pointer to destination	word pointer to destination
	-- R_ADDR2 word pointer to source	word pointer to source
	--
	LSH3	-2,       R_A3,         R_TMP3	-- get number of words to copy
	Beq	 mcpy.no_more_words		-- if none then skip next section
	LDIne	*R_ADDR2++(1),          R_A2	-- get first word
	SUBI	 2,       R_TMP3		-- decrement count to allow for words copied setting up loop
	Blt	 mcpy.only_one_word		-- if count is negative then only word need be copied
	RPTB	 mcpy.block1			-- repeat next instructions
mcpy.block1:
	 STI	 R_A2,   *R_ADDR1++(1)		-- save previous word in destination
	 || LDI	*R_ADDR2++(1),          R_A2	-- and load next word from source
mcpy.only_one_word:
	STI	 R_A2,   *R_ADDR1++(1)		-- save final full word
mcpy.no_more_words:
	AND	 3,       R_A3			-- final number of bytes to copy
	Beq	 R_LR				-- no more bytes => return 
	LDHI	 0xFF00,  R_FT1			-- load mask
	SUBI	 3,       R_A3			-- invert remaining count
	MPYI	 8,       R_A3			-- convert to bit selector
	ASH	 R_A3,    R_FT1			-- move mask into position
	AND	 R_FT1,  *R_ADDR1,      R_T1	-- extract bytes from destination
	BuD	 R_LR				-- return (delayed)
	   ANDN	 R_FT1,  *R_ADDR2,      R_A2	-- extract bytes from source
	   OR	 R_A2,    R_T1			-- move bytes from source into destination word
	   STI	 R_T1,   *R_ADDR1		-- save word
mcpy.not_aligned:
	--
	-- The pointers are not mutually aligned
	--
	-- REG     CONTENTS ON ENTRY		USED AS
	--
	-- R_A1	   - dest   byte offset		not changed
	-- R_A2	   - source byte offset		dest byte mask
	-- R_A3	   - number of bytes to copy	bytes left to copy	
	-- R_T1	   - 				source byte mask
	-- R_FT1   -				temporary word holding shifted source byte
	-- R_FT2   -				bits to shift source byte to align with destination byte
	-- R_TMP3  -				source word
	-- R_TMP1  -				dest   word
	-- R_ADDR1 - dest word pointer		dest   word pointer
	-- R_ADDR2 - source word pointer	source word pointer
	--
	AND3	 3,       R_A1,         R_T1	-- get dest   byte selector
	AND	 3,       R_A2,         R_FT1	-- get source byte selector
	SUBI3	 R_FT1,   R_T1,         R_FT2	-- calculate (byte) shift factor
	MPYI	 8,       R_FT2			-- convert byte shift to bit shift
	LDI     *R_ADDR2++(1),          R_TMP3	-- get word from source
	LDI	 0xFF,    R_A2			-- load destination mask
	MPYI	 8,       R_T1			-- convert dest byte selector into bit selector
	LSH	 R_T1,    R_A2			-- move destination mask into position
	MPYI3	 8,       R_FT1,        R_TMP1	-- convert source byte selector into bit selector
	LDI	 0xFF,    R_T1			-- load source mask
	LSH	 R_TMP1,  R_T1			-- move source mask into position
	LDI     *R_ADDR1, R_TMP1		-- get word from destination
mcpy.loop1:
	AND3	 R_T1,    R_TMP3,       R_FT1	-- get byte from source
	SUBI	 1,       R_A3			-- decrement count of bytes to copy
	BeqD	 mcpy.finished			-- if the count has reached 0 we have finished
	   LSH	 R_FT2,   R_FT1			-- move source byte into position for destination
	   ANDN	 R_A2,    R_TMP1		-- mask out byte in destination word
	   OR	 R_FT1,   R_TMP1		-- merge in byte from source word
	LSH	 8,       R_T1			-- adjust source mask to cover next byte
	Bne	 mcpy.over			-- if the mask is still present skip the next bit
	LDI     *R_ADDR2++(1),          R_TMP3	-- get a new word from the source
	BuD	 mcpy.loop1			-- we know that destination shift will not empty the mask
	   LDI	 0xFF,    R_T1			-- resetore the source mask (to cover bottom byte)
	   XOR	 0xE0,    R_FT2			-- correct the bit shift (I love this magic)
mcpy.over:
	   LSH	 8,       R_A2			-- adjust destination mask
	Bne	 mcpy.loop1			-- if it is not empty then carry on loop
	LDI	 0xFF,    R_A2			-- reset destination mask (to cover bottom byte)
	BuD	 mcpy.loop1			-- return to loop (delayed)
	   STI	 R_TMP1, *R_ADDR1++(1)		-- save destination word		
	   LDI  *R_ADDR1, R_TMP1		-- get new destination word
	   XOR	 0xE0,    R_FT2			-- correct bit shift
mcpy.finished:
	STI	 R_TMP1, *R_ADDR1		-- save the last word
	Bu	 R_LR				-- return
mcpy.very_small:
	--
	-- The pointers are mutually aligned, but only a fraction of a word is to be copied
	--
	LDHI	 0xFF00,  R_FT1			-- load bit mask
	CMPI	 R_A2,	  R_A3			-- compare byte selector (-1 or -2) with count (-1 or -2)
	LDIne	-8,	  R_T1			-- if two bytes are to be copied load 'extender' count
	LDIeq	 0,	  R_T1			-- otherwise use a zero 'extender' count
	ASH	 R_T1,	  R_FT1			-- extend bit mask if necessary
	MPYI	 8,	  R_A3			-- convert count overflow to bit selector
	LSH	 R_A3,	  R_FT1			-- move bit mask into position
	AND3	 R_FT1,  *R_ADDR2++(1), R_A2	-- mask out non-source bytes in source word
	BuD	 R_LR				-- return (delayed)
	   ANDN3 R_FT1,  *R_ADDR1,      R_T1	-- mask out source bytes in destination word
	   OR	 R_A2,    R_T1			-- move source bytes into destination word
	   STI	 R_T1,   *R_ADDR1++(1)		-- save word

--
-- end of memcpy
--

Function _backtrace
--
--	int _backtrace( int * buffer, int frame_pointer )
--
-- Upon Entry:
--      R_A1	byte offset of buffer to contain function name
--      R_A2	frame pointer of previous function
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	frame pointer of the function whoes name is in buffer or NULL
--      memory pointed to by R_A1 will have had function name copied into it  
--
-- Corrupts
--	R_ATMP, R_ADDR1, R_ADDR2, ST
--
-- Purpose
-- 	Produces a string identifying the parent function of
--	the previous function identified on the execution stack.
--	If the frame pointer to the previous function is NULL
--	then it will use the current frame pointer
--
	LDI	   R_A2,	  R_ADDR1		-- copy frame pointer to address register
	LDIeq	   R_FP,	  R_ADDR1		-- if pointer is NULL then use current frame pointer
	LSH	   -2, R_A1,	  R_ATMP		-- convert destination byte offset to word offset

	ldhi	   0x2f,	  R_ADDR2		-- sanity check on computed address
	or	   0xf800,	  R_ADDR2		-- 0x2ff800 is the start of on chip RAM
	cmpi	   R_ADDR2,       R_ADDR1		-- no address can be below this
	blo	   b_insane

	-- @@@@@@ *WARNING* the following check is very dubious:
	--	the trace vector may well stay in the local bus, but code
	--	may use the global bus in future versions of Helios-C40!
	--	GetNucRoot R_ADDR2
	-- ldi   *+R_ADDR2(Root.TraceVec), R_ADDR2
	-- C40WordAddress            R_ADDR2
	-- cmpi	   R_ADDR2,       R_ADDR1		-- sanity check on high
	-- bhi	   b_insane				-- computed address 

	LDI	  *R_ADDR1,       R_A1result		-- get hold of parent's frame pointer
	LDI	 *-R_ADDR1(1),    R_ADDR1		-- get return address to parent function

	-- cmpi	   R_ADDR2,       R_ADDR1		-- sanity check on high
	-- bhi	   b_insane				-- computed address 

	-- ldhi	   0x2f,	  R_ADDR2		-- sanity check on low
	-- or	   0xf800,	  R_ADDR2
	cmpi	   R_ADDR2,       R_ADDR1		-- computed address
	blo	   b_insane

	ldi32	   T.Module           R_TMP1		-- load module structure Type constant
--	ldi	   2048,	      R_ADDR2		-- initialise deadmans handle
--							-- can handle fns =< 8KB
	-- Can find fns and modules  upto 64K words (256k bytes) away.
	ldhi	   1,		      R_ADDR2		-- initialise deadmans handle
b_loop1:						-- drop through into loop
	 LDI	  *R_ADDR1\--(1),     R_A2		-- get word
         CMPI	   R_A2,	      R_TMP1		-- compare against module word
	 Beq	   b_got_module				-- and branch if found
	 ASH	  -24,		      R_A2		-- signed move top byte down to bottom byte
	 CMPI	  -1,		      R_A2		-- a top byte of 0xFF is illegal, and so used as marker
	DBne	   R_ADDR2,	      b_loop1		-- and loop until 0xFF found or limit exceeded
	BneD	   R_LR					-- if loop aborted then return
	   LDIne   0,		      R_A1result	-- if loop aborted return status is FAIL
	   LBU0	*++R_ADDR1(1),        R_A2		-- get hold of size of function name
	   LSH	  -2,		      R_A2		-- convert to number of words
	SUBI3      2,		      R_A2,	RC	-- set up repeat count
	BltD	   b_over				-- if we are only copying one word then skip loop
	   SUBI	   R_A2,	      R_ADDR1		-- subtract size of name from pointer
	   LDI	  *R_ADDR1++(1),      R_A2		-- load first word from source
b_copy_name:						-- back door entry to name copying code
	   ADDI	   R_BASE,	      R_ATMP		-- convert buffer address to word pointer
	RPTB	   b_loop2				-- start loop
b_loop2:
	 STI	   R_A2,             *R_ATMP++(1)	-- store word into destination
	 || LDI	  *R_ADDR1++(1),      R_A2		-- load word from source
b_over:
	STI	   R_A2,             *R_ATMP		-- store last word from destination
	Bu	   R_LR					-- return

b_got_module:						-- found a Module structure
	LDI	   8 - 1,	      RC		-- Module's name is 8 words long
	BuD	   b_copy_name				-- jump into name copying code
	  ADDI	   Module.Name + 1,   R_ADDR1		-- Adjust pointer to Name field of Module structure
	  ldi32	   0x203a6e69	      R_A2		-- string is "in: "

b_insane:
	ldi	   0,		  R_A1result		-- NULL return on error
	b	   R_LR
--
-- end of _backtrace
--


--	(void * _DataToFuncConvert)( void * pointer )()
--	word C40WordAddress(void *Cptr);
--
-- Upon Entry:
--      R_A1	byte offset to be converted
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	word function pointer
--
-- Corrupts
--	ST
--
-- Purpose
-- 	Converts a data pointer, (which is a byte offset from
--	R_BASE) into a function pointer, (which is an
--	absolute word address).
--

	Function _DataToFuncConvert
.C40WordAddress:			-- different name with different (Same)
					-- typed parameters.

	BuD	 R_LR			-- return (delayed)
	   LSH	-2,	  R_A1		-- convert to a word offset
	   ADDI	 R_BASE,  R_A1		-- add in the base address register
	   NOP				-- padding
--
-- end of _DataToFuncConvert
--


--
--	void * _FuncTodataConvert( (void * func)() )
--	void *C40CAddress(word wordptr);
--
-- Upon Entry:
--      R_A1	word pointer to be converted
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	byte offset or 0
--
-- Corrupts
--	ST
--
-- Purpose
-- 	Converts a functions pointer, (which is a absolute
--	word address) into a data pointer, (which is a
--	byte offset from R_BASE).  If the conversion
--	cannot be done then returns NULL
--

	Function _FuncToDataConvert
.C40CAddress:				-- different name with different (Same)
					-- typed parameters.

_test _defp 'NEVER
[
	CMPI	 R_BASE,	R_A1	-- check to see if func pointer < base address
	LDIlo	 R_BASE,	R_A1	-- if it is then cannot convert
	SUBI	 R_BASE,	R_A1	-- subtract base address from func pointer
	BuD	 R_LR			-- return (delayed)
	   LDIlt 0,		R_A1	-- if the top bit of the result is set then cannot convert
	   LSH	 2,		R_A1	-- shift up by 2 to convert to byte offset
	   LDIlo 0,		R_A1	-- if carry was set then conversion has failed
]
[
	SUBI	R_BASE,	R_A1
	LDHI	0xC000,	R_T1
	BuD	R_LR
	  AND	R_A1,	R_T1
	  LDIne	0,	R_A1
	  LSH	2,	R_A1
]
--
-- end of _FuncToDataConvert
--


Function _SetAddrBase
--
--	void _SetAddrBase(word addrbase)
--
-- Upon Entry:
--      R_A1	word containing word address to set IR0 (C address base reg) to
--	R_LR	return address
--	R_BASE	old base address of data RAM
--
-- Upon Exit
--	R_BASE	new base address of data RAM
--
-- Corrupts
--	ST
--
-- Purpose
--	Sets C's address base for this thread.
--
	ldi	R_A1, R_BASE
	b	R_LR


Function _GetAddrBase
--
--	word _GetAddrBase(void)
--
-- Upon Entry:
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	base address of data RAM
--
-- Corrupts
--	ST
--
-- Purpose
--	Gets C's address base for this thread.
--
	ldi	R_BASE, R_A1
	b	R_LR


-- end of c40nccsupp.a
@


1.31
log
@increased deadmans handle to 256k in backtrace
@
text
@d35 1
a35 1
-- RcsId: $Id: c40nccsupp.a,v 1.30 1992/12/04 17:45:44 nickc Exp $
d41 3
d568 2
d577 9
@


1.30
log
@improved _backtrace to cope with missing function names, by returning module name
@
text
@d35 1
a35 1
-- RcsId: $Id: c40nccsupp.a,v 1.29 1992/11/12 20:54:42 paul Exp nickc $
d41 3
d463 4
a466 2
	ldi	   2048,	      R_ADDR2		-- initialise deadmans handle
							-- can handle fns =< 8KB
@


1.29
log
@made C40Word/CAddress compatible with IR0 != 0
@
text
@d35 1
a35 1
-- RcsId: $Id: c40nccsupp.a,v 1.28 1992/11/12 17:15:50 paul Exp $
d41 3
d434 3
a436 3
	ldhi	   0x2f,	  R_ADDR2		-- sanity check on low
	or	   0xf800,	  R_ADDR2
	cmpi	   R_ADDR2,       R_ADDR1		-- computed address
d442 5
a446 5
	GetNucRoot R_ADDR2
	ldi        *+R_ADDR2(Root.TraceVec), R_ADDR2
	C40WordAddress            R_ADDR2
	cmpi	   R_ADDR2,       R_ADDR1		-- sanity check on high
	bhi	   b_insane				-- computed address 
d451 2
a452 2
	cmpi	   R_ADDR2,       R_ADDR1		-- sanity check on high
	bhi	   b_insane				-- computed address 
d454 2
a455 2
	ldhi	   0x2f,	  R_ADDR2		-- sanity check on low
	or	   0xf800,	  R_ADDR2
d459 2
a460 1
	ldi	   2048,	  R_ADDR2		-- initialise deadmans handle
d463 6
a468 3
	 LB3  	  *R_ADDR1\--(1), R_A2			-- get hold of top byte of instruction
	 CMPI	  -1,		  R_A2			-- a top byte of 0xFF is illegal, and so used as marker
	DBne	   R_ADDR2,	  b_loop1		-- and loop until 0xFF found or limit exceeded
d470 4
a473 4
	   LDIne   0,		  R_A1result		-- if loop aborted return status is FAIL
	   LBU0	*++R_ADDR1(1),    R_A2			-- get hold of size of function name
	   LSH	  -2,		  R_A2			-- convert to number of words
	SUBI3      2,		  R_A2,		RC	-- set up repeat count
d475 4
a478 3
	   SUBI	   R_A2,	  R_ADDR1		-- subtract size of name from pointer
	   ADDI	   R_BASE,	  R_ATMP		-- convert buffer address to word pointer
	   LDI	  *R_ADDR1++(1),  R_A2			-- load first word from source
d481 2
a482 2
	 STI	   R_A2,         *R_ATMP++(1)		-- store word into destination
	 || LDI	  *R_ADDR1++(1),  R_A2			-- load word from source
d484 1
a484 1
	STI	   R_A2,         *R_ATMP		-- store last word from destination
d486 6
@


1.28
log
@updated to support c40WordAddress and CAddress macros being converted to
function calls
@
text
@d35 1
a35 1
-- RcsId: $Id: c40nccsupp.a,v 1.27 1992/09/25 09:37:18 paul Exp $
d41 4
d440 2
a441 1
	C40WordAddress            *+R_ADDR2(Root.TraceVec), R_ADDR2
@


1.27
log
@changed to use gexec.m
@
text
@d24 1
d26 1
d35 1
a35 1
-- RcsId: $Id: c40nccsupp.a,v 1.26 1992/08/20 17:31:18 paul Exp paul $
d41 3
a481 2
Function _DataToFuncConvert
--
d483 1
d501 5
d514 1
a514 1
Function _FuncToDataConvert
d517 1
d536 5
@


1.26
log
@added further checks as a bogus FP can make you access global mem
@
text
@d33 1
a33 1
-- RcsId: $Id: c40nccsupp.a,v 1.25 1992/08/18 09:55:16 paul Exp $
d39 3
d119 1
a122 1
include c40exec.m
@


1.25
log
@added GetAddrBase and SetAddrBase
@
text
@d33 1
a33 1
-- RcsId: $Id: c40nccsupp.a,v 1.24 1992/08/12 18:45:56 paul Exp $
d39 3
d417 1
a417 3
	C40WordAddress  R_A1,	  R_ATMP		-- convert destination byte offset to word offset
	LDI	  *R_ADDR1,       R_A1result		-- get hold of parent's frame pointer
	LDI	 *-R_ADDR1(1),    R_ADDR1		-- get return address to parent function
d419 2
a420 1
	ldhi	   0x30,	  R_ADDR2		-- sanity check on low
d431 11
@


1.24
log
@fixed for C40WordAddress macro
@
text
@d25 2
d33 1
a33 1
-- RcsId: $Id: c40nccsupp.a,v 1.23 1992/08/06 12:25:14 paul Exp $
d39 3
d520 44
@


1.23
log
@fixed _backtrace for insanely large pointers
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.22 1992/08/05 15:49:06 paul Exp paul $
d37 3
d409 1
a409 1
	LSH3	   -2,		  R_A1,		R_ATMP	-- convert destination byte offset to word offset
@


1.22
log
@wierd tempory fix to get system out
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.21 1992/08/05 10:32:46 paul Exp $
d37 3
d108 2
d409 13
a421 3
--	ldhi	   0x30,	  R_ADDR2		-- sanity check on
--	cmpi	   R_ADDR2,       R_ADDR1		-- computed address
--	blo	   b_insane
d423 1
a423 1
							-- works for functions < 2k in size
@


1.21
log
@fixed for insane frame pointers
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.20 1992/07/30 14:14:11 nickc Exp $
d37 3
d404 3
a406 3
	ldhi	   0x30,	  R_ADDR2		-- sanity check on
	cmpi	   R_ADDR2,       R_ADDR1		-- computed address
	blo	   b_error
d430 1
a430 1
b_error:
@


1.20
log
@fixed more bugs
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.19 1992/07/30 14:06:42 paul Exp nickc $
d37 3
d401 3
d426 4
d433 1
@


1.19
log
@fixed bugs in _backtrace
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.18 1992/07/21 08:10:52 nickc Exp $
d37 3
d385 1
a385 1
--	R_ATMP, R_ADDR1, R_ADDR1, ST
d395 1
a395 1
	C40WordAddress R_A1,	  R_ATMP		-- convert destination byte offset to word offset
a399 1
	LDI	   0,		  R_A1result		-- if loop aborts return status is FAIL
d401 1
a401 1
	 LB3  	  *R_ADDR1\--,     R_A2			-- get hold of top byte of instruction
d404 5
a408 4
	Bne	   R_LR					-- if loop aborted then return
	LBU0	*++R_ADDR1(1),    R_A2			-- get hold of size of function name
	LSH	  -2,		  R_A2			-- convert to number of words
	SUBI3	   2,		  R_A2,		RC	-- set up repeat count
@


1.18
log
@removed stack overflow function
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.17 1992/07/17 15:31:03 nickc Exp nickc $
d37 3
d95 1
a95 1

d107 2
a108 1
.__stack_overflow:
d119 2
a120 1
.__stack_overflow_1:
d135 1
a135 1
.memset:
d205 1
a205 1
.memcpy:
d367 1
a367 1
._backtrace:
d382 1
a382 1
--	R_ATMP, R_ADDR1, ST
d392 1
a392 1
	LSH3	  -2,		  R_A1,		R_ATMP	-- convert destination byte offset to word offset
d395 3
d399 1
a399 1
	 LB3  	  *R_ADDR1,       R_A2			-- get hold of top byte of instruction
d401 1
a401 2
	DBne	   R_ADDR1,	  b_loop1		-- and loop until 0xFF found or address is negative
	LDIne	   0,		  R_A1result		-- if loop aborts return status is FAIL
d421 1
a421 1
._DataToFuncConvert:
d449 1
a449 1
._FuncToDataConvert:
@


1.17
log
@improved beyong recognition (honest)
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.16 1992/07/01 09:09:13 paul Exp nickc $
d37 3
d102 2
d113 1
@


1.16
log
@added correct macro includes
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.15 1992/06/30 10:11:11 paul Exp $
d37 3
d358 1
a358 1
--	bool _backtrace( int * buffer, bool init )--
d362 1
a362 1
--      R_A2	boolean value (zero or non-zero)
d367 1
a367 1
--	R_A1	contains 0 upon failure, non-zero upon success
d371 1
a371 1
--	R_ATMP, R_ADDR1, R_T1, ST
d376 2
a377 2
--	Resets its notion of 'previous function' if its second 
--	argument is non-zero
d379 4
a382 10
	LDI	 *+R_MT(2),	  R_ATMP	        -- get kernel's data pointer
patchinstr( PATCHC40MASK16ADD, shift ( -16, shift ( 16, DATASYMB( __b_private ) ) ),
	ADDI	   0,		  R_ATMP )	        -- add in the offset to word of data
	LSH	  -2,		  R_ATMP		-- convert byte offset to word offset
	ADDI	   R_BASE,	  R_ATMP		-- convert the word offset to word pointer
	CMPI	   0,	          R_A2			-- check for reset
	LDIne	   R_FP,	  R_ADDR1		-- if so then use current frame pointer
	LDIeq	  *R_ATMP,	  R_ADDR1		-- otherwise use saved frame pointer
	LDI	  *R_ADDR1,       R_T1			-- get hold of parent's frame pointer
	STI	   R_T1,         *R_ATMP		-- and save in private data area
d385 2
a386 2
	 LB3  	  *R_ADDR1,       R_T1			-- get hold of top byte of instruction
	 CMPI	  -1,		  R_T1			-- a top byte of 0xFF is illegal, and so used as marker
d390 3
a392 4
	LBU0	*++R_ADDR1(1),    R_T1			-- get hold of size of function name
	LSH	  -2,		  R_T1			-- convert to number of words
	SUBI	   R_T1,	  R_ADDR1		-- subtract from pointer
	SUBI3	   2,		  R_T1,		RC	-- set up repeat count
d394 3
a396 3
	   LSH3	  -2,		  R_A1,		R_ATMP	-- convert destination byte offset to word offset
	   ADDI	   R_BASE,	  R_ATMP		-- convert to word pointer
	   LDI	  *R_ADDR1++(1),  R_A1			-- load first word from source
d399 2
a400 2
	 STI	   R_A1,         *R_ATMP++(1)		-- store word into destination
	 || LDI	  *R_ADDR1++(1),  R_A1			-- load word from source
d402 2
a403 4
	BuD	   R_LR					-- return
	   STI	   R_A1,         *R_ATMP		-- store last word from destination
	   LDI	   1,		  R_A1result		-- return status is OK
	   NOP						-- padding
@


1.15
log
@cause a SIGSTAK signal on stack overflow
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.14 1992/06/13 14:28:16 nickc Exp $
d37 3
d85 1
@


1.14
log
@fixed very small memcpys
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.13 1992/06/12 11:12:36 nickc Exp nickc $
d37 3
a91 3
/* @@@@@@ need to add __stack_overflow, __stack_overflow_1 and ... */
/* or at least print an error out! */

d93 5
a97 1
	int	0x66ffffff
d99 1
a99 1
		shift(-2, labelref(.JTAGHalt)),
d103 5
a107 1
	int	0x66ffffff
d109 1
a109 1
		shift(-2, labelref(.JTAGHalt)),
@


1.13
log
@added _DataToFuncConvert and _FuncToDataConvert
@
text
@d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.12 1992/06/10 13:38:15 nickc Exp nickc $
d37 3
d220 2
a221 4
	LDIu	 0,       R_T1			-- default adjustment = 0
	LDIlt	 R_A3,    R_T1			-- if count has gone negative the adjustment = count
	LDIlt	 0,       R_A3			-- and count = 0
	ADDI	 R_T1,    R_A2			-- apply adjustment
d320 16
d337 3
@


1.12
log
@fixed bug copying non-aligned data
@
text
@d23 2
d31 1
a31 1
-- RcsId: $Id: c40nccsupp.a,v 1.11 1992/05/20 16:59:32 nickc Exp nickc $
d37 3
d347 1
a347 1
	LSH	   -2,		  R_ATMP		-- convert byte offset to word offset
d366 1
a366 1
	   LSH3	   -2,		  R_A1,		R_ATMP	-- convert destination byte offset to word offset
d376 1
a376 1
	   LDI	   1,		 R_A1result		-- return status is OK
d380 60
@


1.11
log
@changed to be  boolean so that pointer overruns can be detected
@
text
@d29 1
a29 1
-- RcsId: $Id: c40nccsupp.a,v 1.10 1992/05/20 08:19:02 nickc Exp nickc $
d35 3
d210 1
a210 1
	SUBI	 4,       R_A2			-- invert byte selector (1 => -3,  2 => -2,  3 => -1)
@


1.10
log
@fixed bug in _backtrace
@
text
@d29 1
a29 1
-- RcsId: $Id: c40nccsupp.a,v 1.9 1992/05/19 16:35:03 nickc Exp nickc $
d35 3
d315 1
a315 1
--	void _backtrace( int * buffer, bool init )--
d324 1
d351 2
d366 4
a369 2
	STI	   R_A1,         *R_ATMP		-- store last word from destination
	Bu	   R_LR					-- return
@


1.9
log
@added _backtrace
@
text
@d29 1
a29 1
-- RcsId: $Id: c40nccsupp.a,v 1.8 1992/04/28 08:13:37 nickc Exp nickc $
d35 3
d351 1
a351 1
	BleD	   b_over				-- if we are only copying one word then skip loop
@


1.8
log
@really fixed short word copies
@
text
@d17 6
a22 2
--		Implements: __stack_overflow, __stack_overflow1, memcpy()
--		and memset().
d27 1
a27 1
--		snake:/users/nickc/ncc/experimental/src/asm/strings.a
d29 1
a29 1
-- RcsId: $Id: c40nccsupp.a,v 1.7 1992/04/27 17:15:52 nickc Exp nickc $
d31 2
a32 1
-- (C) Copyright 1991 Perihelion Software Ltd.
d35 3
d115 1
a115 1
	LSH	-2,       R_A1,   R_ADDR1	-- convert byte offset to word offset
d118 10
a127 12
	AND3	 3,       R_A1,   R_T1		-- get byte selector
	BeqD	set.word_aligned		-- if the pointer is word aligned then shout for joy
	LDIne	*R_ADDR1, R_FT1 		-- get word at start of string and advance pointer
	MH1	 R_A2,    R_A2			-- copy bottom 16 bits of value into top 16 bits
	CMPI	 2,       R_T1			-- check byte selector
					-- branch (might) take place now
	Beq	set.byte_selector_2		-- if byte selector == 2
	Bgt	set.byte_selector_3		-- if byte selector == 3
					-- drop through
	SUBI	1,        R_A3			-- decrement count
	Bn	R_LR				-- nothing to do
	MB1	R_A2,     R_FT1			-- no then merge in byte
d129 3
a131 3
	SUBI	1,        R_A3			-- decrement count
	Bn	set.completed			-- have we run out ?
	MB2	R_A2,     R_FT1			-- no, then merge in byte
d133 4
a136 5
	SUBI	1,        R_A3			-- decrement count
	Bn	set.completed			-- have we run out ?
	MB3	R_A2,     R_FT1			-- no, then merge in byte
	STI	R_FT1,   *R_ADDR1++(1)		-- place resulting word and advance pointer
					-- drop through
d138 1
a138 1
	LSH	 -2,      R_A3,   R_FT1		-- number of whole words to set
d140 3
a142 4
	SUBI3	 1,       R_FT1,  RC		-- load number of loops - 1
	AND	 3,       R_A3			-- number of bytes remaining to place
	LDHI	 0xFF00,  R_FT1			-- load mask
					-- branch (might) take place now
d148 3
a150 4
	SUBI	 3,       R_A3			-- invert count
	MPYI	 8,       R_A3			-- convert to bit selector
	ASH	 R_A3,    R_FT1			-- adjust mask
					-- return (might) happen now
d154 3
a156 4
	ANDN	 R_FT1,   R_A2			-- mask out bytes in value word
	OR	 R_A2,    R_T1			-- move the bytes into the destination word
	STI	 R_T1,   *R_ADDR1		-- save word back into memory
					-- return happens now
d184 1
a184 1
--	NB/ This function cannot be _memcpy as this is an internal
d187 9
a195 12
	CMPI	0,	R_A3			-- Check for a count of zero
	Beq	R_LR				-- and return if count is zero
	LSH	-2,     R_A1,   R_ADDR1		-- convert dest to word offset

	XOR3	R_A1,   R_A2,   R_T1		-- see if the two pointers are aligned
	AND	3,      R_T1			-- but only check byte selectors
	BneD	mcpy.not_aligned		-- if the pointers are not mutually aligned ...

	LSH	-2,     R_A2,   R_ADDR2		-- convert source to word offset
	ADDI	R_BASE, R_ADDR1			-- convert dest   to word pointer
	ADDI	R_BASE, R_ADDR2			-- convert source to word pointer
					-- branch (might) occur now
d199 15
a213 16
	AND	3,      R_A2			-- get byte selector
	Beq	mcpy.word_aligned		-- pointers are word aligned
	SUBI	4,      R_A2			-- invert byte selector (1 => -3,  2 => -2,  3 => -1)
	ADDI	R_A2,   R_A3			-- decrement count of bytes to copy
	LDIu	0,      R_T1			-- default adjustment = 0
	LDIlt	R_A3,   R_T1			-- if count has gone negative the adjustment = count
	LDIlt	0,      R_A3			-- and count = 0
	ADDI	R_T1,   R_A2			-- apply adjustment
	MPYI	8,      R_A2			-- convert byte selector to bit selector
	LDHI	0xFF00, R_FT1			-- load mask
	ASH	R_A2,   R_FT1			-- shift mask into position
	AND3	R_FT1,  *R_ADDR2++(1), R_A2	-- mask out non-source bytes in source word
	ANDN3	R_FT1,  *R_ADDR1,      R_T1	-- mask out source bytes in destination word
	OR	R_A2,   R_T1			-- move source bytes into destination word
	STI	R_T1,  *R_ADDR1++(1)		-- save word
					-- drop through into word aligned code
d225 1
a225 1
	-- RC					number of words to copy
d229 6
a234 7
	LSH	-2,     R_A3, RC		-- get number of words to copy
	Beq	mcpy.no_more_words		-- if none then skip next section (delayed)
	LDIne	*R_ADDR2++(1), R_A2		-- get first word
	SUBI	2,      RC			-- decrement count to allow for words copied setting up loop
					-- branch (might) occur now
	Blt	mcpy.only_one_word		-- if count is negative then only word need be copied
	RPTB	mcpy.block1			-- repeat next instructions
d236 2
a237 2
	STI	R_A2,  *R_ADDR1++(1)		-- save previous word in destination
	|| LDI	*R_ADDR2++(1), R_A2		-- and load next word from source
d239 1
a239 1
	STI	R_A2,  *R_ADDR1++(1)		-- save final full word
d241 11
a251 12
	AND	3,      R_A3			-- final number of bytes to copy
	Beq	R_LR				-- no more bytes => return 
	LDHI	0xFF00, R_FT1			-- load mask
	SUBI	3,      R_A3			-- invert remaining count
	MPYI	8,      R_A3			-- convert to bit selector
	ASH	R_A3,   R_FT1			-- move mask into position
	AND	R_FT1, *R_ADDR1, R_T1		-- extract bytes from destination
	BuD	R_LR				-- return (delayed)
	ANDN	R_FT1, *R_ADDR2, R_A2		-- extract bytes from source
	OR	R_A2,   R_T1			-- move bytes from source into destination word
	STI	R_T1,  *R_ADDR1			-- save word
					-- return takes place now
d264 2
a265 2
	-- RC	   -				source word
	-- RS	   -				dest   word
d269 12
a280 12
	AND3	3,       R_A1,  R_T1		-- get dest   byte selector
	AND	3,       R_A2,  R_FT1		-- get source byte selector
	SUBI3	R_FT1,   R_T1,  R_FT2		-- calculate (byte) shift factor
	MPYI	8,       R_FT2			-- convert byte shift to bit shift
	LDI    *R_ADDR2++(1),   RC		-- get word from source
	LDI	0xFF,    R_A2			-- load destination mask
	MPYI	8,       R_T1			-- convert dest byte selector into bit selector
	LSH	R_T1,    R_A2			-- move destination mask into position
	MPYI3	8,       R_FT1, RS			-- convert source byte selector into bit selector
	LDI	0xFF,    R_T1			-- load source mask
	LSH	RS,      R_T1			-- move source mask into position
	LDI    *R_ADDR1, RS			-- get word from destination
d282 12
a293 15
	AND3	R_T1,    RC,    R_FT1		-- get byte from source

	SUBI	1,       R_A3			-- decrement count of bytes to copy
	BeqD	mcpy.finished			-- if the count has reached 0 we have finished

	LSH	R_FT2,   R_FT1			-- move source byte into position for destination
	ANDN	R_A2,    RS			-- mask out byte in destination word
	OR	R_FT1,   RS			-- merge in byte from source word
					-- branch (might) take place now
	LSH	8,       R_T1			-- adjust source mask to cover next byte
	Bne	mcpy.over			-- if the mask is still present skip the next bit
	LDI    *R_ADDR2++(1),   RC		-- get a new word from the source
	BuD	mcpy.loop1			-- we know that destination shift will not empty the mask
	LDI	0xFF,    R_T1			-- resetore the source mask (to cover bottom byte)
	XOR	0xE0,    R_FT2			-- correct the bit shift (I love this magic)
d295 7
a301 9
	LSH	8,       R_A2			-- adjust destination mask
					-- branch (might) take place now
	Bne	mcpy.loop1			-- if it is not empty then carry on loop
	LDI	0xFF,    R_A2			-- reset destination mask (to cover bottom byte)
	BuD	mcpy.loop1			-- return to loop (delayed)
	STI	RS,     *R_ADDR1++(1)		-- save destination word		
	LDI    *R_ADDR1, RS			-- get new destination word
	XOR	0xE0,    R_FT2			-- correct bit shift
					-- branch takes place now
d303 2
a304 2
	STI	RS,     *R_ADDR1		-- save the last word
	Bu	R_LR				-- return
d307 55
@


1.7
log
@fixed bug in tail end of memcpy
@
text
@d25 1
a25 1
-- RcsId: $Id: c40nccsupp.a,v 1.6 1992/04/10 16:52:49 paul Exp nickc $
d30 3
d222 1
a222 1
	-- R_A1	byte offset of destination	not changed
d224 1
a224 1
	-- R_A3	number of bytes to copy		number of bytes left to copy
d232 1
a232 2
	BeqD	mcpy.no_more_words		-- if none then skip next section (delayed)
	LDHI	0xFF00, R_FT1			-- load mask
d245 2
a246 1
	BeqD	R_LR			-- no more bytes => return (delayed)
d250 1
a250 2
					-- return (might) happen now
	ANDN	R_FT1,  *R_ADDR1, R_T1		-- extract bytes from source
d252 1
a252 1
	AND	R_FT1,  *R_ADDR2, R_A2		-- extract bytes from destination
d262 8
a269 8
	-- R_A1	- dest   byte offset		not changed
	-- R_A2	- source byte offset		dest byte mask
	-- R_A3	- number of bytes to copy	bytes left to copy	
	-- R_T1	- 				source byte mask
	-- R_FT1-				temporary word holding shifted source byte
	-- R_FT2-				bits to shift source byte to align with destination byte
	-- RC	-				source word
	-- RS	-				dest   word
d271 1
a271 1
	-- R_ADDR2 - source word pointer		source word pointer
@


1.6
log
@fixed a small typo
@
text
@d25 1
a25 1
-- RcsId: $Id: c40nccsupp.a,v 1.5 1992/04/10 16:38:32 nickc Exp $
d30 3
d248 1
a248 1
	AND	R_FT1,  *R_ADDR1, R_T1		-- extract bytes from source
d250 1
a250 1
	ANDN	R_FT1,  *R_ADDR2, R_A2		-- extract bytes from destination
@


1.5
log
@changed RPTS to RPTB
@
text
@d25 1
a25 1
-- RcsId: $Id: c40nccsupp.a,v 1.4 1992/04/08 09:50:29 nickc Exp nickc $
d30 3
d307 1
a307 1
`	STI	RS,     *R_ADDR1		-- save the last word
d309 1
@


1.4
log
@added check for 0 length in memset
@
text
@d6 3
d20 6
a25 1
-- RcsId: $Id: c40nccsupp.a,v 1.3 1992/04/08 09:48:58 nickc Exp nickc $
d30 3
d47 4
d121 1
a121 1
	STI	R_FT1,    *R_ADDR1++(1)		-- place resulting word and advance pointer
d124 1
a124 1
	LSH	 -2,      R_A3,  R_FT1		-- number of whole words to set
d130 2
a131 1
	RPTS	 RC				-- repeat next instruction
d140 1
a140 1
	AND	 R_FT1,    R_T1			-- mask out bytes to be set
d142 1
a142 1
	ANDN	 R_FT1,    R_A2			-- mask out bytes in value word
d147 1
a147 1
	STI	 R_FT1,   *R_ADDR1		-- save result
a222 1
	CMPI	0,      RC			-- XXX for the pesky simulator
d229 2
a230 1
	RPTS	RC				-- repeat next instructions
d265 2
a266 2
	AND3	3,      R_A1,  R_T1		-- get dest   byte selector
	AND	3,      R_A2,  R_FT1		-- get source byte selector
d268 9
a276 9
	MPYI	8,      R_FT2			-- convert byte shift to bit shift
	LDI	*R_ADDR2++(1), RC		-- get word from source
	LDI	0xFF,   R_A2			-- load destination mask
	MPYI	8,      R_T1			-- convert dest byte selector into bit selector
	LSH	R_T1,   R_A2			-- move destination mask into position
	MPYI3	8,      R_FT1,  RS			-- convert source byte selector into bit selector
	LDI	0xFF,   R_T1			-- load source mask
	LSH	RS,     R_T1			-- move source mask into position
	LDI	*R_ADDR1, RS			-- get word from destination
d278 1
a278 1
	AND3	R_T1,   RC,  R_FT1		-- get byte from source
d280 1
a280 1
	SUBI	1,      R_A3			-- decrement count of bytes to copy
d284 1
a284 1
	ANDN	R_A2,   RS			-- mask out byte in destination word
d287 1
a287 1
	LSH	8,      R_T1			-- adjust source mask to cover next byte
d289 1
a289 1
	LDI	*R_ADDR2++(1), RC		-- get a new word from the source
d291 2
a292 2
	LDI	0xFF,   R_T1			-- resetore the source mask (to cover bottom byte)
	XOR	0xE0,   R_FT2			-- correct the bit shift (I love this magic)
d294 1
a294 1
	LSH	8,      R_A2			-- adjust destination mask
d297 1
a297 1
	LDI	0xFF,   R_A2			-- reset destination mask (to cover bottom byte)
d299 3
a301 3
	STI	RS,    *R_ADDR1++(1)		-- save destination word		
	LDI	*R_ADDR1, RS			-- get new destination word
	XOR	0xE0,   R_FT2			-- correct bit shift
d304 1
a304 1
	STI	RS,    *R_ADDR1			-- save the last word
@


1.3
log
@fixed typo in previous delta
@
text
@d17 1
a17 1
-- RcsId: $Id: c40nccsupp.a,v 1.2 1992/04/08 09:39:46 nickc Exp nickc $
d22 3
d81 2
@


1.2
log
@added check for count == 0 in memcpy
@
text
@d17 1
a17 1
-- RcsId: $Id: c40nccsupp.a,v 1.1 1992/04/08 09:36:30 nickc Exp nickc $
d22 3
d155 1
a155 1
	CMPI	R_A3,	0			-- Check for a count of zero
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
-- RcsId: $Id:$
d21 3
a23 1
-- RcsLog: $Log$
d25 1
d152 2
@
