head	1.23;
access;
symbols
	Helios_1_3_1:1.23
	Helios_C40_1_3_Official_Release:1.17
	Alenia_release:1.11
	C40_Field_Test_2:1.9
	C40_Field_Test_R1:1.5;
locks; strict;
comment	@-- @;


1.23
date	93.09.17.16.03.19;	author paul;	state Exp;
branches;
next	1.22;

1.22
date	93.09.17.14.42.27;	author paul;	state Exp;
branches;
next	1.21;

1.21
date	93.09.06.12.02.44;	author paul;	state Exp;
branches;
next	1.20;

1.20
date	93.08.16.08.48.56;	author richardp;	state Exp;
branches;
next	1.19;

1.19
date	93.08.16.08.39.17;	author richardp;	state Exp;
branches;
next	1.18;

1.18
date	93.07.02.09.57.31;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	93.04.27.11.51.21;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	93.04.21.08.52.34;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	93.04.16.12.25.26;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	93.04.01.16.59.34;	author nick;	state Exp;
branches;
next	1.13;

1.13
date	93.02.05.13.25.09;	author paul;	state Exp;
branches;
next	1.12;

1.12
date	93.01.21.09.56.30;	author paul;	state Exp;
branches;
next	1.11;

1.11
date	92.11.20.15.46.23;	author paul;	state Exp;
branches;
next	1.10;

1.10
date	92.11.18.14.33.45;	author paul;	state Exp;
branches;
next	1.9;

1.9
date	92.10.09.16.51.44;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	92.09.25.09.35.13;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	92.09.23.17.20.15;	author paul;	state Exp;
branches;
next	1.6;

1.6
date	92.07.08.16.11.01;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	92.06.26.17.56.51;	author paul;	state Exp;
branches;
next	1.4;

1.4
date	92.06.24.14.11.01;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	92.06.15.13.39.51;	author paul;	state Exp;
branches;
next	1.2;

1.2
date	92.05.14.08.20.57;	author paul;	state Exp;
branches;
next	1.1;

1.1
date	92.04.21.09.54.56;	author paul;	state Exp;
branches;
next	;


desc
@initial alpha version
@


1.23
log
@fixes for high memory access - now uses unsigned compares.
@
text
@-- File:	c40boot.a
-- Subsystem:	'C40 Helios executive
-- Author:	P.A.Beskeen
-- Date:	Nov '91
--
-- Description: 'C40 specific initial boot code.
--
--		This code is downloaded using the on-chip 'C40 boot sequence.
--		It is booted into internal RAM, where upon it initialises the
--		'C40 and updates the ExecRoot with the contents of the ID-ROM.
--		The nucleus load position is calculated, the execroot updated
--		with this information and the nucleus is then downloaded.
--		Finally a C PCS conformant world is set up and we jump into
--		the kernel.
--
-- RcsId: $Id: c40boot.a,v 1.21 1993/09/06 12:02:44 paul Exp paul $
--
-- (C) Copyright 1991 Perihelion Software Ltd.
-- 
-- RcsLog: $Log: c40boot.a,v $
-- Revision 1.21  1993/09/06  12:02:44  paul
-- removed HUNTDBG option - no longer a bug and it was confusing.
--
-- Revision 1.20  1993/08/16  08:48:56  richardp
-- memory sizing even when noTCLK0Reset
--
-- Revision 1.19  1993/08/16  08:39:17  richardp
-- Automatic memory sizing
--
-- Revision 1.18  1993/07/02  09:57:31  nickc
-- removed fix for SANG board
--
-- Revision 1.17  1993/04/27  11:51:21  nickc
-- fixed for SANG board IDROM read
--
-- Revision 1.16  1993/04/21  08:52:34  nickc
-- Changed the way IR0 is calculated.
--
-- Revision 1.15  1993/04/16  12:25:26  nickc
-- Four bit IDrom bugs fixed.  (You got it wrong again Paul!)
--
-- Revision 1.14  1993/04/01  16:59:34  nick
-- If the local RAM is in the first 3Mwords of quadrant 2, the address base
-- is set to 0x002ff0000 to allow both it and the on-chip RAM to be addressed.
--
-- Revision 1.13  1993/02/05  13:25:09  paul
-- fixed HW_Disable cache bug
--
-- Revision 1.12  1993/01/21  09:56:30  paul
-- Bootstrap now records HWConfig word in the ExecRoot for the networking
-- software to use as the default when booting other processors. It gets
-- this info via the Fn GetHWConfig().
--
-- Revision 1.11  1992/11/20  15:46:23  paul
-- if the base+size of strobe used as data is within the first quadrant of
-- memory, then set IR0 address base as zero to keep ONCHIP RAM and periperals
-- in addressablity
--
-- Revision 1.10  1992/11/18  14:33:45  paul
-- big changes. Added support for HW_Config word to select the nucleus load
-- address, the C address base IR0 is setup correctly, and full C40Word/CAddress
-- macros are used. The nucleus load address is now passed as a word pointer,
-- and also saved in the ExecRoot as a WPTR.
--
-- Revision 1.9  1992/10/09  16:51:44  nickc
-- fixed test for contents of idrom's LBASE0 value
--
-- Revision 1.8  1992/09/25  09:35:13  paul
-- changed to use gexec.m and store the initial address of the system stack
--
-- Revision 1.7  1992/09/23  17:20:15  paul
-- added moveable execroot support (tvtp)
--
-- Revision 1.6  1992/07/08  16:11:01  paul
-- added booted acknowledge word
--
-- Revision 1.5  1992/06/26  17:56:51  paul
-- added config line assert/de-assert as per TIM-40 std
--
-- Revision 1.3  1992/06/15  13:39:51  paul
-- added IDROM support
--
-- Revision 1.2  1992/05/14  08:20:57  paul
-- removed unecessary software wait states from mem ctrl regs
--
-- Revision 1.1  1992/04/21  09:54:56  paul
-- Initial revision
--
--

include basic.m
include c40.m
include tim40.m
include c40mmap.m
include ../gexec.m
include module.m
include config.m


	-----------------------------------------------------------------------
	-- The linker will prefix this code with 3 words magic/flags and size.
	-- The booting program should ignore these three words and only download
	-- 'size' bytes, jumping to the first of these.

	-- This boot code is downloaded into the second bank of on-chip RAM.
startboot:
	-- Upon entry the 'C40 will be in its reset state with interrupts
	-- disabled and AR3 points to the cpcr of the link we were
	-- booted down. This register must NOT be corrupted.

	-- Write Boot Acknowledge word to booter.
	stik	0x1, *+ar3(2)

	-- Read Hardware Config word from booter.
	ldi	*+ar3(1), r9

	-- The cache is sometimes disabled to get around C40 bugs.
	-- On revision 1 (GFL) using two strobes of differing speeds on the
	-- same address bus can cause problems with the cache enabled.
	ldi	0, st
	tstb	HW_CacheOff, r9
	bnz	DontEnableCache
	or	ST_CE, st		-- enable cache for fast boot
DontEnableCache:

	-- If we are replacing existing IDROM, then we should still go through
	-- the motions of raising and lowering the module config line and
	-- swapping out the IDROM from local memory.
	tstb	HW_PseudoIDROM, r9
	bnz	DontRaiseConfig
	-- start of bootstrap so raise TIM-40 module config line
	ldi	IIF_TYPE3 | IIF_FLAG3, r0
	ldi	r0, iif

	-- Setup ar1 to control IDROM recall and mapping.
	ldaperi timer0_control ar1	-- control addr for TCLK0 pin.
DontRaiseConfig:

	-- If we are being sent a IDROM look-alike via the link,
	-- then get it in preference to loading a firmware version.
	tstb	HW_PseudoIDROM | HW_ReplaceIDROM, r9
	bz	ReadRealIDROM

	-----------------------------------------------------------------------
	-- Read pseudo/replacement IDROM
ReadPseudoIDROM:
	ldi	*+ar3(1), r1		-- read inclusive size of H/W Config
	subi	2, r1, r0		-- init for // rpts

	OnChipRAM ar4			-- Write to IDROM's std location

	-- Download pseudo IDROM from booter into on-chip RAM bank 0.
	-- Initial size read into r1 is saved immediately.
	rpts	r0			-- loops r0 + 1
		ldi	*+ar3(1), r1 || sti	r1, *ar4++
	sti	r1, *ar4++		-- store final value

	b	InitC40

	-----------------------------------------------------------------------
	-- Read Real IDROM
ReadRealIDROM:
	-- Copy ID-ROM contents to on chip RAM.

	ldhi	0x7000, ar2	-- start address to read IDROM contents from

	-- Remember what type of IDROM is being used in r0
	-- hi = 1bit, lo = 4bit serial IDROM's
	ldi	*ar1, r0

	-- Init sequence for IDROM load.
	-- Enables the use of EEPROMS as their recall can be activated with
	-- this sequence.
	stik	tcr_io, *ar1		-- TCLK0 = output + output 0
	ldi	2000, r1		-- 200uS delay on 50Mhz C40
delay0:
	subi	1, r1
	bnz	delay0

	stik	tcr_io|tcr_datout, *ar1	-- TCLK0 = output + output 1
	ldi	2000, r1		-- 200uS delay on 50Mhz C40
delay1:
	subi	1, r1
	bnz	delay1

	stik	tcr_io, *ar1		-- TCLK0 = output + output 0
	ldi	2000, r1		-- 200uS delay on 50Mhz C40
delay2:
	subi	1, r1
	bnz	delay2

	stik	tcr_io|tcr_datout, *ar1		-- TCLK0 = output + output 1

	-- Find out what type of IDROM is being used.
	and	tcr_datin, r0	-- Timer 0 DATAIN (TCLK0) bit
	bz	fourbitread	-- TCLK0 hi = 1 bit ID ROM
				--	 lo = 4 bit ID ROM

	-----------------------------------------------------------------------
	-- Read one bit IDROM
onebitread:
getidsize:
	ldi	31, rc		-- load 32 bits at a time
	rptb	endblock0
	ldi	*ar2++, r2	-- get a bit
	lsh	-1, r2		-- shift bit into carry
endblock0:
	rorc	r3		-- rotate r3 with input from carry

	ldi	r3, r0		-- amount of ID ROM data to read
	bz	InitC40		-- if size is zero end IDROM load sequence


getdest:
	ldi	31, rc		-- load 32 bits at a time
	rptb	endblock1
	ldi	*ar2++, r2	-- get a bit
	lsh	-1, r2		-- shift bit into carry
endblock1:
	rorc	r3		-- rotate r3 with input from carry

	ldi	r3, ar4		-- address to download data to


dataloop:
	ldi	31, rc		-- load 32 bits at a time
	rptb	endblock2
	ldi	*ar2++, r2	-- get a bit
	lsh	-1, r2		-- shift bit into carry
endblock2:
	rorc	r3		-- rotate r3 with input from carry

	sti	r3, *ar4++	-- store in internal memory

	subi	1, r0		-- read fixed ID-ROM block size
	bnz	dataloop

	b	onebitread

	-----------------------------------------------------------------------
	-- Read four bit IDROM
	-- @@@@@@ Four bit IDROM code has never been tested as no H/W we have
	-- come across has implemented it yet.
fourbitread:
	
get4idsize:
	ldi	0, r1		-- initial shift position
        ldi     0, r3           -- initialise resultant word
	ldi	32/4-1, rc	-- load 8 four bit chunks per word
	rptb	end4block0
	ldi	*ar2++, r2	-- get 4 bits
	and	0xf, r2		-- might not actually have to do this, best safe
	lsh	r1, r2
	or	r2, r3		-- insert into correct pos in r3
end4block0:
	addi	4, r1

	ldi	r3, r0		-- amount of ID ROM data to read
	bz	InitC40		-- if size is zero end IDROM load sequence

get4dest:
	ldi	0, r1		-- initial shift position
        ldi     0, r3           -- initialise resultant word
	ldi	32/4-1, rc	-- load 8 four bit chunks per word
	rptb	end4block1
	ldi	*ar2++, r2	-- get 4 bits
	and	0xf, r2
	lsh	r1, r2
	or	r2, r3		-- insert into correct pos in r3
end4block1:
	addi	4, r1

	ldi	r3, ar4		-- address to download data to

data4loop:
	ldi	0, r1		-- initial shift position
        ldi     0, r3           -- initialise resultant word
	ldi	32/4-1, rc	-- load 8 four bit chunks per word
	rptb	end4block2
	ldi	*ar2++, r2	-- get 4 bits
	and	0xf, r2
	lsh	r1, r2
	or	r2, r3		-- insert into correct pos in r3
end4block2:
	addi	4, r1

	sti	r3, *ar4++	-- store in internal memory

	subi	1, r0		-- read fixed ID-ROM block size
	bnz	data4loop

	b	get4idsize


	-----------------------------------------------------------------------
	--  Check for zero memory sizes and calculate them
InitC40:

	ldperimap ar0

	OnChipRAM ar5		-- Std IDROM's always load first block here

	-- global mem reg
	ldi     *+ar5(IDROM.GBCR), r0
	sti     r0, *+ar0(gmem_control)

	-- local mem regB
	ldi	*+ar5(IDROM.LBCR), r0
	sti	r0, *+ar0(lmem_control)

	-- setup timer 0 for a 1mS period, but do not start it
	ldi	*+ar5(IDROM.TIMER0_PERIOD), r0
	sti	r0, *+ar0(timer0_period)

	-- setup timer 1 as this may be needed for DRAM refresh
	ldi	*+ar5(IDROM.TIMER1_PERIOD), r0
	sti	r0, *+ar0(timer1_period)

	ldi	*+ar5(IDROM.TIMER1_CTRL.w_offset), r0
	-- Timer1 actually in upper 16 bits of word
	lsh	-IDROM.TIMER1_CTRL.shift, r0
	-- set the timer to run on when a JTAG halt is in effect
	-- this ensures that DRAM refresh continues.
	ldhi	((tcr_dbgcont1 | tcr_dbgcont2) >> 16) & 0xffff, r1
	or	r1, r0
	sti	r0, *+ar0(timer1_control)

	tstb	HW_PseudoIDROM, r9
	bnz	NoTCLK0Reset
	-- Allow normal accesses to Local RAM, not ID ROM.
	stik	tcr_io, *ar1		-- TCLK0 = output + output 0
NoTCLK0Reset:

	ldi    *++ar5(IDROM.GBASE0),R0
	ldi    4,R7                 --  4 memory chunks to investigate
nextstrobe:
	LDI    *ar5,AR1             --  Move Address into address register
	LDI    *+ar5(1),R10         --  Set the artificial limit
	CMPI   1,R7                 --  usually next entry,  but last one
	BNE    notlast              --  is the first entry
	LDI    *-ar5(3),R10         --  so get that instead
notlast:
	LDI    *+ar5(4),R0          --  Get size as specified in IDROM
	Bne    dunstrobe            --  Check if size is zero
	LDI    -1,r0                --  Check if address is ffffffff
	CMPI   r0,AR1               --  by comparing to -1
	Beq    dunstrobe            --  and do nothing on strobe if it is
    --   Else we are going to size the memory ourselves
    --   Main problem is to set a limit to where we look
	LDI    0x1000,R1            --  set stride - 16384 bytes
	LDI    0xc40,R2             --  set an arbitrary constant to R2
	STI    R2,*AR1              --  and put that in the first word
	STI    R1,*+AR1(1)
	LDA    AR1,AR2              --  set pointer to current check area
	CMPI   R2,*AR1
        Bne    gotall
lookmore:
	ADDI   R1,AR2               --  point to one stride further up
	LDI    AR2,R3               --  get the address to compute
	ADDI   R2,R3                --  another arbitrary value from it
	STI    R3,*AR2              --  and put that into new location
	CMPI   R2,*AR1              --  check to see if first word still OK
	Bne    gotall               --  and if not,  that is the lot!
	CMPI   AR1,R10              --  have we got to limit value
	Beq    gotall               --  yes - that's the lot
	LDI    *AR2,R6              --  now re-get the current check value
	CMPI   R3,R6                --  and check that is what we stored
	Beq    lookmore             --  if equal,  look for more memory
gotall:
	SUBI3  AR1,AR2,R0           --  subtract original from failed
	sti    R0,*+ar5(4)          --  put size into position
dunstrobe:
	LDI    *++ar5(1),R0         --  increment strobe pointer
	SUBI   1,R7                 --  subtract 1 from the number to do
	Bne    nextstrobe           --  repeat for next strobe if need be


	OnChipRAM ar5		-- Std IDROM's always load first block here



-------------------------------------------------------------------------------
-- Setup basic memory map.
--
--
-- Global Bus:
--
--	Hi loaded Nucleus
--	------------------

-- Local Bus:
--	     Hi addr.
--
--	------------------
--	Trace Vector
--	------------------
--
--	Poss. strobe 1 mem
--
--	------------------
--	Poss. dummy block	Used to stitch together noncontigous strobe 0/1
--	------------------
--
--	Main Memory Pool
--
--	------------------
--	Config vector
--	------------------
--	Kernel Root
--	------------------
--
--	Low loaded Nucleus
--
--	------------------
--	Interrupt vectors       256 bytes (must be 2kb boundary aligned)
--	------------------
--	System Stack		1kb
--	------------------
--	ExecRoot		1kb
--	------------------	< Base of local bus strobe 0/1
--
--	     Lo addr.

	-- Find correct address for start of local bus.
	-- Local bus is currently always used to hold the ExecRoot
	-- system stack, interrupt vector table, kernel root, config
	-- structure and C addressable user RAM. The nucleus may be
	-- loaded on the global bus, or the local bus.

	-- Force use of local bus strobe 1 instead of strobe 0?
	tstb	HW_NucleusLocalS1, r9
	bnz	UseLStrobe1

	-- Default to using local bus strobe 0, but check its validity.
	-- Use local bus strobe 1 if strobe 0 is invalid.
	ldi	*+ar5(IDROM.LBASE0), ar1
	addi	*+ar5(IDROM.LSIZE0), ar1, ar6
	cmpi	-1, ar1
	bne	ValidL0Strobe
UseLStrobe1:
	ldi	*+ar5(IDROM.LBASE1), ar1
	addi	*+ar5(IDROM.LSIZE1), ar1, ar6
	b       ValidL1Strobe		  	-- not strictly true !

	-- OK, by default R_BASE (IR0) will start at 0x002ff000 (the start of
	-- on chip RAM).  This will allow C programs to access this resource.
	-- There are two cases where this is not done:
	--
	--  1.  Only Strobe 0 is being used, and all of strobe 0 is within
	--      the first quadrant (1 giga word) of the address space.
	--      In this case R_BASE is set to zero for backwards compatibilty
	--      with Beta test versions of Helios.
	--
	--  2.  The start or end of both strobes of memory lie outside the
	--      range 0x002ff000 -> 0x402ff000.  In this case it would not
	--      be possible to access all of the memory on at least one of
	--	the strobes, a highly undesirable situation.

	-- at this point:
	-- ar1  - holds base address of selected strobe
	-- ar6  - holds end  address of selected strobe
	-- ar5  - points to IDROM
	-- ar4  - is free

ValidL0Strobe:
	ldi	-1,     ar4
	cmpi	*+ar5(IDROM.LBASE1), ar4	-- check for valid strobe 1
	bne	BothStrobesValid		-- and skip test for case 1 if so
	ldhi	0x4000, ar4
	cmpi	ar4,    ar1			-- check for strobe 0 being outside of first giga word
	ldilo	0,      R_BASE			-- and if not, start base address at 0
	blt     SetAddressBase

BothStrobesValid:
ValidL1Strobe:
	ldhi	0x402f, ar4			-- load end of addressable RAM if base is at 0x002ff00
	or	0xf000, ar4
	cmpi	ar4,    ar6			-- check against end of selected strobe
	ldihi   ar1,    R_BASE
	bhi	SetAddressBase			-- If strobe extendes beyond end of block, then use strobe
	ldhi	0x002f, R_BASE
	or	0xf000, R_BASE			-- otherwise use block starting at 0x002ff00

	-- fall through

SetAddressBase:
	-- Setup address of ExecRoot.
	-- This is held in the tvtp expansion register.
	-- tvtp and ivtp must lie on a 512 word (2k) boundary.

	-- Use the base memory address as the execroot pointer.
	ldpe	ar1, tvtp	-- set trap vector table (execroot) position
				-- GetExecRoot will load this address from tvtp

	-- Save standard address base in nucleus.
	sti	R_BASE,	*+ar1(ExecRoot.CAddressBase)

	-- Save HW_Config sent to bootstrap in the ExecRoot.
	-- This is used as the default when booting other processors.
	sti	r9, *+ar1(ExecRoot.HWConfig)

	-- Position system stack pointer directly after execroot.
	-- Execroot and SSP are nominally 1kb in size each.
	-- (system stack builds upwards)
	-- .sizeof defined in terms of bytes.
	ldi	ar1, R_SSP
	addi	ExecRoot.sizeof / 4, R_SSP

	-- Align interrupt vectors to 0x200 word boundary after execroot
	-- and system stack.
	ldi	R_SSP, ar2
	addi	0x200-1, ar2
	andn	0x200-1, ar2
	ldpe	ar2, ivtp	-- set interrupt vector position

	addi	0x40, ar2	-- add size of interrupt vector table
				-- to give nucleus load position

	-- Depending on HW_Config word, choose nucleus load location and
	-- record it in ExecRoot.
TestGlobalS0:
	tstb	HW_NucleusGlobalS0, r9
	bz	TestGlobalS1
	ldi	*+ar5(IDROM.GBASE0), ar4
	b	UseHighNuc

TestGlobalS1:
	tstb	HW_NucleusGlobalS1, r9
	bz	LocalBusNucleus
	ldi	*+ar5(IDROM.GBASE1), ar4
UseHighNuc:
	-- Load nucleus at base of global strobe 0/1.
	-- ar2 = end of IVTP
	-- ar4 = base address of chosen strobe.
	-- ar1 = ExecRoot
	-- Kernel root struct is therefore located directly after the
	-- interrupt vector table.
	ldi	ar2, r0
	C40CAddress r0				-- Convert to BPTR.
	sti	r0, *+ar1(ExecRoot.KernelRoot)	-- Save in execroot.

	ldi	ar4, ar2			-- set nuc pos to base of strobe

	b	SetNucAddress

LocalBusNucleus:
	-- ar2 = end of IVTP (base of low loaded nucleus).
	-- ar1 = ExecRoot

	-- Note that kernel root address still has to be set.
	-- It will be located directly after the downloaded nucleus.
	stik	0,  *+ar1(ExecRoot.KernelRoot)

SetNucAddress:
	-- Save computed address of nucleus into execroot.
	-- Nucleus location is held as a word pointer on C40
	-- ar2 = Nucleus load position
	sti	ar2, *+ar1(ExecRoot.Nucleus)


	-----------------------------------------------------------------------
	-- Download Nucleus.
	--
	-- Expects simple boot protocol of SIZE in words,
	-- followed by SIZE words of data.
	-- @@@@@@ extend protocol to add peek / poke / exec / boot / worm on cmd?

	-- Download nucleus to RAM address pointed at by ar2
	ldi	*+ar3(1), r0		-- read # bytes of image to download
	ldi	ar2, ar4		-- ar2 points to nucleus load area

	sti	r0, *ar4++		-- save size as part of image
	lsh	-2, r0			-- / sizeof(word) - convert to # words
	subi	3, r0			-- initialise for rpts
					-- -1 size, -2 rpts and || correction

	-- Download image
	ldi	*+ar3(1), r1		-- initialise r1 for parallel loop
	rpts	r0			-- loops r0 + 1
		ldi	*+ar3(1), r1 || sti	r1, *ar4++
	sti	r1, *ar4++		-- store final value


	-----------------------------------------------------------------------
	-- Copy IDROM into ExecRoot structure
	-- ar5 points to base of IDROM in internal ram
	-- ar1 points to ExecRoot base.

	addi	ExecRoot.ID_ROM, ar1, ar4
	ldi	*ar5, r0
IDROM_save:
	ldi	*ar5++, r1
	sti	r1, *ar4++
	subi	1, r0
	bnz	IDROM_save


	-----------------------------------------------------------------------
	-- If ExecRoot->KernelRoot has not been set, then locate it directly
	-- after the nucleus.

	ldi	*+ar1(ExecRoot.KernelRoot), r0
	cmpi	0, r0
	bnz	CallKStart

	-- In the case of a Low loaded nucleus, the kernel root address will not
	-- yet have been set. The nucleus includes its own size at start, so
	-- add this to its start address to get the next free address.
	-- Place the kernel root there.
	ldi	ar2, r0
	C40CAddress r0
	addi	*ar2, r0			-- calculate kernel root struct
	sti	r0, *+ar1(ExecRoot.KernelRoot)	-- (BPTR) address and save in
						-- execroot.

	-----------------------------------------------------------------------
	-- Initialise C PCS conformant world
	--
	-- kernel called thus:
	-- 	void Kstart(Channel bootlink, word *nucbase)
	--
	-- On entry:
	--	AR0 = peri map
	--	AR1 = execroot
	--	AR2 = nucleus address (WPTR)
	--	AR3 = CPCR address of boot link

CallKStart:

	-- Setup initial C stack.
	_test _false [
		-- This is a FALLING stack from top of internal RAM.
		ldhi	0x30, R_USP	-- 0x002f ffff
		subi	1, R_USP
	][
		-- Falling stack using the dispatch stack for initialisation.
		-- This relies on the initial kernel thread NEVER blocking
		-- and interrupts NOT being enabled until a new C addressable
		-- stack has allocated from an initialised memory system.
		ldi	ExecRoot.DispatchStack + DISPATCHSTACKSIZE - 1, R_USP
		addi	ar1, R_USP
	]

	-- All registers set the flags.
	or	ST_SET_COND, R_ST

	-- Module table pointer not required by kernel.
	
	-- Setup arguments and root structure pointer.

	-- Bootlink is now transfered as WPTR to bootlinks control reg.
	ldi	ar3, R_A1			-- bootlink is arg 1

	-- Nucleus is a word address.
	ldi	ar2, R_A2			-- nuc base is arg 2

	-- Jump to initial kernel module (kmodule)
	-- jmp addr = *(GetNucBase() + 1) + (GetNucBase() + 1) + sizeof(Module)

	-- Point at kernel slot.
	addi	1, ar2

	-- Convert kernel rptr to address of kernel.
	ldi	*ar2, ar1	-- get kernel rptr - offset to kernel

	lsh	-2, ar1		-- convert to number of words
	addi	ar2, ar1	-- add in address of rptr

	-- Step over module header (.sizeof in terms of bytes).
	addi	Module.sizeof / 4, ar1

	tstb	HW_PseudoIDROM, r9
	bnz	NoDropConfig
	-- End of bootstrap so drop TIM-40 module config line.
	ldi	IIF_TYPE3, ar2
	ldi	ar2, iif
NoDropConfig:

	-- Jump to startup code.
	b	ar1


	-- notes true size of execroot in c40boot.s
	// 'c40 'execroot 'size 'is ExecRoot.sizeof ('in 'bytes)


-- End of c40boot.a
@


1.22
log
@fix for addressability problems when using hi memory - onchip ram based
initial stack was no good - replaced with Execroot based stack.
@
text
@d471 1
a471 1
	ldilt	0,      R_BASE			-- and if not, start base address at 0
d479 2
a480 2
	ldigt   ar1,    R_BASE
	bgt	SetAddressBase			-- If strobe extendes beyond end of block, then use strobe
d678 1
a678 1
swi
@


1.21
log
@removed HUNTDBG option - no longer a bug and it was confusing.
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.20 1993/08/16 08:48:56 richardp Exp $
d21 3
d629 14
a642 4
	-- Setup initial C stack, this is a FALLING stack from top of
	-- internal RAM.
	ldhi	0x30, R_USP	-- 0x002f ffff
	subi	1, R_USP
d678 1
a678 1

@


1.20
log
@memory sizing even when noTCLK0Reset
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.19 1993/08/16 08:39:17 richardp Exp richardp $
d21 3
d235 1
a235 5
	_test _defp 'HUNTIDBUG [
		b	InitC40
	][
		b	onebitread
	]
@


1.19
log
@Automatic memory sizing
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.18 1993/07/02 09:57:31 nickc Exp $
d21 3
d330 1
a377 1
NoTCLK0Reset:
@


1.18
log
@removed fix for SANG board
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.17 1993/04/27 11:51:21 nickc Exp nickc $
d21 3
d291 1
a291 2
	-- Init processor from contents of ID ROM.
	-- Load base addr of internal periperal map.
d293 1
d299 2
a300 2
	ldi	*+ar5(IDROM.GBCR), r0
	sti	r0, *+ar0(gmem_control)
d327 46
@


1.17
log
@fixed for SANG board IDROM read
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.16 1993/04/21 08:52:34 nickc Exp nickc $
d21 3
a236 9
	-- For SANG board, IDROM only works if you have written to the
	-- SRAM on that strobe.
	ldhi    0x0010, ar4
        or      0x0004, ar4	-- now points to LMCR
        ldhi    0x3D39, r1
        or      0xFFF0, r1      -- enable strobe 1
        sti     r1, *ar4
        ldhi    0x7000, ar4
        sti     r1, *ar4        -- enable IDROM by writing to it !
@


1.16
log
@Changed the way IR0 is calculated.
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.15 1993/04/16 12:25:26 nickc Exp nickc $
d21 3
d236 8
a243 2
	sti     r0, *ar2	-- yuck yuck yuck (a sort of no-op)

@


1.15
log
@Four bit IDrom bugs fixed.  (You got it wrong again Paul!)
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.14 1993/04/01 16:59:34 nick Exp nickc $
d21 3
d231 4
d281 1
a281 1
	b	fourbitread
d382 1
a382 1
	bne	ValidLStrobe
d386 42
d429 1
a429 1
ValidLStrobe:
a437 17
	-- R_BASE (IR0) defines the base of RAM addressable by C (via byte
	-- pointers). Normally this is set to the base of the strobe we
	-- are using for C data, but if the strobe base + its size is in
	-- the first quadrant of memory, then the address base is set to 0. 
	-- This allows us to address the on-chip RAM and peripherals
	-- directly from C.

	ldi	ar1, R_BASE	-- default to base of strobe.
	ldhi	0x402f, ar4
	or	0xf000, ar4
	cmpi	ar4, ar6	-- compare end with top of first quadrant+3068k
	bgt	SetAddressBase
	ldhi	0x002f, ar4	-- set base to 3068k
	or	0xf000, ar4
	ldi	ar4, R_BASE

SetAddressBase:
@


1.14
log
@If the local RAM is in the first 3Mwords of quadrant 2, the address base
is set to 0x002ff0000 to allow both it and the on-chip RAM to be addressed.
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.13 1993/02/05 13:25:09 paul Exp $
d21 4
d230 1
d245 1
d247 1
a247 1
	rptb	endblock1
d259 1
d261 1
a261 1
	rptb	endblock2
@


1.13
log
@fixed HW_Disable cache bug
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.12 1993/01/21 09:56:30 paul Exp $
d21 3
d95 1
d390 9
a398 3
	ldhi	0x4000, ar4
	cmpi	ar4, ar6	-- compare with top of first quadrant
	ldile	0, R_BASE	-- set to zero if in first quadrant
@


1.12
log
@Bootstrap now records HWConfig word in the ExecRoot for the networking
software to use as the default when booting other processors. It gets
this info via the Fn GetHWConfig().
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.11 1992/11/20 15:46:23 paul Exp $
d21 5
d93 1
a93 1
	bz	DontEnableCache
@


1.11
log
@if the base+size of strobe used as data is within the first quadrant of
memory, then set IR0 address base as zero to keep ONCHIP RAM and periperals
in addressablity
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.10 1992/11/18 14:33:45 paul Exp paul $
d21 5
d386 4
@


1.10
log
@big changes. Added support for HW_Config word to select the nucleus load
address, the C address base IR0 is setup correctly, and full C40Word/CAddress
macros are used. The nucleus load address is now passed as a word pointer,
and also saved in the ExecRoot as a WPTR.
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.9 1992/10/09 16:51:44 nickc Exp $
d21 6
d352 1
d357 1
d368 13
a380 3
	-- R_BASE (IR0) is defined to be base of RAM addressable by C (via byte
	-- pointers). This is the same as the ExecRoot's location.
	ldi	ar1, R_BASE
a387 1
	sti	R_SSP, *+ar1(ExecRoot.SystemStack)
@


1.9
log
@fixed test for contents of idrom's LBASE0 value
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.8 1992/09/25 09:35:13 paul Exp nickc $
d21 3
d56 1
d67 1
a67 1
	-- Write Boot Acknowledge word to booter
d70 1
a70 1
	-- read Hardware Config word from booter
d81 1
a81 1
	-- if we are replacing existing IDROM, then we should still go through
d90 1
a90 1
	-- setup ar1 to control IDROM recall and mapping
d94 1
a94 1
	-- If we are being sent a IDROM look-alike via the link
d99 2
d108 1
a108 1
	-- initial size read into r1 is saved immediately
d115 2
d118 1
a118 1
	-- Copy ID-ROM contents to on chip RAM
d149 1
a149 1
	-- find out what type of IDROM is being used
d154 2
d199 2
d250 3
a253 2
	-- Init processor from contents of ID ROM
	-- load base addr of internal periperal map
d287 1
a289 3
_test _defp 'STANDALONE [
	-- Expects simple boot protocol of SIZE in words
	-- followed by SIZE words of data.
d291 8
a298 39
	-- STANDALONE code will onluy work with local bus strobe 0
	-- memory. This code is depreciated and is only left in as example
	-- code.
	ldhi	0x30, ar2		-- postion to load code at

	-- Download standalone image to RAM address pointed at by ar2
	ldi	*+ar3(1), r0		-- read # words of image to download
	ldi	ar2, ar4		-- ar2 points to nucleus load area

	-- size not part of image and is specified in terms of words not bytes
	subi	2, r0			-- initialise for rpts

	-- Download image
	ldi	*+ar3(1), r1		-- initialise r1 for parallel loop
	rpts	r0			-- loops r0 + 1
		ldi	*+ar3(1), r1 || sti	r1, *ar4++
	sti	r1, *ar4++		-- store final value

	-- print booted message and jump to first word of downloaded image

	addi	2, ar3, ar5		-- ar5 = boot links output port

	-- print booted  message
	-- ldaddr pseudo op
	laj	4		-- get absolute address of message into AR1
		ldi	message - 3, ar1
		addi	r11, ar1
		ldi	*ar1++,r0	-- get size of message-1 into r0

	ldi	*ar1++, r1		-- initialise r1
	rpts	r0
		ldi	*ar1++, r1 || sti	r1, *ar5

	tstb	HW_PseudoIDROM, r9
	bnz	NoDropConfig
	-- end of bootstrap so drop TIM-40 module config line
	ldi	IIF_TYPE3, r0
	ldi	r0, iif
NoDropConfig:
d300 1
a300 12
	-- jump to downloaded code
	b	ar2

message:
	word	eom1 - 2		-- size of message
	word	"Downloaded standalone image, executing...\\n"
eom1:

][

	-- Setup basic memory map

d307 2
d310 1
a310 1
--	poss. dummy block	Used to stitch together noncontigous strobe 0/1
d333 5
a337 3
	-- Depending on memory configuration choose nucleus location
	-- record location in execroot.
	-- default to local bus strobe 0
d339 1
d343 2
a344 24
_if _false [
	-- @@@@@@ no support for loading NUCLEUS ON GLOBAL BUS yet implemented
	-- @@@@@@ ExecRoot.Nucleus would have to be changed to a word pointer.
	-- and root structure not placed directly after nucleus image.

testnext0:
	tstb	HW_NucleusGlobalS0, r9
	bz	testnext1
	ldi	*+ar5(IDROM.GBASE0), ar1
	b	SaveNucPos

testnext1:
	tstb	HW_NucleusGlobalS1, r9
	bz	testnext2
	ldi	*+ar5(IDROM.GBASE1), ar1
	b	SaveNucPos

testnext2:
]

	-- default to loading nucleus after execroot structure
	-- on local bus strobe 0, but also check its validity.

	-- if local strobe 0 is invalid or empty then use strobe 1
d347 1
a347 5
	bne	ValidLStrobe0
--	beq	UseLStrobe1
--	ldi	*+ar5(IDROM.LSIZE0), ar2
--	cmpi	0, ar2
--	bne	ValidLStrobe0
a349 1
ValidLStrobe0:
d351 1
d360 4
d382 36
d419 4
a422 2
	C40CAddress ar2, ar4
	sti	ar4, *+ar1(ExecRoot.Nucleus)
d424 3
d447 1
d461 19
d482 1
a482 1
	-- kernal called thus:
d484 6
a489 6
	-- We will use the DispatchStack as our stack space
	-- temporarily until the first real thread is fired up.
	-- AR0 = peri map
	-- AR1 = execroot
	-- AR2 = nucleus address (WPTR)
	-- AR3 = CPCR address of boot link
d491 1
d493 1
a493 1
	-- internal RAM
d497 1
a497 4
	-- Setup byte address base
	ldi	0, R_BASE

	-- All registers set the flags
d500 1
a500 1
	-- Module table pointer not required by kernel
d502 1
a502 4
	-- Setup arguments and root structure pointer

	-- Bootlink is now transfered as WPTR to bootlinks control reg
	ldi	ar3, R_A1
d504 2
a505 1
	C40CAddress	ar2, R_A2		-- nuc base as arg 2
d507 2
a508 3
	addi	R_A2, *ar2, R_A3		-- calculate kernel root struct
	sti	R_A3, *+ar1(ExecRoot.KernelRoot) -- (BPTR) address and save in
						-- execroot for fast ref.
d513 1
a513 1
	-- Point at kernel slot
d516 1
a516 1
	-- Convert kernel rptr to address of kernel
d522 1
a522 1
	-- Step over module header (.sizeof in terms of bytes)
d527 1
a527 1
	-- end of bootstrap so drop TIM-40 module config line
d532 1
a532 1
	-- Jump to startup code
a537 1
]
@


1.8
log
@changed to use gexec.m and store the initial address of the system stack
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.7 1992/09/23 17:20:15 paul Exp paul $
d21 3
a394 3
	beq	UseLStrobe1
	ldi	*+ar5(IDROM.LSIZE0), ar2
	cmpi	0, ar2
d396 4
@


1.7
log
@added moveable execroot support (tvtp)
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.6 1992/07/08 16:11:01 paul Exp $
d21 3
d45 1
a45 1
include c40exec.m
d47 2
d400 2
a401 2
	-- Setup address of ExecRoot
	-- This is held in the tvtp expansion register
d404 1
a404 1
	-- Use the base memory address as the execroot pointer
d408 1
a408 1
	-- position system stack pointer directly after execroot.
d414 1
d416 2
a417 2
	-- align interrupt vectors to 0x200 word boundary after execroot
	-- and system stack
d430 1
a430 1
	-- Expects simple boot protocol of SIZE in words
@


1.6
log
@added booted acknowledge word
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.5 1992/06/26 17:56:51 paul Exp paul $
d21 3
a267 11
	-- Other std initialisations of C40

	SysStack R_SSP		-- point system stack to std address

	TrapVectors ar4		-- setup std trap vector address
	ldpe	ar4, tvtp

	InterruptVectors ar4	-- setup std interrupt vector address
	ldpe	ar4, ivtp


a270 1
	-- @@@@@@ extend protocol to add peek / poke / exec / boot on cmd?
d272 4
a275 1
	NucPosition ar2			-- postion to load code at
a320 2
	-- Depending on memory configuration choose nucleus location
	-- record location in execroot
d322 1
a322 3
	-- @@@@@@ should take any static RAM on global bus into account.
	-- ExecRoot + nucBBBleus should be held in first words of DRAM
	-- on global bus if it exists and not take up precious, expensive SRAM.
d324 29
a352 1
	GetExecRoot ar1
d354 4
d359 1
a359 3
	bz	testnext0
	ldi	*+ar5(IDROM.LBASE0), ar2
	b	SaveNucPos
d361 5
d369 1
a369 1
	ldi	*+ar5(IDROM.GBASE0), ar2
d375 1
a375 1
	ldi	*+ar5(IDROM.GBASE1), ar2
d379 2
d382 1
a382 2
	-- on local bus strobe 0.
	NucPosition ar2
d384 10
a393 3
SaveNucPos:
	-- @@@@@@ ExecRoot.Nucleus MUST be changed to a word pointer.
	-- and/or root structure not placed directly after nucleus image.
d395 26
d468 2
a469 2
	-- Setup C stack
	-- FALLING stack from top of internal RAM
@


1.5
log
@added config line assert/de-assert as per TIM-40 std
@
text
@d16 1
a16 1
-- RcsId: $Id: c40boot.a,v 1.3 1992/06/15 13:39:51 paul Exp paul $
d21 3
d51 3
@


1.4
log
@four bit IDROM read and config line set/unset added
@
text
@a0 3
_def 'HUNTIDBUG 1	-- fail to read penultimate word from hunt board.
			-- @@@@@@ fixed in production board.

a38 1

d46 1
a46 6
	-- disabled.

	-- enable cache for fast boot
	or	ST_CE, st

	-- Remember upon entry AR3 points to the cpcr of the link we were
d49 2
a50 1
	ldperimap	 ar0	-- base of peripheral map
d52 14
a65 1
	-- start of bootstrap so raise config
d69 24
d96 3
a98 2
	ldaperi timer0_control ar1	-- control addr for TCLK0 pin.
	-- remeber what type of IDROM is being used
d101 2
a102 2
	-- Init sequence for IDROM load
	-- enables the use of EEPROMS as their recall can be activated with
d126 2
a127 2
	bz	fourbitread	-- TCLK0 low = 1 bit ID ROM
				--	 hi  = 4 bit ID ROM
d172 2
a173 1

d180 1
a180 1
	and	0xf, r2
a188 1

a201 1

d226 1
a226 1
	OnChipRAM ar4		-- Std IDROM's always load first block here
d229 1
a229 1
	ldi	*+ar4(IDROM_GBCR), r0
d232 2
a233 2
	-- local mem reg
	ldi	*+ar4(IDROM_LBCR), r0
d237 1
a237 1
	ldi	*+ar4(IDROM_TIMER0_PERIOD), r0
d241 1
a241 1
	ldi	*+ar4(IDROM_TIMER1_PERIOD), r0
d244 3
a246 2
	ldi	*+ar4(IDROM_TIMER1_CTRL), r0
	lsh	-16, r0			-- Timer1 actually in upper 16 bits
d253 2
d257 1
a258 1

a268 3
	-- Depending on memory configuration choose nucleus location
	-- record location in execroot @@@@@@
	GetExecRoot ar1
d270 1
a270 4
	ldi32	0x300440 ar2
	C40CAddress ar2, ar4
	sti	ar4, *+ar1(ExecRoot.Nucleus)

d275 4
a278 2
	-- Download nucleus to RAM address pointed at by ar2
	ldi	*+ar3(1), r0		-- read # bytes of image to download
a280 1
_test _defp 'STANDALONE [
d283 1
a283 5
][
	sti	r0, *ar4++		-- save size as part of image
	lsh	-2, r0			-- / sizeof(word) - convert to # words
	subi	3, r0			-- initialise for rpts
]					-- -1 size, -2 rpts and || correction
a289 2

_test _defp 'STANDALONE [
d305 3
a307 1
	-- end of bootstrap so drop config
d310 1
d321 56
a376 2
	-- @@@@@@ update execroot with contents of ID-ROM
	-- ExecRoot->IDROM.xxx
a377 1
	-- @@@@@@ save bootlink, + poss nucleus loadpoint
d379 13
d442 3
a444 1
	-- end of bootstrap so drop config
d447 1
d451 4
@


1.3
log
@added IDROM support
@
text
@d19 1
a19 1
-- RcsId: $Id: c40boot.a,v 1.2 1992/05/14 08:20:57 paul Exp $
d24 3
d60 4
a65 2
	-- start of bootstrap so raise config @@@@@@

d67 2
a68 3

	-- find what type of IDROM is being used
	ldaperi timer0_control ar1
a69 3
	and	tcr_datin, r0	-- Timer 0 DATAIN (TCLK0) bit
	bz	fourbitidrom	-- TCLK0 low = 1 bit ID ROM
				--	 hi = 4 bit ID ROM
a73 1
onebitidrom:
d75 1
a75 1
	ldi	2000, r0		-- 200uS delay on 50Mhz C40
d77 1
a77 1
	subi	1, r0
d81 1
a81 1
	ldi	2000, r0		-- 200uS delay on 50Mhz C40
d83 1
a83 1
	subi	1, r0
d87 1
a87 1
	ldi	2000, r0		-- 200uS delay on 50Mhz C40
d89 1
a89 1
	subi	1, r0
d94 5
d143 47
a189 10
-- @@@@@@ four bit idrom not yet supported.
-- @@@@@@ add code here to download it into the internal RAM.
fourbitidrom:
	_if _defp 'SYSDEB [
		ldaperi	port3_output ar0
		ldi	999, r0
		sti	r0, *ar0
	]
	int	0x66ffffff	-- jtag halt
	b	fourbitidrom
d284 3
a286 1
-- end of bootstrap so drop config @@@@@@
d352 3
a354 1
-- end of bootstrap so drop config @@@@@@
@


1.2
log
@removed unecessary software wait states from mem ctrl regs
@
text
@d1 3
d14 1
a14 1
--		The nucleus load position is calulated, the execroot updated
d19 1
a19 1
-- RcsId: $Id: c40boot.a,v 1.1 1992/04/21 09:54:56 paul Exp $
d24 3
d33 3
a36 1
include c40mmap.m
d44 1
d49 3
d57 1
a57 2
	-- @@@@@@ Copy ID-ROM contents to on chip RAM
	_if _defp '__TIM40 [
d59 1
a59 1
	]
d61 1
a61 3
	-- @@@@@@ initialise C40 from ID-ROM contents
	_test _defp '__TIM40 [
		-- memory control regs
d63 62
a124 1
		-- timer 1 if required
d126 1
a126 1
		-- IDROM initialisation chain execution
d128 2
a129 2
		-- map local bus instead of IDROM
		stik	tcr_datout, *+ar0(timer0_control)
d131 2
d134 2
a135 2
		-- map local bus instead of IDROM
		stik	tcr_io, *+ar0(timer0_control)
d137 8
a144 22
		-- default mem ctrl regs to Hunt board
		_test _true [
			-- local and global bus control word
			ldi32	0x1e4a4000 ar4
		][
			-- with 2 wait states added
			-- local and global bus control word
			ldi32	0x1e4a4230 ar4
		]
		sti	ar4, *+ar0(gmem_control)	-- global
		sti	ar4, *+ar0(lmem_control)	-- local

		-- set timer 1 for dynamic RAM refresh
		ldi	0x80, ar4		-- refresh cycle time
						-- 15.625uS pulse
		sti	ar4, *+ar0(timer1_period)

		-- start RAM refresh by starting timer output on clk1 pin
		-- ldhi	(tcr_dbgcont1 | tcr_dbgcont2) >> 16, ar4
		ldhi	0b11 << 14, ar4
		or	tcr_func | tcr_go | tcr_hld | tcr_clksrc, ar4
		sti	ar4, *+ar0(timer1_control)
d146 37
d184 1
d196 1
a196 1
	-- record location in execroot
d199 7
a205 15
	_test _defp '__TIM40 [
		-- @@@@@@ record location in execroot

	][
		ldi32	0x300440 ar2
		C40CAddress ar2, ar4
		sti	ar4, *+ar1(ExecRoot.Nucleus)
	]

	_if _defp '__TIM40 [
		-- @@@@@@ update execroot with contents of ID-ROM
		-- ExecRoot->IDROM.xxx
	]

	-- @@@@@@ extend protocol to add peek / poke / exec / boot on cmd
a207 2

	-- Setup download
d211 4
d218 1
a218 1
					-- -1 size, -2 rpts and || correction
d226 30
d270 3
a272 9
	_test _false [
		addi	ExecRoot.DispatchStack + DISPATCHSTACKSIZE, ar1, R_USP
		ldi	R_USP, R_FP	-- frame pointer
		ldi	0, R_USE	-- bogus stack base
	][
		-- falling stack from top of internal RAM
		ldhi	0x30, R_USP
		subi	1, R_USP
	]
d284 2
a285 9
	_test _true [
		-- Bootlink is now transfered as WPTR to bootlinks control reg
		ldi	ar3, R_A1
	][
		-- Convert cpcr address of bootlink to link number for arg 1
		subi	ar0, ar3, R_A1		-- subtract periperal base addr
		subi	port0_control, R_A1	-- subtract first cpcr addr
		lsh	-4, R_A1		-- / by size of port group (16)
	]
d308 2
d312 1
a312 1

@


1.1
log
@Initial revision
@
text
@d16 1
a16 1
-- RcsId: $Id$
d20 3
a22 1
-- RcsLog: $Log$
d24 1
d66 8
a73 1
		ldi32	0x1e4a4230 ar4	-- local and global bus control word
d78 2
a79 1
		ldi	0x7d, ar4		-- refresh cycle time
@
