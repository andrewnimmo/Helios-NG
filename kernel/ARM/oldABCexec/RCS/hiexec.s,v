head     1.1;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @! @;


1.1
date     91.03.10.23.53.33;  author paul;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@        TTL  ARM Helios Executive (System independent routines) > hiexec/s
        SUBT Copyright (c) 1989, Active Book Company, Cambridge, United Kingdom
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ARM HELIOS Executive (hi-level Nucleus support routines)
        ;
        ; Author:       James G Smith
        ;
        ; Notes:
        ; ------
        ; All defined routines available externally will be provided as PCS
        ; function call definitions. A suitable C header file will define the
        ; function prototypes ("mcdep.h" in the Helios kernel source).
        ;
        ; When conforming to the Acorn PCS "a1", "a2", "a3" and "a4" are not
        ; preserved over a procedure call. This should be noted when
        ; constructing assembler that must interface directly with compiled
        ; PCS procedures. Currently certain routines WILL preserve these
        ; registers. This was done to aid debugging during development.
        ;
        ; **** NOTE ****
        ; Some routines expect to be called in USR mode. IRQ/FIQ state is
        ; undefined and depends on the current process. OS mode should be
        ; active for all routines called since they may directly access
        ; Executive workspace (Most routines will preserve r14 over SWI
        ; calls in-case they are executing in SVC mode).
        ;
        ; All access to the lo-level Executive (system dependent) functions
        ; will be via a defined SWI interface.
        ;
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; Printing options

	GET	listopts.s		; listing options

        ; ---------------------------------------------------------------------

                GBLL    badaddress
badaddress      SETL    {TRUE}          ; complain if invalid fn ptr

                GBLL    lopriyield
lopriyield      SETL    {TRUE}          ; allow lo-priority yields

                GBLL    stackcheck
stackcheck      SETL    {FALSE}         ; include stack limit checking in
                                        ; critical functions.

        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------

        !       0,"Processing hiexec.s (Helios Executive interface)"

        !       0,"Code included to preserved ALL registers in PCS"
        ; The PCS wrapper should be removed around routines that call
        ; no other PCS functions. It is possible to call SWIs (since these
        ; are system routines and do NOT conform to the PCS standard). If the
        ; PCS wrapper is removed, the function name need not be stored, since
        ; this is only ever referenced by the state stored on a PCS entry.
        ; This would save a small amount of code space.
        ; The above comment (about preserving a1-a4) is TRUE, but for the
        ; moment is is probably safer to preserve all possible state.

        GET     fixes.s
        GET     basic.s
        GET     arm.s
        GET     exmacros.s
        GET     structs.s
	GET	module.s
        GET     exstruct.s
        GET     SWIinfo.s
        GET     ROMitems.s
        GET     hardABFP.s
        GET     manifest.s
        GET     config.s

        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; lo-level functions
        ; ------------------
        ; word  ExecRoot(void) ;
        ; void  ExecInit(void) ;
        ; word  _cputime(word) ;
        ; word  _ldtimer(word) ;
        ; void  ResetCPU(void) ;
        ; void  ResetLink(void) ;
        ; void  Dispatch(SaveState *p) ;
        ; void  ExecHalt(void) ;
        ; void  MoveBlock(word destination,word source,word length) ;
        ; word  ExchangeModTab(word dp) ;
        ; word  After(word arg0,word arg1) ;
        ;
        ; ---------------------------------------------------------------------
        ; hi-level functions
        ; ------------------
	; word       System(WordFnPtr func,word arg0,word arg1,word arg2) ;
        ; void       Suspend(SaveState **pp) ;
        ; void       Resume(SaveState *p) ;
        ; void       Stop(void) ;
        ; void       Yield(void) ;
        ; void       Sleep(word endtime) ;
        ; word       Timer(void) ;
        ; word       CallWithModTab(word a0,word a1,VoidFnPtr fn,word *mtab) ;
        ; word      *CreateProcess(word *stack,VoidFnPtr entry,VoidFnPtr exit,
        ;                          word *descript,word argsize) ;
        ; void       EnterProcess(word *args,word pri) ;
        ; void       RunqPtrs(SaveState **p,word pri) ;
        ; void       LinkTx(word size,struct LinkInfo *link,void *buf) ;
        ; SaveState *AbortLinkTx(struct LinkInfo *link) ;
        ; void       LinkRx(word size,struct LinkInfo *link,void *buf) ;
        ; SaveState *AbortLinkRx(struct LinkInfo *link) ;
        ;
        ; new additions
        ; -------------
        ; byte      *StoreSize(byte *mem_start) ;
        ; void       InitEventHandler(VoidFnPtr handler) ;
	; void       InitShutdownHandler(VoidFnPtr handler) ;
        ; word       SaveCPUState(SaveState *) ;
        ; void       RestoreCPUState(SaveState *) ;
        ; word       GetPhysPri(void) ;
        ; word       GetPhysPriRange(void) ;
        ; word       GetRootBase(void) ;
        ; word       GetNucleusBase(void) ;
        ;
        ; new system error vector patching
        ; --------------------------------
        ; int        DefineExecErrorHandler(VoidFnPtr handler) ;
        ;
        ; new ROM support
        ; ---------------
        ; int        GetROMItem(word loc,word *index,ITEMstructure **item) ;
        ; int        GetROMConfig(Config *ConfLoc) ;
        ;
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------

a1              RN      r0              ; PCS register based argument
a2              RN      r1              ; PCS register based argument
a3              RN      r2              ; PCS register based argument
a4              RN      r3              ; PCS register based argument

v1              RN      r4              ; C "register" variable
v2              RN      r5              ; C "register" variable
v3              RN      r6              ; C "register" variable
v4              RN      r7              ; C "register" variable
v5              RN      r8              ; C "register" variable

v6              RN      r9              ; use of "v6" is deprecated by "dp"

        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; "__stack_overflow" (called "x$stackoverflow" in the Acorn ANSI
        ; library, and the code generated by the NorCroft ARM C compiler)
        ; This "function" is entered when there is insufficient stack for the
        ; procedure entry. PCS functions should claim all the stack they will
        ; need on procedure entry (to ensure stack overflow does NOT occur
        ; within a procedure).

        IMPORT  __stack_overflow,EXCEPTION
	IMPORT	__stack_overflow_1,EXCEPTION
	LIB

        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; lo-level external interface -----------------------------------------
        ; ---------------------------------------------------------------------
        ; word ExecRoot(void) ;
        ; Return the address of the Executive ExecRoot data structure.
        ;
ExecRoot	FnHead
        MOV     ip,lk
        SWI     exec_FindExecRoot
        ; a1 = address of ExecRoot structure
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; void ExecInit(void) ;
        ; Initialise the ExecRoot data structure and the server IO device.
        ; In all current implementations server IO is via a link adaptor.
        ; This function should ideally be moved to the lo-executive, and
        ; provided as a SWI.

ExecInit	FnHead
        STMFD   sp!,{lk}        ; makes function call

        SWI     exec_FindExecRoot
        MOV     a4,a1                   ; a4 = ExecRoot structure address

        MOV     a1,#&00000000           ; NULL

        ; we need to initialise the correct number of ProcessQs
        MOV     a3,#NumberPris          ; number of priority levels
        ADD     a2,a4,#ExecRoot_queues  ; base address of queues
        ; initialise the correct number of process queues
init_rq_loop    
        STR     a1,[a2,#ProcessQ_head]  ; initialise the head of the queue
        STR     a2,[a2,#ProcessQ_tail]  ; the tail points at the head
        ADD     a2,a2,#ProcessQ_size    ; and step onto the next queue
        SUBS    a3,a3,#&01
        BNE     init_rq_loop

        ; Clear (zero) all the other "ExecRoot" fields
        STR     a1,[a4,#ExecRoot_timerQ]        ; Timer queue has no "tail"

        STR     a1,[a4,#ExecRoot_timer]         ; micro-second timer
        STR     a1,[a4,#ExecRoot_cstimer]       ; centi-second timer
        STR     a1,[a4,#ExecRoot_timeslice]     ; useconds remaining to process
        STR     a1,[a4,#ExecRoot_pri]           ; current process priority
        STR     a1,[a4,#ExecRoot_hipri]         ; highest priority that can run
        STR     a1,[a4,#ExecRoot_flags]         ; process state flags
        STR     a1,[a4,#ExecRoot_idleLog]       ; number of seconds IDLE
        STR     a1,[a4,#ExecRoot_fparea]        ; this process has NOT used FP
        STR     a1,[a4,#ExecRoot_initial_dp]    ; this process has NO dp
	[	(intcount)
	STR	a1,[a4,#ExecRoot_IRQoffcount]	; count of IRQ disable calls
	]

        ; Reference the nucleus device driver process.
        ; (At this stage we do NOT know what or where it is, so leave as NULL)
        STR     a1,[a4,#ExecRoot_devhand]
	[	(shutdown)
	; Reference the nucleus device driver shutdown process.
	; (At this stage we do NOT know what or where it is, so leave as NULL)
	STR	a1,[a4,#ExecRoot_shutdownhand]
	]	; EOF (shutdown)

	[	(memmap)
	; We should read the current (default) MEMMAP state and initialise
	; the ExecRoot suitably.
	MOV	a1,#HWReg_MEMMAP		; MEMMAP_regs soft-copy index
	MOV	a2,#&00000000			; no bits to clear
	MOV	a3,#&00000000			; no bits to set
	SWI	exec_HWRegisters
	STR	a2,[a4,#ExecRoot_memmap]	; current MEMMAP state defined
	]	; EOF (memmap)

        SWI     exec_InitBackplane		; init standard hardware
        ; V clear = initialised OK
        ; V set   = initialisation failed (no link adaptor?)
        !       0,"Include error generation when backplane init fails"

        SWI     exec_InitClock			; init and start system timer

        LDMFD   sp!,{pc}^

        ; ---------------------------------------------------------------------
        ; word _cputime(void) ;
        ; Return the current number of centi-second clock ticks
        ;
_cputime	FnHead
        MOV     ip,lk
        SWI     exec_CPUTime                    ; a1 = current num clock ticks
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; word _ldtimer(word);
        ; Return the current number of centi-second or micro-second clock ticks
        ;
_ldtimer	FnHead
        MOV     ip,lk
        MOV     a2,a1                           ; preserve entry flag
        SWI     exec_FindExecRoot               ; a1 = ExecRoot structure
        TEQ     a2,#&00000000                   ; 0 = us; !0 = cs
        LDREQ   a1,[a1,#ExecRoot_timer]         ; micro-seconds
        LDRNE   a1,[a1,#ExecRoot_cstimer]       ; centi-seconds
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; void ResetCPU(void) ;
        ; Reset the ARM
        ;
ResetCPU	FnHead
	MOV	ip,lk
	SWI	exec_ResetCPU
	; only returns if unable to reset this version
	MOVS	pc,ip

        ; ---------------------------------------------------------------------
        ; void ResetLink(void) ;
        ; Reset the single link adapter
        ;
ResetLink	FnHead
        !       0,"ResetLink code to be written"
        MOVS    pc,lk

        ; ---------------------------------------------------------------------
        ; void ExecHalt(void) ;
        ; Terminate Executive execution.
        ; This call should NOT be returned from.
ExecHalt	FnHead
        MOV     a1,#halt_executive
        SWI     exec_ExecHalt       
        ; should NOT return, but if we do... go BANG!
        ERROR   halt_failed,"** FATAL ** Return from ExecHalt call"

        ; ---------------------------------------------------------------------

        ; void MoveBlock(word destination,word source,word length) ;
        ; Move a block of data (byte addressed).
        ; The best system would be to perform word transfers (at least 4 times
        ; quicker) but this relies on the source and destination having the
        ; same byte alignment within the word (We will provide various
        ; optimised copy routines depending on the alignment of the arguments).
        ;
MoveBlock	FnHead
        MOV     ip,sp
        STMFD   sp!,{v1,v2,v3,fp,ip,lk,pc}
        SUB     fp,ip,#&04
        [       (stackcheck)
        CMP     sp,sl
	BLLT	__stack_overflow
        ]

        ; a1 = destination address
        ; a2 = source address
        ; a3 = number of bytes to transfer

	[	{FALSE}
	MOV	v1,r0
	ADR	r0,mbdtxt1
	SWI	exec_Output
	MOV	r0,a2
	SWI	exec_WriteHex8
	ADR	r0,mbdtxt2
	SWI	exec_Output
	MOV	r0,v1
	SWI	exec_WriteHex8
	ADR	r0,mbdtxt3
	SWI	exec_Output
	MOV	r0,a3
	SWI	exec_WriteHex8
	SWI	exec_NewLine
	MOV	r0,v1
	B	mbdovr
mbdtxt1	=	"MoveBlock: source &",&00
mbdtxt2	=	" destination &",&00
mbdtxt3 =	" amount &",&00
	ALIGN
mbdovr
	]

        ; Note: We must ensure that we do NOT generate aborts when the
        ;       source data block is flush with the end of page. This code
        ;       should be OK as long as pages are word-aligned, and not
        ;       byte-aligned.

        CMP     a3,#&00         ; exit immediately if no bytes to move
        LDMEQEA fp,{v1,v2,v3,fp,sp,pc}^

        !       0,"TODO: provide better MoveBlock alignment code"

        ; Initially we word-align with the destination
MoveBlock_Align
        LDRB    a4,[a2],#&01    ; load byte from the source
        STRB    a4,[a1],#&01    ; store at the destination
        SUBS    a3,a3,#&01      ; and decrement the count
        ; If we have no more bytes the exit immediately
        LDMEQEA fp,{v1,v2,v3,fp,sp,pc}^

        TST     a1,#&03         ; check for word-aligned destination
        BNE     MoveBlock_Align ; NOT word-aligned, then transfer another byte

        BICS    a4,a3,#&03      ; a4 = number of words to move * 4
        BEQ     MoveBlock_Spare ; less than one word to go

        ; now move words to the destination
        SUB     a3,a3,a4        ; we will move "a4" bytes of data

        MOVS    v1,a2,LSL #31   ; work out the source alignment
        BIC     v1,a2,#&03      ; word-aligned base address
        ADD     a2,a2,a4        ; and source will move by "a4" bytes
        BCS     MoveBlock_Aligned_2or3

        LDMMIIA v1!,{v3}
        BMI     MoveBlock_Aligned_1

MoveBlock_Aligned_0
        ; Both source and destination are word-aligned
        LDR     v2,[v1],#&04    ; load word from source
        STR     v2,[a1],#&04    ; store word at destination
        SUBS    a4,a4,#&04
        BNE     MoveBlock_Aligned_0
        B       MoveBlock_Spare

MoveBlock_Aligned_1
        ; Source is one byte out
        MOV     v2,v3
        LDMIA   v1!,{v3}
        MOV     v2,v2,LSR #8
        ORR     v2,v2,v3,LSL #24
        STR     v2,[a1],#&04
        SUBS    a4,a4,#&04
        BNE     MoveBlock_Aligned_1
        B       MoveBlock_Spare

MoveBlock_Aligned_2or3
        LDMIA   v1!,{v3}
        BMI     MoveBlock_Aligned_3
MoveBlock_Aligned_2
        ; Source is two bytes out
        MOV     v2,v3
        LDMIA   v1!,{v3}
        MOV     v2,v2,LSR #16
        ORR     v2,v2,v3,LSL #16
        STR     v2,[a1],#&04
        SUBS    a4,a4,#&04
        BNE     MoveBlock_Aligned_2
        B       MoveBlock_Spare

MoveBlock_Aligned_3
        ; Source is three bytes out
        MOV     v2,v3
        LDMIA   v1!,{v3}
        MOV     v2,v2,LSR #24
        ORR     v2,v2,v3,LSL #8
        STR     v2,[a1],#&04
        SUBS    a4,a4,#&04
        BNE     MoveBlock_Aligned_3
MoveBlock_Spare
        ; Copy the spare bytes (less than one word)
        CMP     a3,#&00
        LDMEQEA fp,{v1,v2,v3,fp,sp,pc}^
MoveBlock_Spare_Loop
        LDRB    a4,[a2],#&01    ; load byte from source
        STRB    a4,[a1],#&01    ; store at destination
        SUBS    a3,a3,#&01
        BNE     MoveBlock_Spare_Loop

        ; copy completed
        LDMEA   fp,{v1,v2,v3,fp,sp,pc}^

        ; ---------------------------------------------------------------------
        ; word ExchangeModTab(word dp) ;
        ; Swap current and new module table addresses, returning the old
        ; module table address. This really depends on which register is
        ; allocated to be the global module table pointer (currently dp (v6)).
        ; IRQs should NOT need to be disabled, since any IRQ process will have
        ; its own copy of this register (it forming part of the process
        ; SaveState).
        ;
        ; dp = a1 EOR dp
        ; a1 = a1 EOR dp
        ; dp = a1 EOR dp
        ;
Exchangemodtab	FnHead
        ; Uses no stack and calls no other functions, therefore it does NOT
        ; require the PCS wrapper code as long as we preserve the PCS regs.
        EOR     dp,a1,dp
        EOR     a1,a1,dp
        EOR     dp,a1,dp
        ; a1 = old dp
        ; dp = entry a1
        MOVS    pc,lk

        ; ---------------------------------------------------------------------
        ; byte *StoreSize(byte *mem_start) ;
        ; Calculate the amount of available memory.
        ; This call should be extended so that it will work in a memory managed
        ; system. The "mem_start" address given on entry and the current
        ; process information can be used to return the correct value for this
        ; task.
        ;
        ; in:  a1 = base of free RAM
        ; out: a1 = top of free RAM (last available location + 1)
        ;
StoreSize	FnHead
        MOV     ip,lk
        SWI     exec_SizeMemory
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
	; word FastStoreSize(byte **base)
	; in:	a1 = pointer to word where base address will be placed
	; out:	a1 = size of the FastRAM at the returned base address
FastStoreSize	FnHead
	MOV	ip,lk
	MOV	a3,a1		; address of "base address" variable
	SWI	exec_SizeFastMemory
	; a1 = size of fast memory
	; a2 = address of fast memory
	STR	a2,[a3,#&00]
	MOVS	pc,ip

        ; ---------------------------------------------------------------------
        ; word Timer(void) ;
        ; in:   no conditions
        ; out:  a1 = current ExecRoot time (this is a micro-second value)
        ;
        ; address the ExecRoot structure (via branch table function)
        ; load the timer value from the ExecRoot structure
        ; return timer value to caller
        ;
Timer	FnHead
        MOV     ip,lk                           ; preserve link register
        SWI     exec_FindExecRoot
        LDR     a1,[a1,#ExecRoot_timer]         ; load timer value
        MOVS    pc,ip                           ; exit using entry link reg

        ; ---------------------------------------------------------------------
        ; word CallWithModTab(word arg0,word arg1,VoidFnPtr fn,word *modtab) ;
        ; Call a procedure with the given module table.
        ; in:   a1 = arg0 for function
        ;       a2 = arg1 for function
        ;       a3 = function address
        ;       a4 = module table address to replace current value
        ; out:  no conditions (a1 possibly corrupted)
        ;
        ; replace the current module table addressed with the passed value
        ; execute the function at the passed address
        ; return to caller (restoring our module table pointer)
        ;
        ; Our "current task" module table pointer is held in a register
        ;
CallWithModTab	FnHead
        STMFD   sp!,{dp,lk}

        ; NOTE: this procedure entry stacks the module table pointer
        MOV     dp,a4                           ; define new dp
        MOV     lk,pc                           ; define return address
        MOV     pc,a3                           ; branch to function
        LDMFD   sp!,{dp,pc}^                    ; restore callers dp

        ; ---------------------------------------------------------------------
        ; SaveState *TimerQHead(void) ;
        ; Return the process description at the front of the timer queue.
        ;
TimerQHead	FnHead
        MOV     ip,lk
        SWI     exec_FindExecRoot
        ; a1 = address of the ExecRoot data structure
        LDR     a1,[a1,#ExecRoot_timerQ]
        ; a1 = head of timerQ process chain
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; void RunqPtrs(SaveState **p,word pri) ;
        ; Return the head and tail process descriptions for the specified
        ; process queue.
        ;
RunqPtrs	FnHead
        MOV     ip,lk
        MOV     a3,a1
        SWI     exec_FindExecRoot
        ; a1 = address of the ExecRoot data structure
        ; a2 = desired priority level
        ; a3 = address of buffer where we should place the process pointers

        ; copy the pointers to the allocated space
        ADD     a1,a1,#ExecRoot_queues  ; a1 = base address of queue structures
        ADD     a2,a1,a2,LSL #ProcessQ_shift
        LDMIA   a2,{a1,a4}              ; head and tail pointers
        STMIA   a3,{a1,a4}
        ASSERT  (ProcessQ_head = &00)
        ASSERT  (ProcessQ_tail = (ProcessQ_head + &04))
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; void InitEventHandler(VoidFnPtr handler) ;
        ; Register the event handler function with the Executive.
        ;
InitEventHandler	FnHead
        MOV     ip,lk
        ; Register the function
        SWI     exec_DefineHandler
        ; V clear = OK
        ; V set   = FAILED
        !       0,"InitEventHandler: error handling to be done"
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; void InitShutdownHandler(VoidFnPtr handler) ;
        ; Register the shutdown event handler function with the Executive.
        ;
InitShutdownHandler	FnHead
        MOV     ip,lk
        ; Register the function
	[	{FALSE}
        SWI     exec_DefineShutdownHandler
	]
        ; V clear = OK
        ; V set   = FAILED
        !       0,"InitShutdownHandler: error handling to be done"
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; word SaveCPUState(SaveState *) ;
        ; Fill the passed SaveState structure with our current process
        ; description.
        ; Returns:
        ;       0       = Saved (return from "SaveCPUState")
        ;       != 0    = Restored (return from "RestoreCPUState")
        ;
SaveCPUState	FnHead
        ; Copy all the current state into the structure.
        ; The "next" and "endtime" fields should be NULL.
        ; The "a1" register should be set to a non-zero value.

        ; NOTE: This could cause terrible problems if the "0" return
        ;       function de-stacks, since the restored process will
        ;       NOT have a valid stack-frame.

        STR     a2,[a1,#SaveState_a2]
        MOV     a2,a1
        ADD     a1,a2,#SaveState_a3     ; index the rest of the registers
        STMIA   a1,{a3,a4,v1,v2,v3,v4,v5,dp,sl,fp,ip,sp,lk}

        MOV     ip,lk

        ; we should preserve the process "pri" in the SaveState
        SWI     exec_FindExecRoot
        LDR     a3,[a1,#ExecRoot_pri]
        STR     a3,[a2,#SaveState_pri]
        ; we should preserve the process "FP" state in the SaveState
        LDR     a3,[a1,#ExecRoot_fparea]
        STR     a3,[a2,#SaveState_fparea]
        ; the initial module table pointer
        LDR     a3,[a1,#ExecRoot_initial_dp]
        STR     a3,[a2,#SaveState_initial_dp]
	[	(memmap)
	; and the MEMMAP state
	LDR	a3,[a1,#ExecRoot_memmap]
	STR	a3,[a2,#SaveState_memmap]
	]	; EOF (memmap)

        ; NULL the "SaveState" chain pointer and the timeslice end value
        MOV     a1,#&00000000
        STR     a1,[a2,#SaveState_next]
        STR     a1,[a2,#SaveState_endtime]

        ; Place a non-zero value into the "SaveCPUState" return register
        MOV     a1,#&FFFFFFFF
        STR     a1,[a2,#SaveState_a1]   ; return code from restore SaveCPUState

        ; and give a valid PC so we can return cleanly.
        ; Note: We do not want to return to a state that is de-stacking lot's
        ;       of information, so return directly to the caller.
        STR     ip,[a2,#SaveState_pc]
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; void RestoreCPUState(SaveState *) ;
        ; Continue execution from the described process SaveState.
        ; Therefore this function never returns. The restored state is
        ; that described completely by the passed "SaveState" structure.
        ; Nothing is changed.

RestoreCPUState	FnHead
        ; Restore the processor state to that defined in the passed
        ; "SaveState" structure.

        ; This code assumes that the processor mode (or IRQ state) has
        ; not changed since the "SaveCPUState"... since if we are a USR
        ; mode process then we cannot restore the IF and MODE bits in
        ; the PC. This could be achieved by entering SVC mode to perform
        ; the register re-load (SWI exec_EnterSVC).

        MOV     a4,a1
        ; Restore the saved priority
        SWI     exec_FindExecRoot
        LDR     a3,[a4,#SaveState_pri]
        STR     a3,[a1,#ExecRoot_pri]
        LDR     a3,[a4,#SaveState_fparea]
        STR     a3,[a1,#ExecRoot_fparea]
        LDR     a3,[a4,#SaveState_initial_dp]
        STR     a3,[a1,#ExecRoot_initial_dp]
	[	(memmap)
	LDR	a3,[a4,#SaveState_memmap]
	STR	a3,[a1,#ExecRoot_memmap]

	MOV	a1,#HWReg_MEMMAP	; index of MEMMAP soft-copy register
	MOV	a2,#&FFFFFFFF		; a2 = bits to clear (ie. new value)
					; a3 = bits to set
	SWI	exec_HWRegisters	; and update the MEMMAP state
	]	; EOF (memmap)

        ; Reference the saved register set
        ADD     a1,a4,#SaveState_a1
        ; Return to the "SaveCPUState" state
        LDMIA   a1,{a1,a2,a3,a4,v1,v2,v3,v4,v5,dp,sl,fp,ip,sp,lk,pc}^

        ; ---------------------------------------------------------------------
        ; word GetPhysPri(void) ;
        ; Return the priority number for the current process.
GetPhysPri	FnHead
        MOV     ip,lk
        SWI     exec_FindExecRoot
        LDR     a1,[a1,#ExecRoot_pri]
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; word GetPhysPriRange(void) ;
        ; Return the number of the lowest available priority. This is the
        ; number of distinct priority levels (including 0) - 1.
        ;
GetPhysPriRange	FnHead
        MOV     ip,lk
        SWI     exec_NumPris
        SUB     a1,a1,#&01      ; make into a range (top limit)
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; word *GetRootBase(void) ;
GetRootBase	FnHead
        MOV     ip,lk
	; This could be speeded up if we had direct access to the Executive
	; workspace (which is easily obtainable (defined in "execwork.s")).
	; NOTE: This functions is called a LOT of times (constantly by the
	; 	Helios system.
        SWI     exec_RAMBase
        ; a1 = start of available RAM
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; word *GetNucleusBase(void) ;
GetNucleusBase	FnHead
        MOV     ip,lk
        SWI     exec_NucleusBase
        ; a1 = start address of the nucleus code
        MOVS    pc,ip

        ; ---------------------------------------------------------------------

        ; int DefineExecErrorHandler(VoidFnPtr handler) ;
        ; This attaches the function pointer passed onto the system error
        ; vector. This function will be vectored to when either a system
        ; abort or software failure occurs (FP exception, etc.).
        ; The handler function prototype should be as follows:
        ;       void handler(int signum,char *errtext,word *regset,word urcv) ;
        ;
        ; in:   a1 = C handler function
        ; out:  a1 = 0  OK
        ;       a1 = -1 FAILED
DefineExecErrorHandler	FnHead
        MOV     ip,lk
        MOV     a2,a1                           ; handler routine address

	[	{FALSE}
	ADR	a1,deferrtxt
	SWI	exec_Output
	MOV	a1,a2
	SWI	exec_WriteHex8
	SWI	exec_NewLine
	B	deferrovr
deferrtxt
	=	"DefineExecErrorHandler: address = &",&00
	ALIGN
deferrovr
	]

        MOV     a1,#vec_systemError             ; vector number
        SWI     exec_VectorPatch                ; and patch the vector
        MOVVC   a1,#&00000000                   ;  0 = OK
        MOVVS   a1,#&FFFFFFFF                   ; -1 = FAILED
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; int GetROMItem(word location,word *index,ITEMstructure **item) ;
        ; Returns TRUE and the fields updated if a ROM item is found.
        ; Returns FALSE if there are no more ROM items to be read.
        ; in:	a1	= ROM location to search
	;       a2      = pointer to word containing the current index
        ;       a3      = pointer to ITEMstructure pointer
        ; out:  a1 =  0 = no more ROM items
        ;            -1 = more ROM items
GetROMItem	FnHead
        MOV     ip,sp
        STMFD   sp!,{v1,v2,fp,ip,lk,pc}
        SUB     fp,ip,#&04
        [       (stackcheck)
        CMP     sp,sl
        BLLT	__stack_overflow
        ]

        MOV     v1,a2			; v1 = ptr to index word
        MOV     v2,a3			; v2 = ptr to ITEMstructure ptr word

	; User wishes to enumerate the internal and flash ROM contents
	MOV	a2,a1			; CARD location
        LDR     a1,[v1,#&00]    	; desired index
        SWI     exec_FindNEXTItem
        BVS     bad_return
	; a1 = updated index		; next ITEMstructure pointer
	; a2 = base address		; ITEMstructure pointer
	; a3 = length			; length of the complete ITEM
	STR	a1,[v1,#&00]		; index updated for the caller
	STR	a2,[v2,#&00]		; and present the ITEMstructure pointer

        MOV     a1,#&FFFFFFFF   	; -1 (possibly more ROM items)
        LDMEA   fp,{v1,v2,fp,sp,pc}^

bad_return
        MOV     a1,#&00000000   	; no more ROM items
        MVN     a2,a1           	; -1
        STR     a2,[v1,#&00]    	; update index word
        LDMEA   fp,{v1,v2,fp,sp,pc}^

        ; ---------------------------------------------------------------------
        ; int GetROMConfig(Config *ConfLoc) ;
        ; Returns 0 if the system is RAM based.
        ; Otherwise it returns the size of the configuration information.
        ; in:   a1        = pointer to memory address for configuration data
        ; out:  a1 =    0 = RAM based system
        ;            != 0 = size of the configuration information

GetROMConfig	FnHead
        MOV     ip,sp
        STMFD   sp!,{v1,v2,fp,ip,lk,pc}
        SUB     fp,ip,#&04
        [       (stackcheck)
        CMP     sp,sl
        BLLT	__stack_overflow
        ]

        ; We keep the configuration in a special ROM item "etc/config".
        ; All we do is reference this item, and copy the data to the address
        ; passed to us in a1.
        MOV     v1,a1                   ; remember destination address

        ADRL    a1,default_config_name
        SWI     exec_FindROMItem
        MOVVS   a1,#&00                 ; ROM item not found (or RAM system)
        LDMVSEA fp,{v1,v2,fp,sp,pc}^    ; so exit quickly

	LDR	v2,[a1,#OBJECTOffset]	; offset to config information
	LDR	a2,[a1,#OBJECTLength]	; and the size of the config data

        ADD     v2,a1,v2                ; a1 = base address of config info
	; v1 = destination address
	; v2 = source address
	; a2 = size of the defined structure
        MOV     a1,a2                   ; size of information (return value)
	MOV	a3,v2			; source address (work-copy)
	MOV	a4,v1			; destination address (work-copy)
copy_config_loop
        LDRB    ip,[a3],#&01
        STRB    ip,[a4],#&01
        SUBS    a2,a2,#&01
        BNE     copy_config_loop

        !       0,"TODO: etc/config date initialisation"
        ; The "Date" field in the copied configuration information should
        ; be initialised to the CURRENT time (secs since January 1st 1970 GMT)
	; This information can be read from the uController.

	[	{TRUE}
	; The "MyName" field should be a relative pointer to a NULL terminated
	; ASCII string placed at the end of the config structure (updating the
	; size as necessary). If this value is -1 then we should place the
	; unique machine serial number as the processor name. NOTE: The Helios
	; system we are currently using as a 100character limit on the machine
	; name (fixed in multiple places in the source).
	LDR	a3,[v2,#Config_MyName]	; load RPTR to processor name
	ADDS	a3,a3,#&01		; &FFFFFFFF (-1) --> &00000000 (0)
	LDMNEEA	fp,{v1,v2,fp,sp,pc}^	; a1 = size of config info. copied

	[	{TRUE}
	STMFD	sp!,{a1}
	ADR	a1,GC_txt1
	SWI	exec_Output
	LDMFD	sp!,{a1}
	B	GC_ovr1
GC_txt1	=	"GetROMConfig: MyName RPTR = -1",&0A,&00
	ALIGN
GC_ovr1
	]

	; copy the processor identity to "v1" (updating the count)
	SUB	a3,a1,#Config_MyName	; a3 = offset from MyName entry
	STR	a3,[v1,#Config_MyName]	; update the RPTR to the name
	ADRL	a3,default_processor_name	; bodge until uController
copy_config_name_loop
	LDRB	a2,[a3],#&01		; read byte and increment address
	STRB	a2,[a4],#&01		; store byte and increment address
	TEQ	a2,#&00			; check for termination
	ADD	a1,a1,#&01		; increment config size value
	BNE	copy_config_name_loop	; and around again if not NULL
	]

        LDMEA   fp,{v1,v2,fp,sp,pc}^	; a1 = size of config info. copied

default_config_name
        =       "helios/etc/config",null

	; In the real active book, this ASCII string will be generated from
	; the unique serial number held by the uController.
default_processor_name
	=	"/syzygy",null
        ALIGN

        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
	; ------ These functions should NOT be exported from the kernel -------
        ; ---------------------------------------------------------------------
        ; void IntsOn(void) ;
        ; Enable IRQs.
        ;
IntsOn	FnHead
	[	(intcount)
	; It is more sensible, since IRQs are a processor rather than process
	; resource, that IRQ enabling/disabling is performed globally.
	; This call will only descrement the "IRQoffcount" and if this falls
	; to zero it will enable processor IRQs.
	; NOTE: IRQs will be permanently disabled if a process stops with an
	;       out-standing "IntsOff".
	MOV	ip,lk
        SWI     exec_FindExecRoot
	SWI	exec_IntsOff			; ensure IRQs disabled
	LDR	a2,[a1,#ExecRoot_IRQoffcount]	; load current count
	TEQ	a2,#&00000000			; check for IRQs enabled
	SUBNES	a2,a2,#&00000001		; IRQs disabled, so decrement
	STR	a2,[a1,#ExecRoot_IRQoffcount]	; update count
	MOVNES	pc,ip				; leave quick if not enabling
	; we can enable IRQs
	SWI	exec_IntsOn			; enable IRQs (for USR mode)
	BIC	ip,ip,#Ibit			; enable IRQs (for SVC mode)
	MOVS	pc,ip				; return to caller
	|
	... this code is flawed ... SVC call will return with callers IRQ ...
        MOV     ip,lk
        SWI     exec_IntsOn
        MOVS    pc,ip
	]	; EOF (intcount)

        ; ---------------------------------------------------------------------
        ; void IntsOff(void) ;
        ; Disable IRQs.
        ;
IntsOff	FnHead
	[	(intcount)
	; See comment in the "IntsOn" code.
	; This will increment the "IRQoffcount" value and disable processor
	; IRQs.
	MOV	ip,lk
	SWI	exec_FindExecRoot
	SWI	exec_IntsOff			; disable IRQs (for USR mode)
	LDR	a2,[a1,#ExecRoot_IRQoffcount]	; load current count
	ADD	a2,a2,#&00000001		; increment
	STR	a2,[a1,#ExecRoot_IRQoffcount]	; update stored count
	ORR	ip,ip,#Ibit			; disable IRQs (for SVC mode)
	MOVS	pc,ip				; and return to caller
	|
	... this code is flawed ...
        MOV     ip,lk
        SWI     exec_IntsOff
        MOVS    pc,ip
	]	; EOF (intcount)

        ; ---------------------------------------------------------------------
        ; aptr ReadyQBase(pri) ;
        ; Return the ExecRoot structure entry address for the referenced
        ; ready process queue.
ReadyQBase	FnHead
        MOV     ip,lk
        MOV     a2,a1
        SWI     exec_FindExecRoot
        ; a1 = address of the ExecRoot data structure
        ; a2 = desired priority level
        ADD     a1,a1,#ExecRoot_queues  ; a1 = base address of queue structures
        ADD     a1,a1,a2,LSL #ProcessQ_shift
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; SaveState **TimerQAddr(void) ;
        ; Return the address of the timer queue root.
        ;
TimerQAddr	FnHead
        MOV     ip,lk
        SWI     exec_FindExecRoot
        ; a1 = address of the ExecRoot data structure
        ADD     a1,a1,#ExecRoot_timerQ
        ; a1 = address of the timer Q ptr
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; word SetPhysPri(word newpri) ;
        ; Change the current process priority to the given value, returning
        ; the old priority value.
SetPhysPri	FnHead
        MOV     ip,lk
        MOV     a2,a1                   ; remember entry "a1" parameter
        SWI     exec_FindExecRoot
        ; This load/store could be replaced by a SWP instruction
        LDR     a3,[a1,#ExecRoot_pri]   ; old priority
        STR     a2,[a1,#ExecRoot_pri]   ; new priority
        MOV     a1,a3                   ; and return the old
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
	; word ResetKeyState(void) ;
ResetKeyState	FnHead
	MOV	ip,lk
	; Return a bitmap of the Active Book keys held down during RESET.
	; This allows for upto 32 special keys to be processed.
	!	0,"TODO: ResetKeyState"
	MOV	a1,#&00000000
	MOVS	pc,ip

        ; ---------------------------------------------------------------------
        ; void Output(word string) ;
        ; Pass the NULL terminated ASCII string to the server. The data sent
        ; WILL include the terminating NULL.
        ;
Output	FnHead
        MOV     ip,lk
        SWI     exec_Output
        MOVS    pc,ip

        ; void WriteHex8(word number) ;
WriteHex8	FnHead
        MOV     ip,lk
        SWI     exec_WriteHex8
        MOVS    pc,ip

        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        LNK     hiproc.s                        ; process manipulation
@
