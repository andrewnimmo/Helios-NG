head     1.1;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @! @;


1.1
date     91.03.10.23.53.38;  author paul;  state Exp;
branches ;
next     ;


desc
@@



1.1
log
@Initial revision
@
text
@        SUBT    Executive interrupt handling                    > loint/s
        ; Copyright (c) 1989, Active Book Company, Cambridge, United Kingdom.
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ARM HELIOS Executive (interrupt handlers)
        ;
        ; Author:               James G Smith
        ; History:      900810  Split from the main source file "loexec.s"
	;		901219	Added microlink simulation for FP
        ;

	!	0,"TODO: Spend time optimising IRQ handler register usage"

        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
        ; ---------------------------------------------------------------------
exec_IRQ
        ; in:   IRQ mode
        ;       FIQ preserved (from interrupted process)
        ;       IRQ disabled
        ;       irq_r14 processor mode and (return address + 4)
        ;       All registers (other than "irq_r14" and "pc") are preserved
        ;
        ; We wish to enter SVC mode as early as possible (executing IRQ
        ; handlers in SVC) since we can then enable IRQs quickly. To ensure we
        ; do NOT destroy the SVC thread (if any) we must preserve the current
        ; svc_r13 and svc_r14 before over_loading the registers with our stack
	; and return address. When we have completed our SVC thread we should
	; restore the entry SVC state.
        ;
        ; Externally called interrupt handlers must be called with IRQs
        ; disabled since only they know how to clear their IRQ state. This
	; will affect interrupt latency dramatically over that offered by the
	; Executive based interrupt handlers.
	;
	; So that the IRQ handler system can be re-entered we must NOT use
	; the same stack as the current IRQ handler thread (which is executing
	; in SVC mode).
	;
	; NOTE: External IRQ handlers should not really enable IRQs until
	;	they are sure that another IRQ for them will NOT be generated
	;	in the time taken to exit the IRQ handler. They should however
	;	be capable of being re-entered, just that we may run out of
	;	IRQ stack if it recurses too deep.
	;

	!	0,"TODO: Calculate the amount of stack IRQ handlers can use"

	;
        ; Modify the return address so that it is a true value
        SUB     irq_r14,irq_r14,#&04    ; preserving PSR and mode
	[	(newsvc)
	LDR	irq_r13,=top_IRQ_entry	; always setup on entry
	; NOTE: NO MAPPED REGISTERS should be stored on this entry stack
        STMFD   irq_r13!,{r0,r1,r2,r3,r4}
	ASSERT	((5 * &04) = size_IRQ_entry)
	|
	STMFD	irq_r13!,{r0,r1,dp}	; and stack the work registers

        ; Since we do not want to call the interrupt handler with the "dp" of
        ; the interrupted process, we set the "dp = -1". The system error
        ; handler code can then spot an Executive Fatal error (This same
        ; method should be applied to the FIQ code if we ever provide it as
        ; an external source).
        MOV     dp,#-1                  ; for the error handler
	]	; EOF (newsvc)

        ; search for the interrupt source
	[	(hercules :LOR: activebook)
        ; Hercules interrupt structure
        ; ----------------------------
        ; r0 and r1 are available as temporary registers
        ; The only expected IRQ sources here are:
	;
        ;   Timer 0         --> index 0
        ;   Link  1         --> index 1
	;   Microlink rx    --> index 2
	;   Microlink tx    --> index 3
	;   Microlink break --> index 4
	;
	MOV	r1,#INT_regs
	LDR	r0,[r1,#IRQ_control]	; IRQ request register (after mask)

	LDR	r1,=IRQ_vectors
	TST	r0,#INT_TIM		; timer interrupt
	BNE	timer_irq_found
	ADD	r1,r1,#&04		; step onto the next vector (index 1)
	TST	r0,#LINK_interrupt	; transputer link interrupt
	[	(hercmlink)
	BNE	link_irq_found
	ADD	r1,r1,#&04		; step onto the next vector (index 2)
	TST	r0,#INT_MRX		; microlink reception interrupt
	BNE	link_irq_found
	ADD	r1,r1,#&04		; step onto the next vector (index 3)
	TST	r0,#INT_MTX		; microlink transmission interrupt
	BNE	link_irq_found
	ADD	r1,r1,#&04		; step onto the next vector (index 4)
	TST	r0,#INT_MBK		; microlink break interrupt
	]	; end (hercmlink)
	BEQ	no_interrupt
link_irq_found
	; and fall through to process the relevant vector...
	|	; middle (hercules :LOR: activebook)
        ; AB functional prototype interrupt structure
        ; -------------------------------------------
        ; r0 and r1 are available as temporary registers
        ; The only expected IRQ sources here are:
	;
        ;   Timer 0 --> index 0
        ;   Link 1  --> index 1
	;   Link 0  --> index 2 (used as microlink substitute on FP)

        LDR     r1,=int_source          ; not 8bit constant for this board
        LDRB    r0,[r1,#0]              ; get interrupt source reg

        LDR     r1,=IRQ_vectors         ; base of table

        TST     r0,#intsrc_timer        ; timer interrupt request bit
        BNE     timer_irq_found         ; hi-level, interrupt asserted

        ; check for link1 IRQ
        ADD     r1,r1,#&04              ; step onto the next vector (index 1)
        ; we need to check the interrupt sources directly
        MOV     r0,#inmos_link_base     ; hardware base address
        LDRB    r0,[r0,#link_wstatus]
        TST     r0,#linkw_interrupt     ; are TX interrupts enabled
        TSTNE   r0,#linkw_data          ; bit set marks ready state
        BNE     link_irq_found          ; we have a write interrupt

        MOV     r0,#inmos_link_base     ; hardware base address
        LDRB    r0,[r0,#link_rstatus]
        TST     r0,#linkr_interrupt     ; are RX interrupts enabled
        TSTNE   r0,#linkr_data          ; bit set marks data presence
        BNE     link_irq_found          ; we have a read interrupt

	[	(fpmlink)
        ; check for link0 IRQ (used as microlink substitute on FP)
        ADD     r1,r1,#&04              ; step onto the next vector (index 2)
        ; we need to check the interrupt sources directly
        MOV     r0,#ml_link_base     	; hardware base address
        LDRB    r0,[r0,#link_wstatus]
        TST     r0,#linkw_interrupt     ; are TX interrupts enabled
        TSTNE   r0,#linkw_data          ; bit set marks ready state
        BNE     link_irq_found          ; we have a write interrupt

        MOV     r0,#ml_link_base        ; hardware base address
        LDRB    r0,[r0,#link_rstatus]
        TST     r0,#linkr_interrupt     ; are RX interrupts enabled
        TSTNE   r0,#linkr_data          ; bit set marks data presence
        BEQ     no_interrupt            ; interrupt is active high
	|
	B	no_interrupt
	]	; EOF (fpmlink)
        ; and fall through, since we have a read interrupt
link_irq_found
	]	; EOF (hercules :LOR: activebook)
timer_irq_found
        ; and fall through (index 0 is at the base address)
        ; r0 = undefined
        ; r1 = vector address
        MOV     r0,irq_r14
        ORR     irq_r14,r1,#(Ibit :OR: SVCmode) ; SVC mode, IRQs disabled
        AND     r1,r0,#Fbit                     ; get callers FIQ state
        ORR     irq_r14,irq_r14,r1              ; and add in callers FIQ state
        ; r0  = code return address
        ; r1  = callers FIQ status
        ; r14 = IRQ vector address and new PSR status

        ; We must ensure we keep IRQs disabled during the following
        ; processor mode changes (and preserve the entry FIQ state)
        
        TEQP    pc,irq_r14              ; SVC mode, IRQs disabled
        NOP                             ; and wait for registers to be mapped

	[	(newsvc)
	LDR	r2,=entered_IRQ		; current active IRQ thread count
	LDR	r3,[r2,#&00]
	TEQ	r3,#&00000000
	LDREQ	r4,=top_IRQ_stack	; only thread, so new stack
	MOVNE	r4,svc_r13		; otherwise preserve the current stack
	ADD	r3,r3,#&01		; update the active count
	STR	r3,[r2,#&00]
	; continue SVC thread setup
	STMFD   r4!,{svc_r13,svc_r14}	; preserve SVC thread information
	MOV	svc_r13,r4		; and index the stack for SVC mode
	|
        STMFD   sp!,{svc_r14}           ; preserve SVC thread r14 (stored on
                                        ; SVC stack)
	]
        MOV     svc_r14,r0              ; load the entry "irq_r14" entry

        AND     r0,r0,#Fbit             ; create suitable FIQ mask
        TEQP    r0,#(Ibit :OR: IRQmode) ; and return to IRQ mode
        NOP                             ; and wait for registers to be mapped

	[	(newsvc)
        LDMFD   irq_r13!,{r0,r1,r2,r3,r4}
	ASSERT	((5 * 4) = size_IRQ_entry)
	|
        LDMFD   irq_r13!,{r0,r1,dp}     ; recover entry "r0", "r1" and "dp"
	]

        ; The relevant handler is entered with the following state:
        ;   SVC mode
        ;   IRQs disabled
        ;   FIQs as interrupted process
        ;   svc_r14 - copy of modified irq_r14 (suitable for return to caller)
	[	(newsvc)
        ;   svc_r13 - valid FD stack (containing interrupted SVC r13 and r14)
	|
        ;   svc_r13 - valid FD stack (containing interrupted SVC r14)
	]

        MOVS    pc,irq_r14      ; enter IRQ handler (updating PC mode and PSR)

        ; ---------------------------------------------------------------------
        ; Device driver, call Helios when unrecognised interrupt.
no_interrupt
        ; We do not recognise the IRQ source. Call the nucleus handler
        ; function. This is a C function, so we must set up a minimum
        ; world for it.
	; Interrupt functions should perform as little code as is possible
	; (ie. the only acceptable external call should be one to
	;  "HardenedSignal" (which may generate a "Resume" call)).
        ;
	[	(newsvc)
	; We perform a direct branch to "Return_From_IRQ" in this code.
	|
        ; We need to exit through "Return_From_IRQ" to restore the correct
	; world, and also because the interrupt handler may have resumed a
	; process with higher priority than the currently executing one.
        ADRL    r1,Return_From_IRQ
        MOV     r0,irq_r14
        ORR     irq_r14,r1,#(Ibit :OR: SVCmode) ; SVC mode, IRQs disabled
        AND     r1,r0,#Fbit                     ; get callers FIQ state
        ORR     irq_r14,irq_r14,r1              ; and add in callers FIQ state
        ; r0  = code return address
        ; r1  = callers FIQ status
        ; r14 = "Return_From_IRQ" code address and new PSR status
        ; The return address has been placed into r0 because r0 is never
        ; a mapped register.

        STMFD   irq_r13!,{r0}           ; new "svc_r14"
        ; The new "svc_r14" cannot be loaded now, in-case the interrupt
        ; handler we are about to call executes a SWI call.
	]	; EOF (newsvc)

        ; We must ensure we keep IRQs disabled during the following
        ; processor mode changes (and preserve the entry FIQ state)
        TEQP    pc,irq_r14              ; SVC mode, IRQs disabled
        NOP                             ; and wait for registers to be mapped

	[	(newsvc)
	LDR	r2,=entered_IRQ		; current active IRQ thread count
	LDR	r3,[r2,#&00]
	TEQ	r3,#&00000000
	LDREQ	r4,=top_IRQ_stack	; only thread, so new stack
	MOVNE	r4,svc_r13		; otherwise preserve the current stack
	ADD	r3,r3,#&01		; update the active count
	STR	r3,[r2,#&00]
	; continue SVC thread setup
	STMFD   r4!,{svc_r13,svc_r14}	; preserve SVC thread information
	MOV	svc_r13,r4		; and index the stack for SVC mode

	; SVC mode; IRQs disabled; FIQs as interrupted process
	; r0 = "svc_r14" for "Return_From_IRQ" (ie. caller return address)
	STMFD	sp!,{r0}		; store callers address
	; SVC stack:
	;	+--------------+	top_IRQ_stack or entry SVC r13
	;	| original r14 |
	;	+--------------+
	;	| original r13 |
	;	+--------------+
	;	| return addr  |
	;	+--------------+	SVC r13

	LDR	r0,=bottom_IRQ_entry	        ; address the entry stored regs
	LDMIA	r0,{r0,r1,r2,r3,r4}
	ASSERT	((5 * &04) = size_IRQ_entry)

	LDR	lk,=ROOT_start
	LDR	lk,[lk,#ExecRoot_devhand]	; address of Helios handler
	TEQ	lk,#&00000000			; is there one?
	BNE	no_handler_function

	; r0, r1, r2, r3, r9 and r12 may get corrupted during a standard PCS
	; call. r10 and r11 need to contain sensible values. 
	STMFD	sp!,{r0,r1,r2,r3,r4,r5,r6,r7,r8,dp,sb,fp,ip}
	; Since we do not want to call the interrupt handler with the "dp" of
	; the interrupted process, we set "dp = -1". The system error
	; handler code can then spot a Fatal Executive error.
	MOV	dp,#&FFFFFFFF
	MOV	fp,#&00000000		; no stack-frame structure
	LDR	sb,=bottom_IRQ_stack	; stack limit (no spare room)

	; At the moment we make the handler call all the device drivers.
	; Eventually we will pass through the actual (hercules) interrupt ID
	; (We can then mask the interrupt source and enable IRQs before calling
	; Helios).

	MOV	r0,#&FFFFFFFF		; make Helios call all the handlers
	MOV	r1,lk			; Helios handler address
	MOV	lk,pc			; remember return address
	[	{TRUE}
	MOV	pc,r1			; call function (which can enable IRQs)
	|
	MOVS	pc,r1			; call function (which can enable IRQs)
	]
interrupt_handler_return
	; return from handler
	LDMFD	sp!,{r0,r1,r2,r3,r4,r5,r6,r7,r8,dp,sb,fp,ip}
no_handler_function	; Exit through "Return_From_IRQ" regardless
	LDMFD	sp!,{svc_r14}		; recover stacked "r0" above
	B	Return_From_IRQ
	|
        STMFD   sp!,{svc_r14}           ; preserve SVC thread r14 (stored on
                                        ; SVC stack)
        AND     r0,r0,#Fbit             ; create suitable FIQ mask
        TEQP    r0,#(Ibit :OR: IRQmode) ; and return to IRQ mode
        NOP                             ; and wait for registers to be mapped
        ; IRQ mode; IRQs disabled; FIQs as interrupted process
        ; irq_r13 - FD stack (containing entry state)
        ; svc_r13 - FD stack containing original SVC r14
        ; svc_r14 - <<undefined>>
        ; irq_r14 - "Return_From_IRQ" function address

        LDR     r0,=ROOT_start
        LDR     r1,[r0,#ExecRoot_devhand]       ; address of handler function
        TEQ     r1,#&00000000                   ; is there one?
        BEQ     no_handler_function

        ; r0,r1,r2,r3,r9 and r12 may get corrupted during the function call
        ; r10 and r11 need to contain sensible values. r0,r1 and dp are already
        ; preserved (on entry). We save the variable registers to be on the
        ; safe side.
        STMFD   irq_r13!,{r2,r3,r4,r5,r6,r7,r8,sb,fp,ip,irq_r14} 
        MOV     fp,#&00000000           ; no stack-frame structure
        LDR     sb,=bottom_IRQ_stack    ; stack limit (no spare room)
        ADR     irq_r14,interrupt_handler_return
        ORR     irq_r14,irq_r14,#(Ibit :OR: IRQmode)
        ; Make the handler call all the device drivers
        MOV     r0,#&FFFFFFFF

        ORR     r1,r1,#(Ibit :OR: IRQmode)
        ; code called... IRQ mode; IRQs disabled
        MOVS    pc,r1
interrupt_handler_return
        ; return from handler
        LDMFD   irq_r13!,{r2,r3,r4,r5,r6,r7,r8,sb,fp,ip,irq_r14}
no_handler_function
        ORR     r1,irq_r14,#(Ibit :OR: SVCmode) ; SVCmode, IRQs disabled
        AND     r0,irq_r14,#Fbit        ; get current FIQ state
        ORR     r1,r1,r0                ; and add in the FIQ state
        LDMFD   sp!,{r0}                ; new "svc_r14"
        ; We must ensure we keep IRQs disabled during the following
        ; processor mode changes (and preserve the entry FIQ state)
        TEQP    pc,r1                   ; SVC mode, IRQs disabled
        NOP                             ; and wait for registers to be mapped
        MOV     svc_r14,r0              ; load the SVC mode link register
        AND     r0,r0,#Fbit             ; create suitable FIQ mask
        TEQP    r0,#(Ibit :OR: IRQmode) ; and return to IRQ mode
        NOP                             ; and wait for registers to be mapped
        LDMFD   irq_r13!,{r0,r1,dp}     ; recover entry "r0", "r1" and "dp"
        ;   IRQ mode, IRQs disabled
        ;   FIQs as interrupted process
        ;   irq_r13 - initialised to "top_IRQ_stack" ready for the next IRQ
        ;   svc_r13 - FD stack containing original SVC r14
        ;   svc_r14 - entry IRQ r14 (return to interrupted thread)
        ;   irq_r14 - "Return_From_IRQ" handler address
        MOVS    pc,irq_r14
	]	; EOF (newsvc)

        ; ---------------------------------------------------------------------
        ; Link interrupt routine. This code is just ripped from the
        ; old FIQ code. It will not be amazingly fast compared to the
        ; original IRQ driven transfers (since each call copies one byte only).
	; THIS SHOULD BE SPEEDED UP.
LinkInterrupt
        ; in:   SVC mode; IRQs disabled; FIQs undefined.
        ;       svc_r14 : current process return address
	[	(newsvc)
	;	svc_r13 : FD stack (containing original SVC r13 and r14)
	|
        ;       svc_r13 : FD stack (containing original svc_r14)
	]
        ;       All other registers must be preserved
        ;       "svc_r13" and "svc_r14" should be restored on EXIT
        ;
        ; At the moment the Executive allows bi-directional link transfers
        ; to be active. This means that this IRQ code must discover whether
        ; we are reading or writing a byte.
        ;
        ; If we complete the transfer, then we should disable the particular
        ; link adaptor interrupt source and add the blocked process SaveState
        ; onto the relevant scheduler queue.

        STMFD   sp!,{r0,r1,r2,r3,r4}

	[	(activebook)
	LDR	r1,=LINK0_base		; link hardware address
	|
	[	(hercules)
	MOV	r1,#LINK_base		; link hardware address
	|
        MOV     r1,#inmos_link_base     ; link1 hardware address
	]
	]	; (activebook)
        LDR     r4,=link_IRQ_workspace  ; IRQ transfer descriptions
        LDMIA   r4,{r2,r3}              ; load TX description variables
        CMP     r3,#&00000000           ; check for NULL transfer count
	[	(hercules :LOR: activebook)
	LDRNEB	r0,[r1,#LINK_wstatus]
	TSTNE	r0,#LINK_intenable	; are TX interrupts enabled
	TSTNE	r0,#LINK_data		; bit set marks ready state
	|
        LDRNEB  r0,[r1,#link_wstatus]
        TSTNE   r0,#linkw_interrupt     ; are TX interrupts enabled
        TSTNE   r0,#linkw_data          ; bit set marks ready state
	]	; (hercules :LOR: activebook)
        BNE     write_trans             ; we have a write interrupt

        ADD     r4,r4,#(rxbuffer_address - link_IRQ_workspace)
        LDMIA   r4,{r2,r3}              ; load RX description variables
        CMP     r3,#&00000000           ; check for NULL transfer count
	[	(hercules :LOR: activebook)
	LDRNEB	r0,[r1,#LINK_rstatus]
	TSTNE	r0,#LINK_intenable	; are RX interrupts enabled
	TSTNE	r0,#LINK_data		; bit set marks ready state
	|
        LDRNEB  r0,[r1,#link_rstatus]
        TSTNE   r0,#linkr_interrupt     ; are RX IRQs enabled
        TSTNE   r0,#linkr_data          ; bit set marks ready state
	]	; (hercules :LOR: activebook)
        SUBEQ   r4,r4,#(rxbuffer_address - link_IRQ_workspace)
        BEQ     exit_linkIRQ
read_trans
        ; r0 = undefined
        ; r1 = base address of link adaptor hardware
        ; r2 = buffer address
        ; r3 = transfer count
        ; r4 = base address of receive transfer variables

        ; "r3 = 0" check is made above

	[	(hercules :LOR: activebook)
	LDRB	r0,[r1,#LINK_read]	; get byte
	|
        LDRB    r0,[r1,#link_read]      ; get byte
	]	; (hercules :LOR: activebook)
        STRB    r0,[r2],#&01            ; and store in the buffer

	[	({FALSE} :LAND: (debug2))	; debugging
	!	0,"LINK Interrupt debugging included"
	STMFD	sp!,{r0,r1}
	MOV	r1,r0
	ADRL	r0,idtext1
	BL	local_Output
	MOV	r0,r1
	BL	local_WriteHex8
	BL	local_NewLine
	LDMFD	sp!,{r0,r1}
	B	idovr1
idtext1	=	"LinkInt: byte &",&00
	ALIGN
idovr1
	]	; EOF (debug2)

        SUBS    r3,r3,#&01
        STMIA   r4,{r2,r3}              ; store updated address and count
        BNE     exit_linkIRQ           ; we require more data

        ; no more data required, so disable read interrupt
        MOV     r0,#&00                 ; disable read interrupts
	[	(hercules :LOR: activebook)
	STRB	r0,[r1,#LINK_rstatus]
	|
        STRB    r0,[r1,#link_rstatus]
	]	; (hercules :LOR: activebook)

        ; load "SaveState *"
        LDR     r1,[r4,#(rxbuffer_savestate - rxbuffer_address)]
        LDR     r0,=ROOT_start
        ; r0 = "ExecRoot" data structure
        ; r1 = SaveState of process to be re-started
        ; r2 = undefined
        ; r3 = undefined
        ; r4 = undefined
        ADD     r3,r0,#ExecRoot_queues
        ; r3 = base address of priority 0 ProcessQ
        ; add r1 (SaveState *) onto the referenced queue
        LDR     r2,[r3,#ProcessQ_tail]  ; load the current tail node
        STR     r1,[r2,#SaveState_next] ; reference the new tail node at the
        STR     r1,[r3,#ProcessQ_tail]
        B       exit_linkIRQ

write_trans
        ; r0 = undefined
        ; r1 = base address of link adaptor hardware
        ; r2 = buffer address
        ; r3 = transfer count
        ; r4 = base address of transfer variables

        ; "r3 = 0" check is made above

        LDRB    r0,[r2],#&01            ; read from buffer (updating address)
	[	(hercules :LOR: activebook)
	STRB	r0,[r1,#LINK_write]
	|
        STRB    r0,[r1,#link_write]
	]	; (hercules :LOR: activebook)

        SUBS    r3,r3,#&01
        STMIA   r4,{r2,r3}              ; store updated address and count
        BNE     exit_linkIRQ            ; we have more data to transmit

        ; no more data left, so disable write interrupt
        MOV     r0,#&00                 ; disable write interrupts
	[	(hercules :LOR: activebook)
	STRB	r0,[r1,#LINK_wstatus]
	|
        STRB    r0,[r1,#link_wstatus]
	]	; (hercules :LOR: activebook)

        ; load "SaveState *"
        LDR     r1,[r4,#(txbuffer_savestate - link_IRQ_workspace)]
        LDR     r0,=ROOT_start
        ; r0 = "ExecRoot" data structure
        ; r1 = SaveState of process to be re-started
        ; r2 = undefined
        ; r3 = undefined
        ; r4 = undefined
        ADD     r3,r0,#ExecRoot_queues
        ; r3 = base address of priority 0 ProcessQ
        ; add r1 (SaveState *) onto the referenced queue
        LDR     r2,[r3,#ProcessQ_tail]  ; load the current tail node
        STR     r1,[r2,#SaveState_next] ; reference the new tail node at the
        STR     r1,[r3,#ProcessQ_tail]

exit_linkIRQ
        LDMFD   sp!,{r0,r1,r2,r3,r4}
        B       Return_From_IRQ         ; continue IRQ processing

        ; ---------------------------------------------------------------------
        ; CLOCK interrupt routine: entered for every countdown completion
ClockInterrupt
        ; in:   SVC mode; IRQs disabled; FIQs undefined.
        ;       svc_r14 : current process return address
	[	(newsvc)
	;	svc_r13 : FD stack (containing original SVC r13 and r14)
	|
        ;       svc_r13 : FD stack (containing original svc_r14)
	]
        ;       All other registers must be preserved
        ;       "svc_r13" and "svc_r14" should be restored on EXIT

        ; "TickSize" should be tailored to produce the number of micro-seconds
        ; between clock interrupts.

        ; stack work registers
        STMFD   sp!,{r0,r1,r2,r3,r4}

        ; We already know that it was a clock interrupt,
        ; so clear the interrupt source (and re-enable the next interrupt).
	[	(hercules :LOR: activebook)
	MOV	r0,#TIMER_regs
	LDRB	r0,[r0,#TIMER_countCLR]		; read clears interrupt
	|
        LDR     r0,=timer_intclr                ; Not an 8-bit constant
        STRB    r0,[r0,#0]                      ; Any write here clears int
	]	; EOF (hercules :LOR: activebook)

        ; Note: It should be possible for IRQs to be enabled at this point,
        ;       since we are now executing in SVC mode. All that is required
        ;       is that if we are interrupted, our svc_r14 is preserved.
	;	Note: A copy of SVC r14 is stored on the stack already.

        LDR     r0,=ROOT_start                  ; ExecRoot structure

        ; This should be the only place that the soft timer values are
        ; incremented.
        LDMIA   r0,{r1,r2}              ; load soft timers
        ADD     r1,r1,#TickSize         ; micro-second timer
        ADD     r2,r2,#&01              ; centi-second timer
        STMIA   r0,{r1,r2}              ; store soft timers
        ; ensure that we do not update the ExecRoot structure without this code
        ASSERT  (ExecRoot_timer = &00)
        ASSERT  (ExecRoot_cstimer = (ExecRoot_timer + &04))
	[	(hercmlink :LOR: fpmlink)
	; Call the microlink timeout handler every few (power of 2) ticks
	; as it does not need very fine resolution.
	; r0 points to ExecRoot structure.
	; ML_Timer corrupts r1, r2, r3 and r4 only.
	TST	r2,#ML_TickMask		; Suitable tick boundary?
	BNE	NotMLTick		; No

	STMFD	r13!,{svc_r14}		; Must preserve SVC r14
	BL	ML_Timer		; Call microlink timeout routine
	LDMFD	r13!,{svc_r14}		; Restore SVC r14

NotMLTick
	] ; end (hercmlink :LOR: fpmlink)

	; r0 = ROOT_start
	[	(newsvc)
	!	0,"TODO: remove special return to SVC code in TIMER IRQ"
	; We should time-slice SVC threads in the new world. We should
	; only perform the hi-pri process check.
        TST     svc_r14,#SVCmode        ; mask out all but the processor mode
        BNE     TimerQ                  ; not in USR mode when interrupted
	|
        ; If we are currently executing a SVC thread, we should return to it
        ; immediately. However, we still need to remove any pending processes
        ; from the TimerQ so that they do not miss their wakeup window.

        TST     svc_r14,#SVCmode        ; mask out all but the processor mode
        BNE     TimerQ                  ; not in USR mode when interrupted
	]	; EOF (newsvc)

        LDR     r1,[r0,#ExecRoot_pri]
        TEQ     r1,#&00000000
        ; if hi-priority process then skip to next section
        BEQ     TimerQ

        LDR     r1,[r0,#ExecRoot_flags]
        TST     r1,#xb_idle
        ; if idle process skip to next section
        BNE     TimerQ

        LDR     r1,[r0,#ExecRoot_timeslice]
        TEQ     r1,#&00000000                   ; check for timeslicing
        BGT     DownSlice                       ; if not zero

        ; The following should be an atomic operation, but we are still
        ; executing with IRQs off so we should be OK.

        ; Set the flag to notify the "Return_From_IRQ" code that this process
        ; thread should be time-sliced...
        ; Note: At the moment this code will slice the current process EVEN
        ;       if it is the only process (it should however be started
        ;       immediately again when the scheduler is entered)

        LDR     r1,[r0,#ExecRoot_flags]
        ORR     r1,r1,#xb_next          ; set the bit
        STR     r1,[r0,#ExecRoot_flags] ; and place back into the structure

        B       TimerQ

DownSlice
        ; in:   r0 = ExecRoot structure
        ;       r1 = current "timeslice" value
        ;       r2 = undefined
        ;       r3 = undefined
        ;       r4 = undefined
        SUB     r1,r1,#TickSize         ; decrement timeslicing counter
        STR     r1,[r0,#ExecRoot_timeslice]
TimerQ
        ; Remove all pending processes from the TimerQ
        LDR     r1,[r0,#ExecRoot_timerQ]
        TEQ     r1,#&00000000           ; any processes on timerQ?
        BEQ     ClockReturn             ; if not then exit quickly

        ; We have at least one process waiting on the "timerQ"
TimerQrecheck
        ; NOTE: non-optimal register usage over the following routines
        ; r0 = "ExecRoot" address
        ; r1 = "SaveState" address for the process at the start of the "timerQ"
        ;
        ; Load the "SaveState_endtime" value of the process at the head of the
        ; queue. Decrement "TickSize" from this value, if C is set or Z set
        ; then this process should be re-started.
        LDR     r2,[r1,#SaveState_endtime]      ; wakeup delta

        SUBS    r2,r2,#TickSize                 ; decrement the delta
        BEQ     TimerQwakeup                    ; wakeup this process

        STRCS   r2,[r1,#SaveState_endtime]      ; remember the new delta
        BCS     ClockReturn                     ; do not wakeup this process
        ; fall through to...
TimerQwakeup
        ; r0 = "ExecRoot" address
        ; r1 = "SaveState" address of the process to be re-started
        LDR     r2,[r1,#SaveState_next]
        STR     r2,[r0,#ExecRoot_timerQ]

        LDR     r2,[r1,#SaveState_pri]  ; get priority of process to be resumed
        LDR     r4,[r0,#ExecRoot_hipri] ; and highest that could be run
        CMP     r2,r4
        STRCC   r2,[r0,#ExecRoot_hipri] ; this one is higher priority

        ; r0 = "ExecRoot" address
        ; r1 = "SaveState" address of the process to be re-started
        ; r2 = priority of process to be re-started
        ; r3 = undefined
        ; r4 = undefined
        ADD     r3,r0,#ExecRoot_queues
        ADD     r3,r3,r2,LSL #ProcessQ_shift    ; address of desired entry
        ; r0 = ExecRoot structure
        ; r1 = SaveState structure pointer of process to be re-started
        ; r2 = priority of process to be re-started
        ; r3 = ProcessQ structure pointer of queue where process to be placed
        ; r4 = undefined

        ; NULL the next pointer when taking from this queue onto the ProcessQ
        MOV     r4,#&00000000
        STR     r4,[r1,#SaveState_next]

        ; add r1 (SaveState *) onto the referenced ProcessQ
        LDR     r2,[r3,#ProcessQ_tail]  ; load the current tail node
        STR     r1,[r2,#SaveState_next] ; reference the new tail node
        STR     r1,[r3,#ProcessQ_tail]  ; in both places

        ; We should now check that the next pointer does NOT also need to
        ; taken from the TimerQ.
        LDR     r1,[r0,#ExecRoot_timerQ]
        TEQ     r1,#&00000000                   ; any processes on timerQ?
        BNE     TimerQrecheck                   ; if not then exit quickly
        ; fall through to...
ClockReturn
        ; pop stacked entry registers
        LDMFD   sp!,{r0,r1,r2,r3,r4}
        ; all process registers must be preserved
        ; svc_r13 : FD stack (containing original "svc_r14")
        ; svc_r14 : IRQ return address

        ; and fall through to "Return_From_IRQ"

        ; ---------------------------------------------------------------------
        ; -- Return_From_IRQ --------------------------------------------------
        ; ---------------------------------------------------------------------

Return_From_IRQ
        ; in:   SVC mode, IRQs disabled, FIQs undefined
	[	(newsvc)
	; 	svc_r14 : return address (to original caller)
	;	svc_r13 : FD stack (containing original SVC r13 and r14)
	|
        ;       svc_r14 : return address (should not be used with IRQs enabled)
        ;       svc_r13 : FD stack (containing original "svc_r14")
	]
        ;       All the interrupted processes registers need to be saved into a
        ;       process "SaveState" structure if required.
        ; out:  We return to the current or the next process.
	;
        ; Used by all interrupt routines on exit (executes in SVC (NOT IRQ)
        ; mode). We are preserving SVC state when interrupted by using the
        ; same stack (assuming it is large enough) and preserving the
        ; original SVC r13 and r14 on this stack. When we have finished our IRQ
        ; thread we should restore these registers to the state when the IRQ
        ; occured.
        ;
	[	(newsvc)
	; Deal with direct return to interrupted SVC IRQ thread
	STMFD	sp!,{r0,r1}
	LDR	r0,=entered_IRQ
	LDR	r1,[r0,#&00]		; outstanding IRQ thread count
	SUBS	r1,r1,#&01		; decrement count (for this return)
	STR	r1,[r0,#&00]
	BEQ	UserProcess		; NO more IRQ threads to return to
DirectSVCExit
	LDR	r0,[sp,#&0C]		; r0 = original SVC r14
	STR	lk,[sp,#&0C]		; store current return address on stack
	MOV	lk,r0			; restore original SVC r14
	LDMFD	sp!,{r0,r1,sp,pc}^	; and return to the IRQ thread

	; ---------------------------------------------------------------------
	; This is the outermost interrupt level
UserProcess
	; Deal with direct return to interrupted SVC thread (UserProcess).
	; Eventually these will be treated like normal USR mode threads, and
	; be re-scheduled. At the moment we treat them as always being
	; hi-priority processes.
	!	0,"TODO: remove special return to SVC mode"
	TST	lk,#SVCmode		; mask out all but the processor mode
	BNE	DirectSVCExit		; return to SVC thread

	; At the moment we are guaranteed to be an interrupted USR mode process
	ADD	sp,sp,#&10		; dump r0,r1 and original r13 and r14
	; Deal with direct return to hipriority processes and normal scheduling
	|
        ; If the interrupted routine was executing in SVC mode then it
        ; must be a hi-priority task. (This code assumes that user processes
        ; only run in USR mode).

        ; Check if the bottom 2bits of the return PSR == USRmode
        TST     svc_r14,#SVCmode        ; mask out all but the processor mode
        BEQ     UserProcess             ; in USR mode when interrupted

        ; We are returning to another SVC level routine.
        ; Recover original svc_r14 (reconstructing the svc_r13 value)
        ; We still have IRQs disabled at this point

        STMFD   sp!,{r0}                ; work register
        LDR     r0,[sp,#&04]            ; load original svc_r14
        STR     svc_r14,[sp,#&04]       ; and store the return address
        MOV     svc_r14,r0              ; and recover original svc_r14

        LDMFD   sp!,{r0,pc}^            ; Return to interrupted SVC thread
        
        ; ---------------------------------------------------------------------
        ; This is the outermost interrupt level
UserProcess
        ADD     sp,sp,#&04              ; dump the "svc_r14" copy
        ; We have just lost the "svc_r14" register we had taken a copy of.
        ; This can be lost since we are NOT returning to a interrupted
        ; SVC thread. The act of entering SVC mode legally from a USR process
        ; will always utilise svc_r14 (so we do not need to preserve it
        ; here)
	]	; EOF (newsvc)

        STMFD   sp!,{r1,r2,r3}

        LDR     r1,=ROOT_start

        LDR     r2,[r1,#ExecRoot_pri]
        TEQ     r2,#&00000000           ; if hi-priority then return
        LDMEQFD sp!,{r1,r2,r3}
        MOVEQS  pc,svc_r14              ; return immediately

        ; "lo-priority" or "IDLE" process interrupted

        ; The following code checks if the current process is to be
        ; re-scheduled due to the end of its time-slice, or because a new
        ; process has appeared on a higher priority ProcessQ (pre-emption).

        LDR     r2,[r1,#ExecRoot_flags]
        TST     r2,#xb_next             ; check if due for timeslicing
        BNE     NextProcess             ; YES - then swap to next process

        LDR     r3,[r1,#ExecRoot_hipri]
        CMP     r3,r2           ; check if higher priority process scheduled
        ; If the same or lower priority, then we do not need to do anything
        LDMGEFD sp!,{r1,r2,r3}
        MOVGES  pc,svc_r14      ; return to interrupted USR thread

        ; otherwise we should pre-empt this process
SaveSelf
        ; in:   r1 = ExecRoot structure
        ;       r2 = "SaveState *" from the head of the relevant ProcessQ
        ;       r3 = highest priority that can be run
        ;       SVC mode, IRQs disabled, FIQs undefined

        LDR     r2,[r1,#ExecRoot_flags]
        TST     r2,#xb_idle
        BIC     r2,r2,#xb_idle          ; Always clear IDLE flag
        STR     r2,[r1,#ExecRoot_flags]
        LDMNEFD sp!,{r1,r2,r3}          ; if IDLE process...
        BNE     Scheduler1              ; do not bother saving process state

        ; move the USR mode stack pointer into "r1"

        SUB     sp,sp,#&04              ; make space for the USR mode r13
        STMIA   sp,{usr_sp}^
        NOP
        LDMFD   sp!,{r1}

        ; allocate space on the user process stack for the process description
        SUB     r1,r1,#SaveState_size   ; see NOTES above

        STR     r0,[r1,#SaveState_r0]   ; store "r0" for the process
        MOV     r0,r1                   ; and copy the pointer into r0

        ; NULL "next" pointer
        MOV     r1,#&00000000
        STR     r1,[r0,#SaveState_next]

        ; The actual saved process priority should be derived from the
        ; ExecRoot structure
        LDR     r1,=ROOT_start                  ; ExecRoot structure address
        ; code and time could be saved by using more registers and LDM/STMs
        LDR     r2,[r1,#ExecRoot_fparea]        ; preserve FP state
        STR     r2,[r0,#SaveState_fparea]
        LDR     r2,[r1,#ExecRoot_initial_dp]    ; preserve initial "dp"
        STR     r2,[r0,#SaveState_initial_dp]
	[	(memmap)
	LDR	r2,[r1,#ExecRoot_memmap]	; preserve MEMMAP state
	STR	r2,[r0,#SaveState_memmap]
	]
        LDR     r2,[r1,#ExecRoot_timeslice]     ; timeslice remaining
        STR     r2,[r0,#SaveState_endtime]
        LDR     r2,[r1,#ExecRoot_pri]           ; and current process pri level
        STR     r2,[r0,#SaveState_pri]

        ; Add the process to the FRONT of the relevant queue.
        ; r0 = (SaveState *) of process
        ; r1 = ExecRoot structure address
        ; r2 = process priority
        ADD     r1,r1,#ExecRoot_queues          ; base of the ProcessQs
        ADD     r1,r1,r2,LSL #ProcessQ_shift    ; reference the correct queue
        LDR     r2,[r1,#ProcessQ_head]          ; load current head node
        STR     r2,[r0,#SaveState_next]         ; and reference in new node
        STR     r2,[r1,#ProcessQ_head]          ; and insert new head node

        ; de-stack any pushed registers
        LDMFD   sp!,{r1,r2,r3}
        ; IRQs disabled
        ; "r0" should contain a pointer to the "SaveState" structure
        ; "svc_r14" should contain the return address
        B       Scheduler               ; **** exit from IRQ handler ****

        ; ---------------------------------------------------------------------
        ; Add the current (interrupted) USR process onto the relevant
        ; priority ProcessQ
NextProcess
        ; in:   entry "r1","r2" on the stack
        ;       r1 = ExecRoot structure
        ;       r2 = ExecRoot "flags" value
        ;       r3 = undefined
        ;       SVC mode, IRQs disabled, FIQs undefined

        ; Do not timeslice when we were executing in IDLE
        TST     r2,#xb_idle
        BIC     r2,r2,#xb_idle          ; Always clear IDLE flag
        STR     r2,[r1,#ExecRoot_flags]
        ; If IDLE process, don't bother saving... just try to re-schedule
        LDMNEFD sp!,{r1,r2,r3}          ; if IDLE process...
        BNE     Scheduler1              ; do not bother saving process state

        BIC     r2,r2,#xb_next          ; clear the flag
        STR     r2,[r1,#ExecRoot_flags]

        ; Move the USR mode stack pointer into "r1"
        ; NOTE: This takes a copy of the USR mode stack pointer.
        SUB     sp,sp,#&04              ; make space for the USR mode r13
        STMIA   sp,{usr_sp}^            ; store USR mode "r13" on stack
        NOP
        LDMFD   sp!,{r1}                ; and load into "r1"
        ; r1 = interrupted USR mode process stack pointer

        ; allocate space in the User Stack for the process description.
        ; NOTES: This does NOT check for stack overflow... but we assume that
        ;        the size of the "SaveState" structure will fit into the
        ;        stack overflow buffer area.

        SUB     r1,r1,#SaveState_size

        STR     r0,[r1,#SaveState_r0]   ; save "r0" for the process description
        MOV     r0,r1                   ; and copy the (SaveState *) into r0

        ; NULL "next" pointer
        MOV     r1,#&00000000
        STR     r1,[r0,#SaveState_next]

        ; This code should really copy the current "ExecRoot" priority value
        ; (as long as it has not been corrupted) into the SaveState structure.
        LDR     r1,=ROOT_start
        LDR     r3,[r1,#ExecRoot_pri]           ; current process pri level
        STR     r3,[r0,#SaveState_pri]          ; and store in the "SaveState"
        LDR     r3,[r1,#ExecRoot_fparea]        ; current process FP state
        STR     r3,[r0,#SaveState_fparea]
        LDR     r3,[r1,#ExecRoot_initial_dp]
        STR     r3,[r0,#SaveState_initial_dp]
	[	(memmap)
	LDR	r3,[r1,#ExecRoot_memmap]	; preserve MEMMAP state
	STR	r3,[r0,#SaveState_memmap]
	]

        ; r0 = "SaveState *" of process to be suspended
        ; r1 = ExecRoot structure address
        ; r2 = undefined
        ; r3 = initial dp register value of current process

        ; We need to place the "SaveState *" onto the correct priority queue
        LDR     r2,[r1,#ExecRoot_pri]           ; process priority
        ADD     r1,r1,#ExecRoot_queues          ; base address of the queues
        ADD     r1,r1,r2,LSL #ProcessQ_shift
        ; r0 = "SaveState *" of process to be suspended
        ; r1 = address of the correct priority ProcessQ
        ; r2 = priority of process
        ; r3 = undefined

        ; add r0 (SaveState *) onto the referenced ProcessQ
        LDR     r2,[r1,#ProcessQ_tail]          ; load the current tail node
        STR     r0,[r2,#SaveState_next]         ; reference the new tail node
        STR     r0,[r1,#ProcessQ_tail]

        LDMFD   sp!,{r1,r2,r3}
        ; IRQs should still be disabled
        ; "r0" should contain a pointer to the "SaveState" structure
        ; "svc_r14" should contain the return address
        B       Scheduler               ; **** exit from IRQ handler ****

        ; ---------------------------------------------------------------------
        LNK     lomlink.s
@
