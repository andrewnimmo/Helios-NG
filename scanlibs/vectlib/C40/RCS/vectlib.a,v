head	1.6;
access;
symbols
	Helios_1_3_1:1.5
	Helios_C40_1_3_Official_Release:1.5
	Alenia_release:1.5;
locks; strict;
comment	@-- @;


1.6
date	94.01.11.16.53.12;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	92.10.20.09.20.09;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	92.10.15.16.22.49;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	92.10.15.16.01.01;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	92.10.15.14.49.38;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	92.10.15.10.52.56;	author nickc;	state Exp;
branches;
next	;


desc
@C40 assembler version of the Vector [A Library
@


1.6
log
@added folding
@
text
@--{{{ Comments

;
; vectlib.a - Assembly language implementation of a simple vector library
;
; Copyright (c) 1992 - 1994 by Perihelion Software Ltd.
;   All Rights Reserved
;
; Author: Nick Clifton
;
; $Id: vectlib.a,v 1.5 1992/10/20 09:20:09 nickc Exp nickc $
;
;

--}}}
--{{{ includes
_include 'c40.m
_include 'basic.m
_include 'module.m

--}}}

	StartModule vectlib -1 1

--{{{ Functions

--
-- Vector manipulation libray
--
-- This library has been written for speed.  As a result
-- it will not work with vectors of only one element.  In
-- addition, none of the routines validate their arguments.
--

--{{{ VfAdd

Function VfAdd
--
--	void VfAdd( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of element in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	        2,	           R_A1,	    RC		-- decrement count and place in RC
	RPTBD	        vfadd_loop					-- repeat block of code
	   LSH3	       -2,                 R_A2,	    R_ATMP	-- convert byte offset to word offset
	   LSH3	       -2,                 R_A3,	    R_ADDR1	-- convert byte offset to word offset
	   ADDF3     *++R_ATMP(R_BASE), *++R_ADDR1(R_BASE), R_A1	-- add first elements of arrays	   
	 RND	        R_A1						-- round result to 32 bits
	 STF	        R_A1,             *R_ATMP++(1)			-- store reult of previous addition
vfadd_loop:
	 ADDF3        *+R_ATMP(0),      *++R_ADDR1(1),      R_A1	-- compute next sum
	BuD	        R_LR						-- return
	   RND		R_A1						-- round result to 32 bits
	   STF	        R_A1,             *R_ATMP			-- store final value
	   NOP								-- padding
--
-- end of VfAdd
--

--}}}
--{{{ VfSub

Function VfSub
--
--	void VfSub( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of element in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	        2,	            R_A1,	    RC		-- decrement count and place in RC
	RPTBD	        vfsub_loop					-- repeat block of code
	   LSH3	       -2,                  R_A2,	    R_ATMP	-- convert byte offset to word offset
	   LSH3	       -2,                  R_A3,	    R_ADDR1	-- convert byte offset to word offset
	   SUBF3     *++R_ADDR1(R_BASE), *++R_ATMP(R_BASE), R_A1	-- subtract first elements of arrays
	 RND	        R_A1						-- round result to 32 bits
	 STF	        R_A1,              *R_ATMP++(1)			-- store reult of previous addition
vfsub_loop:
	 SUBF3     *++R_ADDR1(1),       *+R_ATMP(0),      R_A1	-- compute next difference
	BuD	        R_LR						-- return
	   RND		R_A1						-- round result to 32 bits
	   STF	        R_A1,              *R_ATMP			-- store final value
	   NOP								-- padding
--
-- end of VfSub
--

--}}}
--{{{ VfMul

Function VfMul
--
--	void VfMul( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of element in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	        2,	            R_A1,	    RC		-- decrement count and place in RC
	RPTBD	        vfmul_loop					-- repeat block of code
	   LSH3	       -2,                  R_A2,	    R_ATMP	-- convert byte offset to word offset
	   LSH3	       -2,                  R_A3,	    R_ADDR1	-- convert byte offset to word offset
	   MPYF3     *++R_ADDR1(R_BASE), *++R_ATMP(R_BASE), R_A1	-- multiply first elements of arrays
	 RND	        R_A1						-- round result to 32 bits
	 STF	        R_A1,              *R_ATMP++(1)			-- store reult of previous addition
vfmul_loop:
	 MPYF3     *++R_ADDR1(1),       *+R_ATMP(0),      R_A1	-- compute next product
	BuD	        R_LR						-- return
	   RND		R_A1						-- round result to 32 bits
	   STF	        R_A1,              *R_ATMP			-- store final value
	   NOP								-- padding
--
-- end of VfMul
--

--}}}
--{{{ VfDiv

Function VfDiv
--
--	void VfDiv( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	   2, 			R_A1,		RC
	LSH3	  -2,			R_A2,		R_ATMP
	RPTBD	   vfdiv_loop
	   LSH3	  -2,			R_A3,		R_ADDR1
	   ADDI	   R_BASE,		R_ATMP
	   LDF	*++R_ADDR1(R_BASE),	R_A3
	 RCPF	   R_A3,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_FT1,	       *R_ATMP,	R_A2
	 RND	   R_A2
vfdiv_loop:
	 STF	   R_A2,	       *R_ATMP++(1)
	 || LDF	*++R_ADDR1(1),		R_A3
	RCPF	   R_A3,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	BuD	   R_LR
	   MPYF3   R_FT1,	       *R_ATMP,	R_A2
	   RND	   R_A2
	   STF	   R_A2,	       *R_ATMP++(1)
--
-- end of VfDiv
--

--}}}
--{{{ VdAdd

Function VdAdd
--
--	void VdAdd( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3	     -2, 		R_A2,	R_ATMP		-- convert byte offset to word offset
	LSH3	     -2,		R_A3,	R_ADDR1		-- convert byte offset to word offset
	SUBI3	      2,		R_A1,	RC		-- decrement count
	RPTBD          vdadd_loop				-- repeat block of code
	   LDF	   *++R_ATMP(R_BASE),	R_A1			-- load first part of double value for 'x'
	   || LDF  *++R_ADDR1(R_BASE),	R_A2			-- load first part of double value for 'y'
	   LDI	      R_ATMP,		R_ADDR2
	   LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	   || LDI  *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	 ADDF	      R_A2,             R_A1			-- add the two numbers
	 STF	      R_A1,            *R_ADDR2++(1)		-- store the first part of the result
	 STI	      R_A1,            *R_ADDR2++(1)		-- store the second part of the result
	 LDF	   *++R_ATMP(1),	R_A1			-- load first part of double value for 'x'
	 || LDF    *++R_ADDR1(1),	R_A2			-- load first part of double value for 'y'
vdadd_loop:
	 LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	 || LDI    *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	BuD	      R_LR					-- return
	   ADDF	      R_A2,		R_A1			-- add last two numbers
	   STF	      R_A1,	       *R_ADDR2++(1)		-- store first part of result
	   STI	      R_A1,	       *R_ADDR2++(1)		-- store second part of result
--
-- end of VdAdd
--

--}}}
--{{{ VdSub

Function VdSub
--
--	void VdSub( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3	     -2, 		R_A2,	R_ATMP		-- convert byte offset to word offset
	LSH3	     -2,		R_A3,	R_ADDR1		-- convert byte offset to word offset
	SUBI3	      2,		R_A1,	RC		-- decrement count
	RPTBD         vdsub_loop				-- repeat block of code
	   LDF	   *++R_ATMP(R_BASE),	R_A1			-- load first part of double value for 'x'
	   || LDF  *++R_ADDR1(R_BASE),	R_A2			-- load first part of double value for 'y'
	   LDI	      R_ATMP,		R_ADDR2
	   LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	   || LDI  *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	 SUBF	      R_A2,             R_A1			-- add the two numbers
	 STF	      R_A1,            *R_ADDR2++(1)		-- store the first part of the result
	 STI	      R_A1,            *R_ADDR2++(1)		-- store the second part of the result
	 LDF	   *++R_ATMP(1),	R_A1			-- load first part of double value for 'x'
	 || LDF    *++R_ADDR1(1),	R_A2			-- load first part of double value for 'y'
vdsub_loop:
	 LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	 || LDI    *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	BuD	      R_LR					-- return
	   SUBF	      R_A2,		R_A1			-- add last two numbers
	   STF	      R_A1,	       *R_ADDR2++(1)		-- store first part of result
	   STI	      R_A1,	       *R_ADDR2++(1)		-- store second part of result
--
-- end of VdSub
--

--}}}
--{{{ VdMul

Function VdMul
--
--	void VdMul( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3	     -2, 		R_A2,	R_ATMP		-- convert byte offset to word offset
	LSH3	     -2,		R_A3,	R_ADDR1		-- convert byte offset to word offset
	SUBI3	      2,		R_A1,	RC		-- decrement count
	RPTBD         vdmul_loop				-- repeat block of code
	   LDF	   *++R_ATMP(R_BASE),	R_A1			-- load first part of double value for 'x'
	   || LDF  *++R_ADDR1(R_BASE),	R_A2			-- load first part of double value for 'y'
	   LDI	      R_ATMP,		R_ADDR2
	   LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	   || LDI  *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	 MPYF	      R_A2,             R_A1			-- add the two numbers
	 STF	      R_A1,            *R_ADDR2++(1)		-- store the first part of the result
	 STI	      R_A1,            *R_ADDR2++(1)		-- store the second part of the result
	 LDF	   *++R_ATMP(1),	R_A1			-- load first part of double value for 'x'
	 || LDF    *++R_ADDR1(1),	R_A2			-- load first part of double value for 'y'
vdmul_loop:
	 LDI	   *++R_ATMP(1),	R_A1			-- load second part of double value for 'x'
	 || LDI    *++R_ADDR1(1),	R_A2			-- load second part of double value for 'y'
	BuD	      R_LR					-- return
	   MPYF	      R_A2,		R_A1			-- add last two numbers
	   STF	      R_A1,	       *R_ADDR2++(1)		-- store first part of result
	   STI	      R_A1,	       *R_ADDR2++(1)		-- store second part of result
--
-- end of VdMul
--

--}}}
--{{{ VdDiv

Function VdDiv
--
--	void VdDiv( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	      2, 		R_A1,		RC
	LSH3	     -2,		R_A2,		R_ATMP
	RPTBD	      vddiv_loop
	   LSH3	     -2,		R_A3,		R_ADDR1
	   LDF	   *++R_ADDR1(R_BASE),	R_A3
	   || LDF  *++R_ATMP(R_BASE),	R_A1
	   LDI	   *++R_ADDR1(1),	R_A3
	   || LDI   *+R_ATMP(1),	R_A1
	 RCPF	   R_A3,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   1.0,			R_FT2
	 MPYF	   R_FT1,		R_FT2
	 ADDF	   R_FT2,		R_FT1

	 MPYF	   R_FT1,		R_A1

	 STF	   R_A1,	       *R_ATMP++(1)
	 STI	   R_A1,	       *R_ATMP++(1)
	 LDF	*++R_ADDR1(1),		R_A3
	 || LDF	  *R_ATMP,		R_A1
vddiv_loop:
	 LDI	*++R_ADDR1(1),		R_A3
	 || LDI	 *+R_ATMP(1),		R_A1
	RCPF	   R_A3,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   1.0,			R_FT2
	MPYF	   R_FT1,		R_FT2
	ADDF	   R_FT2,		R_FT1

	BuD	   R_LR
	   MPYF    R_FT1,	       	R_A1
	   STF	   R_A1,	       *R_ATMP++(1)
	   STI	   R_A1,	       *R_ATMP++(1)
--
-- end of VdDiv
--

--}}}
--{{{ VfAddScalar

Function VfAddScalar
--
--	void VfAddScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and floating point argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	SUBI3	     2,		     R_A3,	RC
	RPTBD        vfadds_loop
	   LSH3	    -2,		     R_A4,	R_ATMP
	   ADDF3  *++R_ATMP(R_BASE), R_A1,	R_A2
	   LDI	     R_ATMP,		        R_ADDR1
	 RND	     R_A2
	 STF	     R_A2,	    *R_ADDR1++(1)
vfadds_loop:
	 ADDF3  *++R_ATMP(1),	     R_A1,	R_A2
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	    *R_ADDR1++(1)
	   NOP
--
-- end of VfAddScalar
--

--}}}
--{{{ VfSubScalar

Function VfSubScalar
--
--	void VfSubScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and floating point argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	SUBI3	     2,		     R_A3,		RC
	RPTBD        vfsubs_loop
	   LSH3	    -2,		     R_A4,		R_ATMP
	   SUBF3     R_A1,	  *++R_ATMP(R_BASE),	R_A2
	   LDI	     R_ATMP,				R_ADDR1
	 RND	     R_A2
	 STF	     R_A2,	    *R_ADDR1++(1)
vfsubs_loop:
	 SUBF3     R_A1,	  *++R_ATMP(1),	   	R_A2
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	    *R_ADDR1++(1)
	   NOP
--
-- end of VfSubScalar
--

--}}}
--{{{ VfMulScalar

Function VfMulScalar
--
--	void VfMulScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and floating point argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	SUBI3	     2,		     R_A3,		RC
	RPTBD        vfmuls_loop
	   LSH3	    -2,		     R_A4,		R_ATMP
	   MPYF3     R_A1,	  *++R_ATMP(R_BASE),	R_A2
	   LDI	     R_ATMP,				R_ADDR1
	 RND	     R_A2
	 STF	     R_A2,	    *R_ADDR1++(1)
vfmuls_loop:
	 MPYF3       R_A1,	  *++R_ATMP(1),	   	R_A2
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	    *R_ADDR1++(1)
	   NOP
--
-- end of VfMulScalar
--

--}}}
--{{{ VfDivScalar

Function VfDivScalar
--
--	void VfDivScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the floating point argument
--
	LSH3	     -2,	    R_A4,		R_ATMP
	STI	      R_A1,	*\--R_USP(1)
	SUBI3	      2,	    R_A3,		RC
	LDF	     *R_USP++(1),   R_A1
	LDI	      R_A2,	    R_A1
	RCPF	      R_A1,	    R_FT1
	MPYF3	      R_A1,	    R_FT1,		R_FT2
	SUBRF	      2.0,	    R_FT2
	MPYF	      R_FT2,	    R_FT1
	MPYF3	      R_A1,	    R_FT1,		R_FT2
	SUBRF         2.0,	    R_FT2
	RPTBD	      vfdivs_loop
	   MPYF	      R_FT2,	    R_FT1
	   MPYF3      R_FT1,	 *++R_ATMP(R_BASE),	R_A1
	   LDI	      R_ATMP,	    R_ADDR1
	 RND	      R_A1
vfdivs_loop:
	 STF	      R_A1,	   *R_ATMP++(1)
	 || MPYF3  *++R_ADDR1(1),   R_FT1,		R_A1
	BuD	      R_LR
	   RND	      R_A1
	   STF	      R_A1,	   *R_ATMP++(1)
	   NOP
--
-- end of VfDivScalar
--

--}}}
--{{{ VfRecScalar

Function VfRecScalar
--
--	void VfRecScalar( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of the
--	floating point argument and that element of 'x'
--
	STI	   R_A1,	    *\--R_USP(1)
	SUBI3	   2, 			R_A3,		RC
	LDF	  *R_USP++(1),		R_A1
	RPTBD	   vfrecs_loop
	   LSH3	  -2,			R_A4,		R_ATMP
	   LDI	   R_A2,		R_A1
	   LDF	*++R_ATMP(R_BASE),	R_A3
	 RCPF	   R_A3,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_FT1,		R_A1,		R_A2
	 RND	   R_A2
	 STF	   R_A2,	       *R_ATMP++(1)
vfrecs_loop:
	 LDF	  *R_ATMP,		R_A3
	RCPF	   R_A3,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	BuD	   R_LR
	   MPYF3   R_FT1,		R_A1,		R_A2
	   RND	   R_A2
	   STF	   R_A2,	       *R_ATMP++(1)
--
-- end of VfRecScalar
--

--}}}
--{{{ VdAddScalar

Function VdAddScalar
--
--	void VdAddScalar( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and double precision argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	SUBI3	     2,		     R_A3,	RC
	RPTBD        vdadds_loop
	   LDF    *++R_ATMP(R_BASE), R_A2
	   LDI	     R_ATMP,         R_ADDR1
	   LDI	  *++R_ATMP(1),	     R_A2
	 ADDF3       R_A1,	     R_A2,	R_A3
	 STF	     R_A3,	    *R_ADDR1++(1)
	 || LDF   *++R_ATMP(1),	     R_A2
vdadds_loop:
	 STI	     R_A3,	    *R_ADDR1++(1)
	 || LDI   *++R_ATMP(1),	     R_A2
	BuD	     R_LR
	   ADDF3     R_A1,	     R_A2,	R_A3
	   STF	     R_A3,	    *R_ADDR1++(1)
	   STI	     R_A3,	    *R_ADDR1++(1)
--
-- end of VdAddScalar
--

--}}}
--{{{ VdSubScalar

Function VdSubScalar
--
--	void VdSubScalar( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and double precision argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	SUBI3	     2,		     R_A3,	RC
	RPTBD        vdsubs_loop
	   LDF    *++R_ATMP(R_BASE), R_A2
	   LDI	     R_ATMP,         R_ADDR1
	   LDI	  *++R_ATMP(1),	     R_A2
	 SUBF3       R_A1,	     R_A2,	R_A3
	 STF	     R_A3,	    *R_ADDR1++(1)
	 || LDF   *++R_ATMP(1),	     R_A2
vdsubs_loop:
	 STI	     R_A3,	    *R_ADDR1++(1)
	 || LDI   *++R_ATMP(1),	     R_A2
	BuD	     R_LR
	   SUBF3     R_A1,	     R_A2,	R_A3
	   STF	     R_A3,	    *R_ADDR1++(1)
	   STI	     R_A3,	    *R_ADDR1++(1)
--
-- end of VdSubScalar
--

--}}}
--{{{ VdMulScalar

Function VdMulScalar
--
--	void VdMulScalar( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and double precision argument
--
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LDI	     R_A2,	     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	SUBI3	     2,		     R_A3,	RC
	RPTBD        vdmuls_loop
	   LDF    *++R_ATMP(R_BASE), R_A2
	   LDI	     R_ATMP,         R_ADDR1
	   LDI	  *++R_ATMP(1),	     R_A2
	 MPYF3       R_A1,	     R_A2,	R_A3
	 STF	     R_A3,	    *R_ADDR1++(1)
	 || LDF   *++R_ATMP(1),	     R_A2
vdmuls_loop:
	 STI	     R_A3,	    *R_ADDR1++(1)
	 || LDI   *++R_ATMP(1),	     R_A2
	BuD	     R_LR
	   MPYF3     R_A1,	     R_A2,	R_A3
	   STF	     R_A3,	    *R_ADDR1++(1)
	   STI	     R_A3,	    *R_ADDR1++(1)
--
-- end of VdMulScalar
--

--}}}
--{{{ VdDivScalar

Function VdDivScalar
--
--	void VdDiv( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the double precision argument
--
	LSH3	     -2,	       R_A4,		R_ATMP
	STI	      R_A1,	   *\--R_USP(1)
	SUBI3	      2,	       R_A3,		RC
	LDF	     *R_USP++(1),      R_A1
	LDI	      R_A2,	       R_A1
	RCPF	      R_A1,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF         2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      1.0,	       R_FT2
	MPYF	      R_FT1,	       R_FT2
	ADDF	      R_FT2,	       R_FT1

	LDF	   *++R_ATMP(R_BASE),  R_A3
	RPTBD	      vddivs_loop
	   LDI	      R_ATMP,	       R_ADDR1
	   LDI	   *++R_ATMP(1),       R_A3
	   MPYF3      R_FT1,	       R_A3,		R_A1
	 STF	      R_A1,	      *R_ADDR1++(1)
	 || LDF	   *++R_ATMP(1),       R_A3
	 STI	      R_A1,	      *R_ADDR1++(1)
	 || LDI	   *++R_ATMP(1),       R_A3
vddivs_loop:
	 MPYF3	      R_A3,            R_FT1,		R_A1
	BuD	      R_LR
	   STF	      R_A1,	      *R_ADDR1++(1)
	   STI	      R_A1,	      *R_ADDR1++(1)
	   NOP
--
-- end of VdDivScalar
--

--}}}
--{{{ VdRecScalar

Function VdRecScalar
--
--	void VdRecScalar( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of the
--	double precision argument and that element of 'x'
--
	STI	   R_A1,	    *\--R_USP(1)
	SUBI3	   2, 			R_A3,		RC
	LDF	  *R_USP++(1),		R_A1
	LSH3	  -2,			R_A4,		R_ATMP
	LDF	*++R_ATMP(R_BASE),	R_A3
	RPTBD	   vdrecs_loop
	   LDI	   R_ATMP,		R_ADDR1
	   LDI	   R_A2,		R_A1
	   LDI	*++R_ATMP(1),		R_A3
	 RCPF	   R_A3,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   1.0,			R_FT2
	 MPYF	   R_FT1,		R_FT2
	 ADDF	   R_FT2,		R_FT1

	 MPYF3	   R_FT1,		R_A1,		R_A2
	 STF	   R_A2,	       *R_ADDR1++(1)
	 || LDF	*++R_ATMP(1),		R_A3
vdrecs_loop:
	 STI	   R_A2,	       *R_ADDR1++(1)
	 || LDI	*++R_ATMP(1),		R_A3
	RCPF	   R_A3,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   1.0,			R_FT2
	MPYF	   R_FT1,		R_FT2
	ADDF	   R_FT2,		R_FT1

	BuD	   R_LR
	   MPYF3   R_FT1,		R_A1,		R_A2
	   STF	   R_A2,	       *R_ADDR1++(1)
	   STI	   R_A2,	       *R_ADDR1++(1)
--
-- end of VdRecScalar
--

--}}}
--{{{ VfCopy

Function VfCopy
--
--	void VfCopy( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the corresponding element of 'y'
--
	LSH3	     -2,		R_A2,	R_ATMP
	SUBI3	      2,		R_A1,	RC
	RPTBD	      vfcopy_loop
	   LSH3	     -2,		R_A3,	R_ADDR1
	   LDF	   *++R_ADDR1(R_BASE),	R_A1
	   ADDI	      R_BASE,		R_ATMP
vfcopy_loop:
	 STF	      R_A1,	       *R_ATMP++(1)
	 || LDF    *++R_ADDR1(1),	R_A1
	STF	      R_A1,	       *R_ATMP++(1)
	Bu	      R_LR
--
-- end of VfCopy
--

--}}}
--{{{ VdCopy

Function VdCopy
--
--	void VdCopy( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--
-- Corrupts
--	ST
--
-- Purpose
--	Places into each element of 'x' the corresponding element of 'y'
--
	LSH	      1,		R_A1
	LSH3	     -2,		R_A2,	R_ATMP
	SUBI3	      2,		R_A1,	RC
	RPTBD	      vdcopy_loop
	   LSH3	     -2,		R_A3,	R_ADDR1
	   LDI	   *++R_ADDR1(R_BASE),	R_A1
	   ADDI	      R_BASE,		R_ATMP
vdcopy_loop:
	 STI	      R_A1,	       *R_ATMP++(1)
	 || LDI    *++R_ADDR1(1),	R_A1
	STI	      R_A1,	       *R_ATMP++(1)
	Bu	      R_LR
--
-- end of VdCopy
--

--}}}
--{{{ VfFill

Function VfFill
--
--	void VfFill( float value, uword n, float * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the floating point argument
--
	SUBI3	     2,		     R_A3,	RC
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	RPTBD        vffill_loop
	   LDI	     R_A2,	     R_A1
	   RND	     R_A1
	   STF       R_A1,	  *++R_ATMP(R_BASE)
vffill_loop:
	 STF	     R_A1,	  *++R_ATMP(1)
	Bu	     R_LR
--
-- end of VfFill
--

--}}}
--{{{ VdFill

Function VdFill
--
--	void VdFill( double value, uword n, double * x )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the double precision argument
--
	SUBI3	     2,		     R_A3,	RC
	STI	     R_A1,	 *\--R_USP(1)
	LDF	    *R_USP++(1),     R_A1
	LSH3	    -2,		     R_A4,	R_ATMP
	RPTBD        vdfill_loop
	   LDI	     R_A2,	     R_A1
	   STF       R_A1,	  *++R_ATMP(R_BASE)
	   STI       R_A1,	  *++R_ATMP(1)
	 STF	     R_A1,	  *++R_ATMP(1)
vdfill_loop:
	 STI	     R_A1,	  *++R_ATMP(1)
	Bu	     R_LR
--
-- end of VdFill
--

--}}}
--{{{ VfMax

Function VfMax
--
--	uword VfMax( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (signed) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	RPTBD	   vfmax_loop
	   LDI	   0,			R_A1
	   LDI	   0,			R_A3
	   LDF	*++R_ATMP(R_BASE),	R_A2
	 ADDI	   1,			R_A3
	 CMPF3	   R_A2,	     *++R_ATMP(1)
	 LDIgt	   R_A3,		R_A1
vfmax_loop:
	 LDFgt	  *R_ATMP,		R_A2
	Bu	   R_LR 
--
-- end of VfMax
--

--}}}
--{{{ VdMax

Function VdMax
--
--	uword VdMax( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Corrupts
--	ST
--
-- Purpose
--	Finds the largest (signed) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	LDI	   0,			R_A1
	RPTBD	   vdmax_loop
	   LDI	   0,			R_A3
	   LDF	*++R_ATMP(R_BASE),	R_A2
	   LDI	*++R_ATMP(1),		R_A2
	 LDF	*++R_ATMP(1),		R_FT1
	 LDI	*++R_ATMP(1),		R_FT1
	 ADDI	   1,			R_A3
	 CMPF	   R_A2,		R_FT1
	 LDFgt	   R_FT1,		R_A2
vdmax_loop:
	 LDIgt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VdMax
--

--}}}
--{{{ VfMin

Function VfMin
--
--	uword VfMin( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (signed) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	RPTBD	   vfmin_loop
	   LDI	   0,			R_A1
	   LDI	   0,			R_A3
	   LDF	*++R_ATMP(R_BASE),	R_A2
	 ADDI	   1,			R_A3
	 CMPF3	   R_A2,             *++R_ATMP(1)
	 LDIlt	   R_A3,		R_A1
vfmin_loop:
	 LDFlt	  *R_ATMP,		R_A2
	Bu	   R_LR 
--
-- end of VfMin
--

--}}}
--{{{ VdMin

Function VdMin
--
--	uword VdMin( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (signed) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	LDI	   0,			R_A1
	RPTBD	   vdmin_loop
	   LDI	   0,			R_A3
	   LDF	*++R_ATMP(R_BASE),	R_A2
	   LDI	*++R_ATMP(1),		R_A2
	 LDF	*++R_ATMP(1),		R_FT1
	 LDI	*++R_ATMP(1),		R_FT1
	 ADDI	   1,			R_A3
	 CMPF	   R_A2,		R_FT1
	 LDFlt	   R_FT1,		R_A2
vdmin_loop:
	 LDIlt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VdMin
--

--}}}
--{{{ VfAmax

Function VfAmax
--
--	uword VfAmax( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	RPTBD	   vfamax_loop
	   LDI	   0,			R_A1
	   LDI	   0,			R_A3
	   ABSF	*++R_ATMP(R_BASE),	R_A2
	 ADDI	   1,			R_A3
	 ABSF	*++R_ATMP(1),		R_FT1
	 CMPF	   R_A2,		R_FT1
	 LDFgt	   R_FT1,		R_A2
vfamax_loop:
	 LDIgt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VfAmax
--

--}}}
--{{{ VdAmax

Function VdAmax
--
--	uword VdAmax( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	LDI	   0,			R_A1
	LDI	   0,			R_A3
	RPTBD	   vdamax_loop
	   LDF	*++R_ATMP(R_BASE),	R_A2
	   LDI	*++R_ATMP(1),		R_A2
	   ABSF    R_A2
	 LDF	*++R_ATMP(1),		R_FT1
	 LDI	*++R_ATMP(1),		R_FT1
	 ABSF	   R_FT1
	 ADDI	   1,			R_A3
	 CMPF	   R_A2,		R_FT1
	 LDFgt	   R_FT1,		R_A2
vdamax_loop:
	 LDIgt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VdAmax
--

--}}}
--{{{ VfAmin

Function VfAmin
--
--	uword VfAmin( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (absolute) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	RPTBD	   vfamin_loop
	   LDI	   0,			R_A1
	   LDI	   0,			R_A3
	   ABSF	*++R_ATMP(R_BASE),	R_A2
	 ADDI	   1,			R_A3
	 ABSF	*++R_ATMP(1),		R_FT1
	 CMPF	   R_A2,		R_FT1
	 LDFlt	   R_FT1,		R_A2
vfamin_loop:
	 LDIlt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VfAmin
--

--}}}
--{{{ VdAmin

Function VdAmin
--
--	uword VdAmin( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	SUBI3	   2,			R_A1,	RC
	LSH3	  -2,			R_A2,	R_ATMP
	LDI	   0,			R_A1
	LDI	   0,			R_A3
	RPTBD	   vdamin_loop
	   LDF	*++R_ATMP(R_BASE),	R_A2
	   LDI	*++R_ATMP(1),		R_A2
	   ABSF    R_A2
	 LDF	*++R_ATMP(1),		R_FT1
	 LDI	*++R_ATMP(1),		R_FT1
	 ABSF	   R_FT1
	 ADDI	   1,			R_A3
	 CMPF	   R_A2,		R_FT1
	 LDFlt	   R_FT1,		R_A2
vdamin_loop:
	 LDIlt	   R_A3,		R_A1
	Bu	   R_LR 
--
-- end of VdAmin
--

--}}}
--{{{ VfDot

Function VfDot
--
--	float VfDot( uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the products of each pair of elements
--	in the two arrays.  Does not alter the input arrays.
--
	SUBI	     2,			R_A1,			RC
	   LSH3	    -2,			R_A2,			R_ATMP
	RPTBD        vfdot_loop
	   LSH3	    -2,			R_A3,			R_ADDR1
	   LDF	     0.0,		R_A3
	   MPYF3  *++R_ATMP(R_BASE), *++R_ADDR1(R_BASE),	R_A2
vfdot_loop:
	 MPYF3	  *++R_ATMP(1),	     *++R_ADDR1(1),		R_A2
	 || ADDF3    R_A3,	        R_A2,			R_A3
	BuD	     R_LR
	   ADDF3     R_A2,		R_A3,			R_A1
	   RND	     R_A1
	   NOP
--
-- end of VfDot
--

--}}}
--{{{ VdDot

Function VdDot
--
--	double VdDot( uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the products of each pair of elements
--	in the two arrays.  Does not alter the input arrays.
--
	LSH3	     -2,		R_A2,	R_ATMP
	LSH3	     -2,		R_A3,	R_ADDR1
	SUBI	      2,		R_A1,	RC
	RPTBD         vddot_loop
	   LDF	   *++R_ATMP(R_BASE),	R_A2
	   || LDF  *++R_ADDR1(R_BASE),	R_A3
	   LDF	      0.0,		R_A1
	   LDI	   *++R_ATMP(1),	R_A2
	   || LDI  *++R_ADDR1(1),	R_A3
	 MPYF	      R_A2,		R_A3
	 ADDF	      R_A3,		R_A1
	 LDF	   *++R_ATMP(1),	R_A2
	 || LDF	   *++R_ADDR1(1),	R_A3
vddot_loop:
	 LDI	   *++R_ATMP(1),	R_A2
	 || LDI	   *++R_ADDR1(1),	R_A3
	BuD	      R_LR
	   MPYF	      R_A2,		R_A3
	   ADDF	      R_A3,		R_A1
	   NOP
--
-- end of VdDot
--

--}}}
--{{{ VfSum

Function VfSum
--
--	float VfSum( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the elements in the array.
--
	SUBI3	  2,			R_A1,	RC
	RPTBD     vfsum_loop
	   LSH3	 -2,			R_A2,	R_ATMP
	   NOP
	   LDF	*++R_ATMP(R_BASE),	R_A1
vfsum_loop:
	 ADDF	*++R_ATMP(1),		R_A1
	RND	   R_A1
	Bu	   R_LR
--
-- end of VfSum
--

--}}}
--{{{ VdSum

Function VdSum
--
--	double VdSum( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Corrupts
--	ST
--
-- Purpose
--	Computes the sum of the elements in the array.
--
	SUBI3	  2,			R_A1,	RC
	RPTBD     vdsum_loop
	   LSH3	 -2,			R_A2,	R_ATMP
	   LDF	*++R_ATMP(R_BASE),	R_A1
	   LDI	*++R_ATMP(1),		R_A1
	 LDF	*++R_ATMP(1),		R_A2
	 LDI	*++R_ATMP(1),		R_A2
vdsum_loop:
	 ADDF	   R_A2,		R_A1
	Bu	   R_LR
--
-- end of VdSum
--

--}}}
--{{{ VfProd

Function VfProd
--
--	float VfProd( uword n, float * x )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the product of the elements in the array.
--
	SUBI3	  2,			R_A1,	RC
	RPTBD     vfprod_loop
	   LSH3	 -2,			R_A2,	R_ATMP
	   NOP
	   LDF	*++R_ATMP(R_BASE),	R_A1
vfprod_loop:
	 MPYF	*++R_ATMP(1),		R_A1
	RND	   R_A1
	Bu	   R_LR
--
-- end of VfProd
--

--}}}
--{{{ VdProd

Function VdProd
--
--	double VdProd( uword n, double * x )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the product of the elements in the array.
--
	SUBI3	  2,			R_A1,	RC
	RPTBD     vdprod_loop
	   LSH3	 -2,			R_A2,	R_ATMP
	   LDF	*++R_ATMP(R_BASE),	R_A1
	   LDI	*++R_ATMP(1),		R_A1
	 LDF	*++R_ATMP(1),		R_A2
	 LDI	*++R_ATMP(1),		R_A2
vdprod_loop:
	 MPYF	   R_A2,		R_A1
	Bu	   R_LR
--
-- end of VdProd
--

--}}}
--{{{ VfMulAdd

Function VfMulAdd
--
--	void VfMulAdd( float value, uword n, float * x, float * y )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in arrays 'x' and 'y'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	byte offset of start of floating point array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	For each element in 'x' the function computes the sum of
--	that element with the product of the corresponding
--	element of 'y' and the floating point argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LDF	    *R_USP++(1),	R_A1
	LSH3	    -2,			R_A4,		R_ATMP
	SUBI3	     2,			R_A3,		RC
	LSH3        -2,		      *+R_USP(0),	R_ADDR1
	RPTBD	     vfmuladd_loop
	   LDI	     R_A2,		R_A1
	   MPYF3  *++R_ADDR1(R_BASE),	R_A1,		R_A2
	   ADDF	  *++R_ATMP(R_BASE),	R_A2
	 RND	     R_A2
	 STF	     R_A2,	       *R_ATMP++(1)
	 || MPYF3 *++R_ADDR1(1),	R_A1,		R_A2
vfmuladd_loop:
	 ADDF	    *R_ATMP,		R_A2
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	       *R_ATMP
	   NOP
--
-- end of VfMulAdd
--

--}}}
--{{{ VdMulAdd

Function VdMulAdd
--
--	void VdMulAdd( double value, uword n, double * x, double * y )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in arrays 'x' and 'y'
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	byte offset of start of double precision array 'y'
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	For each element in 'x' the function computes the sum of
--	that element with the product of the corresponding
--	element of 'y' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LDF	    *R_USP++(1),	R_A1
	LSH3	    -2,			R_A4,		R_ATMP
	SUBI3	     2,			R_A3,		RC
	LSH3        -2,		      *+R_USP(0),	R_ADDR1
	LDI	     R_A2,		R_A1
	RPTBD	     vdmuladd_loop
	   LDF	  *++R_ADDR1(R_BASE),	R_A2
	   || LDF *++R_ATMP(R_BASE),	R_A3
	   LDI	  *++R_ADDR1(1),	R_A2
	   || LDI  *+R_ATMP(1),		R_A3
	   MPYF      R_A1,		R_A2
	 ADDF	     R_A3,	        R_A2
	 STF	     R_A2,	       *R_ATMP++(1)
	 STI	     R_A2,	       *R_ATMP++(1)
	 LDF	  *++R_ADDR1(1),	R_A2
	 || LDF     *R_ATMP,		R_A3
	 LDI	  *++R_ADDR1(1),	R_A2
	 || LDI    *+R_ATMP(1),		R_A3
vdmuladd_loop:
	 MPYF        R_A1,		R_A2
	BuD	     R_LR
	   ADDF	     R_A3,		R_A2
	   STF	     R_A2,	       *R_ATMP++(1)
	   STI	     R_A2,	       *R_ATMP
--
-- end of VdMulAdd
--

--}}}
--{{{ VfsAdd

Function VfsAdd
--
--	void VfsAdd( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	width of x in sizeof (float) units
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	width of y in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3     -2,		      R_A2,	R_ATMP
	LSH3     -2,		      R_A4,	R_ADDR1
	STI	  R_BASE,         *\--R_USP(1)
	STI	  R_USE,	  *\--R_USP(1)
	LDF    *++R_ATMP(R_BASE),     R_A2
	ADDF   *++R_ADDR1(R_BASE),    R_A2
	SUBI3     2,		      R_A1,	RC
	RPTBD	  vfsadd_loop
	   LDI	  R_A3,		      R_BASE
	   LDI  *+R_USP(2),	      R_USE
	   RND    R_A2
	 STF      R_A2,		     *R_ATMP++(R_BASE)
	 LDF     *R_ATMP,	      R_A2
	 ADDF  *++R_ADDR1(R_USE),     R_A2
vfsadd_loop:
	 RND      R_A2
	BuD	  R_LR
 	   STF	  R_A2,		     *R_ATMP
	   LDI	 *R_USP++(1),	      R_USE
	   LDI	 *R_USP++(1),	      R_BASE
--
-- end of VfsAdd
--

--}}}
--{{{ VfsSub

Function VfsSub
--
--	void VfsSub( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	width of x in sizeof (float) units
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	width of y in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3     -2,		      R_A2,	R_ATMP
	LSH3     -2,		      R_A4,	R_ADDR1
	STI	  R_BASE,         *\--R_USP(1)
	STI	  R_USE,	  *\--R_USP(1)
	LDF    *++R_ATMP(R_BASE),     R_A2
	SUBF   *++R_ADDR1(R_BASE),    R_A2
	SUBI3     2,		      R_A1,	RC
	RPTBD	  vfssub_loop
	   LDI	  R_A3,		      R_BASE
	   LDI  *+R_USP(2),	      R_USE
	   RND    R_A2
	 STF      R_A2,		     *R_ATMP++(R_BASE)
	 LDF     *R_ATMP,	      R_A2
	 SUBF  *++R_ADDR1(R_USE),     R_A2
vfssub_loop:
	 RND      R_A2
	BuD	  R_LR
 	   STF	  R_A2,		     *R_ATMP
	   LDI	 *R_USP++(1),	      R_USE
	   LDI	 *R_USP++(1),	      R_BASE
--
-- end of VfsSub
--

--}}}
--{{{ VfsMul

Function VfsMul
--
--	void VfsMul( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	width of x in sizeof (float) units
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	width of y in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3     -2,		      R_A2,	R_ATMP
	LSH3     -2,		      R_A4,	R_ADDR1
	STI	  R_BASE,         *\--R_USP(1)
	STI	  R_USE,	  *\--R_USP(1)
	LDF    *++R_ATMP(R_BASE),     R_A2
	MPYF   *++R_ADDR1(R_BASE),    R_A2
	SUBI3     2,		      R_A1,	RC
	RPTBD	  vfsmul_loop
	   LDI	  R_A3,		      R_BASE
	   LDI  *+R_USP(2),	      R_USE
	   RND    R_A2
	 STF      R_A2,		     *R_ATMP++(R_BASE)
	 LDF     *R_ATMP,	      R_A2
	 MPYF  *++R_ADDR1(R_USE),     R_A2
vfsmul_loop:
	 RND      R_A2
	BuD	  R_LR
 	   STF	  R_A2,		     *R_ATMP
	   LDI	 *R_USP++(1),	      R_USE
	   LDI	 *R_USP++(1),	      R_BASE
--
-- end of VfsMul
--

--}}}
--{{{ VfsDiv

Function VfsDiv
--
--	void VfsDiv( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	distance between elements of 'y' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	   2, 			R_A1,		RC
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,		R_T1
	LDI	  *R_USP,		R_USE
	LSH3	  -2,			R_A4,		R_ADDR1
	ADDI	   R_BASE,		R_ATMP
	RPTBD	   vfsdiv_loop
	   LDF	*++R_ADDR1(R_BASE),	R_A4
	   LDI	   R_BASE,		R_ADDR2
	   LDI	   R_A3,		R_BASE
	 RCPF	   R_A4,		R_FT1
	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_FT1,	       *R_ATMP,	R_A2
	 RND	   R_A2
vfsdiv_loop:
	 STF	   R_A2,	       *R_ATMP++(R_BASE)
	 || LDF	*++R_ADDR1(R_USE),	R_A4
	RCPF	   R_A4,		R_FT1
	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3      R_FT1,	       *R_ATMP,		R_A2
	RND	   R_A2
	BuD	   R_LR
	   STF	   R_A2,	       *R_ATMP
	   LDI	   R_T1,	        R_USE
	   LDI	   R_ADDR2,		R_BASE
--
-- end of VfsDiv
--

--}}}
--{{{ VdsAdd

Function VdsAdd
--
--	void VdsAdd( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	width of 'x' in sizeof (double) units
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	width of 'y' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3       -2,		      R_A2,		R_ATMP
	LSH3       -2,		      R_A4,		R_ADDR1
	STI	    R_BASE,       *\--R_USP(1)
	STI	    R_USE,	  *\--R_USP(1)
	LDF      *++R_ATMP(R_BASE),   R_A2
	|| LDF   *++R_ADDR1(R_BASE),  R_FT1
	LDI       *+R_ATMP(1),	      R_A2
	|| LDI    *+R_ADDR1(1),	      R_FT1
	SUBI3       2,		      R_A1,		RC
	RPTBD	    vdsadd_loop
	   ADDF     R_FT1,	      R_A2
	   LSH3	    1,		      R_A3,		R_BASE
	   LSH3     1,		    *+R_USP(2),		R_USE
	 STI        R_A2,	    *+R_ATMP(1)
	 STF        R_A2,	     *R_ATMP++(R_BASE)
	 LDF       *R_ATMP,	      R_A2
	 || LDF  *++R_ADDR1(R_USE),   R_FT1
	 LDI      *+R_ATMP(1),	      R_A2
	 || LDI   *+R_ADDR1(1),       R_FT1
vdsadd_loop:
	 ADDF	    R_FT1,	      R_A2
 	STI	    R_A2,	    *+R_ATMP(1)
	BuD	    R_LR
 	   STF	    R_A2,	     *R_ATMP
	   LDI	   *R_USP++(1),	      R_USE
	   LDI	   *R_USP++(1),	      R_BASE
--
-- end of VdsAdd
--

--}}}
--{{{ VdsSub

Function VdsSub
--
--	void VdsSub( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	width of 'x' in sizeof (double) units
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	width of 'y' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3       -2,		      R_A2,		R_ATMP
	LSH3       -2,		      R_A4,		R_ADDR1
	STI	    R_BASE,       *\--R_USP(1)
	STI	    R_USE,	  *\--R_USP(1)
	LDF      *++R_ATMP(R_BASE),   R_A2
	|| LDF   *++R_ADDR1(R_BASE),  R_FT1
	LDI       *+R_ATMP(1),	      R_A2
	|| LDI    *+R_ADDR1(1),	      R_FT1
	SUBI3       2,		      R_A1,		RC
	RPTBD	    vdssub_loop
	   SUBF     R_FT1,	      R_A2
	   LSH3	    1,		      R_A3,		R_BASE
	   LSH3     1,		    *+R_USP(2),		R_USE
	 STI        R_A2,	    *+R_ATMP(1)
	 STF        R_A2,	     *R_ATMP++(R_BASE)
	 LDF       *R_ATMP,	      R_A2
	 || LDF  *++R_ADDR1(R_USE),   R_FT1
	 LDI      *+R_ATMP(1),	      R_A2
	 || LDI   *+R_ADDR1(1),       R_FT1
vdssub_loop:
	 SUBF	    R_FT1,	      R_A2
 	STI	    R_A2,	    *+R_ATMP(1)
	BuD	    R_LR
 	   STF	    R_A2,	     *R_ATMP
	   LDI	   *R_USP++(1),	      R_USE
	   LDI	   *R_USP++(1),	      R_BASE
--
-- end of VdsSub
--

--}}}
--{{{ VdsMul

Function VdsMul
--
--	void VdsMul( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	width of 'x' in sizeof (double) units
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	width of 'y' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	LSH3       -2,		      R_A2,		R_ATMP
	LSH3       -2,		      R_A4,		R_ADDR1
	STI	    R_BASE,       *\--R_USP(1)
	STI	    R_USE,	  *\--R_USP(1)
	LDF      *++R_ATMP(R_BASE),   R_A2
	|| LDF   *++R_ADDR1(R_BASE),  R_FT1
	LDI       *+R_ATMP(1),	      R_A2
	|| LDI    *+R_ADDR1(1),	      R_FT1
	SUBI3       2,		      R_A1,		RC
	RPTBD	    vdsmul_loop
	   MPYF     R_FT1,	      R_A2
	   LSH3	    1,		      R_A3,		R_BASE
	   LSH3     1,		    *+R_USP(2),		R_USE
	 STI        R_A2,	    *+R_ATMP(1)
	 STF        R_A2,	     *R_ATMP++(R_BASE)
	 LDF       *R_ATMP,	      R_A2
	 || LDF  *++R_ADDR1(R_USE),   R_FT1
	 LDI      *+R_ATMP(1),	      R_A2
	 || LDI   *+R_ADDR1(1),       R_FT1
vdsmul_loop:
	 MPYF	    R_FT1,	      R_A2
 	STI	    R_A2,	    *+R_ATMP(1)
	BuD	    R_LR
 	   STF	    R_A2,	     *R_ATMP
	   LDI	   *R_USP++(1),	      R_USE
	   LDI	   *R_USP++(1),	      R_BASE
--
-- end of VdsMul
--

--}}}
--{{{ VdsDiv

Function VdsDiv
--
--	void VdsDiv( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (double)
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	distance between elements of 'y' in units of sizeof (double)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the corresponding element of 'y'.
--	Does not alter 'y'.
--
	SUBI3	   2, 			R_A1,		RC
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,		R_T1
	LSH3	   1,		      *+R_USP(0),	R_USE
	LSH3	  -2,			R_A4,		R_ADDR1
	ADDI	   R_BASE,		R_ATMP
	LDF	*++R_ADDR1(R_BASE),	R_A4
	RPTBD	   vdsdiv_loop
	   LDI	   R_BASE,		R_ADDR2
	   LDI	 *+R_ADDR1(1),		R_A4
	   LSH3	   1,			R_A3,		R_BASE
	 RCPF	   R_A4,		R_FT1

	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A4,		R_FT1,		R_FT2
	 SUBRF	   1.0,			R_FT2
	 MPYF	   R_FT1,		R_FT2
	 ADDF	   R_FT2,		R_FT1

	 LDF	  *R_ATMP,		R_A2
	 LDI	 *+R_ATMP(1),		R_A2

	 MPYF	   R_FT1,	       	R_A2

	 STI	   R_A2,	      *+R_ATMP(1)
	 STF	   R_A2,	       *R_ATMP++(R_BASE)
	 || LDF	*++R_ADDR1(R_USE),	R_A4
vdsdiv_loop:
	 LDI	 *+R_ADDR1(1),		R_A4
	RCPF	   R_A4,		R_FT1

	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A4,		R_FT1,		R_FT2
	SUBRF	   1.0,			R_FT2
	MPYF	   R_FT1,		R_FT2
	ADDF	   R_FT2,		R_FT1

	LDF	  *R_ATMP,		R_A2
	LDI	 *+R_ATMP(1),		R_A2

	MPYF       R_FT1,	       	R_A2
	STF	   R_A2,	       *R_ATMP
	BuD	   R_LR
	   STI	   R_A2,	      *+R_ATMP(1)
	   LDI	   R_T1,	        R_USE
	   LDI	   R_ADDR2,		R_BASE
--
-- end of VdsDiv
--

--}}}
--{{{ VfsAddScalar

Function VfsAddScalar
--
--	void VfsAddScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	width of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the floating point argument
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vfsadds_loop
	   STI	     R_USE,	    *\--R_USP(1)
	   ADDF3  *++R_ATMP(R_BASE),	R_A1,		R_A4
	   LDI	   *+R_USP(1),		R_USE
	 RND	     R_A4
	 STF	     R_A4,	       *R_ATMP
vfsadds_loop:
	 ADDF3    *++R_ATMP(R_USE),     R_A1,		R_A4
	BuD	     R_LR
	   RND	     R_A4
           STF	     R_A4,	       *R_ATMP
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VfsAddScalar
--

--}}}
--{{{ VfsSubScalar

Function VfsSubScalar
--
--	void VfsSubScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x' 
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	width of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the floating point argument
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vfssubs_loop
	   STI	     R_USE,	    *\--R_USP(1)
	   SUBF3     R_A1,	     *++R_ATMP(R_BASE),	R_A4
	   LDI	   *+R_USP(1),		R_USE
	 RND	     R_A4
	 STF	     R_A4,	       *R_ATMP
vfssubs_loop:
	 SUBF3       R_A1,	     *++R_ATMP(R_USE),  R_A4
	BuD	     R_LR
	   RND	     R_A4
           STF	     R_A4,	       *R_ATMP
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VfsSubScalar
--

--}}}
--{{{ VfsMulScalar

Function VfsMulScalar
--
--	void VfsMulScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	width of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the floating point argument
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vfsmuls_loop
	   STI	     R_USE,	    *\--R_USP(1)
	   MPYF3  *++R_ATMP(R_BASE),	R_A1,		R_A4
	   LDI	   *+R_USP(1),		R_USE
	 RND	     R_A4
	 STF	     R_A4,	       *R_ATMP
vfsmuls_loop:
	 MPYF3    *++R_ATMP(R_USE),     R_A1,		R_A4
	BuD	     R_LR
	   RND	     R_A4
           STF	     R_A4,	       *R_ATMP
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VfsMulScalar
--

--}}}
--{{{ VfsDivScalar

Function VfsDivScalar
--
--	void VfsDivScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP   distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the floating point argument
--
	LSH3	     -2,	       R_A4,		R_ATMP
	STI	      R_A1,	   *\--R_USP(1)
	SUBI3	      2,	       R_A3,		RC
	LDF	     *R_USP++(1),      R_A1
	LDI	      R_A2,	       R_A1
	LDI	      R_USE,	       R_T1
	LDI	     *R_USP,	       R_USE
	RCPF	      R_A1,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF         2.0,	       R_FT2
	RPTBD	      vfsdivs_loop
	   MPYF	      R_FT2,	       R_FT1
	   MPYF3      R_FT1,	    *++R_ATMP(R_BASE),	R_A1
	   LDI	      R_ATMP,	       R_ADDR1
	 RND	      R_A1
vfsdivs_loop:
	 STF	      R_A1,	      *R_ATMP++(R_USE)
	 || MPYF3  *++R_ADDR1(R_USE),  R_FT1,		R_A1
	BuD	      R_LR
	   RND	      R_A1
	   STF	      R_A1,	      *R_ATMP
	   LDI	      R_T1,	       R_USE
--
-- end of VfsDivScalar
--

--}}}
--{{{ VfsRecScalar

Function VfsRecScalar
--
--	void VfsRecScalar( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of the
--	floating point argument and that element of 'x'
--
	STI	   R_A1,	    *\--R_USP(1)
	SUBI3	   2, 			R_A3,		RC
	LDF	  *R_USP++(1),		R_A1
	LDI	   R_USE,		R_T1
	LDI	  *R_USP,		R_USE
	RPTBD	   vfsrecs_loop
	   LSH3	  -2,			R_A4,		R_ATMP
	   LDI	   R_A2,		R_A1
	   LDF	*++R_ATMP(R_BASE),	R_A3
	 RCPF	   R_A3,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1
	 MPYF3	   R_FT1,		R_A1,		R_A2
	 RND	   R_A2
	 STF	   R_A2,	       *R_ATMP++(R_USE)
vfsrecs_loop:
	 LDF	  *R_ATMP,		R_A3
	RCPF	   R_A3,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1
	LDI	   R_T1,		R_USE
	BuD	   R_LR
	   MPYF3   R_FT1,		R_A1,		R_A2
	   RND	   R_A2
	   STF	   R_A2,	       *R_ATMP
--
-- end of VfsRecScalar
--

--}}}
--{{{ VdsAddScalar

Function VdsAddScalar
--
--	void VdsAddScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x' 
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	width of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the sum of that element of
--	'x' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	LDF       *++R_ATMP(R_BASE),	R_A4
	STI	     R_USE,	    *\--R_USP(1)
	LDI        *+R_ATMP(1),		R_A4
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vdsadds_loop
	   LDI	     R_ATMP,		R_ADDR1
	   LSH3	     1,		      *+R_USP(1),	R_USE
	   ADDF	     R_A1,		R_A4
	 STI	     R_A4,	      *+R_ADDR1(1)
	 STF	     R_A4,	       *R_ADDR1++(R_USE)
	 || LDF   *++R_ATMP(R_USE),     R_A4
	 LDI       *+R_ATMP(1),         R_A4
vdsadds_loop:
	 ADDF	     R_A1,		R_A4
	BuD	     R_LR
           STF	     R_A4,	       *R_ADDR1
           STI	     R_A4,	      *+R_ADDR1(1)
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VdsAddScalar
--

--}}}
--{{{ VdsSubScalar

Function VdsSubScalar
--
--	void VdsSubScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x' 
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	width of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the difference of that element of
--	'x' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	LDF       *++R_ATMP(R_BASE),	R_A4
	STI	     R_USE,	    *\--R_USP(1)
	LDI        *+R_ATMP(1),		R_A4
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vdssubs_loop
	   LDI	     R_ATMP,		R_ADDR1
	   LSH3	     1,		      *+R_USP(1),	R_USE
	   SUBF	     R_A1,		R_A4
	 STI	     R_A4,	      *+R_ADDR1(1)
	 STF	     R_A4,	       *R_ADDR1++(R_USE)
	 || LDF   *++R_ATMP(R_USE),     R_A4
	 LDI       *+R_ATMP(1),         R_A4
vdssubs_loop:
	 SUBF	     R_A1,		R_A4
	BuD	     R_LR
           STF	     R_A4,	       *R_ADDR1
           STI	     R_A4,	      *+R_ADDR1(1)
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VdsSubScalar
--

--}}}
--{{{ VdsMulScalar

Function VdsMulScalar
--
--	void VdsMulScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant bits of FP number
--	R_A2	least significant bits of FP number
--	R_A3	number of elements in array 'x' 
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	width of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the product of that element of
--	'x' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LSH3	    -2,			R_A4,		R_ATMP
	LDF	    *R_USP++(1),	R_A1
	LDI	     R_A2,		R_A1
	LDF       *++R_ATMP(R_BASE),	R_A4
	STI	     R_USE,	    *\--R_USP(1)
	LDI        *+R_ATMP(1),		R_A4
	SUBI3	     2,			R_A3,		RC
	RPTBD	     vdsmuls_loop
	   LDI	     R_ATMP,		R_ADDR1
	   LSH3	     1,		      *+R_USP(1),	R_USE
	   MPYF	     R_A1,		R_A4
	 STI	     R_A4,	      *+R_ADDR1(1)
	 STF	     R_A4,	       *R_ADDR1++(R_USE)
	 || LDF   *++R_ATMP(R_USE),     R_A4
	 LDI       *+R_ATMP(1),         R_A4
vdsmuls_loop:
	 MPYF	     R_A1,		R_A4
	BuD	     R_LR
           STF	     R_A4,	       *R_ADDR1
           STI	     R_A4,	      *+R_ADDR1(1)
	   LDI	    *R_USP++(1),	R_USE
--
-- end of VdsMulScalar
--

--}}}
--{{{ VdsDivScalar

Function VdsDivScalar
--
--	void VdsDivScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP   distance between elements of 'x' in units of sizeof (double)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of that element of
--	'x' and the double precision argument
--
	LSH3	     -2,	       R_A4,		R_ATMP
	STI	      R_A1,	   *\--R_USP(1)
	SUBI3	      2,	       R_A3,		RC
	LDF	     *R_USP++(1),      R_A1
	LDI	      R_A2,	       R_A1
	LDI	      R_USE,	       R_T1
	LSH3	      1,	     *+R_USP(0),	R_USE
	RCPF	      R_A1,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF         2.0,	       R_FT2
	MPYF	      R_FT2,	       R_FT1

	MPYF3	      R_A1,	       R_FT1,		R_FT2
	SUBRF	      1.0,	       R_FT2
	MPYF	      R_FT1,	       R_FT2
	ADDF	      R_FT2,	       R_FT1

	LDF	   *++R_ATMP(R_BASE),  R_A1
	RPTBD	      vdsdivs_loop
	   LDI	    *+R_ATMP(1),       R_A1
	   MPYF       R_FT1,	       R_A1
	   LDI	      R_ATMP,	       R_ADDR1
	 STI	      R_A1,	     *+R_ATMP(1)
	 STF	      R_A1,	      *R_ATMP++(R_USE)
	 || LDF	   *++R_ADDR1(R_USE),  R_A2
	 LDI	    *+R_ADDR1(1),      R_A2
vdsdivs_loop:
	 MPYF3	      R_FT1,	       R_A2,		R_A1
	BuD	      R_LR
	   STF	      R_A1,	      *R_ATMP
	   STI	      R_A1,	     *+R_ATMP(1)
	   LDI	      R_T1,	       R_USE
--
-- end of VdsDivScalar
--

--}}}
--{{{ VdsRecScalar

Function VdsRecScalar
--
--	void VdsRecScalar( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	most  significant 32 bits of FP number
--	R_A2	least significant 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the quotient of the
--	double precision argument and that element of 'x'
--
	STI	   R_A1,	    *\--R_USP(1)
	SUBI3	   2, 			R_A3,		RC
	LDF	  *R_USP++(1),		R_A1
	LDI	   R_USE,		R_T1
	LSH3	   1,		      *+R_USP(0),	R_USE
	LSH3	  -2,			R_A4,		R_ATMP
	RPTBD	   vdsrecs_loop
	   LDI	   R_A2,		R_A1
	   LDF	*++R_ATMP(R_BASE),	R_A3
	   LDI	   R_ATMP,		R_ADDR1
	 RCPF	   R_A3,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   2.0,			R_FT2
	 MPYF	   R_FT2,		R_FT1

	 MPYF3	   R_A3,		R_FT1,		R_FT2
	 SUBRF	   1.0,			R_FT2
	 MPYF	   R_FT1,		R_FT2
	 ADDF	   R_FT2,		R_FT1

	 MPYF3	   R_FT1,		R_A1,		R_A2
	 STI	   R_A2,	      *+R_ATMP(1)
	 STF	   R_A2,	       *R_ATMP++(R_USE)
	 || LDF	*++R_ADDR1(R_USE),	R_A3
vdsrecs_loop:
	 LDI	 *+R_ADDR1(1),		R_A3
	RCPF	   R_A3,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   2.0,			R_FT2
	MPYF	   R_FT2,		R_FT1

	MPYF3	   R_A3,		R_FT1,		R_FT2
	SUBRF	   1.0,			R_FT2
	MPYF	   R_FT1,		R_FT2
	ADDF	   R_FT2,		R_FT1

	LDI	   R_T1,		R_USE
	BuD	   R_LR
	   MPYF3   R_FT1,		R_A1,		R_A2
	   STF	   R_A2,	       *R_ATMP
	   STI	   R_A2,	      *+R_ATMP(1)
--
-- end of VdsRecScalar
--

--}}}
--{{{ VfsCopy

Function VfsCopy
--
--	void VfsCopy( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in sizeof (float) units
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	distance between elements of 'y' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the corresponding element of 'y'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LSH3	  -2,			R_A4,		R_ADDR1
	ADDI	   R_BASE,		R_ATMP
	LDF	*++R_ADDR1(R_BASE),	R_A2
	STI	   R_BASE,	    *\--R_USP(1)
	SUBI3	   2,		    	R_A1,		RC
	RPTBD	   vfscopy_loop
	   STI	   R_USE,	    *\--R_USP(1)
	   LDI	   R_A3,	    	R_BASE
	   LDI	 *+R_USP(2),		R_USE
vfscopy_loop:
	 LDF	*++R_ADDR1(R_USE),	R_A2
	 || STF	   R_A2,	       *R_ATMP++(R_BASE)
	BuD	   R_LR
           STF	   R_A2,	       *R_ATMP
	   LDI	  *R_USP++(1),	        R_USE
	   LDI	  *R_USP++(1),		R_BASE
--
-- end of VfsCopy
--

--}}}
--{{{ VdsCopy

Function VdsCopy
--
--	void VdsCopy( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in sizeof (double) units
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	distance between elements of 'y' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the corresponding element of 'y'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LSH3	  -2,			R_A4,		R_ADDR1
	LDI	*++R_ADDR1(R_BASE),	R_A2
	STI	   R_A2,	     *++R_ATMP(R_BASE)
	|| LDI	 *+R_ADDR1(1),		R_A4
	STI	   R_BASE,	    *\--R_USP(1)
	SUBI3	   2,		    	R_A1,		RC
	RPTBD	   vdscopy_loop
	   STI	   R_USE,	    *\--R_USP(1)
	   LSH3	   1,		        R_A3,	    	R_BASE
	   LSH3	   1,		      *+R_USP(2),	R_USE
	 STI	   R_A4,	      *+R_ATMP(1)
	 || LDI	*++R_ADDR1(R_USE),      R_A2
vdscopy_loop:
	 STI	   R_A2,	     *++R_ATMP(R_BASE)
	 || LDI	 *+R_ADDR1(1),		R_A4
	BuD	   R_LR
           STI	   R_A4,	      *+R_ATMP(1)
	   LDI	  *R_USP++(1),	        R_USE
	   LDI	  *R_USP++(1),		R_BASE
--
-- end of VdsCopy
--

--}}}
--{{{ VfsFill

Function VfsFill
--
--	void VfsFill( float value, uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of floating point array 'x'
--     *R_USP	distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the floating point argument
--
	STI	  R_A1,	    *\--R_USP(1)
	LDF	 *R_USP++(1),	R_A1
	LDI	  R_A2,		R_A1
	RND	  R_A1
	LSH3	 -2,		R_A4,	R_ATMP
	SUBI3	  2,		R_A3,	RC
	RPTBD	  vfsfill_loop
	   STF	  R_A1,      *++R_ATMP(R_BASE)
	   STI	  R_USE,    *\--R_USP(1)
	   LDI	*+R_USP(1),	R_USE
vfsfill_loop:
	 STF	  R_A1,	     *++R_ATMP(R_USE)
	LDI	 *R_USP++(1),	R_USE
	Bu	  R_LR
--
-- end of VfsFill
--

--}}}
--{{{ VdsFill

Function VdsFill
--
--	void VdsFill( double value, uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	binary pattern of top    32 bits of FP number
--	R_A2	binary pattern of bottom 32 bits of FP number
--	R_A3	number of elements in array 'x'
--	R_A4	byte offset of start of double precision array 'x'
--     *R_USP	distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Purpose
--	Places into each element of 'x' the double precision argument
--
	STI	  R_A1,	    *\--R_USP(1)
	LDF	 *R_USP++(1),	R_A1
	LSH3	 -2,		R_A4,	R_ATMP
	LDI	  R_A2,		R_A1
	SUBI3	  2,		R_A3,	RC
	STF	  R_A1,      *++R_ATMP(R_BASE)
	RPTBD	  vdsfill_loop
	   STI	  R_A1,       *+R_ATMP(1)
	   STI	  R_USE,    *\--R_USP(1)
	   LSH3	  1,          *+R_USP(1),	R_USE
	 STF	  R_A1,	     *++R_ATMP(R_USE)
vdsfill_loop:
	 STI	  R_A1,	      *+R_ATMP(1)
	LDI	 *R_USP++(1),	R_USE
	Bu	  R_LR
--
-- end of VdsFill
--

--}}}
--{{{ VfsMax

Function VfsMax
--
--	uword VfsMax( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3    distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (signed) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LDI	   R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	RPTBD	   vfsmax_loop
	   LDF	*++R_ATMP(R_BASE),	R_A3
	   LDI	   0,			R_A2
	   LDI	   0,			R_A1
	 LDF	*++R_ATMP(R_USE),	R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIgt	   R_A2,		R_A1
vfsmax_loop:
	 LDFgt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VfsMax
--

--}}}
--{{{ VdsMax

Function VdsMax
--
--	uword VdsMax( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3    distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (signed) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LSH3	   1,		        R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	LDF	*++R_ATMP(R_BASE),	R_A3
	RPTBD	   vdsmax_loop
	   LDI	   0,			R_A2
	   LDI	 *+R_ATMP(1),		R_A3
	   LDI	   0,			R_A1
	 LDF	*++R_ATMP(R_USE),	R_A4
	 LDI	 *+R_ATMP(1),		R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIgt	   R_A2,		R_A1
vdsmax_loop:
	 LDFgt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VdsMax
--

--}}}
--{{{ VfsMin

Function VfsMin
--
--	uword VfsMin( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3    distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (signed) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LDI	   R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	RPTBD	   vfsmin_loop
	   LDF	*++R_ATMP(R_BASE),	R_A3
	   LDI	   0,			R_A2
	   LDI	   0,			R_A1
	 LDF	*++R_ATMP(R_USE),	R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIlt	   R_A2,		R_A1
vfsmin_loop:
	 LDFlt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VfsMin
--

--}}}
--{{{ VdsMin

Function VdsMin
--
--	uword VdsMin( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3    distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (signed) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,		R_T1
	LSH3	   1,		        R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	LDF	*++R_ATMP(R_BASE),	R_A3
	RPTBD	   vdsmin_loop
	   LDI	   0,			R_A2
	   LDI	 *+R_ATMP(1),		R_A3
	   LDI	   0,			R_A1
	 LDF	*++R_ATMP(R_USE),	R_A4
	 LDI	 *+R_ATMP(1),		R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIlt	   R_A2,		R_A1
vdsmin_loop:
	 LDFlt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VdsMin
--

--}}}
--{{{ VfsAmax

Function VfsAmax
--
--	uword VfsAmax( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3    distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LDI	   R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	RPTBD	   vfsamax_loop
	   ABSF	*++R_ATMP(R_BASE),	R_A3	   
	   LDI	   0,			R_A2
	   LDI	   0,			R_A1
	 ABSF	*++R_ATMP(R_USE),	R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIgt	   R_A2,		R_A1
vfsamax_loop:
	 LDFgt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VfsAmax
--

--}}}
--{{{ VdsAmax

Function VdsAmax
--
--	uword VdsAmax( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3    distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LSH3	   1,		        R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	LDF	*++R_ATMP(R_BASE),	R_A3
	LDI	   0,			R_A2
	RPTBD	   vdsamax_loop
	   LDI	   0,			R_A1
	   LDI	 *+R_ATMP(1),		R_A3
	   ABSF	   R_A3
	 LDF	*++R_ATMP(R_USE),	R_A4
	 LDI	 *+R_ATMP(1),		R_A4
	 ABSF	   R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIgt	   R_A2,		R_A1
vdsamax_loop:
	 LDFgt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VdsAmax
--

--}}}
--{{{ VfsAmin

Function VfsAmin
--
--	uword VfsAmin( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3    distance between elements of 'x' in sizeof (float) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of largest value in 'x'
--
-- Purpose
--	Finds the largest (absolute) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LDI	   R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	RPTBD	   vfsamin_loop
	   ABSF	*++R_ATMP(R_BASE),	R_A3	   
	   LDI	   0,			R_A2
	   LDI	   0,			R_A1
	 ABSF	*++R_ATMP(R_USE),	R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIlt	   R_A2,		R_A1
vfsamin_loop:
	 LDFlt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VfsAmin
--

--}}}
--{{{ VdsAmin

Function VdsAmin
--
--	uword VdsAmin( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3    distance between elements of 'x' in sizeof (double) units
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	index of least value in 'x'
--
-- Purpose
--	Finds the least (absolute) value in 'x'
--
	LSH3	  -2,			R_A2,		R_ATMP
	LDI	   R_USE,	        R_T1
	LSH3	   1,		        R_A3,		R_USE
	SUBI3	   2,			R_A1,		RC
	LDF	*++R_ATMP(R_BASE),	R_A3
	LDI	   0,			R_A2
	RPTBD	   vdsamin_loop
	   LDI	   0,			R_A1
	   LDI	 *+R_ATMP(1),		R_A3
	   ABSF	   R_A3
	 LDF	*++R_ATMP(R_USE),	R_A4
	 LDI	 *+R_ATMP(1),		R_A4
	 ABSF	   R_A4
	 ADDI	   1,			R_A2
	 CMPF	   R_A3,		R_A4
	 LDIlt	   R_A2,		R_A1
vdsamin_loop:
	 LDFlt	   R_A4,		R_A3
	LDI	   R_T1,		R_USE
	Bu	   R_LR
--
-- end of VdsAmin
--

--}}}
--{{{ VfsDot

Function VfsDot
--
--	float VfDot( uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_A4	byte offset of start of floating point array 'y'
--     *R_USP	distance between elements of 'y' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the products of each pair of elements
--	in the two arrays.  Does not alter the input arrays.
--
	LSH3	     -2,		  R_A2,			R_ATMP
	LSH3	     -2,		  R_A4,			R_ADDR1
	MPYF3	   *++R_ATMP(R_BASE),  *++R_ADDR1(R_BASE),	R_A2
	STI	      R_USE,	      *\--R_USP(1)
	SUBI3	      2,		  R_A1,			RC	
	LDF	      0.0,		  R_A4
	RPTBD	      vfsdot_loop
	   STI	      R_BASE,	      *\--R_USP(1)
	   LDI	      R_A3,		  R_BASE
	   LDI	    *+R_USP(2),		  R_USE
vfsdot_loop:
	 MPYF3	   *++R_ATMP(R_BASE),  *++R_ADDR1(R_USE),	R_A2
	 || ADDF3     R_A2,		  R_A4,			R_A4
	ADDF3	      R_A2,		  R_A4,			R_A1
	BuD	      R_LR
	   RND	      R_A1
	   LDI	     *R_USP++(1),	  R_BASE
	   LDI	     *R_USP++(1),	  R_USE
--
-- end of VfsDot
--

--}}}
--{{{ VdsDot

Function VdsDot
--
--	double VdDot( uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	number of elements in arrays 'x' and 'y'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (double)
--	R_A4	byte offset of start of double precision array 'y'
--     *R_USP	distance between elements of 'y' in units of sizeof (double)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the products of each pair of elements
--	in the two arrays.  Does not alter the input arrays.
--
	LSH3	     -2,		  R_A2,			R_ATMP
	LSH3	     -2,		  R_A4,			R_ADDR1
	LDF	   *++R_ATMP(R_BASE),	  R_A2
	|| LDF	   *++R_ADDR1(R_BASE),	  R_A4
	SUBI3	      2,		  R_A1,			RC	
	STI	      R_USE,	      *\--R_USP(1)
	LDI	    *+R_ATMP(1),	  R_A2
	|| LDI	    *+R_ADDR1(1),	  R_A4
	MPYF3	      R_A4,		  R_A2,			R_A1
	RPTBD	      vdsdot_loop
	   STI	      R_BASE,	      *\--R_USP(1)
	   LSH3	      1,	          R_A3,			R_BASE
	   LSH3	      1,	        *+R_USP(2),		R_USE         
	 LDF	   *++R_ATMP(R_BASE),	  R_A2
	 || LDF	   *++R_ADDR1(R_USE),	  R_A4
	 LDI	    *+R_ATMP(1),	  R_A2
	 || LDI	    *+R_ADDR1(1),	  R_A4
	 MPYF	      R_A4,		  R_A2
vdsdot_loop:
	 ADDF	      R_A2,		  R_A1
	BuD	      R_LR
	   LDI	     *R_USP++(1),	  R_BASE
	   NOP
	   LDI	     *R_USP++(1),	  R_USE
--
-- end of VfsDot
--

--}}}
--{{{ VfsSum

Function VfsSum
--
--	float VfsSum( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x' 
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the elements in the array.
--
	LSH3	  -2,		   R_A2,	R_ATMP
	SUBI3	   2,		   R_A1,	RC
	RPTBD	   vfssum_loop
	   LDF	*++R_ATMP(R_BASE), R_A1
	   LDI	   R_USE,	   R_A2
	   LDI	   R_A3,	   R_USE
vfssum_loop:
	 ADDF	*++R_ATMP(R_USE),  R_A1
	BuD	   R_LR
	   RND	   R_A1
	   LDI	   R_A2,	   R_USE
	   NOP
--
-- end of VfsSum
--

--}}}
--{{{ VdsSum

Function VdsSum
--
--	double VdsSum( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the sum of the elements in the array.
--
	LSH3	  -2,		   R_A2,	R_ATMP
	SUBI3	   2,		   R_A1,	RC
	LDF	*++R_ATMP(R_BASE), R_A1
	RPTBD	   vdssum_loop
	   LDI	 *+R_ATMP(1),      R_A1
	   LDI	   R_USE,	   R_A2
	   LSH3	   1,		   R_A3,	R_USE
	 LDF	*++R_ATMP(R_USE),  R_A3
	 LDI	 *+R_ATMP(1),      R_A3
vdssum_loop:
	 ADDF	   R_A3,	   R_A1
	LDI	   R_A2,	   R_USE
	Bu	   R_LR
--
-- end of VdsSum
--

--}}}
--{{{ VfsProd

Function VfsProd
--
--	float VfsProd( uword n, float * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of floating point array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the product of the elements in the array.
--
	LSH3	  -2,		   R_A2,	R_ATMP
	SUBI3	   2,		   R_A1,	RC
	RPTBD	   vfsprod_loop
	   LDF	*++R_ATMP(R_BASE), R_A1
	   LDI	   R_USE,	   R_A2
	   LDI	   R_A3,	   R_USE
vfsprod_loop:
	 MPYF	*++R_ATMP(R_USE),  R_A1
	BuD	   R_LR
	   RND	   R_A1
	   LDI	   R_A2,	   R_USE
	   NOP
--
-- end of VfsProd
--

--}}}
--{{{ VdsProd

Function VdsProd
--
--	double VdsProd( uword n, double * x, word x_stride )
--
-- Upon Entry:
--	R_A1	number of elements in array 'x'
--	R_A2	byte offset of start of double precision array 'x'
--	R_A3	distance between elements of 'x' in units of sizeof (float)
--	R_LR	return address
--	R_BASE	base address of data RAM
--
-- Upon Exit
--	R_A1	FP result
--
-- Purpose
--	Computes the product of the elements in the array.
--
	LSH3	  -2,		   R_A2,	R_ATMP
	SUBI3	   2,		   R_A1,	RC
	LDF	*++R_ATMP(R_BASE), R_A1
	RPTBD	   vdsprod_loop
	   LDI	 *+R_ATMP(1),      R_A1
	   LDI	   R_USE,	   R_A2
	   LSH3	   1,		   R_A3,	R_USE
	 LDF	*++R_ATMP(R_USE),  R_A3
	 LDI	 *+R_ATMP(1),      R_A3
vdsprod_loop:
	 MPYF	   R_A3,	   R_A1
	LDI	   R_A2,	   R_USE
	Bu	   R_LR
--
-- end of VdsProd
--

--}}}
--{{{ VfsMulAdd

Function VfsMulAdd
--
--	void VfsMulAdd( float value, uword n, float * x, word x_stride, float * y, word y_stride )
--
-- Upon Entry:
--	R_A1	 most  significant 32 bits of FP number
--	R_A2	 least significant 32 bits of FP number
--	R_A3	 number of elements in arrays 'x' and 'y'
--	R_A4	 byte offset of start of floating point array 'x'
--     *R_USP    distance between elements of 'x' in sizeof (float) units
--    *+R_USP(1) byte offset of start of floating point array 'y'
--    *+R_USP(2) distance between elements of 'y' in sizeof (float) units
--	R_LR	 return address
--	R_BASE	 base address of data RAM
--
-- Purpose
--	For each element in 'x' the function computes the sum of
--	that element with the product of the corresponding
--	element of 'y' and the floating point argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LDF	    *R_USP++(1),	R_A1
	LSH3	    -2,			R_A4,		R_ATMP
	SUBI3	     2,			R_A3,		RC
	LSH3        -2,		      *+R_USP(1),	R_ADDR1
	LDI	     R_A2,		R_A1
	LDI	     R_USE,		R_T1
	MPYF3     *++R_ADDR1(R_BASE),	R_A1,		R_A2
	ADDF	  *++R_ATMP(R_BASE),	R_A2
	RPTBD	     vfsmuladd_loop
	   LDI	   *+R_USP(2),		R_USE
	   LDI	     R_BASE,		R_ADDR2
	   LDI	    *R_USP,		R_BASE
	 RND	     R_A2
	 STF	     R_A2,	       *R_ATMP++(R_BASE)
	 || MPYF3 *++R_ADDR1(R_USE),	R_A1,		R_A2
vfsmuladd_loop:
	 ADDF	    *R_ATMP,		R_A2
        LDI	     R_ADDR2,		R_BASE
	BuD	     R_LR
	   RND	     R_A2
	   STF	     R_A2,	       *R_ATMP
	   LDI	     R_T1,	        R_USE
--
-- end of VfsMulAdd
--

--}}}
--{{{ VdsMulAdd

Function VdsMulAdd
--
--	void VdsMulAdd( double value, uword n, double * x, word x_stride, double * y, word y_stride )
--
-- Upon Entry:
--	R_A1	  most  significant 32 bits of FP number
--	R_A2	  least significant 32 bits of FP number
--	R_A3	  number of elements in arrays 'x' and 'y'
--	R_A4	  byte offset of start of double precision array 'x'
--     *R_USP     distance between elements of 'x' in sizeof (double) units
--    *+R_USP(1)  byte offset of start of double precision array 'y'
--    *+R_USP(2)  distance between elements of 'y' in sizeof (double) units
--	R_LR	  return address
--	R_BASE	  base address of data RAM
--
-- Purpose
--	For each element in 'x' the function computes the sum of
--	that element with the product of the corresponding
--	element of 'y' and the double precision argument.
--
	STI	     R_A1,	    *\--R_USP(1)
	LDF	    *R_USP++(1),	R_A1
	LSH3	    -2,			R_A4,		R_ATMP
	SUBI3	     2,			R_A3,		RC
	LSH3        -2,		      *+R_USP(1),	R_ADDR1
	LDI	     R_A2,		R_A1
	LDF	  *++R_ADDR1(R_BASE),	R_A2
	|| LDF    *++R_ATMP(R_BASE),	R_A3
	LDI	     R_BASE,		R_ADDR2
	LDI	     R_USE,		R_T1
	LSH3	     1,		      *+R_USP(0),	R_BASE
	RPTBD	     vdsmuladd_loop
	   LSH3	     1,		      *+R_USP(2),	R_USE
	   LDI	   *+R_ADDR1(1),	R_A2
	   || LDI  *+R_ATMP(1),		R_A3
	   MPYF      R_A1,		R_A2
	 ADDF	     R_A3,	        R_A2
	 STI	     R_A2,	      *+R_ATMP(1)
	 STF	     R_A2,	       *R_ATMP++(R_BASE)
	 LDF	  *++R_ADDR1(R_USE),	R_A2
	 || LDF     *R_ATMP,		R_A3
	 LDI	   *+R_ADDR1(1),	R_A2
	 || LDI    *+R_ATMP(1),		R_A3
vdsmuladd_loop:
	 MPYF        R_A1,		R_A2
	ADDF	     R_A3,		R_A2
	STI	     R_A2,	      *+R_ATMP(1)
	BuD	     R_LR
	   STF	     R_A2,	       *R_ATMP
	   LDI	     R_ADDR2,	        R_BASE
	   LDI	     R_T1,		R_USE
--
-- end of VdMulAdd
--

--}}}

--}}}
--{{{ Initialisation

init
	Bu	R_LR

--}}}

        EndModule

@


1.5
log
@fixed bug in VfsMax
@
text
@d1 2
d6 1
a6 1
; Copyright (c) 1992 by Perihelion Software Ltd.
d11 1
a11 1
; $Id: vectlib.a,v 1.4 1992/10/15 16:22:49 nickc Exp nickc $
d15 2
d21 2
d25 2
d35 2
d70 3
d106 3
d142 3
d194 3
d238 3
d282 3
d326 3
d400 3
d439 3
d478 3
d517 3
d563 3
d616 3
d658 3
d700 3
d742 3
d800 3
d872 3
d904 3
d942 3
d975 3
d1009 3
d1044 3
d1085 3
d1120 3
d1158 3
d1194 3
d1234 3
d1270 3
d1310 3
d1348 3
d1393 3
d1425 3
d1461 3
d1493 3
d1526 3
d1569 3
d1619 3
d1664 3
d1709 3
d1754 3
d1814 3
d1865 3
d1916 3
d1967 3
d2052 3
d2093 3
d2134 3
d2175 3
d2226 3
d2283 3
d2329 3
d2375 3
d2421 3
d2482 3
d2557 3
d2597 3
d2640 3
d2677 3
d2715 3
d2755 3
d2797 3
d2837 3
d2879 3
d2919 3
d2963 3
d3003 3
d3047 3
d3092 3
d3143 3
d3179 3
d3216 3
d3252 3
d3289 3
d3339 3
d3397 5
d3405 3
a3407 1
EndModule
a3408 1
; end of vectlib.a
@


1.4
log
@fixed bugs in VfMin and VfMax
@
text
@d9 1
a9 1
; $Id: vectlib.a,v 1.3 1992/10/15 16:01:01 nickc Exp nickc $
d2558 1
a2558 1
	 LDIgt	   R_A4,		R_A3
@


1.3
log
@fixed bugs in VfMulAdd and VfsMulAdd
@
text
@d9 1
a9 1
; $Id: vectlib.a,v 1.2 1992/10/15 14:49:38 nickc Exp nickc $
d938 1
a938 1
--	int VfMax( uword n, float * x )
d959 2
a960 2
	 CMPF	*++R_ATMP(1),		R_A2
	 LDFlt	 *-R_ATMP(1),		R_A2
d962 1
a962 1
	 LDIlt	   R_A3,		R_A1
d970 1
a970 1
--	int VdMax( uword n, double * x )
d1008 1
a1008 1
--	int VfMin( uword n, float * x )
d1029 2
a1030 2
	 CMPF	*++R_ATMP(1),		R_A2
	 LDFgt	 *-R_ATMP(1),		R_A2
d1032 1
a1032 1
	 LDIgt	   R_A3,		R_A1
d1040 1
a1040 1
--	int VdMin( uword n, double * x )
d1075 1
a1075 1
--	int VfAmax( uword n, float * x )
d1108 1
a1108 1
--	int VdAmax( uword n, double * x )
d1145 1
a1145 1
--	int VfAmin( uword n, float * x )
d1178 1
a1178 1
--	int VdAmin( uword n, double * x )
d2530 1
a2530 1
--	int VfsMax( uword n, float * x, word x_stride )
d2546 1
a2546 1
	STI	   R_USE,	    *\--R_USP(1)
d2559 1
a2559 1
	LDI	  *R_USP++(1),		R_USE
d2567 1
a2567 1
--	int VdsMax( uword n, double * x, word x_stride )
d2583 1
a2583 1
	STI	   R_USE,	    *\--R_USP(1)
d2597 2
a2598 2
	 LDIgt	   R_A4,		R_A3
	LDI	  *R_USP++(1),		R_USE
d2606 1
a2606 1
--	int VfsMin( uword n, float * x, word x_stride )
d2622 1
a2622 1
	STI	   R_USE,	    *\--R_USP(1)
d2634 2
a2635 2
	 LDIlt	   R_A4,		R_A3
	LDI	  *R_USP++(1),		R_USE
d2643 1
a2643 1
--	int VdsMin( uword n, double * x, word x_stride )
d2659 1
a2659 1
	STI	   R_USE,	    *\--R_USP(1)
d2673 2
a2674 2
	 LDIlt	   R_A4,		R_A3
	LDI	  *R_USP++(1),		R_USE
d2682 1
a2682 1
--	int VfsAmax( uword n, float * x, word x_stride )
d2698 1
a2698 1
	STI	   R_USE,	    *\--R_USP(1)
d2710 2
a2711 2
	 LDIgt	   R_A4,		R_A3
	LDI	  *R_USP++(1),		R_USE
d2719 1
a2719 1
--	int VdsAmax( uword n, double * x, word x_stride )
d2735 1
a2735 1
	STI	   R_USE,	    *\--R_USP(1)
d2751 2
a2752 2
	 LDIgt	   R_A4,		R_A3
	LDI	  *R_USP++(1),		R_USE
d2760 1
a2760 1
--	int VfsAmin( uword n, float * x, word x_stride )
d2776 1
a2776 1
	STI	   R_USE,	    *\--R_USP(1)
d2788 2
a2789 2
	 LDIlt	   R_A4,		R_A3
	LDI	  *R_USP++(1),		R_USE
d2797 1
a2797 1
--	int VdsAmin( uword n, double * x, word x_stride )
d2813 1
a2813 1
	STI	   R_USE,	    *\--R_USP(1)
d2829 2
a2830 2
	 LDIlt	   R_A4,		R_A3
	LDI	  *R_USP++(1),		R_USE
@


1.2
log
@improved FP accuracy in divides
@
text
@d9 1
a9 1
; $Id: vector.a,v 1.2 1992/10/15 10:30:11 nickc Exp nickc $
d29 1
a29 1
--	void VfAdd( int n, float * x, float * y )
d62 1
a62 1
--	void VfSub( int n, float * x, float * y )
d95 1
a95 1
--	void VfMul( int n, float * x, float * y )
d128 1
a128 1
--	void VfDiv( int n, float * x, float * y )
d177 1
a177 1
--	void VdAdd( int n, double * x, double * y )
d218 1
a218 1
--	void VdSub( int n, double * x, double * y )
d259 1
a259 1
--	void VdMul( int n, double * x, double * y )
d300 1
a300 1
--	void VdDiv( int n, double * x, double * y )
d371 1
a371 1
--	void VfAddScalar( float value, int n, float * x )
d407 1
a407 1
--	void VfSubScalar( float value, int n, float * x )
d443 1
a443 1
--	void VfMulScalar( float value, int n, float * x )
d479 1
a479 1
--	void VfDivScalar( float value, int n, float * x )
d522 1
a522 1
--	void VfRecScalar( float value, int n, float * x )
d572 1
a572 1
--	void VdAddScalar( double value, int n, double * x )
d611 1
a611 1
--	void VdSubScalar( double value, int n, double * x )
d650 1
a650 1
--	void VdMulScalar( double value, int n, double * x )
d689 1
a689 1
--	void VdDiv( double value, int n, double * x )
d744 1
a744 1
--	void VdRecScalar( double value, int n, double * x )
d813 1
a813 1
--	void VfCopy( int n, float * x, float * y )
d842 1
a842 1
--	void VdCopy( int n, double * x, double * y )
d877 1
a877 1
--	void VfFill( float value, int n, float * x )
d907 1
a907 1
--	void VdFill( double value, int n, double * x )
d938 1
a938 1
--	int VfMax( int n, float * x )
d970 1
a970 1
--	int VdMax( int n, double * x )
d1008 1
a1008 1
--	int VfMin( int n, float * x )
d1040 1
a1040 1
--	int VdMin( int n, double * x )
d1075 1
a1075 1
--	int VfAmax( int n, float * x )
d1108 1
a1108 1
--	int VdAmax( int n, double * x )
d1145 1
a1145 1
--	int VfAmin( int n, float * x )
d1178 1
a1178 1
--	int VdAmin( int n, double * x )
d1215 1
a1215 1
--	float VfDot( int n, float * x, float * y )
d1250 1
a1250 1
--	double VdDot( int n, double * x, double * y )
d1292 1
a1292 1
--	float VfSum( int n, float * x )
d1321 1
a1321 1
--	double VdSum( int n, double * x )
d1354 1
a1354 1
--	float VfProd( int n, float * x )
d1383 1
a1383 1
--	double VdProd( int n, double * x )
d1413 1
a1413 1
--	void VfMulAdd( float value, unsigned long int n, float * x, float * y )
d1440 1
a1440 1
	 || MPYF3   *R_ADDR1++(1),	R_A1,		R_A2
d1453 1
a1453 1
--	void VdMulAdd( double value, unsigned long int n, double * x, double * y )
d1500 1
a1500 1
--	void VfsAdd( int n, float * x, int x_stride, float * y, int y_stride )
d1542 1
a1542 1
--	void VfsSub( int n, float * x, int x_stride, float * y, int y_stride )
d1584 1
a1584 1
--	void VfsMul( int n, float * x, int x_stride, float * y, int y_stride )
d1626 1
a1626 1
--	void VfsDiv( int n, float * x, int x_stride, float * y, int y_stride )
d1683 1
a1683 1
--	void VdsAdd( int n, double * x, int x_stride, double * y, int y_stride )
d1731 1
a1731 1
--	void VdsSub( int n, double * x, int x_stride, double * y, int y_stride )
d1779 1
a1779 1
--	void VdsMul( int n, double * x, int x_stride, double * y, int y_stride )
d1827 1
a1827 1
--	void VdsDiv( int n, double * x, int x_stride, double * y, int y_stride )
d1909 1
a1909 1
--	void VfsAddScalar( float value, int n, float * x, int x_stride )
d1947 1
a1947 1
--	void VfsSubScalar( float value, int n, float * x, int x_stride )
d1985 1
a1985 1
--	void VfsMulScalar( float value, int n, float * x, int x_stride )
d2023 1
a2023 1
--	void VfsDivScalar( float value, int n, float * x, int x_stride )
d2071 1
a2071 1
--	void VfsRecScalar( float value, int n, float * x, int x_stride )
d2125 1
a2125 1
--	void VdsAddScalar( double value, int n, double * x, int x_stride )
d2168 1
a2168 1
--	void VdsSubScalar( double value, int n, double * x, int x_stride )
d2211 1
a2211 1
--	void VdsMulScalar( double value, int n, double * x, int x_stride )
d2254 1
a2254 1
--	void VdsDivScalar( double value, int n, double * x, int x_stride )
d2312 1
a2312 1
--	void VdsRecScalar( double value, int n, double * x, int x_stride )
d2384 1
a2384 1
--	void VfsCopy( int n, float * x, int x_stride, float * y, int y_stride )
d2421 1
a2421 1
--	void VdsCopy( int n, double * x, int x_stride, double * y, int y_stride )
d2461 1
a2461 1
--	void VfsFill( float value, int n, float * x, int x_stride )
d2495 1
a2495 1
--	void VdsFill( double value, int n, double * x, int x_stride )
d2530 1
a2530 1
--	int VfsMax( int n, float * x, int x_stride )
d2567 1
a2567 1
--	int VdsMax( int n, double * x, int x_stride )
d2606 1
a2606 1
--	int VfsMin( int n, float * x, int x_stride )
d2643 1
a2643 1
--	int VdsMin( int n, double * x, int x_stride )
d2682 1
a2682 1
--	int VfsAmax( int n, float * x, int x_stride )
d2719 1
a2719 1
--	int VdsAmax( int n, double * x, int x_stride )
d2760 1
a2760 1
--	int VfsAmin( int n, float * x, int x_stride )
d2797 1
a2797 1
--	int VdsAmin( int n, double * x, int x_stride )
d2838 1
a2838 1
--	float VfDot( int n, float * x, int x_stride, float * y, int y_stride )
d2880 1
a2880 1
--	double VdDot( int n, double * x, int x_stride, double * y, int y_stride )
d2928 1
a2928 1
--	float VfsSum( int n, float * x, int x_stride )
d2961 1
a2961 1
--	double VdsSum( int n, double * x, int x_stride )
d2995 1
a2995 1
--	float VfsProd( int n, float * x, int x_stride )
d3028 1
a3028 1
--	double VdsProd( int n, double * x, int x_stride )
d3062 1
a3062 1
--	void VfsMulAdd( float value, unsigned long int n, float * x, signed long int x_stride, float * y, signed long int y_stride )
d3095 1
a3095 1
	 || MPYF3   *R_ADDR1++(R_USE),	R_A1,		R_A2
d3109 1
a3109 1
--	void VdsMulAdd( double value, unsigned long int n, double * x, signed long int x_stride, double * y, signed long int y_stride )
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
; $Id: vector.a,v 1.2 1992/10/15 10:30:11 nickc Exp $
d323 1
d327 1
d331 6
d338 1
d347 1
d351 1
d355 6
d709 1
d713 1
d717 6
d768 1
d772 1
d776 6
d789 1
d793 1
d797 6
d1855 1
d1859 1
d1863 6
d1871 1
d1873 1
d1880 1
d1884 1
d1888 6
d1896 1
d2046 1
d2050 1
d2277 1
d2281 1
d2285 6
d2338 1
d2342 1
d2346 6
d2359 1
d2363 1
d2367 6
@
