head	1.27;
access;
symbols
	Helios_C40_1_3_Official_Release:1.19
	Alenia_release:1.17
	Helios1_3:1.17
	C40_Field_Test_2:1.16
	C40_Field_Test_R1:1.12
	Helios13_beta:1.12
	Helios1_2_2_Fault:1.9
	Helios1_2_2_Native:1.8
	Helios1_2_2_native_beta:1.8
	Helios1_2_2:1.7
	Helios1_2_2Beta:1.7
	Helios1_2_1:1.6
	Helios1_2:1.6;
locks; strict;
comment	@ * @;


1.27
date	94.03.10.17.14.04;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	93.12.08.17.53.32;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	93.08.12.11.16.05;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	93.08.11.11.14.03;	author bart;	state Exp;
branches;
next	1.23;

1.23
date	93.08.06.10.09.07;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	93.08.05.15.14.05;	author bart;	state Exp;
branches;
next	1.21;

1.21
date	93.06.14.18.18.33;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	93.06.11.15.26.32;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	93.04.14.16.11.47;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	93.01.08.12.33.23;	author bart;	state Exp;
branches;
next	1.17;

1.17
date	92.10.26.17.45.54;	author bart;	state Exp;
branches;
next	1.16;

1.16
date	92.10.07.13.36.31;	author bart;	state Exp;
branches;
next	1.15;

1.15
date	92.09.09.11.42.46;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	92.08.14.17.21.19;	author bart;	state Exp;
branches;
next	1.13;

1.13
date	92.07.21.11.02.39;	author bart;	state Exp;
branches;
next	1.12;

1.12
date	92.06.07.16.26.17;	author bart;	state Exp;
branches;
next	1.11;

1.11
date	92.04.24.15.42.20;	author bart;	state Exp;
branches;
next	1.10;

1.10
date	92.03.25.18.03.41;	author bart;	state Exp;
branches;
next	1.9;

1.9
date	92.01.15.11.04.39;	author bart;	state Exp;
branches;
next	1.8;

1.8
date	92.01.14.14.20.34;	author bart;	state Exp;
branches;
next	1.7;

1.7
date	91.06.03.13.21.48;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	90.12.01.15.36.16;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	90.11.25.20.05.36;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	90.11.01.14.56.23;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	90.09.24.18.47.40;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	90.09.20.17.43.34;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	90.09.12.14.52.35;	author jon;	state Exp;
branches;
next	;


desc
@@


1.27
log
@added initialisation of Nodes in SYSDEB world
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990 - 1993, Perihelion Software Ltd.      --
--                        All Rights Reserved.                          --
--                                                                      --
-- rmlib1.c								--
--                                                                      --
--	The construction module of the Resource Management library.	--
--	This module contains all the code needed to build networks,	--
--	taskforces, and the like.					--
--                                                                      --
--	Author:  BLV 1/5/90						--
--                                                                      --
------------------------------------------------------------------------*/
/* RcsId: $Header: /hsrc/network/RCS/rmlib1.c,v 1.26 1993/12/08 17:53:32 nickc Exp nickc $*/

#define in_rmlib	1

/*{{{  Header files */

#include <helios.h>
#if defined __SUN4 || defined RS6000
#include </hsrc/include/memory.h>
#include </hsrc/include/link.h>
#define _link_h
#endif
#include <stddef.h>
#include <syslib.h>
#include <root.h>
#include <gsp.h>
#include <nonansi.h>
#include <module.h>
#include <posix.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include "exports.h"
#include "private.h"
#include "rmlib.h"

#ifdef Malloc		/* courtesy of servlib.h */
#undef Malloc
#endif

/*}}}*/
/*{{{  Compile-time options */

#ifdef __TRAN
#pragma -f0		/* 0 == disable vector stack			*/
#pragma -g0		/* remove names from code			*/
#endif

#ifdef STACKCHECK
#ifdef __TRAN
#pragma -s1
static void _stack_error(Proc *p)
{ IOdebug("RmLib: stack overflow in %s at %x",p->Name,&p);
  Exit(0x0080 | SIGSTAK);
}
#endif
#pragma	-s0
#else
#pragma -s1
#endif

#ifdef RS6000
extern Environ * getenviron( void );
#endif

/*}}}*/
/*{{{  Library version numbers */
/**
*** Library revision versions.
***	1.10	first numbered version
***	1.11	change of communication to sockets
***	1.12	execute functions plus clean-up
***	1.13	cleaned up comms code, re. resetting pointers on receipt
***	1.14	added RmRegisterTask(), RmConvertTaskToTaskforce()
***	1.15	bug fixes
***	1.16	fixed problem with EOF conditions in PipeGuardian
***	1.17	now partially compiles on Unix hosts
***	1.18	reduced memory requirements for C40 1.3.1 release
**/
#define	VersionNumber	"1.18"

/*
 * N.B. Please update rmlhost.c as well.
 */
/*}}}*/
/*{{{  Library initialisation routine */
/*
 * This routine must be kept in step with rmlhost.c
 */
void _RmLib_Init()
{
#if 0	
  Object *lib = Locate(Null(Object), "/loader/RmLib");
  if (lib eq Null(Object))
   IOdebug("rmlib : failed to locate library");
  else
   { (void) Delete(lib, Null(char)); (void) Close(lib); }
#endif

  RmT_Names[RmT_Unknown]= "<Unknown>";
  RmT_Names[RmT_Default]= "<Default>";
  RmT_Names[RmT_T800]	= "T800";
  RmT_Names[RmT_T414]	= "T414";
  RmT_Names[RmT_T425]	= "T425";
  RmT_Names[RmT_T212]	= "T212";
  RmT_Names[RmT_T9000]	= "T9000";
  RmT_Names[RmT_T400]	= "T400";
  RmT_Names[RmT_i860]	= "i860";
  RmT_Names[RmT_Arm]	= "Arm";
  RmT_Names[RmT_680x0]	= "680x0";
  RmT_Names[RmT_C40]	= "C40";
  RmProgram		= Rm_User;
  RmNetworkServer	=
  RmSessionManager	=
  RmParent		= (RmServer) NULL;
  RmStartSearchHere	= 0;
  RmVersionNumber	= VersionNumber;
  RmExceptionHandler	= (VoidFnPtr) NULL;
#ifdef STACKEXTENSION
  RmExceptionStack	= 1000;
#else
  RmExceptionStack	= 2000;
#endif
  RmRootName		= NULL;
}
/*}}}*/
/*{{{  Processor manipulation */
/**-----------------------------------------------------------------------------
*** Processor manipulation. These routines deal with a single processor at
*** a time.
***
*** RmNewProcessor : allocate space for a new structure, fill it in
*** with default values, and return a pointer to the new structure.
**/
RmProcessor	RmNewProcessor(void)
{ RmProcessor	result = (RmProcessor) Malloc(sizeof(RmProcessorStruct));
  Date		date = GetDate();
  
  if (result eq (RmProcessor) NULL)
   { RmErrno = RmE_NoMemory; return((RmProcessor) NULL); }

	/* Most of the contents is 0, the rest is set explicitly */
  memset(result, 0, sizeof(RmProcessorStruct));
  result->ObjNode.Type		= Type_Processor;
  result->ObjNode.Matrix	= 0x010101c3;	/* darw:r:r:r */
  InitSemaphore(&(result->ObjNode.Lock), 1);	/* As per InitNode() */
  result->ObjNode.Key		= date + _cputime();
  result->ObjNode.Parent	= Null(struct DirNode);
  result->ObjNode.Dates.Creation =
  result->ObjNode.Dates.Access   =
  result->ObjNode.Dates.Modified = date;
  result->ObjNode.Account	= RmM_NoOwner;
  result->Type			= RmT_Default;
  result->StructType		= RmL_New;
  result->Purpose		= RmP_Helios | RmP_User;
  InitList(&(result->MappedTasks));
  result->SessionId		= -1;
  result->ApplicationId		= -1;
  return(result);
}

/**
*** Free'ing a processor structure. This will fail if the argument is
*** NULL, if the argument does not appear to be a processor, or if the
*** processor is currently in a network. Any mapped tasks have to be
*** unmapped.
**/
int RmFreeProcessor(RmProcessor processor)
{
  CheckProcessor(processor);

  if (processor->ObjNode.Parent ne Null(struct DirNode))
   return(RmErrno = processor->Errno = RmE_InUse);

  if (!EmptyList_(processor->MappedTasks))
   { Node	*x, *y;
     RmTask	 task;
     for (x = Head_(Node, processor->MappedTasks); !EndOfList_(x); x = y)
      { y = Next_(Node, x);
 	task = (RmTask) (((BYTE *) x) - offsetof(RmTaskStruct, MappedNode));
        task->MappedTo = RmL_NoUid;
        Remove(x);
      }
   }

  if (processor->OtherLinks ne Null(RmLink))
   if (Free(processor->OtherLinks) ne Err_Null)
    return(RmErrno = processor->Errno = RmE_Corruption);

  if (processor->AttribData ne Null(char))
   if (Free(processor->AttribData) ne Err_Null)
    return(RmErrno = processor->Errno = RmE_Corruption);

  if (processor->PAttribData ne Null(char))
   if (Free(processor->PAttribData) ne Err_Null)
    return(RmErrno = processor->Errno = RmE_Corruption);
    
	/* This is true iff the routine is called courtesy of RmFreeNetwork() */
	/* when a whole network is being deleted in one go. */
  if (processor->Root ne (RmNetwork) NULL)
   unless(RmReleaseUid((RmObject)processor))
    return(RmErrno = processor->Errno = RmE_Corruption);

  processor->ObjNode.Type	= 0;             
  if (Free(processor) ne Err_Null)
   return(RmErrno = processor->Errno = RmE_Corruption);
  return(RmE_Success);
}

/**
*** The basic operations for manipulating processors.
**/
unsigned long RmGetProcessorMemory(RmProcessor processor)
{ CheckProcessorFail(processor, 0L);
  return(processor->MemorySize);
}

int RmSetProcessorMemory(RmProcessor processor, unsigned long size)
{ CheckProcessor(processor);
  processor->MemorySize = size;
  return(RmE_Success);
}

const char *RmGetProcessorId(RmProcessor processor)
{ CheckProcessorFail(processor, (const char *) NULL);
  return(processor->ObjNode.Name);
}

int RmSetProcessorId(RmProcessor processor, char *name)
{ 
  CheckProcessor(processor);
	/* It is illegal to rename an existing processor */
  if (processor->StructType ne RmL_New)
    return(RmErrno = processor->Errno = RmE_ReadOnly);

  if (strlen(name) >= NameMax)
    return(RmErrno = processor->Errno = RmE_TooLong);
  strcpy(processor->ObjNode.Name, name);
  return(RmE_Success);
}

int RmGetProcessorPurpose(RmProcessor processor)
{ CheckProcessorFail(processor, -1);
  return(processor->Purpose);
}

int RmSetProcessorPurpose(RmProcessor processor, int Purpose)
{ CheckProcessor(processor);
  processor->Purpose = Purpose;
  return(RmE_Success);
}

int RmGetProcessorState(RmProcessor processor)
{ CheckProcessorFail(processor, -1);
  return((int)processor->ObjNode.Size);
}

int RmSetProcessorState(RmProcessor processor, int state)
{ CheckProcessor(processor);
  processor->ObjNode.Size = state;
  return(RmE_Success);
}

int RmGetProcessorType(RmProcessor processor)
{ CheckProcessorFail(processor, -1);
  return(processor->Type);
}

int RmSetProcessorType(RmProcessor processor, int type)
{ CheckProcessor(processor);
  processor->Type = type;
  return(RmE_Success);
}

int RmGetProcessorOwner(RmProcessor processor)
{ CheckProcessorFail(processor, -1);
  return((int)processor->ObjNode.Account);
}

int RmSetProcessorPrivate(RmProcessor processor, int x)
{ CheckProcessor(processor);
  processor->Private = x;
  return(RmE_Success);
}

int RmSetProcessorPrivate2(RmProcessor processor, int x)
{ CheckProcessor(processor);
  processor->Private2 = x;
  return(RmE_Success);
}

int RmGetProcessorPrivate(RmProcessor processor)
{ CheckProcessorFail(processor, -1);	
  return(processor->Private);
}

int RmGetProcessorPrivate2(RmProcessor processor)
{ CheckProcessorFail(processor, -1);
  return(processor->Private2);
}

int RmGetProcessorError(RmProcessor processor)
{ CheckProcessor(processor);	
  return(processor->Errno);
}

int RmClearProcessorError(RmProcessor processor)
{ CheckProcessor(processor);	
  return(processor->Errno = RmE_Success);
}

RmUid RmGetProcessorUid(RmProcessor processor)
{ CheckProcessorFail(processor, 0);	
  return(processor->Uid);
}

Capability *RmGetProcessorCapability(RmProcessor processor, bool real)
{ if (real)
   return(&(processor->RealCap));
  else
   return(&(processor->NsCap));
}

int RmGetProcessorControl(RmProcessor processor)
{ CheckProcessorFail(processor, -1);
  return(processor->Control);
}
/*}}}*/
/*{{{  Attribute handling */

/**-----------------------------------------------------------------------------
*** Attribute handling. This is the same for processors and for tasks.
***
*** Adding an attribute is valid provided there is enough memory
*** and the string is real. This means it must contain at least one
*** character. The data field is variable-length, initially
*** 32 bytes, which should suffice for a few attributes. If the
*** object does not have one yet, a data vector is allocated.
*** Strings are held as a single byte for the string length, BCPL style,
*** followed by the string itself including the NULL terminator.
**/
typedef	struct	RmAttributes {
	int	Size;
	int	Free;
	char	*Data;
} RmAttributes;

int RmAddObjectAttribute(RmObject obj, char *attr, bool bPrivate)
{ int		length;
  RmAttributes	*attrib;
  
  if (attr eq Null(char)) return(RmE_BadArgument);
  if ((length = strlen(attr)) < 1) return(RmE_BadArgument);
  
  if (bPrivate)
   attrib = (RmAttributes *) &(obj->PAttribSize);
  else
   attrib = (RmAttributes *) &(obj->AttribSize);

  if (attrib->Size eq 0)
   { attrib->Data	= (char *) Malloc(32);
     if (attrib->Data eq Null(BYTE))
      return(RmE_NoMemory);
     attrib->Size	= 32; 
     attrib->Free = 0;
   }

   	/* Re-alloc the current data structure if necessary */
  while ((attrib->Size - attrib->Free) < (length + 2))
   { char *newdata = (char *)Malloc(2 * (word)(attrib->Size));
     if (newdata eq Null(char))
      return(RmE_NoMemory);

     if (attrib->Free > 0)
      memcpy((void *) newdata, attrib->Data, attrib->Free); 
     attrib->Size = 2 * attrib->Size;
     if (Free(attrib->Data) ne Err_Null) return(RmE_Corruption);
     attrib->Data = newdata;
   }

  	/* Fill in the data structure */
  { char *datavec = attrib->Data;
    datavec[attrib->Free] = length + 2;
    strcpy(&(datavec[attrib->Free+1]), attr);
    attrib->Free += (length + 2);
  }
  
  return(RmE_Success);
}

int RmAddProcessorAttribute(RmProcessor processor, char *attr)
{ int x;

  CheckProcessor(processor);

  if ((x = RmAddObjectAttribute((RmObject) processor, attr, FALSE)) ne RmE_Success)
   RmErrno = processor->Errno = x;
  return(x);
}

int RmAddTaskAttribute(RmTask task, char *attr)
{ int x;

  CheckTask(task);

  if ((x = RmAddObjectAttribute((RmObject) task, attr, FALSE)) ne RmE_Success)
   RmErrno = task->Errno = x;
  return(x);  
}

/**
*** This routine is useful to locate an attribute. It returns an index
*** into the data vector of the RmAttributes structure, or -1 for failure.
**/
static int RmFindObjectAttribute(RmAttributes *attrib, char *attr)
{ int index = 0;
  char	*datavec = attrib->Data;
  
  while (index < attrib->Free)
   { if (!strcmp(&(datavec[index+1]), attr))
      return(index);
     index += datavec[index];
   }
  return(-1);
}

/**
*** Removing an attribute. Again the arguments have to be valid. If the
*** attribute exists it is removed from the table, which is readjusted.
**/
int RmRemoveObjectAttribute(RmObject object, char *attr, bool bPrivate)
{ RmAttributes *attrib;
  int		index;
  char		*datavec;
  int		length;
    
  if (attr eq Null(char)) return(RmE_BadArgument);
  if (strlen(attr) < 1) return(RmE_BadArgument);
  if (bPrivate)
   attrib = (RmAttributes *) &(object->PAttribSize);
  else
   attrib = (RmAttributes *) &(object->AttribSize);

  index = RmFindObjectAttribute(attrib, attr);

  if (index eq -1) return(RmE_NotFound);
  datavec = attrib->Data;
  length = datavec[index];
  if (index + length < attrib->Free)
   memcpy((void *) &(datavec[index]), (void *) &(datavec[index+length]), 
          attrib->Free - (index + length));
  attrib->Free -= length;
  if (attrib->Free eq 0)
   { char 	*temp = attrib->Data;
     attrib->Size = 0;
     attrib->Data = Null(char);
     if (Free(temp) ne Err_Null)
      return(RmE_Corruption);
   }
  return(RmE_Success);
}

int RmRemoveProcessorAttribute(RmProcessor processor, char *attr)
{ int x;

  CheckProcessor(processor);

  if ((x = RmRemoveObjectAttribute((RmObject) processor, attr, FALSE)) ne RmE_Success)
   RmErrno = processor->Errno = x;
  return(x);
}

int RmRemoveTaskAttribute(RmTask task, char *attr)
{ int x;

  CheckTask(task);

  if ((x = RmRemoveObjectAttribute((RmObject) task, attr, FALSE)) ne RmE_Success)
   RmErrno = task->Errno = x;
  return(x);
}

/**
*** Internal attributes can be of type xx=yy. This routine will return the yy
*** part.
**/
char *RmGetObjectAttribute(RmObject obj, char *attr, bool bPrivate)
{ RmAttributes	*attrib;
  int		length	= strlen(attr);
  int		index = 0;
  char		*datavec;

  if (bPrivate)
   attrib = (RmAttributes *) &(obj->PAttribSize);
  else
   attrib = (RmAttributes *) &(obj->AttribSize);  
  datavec = attrib->Data;
  while (index < attrib->Free)
   { 
     if (!strncmp(&(datavec[index+1]), attr, length))
      { if (datavec[index+1+length] eq '=')
         return(&(datavec[index+1+length+1]));
      }
     index += datavec[index];
   }
  return(Null(char));
}

const char *RmGetProcessorAttribute(RmProcessor processor, char *text)
{ CheckProcessorFail(processor, (const char *) NULL);
  if (text eq Null(char))
   return(RmErrno = RmE_BadArgument, (const char *) NULL);
   
  return((const char *)RmGetObjectAttribute((RmObject) processor, text, FALSE));
}

const char *RmGetTaskAttribute(RmTask task, char *text)
{ CheckTaskFail(task, (const char *) NULL);
  if (text eq Null(char))
   return(RmErrno = RmE_BadArgument, (const char *) NULL);
   
  return((const char *) RmGetObjectAttribute((RmObject) task, text, FALSE));
}

static int RmIsAnObjectAttribute(RmObject obj, char *attr, bool bPrivate)
{ RmAttributes 	*attrib;

  if (attr eq Null(char)) return(RmE_BadArgument);
  if (strlen(attr) < 1) return(RmE_BadArgument);
  if (bPrivate)
   attrib = (RmAttributes *) &(obj->PAttribSize);
  else
   attrib = (RmAttributes *) &(obj->AttribSize);
  if (RmFindObjectAttribute(attrib, attr) ne -1)
   return(RmE_Success);
  else
   return(RmE_NotFound);
}

int RmTestProcessorAttribute(RmProcessor processor, char *attr)
{ int x;

  CheckProcessor(processor);

  if ((x = RmIsAnObjectAttribute((RmObject) processor, attr, FALSE)) ne RmE_Success)
   RmErrno = processor->Errno = x;
  return(x);
}

int RmTestTaskAttribute(RmTask task, char *attr)
{ int x;

  CheckTask(task);

  if ((x = RmIsAnObjectAttribute((RmObject) task, attr, FALSE)) ne RmE_Success)
   RmErrno = task->Errno = x;
  return(x);
}

/**
*** Counting the number of attributes is easy, just loop until the Free
*** index is found.
**/
static int RmCountObjectAttributes(RmObject obj, bool bPrivate)
{ int		 result = 0;
  RmAttributes	*attrib;
  int		 index;
  char		*datavec;

  if (bPrivate)
   attrib = (RmAttributes *) &(obj->PAttribSize);
  else
   attrib = (RmAttributes *) &(obj->AttribSize);

  index = 0;
  datavec = attrib->Data;
  while (index < attrib->Free)
   { result++;
     index += datavec[index];
   }
  return(result);
}

int RmCountProcessorAttributes(RmProcessor processor)
{ CheckProcessorFail(processor, -1);
  return(RmCountObjectAttributes((RmObject) processor, FALSE));
}

int RmCountTaskAttributes(RmTask task)
{ CheckTaskFail(task, -1);
  return(RmCountObjectAttributes((RmObject) task, FALSE));
}

/**
*** Listing a set of attributes is similarly easy, assuming the user is
*** sensible enough to provide an adequate table.
**/

static int RmListObjectAttributes(RmObject obj, char **table, bool bPrivate)
{ RmAttributes	*attrib;
  int		i = 0;
  int		index;
  char		*datavec;
  
  if (table eq Null(char *)) return(RmE_BadArgument);
  if (bPrivate)
   attrib = (RmAttributes *) &(obj->PAttribSize);
  else
   attrib = (RmAttributes *) &(obj->AttribSize);

  index = 0;
  datavec = attrib->Data;
  while (index < attrib->Free)
   { table[i++] = &(datavec[index + 1]);
     index += datavec[index];
   }
  return(RmE_Success);
}
     
int RmListProcessorAttributes(RmProcessor processor, char **table)
{ int x;

  CheckProcessor(processor);

  if ((x = RmListObjectAttributes((RmObject) processor, table, FALSE)) ne RmE_Success)
    RmErrno = processor->Errno = x;
  return(x);
}

int RmListTaskAttributes(RmTask task, char **table)
{ int x;

  CheckTask(task);

  if ((x = RmListObjectAttributes((RmObject) task, table, FALSE)) ne RmE_Success)
   RmErrno = task->Errno = x;
  return(x);
}

/**
*** Getting the current processor nucleus is always legal. The most likely
*** result is an empty string, indicating that the default nucleus should be
*** used. Setting the nucleus only makes sense when generating resource maps.
**/
const char *RmGetProcessorNucleus(RmProcessor processor)
{ char	*result;

  CheckProcessorFail(processor, (const char *) NULL);

  result = RmGetObjectAttribute((RmObject) processor, "nucleus", TRUE);
  if (result  eq Null(char))
   return("");
  else
   return(result);
}

/**
*** Setting the processor nucleus involves adding a private attribute,
*** of the form nucleus=/helios/lib/nucleus.dbg. If the nucleus passed
*** is null then the application is simply trying to eliminate the
*** existing nucleus, rather than install one. Either way the routine
*** constructs a suitable attribute string, eliminates the existing
*** attribute if possible, and installs the new string. 
**/
int RmSetProcessorNucleus(RmProcessor processor, char *nucleus)
{ char	*buffer = NULL;
  int	length;
  char	*temp;
  int	rc;

  CheckProcessor(processor);      

	/* Construct an attribute string for the new nucleus */
  if (nucleus ne Null(char))
   { length = strlen(nucleus) + 9;	/* nucleus=xxx\0 */
     buffer = (char *)Malloc(length);
     if (buffer eq Null(BYTE)) return(RmE_NoMemory);
     strcpy(buffer, "nucleus=");
     strcat(buffer, nucleus);
   }     

	/* If a nucleus is already defined, get rid of it */
  temp = RmGetObjectAttribute((RmObject) processor, "nucleus", TRUE);
  if (temp ne Null(char))
   { temp = &(temp[-8]);
     if ((rc = RmRemoveObjectAttribute((RmObject) processor, temp, TRUE)) ne RmE_Success)
      return(RmErrno = processor->Errno = RmE_Corruption);
   }

  if (nucleus ne Null(char))
   { rc = RmAddObjectAttribute((RmObject) processor, buffer, TRUE);
     Free(buffer);
     if (rc ne RmE_Success)
      return(RmErrno = processor->Errno = rc);
   }
  return(RmE_Success);
}

/*}}}*/
/*{{{  Task manipulation */

/**
*** RmNewTask() creates a new task structure and fills it in with default
*** values.
**/

RmTask RmNewTask(void)
{ RmTask result = (RmTask) Malloc(sizeof(RmTaskStruct));
  Date	 date	= GetDate();

  if (result eq (RmTask) NULL)
   return(RmErrno = RmE_NoMemory, (RmTask) NULL);

  memset(result, 0, sizeof(RmTaskStruct));
  result->ObjNode.Type		= Type_Task;
  result->ObjNode.Matrix	= 0x010101c3;	/* darw:r:r:r */
  InitSemaphore(&(result->ObjNode.Lock), 1);	/* As per InitNode() */
  result->ObjNode.Key		= date + _cputime();
  result->ObjNode.Dates.Creation =
  result->ObjNode.Dates.Access   =
  result->ObjNode.Dates.Modified = date;
  result->Type			= RmT_Default;
  result->StructType		= RmL_New;
  result->IsNative		= FALSE;
  result->NextArgIndex		= 1;
  result->ReturnCode		= -1;
  return(result);
}

/**
*** Free'ing a task is essentially the same as freeing a processor.
**/
int RmFreeTask(RmTask task)
{
  CheckTask(task);	

  if (task->ObjNode.Parent ne Null(struct DirNode))
   return(RmErrno = task->Errno = RmE_InUse);

  if (task->MappedTo ne RmL_NoUid)
   { Remove(&(task->MappedNode));
     task->MappedTo = RmL_NoUid;
   }

  if (task->OtherChannels ne Null(RmChannel))
   if (Free(task->OtherChannels) ne Err_Null)
    return(RmErrno = task->Errno = RmE_Corruption);

  if (task->AttribData ne Null(char))
   if (Free(task->AttribData) ne Err_Null)
    return(RmErrno = task->Errno = RmE_Corruption);

  if (task->PAttribData ne Null(char))
   if (Free(task->PAttribData) ne Err_Null)
    return(RmErrno = task->Errno = RmE_Corruption);

  if (task->ArgIndex ne Null(int))
   if (Free(task->ArgIndex) ne Err_Null)
    return(RmErrno = task->Errno = RmE_Corruption);

  if (task->ArgStrings ne Null(char))
   if (Free(task->ArgStrings) ne Err_Null)
    return(RmErrno = task->Errno = RmE_Corruption);
    
	/* This case is true iff the task is being freed as a	*/
	/* result of an RmFreeTaskforce call.			*/
  if (task->Root ne (RmTaskforce) NULL)
   unless(RmReleaseUid((RmObject)task))
    return(RmErrno = task->Errno = RmE_Corruption);

  task->ObjNode.Type	= 0;
  if (Free(task) ne Err_Null)
   return(RmErrno = RmE_Corruption);
  return(RmE_Success); 
}

unsigned long RmGetTaskMemory(RmTask task)
{ CheckTaskFail(task, 0L);	
  return(task->MemorySize);
}

int RmSetTaskMemory(RmTask task, unsigned long size)
{ CheckTask(task);
  task->MemorySize = size; 
  return(RmE_Success);
}

const char *RmGetTaskId(RmTask task)
{ CheckTaskFail(task, (const char *) NULL);
  return(task->ObjNode.Name);
}

int RmSetTaskId(RmTask task, char *name)
{ CheckTask(task);
	/* It is illegal to rename an existing task */
  if (task->StructType ne RmL_New)
   return(RmErrno = task->Errno = RmE_ReadOnly);
  if (strlen(name) >= NameMax)
   return(RmErrno = task->Errno = RmE_TooLong);
  strcpy(task->ObjNode.Name, name);
  return(RmE_Success);
}

int RmGetTaskType(RmTask task)
{ CheckTaskFail(task, -1); 
  return(task->Type);	/* processor type, e.g. T800 */
}

int RmSetTaskType(RmTask task, int type)
{ CheckTask(task);
  if ((type < RmT_Unknown) || (type >= RmT_Known))
   return(RmErrno = task->Errno = RmE_BadArgument);
  task->Type = type;
  return(RmE_Success);
}

int RmGetTaskState(RmTask task)
{ CheckTaskFail(task, -1);
  return((int)task->ObjNode.Size);
}

int RmSetTaskState(RmTask task, int state)
{ CheckTask(task);
  task->ObjNode.Size	= state;
  return(RmE_Success);
}

const char *RmGetTaskCode(RmTask task)
{ char	*result;

  CheckTaskFail(task, (const char *) NULL);
  result = RmGetObjectAttribute((RmObject) task, "code", TRUE);
  if (result eq Null(char))
   return("");
  else
   return(result);
}

int		RmSetTaskCode(RmTask task, char *file)
{ char *buffer;
  int	length;
  int	rc;

  CheckTask(task);     

  if (file eq Null(char))
   return(RmErrno = task->Errno = RmE_BadArgument);

  length = 5 + strlen(file) + 1;	/* code=xxx\0 */
  buffer = (char *) Malloc(length);
  if (buffer eq Null(char))
   return(RmErrno = task->Errno = RmE_NoMemory);
  strcpy(buffer, "code=");
  strcat(buffer, file);
  { char *temp = RmGetObjectAttribute((RmObject) task, "code", TRUE);
     if (temp ne Null(char))
      { temp -= 5;	/* get back to the start of the string, code=xx */
        rc = RmRemoveObjectAttribute((RmObject) task, temp, TRUE);
        if (rc ne RmE_Success)
         return(RmErrno = task->Errno = rc);
      }
  }

  rc = RmAddObjectAttribute((RmObject) task, buffer, TRUE);
  if (Free(buffer) ne Err_Null)
   if (rc eq RmE_Success) rc = RmE_Corruption;

  if (rc ne RmE_Success)
   RmErrno = task->Errno = rc;
      
  return(rc);
}

int RmSetTaskPrivate(RmTask task, int x)
{ CheckTask(task);
  task->Private = x;
  return(RmE_Success);
}

int RmSetTaskPrivate2(RmTask task, int x)
{ CheckTask(task); 
  task->Private2 = x;
  return(RmE_Success);
}

int RmGetTaskPrivate(RmTask task)
{ CheckTaskFail(task, -1);
  return(task->Private);
}

int RmGetTaskPrivate2(RmTask task)
{ CheckTaskFail(task, -1); 
  return(task->Private2);
}

int RmGetTaskError(RmTask task)
{ CheckTask(task);
  return(task->Errno);
}

int RmClearTaskError(RmTask task)
{ CheckTask(task);
  return(task->Errno = RmE_Success);
}

RmUid RmGetTaskUid(RmTask task)
{ CheckTaskFail(task, 0);
  return(task->Uid);
}

/**
BLV These should be replaced by RmSetTaskPurpose() etc., and should
BLV include things like broadcast tasks etc.
**/
int RmSetTaskNative(RmTask task)
{ CheckTask(task);
  task->IsNative = TRUE;
  return(RmE_Success);
}

bool RmIsTaskNative(RmTask task)
{ CheckTaskFail(task, FALSE);	
  return(task->IsNative);
}

bool RmIsTaskNormal(RmTask task)
{ CheckTaskFail(task, FALSE);
  return(!task->IsNative);
}

int RmSetTaskNormal(RmTask task)
{ CheckTask(task); 
  task->IsNative = FALSE;
  return(RmE_Success);
}

/**
*** Argument handling. There are two tables pointed at by the RmTask
*** structure. First there is a big buffer to hold all the strings
*** consecutively. Second there is a table of indexes for this buffer.
***
*** NOTE : valid argument numbers for these routines start at 1.
*** argv[0] is always reserved for the component name.
**/

static int	RmAddTaskArgumentAux1(RmTask task, int number, char *str);

int RmAddTaskArgument(RmTask task, int number, char *str)
{
  CheckTask(task);

  if ((number < 1) || (number > task->NextArgIndex) || (str eq Null(char)))
   return(RmErrno = task->Errno = RmE_BadArgument);
  
	/* Changing an existing argument is difficult and is handled by */
	/* a separate routine.						*/
  if (number ne task->NextArgIndex)
   return(RmAddTaskArgumentAux1(task, number, str));

	/* OK, the simple case of simply setting the next argument.	*/
	/* First time around the buffers have to be allocated.		*/
  if (task->ArgIndex eq Null(int))
   { task->ArgIndex	= (int *) Malloc(8 * sizeof(int));
     if (task->ArgIndex eq Null(int))
      return(RmErrno = task->Errno = RmE_NoMemory);
     task->MaxArgIndex	= 8;
     task->ArgStrings	= (char *) Malloc(64);
     if (task->ArgStrings eq Null(char))
      return(RmErrno = task->Errno = RmE_NoMemory);
     task->MaxArgStrings= 64;
   }

	/* On occasion one of the two tables may be too small.		*/
  if (number > task->MaxArgIndex)
   { int *temp = (int *) Malloc(2 * (word)(task->MaxArgIndex) * sizeof(int));
     word rc;
     if (temp eq Null(int)) 
      return(RmErrno = task->Errno = RmE_NoMemory);
     memcpy(temp, task->ArgIndex, task->MaxArgIndex * sizeof(int));
     rc = Free(task->ArgIndex);
     task->ArgIndex	= temp;
     task->MaxArgIndex	= 2 * task->MaxArgIndex;
     if (rc ne Err_Null)
      return(RmErrno = task->Errno = RmE_Corruption);
   }

  while ((task->NextArgStrings + strlen(str) + 1) > task->MaxArgStrings)
   { char	*temp = (char *) Malloc(2L * (word)(task->MaxArgStrings));
     word	 rc;
     if (temp eq Null(char))
      return(RmErrno = task->Errno = RmE_NoMemory);
     if (task->NextArgStrings > 0)
      memcpy(temp, task->ArgStrings, task->NextArgStrings);
     rc = Free(task->ArgStrings);
     task->ArgStrings		= temp;
     task->MaxArgStrings	= 2 * task->MaxArgStrings;
     if (rc ne Err_Null)
      return(RmErrno = task->Errno = RmE_Corruption);
   }

	/* Everything seems to be OK. Put the string into the table */
  task->ArgIndex[number - 1] 	 = task->NextArgStrings;
  task->NextArgIndex		+= 1;
  { char *temp = &(task->ArgStrings[task->NextArgStrings]);
    strcpy(temp, str);
    task->NextArgStrings	+= (strlen(temp) + 1);
  }
 return(RmE_Success);
}

static int RmAddTaskArgumentAux1(RmTask task, int number, char *str)
{	/* This routine has the unfortunate chore of rearranging the	*/
	/* existing arguments to change one of them.			*/
  char	*old_buffer		= task->ArgStrings;
  int	*arg_index		= task->ArgIndex;
  char	*new_buffer;
  int	buffer_size		= task->MaxArgStrings;
  int	new_index, old_index, i, length;
    
	/* Allocate a new buffer to do the copying. This may or may not	*/
	/* have to be bigger than the current buffer.			*/
  while ((task->NextArgStrings + strlen(str) + 1)  > buffer_size)
   buffer_size += buffer_size;
  new_buffer	= (char *) Malloc(buffer_size);
  if (new_buffer eq Null(char))
   return(RmErrno = task->Errno = RmE_NoMemory);

	/* Put the current strings into the buffer, up to the new one	*/
	/* The ArgIndex table remains unchanged.			*/
  new_index = 0; old_index = 0;
  for (i = 1; i < number; i++)
   { strcpy(&(new_buffer[new_index]), &(old_buffer[new_index]));
     length	 = strlen(&(new_buffer[new_index])) + 1;
     new_index	+= length;
     old_index  += length;
   }
	/* Substitute in the new string. */
  strcpy(&(new_buffer[new_index]), str);
  new_index	+= (strlen(str) + 1);
  old_index	+= (strlen(&(old_buffer[old_index])) + 1);

	/* And copy the remaining arguments, this time updating the	*/
	/* ArgIndex table.						*/
  for (i = number + 1; i < task->NextArgIndex; i++)
   { arg_index[i - 1]	= new_index;
     strcpy(&(new_buffer[new_index]), &(old_buffer[old_index]));
     length	= strlen(&(new_buffer[new_index])) + 1;
     new_index += length;
     old_index += length;
   }

	/* Free the old buffer, and update the fields in the task structure */
  Free(old_buffer);
  task->ArgStrings	= new_buffer;
  task->MaxArgStrings	= buffer_size;
  task->NextArgStrings	= new_index;
  return(RmE_Success);
}

const char *RmGetTaskArgument(RmTask task, int argc)
{
  CheckTaskFail(task, (const char *) NULL);

  if (argc eq 0) return(RmGetTaskId(task));
  if ((argc < 1) || (argc >= task->NextArgIndex))
   return(RmErrno = RmE_BadArgument, Null(char));
  return(&(task->ArgStrings[task->ArgIndex[argc-1]]));
}

int RmCountTaskArguments(RmTask task)
{ CheckTaskFail(task, -1);
  return(task->NextArgIndex);
}

/**
*** There is no processor equivalent for this routine. Its purpose is to
*** examine a binary file and figure out what type of processor it is
*** supposed to run on. Under Helios this information should be stored at
*** the start of a file. Again the type can be a complex object rather
*** than just a simple number.
**/
int RmGetProgramType(char *file)
{ file = file;
  return(RmT_Default);
}

/*}}}*/
/*{{{  Network manipulation */
/**-----------------------------------------------------------------------------
*** Here are the basic operations for a network, at least the ones that
*** do not change the size of the network. Things like AddTailProcessor()
*** require more work than you might expect, because of the problems of
*** maintaining uid's and adding subnets and so on.
***
*** RmNewNetwork() allocates space for a network structure and fills in
*** the usual defaults. For now this is the root network of itself, so the
*** root is filled in to point to itself.
**/
RmNetwork RmNewNetwork(void)
{ RmNetwork	result = (RmNetwork) Malloc(sizeof(RmNetworkStruct));
  Date		date = GetDate();
  
  if (result eq (RmNetwork) NULL)
   return(RmErrno = RmE_NoMemory, (RmNetwork) NULL);

  memset(result, 0, sizeof(RmNetworkStruct));
  result->DirNode.Type		= Type_Network; 
  result->DirNode.Matrix	= 0x211109c7;  /* darwv:rx:ry:rz */
  InitSemaphore(&(result->DirNode.Lock), 1);
  result->DirNode.Key		= date + _cputime();
  result->DirNode.Dates.Creation =
  result->DirNode.Dates.Access	 =
  result->DirNode.Dates.Modified = date;
  InitList(&(result->DirNode.Entries));
  result->Root			= (RmSet) result;
  result->StructType		= RmL_New;
  InitList(&(result->Hardware));
  return(result);
}

/**
*** Free'ing a network means removing and freeing all subnets and processors.
*** Any mapped tasks are unmapped. The reset and configuration facilities are
*** freed, as are the Uid tables if this is the root.
**/
static int FreeNetwork_aux(RmProcessor processor, ...)
{
  (void) Remove((Node *) processor);
  processor->ObjNode.Parent = Null(struct DirNode);
  if (RmIsNetwork(processor))
   return(RmFreeNetwork((RmNetwork) processor));
  else
   return(RmFreeProcessor(processor));
} 

static int FreeHardware(RmHardwareFacility *reset, ...)
{ (void) Remove(&(reset->Node));
  if (Free(reset) ne Err_Null)
   return(RmErrno = RmE_Corruption);
  else
   return(RmE_Success);
}

int RmFreeNetwork(RmNetwork network)
{ int result, i;

  CheckNetwork(network); 

  if (network->DirNode.Parent ne Null(struct DirNode))
   return(RmErrno = network->Errno = RmE_InUse);

  if (network->DirNode.Nentries ne 0)
   { result = RmApplyNetwork(network, &FreeNetwork_aux);  
     if (result ne RmE_Success)
      return(RmErrno = network->Errno = result);
   }

  if ((result = RmApplyHardwareFacilities(network, &FreeHardware))
       ne RmE_Success)
   return(RmErrno = network->Errno = result);

  if (network->NoTables > 0)
   { for (i = 0; i < network->NoTables; i++)
      if (Free(network->Tables[i]) ne Err_Null)
       return(RmErrno = network->Errno = RmE_Corruption);
     if (Free(network->Tables) ne Err_Null)
       return(RmErrno = network->Errno = RmE_Corruption);
   }
   
  network->DirNode.Type = 0;
  if (Free(network) ne Err_Null)
   return(RmErrno = RmE_Corruption);
   
  return(RmE_Success);
}

const char *RmGetNetworkId(RmNetwork network)
{ CheckNetworkFail(network, (const char *) NULL);
  return(network->DirNode.Name);
}

int RmSetNetworkId(RmNetwork network, char *name)
{ CheckNetwork(network);
  if (network->StructType ne RmL_New)
   return(RmErrno = network->Errno = RmE_ReadOnly);
  if (strlen(name) >= NameMax) 
   return(RmErrno = network->Errno = RmE_TooLong);
  strcpy(network->DirNode.Name, name);
  return(RmE_Success);
}

int RmSetNetworkPrivate(RmNetwork network, int x)
{ CheckNetwork(network);
  network->Private = x;
  return(RmE_Success);
}

int RmSetNetworkPrivate2(RmNetwork network, int x)
{ CheckNetwork(network);	
  network->Private2 = x;
  return(RmE_Success);
}

int RmGetNetworkPrivate(RmNetwork network)
{ CheckNetworkFail(network, -1);	
  return(network->Private);
}

int RmGetNetworkPrivate2(RmNetwork network)
{ CheckNetworkFail(network, -1);	
  return(network->Private2);
}

int RmGetNetworkError(RmNetwork network)
{ CheckNetwork(network);
  return(network->Errno);
}

int RmClearNetworkError(RmNetwork network)
{ CheckNetwork(network);
  return(network->Errno = RmE_Success);
}

/**
*** The first and last processors are easy to get hold of, because there
*** are pointers in the list structure.
**/
RmProcessor RmFirstProcessor(RmNetwork network)
{ CheckNetworkFail(network, (RmProcessor) NULL);
  if (network->DirNode.Nentries < 1)
   return((RmProcessor) NULL);
  return((RmProcessor) network->DirNode.Entries.Head);
}

RmProcessor RmLastProcessor(RmNetwork network)
{ CheckNetworkFail(network, (RmProcessor) NULL); 
  if (network->DirNode.Nentries < 1) return((RmProcessor) NULL);
  return((RmProcessor) network->DirNode.Entries.Tail);
}

/**
*** The next and previous routines are only valid if the processor is
*** currently in a network. N.B. do not validate Type_Processor for these,
*** since they may be subnets.
**/
RmProcessor RmNextProcessor(RmProcessor processor)
{ 
  if (processor eq (RmProcessor) NULL)
   return(RmErrno = RmE_NotProcessor, (RmProcessor) NULL);
  if ((processor->ObjNode.Type ne Type_Processor) &&
      (processor->ObjNode.Type ne Type_Network))
   return(RmErrno = RmE_NotProcessor, (RmProcessor) NULL);

  if (processor->ObjNode.Parent eq Null(struct DirNode))
   return(RmErrno = processor->Errno = RmE_NotNetwork, (RmProcessor) NULL);
  processor = (RmProcessor) processor->ObjNode.Node.Next;
  if (processor->ObjNode.Node.Next eq Null(struct Node))
   return((RmProcessor) NULL);
  else
   return(processor);
}

RmProcessor RmPreviousProcessor(RmProcessor processor)
{ RmProcessor	result;
  RmNetwork	parent;

  if (processor eq (RmProcessor) NULL)
   return(RmErrno = RmE_NotProcessor, (RmProcessor) NULL);
  if ((processor->ObjNode.Type ne Type_Processor) &&
      (processor->ObjNode.Type ne Type_Network))
   return(RmErrno = RmE_NotProcessor, (RmProcessor) NULL);

  parent = (RmNetwork) processor->ObjNode.Parent;
  if (parent eq (RmNetwork) NULL)
   return(RmErrno = processor->Errno = RmE_NotNetwork, (RmProcessor) NULL); 
  result = (RmProcessor) processor->ObjNode.Node.Prev;
  if (result eq (RmProcessor) &(parent->DirNode.Entries.Head))
   return((RmProcessor) NULL);
  return(result);
}

/**
*** An empty network has 0 Nentries. The size of a network is Nentries,
*** not the number of processors in all the subnets. The parent network
*** is null if this is the root, otherwise it is held in the DirNode.
**/

bool RmIsNetworkEmpty(RmNetwork network)
{ CheckNetworkFail(network, TRUE);
  return(network->DirNode.Nentries eq 0);
}

int RmSizeofNetwork(RmNetwork network)
{ CheckNetworkFail(network, -1);
  return((int)network->DirNode.Nentries);
}

int RmCountProcessors(RmNetwork network)
{ int		result;
  RmProcessor	current;

  CheckNetworkFail(network, -1);  

  if (network->NoSubnets eq 0) return((int)network->DirNode.Nentries);
  result = (int)(network->DirNode.Nentries - network->NoSubnets);
  for (current = RmFirstProcessor(network);
       current ne (RmProcessor) NULL;
       current = RmNextProcessor(current))
   if (current->ObjNode.Type eq Type_Network)
    result += RmCountProcessors((RmNetwork) current);
  return(result);
}

/**
*** Do not validate the type, it may be a subnet. Any object in a network
*** has a root, so if the root is NULL then the object is not in a network.
*** It is necessary to allow for the special case of the root network,
*** which has a pointer to itself but is not its own parent.
**/
RmNetwork RmParentNetwork(RmProcessor processor)
{ if (processor eq (RmProcessor) NULL)
   return(RmErrno = RmE_NotProcessor, (RmNetwork) NULL);
  if (processor->Root eq (RmNetwork) NULL) 
   return(RmErrno = processor->Errno = RmE_NotNetwork, (RmNetwork) NULL);
  if (processor->Root eq (RmNetwork) processor) return((RmNetwork) NULL);
  return((RmNetwork) processor->ObjNode.Parent);
}

int RmApplyNetwork(RmNetwork network, int (*fn)(RmProcessor, ...), ...)
{ va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0;
  RmProcessor	processor, next;
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);

  CheckNetworkFail(network, -1);  

  processor	= (RmProcessor) network->DirNode.Entries.Head;
  next		= (RmProcessor) processor->ObjNode.Node.Next;
  while (next ne (RmProcessor) NULL)
   { result	+= (*fn)(processor, arg1, arg2, arg3);
     processor	 = next;
     next	 = (RmProcessor) processor->ObjNode.Node.Next;
   }
  return(result);
}

int RmSearchNetwork(RmNetwork network, int (*fn)(RmProcessor, ...), ...)
{ va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0;
  RmProcessor	processor, next;
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);

  CheckNetworkFail(network, -1);  

  processor	= (RmProcessor) network->DirNode.Entries.Head;
  next		= (RmProcessor) processor->ObjNode.Node.Next;
  while ((next ne (RmProcessor) NULL) && (result eq 0))
   { result	+= (*fn)(processor, arg1, arg2, arg3);
     processor	 = next;
     next	 = (RmProcessor) processor->ObjNode.Node.Next;
   }
  return(result);
}


int RmApplyProcessors(RmNetwork network, int (*fn)(RmProcessor, ...), ...)
{ va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0;
  RmProcessor	processor, next;
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);

  CheckNetworkFail(network, -1);  

  processor	= (RmProcessor) network->DirNode.Entries.Head;
  next		= (RmProcessor) processor->ObjNode.Node.Next;
  while (next ne (RmProcessor) NULL)
   { if (processor->ObjNode.Type eq Type_Network)
      result += RmApplyProcessors((RmNetwork) processor, fn, arg1, arg2, arg3);
     else   
      result	+= (*fn)(processor, arg1, arg2, arg3);
     processor	 = next;
     next	 = (RmProcessor) processor->ObjNode.Node.Next;
   }
  return(result);
}

int RmSearchProcessors(RmNetwork network, int (*fn)(RmProcessor, ...), ...)
{ va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0;
  RmProcessor	processor, next;
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);

  CheckNetworkFail(network, -1);  

  processor	= (RmProcessor) network->DirNode.Entries.Head;
  next		= (RmProcessor) processor->ObjNode.Node.Next;
  while ((next ne (RmProcessor) NULL) && (result eq 0))
   { if (processor->ObjNode.Type eq Type_Network)
      result += RmSearchProcessors((RmNetwork) processor, fn, arg1, arg2, arg3);
     else
      result	+= (*fn)(processor, arg1, arg2, arg3);
     processor	 = next;
     next	 = (RmProcessor) processor->ObjNode.Node.Next;
   }
  return(result);
}

/**
*** Do not validate the type, it may be a subnet. Note that the root
*** network is its own root.
**/
RmNetwork RmRootNetwork(RmProcessor processor)
{ if (processor eq (RmProcessor) NULL)
   return(RmErrno = RmE_NotProcessor, (RmNetwork) NULL);
  return(processor->Root);
}

bool RmIsNetwork(RmProcessor processor)
{ if (processor eq (RmProcessor)NULL)
   return(RmErrno = RmE_NotProcessor, FALSE);
  return(processor->ObjNode.Type eq Type_Network);
}

bool RmIsProcessor(RmProcessor processor)
{ if (processor eq (RmProcessor)NULL) 
   return(RmErrno = RmE_NotProcessor, FALSE);
  return(processor->ObjNode.Type eq Type_Processor);
}

/**
*** RmFindMatchingProcessor(). This serves two purposes:
*** a) when considering two existing networks or subnets, for example the
***    user's domain and the global network, it allows the programmer
***    to switch from one to the other.
*** b) when using a constructed template to obtain a network of processors
***    it allowsa similar mapping.
**/
RmProcessor RmFindMatchingProcessor(RmProcessor processor, RmNetwork network)
{ RmProcessor	result;

  CheckProcessorFail(processor, (RmProcessor) NULL);
  CheckNetworkFail(network, (RmProcessor) NULL);

  if ((processor->StructType eq RmL_Existing) || 
      (processor->StructType eq RmL_Obtained))
   result = RmFindProcessor(network, processor->Uid);
  else
   { if (processor->MappedTo eq 0) 
      return(processor->Errno = RmErrno = RmE_BadProcessor, (RmProcessor) NULL);
     result = RmFindProcessor(network, processor->MappedTo);
   }
  if (result eq RmM_ExternalProcessor) result = NULL;
  if (result eq (RmProcessor) NULL)
   processor->Errno = RmErrno = RmE_NotFound;
  return(result);   
}
/*}}}*/
/*{{{  Hardware facilities */

/**-----------------------------------------------------------------------------
*** Adding a hardware facility. These contain pointers to real processors,
*** not uid's, since applications must be able to examine hardware
*** facilities without knowing about uids. This means that conversions
*** are required when communicating networks. There are also problems if
*** a processor is removed from a network, because a pointer to that
*** processor can remain inside one or more hardware facility structures.
*** I am not too worried about all this since hardware facilities are not
*** really an important part of the library.
**/

int RmAddHardwareFacility(RmNetwork network, RmHardwareFacility *Reset)
{ RmHardwareFacility	*NewReset;

  CheckNetwork(network);  

  if (Reset eq Null(RmHardwareFacility))
   return(RmErrno = network->Errno = RmE_BadArgument);

  NewReset = (RmHardwareFacility *) Malloc(
   sizeof(RmHardwareFacility) + ((word)(Reset->NumberProcessors) * sizeof(RmProcessor *)));
  if (NewReset eq Null(RmHardwareFacility))
   return(RmErrno = network->Errno = RmE_NoMemory);

  memcpy((void *) NewReset, (void *) Reset, sizeof(RmHardwareFacility));
  NewReset->Processors = (RmProcessor *)
                ( &(((BYTE *)NewReset)[sizeof(RmHardwareFacility)]));
  NewReset->Device	= Null(void);
  NewReset->Essential	= (RmProcessor) NULL;
  memcpy((void *) NewReset->Processors, (void *) Reset->Processors,
         Reset->NumberProcessors * sizeof(RmProcessor *));
#ifdef SYSDEB
  NewReset->Node.Next = NewReset->Node.Prev = &NewReset->Node;
#endif
  AddTail(&(network->Hardware), &(NewReset->Node));
  return(RmE_Success);
}

int RmApplyHardwareFacilities(RmNetwork network,
		int (*fn)(RmHardwareFacility *, ...), ...)
{ va_list args;
  RmHardwareFacility *current, *next;
  int	arg1, arg2, arg3;
  int   result = 0;

  CheckNetworkFail(network, -1);  
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);
  
  current = (RmHardwareFacility *) network->Hardware.Head;
  next    = (RmHardwareFacility *) current->Node.Next;
  while (next ne Null(RmHardwareFacility))
   { result += (*fn)(current, arg1, arg2, arg3);
     current = next;
     next    = (RmHardwareFacility *) current->Node.Next;
   }
  return(result);
}

int RmSearchHardwareFacilities(RmNetwork network,
		int (*fn)(RmHardwareFacility *, ...), ...)
{ va_list args;
  RmHardwareFacility *current, *next;
  int	arg1, arg2, arg3;
  int   result = 0;

  CheckNetworkFail(network, -1);  
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);
  
  current = (RmHardwareFacility *) network->Hardware.Head;
  next    = (RmHardwareFacility *) current->Node.Next;
  while (next ne Null(RmHardwareFacility))
   { if ((result = (*fn)(current, arg1, arg2, arg3)) ne 0)
      return(result);
     current = next;
     next    = (RmHardwareFacility *) current->Node.Next;
   }
  return(0);
}

/*}}}*/
/*{{{  Taskforce manipulation */
RmTaskforce RmNewTaskforce(void)
{ RmTaskforce	result = (RmTaskforce) Malloc(sizeof(RmTaskforceStruct));
  Date		date = GetDate();
  
  if (result eq (RmTaskforce) NULL)
   return(RmErrno = RmE_NoMemory, (RmTaskforce) NULL);

  memset(result, 0, sizeof(RmTaskforceStruct));   
  result->DirNode.Type		= Type_Taskforce; 
  result->DirNode.Matrix	= 0x211109c7;	/* darwv:rx:ry:rz */
  InitSemaphore(&(result->DirNode.Lock), 1);
  result->DirNode.Key		= date + _cputime();
  result->DirNode.Parent	= Null(struct DirNode);
  result->DirNode.Dates.Creation =
  result->DirNode.Dates.Access	 =
  result->DirNode.Dates.Modified = date;
  InitList(&(result->DirNode.Entries));
  result->Root			= (RmSet) result;
  result->StructType		= RmL_New;
  result->ReturnCode		= -1;
  return(result);
}

static int FreeTaskforce_aux(RmTask task, ...)
{
  (void) Remove((Node *) task);
  task->ObjNode.Parent = Null(struct DirNode);

  if (RmIsTaskforce(task))
   return(RmFreeTaskforce((RmTaskforce) task));
  else
   return(RmFreeTask(task));
} 

int RmFreeTaskforce(RmTaskforce taskforce)
{ int result, i;

  CheckTaskforce(taskforce); 

  if (taskforce->DirNode.Parent ne Null(struct DirNode))
   return(RmErrno = taskforce->Errno = RmE_InUse);

  if (taskforce->DirNode.Nentries ne 0)
   { result = RmApplyTaskforce(taskforce, &FreeTaskforce_aux);  
     if (result ne RmE_Success)
      return(RmErrno = taskforce->Errno = result);
   }

  if (taskforce->NoTables > 0)
   { for (i = 0; i < taskforce->NoTables; i++)
      if (Free(taskforce->Tables[i]) ne Err_Null)
       return(RmErrno = taskforce->Errno = RmE_Corruption);
     if (Free(taskforce->Tables) ne Err_Null)
       return(RmErrno = taskforce->Errno = RmE_Corruption);
   }

  taskforce->DirNode.Type	= 0;
  Free(taskforce);
  return(RmE_Success);
}

const char *RmGetTaskforceId(RmTaskforce taskforce)
{
  CheckTaskforceFail(taskforce, (const char *) NULL);
  return(taskforce->DirNode.Name);
}

int RmSetTaskforceId(RmTaskforce taskforce, char *name)
{
  CheckTaskforce(taskforce);	
  if (taskforce->StructType ne RmL_New)
   return(RmErrno = taskforce->Errno = RmE_ReadOnly);
  if (strlen(name) >= NameMax)
   return(RmErrno = taskforce->Errno = RmE_TooLong);
  strcpy(taskforce->DirNode.Name, name);
  return(RmE_Success);
}

int RmSetTaskforcePrivate(RmTaskforce taskforce, int x)
{ CheckTaskforce(taskforce);	
  taskforce->Private = x;
  return(RmE_Success);
}

int RmSetTaskforcePrivate2(RmTaskforce taskforce, int x)
{ CheckTaskforce(taskforce);	
  taskforce->Private2 = x;
  return(RmE_Success);
}

int RmGetTaskforcePrivate(RmTaskforce taskforce)
{ CheckTaskforceFail(taskforce, -1);	
  return(taskforce->Private);
}

int RmGetTaskforcePrivate2(RmTaskforce taskforce)
{ CheckTaskforceFail(taskforce, -1);
  return(taskforce->Private2);
}

int RmGetTaskforceError(RmTaskforce taskforce)
{ CheckTaskforce(taskforce);	
  return(taskforce->Errno);
}

int RmClearTaskforceError(RmTaskforce taskforce)
{ CheckTaskforce(taskforce);
  return(taskforce->Errno = RmE_Success);
}

int RmGetTaskforceState(RmTaskforce taskforce)
{ CheckTaskforceFail(taskforce, -1);
  return(taskforce->State);
}

int RmSetTaskforceState(RmTaskforce taskforce, int state)
{ CheckTaskforce(taskforce);
  taskforce->State = state;
  return(RmE_Success);
}


RmTask RmFirstTask(RmTaskforce taskforce)
{ CheckTaskforceFail(taskforce, (RmTask) NULL);
  if (taskforce->DirNode.Nentries < 1)
   return((RmTask) NULL);
  return((RmTask) taskforce->DirNode.Entries.Head);
}

RmTask RmLastTask(RmTaskforce taskforce)
{ CheckTaskforceFail(taskforce, (RmTask) NULL); 
  if (taskforce->DirNode.Nentries < 1)
   return((RmTask) NULL);
  return((RmTask) taskforce->DirNode.Entries.Tail);
}

RmTask RmNextTask(RmTask task)
{ 
  if (task eq (RmTask) NULL)
   return(RmErrno = RmE_NotTask, (RmTask) NULL);
  if ((task->ObjNode.Type ne Type_Task) &&
      (task->ObjNode.Type ne Type_Taskforce))
   return(RmErrno = RmE_NotTask, (RmTask) NULL);

  if (task->ObjNode.Parent eq Null(struct DirNode))
   return(RmErrno = task->Errno = RmE_NotTaskforce, (RmTask) NULL);
  task = (RmTask) task->ObjNode.Node.Next;
  if (task->ObjNode.Node.Next eq Null(struct Node))
   return((RmTask) NULL);
  else
   return(task);
}

RmTask RmPreviousTask(RmTask task)
{ RmTask        result;
  RmTaskforce   parent;

  if (task eq (RmTask) NULL)
   return(RmErrno = RmE_NotTask, (RmTask) NULL);
  if ((task->ObjNode.Type ne Type_Task) &&
      (task->ObjNode.Type ne Type_Taskforce))
   return(RmErrno = RmE_NotTask, (RmTask) NULL);

  parent = (RmTaskforce) task->ObjNode.Parent;
  if (parent eq (RmTaskforce) NULL)
   return(RmErrno = task->Errno = RmE_NotTaskforce, (RmTask) NULL); 
  result = (RmTask) task->ObjNode.Node.Prev;
  if (result eq (RmTask) &(parent->DirNode.Entries.Head))
   return((RmTask) NULL);
  return(result);
}

bool RmIsTaskforceEmpty(RmTaskforce taskforce)
{ CheckTaskforceFail(taskforce, TRUE);
  return(taskforce->DirNode.Nentries eq 0);
}

int RmSizeofTaskforce(RmTaskforce taskforce)
{ CheckTaskforceFail(taskforce, -1);    
  return((int)taskforce->DirNode.Nentries);
}

int RmCountTasks(RmTaskforce taskforce)
{ int           result;
  RmTask        current;

  CheckTaskforceFail(taskforce, -1);  

  if (taskforce->NoSubsets eq 0) return((int)taskforce->DirNode.Nentries);
  result = (int)(taskforce->DirNode.Nentries - taskforce->NoSubsets);
  for (current = RmFirstTask(taskforce);
       current ne (RmTask) NULL;
       current = RmNextTask(current))
   if (current->ObjNode.Type eq Type_Taskforce)
    result += RmCountTasks((RmTaskforce) current);
  return(result);
}

RmTaskforce RmParentTaskforce(RmTask task)
{
  if (task eq (RmTask) NULL)
   return(RmErrno = RmE_NotTask, (RmTaskforce) NULL);
  if (task->Root eq (RmTaskforce) NULL)
   return(RmErrno = RmE_NotTask, (RmTaskforce) NULL);
  if (task->Root eq (RmTaskforce) task)
   return((RmTaskforce) NULL);
  return((RmTaskforce) task->ObjNode.Parent);
}

int RmApplyTaskforce(RmTaskforce taskforce, int (*fn)(RmTask, ...), ...)
{ va_list       args;
  int           arg1, arg2, arg3;
  int           result = 0;
  RmTask        task, next;
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);

  CheckTaskforceFail(taskforce, -1);  

  task          = (RmTask) taskforce->DirNode.Entries.Head;
  next          = (RmTask) task->ObjNode.Node.Next;
  while (next ne (RmTask) NULL)
   { 
     result     += (*fn)(task, arg1, arg2, arg3);
     task        = next;
     next        = (RmTask) task->ObjNode.Node.Next;
   }
  return(result);
}

int RmSearchTaskforce(RmTaskforce taskforce, int (*fn)(RmTask, ...), ...)
{ va_list       args;
  int           arg1, arg2, arg3;
  int           result = 0;
  RmTask        task, next;
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);

  CheckTaskforceFail(taskforce, -1);  
   
  task          = (RmTask) taskforce->DirNode.Entries.Head;
  next          = (RmTask) task->ObjNode.Node.Next;
  while ((next ne (RmTask) NULL) && (result eq 0))
   { result     += (*fn)(task, arg1, arg2, arg3);
     task        = next;
     next        = (RmTask) task->ObjNode.Node.Next;
   }
  return(result);
}

int RmApplyTasks(RmTaskforce taskforce, int (*fn)(RmTask, ...), ...)
{ va_list       args;
  int           arg1, arg2, arg3;
  int           result = 0;
  RmTask        task, next;
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);

  CheckTaskforceFail(taskforce, -1);  

  task          = (RmTask) taskforce->DirNode.Entries.Head;
  next          = (RmTask) task->ObjNode.Node.Next;
  while (next ne (RmTask) NULL)
   { if (task->ObjNode.Type eq Type_Taskforce)
      result += RmApplyTasks((RmTaskforce) task, fn, arg1, arg2, arg3);
     else
      result    += (*fn)(task, arg1, arg2, arg3);
     task        = next;
     next        = (RmTask) task->ObjNode.Node.Next;
   }
  return(result);
}

int RmSearchTasks(RmTaskforce taskforce, int (*fn)(RmTask, ...), ...)
{ va_list       args;
  int           arg1, arg2, arg3;
  int           result = 0;
  RmTask        task, next;
  
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);

  CheckTaskforceFail(taskforce, -1);  
   
  task          = (RmTask) taskforce->DirNode.Entries.Head;
  next          = (RmTask) task->ObjNode.Node.Next;
  while ((next ne (RmTask) NULL) && (result eq 0))
   { if (task->ObjNode.Type eq Type_Taskforce)
      result    += RmSearchTasks((RmTaskforce) task, fn, arg1, arg2, arg3);
     else
      result    += (*fn)(task, arg1, arg2, arg3);
     task        = next;
     next        = (RmTask) task->ObjNode.Node.Next;
   }
  return(result);
}

RmTaskforce RmRootTaskforce(RmTask task)
{ if (task eq (RmTask) NULL)
   return(RmErrno = RmE_NotTask, (RmTaskforce) NULL);
  return(task->Root);
}

bool RmIsTaskforce(RmTask task)
{ if (task eq (RmTask)NULL)
   return(RmErrno = RmE_NotTask, FALSE);
  return(task->ObjNode.Type eq Type_Taskforce);
}

bool RmIsTask(RmTask task)
{ if (task eq (RmTask)NULL)
   return(RmErrno = RmE_NotTask, FALSE);
  return(task->ObjNode.Type eq Type_Task);
}

RmTask RmFindMatchingTask(RmTask task, RmTaskforce taskforce)
{ RmTask result;

  CheckTaskFail(task, (RmTask) NULL);
  CheckTaskforceFail(taskforce, (RmTask) NULL);

  result = RmFindTask(taskforce, task->Uid);
  if (result eq RmM_ExternalTask) result = NULL;
  if (result eq (RmTask) NULL)
   task->Errno = RmErrno = RmE_NotFound;
  return(result);   
}
/*}}}*/
/*{{{  Task <-> Processor mapping */

int RmMapTask(RmProcessor processor, RmTask task)
{
  CheckProcessor(processor);
  CheckTask(task);
  
  if (task->MappedTo ne RmL_NoUid)
   return(RmErrno = task->Errno = RmE_InUse);
  AddTail(&(processor->MappedTasks), &(task->MappedNode));
  task->MappedTo = processor->Uid;
  return(RmE_Success);
}

static int RmCheckMappedTask(RmProcessor processor, RmTask task)
{ Node  *current;
  Node  *real;

  CheckProcessor(processor);
  CheckTask(task);  

  real = &(task->MappedNode);
  for (current = Head_(Node, processor->MappedTasks);
       !EndOfList_(current);
       current = Next_(Node, current))
   if (current eq real)
    return(RmE_Success);
    
  return(RmErrno = task->Errno = RmE_NotFound);       
}

bool RmIsMappedTask(RmProcessor processor, RmTask task)
{ if (RmCheckMappedTask(processor, task) eq RmE_Success)
   return(TRUE);
  else
   return(FALSE);
}

int RmUnmapTask(RmProcessor processor, RmTask task)
{ int   x = RmCheckMappedTask(processor, task);
  if (x eq RmE_Success)
   { Remove(&(task->MappedNode));
     task->MappedTo = RmL_NoUid;
   }
  return(x);
}

RmProcessor RmFollowTaskMapping(RmNetwork network, RmTask task)
{ 
  CheckNetworkFail(network, (RmProcessor) NULL);
  CheckTaskFail(task, (RmProcessor) NULL);

  if (task->MappedTo eq RmL_NoUid) return((RmProcessor) NULL);
  return(RmFindProcessor(network, task->MappedTo));
}

int RmApplyMappedTasks(RmProcessor processor, int (*fn)(RmTask, ...), ...)
{ Node		*current, *next;
  RmTask         temp;
  va_list        args;
  int            arg1, arg2, arg3;
  int            result = 0; 

  CheckProcessorFail(processor, -1);

  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);
  
  for (current = Head_(Node, processor->MappedTasks);
       !EndOfList_(current);
       current = next )
   { next = Next_(Node, current);
     temp = (RmTask) (((BYTE *) current) - offsetof(RmTaskStruct, MappedNode));
     result += (*fn)(temp, arg1, arg2, arg3);
   }
  return(result);
}

int RmSearchMappedTasks(RmProcessor Processor, int (*fn)(RmTask, ...), ...)
{ Node		*current, *next;
  RmTask         temp;
  va_list        args;
  int            arg1, arg2, arg3;
  int            result = 0; 

  CheckProcessorFail(Processor, -1);

  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);
  
  for (current = Head_(Node, Processor->MappedTasks);
       !EndOfList_(current);
       current = next )
   { next = Next_(Node, current);
     temp = (RmTask) (((BYTE *) current) - offsetof(RmTaskStruct, MappedNode));
     result = (*fn)(temp, arg1, arg2, arg3);
     if (result ne 0) return(result);
   }
  return(result);
}

int RmCountMappedTasks(RmProcessor processor)
{ int   result = 0;
  Node  *temp;

  CheckProcessorFail(processor, -1);  
  
  for (temp = Head_(Node, processor->MappedTasks);
       !EndOfList_(temp);
       temp = Next_(Node, temp))
   result++;
  return(result);
}

/*}}}*/
/*{{{  Uid manipulation */

/**-----------------------------------------------------------------------------
*** Before considering the structure manipulation routines, here are the
*** routines for manipulating Uid's.
***
*** RmFindTableEntry takes as arguments the root of a network or taskforce
*** and a uid, and returns a pointer to the RmUidTableEntry. It validates
*** the table number and the index within the table, but not the cycle
*** number.
**/

RmUidTableEntry *RmFindTableEntry(RmSet root, RmUid uid)
{ int             tabno, tabindex;
  RmUidTableEntry *tab;
  
  if ((root eq (RmSet)NULL) || (uid  eq RmL_NoUid) )
   return(Null(RmUidTableEntry));
   
  tabno    = (uid >> 8) & 0x0000FFFF;
  tabindex = uid & 0x000000FF;
  if ((tabindex >= RmL_SlotsPerTable) ||
      (tabno    >= root->NoTables))
   return(Null(RmUidTableEntry));
  tab = &(((root->Tables)[tabno])[tabindex]);
  return(tab);
}

/**
*** RmFindUid() is similar to RmFindTableEntry(), but returns a pointer
*** to the target object rather the TableEntry. In addition it checks
*** the cycle number.
**/
RmObject RmFindUid(RmSet root, RmUid uid)
{ RmUidTableEntry *tab = RmFindTableEntry(root, uid);

  if (tab eq Null(RmUidTableEntry)) return(RmL_NoObject);
  if (RmGetCycle(uid) ne tab->Cycle)
   return(RmL_ExtObject);
  return((RmObject) tab->Target);
}

/**
*** This routine extends the table of tables by 1, to allow for overflows.
**/  
bool RmExtendFreeQ(RmSet root)
{ RmUidTableEntry *newtab;
  RmUidTableEntry **tabs;

    /* Obtain space for another 64 TableEntry's */
  newtab = (RmUidTableEntry *)
      Malloc(RmL_SlotsPerTable * sizeof(RmUidTableEntry));     
  if (newtab eq Null(RmUidTableEntry))
   return(FALSE);

    /* Realloc the table of tables of TableEntries */
  tabs = (RmUidTableEntry **) 
          Malloc(((word)(root->NoTables) + 1) * sizeof(RmUidTableEntry *));
  if (tabs eq Null(RmUidTableEntry *))
   { Free(newtab);
     return(FALSE);
   }
  if (root->NoTables > 0)
   memcpy(tabs, root->Tables, (size_t)(root->NoTables * sizeof(RmUidTableEntry *)));
  tabs[root->NoTables] = newtab;
  
    /* Set all the new slots to free */
  { int i; 
    for (i = 0; i < RmL_SlotsPerTable; i++)
     { newtab[i].Cycle  = 0;
       newtab[i].Free   = TRUE;
       newtab[i].Target = (void *) RmL_NoObject;
     }
  }
  
  if (root->NoTables eq 0)      /* Very first one */
   { newtab[0].Free     = FALSE;        /* Ensures that Uid of 0 is invalid */
     newtab[0].Target   = (void *) RmM_NoProcessor;
     newtab[1].Free     = FALSE;
     newtab[1].Target   = (void *) RmM_ExternalProcessor;
   }
   
   /* Update the Root structure */     
  if (root->NoTables > 0)
   Free(root->Tables);
  root->Tables  = tabs;
  root->NoTables++;
  return(TRUE);
}

/**
*** The routine picks the next free Uid that is available, and assigns
*** the given object that Uid. This involves filling in the table of
*** Uid's and filling in the Uid field of the object. The routine may
*** recurse once, to allow for having to extend the queue.
**/
bool RmNextFreeUid(RmSet root, RmObject obj)
{ int tabno, slot;

  if ((root eq (RmSet)NULL) || (obj eq (RmObject)NULL))
   return(FALSE);
  if (obj->Uid ne RmL_NoUid) return(FALSE);

  for (tabno = 0; tabno < root->NoTables; tabno++)
   { RmUidTableEntry *table = (root->Tables)[tabno];
     for (slot = 0; slot < RmL_SlotsPerTable; slot++)
      { if (table[slot].Free)
         { table[slot].Free = FALSE;
           obj->Uid = (table[slot].Cycle << 24) + (tabno << 8) + slot;
           table[slot].Target = (void *) obj;
           return(TRUE);
         }
       }
   }

  unless(RmExtendFreeQ(root))
   return(FALSE);
  return(RmNextFreeUid(root, obj));
}

/**
*** This routine releases the Uid associated with the object. It is
*** called when free'ing an object that is still inside a network or
*** taskforce.
***/
bool RmReleaseUid(RmObject obj)
{ RmSet root;
  RmUidTableEntry *tab;
  int uid;
    
  if (obj eq (RmObject)NULL) return(FALSE);
  root = obj->Root;
  uid  = obj->Uid;
  
  if (root eq (RmSet)NULL) return(FALSE);
  if (uid eq RmL_NoUid) return(FALSE);
  tab = RmFindTableEntry(root, uid);
  if (tab eq Null(RmUidTableEntry)) return(FALSE);
  if (tab->Target ne (void *) obj) return(FALSE);
  if (RmGetCycle(uid) ne tab->Cycle)
   return(FALSE);
   
  tab->Target   = (void *) RmL_NoObject;
  tab->Cycle    = tab->Cycle + 1;
  tab->Free     = TRUE;
  obj->Uid      = RmL_NoUid;
  return(TRUE);
}

/**
*** This routine is similar to RmNextFreeUid(), but if the object already
*** has a Uid of some sort then the system will attempt to reuse it.
*** For example, when adding an obtained processor to an obtained network
*** it is very desirable to keep the same Uid.
**/
bool RmObtainUid(RmSet root, RmObject obj)
{ int uid;
  RmUidTableEntry *tab;
  
  if ((root eq (RmSet)NULL) || (obj eq (RmObject)NULL)) return(FALSE);

  uid = obj->Uid;
  if (uid eq RmL_NoUid)
   return(RmNextFreeUid(root, obj));

  tab = RmFindTableEntry(root, uid);
  if (tab eq Null(RmUidTableEntry))
   { int tabno = (uid >> 8) & 0x00FFFF;
     if (tabno >= root->NoTables)
      { while(tabno >= root->NoTables)
         unless(RmExtendFreeQ(root))
          return(FALSE);
        return(RmObtainUid(root, obj));
      }
     else
      return(FALSE);
   }
  if (tab->Free)
   { tab->Free   = FALSE;
     tab->Cycle  = RmGetCycle(uid);
     tab->Target = (void *) obj;
     return(TRUE);
   }
  else
   return(FALSE);
}

/*}}}*/
/*{{{  Adding objects (including subsets and merging) */

/**-----------------------------------------------------------------------------
*** List manipulation routines. These are much more complicated than they
*** appear, because of the need to keep Uid's in a sensible state. 
***
*** The final routine is RmAddObject. By now both objects are believed
*** to exist, and it is legal to add the object to the set. The object may
*** be terminal, or a subset. The routine can be used irrespective of
*** whether or not it is already in the network, by use of a flag argument.
*** This means that it can be used by AddTail, AddHead, PreInsert, and
*** PostInsert. Note that the routine does not put the object into the list.
***
*** RmAddObject() is called by RmAddProcessor() or RmAddTail(), which
*** do the necessary type validation.
***
*** RmAddProcessor() is called by RmAddTailProcessor(), RmAddHeadProcessor(),
*** RmPreInsertProcessor(), and RmPostInsertProcessor().
**/
static RmObject    RmAddObject(RmSet set, RmObject obj, bool bNew);
static RmProcessor RmAddProcessor(RmNetwork, RmProcessor, bool);
static RmTask      RmAddTask(RmTaskforce, RmTask, bool);


/**
*** This routine is called to add an obtained processor to an obtained network
*** First check that these conditions have been met. Then determine the right
*** subnet in which to put the processor. Then call RmAddProcessor.
**/
RmProcessor     RmInsertProcessor(RmNetwork network, RmProcessor processor)
{ char          *netname, *temp;
  RmProcessor   cur_proc;

  CheckNetworkFail(network, (RmProcessor) NULL);
  CheckProcessorFail(processor, (RmProcessor) NULL);

  netname = RmGetObjectAttribute((RmObject) processor, "PUID", TRUE);
  if (netname eq Null(char))
   return(RmErrno = network->Errno = processor->Errno = RmE_NoAccess,
          (RmProcessor) NULL);

        /* Do not validate the root of the network, this might be /domain */
  for (temp = &(netname[1]); (*temp ne '/') && (*temp ne '\0'); temp++);
  if (*temp eq '\0')            /* just /Net ?? */
   return(RmErrno = network->Errno = processor->Errno = RmE_WrongNetwork,
          (RmProcessor) NULL);

  forever 
   { 
loop:
     netname = ++temp;          /* now root or Cluster/Root */
     if (netname eq '\0')               /* /Net/ ??? */
      return(RmErrno = network->Errno = processor->Errno = RmE_WrongNetwork,
             (RmProcessor)NULL);

     for (temp = netname; (*temp ne '/') && (*temp ne '\0'); temp++);
     if (*temp eq '\0') /* we are now in the target network */
      { 
        if (RmAddProcessor(network, processor, TRUE) ne (RmProcessor) NULL)
         { if (network->NoSubnets eq 0)
            AddTail(&(network->DirNode.Entries), &(processor->ObjNode.Node));
           elif (network->NoSubnets eq network->DirNode.Nentries)
            AddHead(&(network->DirNode.Entries), &(processor->ObjNode.Node));
           else
            { RmProcessor head = RmFirstProcessor(network);
              until(RmIsNetwork(head)) head = RmNextProcessor(head);
              PreInsert(&(head->ObjNode.Node), &(processor->ObjNode.Node));
            }
           return(processor);
         }
        else
         return((RmProcessor) NULL);
      }


     *temp = '\0';              /* netname is Cluster/root, temp is /root */
     for (cur_proc = RmFirstProcessor(network);
          cur_proc ne (RmProcessor) NULL;
          cur_proc = RmNextProcessor(cur_proc))
      if (RmIsNetwork(cur_proc))
       if (!strcmp(netname, cur_proc->ObjNode.Name))
        { network       = (RmNetwork) cur_proc;
          *temp = '/';
          goto  loop;
        }
                /* specified subnet Cluster is not in this network */
     *temp = '/';
     return((RmProcessor) NULL);
  }
}

RmProcessor     RmAddtailProcessor(RmNetwork network, RmProcessor processor)
{
  if (RmAddProcessor(network, processor, TRUE) ne (RmProcessor) NULL)
   { AddTail(&(network->DirNode.Entries), &(processor->ObjNode.Node));
     return(processor);
   }
  else
   return((RmProcessor) NULL);
}

RmProcessor     RmAddheadProcessor(RmNetwork network, RmProcessor processor)
{
  if (RmAddProcessor(network, processor, TRUE) ne (RmProcessor) NULL)
   { AddHead(&(network->DirNode.Entries), &(processor->ObjNode.Node));
     return(processor);
   }
  else
   return((RmProcessor) NULL);
}

RmProcessor     RmPreinsertProcessor(RmProcessor procA, RmProcessor procB)
{ if ((procA eq (RmProcessor) NULL) || (procB eq (RmProcessor) NULL))
   return((RmProcessor) NULL);

  if (procB->ObjNode.Parent eq Null(struct DirNode))
   { if (RmAddProcessor((RmNetwork) procA->ObjNode.Parent, procB, TRUE))
      { PreInsert(&(procA->ObjNode.Node), &(procB->ObjNode.Node));
        return(procB);
      }
     else
      return((RmProcessor) NULL);
   }
  else
   { if (RmAddProcessor((RmNetwork) procA->ObjNode.Parent, procB, FALSE))
      { Remove(&(procB->ObjNode.Node));
        PreInsert(&(procA->ObjNode.Node), &(procB->ObjNode.Node));
        return(procB);
      }
     else
      return((RmProcessor) NULL);
   }
}

RmProcessor     RmPostinsertProcessor(RmProcessor procA, RmProcessor procB)
{ if ((procA eq (RmProcessor) NULL) || (procB eq (RmProcessor) NULL))
   return((RmProcessor) NULL);

  if (procB->ObjNode.Parent eq Null(struct DirNode))
   { if (RmAddProcessor((RmNetwork)procA->ObjNode.Parent, procB, TRUE))
      { PostInsert(&(procA->ObjNode.Node), &(procB->ObjNode.Node));
        return(procB);
      }
     else
      return((RmProcessor) NULL);
   }
  else
   { if (RmAddProcessor((RmNetwork) procA->ObjNode.Parent, procB, FALSE))
      { Remove(&(procB->ObjNode.Node));
        PostInsert(&(procA->ObjNode.Node), &(procB->ObjNode.Node));
        return(procB);
      }
     else
      return((RmProcessor) NULL);
   }
}

RmTask  RmAddtailTask(RmTaskforce taskforce, RmTask task)
{
  if (RmAddTask(taskforce, task, TRUE) ne (RmTask) NULL)
   { AddTail(&(taskforce->DirNode.Entries), &(task->ObjNode.Node));
     return(task);
   }
  else
   return((RmTask) NULL);
}

RmTask  RmAddheadTask(RmTaskforce taskforce, RmTask task)
{
  if (RmAddTask(taskforce, task, TRUE) ne (RmTask) NULL)
   { AddHead(&(taskforce->DirNode.Entries), &(task->ObjNode.Node));
     return(task);
   }
  else
   return((RmTask) NULL);
}

RmTask  RmPreinsertTask(RmTask taskA, RmTask taskB)
{ if ((taskA eq (RmTask) NULL) || (taskB eq (RmTask) NULL))
   return((RmTask) NULL);

  if (taskB->ObjNode.Parent eq Null(struct DirNode))
   { if (RmAddTask((RmTaskforce) taskA->ObjNode.Parent, taskB, TRUE))
      { PreInsert(&(taskA->ObjNode.Node), &(taskB->ObjNode.Node));
        return(taskB);
      }
     else
      return((RmTask) NULL);
   }
  else
   { if (RmAddTask((RmTaskforce) taskA->ObjNode.Parent, taskB, FALSE))
      { Remove(&(taskB->ObjNode.Node));
        PreInsert(&(taskA->ObjNode.Node), &(taskB->ObjNode.Node));
        return(taskB);
      }
     else
      return((RmTask) NULL);
   }
}

RmTask  RmPostinsertTask(RmTask taskA, RmTask taskB)
{ if ((taskA eq (RmTask) NULL) || (taskB eq (RmTask) NULL))
   return((RmTask) NULL);

  if (taskB->ObjNode.Parent eq Null(struct DirNode))
   { if (RmAddTask((RmTaskforce) taskA->ObjNode.Parent, taskB, TRUE))
      { PostInsert(&(taskA->ObjNode.Node), &(taskB->ObjNode.Node));
        return(taskB);
      }
     else
      return((RmTask) NULL);
   }
  else
   { if (RmAddTask((RmTaskforce) taskA->ObjNode.Parent, taskB, FALSE))
      { Remove(&(taskB->ObjNode.Node));
        PostInsert(&(taskA->ObjNode.Node), &(taskB->ObjNode.Node));
        return(taskB);
      }
     else
      return((RmTask) NULL);
   }
}

/**
*** These two routines validate the data types of the main arguments,
*** and then call RmAddObject() to do most of the real work. The
*** target object is not added to the list, that is done by the calling
*** routine.
**/

static RmTask   RmAddTask(RmTaskforce taskforce, RmTask task, bool bNew)
{ RmTask result;

  CheckTaskforceFail(taskforce, (RmTask) NULL);

  if (task eq (RmTask) NULL)
   return(RmErrno = RmE_NotTask, (RmTask) NULL);
  if ((task->ObjNode.Type ne Type_Task) && 
      (task->ObjNode.Type ne Type_Taskforce))
   return(RmErrno = RmE_NotTask, (RmTask) NULL);
  result = (RmTask) RmAddObject((RmSet) taskforce, (RmObject) task, bNew);
  if (result eq (RmTask) NULL) taskforce->Errno = RmErrno;
  return(result);
}

static RmProcessor      RmAddProcessor(RmNetwork network, RmProcessor processor,
                                        bool    bNew)
{ RmProcessor result;

  CheckNetworkFail(network, (RmProcessor) NULL);

  if (processor eq (RmProcessor)NULL)
   return(RmErrno = RmE_NotProcessor, (RmProcessor) NULL);
  if ((processor->ObjNode.Type ne Type_Processor) &&
      (processor->ObjNode.Type ne Type_Network))
   return(RmErrno = RmE_NotProcessor, (RmProcessor) NULL);

  result = (RmProcessor)RmAddObject((RmSet) network, (RmObject) processor, bNew);
   
  if (result eq (RmProcessor) NULL)
   network->Errno = RmErrno;
  return(result);  
}

/**
*** O.K, this is where things get tricky. RmAddObject()...
***
*** The following is known at this point. Set really is a directory of
*** some sort, possibly the root, possibly not. Obj can be either
*** a subset or a leaf object. The third argument indicates whether or
*** not this object is being added, or whether the list is being
*** rearranged. There are several more tests that have to be performed.
*** Otherwise, there is another routine call, depending on whether the
*** object is terminal or a subset.
**/

static RmObject RmAddTerminal(RmSet, RmObject, bool);
static RmSet    RmAddSubset(RmSet, RmSet, bool);

static RmObject RmAddObject(RmSet set, RmObject obj, bool bNew)
{ 
  if (set eq (RmSet) obj)
   return(RmErrno = RmE_BadArgument, (RmObject) NULL);

  if (bNew)      /* then the object cannot have a parent */
   { if (obj->ObjNode.Parent ne Null(struct DirNode))
      return(RmErrno = RmE_InUse, (RmObject) NULL);
   }
   
  if ((obj->ObjNode.Type & Type_Flags) eq Type_Directory)
   return((RmObject) RmAddSubset(set, (RmSet) obj, bNew));
  else
   return(RmAddTerminal(set, obj, bNew));
}

/**
*** If the subset is already part of the set, very little has to be done.
*** If the subset is empty, very little has to be done. However,
*** if the subset contains stuff then it is necessary to do quite a bit
*** of work remapping Uid's. A similar remapping has to take place when
*** merging two networks together.
**/
static bool  RmRemapUids(RmSet target, RmSet current);

static int change_root(RmProcessor obj, ...)
{ va_list args;
  RmSet   *root;
  
  va_start(args, obj);
  root = va_arg(args, RmSet *);
  va_end(args);
  if ((obj->ObjNode.Type & Type_Flags) eq Type_Directory)
   return(RmApplyNetwork((RmNetwork) obj, &change_root, root));
  obj->Root = (RmNetwork) root;
  return(0);
}
  
static RmSet RmAddSubset(RmSet set, RmSet subset, bool bNew)
{ int	i;

  if (bNew && (subset->DirNode.Nentries > 0))
   unless(RmRemapUids(set, subset))
    return(RmErrno = RmE_NoMemory, (RmSet) NULL);

  (void) RmApplyNetwork((RmNetwork) subset, &change_root, set->Root);

  subset->Root = set->Root;
  set->DirNode.Nentries++;
  unless(bNew)
   { RmSet parent = (RmSet) subset->DirNode.Parent;
     parent->DirNode.Nentries--;
   }  
  subset->DirNode.Parent = (struct DirNode *) set;
  set->NoSubsets++;

	/* The subset no longer has or needs uid info			*/
  for (i = 0; i < subset->NoTables; i++)
   Free(subset->Tables[i]);
  Free(subset->Tables);
  subset->Tables = NULL;
  subset->NoTables = 0;

  return(subset);
}

static RmObject RmAddTerminal(RmSet set, RmObject obj, bool bNew)
{ 
  if (bNew)
   unless(RmObtainUid(set->Root, obj))
     return(RmErrno = RmE_NoMemory, (RmObject) NULL);

  obj->Root = (RmSet) set->Root;
  set->DirNode.Nentries++;
  unless(bNew)
   { RmSet parent = (RmSet) obj->ObjNode.Parent;
     parent->DirNode.Nentries--;
   }
  obj->ObjNode.Parent = (struct DirNode *) set;
  return(obj);  
}

/**
*** Merging networks. This is only really used by the Taskforce Manager to
*** add an obtained network to the domain, but conceivably other applications
*** might want to do the same.
**/

static int RmMergeNetworksAux2(RmProcessor, ...);

int             RmMergeNetworks(RmNetwork domain, RmNetwork obtained)
{ int   rc;

  CheckNetwork(domain);
  CheckNetwork(obtained);
  
  if ((rc = RmSearchNetwork(obtained, &RmMergeNetworksAux2, domain))
      ne RmE_Success)
   RmErrno = domain->Errno = obtained->Errno = rc;
  return(rc);
}

static int RmMergeNetworksAux2(RmProcessor processor, ...)
{ RmNetwork     target;
  va_list       args;
  RmProcessor   current;
  
  va_start(args, processor);
  target = va_arg(args, RmNetwork);
  va_end(args);

  if (processor->ObjNode.Type ne Type_Processor)
   { for (current = RmFirstProcessor(target);
          current ne (RmProcessor) NULL;
          current = RmNextProcessor(current))
      if (current->ObjNode.Type eq Type_Network)
       if (!strcmp(current->ObjNode.Name, processor->ObjNode.Name))
        return(RmSearchNetwork((RmNetwork) processor, &RmMergeNetworksAux2, current));
      return(RmE_BadArgument);
   }

  { RmNetwork   parent = (RmNetwork) processor->ObjNode.Parent;
    parent->DirNode.Nentries--;
    Remove(&(processor->ObjNode.Node));
  }

  unless(RmObtainUid((RmSet) target->Root, (RmObject) processor))
   return(RmE_InUse);

  if (target->NoSubnets eq 0)
   AddTail(&(target->DirNode.Entries), &(processor->ObjNode.Node));
  elif (target->NoSubnets eq target->DirNode.Nentries)
   AddHead(&(target->DirNode.Entries), &(processor->ObjNode.Node));
  else
   { for (current = RmFirstProcessor(target);
          current->ObjNode.Type ne Type_Network;
          current = RmNextProcessor(current));
     PreInsert( &(current->ObjNode.Node), &(processor->ObjNode.Node));
   }
  target->DirNode.Nentries++;
  processor->ObjNode.Parent = (DirNode *) target;
  processor->Root           = (RmNetwork) target->Root;
  return(RmE_Success);
}
/**
*** For every terminal object in SetB, allocate a new Uid inside SetA.
*** Then walk through all the connections inside SetB and change them
*** for the new Uids. The routine works in four stages.
***
*** 1) walk down the terminals and obtain a new Uid. This will invalidate
***    the current Uid's, but not the Uid tables for SetB. The old Uid is
***    stored in the RmLib field, for restoring purposes.
***
*** 2) On an error, restore all the old Uid's and free the slots in the
***    new slot.
***
*** 3) Check whether any of the Uid's have changed. If not, finished.
***
*** 4) walk down the terminals again, and for every connection use the old
***    Uid tables to get to the right pointer and fill in the new Uid
***
*** The routine is called only from inside the library, with all the
*** arguments validated.
**/

static int      RmRemapAux1(RmProcessor processor, ...)
{ va_list args;
  RmNetwork network;
  
  va_start(args, processor);
  network = va_arg(args, RmNetwork);
  va_end(args);
  
  processor->Private = processor->Uid;
  
  if (RmIsNetwork(processor))
   return(RmApplyNetwork((RmNetwork) processor, &RmRemapAux1, network));
   
  if (RmObtainUid((RmSet) network, (RmObject) processor))
   return(0);

        /* The uid is already in use, so get a different one */
  processor->Uid = RmL_NoUid;
  if (RmNextFreeUid((RmSet) network, (RmObject) processor))
   return(0);
  
        /* Failed to get a Uid of any sort. This is an error */
  return(1);
}

        /* This routine undoes any damage done by the previous routine */
static int      RmRemapAux2(RmProcessor processor, ...)
{ va_list args;
  RmNetwork network, save;
  
  va_start(args, processor);
  network = va_arg(args, RmNetwork);
  va_end(args);
  if (RmIsNetwork(processor))
   return(RmApplyNetwork((RmNetwork) processor, &RmRemapAux2, network));
  if (processor->Uid eq RmL_NoUid)
   { processor->Uid = processor->Private;
     return(0);
   }
  save = processor->Root;
  processor->Root = network;
  if (!RmReleaseUid((RmObject) processor))
   { processor->Root = save;
     return(1);
   }
  processor->Root = save;
  processor->Uid  = processor->Private;
  return(0);
}

static int      RmRemapAux3(RmProcessor processor, ...)
{ if (RmIsNetwork(processor))
   return(RmApplyNetwork((RmNetwork) processor, &RmRemapAux3));
  if (processor->Uid ne processor->Private)
   return(1);
  return(0);
}

static int      RmRemapAux4(RmProcessor processor, ...)
{ int   count, i;

  if (RmIsNetwork(processor))
   return(RmApplyNetwork((RmNetwork) processor, &RmRemapAux4));

  count = RmCountLinks(processor);
  for (i = 0; i < count; i++)
   { RmLink *link = RmFindLink(processor, i);
     RmObject obj;
     if ((link->Target eq RmL_NoUid) || (link->Target eq RmL_ExtUid))
      continue;
     obj = RmFindUid((RmSet) processor->Root, link->Target);
     if ((obj eq RmL_NoObject) || (obj eq RmL_ExtObject))
      continue;
     link->Target = obj->Uid;
   } 
  return(0);
}

static bool     RmRemapUids(RmSet setA, RmSet setB)
{
  if (RmApplyNetwork((RmNetwork) setB, &RmRemapAux1, setA) ne 0)
   { if (RmApplyNetwork((RmNetwork) setB, &RmRemapAux2, setA) ne 0)
      IOdebug("RmLib internal error : failed to undo RemapUids");
     return(FALSE);
   }
  if (RmSearchNetwork((RmNetwork) setB, &RmRemapAux3) ne 0)
   return(RmApplyNetwork((RmNetwork) setB, &RmRemapAux4) eq 0);
  return(TRUE);
}

/*}}}*/
/*{{{  Removing objects (including subsets) */
/**
*** RmRemoveProcessor() and RmRemoveTask(), these verify the argument
*** and call routines RmRemoveSet() and RmRemoveObject() to do the real
*** work.
**/
static RmSet    RmRemoveSet(RmSet set);
static RmObject RmRemoveObject(RmObject obj);

RmProcessor     RmRemoveProcessor(RmProcessor processor)
{ RmProcessor result;

  if (processor eq (RmProcessor) NULL)
   return(RmErrno = RmE_NotProcessor, (RmProcessor) NULL);
  if (processor->ObjNode.Type eq Type_Processor)
   { if ((result = (RmProcessor) RmRemoveObject((RmObject) processor))
         eq (RmProcessor) NULL)
      processor->Errno = RmErrno;
     return(result);
   }
  elif(processor->ObjNode.Type eq Type_Network)
   { if ((result = (RmProcessor) RmRemoveSet((RmSet) processor))
         eq (RmProcessor) NULL)
      { RmNetwork network = (RmNetwork) processor;
        network->Errno    = RmErrno;
      }
     return(result);
   }
  else
   return(RmErrno = RmE_NotProcessor, (RmProcessor) NULL);
}

RmTask          RmRemoveTask(RmTask task)
{ RmTask        result;

  if (task eq (RmTask)NULL)
   return(RmErrno = RmE_NotTask, (RmTask) NULL);
  if (task->ObjNode.Type eq Type_Task)
   { if ((result = (RmTask) RmRemoveObject((RmObject) task))
         eq (RmTask) NULL)
      task->Errno = RmErrno;
     return(result);
   }
  elif (task->ObjNode.Type eq Type_Taskforce)
   { if ((result = (RmTask) RmRemoveSet((RmSet) task))
         eq (RmTask) NULL)
      { RmTaskforce taskforce = (RmTaskforce) task;
        taskforce->Errno      = RmErrno;
      }
     return(result);
   }
  else
   return(RmErrno = RmE_NotTask, (RmTask) NULL);
}

/**
*** RemoveObject(). This is only legal if the object is currently in a set.
*** The following steps are required.
***
*** 1) releasing the Uid. Unless the object is new, i.e. a structure created
***    by the user's application, the Uid should be restored afterwards.
***
*** 2) removing the object from the parent, updating all the fields
***
*** 3) setting the parent and root fields in the object
***
*** 4) if the object has been created locally get rid of the connections. 
***    It is almost impossible to maintain a user's
***    connections in a sensible state once an object has been removed,
***    so the connections are deleted
**/
static RmObject RmRemoveObject(RmObject obj)
{ int  Uid;
  RmSet parent;
  
  parent = (RmSet) obj->ObjNode.Parent;
  if (parent eq (RmSet)NULL)
   { RmErrno = (obj->ObjNode.Type eq Type_Processor) ? RmE_NotNetwork :
               RmE_NotTaskforce;
     return((RmObject) NULL);
   }

  Uid = obj->Uid;
  unless(RmReleaseUid(obj))
   return(RmErrno = RmE_Corruption, (RmObject) NULL);

  if (obj->StructType ne RmL_New) obj->Uid = Uid;
  
  (void) Remove(&(obj->ObjNode.Node));
  parent->DirNode.Nentries--;
    
  obj->ObjNode.Parent = Null(struct DirNode);
  obj->Root = (RmSet) NULL;

  if (obj->StructType eq RmL_New)  
   { int i;
     if (obj->Connections > 4)
      { (void) Free(obj->OtherLinks);
        obj->OtherLinks = Null(RmLink);
      }
     obj->Connections = 0;
     for (i = 0; i < 4; i++)
      { obj->DefaultLinks[i].Flags              = 0;
        obj->DefaultLinks[i].Destination        = 0;
        /* obj->Defaultlinks[i].Spare           = 0; */
        obj->DefaultLinks[i].Target             = RmL_NoUid;
      }
   }
  return(obj);
}

/**
*** RmRemoveSet(). If the set is empty then it is easy, the job is
*** equivalent to removing an object and setting the Root pointer
*** appropriately. Otherwise some work is needed.
***
*** 1) update the parent and current structures.
*** 2) allocate space for UidTables, using the same number of tables as in
***    the root. This may be more than necessary.
*** 3) update very processor in the target subnet, releasing the current Uid,
***    obtaining a uid using the new tables, and zapping the root pointer
*** 4) check every connection of every processor in the network, to see if
***    the connection now leads to the outside world. If there used to be
***    a connection but it is no longer valid, it is set to external
**/
static int      RmRemoveSetAux(RmProcessor, ...);
static int      RmRemoveSetAux2(RmProcessor, ...);

static RmSet    RmRemoveSet(RmSet set)
{ RmSet parent, root;
  int   i;

  parent = (RmSet) set->DirNode.Parent;
  root   = (RmSet) set->Root;
  if ((parent eq (RmSet) NULL) || (root eq (RmSet) NULL))
   { RmErrno = (set->DirNode.Type eq Type_Network) ? RmE_NotNetwork :
               RmE_NotTaskforce;
     return((RmSet) NULL);
   }

  if (set->DirNode.Nentries eq 0)
   { (void) Remove(&(set->DirNode.Node));
     parent->DirNode.Nentries--;
     parent->NoSubsets--;
     set->Root = (struct RmSetStruct *) set;
     set->DirNode.Parent = NULL;
     return(set);
   }

  for(i = 0; i < root->NoTables; i++)
   if (!RmExtendFreeQ(set))
    { int j;
      for (j = 0; j < i; j++)
       (void) Free(set->Tables[j]);
      (void) Free(set->Tables);
      set->NoTables = 0;
      return(RmErrno = RmE_NoMemory, (RmSet) NULL);
    }

  (void) Remove(&(set->DirNode.Node));
  parent->DirNode.Nentries--;
  parent->NoSubsets--;
  set->DirNode.Parent = Null(struct DirNode);
  set->Root = (struct RmSetStruct *) set;

  if (RmApplyNetwork((RmNetwork) set, &RmRemoveSetAux, set))
   return(RmErrno = RmE_NoMemory, (RmSet) NULL);

  (void) RmApplyNetwork((RmNetwork) set, &RmRemoveSetAux2);
  return(set);
}

static int RmRemoveSetAux(RmProcessor obj, ...)
{ va_list       args;
  RmNetwork     root;
  int           temp;

  va_start(args, obj);
  root = va_arg(args, RmNetwork);
  va_end(args);

  if ((obj->ObjNode.Type & Type_Flags) eq Type_Directory)
   { RmSet tmp = (RmSet) obj;
     tmp->Root = (RmSet) root;
     return(RmApplyNetwork((RmNetwork) obj, &RmRemoveSetAux, root));
   }
   
  temp       = obj->Uid;
  unless(RmReleaseUid((RmObject) obj)) return(1);
  obj->Uid   = temp;
  obj->Root  = (RmNetwork) root;
  unless(RmObtainUid((RmSet) root, (RmObject) obj)) return(1);
  return(0);
}

static int      RmRemoveSetAux2(RmProcessor processor, ...)
{ int i;

  if (RmIsNetwork(processor))
   return(RmApplyNetwork((RmNetwork) processor, &RmRemoveSetAux2));

  for (i = 0; i < processor->Connections; i++)
   { RmLink *link = RmFindLink(processor, i);

     if ((link->Target ne RmL_NoUid) && (link->Target ne RmL_ExtUid))
      { RmUidTableEntry *entry = 
         RmFindTableEntry((RmSet) processor->Root, link->Target);
        if (entry->Free)
         link->Target = RmL_ExtUid;
      }
   }
  return(0); 
}
/*}}}*/
/*{{{  Links and channels */

/**-----------------------------------------------------------------------------
*** Manipulating links and channels. By a strange coincidence the same
*** code can be used for manipulating links between processors and channels
*** between tasks. Both are implemented in terms of RmObjects, which happen
*** to use links. Links are numbered from 0 onwards. 
***
*** The first routine, RmFindLink(), simply returns a pointer to the
*** appropriate RmLink structure given the object.
**/

RmLink  *RmFindLink(RmProcessor processor, int linkno)
{ if (linkno >= processor->Connections)
   return(RmErrno = RmE_BadArgument, Null(RmLink));
  elif (linkno < 4)
   return(&(processor->DefaultLinks[linkno]));
  else
   return(&(processor->OtherLinks[linkno - 4]));
}

/**
*** There are routines RmMakeConn(), RmFollowConn(), and so on, that
*** get called by RmMakeLink(), RmMakeChannel(), etc. following
*** basic validation tests. Some of the routines call themselves
*** recursively to deal with the other end of the connection, so there
*** is an extra argument to control this.
**/
static int      RmMakeConn(RmObject, int, RmObject, int, int recurse);
static int      RmBreakConn(RmObject, int, int recurse);
static RmObject RmFollowConn(RmObject, int, int *);
static void      build_fd_string(char *buf, int channel);

int RmMakeLink(RmProcessor source, int sourcelink, 
                   RmProcessor dest,   int destlink)
{ int rc;

  CheckProcessor(source);

  unless ((dest eq RmM_NoProcessor) || (dest eq RmM_ExternalProcessor))
   { CheckProcessor(dest);
   }
  if ((rc = RmMakeConn((RmObject) source, sourcelink, (RmObject) dest, destlink, TRUE))
      ne RmE_Success)
   RmErrno = source->Errno = rc;
  return(rc);
}

int RmMakeChannel(RmTask source, int sourcechan,
                      RmTask dest, int destchan)
{ int rc;

  CheckTask(source);

  unless ((dest eq RmM_NoTask) || (dest eq RmM_ExternalTask))
   { CheckTask(dest);
   }
  if ((rc = RmMakeConn((RmObject) source, sourcechan, (RmObject) dest, destchan, TRUE))
      ne RmE_Success)
   RmErrno = source->Errno = rc;
  return(rc);
}


int RmBreakLink(RmProcessor processor, int link)
{ int rc;

  CheckProcessor(processor);

  if ((link < 0) || (link >= processor->Connections))
   return(RmErrno = processor->Errno = RmE_BadArgument);
  if ((rc = RmBreakConn((RmObject) processor, link, TRUE))
      ne RmE_Success)
   RmErrno = processor->Errno = rc;
  return(rc);
}

/**
*** This has to cope with the special case of external channels, i.e.
*** streams redirected to and from files.
**/
int RmBreakChannel(RmTask task, int channel)
{ int rc;

  CheckTask(task);

  if ((channel < 0) || (channel >= task->Connections))
   return(RmErrno = task->Errno = RmE_BadArgument);

  if (RmFollowChannel(task, channel, Null(int)) eq RmM_ExternalTask)
   { char	buf[9];
     char	*result;
     build_fd_string(buf, channel);
     result	= RmGetObjectAttribute((RmObject) task, buf, TRUE);
     if (result ne Null(char))
      { result	= &(result[-9]);   /* fd000000=/helios/tmp/xx */
        (void) RmRemoveObjectAttribute((RmObject) task, result, TRUE);
      }
   }
  if ((rc = RmBreakConn((RmObject) task, channel, TRUE))
      ne RmE_Success)
   RmErrno = task->Errno = rc;
  return(rc);
}

int RmCountLinks(RmProcessor processor)
{ CheckProcessorFail(processor, -1);
  return(processor->Connections);
}

int RmCountChannels(RmTask task)
{ CheckTaskFail(task, -1);	
  return(task->Connections);
}

RmProcessor RmFollowLink(RmProcessor processor, int link, int *dlink)
{ RmProcessor result;
  int junk;
  if (dlink eq Null(int)) dlink = &junk;
  
  if (processor eq (RmProcessor) NULL)
   return(RmErrno = *dlink = RmE_NotProcessor, RmM_NoProcessor); 
  if (processor->ObjNode.Type ne Type_Processor)
   return(RmErrno = *dlink = RmE_NotProcessor, RmM_NoProcessor);
  
  if ((result = (RmProcessor) RmFollowConn((RmObject) processor, link, dlink))
      eq (RmProcessor) NULL)
   processor->Errno = RmErrno;
  return(result);
}

RmTask RmFollowChannel(RmTask task, int channel, int *dchannel)
{ RmTask result;
  int junk;
  if (dchannel eq Null(int)) dchannel = &junk;

  if (task eq (RmTask) NULL)
   return(RmErrno = *dchannel = RmE_NotTask, RmM_NoTask);
  if (task->ObjNode.Type ne Type_Task)
   return(RmErrno = *dchannel = RmE_NotTask, RmM_NoTask);
  if ((result = (RmTask) RmFollowConn((RmObject) task, channel, dchannel))
      eq (RmTask) NULL)
   task->Errno = RmErrno;
  return(result);
}

int RmGetLinkFlags(RmProcessor processor, int link)
{ RmLink *res;

  CheckProcessorFail(processor, -1);

  if ((link < 0) || (link >= processor->Connections))
   return(RmErrno = processor->Errno = RmE_BadArgument, -1);
  res = RmFindLink(processor, link);
  if (res eq Null(RmLink))
   return(RmErrno = RmE_BadLink, -1);
  else
   return(res->Flags);
}

int RmGetChannelFlags(RmTask task, int channel)
{ RmLink *res;

  CheckTaskFail(task, -1);

  if ((channel < 0) || (channel >= task->Connections))
   return(RmErrno = task->Errno = RmE_BadArgument, -1);
  res = RmFindLink((RmProcessor) task, channel);
  if (res eq Null(RmLink))
   return(RmErrno = task->Errno = RmE_BadChannel, -1);
  else
   return(res->Flags);
}

/**
*** Special routines to deal with redirection to and from files. These
*** are treated as external links, with the file name stored in the
*** private attributes list. The destlink field is overloaded with the
*** file open mode.
***
*** Fill in an attribute name depending on the channel number. For example,
*** if the channel number is 3 then the attribute name will be
*** fdaaaaad.
**/
static void build_fd_string(char *buf, int channel)
{ buf[0] = 'f';
  buf[1] = 'd';
  buf[7] = (channel & 0x0F) + 'a'; channel >>= 4;
  buf[6] = (channel & 0x0F) + 'a'; channel >>= 4;
  buf[5] = (channel & 0x0F) + 'a'; channel >>= 4;
  buf[4] = (channel & 0x0F) + 'a'; channel >>= 4;
  buf[3] = (channel & 0x0F) + 'a'; channel >>= 4;
  buf[2] = (channel & 0x0F) + 'a'; channel >>= 4;
  buf[8] = '\0';  
}

/**
*** RmConnectChannelToFile(). There are two cases. If the filename
*** is absolute then there is no way of getting an extra capability
*** for it. Otherwise the name stored should include a capability
*** for the current directory, in the form @@xxxx/helios/tmp:filename
*** This has the disadvantage of potentially confusing RmFollowChannelToFile()
***
*** N.B. the current CDL compiler does not store any capabilities.
**/

int RmConnectChannelToFile(RmTask task, int channelno, char *name, int mode)
{ int	rc;
  int	length;
  BYTE	*buffer;

	/* Validate all the arguments */    
  CheckTask(task);

  if ((name eq Null(char)) || (channelno eq RmM_AnyLink) || (channelno < 0))
   return(RmErrno = task->Errno = RmE_BadArgument);
  if (name[0] eq '\0') 
   return(RmErrno = task->Errno = RmE_BadArgument);

  if (name[0] eq '/')
   {	/* Create the attribute string fdaaaaad=/helios/temp */
     length = 10 + strlen(name);
     buffer = (BYTE *) Malloc(length);
     if (buffer eq Null(BYTE))
      return(RmErrno = task->Errno = RmE_NoMemory);
     build_fd_string(buffer, channelno);
     buffer[8] = '=';
     strcpy(&(buffer[9]), name);
   }
  else
   {    /* Creating a name relative to the current directory	*/
   	/* Format is aaaa=@@xxxxxxxxxxxxxxxx/helios/tmp:filename	*/
     Environ	*env = getenviron();
     Object	*context;
     if (env eq Null(Environ))
      return(RmErrno = task->Errno = RmE_NoMemory);
     context = env->Objv[OV_Cdir];

     length = 9 + 17 + strlen(context->Name) + 1 + strlen(name) + 1;
     buffer = (BYTE *) Malloc(length);
     if (buffer eq Null(BYTE))
      return(RmErrno = task->Errno = RmE_NoMemory);
     build_fd_string(buffer, channelno);
     buffer[8] = '=';
     (void) DecodeCapability(&(buffer[9]), &(context->Access));
     strcpy(&(buffer[26]), context->Name);
     strcat(&(buffer[26]), ":");
     strcat(&(buffer[26]), name);
   }
	/* Try to make this connection */    
  rc = RmMakeConn((RmObject) task, channelno, RmL_ExternalObject, mode, FALSE);
  if (rc ne RmE_Success)
   { Free(buffer);
     return(RmErrno = task->Errno = rc);
   }
	/* Add the string to the attributes, so that I can figure out */
	/* what the file name is */
  rc = RmAddObjectAttribute((RmObject) task, buffer, TRUE);
  if (rc ne RmE_Success)
   { (void) RmBreakConn((RmObject) task, channelno, FALSE);
     RmErrno = task->Errno = rc;
   }
  Free(buffer);
  return(rc);
}

const char *RmFollowChannelToFile(RmTask task, int channelno, int *mode_ptr)
{ int	temp;
  int	rc = RmE_NotTask;
  char	*result = NULL;
  char	buffer[9];
   
  if (mode_ptr eq Null(int)) mode_ptr = &temp;
  
  if (task eq (RmTask) NULL) 
   return(RmErrno = *mode_ptr = RmE_NotTask, Null(char));
  if (task->ObjNode.Type ne Type_Task)
   return(RmErrno = *mode_ptr = RmE_NotTask, Null(char));
  if ((channelno eq RmM_AnyLink) || (channelno < 0))
   { rc = RmE_BadArgument; goto done; }

  if (RmFollowChannel(task, channelno, mode_ptr) ne RmM_ExternalTask)
   { rc = RmE_BadFile; goto done; }
   
  build_fd_string(buffer, channelno); 
  result = RmGetObjectAttribute((RmObject) task, buffer, TRUE);
  if (result eq Null(char))
   rc = RmE_Corruption;
  else
   rc = RmE_Success;
   
done:
  if (rc ne RmE_Success)
   { *mode_ptr = RmErrno = task->Errno = rc; return(Null(char)); }
  else
   return(result); 
}

/**
*** The fill_in_link() routine takes a pointer to a
*** the target object and the number of the link to fill in, and
*** details of the destination. The relevant RmLink structure is known
*** to exist. 
**/
static int fill_in_link(RmObject source, int linkno,
			 RmObject dest, int destlink)
{ RmLink *curr_link = RmFindLink((RmProcessor) source, linkno);

  curr_link->Destination = destlink;

  if (dest eq RmL_NoObject)
   curr_link->Target		= RmL_NoUid;
  elif (dest eq RmL_ExternalObject)
   curr_link->Target		= RmL_ExtUid;
  else
   curr_link->Target		= dest->Uid;
  return(RmE_Success);
}

/**
*** add_link() is called when it is necessary to extend the number of
*** extra links held within an object. linkno is guaranteed to be
*** >= 4. Essentially it is a case of realloc'ing, without
*** using the C library, and then filling in the link.
**/
static int add_link(RmObject processor, int linkno, RmObject dest,
                    int destlink)
{ RmLink *new_links;
  int    i;
  
  new_links = (RmLink *) Malloc(((word)linkno - 3) * sizeof(RmLink));
  if (new_links eq Null(RmLink))
   return(RmErrno = RmE_NoMemory);
  for (i = (processor->Connections <= 4) ? 0 : processor->Connections - 4;
       i < (linkno - 3);
       i++)
   { new_links[i].Target       = RmL_NoUid;
     new_links[i].Flags	       = 0;
     new_links[i].Destination  = 0;
   }
  if (processor->Connections > 4)
   { memcpy((void *) new_links, (void *) processor->OtherLinks,
          (processor->Connections - 4) * sizeof(RmLink));
     Free(processor->OtherLinks);
   }

  processor->OtherLinks  = new_links;
  processor->Connections = linkno + 1;
  return(fill_in_link(processor, linkno, dest, destlink));
}


/**
*** This routine is responsible for making connections between objects.
*** The following things are known: source is a real object, either a
*** processor or a task; dest can be NoObject, ExtObject, or a real
*** object; sourcelink and destlink can be anything. This is not completely
*** true. In a recursive call source may well be NoObject or ExtObject,
*** in which case the routine is a no-op. The routine recurses if and only
*** if the link arguments are symmetrical: if both links are defined, or
*** neither link is defined. If only one link is defined then there is
*** no recursion.
***
*** 1) Check for source being NoObject or ExtObject
*** 2) It is illegal to connect AnyLink to NoObject or ExtObject
*** 3) If dest is a real object, it must be in the same set as source
*** 4) If sourcelink can be any link, look for a free slot, fill it in,
***    and mark it as AnyLink. See comment below.
*** 5) if sourcelink is a particular link, decide what should be done with
***    it. See comment below.
**/

static int RmMakeConn(RmObject source, int sourcelink, 
		   RmObject dest, int destlink, int recurse)
{
  if ((source eq RmL_NoObject) || (source eq RmL_ExternalObject))
   return(RmE_Success);
   
  if ((sourcelink eq RmM_AnyLink) && 
      ((dest eq RmL_NoObject) || (dest eq RmL_ExternalObject)))
   return(RmErrno = RmE_BadArgument);
   
  if ((dest ne RmL_NoObject) && (dest ne RmL_ExternalObject))
   { if (source->Root ne dest->Root)
      return(RmErrno = (source->ObjNode.Type eq Type_Processor) ? 
      		RmE_WrongNetwork : RmE_WrongTaskforce);
   }

  if (sourcelink eq RmM_AnyLink)
   { int i;
	/* If the source link can be any link, it is necessary to walk	*/
	/* through the table of known links to find a free slot. This	*/
	/* slot can now be used for this connection. If there are no	*/
	/* free slots it may be possible to fill in one of the four	*/
	/* default slots, if less than four links have been allocated,	*/
	/* otherwise the table of other connections has to be extended.	*/
     for (i = 0; i < source->Connections; i++)
      { RmLink *curr_link = RmFindLink((RmProcessor) source, i);

        if (curr_link->Target eq RmL_NoUid)
         { int result = fill_in_link(source, i, dest, destlink);
           if (result ne RmE_Success) return(RmErrno = result);
           curr_link->Flags |= RmF_AnyLink;
           goto recurse;
         }
      }

	/* There are no gaps in the current table of connections. This may */
	/* be because not all of the default connections have been used.   */
	/* If so I can use the next free default link.			   */
     if (source->Connections < 4)
      { int linkno = source->Connections++;
        RmLink	*link = RmFindLink((RmProcessor) source, linkno);
        int	result = fill_in_link(source, linkno, dest, destlink);
        if (result ne RmE_Success) return(RmErrno = result);
        link->Flags |= RmF_AnyLink;
	goto recurse;
      }   

	/* All the links including the default ones have been used, so it */
	/* is necessary to expand the table. */
      { int linkno = source->Connections;
        int result = add_link(source, linkno, dest, destlink);
        RmLink *link;
	if (result ne RmE_Success) return(RmErrno = result);
        link = RmFindLink((RmProcessor) source, linkno);
        link->Flags |= RmF_AnyLink;
	goto recurse;
      }

  }

	/* Special case, any negative link is invalid */
  if (sourcelink < 0) return(RmErrno = RmE_BadArgument);
       
	/* If a specific link number has been supplied, and this number is */
	/* greater than that of any existing link, then the link table must */
	/* be expanded to match. */
  if (sourcelink >= source->Connections)
   { if (sourcelink < 4)
      { int result;
        source->Connections = sourcelink + 1;
        result = fill_in_link(source, sourcelink, dest, destlink);
        if (result ne RmE_Success) return(RmErrno = result);
	goto recurse;
       }         
      else
       { int result = add_link(source, sourcelink, dest, destlink);
         if (result ne RmE_Success) return(RmErrno = result);
         goto recurse;
       }
   }

	/* A real link number has been supplied, and the link tables	*/
	/* contain this link. If the link is currently in use as AnyLink*/
	/* some rearranging is necessary. If the link is in		*/
	/* use as a real connection then this would have to be broken	*/
	/* first.							*/
   { RmLink *link = RmFindLink((RmProcessor) source, sourcelink);
   
     if (link->Target eq RmL_NoUid)
      { int result = fill_in_link(source, sourcelink, dest, destlink);
        if (result ne RmE_Success) return(RmErrno = result);
  	goto recurse;
      }

	/* If the connection already exists, there is no problem. */
    if ((dest ne RmL_NoObject) && (link->Target eq dest->Uid))
     { link->Destination = destlink;
       link->Flags	&= ~RmF_AnyLink;
       goto recurse;
     }
     
    if (link->Flags & RmF_AnyLink)
     { RmObject	obj	= RmFindUid(source->Root, link->Target);
       int	destlink = link->Destination;
       int	result;
       result = fill_in_link(source, sourcelink, dest, destlink);
       if (result ne RmE_Success) return(RmErrno = result);
       if (obj ne (RmObject)NULL)
        { result = RmMakeConn(source, RmM_AnyLink, obj, destlink, FALSE);
          if (result ne RmE_Success) return(RmErrno = result);
        }
     }
    return(RmErrno = RmE_InUse);
   }

recurse:
  unless(recurse)
   return(RmE_Success);
  if (((sourcelink ne RmM_AnyLink) && (destlink ne RmM_AnyLink)) ||
      ((sourcelink eq RmM_AnyLink) && (destlink eq RmM_AnyLink)))
   return(RmMakeConn(dest, destlink, source, sourcelink, FALSE));
  else
   return(RmE_Success);
}

/**
*** Breaking connections. At this point the source object has been
*** validated, but nothing else. Breaking a connection is equivalent
*** to connecting it to NoObject.
**/
static int RmBreakConn(RmObject source, int sourcelink, int recurse)
{ RmObject	dest;
  int		destlink;
  RmLink	*link;
  
  if ((sourcelink eq RmM_AnyLink) || (sourcelink < 0) ||
      (sourcelink >= source->Connections))
   return(RmErrno = RmE_BadArgument);
   
  link = RmFindLink((RmProcessor) source, sourcelink);
  if (link eq Null(RmLink)) return(RmErrno = RmE_Corruption);
  if (recurse && (link->Target ne RmL_NoUid) && (link->Target ne RmL_ExtUid))
   { dest = RmFindUid(source->Root, link->Target);
     destlink = link->Destination;
     if ((dest ne RmL_NoObject) && (dest ne RmL_ExtObject) &&
         (destlink ne RmM_AnyLink))
      (void) RmBreakConn(dest, destlink, FALSE);
   }
   
  link->Target  = RmL_NoUid;
  link->Destination = 0;
  link->Flags &= ~(RmF_AnyLink + RmF_ToFile);
  return(RmE_Success);
}

/**
*** Following a connection to its destination. At this point Processor
*** is guaranteed to be a valid object and dlink a valid pointer,
*** possibly pointing to a local somewhere in the calling routine's
*** stackframe. The value of link has not been validated. If reasonable,
*** the specified connection may be external, non-existant, or some
*** real object.
**/
static RmObject RmFollowConn(RmObject processor, int linkno, int *dlink)
{ RmLink   *link;
  RmObject Target;
  
  if ((linkno eq RmM_AnyLink) || (linkno < 0) || (linkno >= processor->Connections))
   { RmErrno = *dlink = RmE_BadArgument; return((RmObject) NULL); }
  link = RmFindLink((RmProcessor) processor, linkno);
  if (link->Target eq RmL_ExtUid)
   { *dlink = link->Destination; return(RmL_ExternalObject); }
  elif (link->Target eq RmL_NoUid)
   { *dlink = 0; return(RmL_NoObject); }

  Target = RmFindUid(processor->Root, link->Target);
  if (Target eq RmL_NoObject)
   *dlink = 0;
  else
   *dlink = link->Destination;
  if (Target eq RmL_NoObject)
   return(RmL_ExternalObject);
  else
   return(Target); 
}

/*}}}*/
/*{{{  Emacs Customisation */

/* Local variables: */
/* folded-file: t */
/* end: */

/*}}}*/
@


1.26
log
@fixed compile time warnings from ARM compiler
@
text
@d18 1
a18 1
/* RcsId: $Header: /hsrc/network/RCS/rmlib1.c,v 1.25 1993/08/12 11:16:05 nickc Exp nickc $*/
d1522 3
d1926 1
d2044 1
d2235 1
d2767 1
@


1.25
log
@fixed compile time warnings
@
text
@d18 1
a18 1
/* RcsId: $Header: /hsrc/network/RCS/rmlib1.c,v 1.24 1993/08/11 11:14:03 bart Exp nickc $*/
d355 1
a355 1
int RmAddObjectAttribute(RmObject obj, char *attr, bool private)
d362 1
a362 1
  if (private)
d377 1
a377 1
   { char *newdata = Malloc(2 * (word)(attrib->Size));
d438 1
a438 1
int RmRemoveObjectAttribute(RmObject object, char *attr, bool private)
d446 1
a446 1
  if (private)
d494 1
a494 1
char *RmGetObjectAttribute(RmObject obj, char *attr, bool private)
d500 1
a500 1
  if (private)
d532 1
a532 1
static int RmIsAnObjectAttribute(RmObject obj, char *attr, bool private)
d537 1
a537 1
  if (private)
d571 1
a571 1
static int RmCountObjectAttributes(RmObject obj, bool private)
d577 1
a577 1
  if (private)
d606 1
a606 1
static int RmListObjectAttributes(RmObject obj, char **table, bool private)
d613 1
a613 1
  if (private)
d683 1
a683 1
     buffer = Malloc(length);
d2247 1
a2247 1
static RmObject    RmAddObject(RmSet set, RmObject obj, bool new);
d2458 1
a2458 1
static RmTask   RmAddTask(RmTaskforce taskforce, RmTask task, bool new)
d2468 1
a2468 1
  result = (RmTask) RmAddObject((RmSet) taskforce, (RmObject) task, new);
d2474 1
a2474 1
                                        bool    new)
d2485 1
a2485 1
  result = (RmProcessor)RmAddObject((RmSet) network, (RmObject) processor, new);
d2507 1
a2507 1
static RmObject RmAddObject(RmSet set, RmObject obj, bool new)
d2512 1
a2512 1
  if (new)      /* then the object cannot have a parent */
d2518 1
a2518 1
   return((RmObject) RmAddSubset(set, (RmSet) obj, new));
d2520 1
a2520 1
   return(RmAddTerminal(set, obj, new));
d2545 1
a2545 1
static RmSet RmAddSubset(RmSet set, RmSet subset, bool new)
d2548 1
a2548 1
  if (new && (subset->DirNode.Nentries > 0))
d2556 1
a2556 1
  unless(new)
d2573 1
a2573 1
static RmObject RmAddTerminal(RmSet set, RmObject obj, bool new)
d2575 1
a2575 1
  if (new)
d2581 1
a2581 1
  unless(new)
@


1.24
log
@Sorted out stack checking options and upped the version number
@
text
@d6 1
a6 1
--             Copyright (C) 1990, Perihelion Software Ltd.             --
d18 1
a18 1
/* RcsId: $Header: /hsrc/network/RCS/rmlib1.c,v 1.23 1993/08/06 10:09:07 nickc Exp $*/
d377 1
a377 1
   { char *newdata = Malloc(2 * attrib->Size);
d708 1
d982 1
a982 1
   { int *temp = (int *) Malloc(2 * task->MaxArgIndex * sizeof(int));
d995 1
a995 1
   { char	*temp = (char *) Malloc(2 * task->MaxArgStrings);
d1093 1
d1490 1
d1511 1
a1511 1
   sizeof(RmHardwareFacility) + (Reset->NumberProcessors * sizeof(RmProcessor *)));
d1576 1
d2042 1
d2098 1
a2098 1
          Malloc((root->NoTables + 1) * sizeof(RmUidTableEntry *));
d2227 1
d3306 1
a3306 1
  new_links = (RmLink *) Malloc((linkno - 3) * sizeof(RmLink));
@


1.23
log
@fixed for compilation on RS6000
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /hsrc/network/RCS/rmlib1.c,v 1.22 1993/08/05 15:14:05 bart Exp nickc $";
d53 1
d56 1
a56 7
#if 1
#pragma -s1		/* disable stack checking			*/
#pragma -g0		/* remove names from code			*/
#else
#pragma -s0		/* enable stack checking			*/
#pragma -g1		/* put names into code				*/

d58 1
d64 3
a66 1

d85 1
d87 1
a87 1
#define	VersionNumber	"1.17"
d126 3
d130 1
@


1.22
log
@Now compiles for Sun4, plus fixed NULL pointer access
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /hsrc/network/RCS/rmlib1.c,v 1.21 1993/06/14 18:18:33 nickc Exp bart $";
d23 1
d25 1
a25 1
#ifdef __SUN4
d30 1
a38 1
#include <stddef.h>
d47 1
d50 1
d70 5
d2968 1
@


1.21
log
@oops, fixed lisp-ism in folding initialisation
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /hsrc/network/RCS/rmlib1.c,v 1.20 1993/06/11 15:26:32 nickc Exp nickc $";
d78 1
d80 5
a84 1
#define	VersionNumber	"1.16"
d87 3
d3425 1
a3425 1
    if (link->Target eq dest->Uid)
@


1.20
log
@added Emacs customisation to allow folding editing to work
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /hsrc/network/RCS/rmlib1.c,v 1.19 1993/04/14 16:11:47 nickc Exp nickc $";
d3511 3
a3513 3
;; Local variables:
;; folded-file: t
;; end:
a3515 1

@


1.19
log
@fixed for SUN4 compilation
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /hsrc/network/RCS/rmlib1.c,v 1.18 1993/01/08 12:33:23 bart Exp nickc $";
d3509 8
@


1.18
log
@sorted out pragmas and incremented version number
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib1.c,v 1.17 1992/10/26 17:45:54 bart Exp $";
d24 5
d38 1
@


1.17
log
@Fixed bug in AddSubset(), which was failing to clear out Uid tables in
the subset being added.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib1.c,v 1.15 1992/09/09 11:42:46 bart Exp $";
d42 4
d47 2
a48 3
#pragma -s1		/* disable stack checking */
#pragma -f0		/* and vector stack */
#pragma -g0		/* and do not put the names into the code */
d50 4
d58 1
a60 1

d71 1
d73 1
a73 1
#define	VersionNumber	"1.15"
@


1.16
log
@Updated version number for next release, and fixed a bug in
RmFreeProcessor() (walking down the wrong list of tasks)
@
text
@d2507 2
a2508 1
{ 
d2523 8
d2856 7
a2862 1
    
d2868 1
a2868 1
     set->Root = (struct RmSetStruct *) set;
a2871 8
  parent = (RmSet) set->DirNode.Parent;
  root   = (RmSet) set->Root;
  if ((parent eq (RmSet) NULL) || (root eq (RmSet) NULL))
   { RmErrno = (set->DirNode.Type eq Type_Network) ? RmE_NotNetwork :
               RmE_NotTaskforce;
     return((RmSet) NULL);
   }
   
d2887 1
d2898 2
a2899 1
  int          temp;
d2905 4
a2908 1
   return(RmApplyNetwork((RmNetwork) obj, &RmRemoveSetAux, root));
d2910 1
a2910 1
  temp = obj->Uid;
d2920 1
d2926 1
d3488 1
a3488 1
  if (Target eq (RmObject) NULL)
@


1.15
log
@Minor changes to keep C40 compiler happier. Also, the version number has
been updated because this version of RmLib supports the farm library
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib1.c,v 1.14 1992/08/14 17:21:19 bart Exp $";
d63 1
d65 1
a65 1
#define	VersionNumber	"1.14"
d150 7
a156 5
   { RmTask	x, y;
     for (x = Head_(RmTaskStruct, processor->MappedTasks); !EndOfList_(x); x = y)
      { y = (RmTask) x->MappedNode.Next;
        x->MappedTo = RmL_NoUid;
        Remove(&(x->MappedNode));
@


1.14
log
@Exception handlers are now Fork()'ed off rather than called by the
connection guardian, to avoid deadlocks. Hence there is a new exception
stack variable.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/rmlib1.c,v 1.12 1992/06/07 16:26:17 bart Exp $";
d62 1
d64 1
a64 1
#define	VersionNumber	"1.13"
d226 1
a226 1
  return(processor->ObjNode.Size);
d248 1
a248 1
  return(processor->ObjNode.Account);
d341 1
a341 1
   { char	*newdata = Malloc(2 * attrib->Size);
d637 1
a637 1
{ char	*buffer;
d789 1
a789 1
  return(task->ObjNode.Size);
d946 1
a946 1
     int rc;
d959 1
a959 1
     int	rc;
d1264 1
a1264 1
  return(network->DirNode.Nentries);
d1273 2
a1274 2
  if (network->NoSubnets eq 0) return(network->DirNode.Nentries);
  result = network->DirNode.Nentries - network->NoSubnets;
d1718 1
a1718 1
  return(taskforce->DirNode.Nentries);
d1727 2
a1728 2
  if (taskforce->NoSubsets eq 0) return(taskforce->DirNode.Nentries);
  result = taskforce->DirNode.Nentries - taskforce->NoSubsets;
d2013 1
a2013 1
{ int              tabno, tabindex;
d2019 2
a2020 2
  tabno    = (uid >> 8) & 0x0000FFFFL;
  tabindex = uid & 0x000000FFL;
d2063 1
a2063 1
   memcpy(tabs, root->Tables, root->NoTables * sizeof(RmUidTableEntry *));
d2167 1
a2167 1
   { int tabno = (uid >> 8) & 0x00FFFFL;
d2783 1
a2783 1
{ int   Uid;
d2887 1
a2887 1
  int           temp;
d3188 1
a3188 1
  char	*result;
@


1.13
log
@1) extended RmLookupProcessor to cope with variable root names
2) cleaned up the pointer manipulations in the communication code
@
text
@d95 1
@


1.12
log
@RmNext/Previous Processor/Task were too eager when it came to type
checking. Subnets and sub-taskforces were not catered for.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib1.c,v 1.11 1992/04/24 15:42:20 bart Exp $";
d61 1
d63 1
a63 1
#define	VersionNumber	"1.12"
d95 1
@


1.11
log
@minor patches to RmFindMatchingProcessor() and RmFindMatchingTask(),
to cope with re-used UIDs
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib1.c,v 1.10 1992/03/25 18:03:41 bart Exp $";
d1212 6
a1217 1
{ CheckProcessorFail(processor, (RmProcessor) NULL);
d1232 5
a1236 1
  CheckProcessorFail(processor, (RmProcessor) NULL);  
d1672 7
a1678 1
{ CheckTaskFail(task, (RmTask) NULL);
d1692 5
a1696 1
  CheckTaskFail(task, (RmTask) NULL);  
@


1.10
log
@Various changes including:
1) first attempt at C40 support
2) RmLib execute support (not yet fully tested)
3) faster bootstrap, taskforce load, and better mapping
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib1.c,v 1.9 1992/01/15 11:04:39 bart Exp $";
d1432 1
d1853 1
d3453 1
@


1.9
log
@Major update of networking sources, to incorporate the fault-tolerance
work as demonstrated at the IED meeting 10.1.92
@
text
@d18 1
a19 2
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/rmlib1.c,v 1.6 90/12/01 15:36:16 bart Exp $";

d22 3
a24 2
#include <stdarg.h>
#include <string.h>
a27 1
#include <pwd.h>
d29 4
a35 1
#include <posix.h>
d40 2
a41 1

d48 2
a49 2
{
	IOdebug("RmLib: stack overflow in %s at %x",p->Name,&p);	
d54 2
a56 6
*** A couple of forward declarations for this library.
**/
static RmLink	*RmGetLinkEntry(RmObject, int);
static void	 build_fd_string(char *buf, int channel);

/**
d60 1
d62 3
a64 6
#define	VersionNumber	"1.11"

/**
*** Library initialisation routine
**/

d86 1
d95 6
a100 2

/**
a102 4
***
*** BLV - this should be optimised with a single structure copy. That
*** will sort out everything except the dates, which should probably not
*** be set anyway.
d105 1
a105 1
{ RmProcessor	Result = (RmProcessor) Malloc(sizeof(RmProcessorStruct));
a106 1
  int		i;  
d108 1
a108 1
  if (Result eq (RmProcessor) NULL)
d110 19
a128 45
   
  Result->ObjNode.Name[0]	= '\0';	/* A new processor has no name */
  Result->ObjNode.Type		= Type_Processor;
  Result->ObjNode.Flags		= 0;
  Result->ObjNode.Matrix	= 0x010101c3;	/* darw:r:r:r */
  InitSemaphore(&(Result->ObjNode.Lock), 1);	/* As per InitNode() */
  Result->ObjNode.Key		= date + _cputime();
  Result->ObjNode.Parent	= Null(struct DirNode);
  Result->ObjNode.Dates.Creation =
  Result->ObjNode.Dates.Access   =
  Result->ObjNode.Dates.Modified = date;
  Result->ObjNode.Account	= RmM_NoOwner;
  Result->ObjNode.Size		= 0;	/* Processor state only */
  Result->Root			= (RmNetwork)NULL;
  Result->Uid			= RmL_NoUid;
  Result->Private		= 0;
  Result->Connections		= 0;
  for (i = 0; i < 4; i++)
   { Result->DefaultLinks[i].Flags		= 0;
     Result->DefaultLinks[i].Destination	= 0;
     Result->DefaultLinks[i].Target		= RmL_NoUid;
   }
  Result->OtherLinks		= Null(RmLink);
  Result->AttribSize		= 0;
  Result->AttribFree		= 0;
  Result->AttribData		= Null(char);
  Result->PAttribSize		= 0;
  Result->PAttribFree		= 0;
  Result->PAttribData		= 0;
  memset((void *) &(Result->RealCap),     0, sizeof(Capability));
  memset((void *) &(Result->NsCap),       0, sizeof(Capability));
  memset((void *) &(Result->ReadOnlyCap), 0, sizeof(Capability));
  Result->MemorySize		= 0L;	/* Irrelevant */
  Result->Type			= RmT_Default;
  Result->StructType		= RmL_New;
  Result->AllocationFlags	= 0;
  Result->Purpose		= RmP_Helios | RmP_User;
  Result->Control		= 0;
  Result->MappedTo		= 0;
  InitList(&(Result->MappedTasks));
  Result->Private2		= 0;
  Result->Errno			= 0;
  Result->SessionId		= -1;
  Result->ApplicationId		= -1;
  return(Result);
d134 2
a135 4
*** processor is currently in a network.
***
*** BLV - it should probably fail if any tasks have been mapped onto the
*** processor, or if any tasks are currently running on the processor.
d137 1
a137 1
int		RmFreeProcessor(RmProcessor Processor)
d139 1
a139 1
  CheckProcessor(Processor);
d141 2
a142 2
  if (Processor->ObjNode.Parent ne Null(struct DirNode)) 
   return(RmErrno = Processor->Errno = RmE_InUse);
d144 8
a151 3
  if (Processor->OtherLinks ne Null(RmLink))
   if (Free(Processor->OtherLinks) ne Err_Null)
    return(RmErrno = Processor->Errno = RmE_Corruption);
d153 3
a155 3
  if (Processor->AttribData ne Null(char))
   if (Free(Processor->AttribData) ne Err_Null)
    return(RmErrno = Processor->Errno = RmE_Corruption);
d157 7
a163 3
  if (Processor->PAttribData ne Null(char))
   if (Free(Processor->PAttribData) ne Err_Null)
    return(RmErrno = Processor->Errno = RmE_Corruption);
d167 3
a169 3
  if (Processor->Root ne (RmNetwork) NULL)
   unless(RmReleaseUid((RmObject)Processor))
    return(RmErrno = Processor->Errno = RmE_Corruption);
d171 3
a173 3
  Processor->ObjNode.Type	= 0;             
  if (Free(Processor) ne Err_Null)
   return(RmErrno = Processor->Errno = RmE_Corruption);
d178 1
a178 2
*** GetProcessorMemory should succeed irrespective of whether the processor
*** is New, Obtained, or Existing. However, the argument should be a processor.
d180 3
a182 5
unsigned long RmGetProcessorMemory(RmProcessor Processor)
{ 
  CheckProcessorFail(Processor, 0L);

  return(Processor->MemorySize);
d185 3
a187 12
/**
*** SetProcessorMemory can be used only on new processors. The first
*** argument must be a processor. Setting the memory size of an existing
*** or an obtained processor is silly.
**/
int		RmSetProcessorMemory(RmProcessor Processor, unsigned long size)
{ 
  CheckProcessor(Processor);

  if (Processor->StructType ne RmL_New)
   return(RmErrno = Processor->Errno = RmE_ReadOnly);
  Processor->MemorySize = size;
d191 3
a193 11
/**
*** This routine returns the name of the processor. If the argument is
*** invalid it returns NULL. Note that a new processor is initialised to
*** have an empty string as the name.
**/

const char *RmGetProcessorId(RmProcessor Processor)
{ 
  CheckProcessorFail(Processor, (const char *) NULL);

  return(Processor->ObjNode.Name);
d196 1
a196 6
/**
*** Setting a processor id is only legal if the processor is new. It is
*** useful when defining templates, to specify one particular processor.
*** It is also useful when producing binary resource maps.
**/
int		RmSetProcessorId(RmProcessor Processor, char *name)
d198 4
a201 1
  CheckProcessor(Processor);
a202 2
  if (Processor->StructType ne RmL_New)
   return(RmErrno = Processor->Errno = RmE_ReadOnly);
d204 2
a205 2
   return(RmErrno = Processor->Errno = RmE_TooLong);
  strcpy(Processor->ObjNode.Name, name);
d209 4
a212 8
/**
*** The processor purpose used to be encoded into the bottom nibble of the size
*** field, but now has its own byte.
*** The argument must be a processor.
**/
int		RmGetProcessorPurpose(RmProcessor Processor)
{ 
  CheckProcessorFail(Processor, -1);
d214 4
a217 1
  return(Processor->Purpose);
d220 4
a223 8
/**
*** Setting a processor purpose is always legal if the processor is new.
*** If the processor already exists then it is legal only to set the
*** purpose to RmP_Helios or RmP_Native, depending on the current purpose.
**/
int		RmSetProcessorPurpose(RmProcessor Processor, int Purpose)
{
  CheckProcessor(Processor);
d225 4
a228 16
  if ((Processor->StructType eq RmL_New) ||
      (Processor->StructType eq RmL_Existing))
   { Processor->Purpose = Purpose;	/* BLV, validate */
     return(RmE_Success);
   }
  elif (Processor->StructType eq RmL_Obtained)
   { if ((Purpose ne RmP_Native) && (Purpose ne RmP_Helios))
      return(RmErrno = Processor->Errno = RmE_BadArgument);
     unless((Processor->Purpose eq RmP_Helios) ||
            (Processor->Purpose eq RmP_Native))
      return(RmErrno = Processor->Errno = RmE_ReadOnly);
     Processor->Purpose = Purpose;
     return(RmE_Success);
   }
  else 
   return(RmErrno = Processor->Errno = RmE_ReadOnly);
d231 3
a233 8
/**
*** Getting a processor state is always allowed.
**/
int		RmGetProcessorState(RmProcessor Processor)
{ 
  CheckProcessorFail(Processor, -1);

  return(Processor->ObjNode.Size);
d236 3
a238 4
int		RmSetProcessorState(RmProcessor Processor, int state)
{
  CheckProcessor(Processor);
  Processor->ObjNode.Size = state;
d242 4
d247 4
a250 11
/**
*** Getting a processor type is easy. The type is T800, T425, etc.,
*** and has its own field in the structure.
BLV Important, having a simple integer for the type is not good
BLV enough. Processor types are complex entities.
**/
int		RmGetProcessorType(RmProcessor Processor)
{ 
  CheckProcessorFail(Processor, -1);

  return(Processor->Type);
d253 3
a255 13
/**
*** Setting a processor type is legal only if it is a new processor,
*** i.e. when producing a template or a resource map.
**/
int		RmSetProcessorType(RmProcessor Processor, int type)
{ 
  CheckProcessor(Processor);

  if (Processor->StructType ne RmL_New)
   return(RmErrno = Processor->Errno = RmE_ReadOnly);
  if ((type < RmT_Unknown) || (type >= RmT_Known))
   return(RmErrno = Processor->Errno = RmE_BadArgument);
  Processor->Type = type;
d259 4
a262 7
/**
*** Getting a processor owner is always valid. When creating a new processor
*** the owner is set to system.
**/
int		RmGetProcessorOwner(RmProcessor Processor)
{ 
  CheckProcessorFail(Processor, -1);
d264 3
a266 1
  return(Processor->ObjNode.Account);
d269 4
a272 22
/**
*** RmWhoAmI() and RmWhoIs(). These are used to examine the user id's
*** returned by the previous routine, and map onto posix calls -
*** eventually.
**/
int		RmWhoAmI(void)
{ Environ	*env		= getenviron();
  Object	*session;
  int		i;
  char		username[NameMax];
  char		*temp;
  struct passwd	*passwd;
  
	/* First, get hold of the environment and the Session object */    
  if (env eq Null(Environ)) return(-1);
  if (env->Objv eq Null(Object *)) return(-1);
  for (i = 0; i <= OV_Session; i++)
   if (env->Objv[i] eq Null(Object))
    return(0);
 
  session = env->Objv[OV_Session];
  if (session eq (Object *) MinInt) return(-1);
d274 4
a277 4
	/* Get the last bit of the session name, which should be the username */
  temp = session->Name + strlen(session->Name);
  for ( ; *temp ne '/'; temp--);
  strcpy(username, ++temp);
d279 3
a281 10
	/* Strip out .12 at the end, if present */
  for (temp = username + strlen(username); temp > username; temp--)
   if (*temp eq '.')
    { *temp = '\0'; break; }

  passwd =  getpwnam(username);
  if (passwd eq Null(struct passwd))
   return(0);

  return(passwd->pw_uid);
d284 3
a286 11
const char	*RmWhoIs(int uid)
{ struct passwd	*passwd;

  if (uid eq RmO_SystemPool)	return("free pool");
  if (uid eq RmO_System)	return("system");
  if (uid eq RmO_Cleaners)	return("cleaners");
  if (uid eq RmO_Graveyard)	return("graveyard");

  passwd = getpwuid(uid);
  if (passwd eq Null(struct passwd))
   return("<unknown>");
d288 1
a288 1
   return(passwd->pw_name);
d291 8
a298 1
/**
d315 1
a315 1
int	RmAddObjectAttribute(RmObject Obj, char *attr, bool private)
d317 1
a317 1
  RmAttributes	*Attrib;
d323 1
a323 1
   Attrib = (RmAttributes *) &(Obj->PAttribSize);
d325 1
a325 1
   Attrib = (RmAttributes *) &(Obj->AttribSize);
d327 3
a329 3
  if (Attrib->Size eq 0)
   { Attrib->Data	= (char *) Malloc(32);
     if (Attrib->Data eq Null(BYTE))
d331 2
a332 2
     Attrib->Size	= 32; 
     Attrib->Free = 0;
d336 2
a337 2
  while ((Attrib->Size - Attrib->Free) < (length + 2))
   { char	*newdata = Malloc(2 * Attrib->Size);
d341 5
a345 5
     if (Attrib->Free > 0)
      memcpy((void *) newdata, Attrib->Data, Attrib->Free); 
     Attrib->Size = 2 * Attrib->Size;
     if (Free(Attrib->Data) ne Err_Null) return(RmE_Corruption);
     Attrib->Data = newdata;
d349 4
a352 4
  { char	*datavec = Attrib->Data;
    datavec[Attrib->Free] = length + 2;
    strcpy(&(datavec[Attrib->Free+1]), attr);
    Attrib->Free += (length + 2);
d358 1
a358 1
int		RmAddProcessorAttribute(RmProcessor Processor, char *attr)
d361 1
a361 1
  CheckProcessor(Processor);
d363 2
a364 6
  if (Processor->StructType ne RmL_New)
   return(RmErrno = Processor->Errno = RmE_ReadOnly);
     
  if ((x = RmAddObjectAttribute((RmObject) Processor, attr, FALSE))
       ne RmE_Success)
   RmErrno = Processor->Errno = x;
d368 1
a368 1
int		RmAddTaskAttribute(RmTask Task, char *attr)
d371 1
a371 1
  CheckTask(Task);
d373 2
a374 3
  if ((x = RmAddObjectAttribute((RmObject) Task, attr, FALSE))
      ne RmE_Success)
   RmErrno = Task->Errno = x;
d382 1
a382 1
static int	RmFindObjectAttribute(RmAttributes *Attrib, char *attr)
d384 1
a384 1
  char	*datavec = Attrib->Data;
d386 1
a386 1
  while (index < Attrib->Free)
d393 1
d398 2
a399 2
int	RmRemoveObjectAttribute(RmObject Object, char *attr, bool private)
{ RmAttributes *Attrib;
d407 1
a407 1
   Attrib = (RmAttributes *) &(Object->PAttribSize);
d409 1
a409 1
   Attrib = (RmAttributes *) &(Object->AttribSize);
d411 1
a411 1
  index = RmFindObjectAttribute(Attrib, attr);
d414 1
a414 1
  datavec = Attrib->Data;
d416 1
a416 1
  if (index + length < Attrib->Free)
d418 6
a423 6
          Attrib->Free - (index + length));
  Attrib->Free -= length;
  if (Attrib->Free eq 0)
   { char 	*temp = Attrib->Data;
     Attrib->Size = 0;
     Attrib->Data = Null(char);
d430 1
a430 1
int		RmRemoveProcessorAttribute(RmProcessor Processor, char *attr)
d433 1
a433 1
  CheckProcessor(Processor);
d435 2
a436 5
  if (Processor->StructType ne RmL_New)
   return(RmErrno = Processor->Errno = RmE_ReadOnly);
  if ((x = RmRemoveObjectAttribute((RmObject) Processor, attr, FALSE))
      ne RmE_Success)
   RmErrno = Processor->Errno = x;
d440 1
a440 1
int		RmRemoveTaskAttribute(RmTask Task, char *attr)
d443 1
a443 1
  CheckTask(Task);
d445 2
a446 3
  if ((x = RmRemoveObjectAttribute((RmObject) Task, attr, FALSE))
      ne RmE_Success)
   RmErrno = Task->Errno = x;
d454 2
a455 2
char	*RmGetObjectAttribute(RmObject Obj, char *attr, bool private)
{ RmAttributes	*Attrib;
d461 1
a461 1
   Attrib = (RmAttributes *) &(Obj->PAttribSize);
d463 3
a465 3
   Attrib = (RmAttributes *) &(Obj->AttribSize);  
  datavec = Attrib->Data;
  while (index < Attrib->Free)
d476 1
a476 1
const char	*RmGetProcessorAttribute(RmProcessor processor, char *text)
d481 1
a481 1
  return((const char *) RmGetObjectAttribute((RmObject) processor, text, FALSE));
d484 1
a484 1
const char	*RmGetTaskAttribute(RmTask task, char *text)
d492 2
a494 6
/**
*** Checking whether an attribute is valid or not is easy.
**/
static int	RmIsAnObjectAttribute(RmObject Obj, char *attr, bool private)
{ RmAttributes 	*Attrib;

d498 1
a498 1
   Attrib = (RmAttributes *) &(Obj->PAttribSize);
d500 2
a501 2
   Attrib = (RmAttributes *) &(Obj->AttribSize);
  if (RmFindObjectAttribute(Attrib, attr) ne -1)
d507 1
a507 1
int		RmTestProcessorAttribute(RmProcessor Processor, char *attr)
d510 1
a510 1
  CheckProcessor(Processor);
d512 2
a513 3
  if ((x = RmIsAnObjectAttribute((RmObject) Processor, attr, FALSE))
      ne RmE_Success)
   RmErrno = Processor->Errno = x;
d517 1
a517 1
int		RmTestTaskAttribute(RmTask Task, char *attr)
d520 1
a520 1
  CheckTask(Task);
d522 2
a523 3
  if ((x = RmIsAnObjectAttribute((RmObject) Task, attr, FALSE))
      ne RmE_Success)
   RmErrno = Task->Errno = x;
d531 5
a535 5
static int RmCountObjectAttributes(RmObject Obj, bool private)
{ int	result = 0;
  RmAttributes	*Attrib;
  int	index;
  char	*datavec;
d538 1
a538 1
   Attrib = (RmAttributes *) &(Obj->PAttribSize);
d540 1
a540 1
   Attrib = (RmAttributes *) &(Obj->AttribSize);
d543 2
a544 2
  datavec = Attrib->Data;
  while (index < Attrib->Free)
d551 3
a553 5
int		RmCountProcessorAttributes(RmProcessor Processor)
{ 
  CheckProcessorFail(Processor, -1);

  return(RmCountObjectAttributes((RmObject) Processor, FALSE));
d556 3
a558 5
int		RmCountTaskAttributes(RmTask Task)
{ 
  CheckTaskFail(Task, -1);

  return(RmCountObjectAttributes((RmObject) Task, FALSE));
d566 2
a567 2
static int RmListObjectAttributes(RmObject Obj, char **table, bool private)
{ RmAttributes	*Attrib;
d574 1
a574 1
   Attrib = (RmAttributes *) &(Obj->PAttribSize);
d576 1
a576 1
   Attrib = (RmAttributes *) &(Obj->AttribSize);
d579 2
a580 2
  datavec = Attrib->Data;
  while (index < Attrib->Free)
d587 1
a587 1
int		RmListProcessorAttributes(RmProcessor Processor, char **table)
d590 1
a590 1
  CheckProcessor(Processor);
d592 2
a593 3
  if ((x = RmListObjectAttributes((RmObject) Processor, table, FALSE))
      ne RmE_Success)
    RmErrno = Processor->Errno = x;
d597 1
a597 1
int		RmListTaskAttributes(RmTask Task, char **table)
d600 1
a600 1
  CheckTask(Task);
d602 2
a603 3
  if ((x = RmListObjectAttributes((RmObject) Task, table, FALSE))
      ne RmE_Success)
   RmErrno = Task->Errno = x;
d609 2
a610 7
*** result is an empty, indicating that the default nucleus should be used.
*** Setting the nucleus is legal only for a new processor, and only makes
*** sense when generating resource maps. I suppose it might be valid for
*** a user to reboot a processor with a different nucleus, but that is
*** more trouble than it is worth. Note that setting a nucleus involves
*** allocating space for the string, which is extended to be a multiple
*** of four bytes.
d612 1
a612 1
const char	*RmGetProcessorNucleus(RmProcessor Processor)
d615 1
a615 1
  CheckProcessorFail(Processor, (const char *) NULL);
d617 1
a617 1
  result = RmGetObjectAttribute((RmObject) Processor, "nucleus", TRUE);
d632 1
a632 1
int		RmSetProcessorNucleus(RmProcessor Processor, char *nucleus)
d638 1
a638 1
  CheckProcessor(Processor);      
a639 3
  if (Processor->StructType ne RmL_New)
   return(RmErrno = Processor->Errno = RmE_ReadOnly);

d650 1
a650 1
  temp = RmGetObjectAttribute((RmObject) Processor, "nucleus", TRUE);
d653 2
a654 3
     if ((rc = RmRemoveObjectAttribute((RmObject) Processor, temp, TRUE))
         ne RmE_Success)
      return(RmErrno = Processor->Errno = RmE_Corruption);
d658 1
a658 1
   { rc = RmAddObjectAttribute((RmObject) Processor, buffer, TRUE);
d661 1
a661 2
      RmErrno = Processor->Errno = rc;
     return(rc);
d666 2
a668 72
*** These routines are used for application-specific purposes
**/
int	RmSetProcessorPrivate(RmProcessor processor, int x)
{ 
  CheckProcessor(processor);

  processor->Private = x;
  return(RmE_Success);
}

int	RmSetProcessorPrivate2(RmProcessor processor, int x)
{ 
  CheckProcessor(processor);

  processor->Private2 = x;
  return(RmE_Success);
}

int	RmGetProcessorPrivate(RmProcessor processor)
{
  CheckProcessorFail(processor, -1);	

  return(processor->Private);
}

int	RmGetProcessorPrivate2(RmProcessor processor)
{ 
  CheckProcessorFail(processor, -1);

  return(processor->Private2);
}

int	RmGetProcessorError(RmProcessor Processor)
{
  CheckProcessor(Processor);	

  return(Processor->Errno);
}

int	RmClearProcessorError(RmProcessor Processor)
{
  CheckProcessor(Processor);	

  return(Processor->Errno = RmE_Success);
}

RmUid	RmGetProcessorUid(RmProcessor processor)
{
  CheckProcessorFail(processor, 0);	

  return(processor->Uid);
}

Capability	*RmGetProcessorCapability(RmProcessor Processor, bool real)
{ if (real)
   return(&(Processor->RealCap));
  else
   return(&(Processor->NsCap));
}

int		RmGetProcessorControl(RmProcessor Processor)
{ CheckProcessorFail(Processor, -1);
  if ((Processor->StructType ne RmL_Obtained) &&
      (Processor->StructType ne RmL_Existing))
   return(RmErrno = RmE_BadArgument, -1);
  return(Processor->Control);
}

/**
*** And that takes care of the basic manipulations of the RmProcessor
*** structure. Next, RmTask.
***
d673 2
a674 2
RmTask		RmNewTask(void)
{ RmTask Result = (RmTask) Malloc(sizeof(RmTaskStruct));
a675 1
  int	 i;
d677 1
a677 1
  if (Result eq (RmTask) NULL)
d679 15
a693 47
      
  Result->ObjNode.Name[0]	= '\0';	/* A new task has no name */
  Result->ObjNode.Type		= Type_Task;
  Result->ObjNode.Flags		= 0;
  Result->ObjNode.Matrix	= 0x010101c3;	/* darw:r:r:r */
  InitSemaphore(&(Result->ObjNode.Lock), 1);	/* As per InitNode() */
  Result->ObjNode.Key		= date + _cputime();
  Result->ObjNode.Parent	= Null(struct DirNode);
  Result->ObjNode.Dates.Creation =
  Result->ObjNode.Dates.Access   =
  Result->ObjNode.Dates.Modified = date;
  Result->ObjNode.Account	= 0;
  Result->ObjNode.Size		= 0;
  Result->Root			= (RmTaskforce)NULL;
  Result->Uid			= RmL_NoUid;
  Result->Private		= 0;
  Result->Connections		= 0;
  for (i = 0; i < 4; i++)
   { Result->DefaultChannels[i].Flags		= 
     Result->DefaultChannels[i].Destination	= 0;
     /* Result->DefaultLinks[i].Spare1		= 0;*/
     /* Result->DefaultLinks[i].Spare2		= 0;*/
     Result->DefaultChannels[i].Target		= RmL_NoUid;
   }
  Result->OtherChannels		= Null(RmChannel);
  Result->AttribSize		= 0;
  Result->AttribFree		= 0;
  Result->AttribData		= Null(char);
  Result->PAttribSize		= 0;
  Result->PAttribFree		= 0;
  Result->PAttribData		= Null(char);
  Result->MemorySize		= 0L;
  Result->Type			= RmT_Default;
  Result->StructType		= RmL_New;
  Result->IsNative		= FALSE;
  Result->ArgIndex		= Null(int);
  Result->MaxArgIndex		= 0;
  Result->NextArgIndex		= 1;
  Result->ArgStrings		= Null(char);
  Result->MaxArgStrings		= 0;
  Result->NextArgStrings	= 0;
  Result->MappedTo		= RmL_NoUid;
  memset((void *) &(Result->MappedNode), 0, sizeof(Node));
  Result->Private2		= 0;
  Result->Errno			= 0;
  Result->ReturnCode		= -1;
  return(Result);
a697 1
BLV there should be a check to see if the task is currently executing.
d699 1
a699 1
int		RmFreeTask(RmTask Task)
d701 1
a701 1
  CheckTask(Task);	
d703 2
a704 2
  if (Task->ObjNode.Parent ne Null(struct DirNode))
   return(RmErrno = Task->Errno = RmE_InUse);
d706 4
a709 3
  if (Task->OtherChannels ne Null(RmChannel))
   if (Free(Task->OtherChannels) ne Err_Null)
    return(RmErrno = Task->Errno = RmE_Corruption);
d711 3
a713 3
  if (Task->AttribData ne Null(char))
   if (Free(Task->AttribData) ne Err_Null)
    return(RmErrno = Task->Errno = RmE_Corruption);
d715 3
a717 3
  if (Task->PAttribData ne Null(char))
   if (Free(Task->PAttribData) ne Err_Null)
    return(RmErrno = Task->Errno = RmE_Corruption);
d719 3
a721 3
  if (Task->ArgIndex ne Null(int))
   if (Free(Task->ArgIndex) ne Err_Null)
    return(RmErrno = Task->Errno = RmE_Corruption);
d723 7
a729 3
  if (Task->ArgStrings ne Null(char))
   if (Free(Task->ArgStrings) ne Err_Null)
    return(RmErrno = Task->Errno = RmE_Corruption);
d731 5
a735 5
	/* This case is true iff the Task is being freed as a result of */
	/* an RmFreeTaskforce all. */
  if (Task->Root ne (RmTaskforce) NULL)
   unless(RmReleaseUid((RmObject)Task))
    return(RmErrno = Task->Errno = RmE_Corruption);
d737 2
a738 2
  Task->ObjNode.Type	= 0;
  if (Free(Task) ne Err_Null)
d743 3
a745 8
/**
*** This is boring, look at the code for processors above.
**/	
unsigned long RmGetTaskMemory(RmTask Task)
{
  CheckTaskFail(Task, 0L);	

  return(Task->MemorySize);
d748 3
a750 7
int		RmSetTaskMemory(RmTask Task, unsigned long size)
{
  CheckTask(Task);

  if (Task->StructType ne RmL_New)
   return(RmErrno = Task->Errno = RmE_ReadOnly);
  Task->MemorySize = size; 
d754 3
a756 5
const char	*RmGetTaskId(RmTask Task)
{
  CheckTaskFail(Task, (const char *) NULL);

  return(Task->ObjNode.Name);
d759 5
a763 6
int		RmSetTaskId(RmTask Task, char *name)
{
  CheckTask(Task);

  if (Task->StructType ne RmL_New)
   return(RmErrno = Task->Errno = RmE_ReadOnly);
d765 2
a766 2
   return(RmErrno = Task->Errno = RmE_TooLong);
  strcpy(Task->ObjNode.Name, name);
d770 3
a772 5
int		RmGetTaskType(RmTask Task)
{
  CheckTaskFail(Task, -1); 

  return(Task->Type);
d775 2
a776 6
int		RmSetTaskType(RmTask Task, int type)
{
  CheckTask(Task);

  if (Task->StructType ne RmL_New)
   return(RmErrno = Task->Errno = RmE_ReadOnly);
d778 2
a779 2
   return(RmErrno = Task->Errno = RmE_BadArgument);
  Task->Type = type;
d783 2
a784 6
/**
*** Task state indicates whether it is running, finished, or dead
**/
int		 RmGetTaskState(RmTask task)
{ 
  CheckTaskFail(task, -1);
d788 1
a788 1
int		RmSetTaskState(RmTask task, int state)
d794 1
a794 1
const char	*RmGetTaskCode(RmTask Task)
d797 2
a798 3
  CheckTaskFail(Task, (const char *) NULL);

  result = RmGetObjectAttribute((RmObject) Task, "code", TRUE);
d805 1
a805 1
int		RmSetTaskCode(RmTask Task, char *file)
d810 1
a810 1
  CheckTask(Task);     
a811 2
  if (Task->StructType ne RmL_New) 
   return(RmErrno = Task->Errno = RmE_ReadOnly);
d813 1
a813 1
   return(RmErrno = Task->Errno = RmE_BadArgument);
d818 1
a818 1
   return(RmErrno = Task->Errno = RmE_NoMemory);
d821 1
a821 1
  { char *temp = RmGetObjectAttribute((RmObject) Task, "code", TRUE);
d824 1
a824 1
        rc = RmRemoveObjectAttribute((RmObject) Task, temp, TRUE);
d826 1
a826 1
         return(RmErrno = Task->Errno = rc);
d830 1
a830 1
  rc = RmAddObjectAttribute((RmObject) Task, buffer, TRUE);
d835 1
a835 1
   RmErrno = Task->Errno = rc;
d840 2
a841 4
int	RmSetTaskPrivate(RmTask task, int x)
{
  CheckTask(task);
  
d846 2
a847 4
int	RmSetTaskPrivate2(RmTask task, int x)
{
  CheckTask(task); 

d852 2
a853 4
int	RmGetTaskPrivate(RmTask task)
{
  CheckTaskFail(task, -1);

d857 2
a858 4
int	RmGetTaskPrivate2(RmTask task)
{
  CheckTaskFail(task, -1); 

d862 2
a863 4
int	RmGetTaskError(RmTask task)
{ 
  CheckTask(task);

d867 2
a868 4
int	RmClearTaskError(RmTask task)
{
  CheckTask(task);

d872 2
a873 4
RmUid	RmGetTaskUid(RmTask task)
{
  CheckTaskFail(task, 0);

d878 26
d912 1
a912 1
static int	RmSetTaskArgumentAux1(RmTask task, int number, char *str);
d914 1
a914 1
int		RmAddTaskArgument(RmTask Task, int number, char *str)
d916 1
a916 1
  CheckTask(Task);
d918 2
a919 4
  if (Task->StructType ne RmL_New)
   return(RmErrno = Task->Errno = RmE_ReadOnly);
  if ((number < 1) || (number > Task->NextArgIndex) || (str eq Null(char)))
   return(RmErrno = Task->Errno = RmE_BadArgument);
d923 2
a924 2
  if (number ne Task->NextArgIndex)
   return(RmSetTaskArgumentAux1(Task, number, str));
d928 9
a936 9
  if (Task->ArgIndex eq Null(int))
   { Task->ArgIndex	= (int *) Malloc(8 * sizeof(int));
     if (Task->ArgIndex eq Null(int))
      return(RmErrno = Task->Errno = RmE_NoMemory);
     Task->MaxArgIndex	= 8;
     Task->ArgStrings	= (char *) Malloc(64);
     if (Task->ArgStrings eq Null(char))
      return(RmErrno = Task->Errno = RmE_NoMemory);
     Task->MaxArgStrings= 64;
d940 2
a941 2
  if (number > Task->MaxArgIndex)
   { int *temp = (int *) Malloc(2 * Task->MaxArgIndex * sizeof(int));
d944 5
a948 5
      return(RmErrno = Task->Errno = RmE_NoMemory);
     memcpy(temp, Task->ArgIndex, Task->MaxArgIndex * sizeof(int));
     rc = Free(Task->ArgIndex);
     Task->ArgIndex	= temp;
     Task->MaxArgIndex	= 2 * Task->MaxArgIndex;
d950 1
a950 1
      return(RmErrno = Task->Errno = RmE_Corruption);
d953 2
a954 2
  while ((Task->NextArgStrings + strlen(str) + 1) > Task->MaxArgStrings)
   { char	*temp = (char *) Malloc(2 * Task->MaxArgStrings);
d957 6
a962 6
      return(RmErrno = Task->Errno = RmE_NoMemory);
     if (Task->NextArgStrings > 0)
      memcpy(temp, Task->ArgStrings, Task->NextArgStrings);
     rc = Free(Task->ArgStrings);
     Task->ArgStrings		= temp;
     Task->MaxArgStrings	= 2 * Task->MaxArgStrings;
d964 1
a964 1
      return(RmErrno = Task->Errno = RmE_Corruption);
d968 3
a970 3
  Task->ArgIndex[number - 1] 	 = Task->NextArgStrings;
  Task->NextArgIndex		+= 1;
  { char *temp = &(Task->ArgStrings[Task->NextArgStrings]);
d972 1
a972 1
    Task->NextArgStrings	+= (strlen(temp) + 1);
d977 1
a977 1
static int	RmSetTaskArgumentAux1(RmTask Task, int number, char *str)
d980 2
a981 2
  char	*old_buffer		= Task->ArgStrings;
  int	*arg_index		= Task->ArgIndex;
d983 1
a983 1
  int	buffer_size		= Task->MaxArgStrings;
d988 1
a988 2
	/* BLV should really subtract the size of the current entry.	*/
  while ((Task->NextArgStrings + strlen(str) + 1)  > buffer_size)
d992 1
a992 1
   return(RmErrno = Task->Errno = RmE_NoMemory);
d1010 1
a1010 1
  for (i = number + 1; i < Task->NextArgIndex; i++)
d1018 1
a1018 1
	/* Free the old buffer, and update the fields in the Task structure */
d1020 3
a1022 3
  Task->ArgStrings	= new_buffer;
  Task->MaxArgStrings	= buffer_size;
  Task->NextArgStrings	= new_index;
d1026 1
a1026 1
const char	*RmGetTaskArgument(RmTask task, int argc)
d1036 2
a1037 4
int		RmCountTaskArguments(RmTask task)
{
  CheckTaskFail(task, -1);

d1044 3
a1046 4
*** supposed to run on. Under Helios this information should be stored in
*** the first twelve bytes.
BLV
BLV Implement properly.
d1048 1
a1048 1
int		RmGetProgramType(char *file)
d1052 3
a1054 2

/**
d1065 1
a1065 1
{ RmNetwork	Result = (RmNetwork) Malloc(sizeof(RmNetworkStruct));
d1068 1
a1068 1
  if (Result eq (RmNetwork) NULL)
d1070 14
a1083 22
  Result->DirNode.Name[0]	= '\0';		/* a new network has no name */
  Result->DirNode.Type		= Type_Network; 
  Result->DirNode.Flags		= 0;
  Result->DirNode.Matrix	= 0x211109c7;  /* darwv:rx:ry:rz */
  InitSemaphore(&(Result->DirNode.Lock), 1);
  Result->DirNode.Key		= date + _cputime();
  Result->DirNode.Parent	= Null(struct DirNode);
  Result->DirNode.Dates.Creation =
  Result->DirNode.Dates.Access	 =
  Result->DirNode.Dates.Modified = date;
  Result->DirNode.Account	= 0;
  Result->DirNode.Nentries	= 0;
  InitList(&(Result->DirNode.Entries));
  Result->Root			= (RmSet) Result;
  Result->NoTables		= 0;
  Result->Tables		= Null(RmUidTableEntry *);
  Result->StructType		= RmL_New;
  Result->NoSubnets		= 0;
  InitList(&(Result->Hardware));
  Result->Private2		= 0;
  Result->Errno			= 0;
  return(Result);
d1088 2
a1089 2
*** It also means free'ing the reset and configuration facilities, and the
*** Uid tables if this is the root.
d1091 1
a1091 1
static int FreeNetwork_aux(RmProcessor Processor, ...)
d1093 4
a1096 5
  (void) Remove((Node *) Processor);
  Processor->ObjNode.Parent = Null(struct DirNode);

  if (RmIsNetwork(Processor))
   return(RmFreeNetwork((RmNetwork) Processor));
d1098 1
a1098 1
   return(RmFreeProcessor(Processor));
d1109 1
a1109 1
int		RmFreeNetwork(RmNetwork Network)
d1112 1
a1112 1
  CheckNetwork(Network); 
d1114 2
a1115 2
  if (Network->DirNode.Parent ne Null(struct DirNode))
   return(RmErrno = Network->Errno = RmE_InUse);
d1117 2
a1118 2
  if (Network->DirNode.Nentries ne 0)
   { result = RmApplyNetwork(Network, &FreeNetwork_aux);  
d1120 1
a1120 1
      return(RmErrno = Network->Errno = result);
d1123 1
a1123 1
  if ((result = RmApplyHardwareFacilities(Network, &FreeHardware))
d1125 1
a1125 1
   return(RmErrno = Network->Errno = result);
d1127 6
a1132 6
  if (Network->NoTables > 0)
   { for (i = 0; i < Network->NoTables; i++)
      if (Free(Network->Tables[i]) ne Err_Null)
       return(RmErrno = Network->Errno = RmE_Corruption);
     if (Free(Network->Tables) ne Err_Null)
       return(RmErrno = Network->Errno = RmE_Corruption);
d1135 2
a1136 2
  Network->DirNode.Type = 0;
  if (Free(Network) ne Err_Null)
d1142 3
a1144 9
/**
*** Like processors, networks can have names. The same restrictions apply as
*** for processors.
**/
const char	*RmGetNetworkId(RmNetwork Network)
{
  CheckNetworkFail(Network, (const char *) NULL);

  return(Network->DirNode.Name);
d1147 4
a1150 6
int		RmSetNetworkId(RmNetwork Network, char *name)
{
  CheckNetwork(Network);	

  if (Network->StructType ne RmL_New)
   return(RmErrno = Network->Errno = RmE_ReadOnly);
d1152 2
a1153 2
   return(RmErrno = Network->Errno = RmE_TooLong);
  strcpy(Network->DirNode.Name, name);
d1157 2
a1158 4
int	RmSetNetworkPrivate(RmNetwork network, int x)
{
  CheckNetwork(network);

d1163 2
a1164 4
int	RmSetNetworkPrivate2(RmNetwork network, int x)
{
  CheckNetwork(network);	

d1169 2
a1170 4
int	RmGetNetworkPrivate(RmNetwork network)
{
  CheckNetworkFail(network, -1);	

d1174 2
a1175 4
int	RmGetNetworkPrivate2(RmNetwork network)
{
  CheckNetworkFail(network, -1);	

d1179 1
a1179 1
int	RmGetNetworkError(RmNetwork network)
a1180 1

d1184 1
a1184 1
int		RmClearNetworkError(RmNetwork network)
a1185 1

d1193 3
a1195 4
RmProcessor	RmFirstProcessor(RmNetwork Network)
{
  CheckNetworkFail(Network, (RmProcessor) NULL);
  if (Network->DirNode.Nentries < 1)
d1197 1
a1197 1
  return((RmProcessor) Network->DirNode.Entries.Head);
d1200 4
a1203 6
RmProcessor	RmLastProcessor(RmNetwork Network)
{
  CheckNetworkFail(Network, (RmProcessor) NULL); 

  if (Network->DirNode.Nentries < 1) return((RmProcessor) NULL);
  return((RmProcessor) Network->DirNode.Entries.Tail);
d1211 2
a1212 3
RmProcessor	RmNextProcessor(RmProcessor Processor)
{
  CheckProcessorFail(Processor, (RmProcessor) NULL);
d1214 4
a1217 4
  if (Processor->ObjNode.Parent eq Null(struct DirNode))
   return(RmErrno = Processor->Errno = RmE_NotNetwork, (RmProcessor) NULL);
  Processor = (RmProcessor) Processor->ObjNode.Node.Next;
  if (Processor->ObjNode.Node.Next eq Null(struct Node))
d1220 1
a1220 1
   return(Processor);
d1223 3
a1225 3
RmProcessor	RmPreviousProcessor(RmProcessor Processor)
{ RmProcessor	Result;
  RmNetwork	Parent;
d1227 1
a1227 1
  CheckProcessorFail(Processor, (RmProcessor) NULL);  
d1229 5
a1233 5
  Parent = (RmNetwork) Processor->ObjNode.Parent;
  if (Parent eq (RmNetwork) NULL)
   return(RmErrno = Processor->Errno = RmE_NotNetwork, (RmProcessor) NULL); 
  Result = (RmProcessor) Processor->ObjNode.Node.Prev;
  if (Result eq (RmProcessor) &(Parent->DirNode.Entries.Head))
d1235 1
a1235 1
  return(Result);
d1244 3
a1246 5
bool		RmIsNetworkEmpty(RmNetwork Network)
{
  CheckNetworkFail(Network, TRUE);

  return(Network->DirNode.Nentries eq 0);
d1249 3
a1251 5
int		RmSizeofNetwork(RmNetwork Network)
{
  CheckNetworkFail(Network, -1);

  return(Network->DirNode.Nentries);
d1254 1
a1254 1
int		RmCountProcessors(RmNetwork Network)
d1258 1
a1258 1
  CheckNetworkFail(Network, -1);  
d1260 3
a1262 3
  if (Network->NoSubnets eq 0) return(Network->DirNode.Nentries);
  result = Network->DirNode.Nentries - Network->NoSubnets;
  for (current = RmFirstProcessor(Network);
d1276 2
a1277 3
RmNetwork	RmParentNetwork(RmProcessor Processor)
{
  if (Processor eq (RmProcessor) NULL)
d1279 4
a1282 4
  if (Processor->Root eq (RmNetwork) NULL) 
   return(RmErrno = Processor->Errno = RmE_NotNetwork, (RmNetwork) NULL);
  if (Processor->Root eq (RmNetwork) Processor) return((RmNetwork) NULL);
  return((RmNetwork) Processor->ObjNode.Parent);
d1285 1
a1285 1
int RmApplyNetwork(RmNetwork Network, int (*fn)(RmProcessor, ...), ...)
d1289 1
a1289 1
  RmProcessor	Processor, Next;
d1297 1
a1297 1
  CheckNetworkFail(Network, -1);  
d1299 6
a1304 6
  Processor	= (RmProcessor) Network->DirNode.Entries.Head;
  Next		= (RmProcessor) Processor->ObjNode.Node.Next;
  while (Next ne (RmProcessor) NULL)
   { result	+= (*fn)(Processor, arg1, arg2, arg3);
     Processor	 = Next;
     Next	 = (RmProcessor) Processor->ObjNode.Node.Next;
d1309 1
a1309 1
int RmSearchNetwork(RmNetwork Network, int (*fn)(RmProcessor, ...), ...)
d1313 1
a1313 1
  RmProcessor	Processor, Next;
d1321 1
a1321 1
  CheckNetworkFail(Network, -1);  
d1323 6
a1328 6
  Processor	= (RmProcessor) Network->DirNode.Entries.Head;
  Next		= (RmProcessor) Processor->ObjNode.Node.Next;
  while ((Next ne (RmProcessor) NULL) && (result eq 0))
   { result	+= (*fn)(Processor, arg1, arg2, arg3);
     Processor	 = Next;
     Next	 = (RmProcessor) Processor->ObjNode.Node.Next;
d1334 1
a1334 1
int RmApplyProcessors(RmNetwork Network, int (*fn)(RmProcessor, ...), ...)
d1338 1
a1338 1
  RmProcessor	Processor, Next;
d1346 1
a1346 1
  CheckNetworkFail(Network, -1);  
d1348 5
a1352 5
  Processor	= (RmProcessor) Network->DirNode.Entries.Head;
  Next		= (RmProcessor) Processor->ObjNode.Node.Next;
  while (Next ne (RmProcessor) NULL)
   { if (Processor->ObjNode.Type eq Type_Network)
      result += RmApplyProcessors((RmNetwork) Processor, fn, arg1, arg2, arg3);
d1354 3
a1356 3
      result	+= (*fn)(Processor, arg1, arg2, arg3);
     Processor	 = Next;
     Next	 = (RmProcessor) Processor->ObjNode.Node.Next;
d1361 1
a1361 1
int RmSearchProcessors(RmNetwork Network, int (*fn)(RmProcessor, ...), ...)
d1365 1
a1365 1
  RmProcessor	Processor, Next;
d1373 1
a1373 1
  CheckNetworkFail(Network, -1);  
d1375 5
a1379 5
  Processor	= (RmProcessor) Network->DirNode.Entries.Head;
  Next		= (RmProcessor) Processor->ObjNode.Node.Next;
  while ((Next ne (RmProcessor) NULL) && (result eq 0))
   { if (Processor->ObjNode.Type eq Type_Network)
      result += RmSearchProcessors((RmNetwork) Processor, fn, arg1, arg2, arg3);
d1381 3
a1383 3
      result	+= (*fn)(Processor, arg1, arg2, arg3);
     Processor	 = Next;
     Next	 = (RmProcessor) Processor->ObjNode.Node.Next;
d1392 2
a1393 2
RmNetwork	RmRootNetwork(RmProcessor Processor)
{ if (Processor eq (RmProcessor) NULL)
d1395 1
a1395 1
  return(Processor->Root);
d1398 2
a1399 2
bool		RmIsNetwork(RmProcessor Processor)
{ if (Processor eq (RmProcessor)NULL)
d1401 1
a1401 1
  return(Processor->ObjNode.Type eq Type_Network);
d1404 2
a1405 2
bool		RmIsProcessor(RmProcessor Processor)
{ if (Processor eq (RmProcessor)NULL) 
d1407 1
a1407 1
  return(Processor->ObjNode.Type eq Type_Processor);
d1411 6
a1416 6
*** Adding a hardware facility. When shipping networks around between programs,
*** I want to ship Uid's rather than pointers to processors. This routine
*** should still be used, so it cannot validate the processors.
*** Space is allocated for the structure and the copy is made.
*** Note that users can apply their own functions to these reset facilities
*** so the tables must contain real pointers, not UID's. 
d1418 2
d1421 29
a1449 1
int	RmAddHardwareFacility(RmNetwork Network, RmHardwareFacility *Reset)
d1452 1
a1452 1
  CheckNetwork(Network);  
d1455 1
a1455 1
   return(RmErrno = Network->Errno = RmE_BadArgument);
d1460 1
a1460 1
   return(RmErrno = Network->Errno = RmE_NoMemory);
d1469 1
a1469 1
  AddTail(&(Network->Hardware), &(NewReset->Node));
d1473 1
a1473 1
int		RmApplyHardwareFacilities(RmNetwork Network,
d1480 1
a1480 1
  CheckNetworkFail(Network, -1);  
d1488 1
a1488 1
  current = (RmHardwareFacility *) Network->Hardware.Head;
d1498 1
a1498 1
int		RmSearchHardwareFacilities(RmNetwork Network,
d1505 1
a1505 1
  CheckNetworkFail(Network, -1);  
d1513 1
a1513 1
  current = (RmHardwareFacility *) Network->Hardware.Head;
d1523 4
a1526 7


/**
*** Manipulating Taskforces is the same as manipulating networks.
**/
RmTaskforce	RmNewTaskforce(void)
{ RmTaskforce	Result = (RmTaskforce) Malloc(sizeof(RmTaskforceStruct));
d1529 1
a1529 1
  if (Result eq (RmTaskforce) NULL)
d1531 15
a1545 24
   
  Result->DirNode.Name[0]	= '\0';		/* a new Taskforce has no name */
  Result->DirNode.Type		= Type_Taskforce; 
  Result->DirNode.Flags		= 0;
  Result->DirNode.Matrix	= 0x211109c7;	/* darwv:rx:ry:rz */
  InitSemaphore(&(Result->DirNode.Lock), 1);
  Result->DirNode.Key		= date + _cputime();
  Result->DirNode.Parent	= Null(struct DirNode);
  Result->DirNode.Dates.Creation =
  Result->DirNode.Dates.Access	 =
  Result->DirNode.Dates.Modified = date;
  Result->DirNode.Account	= 0;
  Result->DirNode.Nentries	= 0;
  InitList(&(Result->DirNode.Entries));
  Result->Root			= (RmSet) Result;
  Result->NoTables		= 0;
  Result->Tables		= Null(RmUidTableEntry *);
  Result->StructType		= RmL_New;
  Result->NoSubsets		= 0;
  Result->Private2		= 0;
  Result->Errno			= 0;
  Result->ReturnCode		= -1;
  Result->State			= 0;
  return(Result);
d1548 1
a1548 1
static int FreeTaskforce_aux(RmTask Task, ...)
d1550 2
a1551 2
  (void) Remove((Node *) Task);
  Task->ObjNode.Parent = Null(struct DirNode);
d1553 2
a1554 2
  if (RmIsTaskforce(Task))
   return(RmFreeTaskforce((RmTaskforce) Task));
d1556 1
a1556 1
   return(RmFreeTask(Task));
d1559 1
a1559 1
int		RmFreeTaskforce(RmTaskforce Taskforce)
d1562 1
a1562 1
  CheckTaskforce(Taskforce); 
d1564 2
a1565 2
  if (Taskforce->DirNode.Parent ne Null(struct DirNode))
   return(RmErrno = Taskforce->Errno = RmE_InUse);
d1567 2
a1568 2
  if (Taskforce->DirNode.Nentries ne 0)
   { result = RmApplyTaskforce(Taskforce, &FreeTaskforce_aux);  
d1570 1
a1570 1
      return(RmErrno = Taskforce->Errno = result);
d1573 6
a1578 6
  if (Taskforce->NoTables > 0)
   { for (i = 0; i < Taskforce->NoTables; i++)
      if (Free(Taskforce->Tables[i]) ne Err_Null)
       return(RmErrno = Taskforce->Errno = RmE_Corruption);
     if (Free(Taskforce->Tables) ne Err_Null)
       return(RmErrno = Taskforce->Errno = RmE_Corruption);
d1581 2
a1582 2
  Taskforce->DirNode.Type	= 0;
  Free(Taskforce);
d1586 1
a1586 1
const char	*RmGetTaskforceId(RmTaskforce Taskforce)
d1588 2
a1589 3
  CheckTaskforceFail(Taskforce, (const char *) NULL);

  return(Taskforce->DirNode.Name);
d1592 1
a1592 1
int		RmSetTaskforceId(RmTaskforce Taskforce, char *name)
d1594 3
a1596 4
  CheckTaskforce(Taskforce);	

  if (Taskforce->StructType ne RmL_New)
   return(RmErrno = Taskforce->Errno = RmE_ReadOnly);
d1598 2
a1599 2
   return(RmErrno = Taskforce->Errno = RmE_TooLong);
  strcpy(Taskforce->DirNode.Name, name);
d1603 2
a1604 4
int		RmSetTaskforcePrivate(RmTaskforce taskforce, int x)
{
  CheckTaskforce(taskforce);	

d1609 2
a1610 4
int		RmSetTaskforcePrivate2(RmTaskforce taskforce, int x)
{
  CheckTaskforce(taskforce);	

d1615 2
a1616 4
int		RmGetTaskforcePrivate(RmTaskforce taskforce)
{
  CheckTaskforceFail(taskforce, -1);	

d1620 2
a1621 4
int		RmGetTaskforcePrivate2(RmTaskforce taskforce)
{ 
  CheckTaskforceFail(taskforce, -1);

d1625 2
a1626 4
int		RmGetTaskforceError(RmTaskforce taskforce)
{
  CheckTaskforce(taskforce);	

d1630 2
a1631 4
int		RmClearTaskforceError(RmTaskforce taskforce)
{
  CheckTaskforce(taskforce);

d1635 2
a1636 3
int		RmGetTaskforceState(RmTaskforce taskforce)
{
  CheckTaskforceFail(taskforce, -1);
d1640 2
a1641 3
int		RmSetTaskforceState(RmTaskforce taskforce, int state)
{
  CheckTaskforce(taskforce);
a1645 3
int		RmSetTaskNative(RmTask Task)
{
  CheckTask(Task);
d1647 3
a1649 35
  if (Task->StructType ne RmL_New) 
   return(RmErrno = Task->Errno = RmE_ReadOnly);
  Task->IsNative = TRUE;
  return(RmE_Success);
}

bool		RmIsTaskNative(RmTask Task)
{
  CheckTaskFail(Task, FALSE);	

  return(Task->IsNative);
}

bool		RmIsTaskNormal(RmTask Task)
{
  CheckTaskFail(Task, FALSE);

  return(!Task->IsNative);
}

int		RmSetTaskNormal(RmTask Task)
{
  CheckTask(Task); 

  if (Task->StructType ne RmL_New)
   return(RmErrno = Task->Errno = RmE_ReadOnly);
  Task->IsNative = FALSE;
  return(RmE_Success);
}

RmTask		RmFirstTask(RmTaskforce Taskforce)
{
  CheckTaskforceFail(Taskforce, (RmTask) NULL);

  if (Taskforce->DirNode.Nentries < 1)
d1651 1
a1651 1
  return((RmTask) Taskforce->DirNode.Entries.Head);
d1654 3
a1656 5
RmTask		RmLastTask(RmTaskforce Taskforce)
{
  CheckTaskforceFail(Taskforce, (RmTask) NULL);	

  if (Taskforce->DirNode.Nentries < 1)
d1658 1
a1658 1
  return((RmTask) Taskforce->DirNode.Entries.Tail);
d1661 6
a1666 8
RmTask		RmNextTask(RmTask Task)
{
  CheckTaskFail(Task, (RmTask) NULL);

  if (Task->ObjNode.Parent eq Null(struct DirNode))
   return(RmErrno = Task->Errno = RmE_NotTaskforce, (RmTask) NULL);
  Task = (RmTask) Task->ObjNode.Node.Next;
  if (Task->ObjNode.Node.Next eq Null(struct Node))
d1669 1
a1669 1
   return(Task);
d1672 3
a1674 3
RmTask		RmPreviousTask(RmTask Task)
{ RmTask	Result;
  RmTaskforce	Parent;
d1676 1
a1676 1
  CheckTaskFail(Task, (RmTask) NULL);  
d1678 5
a1682 5
  Parent = (RmTaskforce) Task->ObjNode.Parent;
  if (Parent eq (RmTaskforce) NULL)
   return(RmErrno = Task->Errno = RmE_NotTaskforce, (RmTask) NULL); 
  Result = (RmTask) Task->ObjNode.Node.Prev;
  if (Result eq (RmTask) &(Parent->DirNode.Entries.Head))
d1684 1
a1684 1
  return(Result);
d1687 3
a1689 5
bool		RmIsTaskforceEmpty(RmTaskforce Taskforce)
{ 
  CheckTaskforceFail(Taskforce, TRUE);

  return(Taskforce->DirNode.Nentries eq 0);
d1692 3
a1694 5
int		RmSizeofTaskforce(RmTaskforce Taskforce)
{
  CheckTaskforceFail(Taskforce, -1);	

  return(Taskforce->DirNode.Nentries);
d1697 3
a1699 3
int		RmCountTasks(RmTaskforce Taskforce)
{ int		result;
  RmTask	current;
d1701 1
a1701 1
  CheckTaskforceFail(Taskforce, -1);  
d1703 3
a1705 3
  if (Taskforce->NoSubsets eq 0) return(Taskforce->DirNode.Nentries);
  result = Taskforce->DirNode.Nentries - Taskforce->NoSubsets;
  for (current = RmFirstTask(Taskforce);
d1713 1
a1713 1
RmTaskforce	RmParentTaskforce(RmTask Task)
d1715 1
a1715 1
  if (Task eq (RmTask) NULL)
d1717 1
a1717 1
  if (Task->Root eq (RmTaskforce) NULL)
d1719 1
a1719 1
  if (Task->Root eq (RmTaskforce) Task)
d1721 1
a1721 1
  return((RmTaskforce) Task->ObjNode.Parent);
d1724 5
a1728 5
int 	RmApplyTaskforce(RmTaskforce Taskforce, int (*fn)(RmTask, ...), ...)
{ va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0;
  RmTask	Task, Next;
d1736 1
a1736 1
  CheckTaskforceFail(Taskforce, -1);  
d1738 3
a1740 3
  Task		= (RmTask) Taskforce->DirNode.Entries.Head;
  Next		= (RmTask) Task->ObjNode.Node.Next;
  while (Next ne (RmTask) NULL)
d1742 3
a1744 3
     result	+= (*fn)(Task, arg1, arg2, arg3);
     Task	 = Next;
     Next	 = (RmTask) Task->ObjNode.Node.Next;
d1749 5
a1753 5
int 	RmSearchTaskforce(RmTaskforce Taskforce, int (*fn)(RmTask, ...), ...)
{ va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0;
  RmTask	Task, Next;
d1761 1
a1761 1
  CheckTaskforceFail(Taskforce, -1);  
d1763 6
a1768 6
  Task		= (RmTask) Taskforce->DirNode.Entries.Head;
  Next		= (RmTask) Task->ObjNode.Node.Next;
  while ((Next ne (RmTask) NULL) && (result eq 0))
   { result	+= (*fn)(Task, arg1, arg2, arg3);
     Task	 = Next;
     Next	 = (RmTask) Task->ObjNode.Node.Next;
d1773 5
a1777 5
int 	RmApplyTasks(RmTaskforce Taskforce, int (*fn)(RmTask, ...), ...)
{ va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0;
  RmTask	Task, Next;
d1785 1
a1785 1
  CheckTaskforceFail(Taskforce, -1);  
d1787 5
a1791 5
  Task		= (RmTask) Taskforce->DirNode.Entries.Head;
  Next		= (RmTask) Task->ObjNode.Node.Next;
  while (Next ne (RmTask) NULL)
   { if (Task->ObjNode.Type eq Type_Taskforce)
      result += RmApplyTasks((RmTaskforce) Task, fn, arg1, arg2, arg3);
d1793 3
a1795 3
      result	+= (*fn)(Task, arg1, arg2, arg3);
     Task	 = Next;
     Next	 = (RmTask) Task->ObjNode.Node.Next;
d1800 5
a1804 5
int 	RmSearchTasks(RmTaskforce Taskforce, int (*fn)(RmTask, ...), ...)
{ va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0;
  RmTask	Task, Next;
d1812 1
a1812 1
  CheckTaskforceFail(Taskforce, -1);  
d1814 5
a1818 5
  Task		= (RmTask) Taskforce->DirNode.Entries.Head;
  Next		= (RmTask) Task->ObjNode.Node.Next;
  while ((Next ne (RmTask) NULL) && (result eq 0))
   { if (Task->ObjNode.Type eq Type_Taskforce)
      result	+= RmSearchTasks((RmTaskforce) Task, fn, arg1, arg2, arg3);
d1820 3
a1822 3
      result	+= (*fn)(Task, arg1, arg2, arg3);
     Task	 = Next;
     Next	 = (RmTask) Task->ObjNode.Node.Next;
d1827 2
a1828 2
RmTaskforce	RmRootTaskforce(RmTask Task)
{ if (Task eq (RmTask) NULL)
d1830 1
a1830 1
  return(Task->Root);
d1833 2
a1834 2
bool		RmIsTaskforce(RmTask Task)
{ if (Task eq (RmTask)NULL)
d1836 1
a1836 1
  return(Task->ObjNode.Type eq Type_Taskforce);
d1839 2
a1840 2
bool		RmIsTask(RmTask Task)
{ if (Task eq (RmTask)NULL)
d1842 1
a1842 1
  return(Task->ObjNode.Type eq Type_Task);
d1845 133
a1977 1
/**
d1987 2
a1988 2
RmUidTableEntry *RmFindTableEntry(RmSet Root, RmUid uid)
{ int tabno, tabindex;
d1991 1
a1991 1
  if ((Root eq (RmSet)NULL) || (uid  eq RmL_NoUid) )
d1997 1
a1997 1
      (tabno    >= Root->NoTables))
d1999 1
a1999 1
  tab = &(((Root->Tables)[tabno])[tabindex]);
d2008 2
a2009 2
RmObject RmFindUid(RmSet Root, RmUid uid)
{ RmUidTableEntry *tab = RmFindTableEntry(Root, uid);
d2020 1
a2020 1
bool RmExtendFreeQ(RmSet Root)
d2032 1
a2032 1
          Malloc((Root->NoTables + 1) * sizeof(RmUidTableEntry *));
d2037 3
a2039 3
  if (Root->NoTables > 0)
   memcpy(tabs, Root->Tables, Root->NoTables * sizeof(RmUidTableEntry *));
  tabs[Root->NoTables] = newtab;
d2045 1
a2045 1
       newtab[i].Free	= TRUE;
d2050 5
a2054 5
  if (Root->NoTables eq 0)	/* Very first one */
   { newtab[0].Free	= FALSE;	/* Ensures that Uid of 0 is invalid */
     newtab[0].Target	= (void *) RmM_NoProcessor;
     newtab[1].Free	= FALSE;
     newtab[1].Target	= (void *) RmM_ExternalProcessor;
d2058 4
a2061 4
  if (Root->NoTables > 0)
   Free(Root->Tables);
  Root->Tables	= tabs;
  Root->NoTables++;
d2071 1
a2071 1
bool RmNextFreeUid(RmSet Root, RmObject Obj)
d2074 1
a2074 1
  if ((Root eq (RmSet)NULL) || (Obj eq (RmObject)NULL))
d2076 1
a2076 1
  if (Obj->Uid ne RmL_NoUid) return(FALSE);
d2078 2
a2079 2
  for (tabno = 0; tabno < Root->NoTables; tabno++)
   { RmUidTableEntry *table = (Root->Tables)[tabno];
d2083 2
a2084 2
           Obj->Uid = (table[slot].Cycle << 24) + (tabno << 8) + slot;
           table[slot].Target = (void *) Obj;
d2090 1
a2090 1
  unless(RmExtendFreeQ(Root))
d2092 1
a2092 1
  return(RmNextFreeUid(Root, Obj));
d2100 2
a2101 2
bool RmReleaseUid(RmObject Obj)
{ RmSet Root;
d2105 3
a2107 3
  if (Obj eq (RmObject)NULL) return(FALSE);
  Root = Obj->Root;
  uid  = Obj->Uid;
d2109 1
a2109 1
  if (Root eq (RmSet)NULL) return(FALSE);
d2111 1
a2111 1
  tab = RmFindTableEntry(Root, uid);
d2113 1
a2113 1
  if (tab->Target ne (void *) Obj) return(FALSE);
d2117 4
a2120 4
  tab->Target	= (void *) RmL_NoObject;
  tab->Cycle	= tab->Cycle + 1;
  tab->Free	= TRUE;
  Obj->Uid	= RmL_NoUid;
d2130 1
a2130 1
bool RmObtainUid(RmSet Root, RmObject Obj)
d2134 1
a2134 1
  if ((Root eq (RmSet)NULL) || (Obj eq (RmObject)NULL)) return(FALSE);
d2136 1
a2136 1
  uid = Obj->Uid;
d2138 1
a2138 1
   return(RmNextFreeUid(Root, Obj));
d2140 1
a2140 1
  tab = RmFindTableEntry(Root, uid);
d2143 3
a2145 3
     if (tabno >= Root->NoTables)
      { while(tabno >= Root->NoTables)
         unless(RmExtendFreeQ(Root))
d2147 1
a2147 1
        return(RmObtainUid(Root, Obj));
d2155 1
a2155 1
     tab->Target = (void *) Obj;
d2161 3
a2163 2

/**
d2165 1
a2165 3
*** appear, because of the need to keep Uid's in a sensible state. It is
*** also necessary to enforce restrictions as to what type of object can
*** be added to what type of set, e.g. obtained versus new.
d2180 1
a2180 1
static RmObject	RmAddObject(RmSet Set, RmObject Obj, bool new);
d2190 3
a2192 3
RmProcessor	RmInsertProcessor(RmNetwork Network, RmProcessor Processor)
{ char		*netname, *temp;
  RmProcessor	cur_proc;
d2194 2
a2195 2
  CheckNetworkFail(Network, (RmProcessor) NULL);
  CheckProcessorFail(Processor, (RmProcessor) NULL);
d2197 1
a2197 5
  if (Processor->StructType ne RmL_Obtained)
   return(RmErrno = Network->Errno = Processor->Errno = RmE_NoAccess,
          (RmProcessor) NULL);
   
  netname = RmGetObjectAttribute((RmObject) Processor, "PUID", TRUE);
d2199 1
a2199 1
   return(RmErrno = Network->Errno = Processor->Errno = RmE_NoAccess,
d2202 1
a2202 1
	/* Do not validate the root of the network, this might be /domain */
d2204 2
a2205 2
  if (*temp eq '\0')		/* just /Net ?? */
   return(RmErrno = Network->Errno = Processor->Errno = RmE_WrongNetwork,
d2211 3
a2213 3
     netname = ++temp;		/* now root or Cluster/Root */
     if (netname eq '\0')		/* /Net/ ??? */
      return(RmErrno = Network->Errno = Processor->Errno = RmE_WrongNetwork,
d2217 1
a2217 1
     if (*temp eq '\0')	/* we are now in the target network */
d2219 7
a2225 7
        if (RmAddProcessor(Network, Processor, TRUE) ne (RmProcessor) NULL)
         { if (Network->NoSubnets eq 0)
            AddTail(&(Network->DirNode.Entries), &(Processor->ObjNode.Node));
           elif (Network->NoSubnets eq Network->DirNode.Nentries)
            AddHead(&(Network->DirNode.Entries), &(Processor->ObjNode.Node));
	   else
            { RmProcessor head = RmFirstProcessor(Network);
d2227 1
a2227 1
              PreInsert(&(head->ObjNode.Node), &(Processor->ObjNode.Node));
d2229 1
a2229 1
           return(Processor);
d2236 2
a2237 2
     *temp = '\0';		/* netname is Cluster/root, temp is /root */
     for (cur_proc = RmFirstProcessor(Network);
d2242 1
a2242 1
        { Network	= (RmNetwork) cur_proc;
d2244 1
a2244 1
          goto	loop;
d2246 1
a2246 1
     		/* specified subnet Cluster is not in this network */
d2252 1
a2252 1
RmProcessor	RmAddtailProcessor(RmNetwork Network, RmProcessor Processor)
d2254 3
a2256 3
  if (RmAddProcessor(Network, Processor, TRUE) ne (RmProcessor) NULL)
   { AddTail(&(Network->DirNode.Entries), &(Processor->ObjNode.Node));
     return(Processor);
d2262 1
a2262 1
RmProcessor	RmAddheadProcessor(RmNetwork Network, RmProcessor Processor)
d2264 3
a2266 3
  if (RmAddProcessor(Network, Processor, TRUE) ne (RmProcessor) NULL)
   { AddHead(&(Network->DirNode.Entries), &(Processor->ObjNode.Node));
     return(Processor);
d2272 2
a2273 2
RmProcessor	RmPreinsertProcessor(RmProcessor ProcA, RmProcessor ProcB)
{ if ((ProcA eq (RmProcessor) NULL) || (ProcB eq (RmProcessor) NULL))
d2276 4
a2279 4
  if (ProcB->ObjNode.Parent eq Null(struct DirNode))
   { if (RmAddProcessor((RmNetwork) ProcA->ObjNode.Parent, ProcB, TRUE))
      { PreInsert(&(ProcA->ObjNode.Node), &(ProcB->ObjNode.Node));
        return(ProcB);
d2285 4
a2288 4
   { if (RmAddProcessor((RmNetwork) ProcA->ObjNode.Parent, ProcB, FALSE))
      { Remove(&(ProcB->ObjNode.Node));
        PreInsert(&(ProcA->ObjNode.Node), &(ProcB->ObjNode.Node));
        return(ProcB);
d2295 2
a2296 2
RmProcessor	RmPostinsertProcessor(RmProcessor ProcA, RmProcessor ProcB)
{ if ((ProcA eq (RmProcessor) NULL) || (ProcB eq (RmProcessor) NULL))
d2299 4
a2302 4
  if (ProcB->ObjNode.Parent eq Null(struct DirNode))
   { if (RmAddProcessor((RmNetwork)ProcA->ObjNode.Parent, ProcB, TRUE))
      { PostInsert(&(ProcA->ObjNode.Node), &(ProcB->ObjNode.Node));
        return(ProcB);
d2308 4
a2311 4
   { if (RmAddProcessor((RmNetwork) ProcA->ObjNode.Parent, ProcB, FALSE))
      { Remove(&(ProcB->ObjNode.Node));
        PostInsert(&(ProcA->ObjNode.Node), &(ProcB->ObjNode.Node));
        return(ProcB);
d2318 1
a2318 1
RmTask	RmAddtailTask(RmTaskforce Taskforce, RmTask Task)
d2320 3
a2322 3
  if (RmAddTask(Taskforce, Task, TRUE) ne (RmTask) NULL)
   { AddTail(&(Taskforce->DirNode.Entries), &(Task->ObjNode.Node));
     return(Task);
d2328 1
a2328 1
RmTask	RmAddheadTask(RmTaskforce Taskforce, RmTask Task)
d2330 3
a2332 3
  if (RmAddTask(Taskforce, Task, TRUE) ne (RmTask) NULL)
   { AddHead(&(Taskforce->DirNode.Entries), &(Task->ObjNode.Node));
     return(Task);
d2338 2
a2339 2
RmTask	RmPreinsertTask(RmTask TaskA, RmTask TaskB)
{ if ((TaskA eq (RmTask) NULL) || (TaskB eq (RmTask) NULL))
d2342 4
a2345 4
  if (TaskB->ObjNode.Parent eq Null(struct DirNode))
   { if (RmAddTask((RmTaskforce) TaskA->ObjNode.Parent, TaskB, TRUE))
      { PreInsert(&(TaskA->ObjNode.Node), &(TaskB->ObjNode.Node));
        return(TaskB);
d2351 4
a2354 4
   { if (RmAddTask((RmTaskforce) TaskA->ObjNode.Parent, TaskB, FALSE))
      { Remove(&(TaskB->ObjNode.Node));
        PreInsert(&(TaskA->ObjNode.Node), &(TaskB->ObjNode.Node));
        return(TaskB);
d2361 2
a2362 2
RmTask	RmPostinsertTask(RmTask TaskA, RmTask TaskB)
{ if ((TaskA eq (RmTask) NULL) || (TaskB eq (RmTask) NULL))
d2365 4
a2368 4
  if (TaskB->ObjNode.Parent eq Null(struct DirNode))
   { if (RmAddTask((RmTaskforce) TaskA->ObjNode.Parent, TaskB, TRUE))
      { PostInsert(&(TaskA->ObjNode.Node), &(TaskB->ObjNode.Node));
        return(TaskB);
d2374 4
a2377 4
   { if (RmAddTask((RmTaskforce) TaskA->ObjNode.Parent, TaskB, FALSE))
      { Remove(&(TaskB->ObjNode.Node));
        PostInsert(&(TaskA->ObjNode.Node), &(TaskB->ObjNode.Node));
        return(TaskB);
d2391 1
a2391 1
static RmTask	RmAddTask(RmTaskforce Taskforce, RmTask Task, bool new)
d2394 1
a2394 1
  CheckTaskforceFail(Taskforce, (RmTask) NULL);
d2396 1
a2396 1
  if (Task eq (RmTask) NULL)
d2398 2
a2399 2
  if ((Task->ObjNode.Type ne Type_Task) && 
      (Task->ObjNode.Type ne Type_Taskforce))
d2401 2
a2402 5
  if ((Task->StructType ne RmL_New) || (Taskforce->StructType ne RmL_New))
   return(RmErrno = Taskforce->Errno = RmE_NoAccess, (RmTask) NULL);
   
  result = (RmTask) RmAddObject((RmSet) Taskforce, (RmObject) Task, new);
  if (result eq (RmTask) NULL) Taskforce->Errno = RmErrno;
d2406 2
a2407 2
static RmProcessor	RmAddProcessor(RmNetwork Network, RmProcessor Processor,
					bool	new)
d2410 1
a2410 1
  CheckNetworkFail(Network, (RmProcessor) NULL);
d2412 1
a2412 1
  if (Processor eq (RmProcessor)NULL)
d2414 2
a2415 2
  if ((Processor->ObjNode.Type ne Type_Processor) &&
      (Processor->ObjNode.Type ne Type_Network))
d2418 1
a2418 15
  if (Processor->StructType eq RmL_New)
   { if ((Network->StructType eq RmL_New) ||
         (Network->StructType eq RmL_Existing))
      result = (RmProcessor)
             RmAddObject((RmSet) Network, (RmObject) Processor, new);
     else
      return(RmErrno = Network->Errno = RmE_NoAccess, (RmProcessor) NULL);
   }
  elif (Processor->StructType eq RmL_Obtained)
   { 
     result = (RmProcessor)
             RmAddObject((RmSet) Network, (RmObject) Processor, new);
   }
  else
   return(RmErrno = Network->Errno = RmE_NoAccess, (RmProcessor) NULL);
d2421 1
a2421 1
   Network->Errno = RmErrno;
d2437 2
a2438 2
static RmObject	RmAddTerminal(RmSet, RmObject, bool);
static RmSet	RmAddSubset(RmSet, RmSet, bool);
d2440 1
a2440 1
static RmObject	RmAddObject(RmSet Set, RmObject Obj, bool new)
d2442 1
a2442 1
  if (Set eq (RmSet) Obj)
d2445 2
a2446 2
  if (new)	/* then the object cannot have a parent */
   { if (Obj->ObjNode.Parent ne Null(struct DirNode))
d2450 2
a2451 2
  if ((Obj->ObjNode.Type & Type_Flags) eq Type_Directory)
   return((RmObject) RmAddSubset(Set, (RmSet) Obj, new));
d2453 1
a2453 1
   return(RmAddTerminal(Set, Obj, new));
d2465 1
a2465 1
static int change_root(RmProcessor Obj, ...)
d2467 1
a2467 1
  RmSet   *Root;
d2469 2
a2470 2
  va_start(args, Obj);
  Root = va_arg(args, RmSet *);
d2472 3
a2474 3
  if ((Obj->ObjNode.Type & Type_Flags) eq Type_Directory)
   return(RmApplyNetwork((RmNetwork) Obj, &change_root, Root));
  Obj->Root = (RmNetwork) Root;
d2478 1
a2478 1
static RmSet RmAddSubset(RmSet Set, RmSet Subset, bool new)
d2480 2
a2481 2
  if (new && (Subset->DirNode.Nentries > 0))
   unless(RmRemapUids(Set, Subset))
d2484 1
a2484 1
  (void) RmApplyNetwork((RmNetwork) Subset, &change_root, Set->Root);
d2486 2
a2487 2
  Subset->Root = Set->Root;
  Set->DirNode.Nentries++;
d2489 2
a2490 2
   { RmSet Parent = (RmSet) Subset->DirNode.Parent;
     Parent->DirNode.Nentries--;
d2492 3
a2494 3
  Subset->DirNode.Parent = (struct DirNode *) Set;
  Set->NoSubsets++;
  return(Subset);
d2497 1
a2497 1
static RmObject RmAddTerminal(RmSet Set, RmObject Obj, bool new)
d2500 1
a2500 1
   unless(RmObtainUid(Set->Root, Obj))
d2503 2
a2504 2
  Obj->Root = (RmSet) Set->Root;
  Set->DirNode.Nentries++;
d2506 2
a2507 2
   { RmSet Parent = (RmSet) Obj->ObjNode.Parent;
     Parent->DirNode.Nentries--;
d2509 2
a2510 2
  Obj->ObjNode.Parent = (struct DirNode *) Set;
  return(Obj);  
a2518 1
static int RmMergeNetworksAux1(RmProcessor, ...);
d2521 2
a2522 2
int		RmMergeNetworks(RmNetwork domain, RmNetwork obtained)
{ int	rc;
a2526 6
  if ((rc = RmSearchNetwork(domain, &RmMergeNetworksAux1)) ne RmE_Success)
   return(RmErrno = domain->Errno = obtained->Errno = rc);

  if ((rc = RmSearchNetwork(obtained, &RmMergeNetworksAux1)) ne RmE_Success)
   return(RmErrno = domain->Errno = obtained->Errno = rc);

d2533 4
a2536 12
static	int RmMergeNetworksAux1(RmProcessor Processor, ...)
{ if (RmIsNetwork(Processor))
   return(RmSearchNetwork((RmNetwork) Processor, &RmMergeNetworksAux1));
  if (Processor->StructType ne RmL_Obtained)
   return(RmE_NoAccess);
  return(RmE_Success);
}

static int RmMergeNetworksAux2(RmProcessor Processor, ...)
{ RmNetwork	target;
  va_list	args;
  RmProcessor	current;
d2538 1
a2538 1
  va_start(args, Processor);
d2542 1
a2542 1
  if (Processor->ObjNode.Type ne Type_Processor)
d2547 2
a2548 2
       if (!strcmp(current->ObjNode.Name, Processor->ObjNode.Name))
        return(RmSearchNetwork((RmNetwork) Processor, &RmMergeNetworksAux2, current));
d2552 1
a2552 1
  { RmNetwork	parent = (RmNetwork) Processor->ObjNode.Parent;
d2554 1
a2554 1
    Remove(&(Processor->ObjNode.Node));
d2557 1
a2557 1
  unless(RmObtainUid((RmSet) target->Root, (RmObject) Processor))
d2561 1
a2561 1
   AddTail(&(target->DirNode.Entries), &(Processor->ObjNode.Node));
d2563 1
a2563 1
   AddHead(&(target->DirNode.Entries), &(Processor->ObjNode.Node));
d2568 1
a2568 1
     PreInsert( &(current->ObjNode.Node), &(Processor->ObjNode.Node));
d2571 2
a2572 2
  Processor->ObjNode.Parent = (DirNode *) target;
  Processor->Root	    = (RmNetwork) target->Root;
d2596 1
a2596 1
static int	RmRemapAux1(RmProcessor Processor, ...)
d2598 1
a2598 1
  RmNetwork Network;
d2600 2
a2601 2
  va_start(args, Processor);
  Network = va_arg(args, RmNetwork);
d2604 1
a2604 1
  Processor->Private = Processor->Uid;
d2606 2
a2607 2
  if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &RmRemapAux1, Network));
d2609 1
a2609 1
  if (RmObtainUid((RmSet) Network, (RmObject) Processor))
d2612 3
a2614 3
	/* The uid is already in use, so get a different one */
  Processor->Uid = RmL_NoUid;
  if (RmNextFreeUid((RmSet) Network, (RmObject) Processor))
d2617 1
a2617 1
 	/* Failed to get a Uid of any sort. This is an error */
d2621 2
a2622 2
	/* This routine undoes any damage done by the previous routine */
static int	RmRemapAux2(RmProcessor Processor, ...)
d2624 1
a2624 1
  RmNetwork Network, Save;
d2626 2
a2627 2
  va_start(args, Processor);
  Network = va_arg(args, RmNetwork);
d2629 4
a2632 4
  if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &RmRemapAux2, Network));
  if (Processor->Uid eq RmL_NoUid)
   { Processor->Uid = Processor->Private;
d2635 4
a2638 4
  Save = Processor->Root;
  Processor->Root = Network;
  if (!RmReleaseUid((RmObject) Processor))
   { Processor->Root = Save;
d2641 2
a2642 2
  Processor->Root = Save;
  Processor->Uid  = Processor->Private;
d2646 4
a2649 4
static int	RmRemapAux3(RmProcessor Processor, ...)
{ if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &RmRemapAux3));
  if (Processor->Uid ne Processor->Private)
d2654 2
a2655 2
static int	RmRemapAux4(RmProcessor Processor, ...)
{ int	count, i;
d2657 2
a2658 2
  if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &RmRemapAux4));
d2660 1
a2660 1
  count = RmCountLinks(Processor);
d2662 3
a2664 3
   { RmLink *Link = RmGetLinkEntry((RmObject) Processor, i);
     RmObject Obj;
     if ((Link->Target eq RmL_NoUid) || (Link->Target eq RmL_ExtUid))
d2666 2
a2667 2
     Obj = RmFindUid((RmSet) Processor->Root, Link->Target);
     if ((Obj eq RmL_NoObject) || (Obj eq RmL_ExtObject))
d2669 1
a2669 1
     Link->Target = Obj->Uid;
d2674 1
a2674 1
static bool	RmRemapUids(RmSet SetA, RmSet SetB)
d2676 2
a2677 2
  if (RmApplyNetwork((RmNetwork) SetB, &RmRemapAux1, SetA) ne 0)
   { if (RmApplyNetwork((RmNetwork) SetB, &RmRemapAux2, SetA) ne 0)
d2681 2
a2682 2
  if (RmSearchNetwork((RmNetwork) SetB, &RmRemapAux3) ne 0)
   return(RmApplyNetwork((RmNetwork) SetB, &RmRemapAux4) eq 0);
d2685 2
a2686 1

d2692 2
a2693 2
static RmSet	RmRemoveSet(RmSet Set);
static RmObject	RmRemoveObject(RmObject Obj);
d2695 1
a2695 1
RmProcessor	RmRemoveProcessor(RmProcessor Processor)
d2698 1
a2698 1
  if (Processor eq (RmProcessor) NULL)
d2700 2
a2701 2
  if (Processor->ObjNode.Type eq Type_Processor)
   { if ((result = (RmProcessor) RmRemoveObject((RmObject) Processor))
d2703 1
a2703 1
      Processor->Errno = RmErrno;
d2706 2
a2707 2
  elif(Processor->ObjNode.Type eq Type_Network)
   { if ((result = (RmProcessor) RmRemoveSet((RmSet) Processor))
d2709 2
a2710 2
      { RmNetwork Network = (RmNetwork) Processor;
        Network->Errno    = RmErrno;
d2718 2
a2719 2
RmTask		RmRemoveTask(RmTask Task)
{ RmTask	result;
d2721 1
a2721 1
  if (Task eq (RmTask)NULL)
d2723 2
a2724 2
  if (Task->ObjNode.Type eq Type_Task)
   { if ((result = (RmTask) RmRemoveObject((RmObject) Task))
d2726 1
a2726 1
      Task->Errno = RmErrno;
d2729 2
a2730 2
  elif (Task->ObjNode.Type eq Type_Taskforce)
   { if ((result = (RmTask) RmRemoveSet((RmSet) Task))
d2732 2
a2733 2
      { RmTaskforce Taskforce = (RmTaskforce) Task;
        Taskforce->Errno      = RmErrno;
d2757 3
a2759 3
static RmObject	RmRemoveObject(RmObject Obj)
{ int	Uid;
  RmSet	Parent;
d2761 3
a2763 3
  Parent = (RmSet) Obj->ObjNode.Parent;
  if (Parent eq (RmSet)NULL)
   { RmErrno = (Obj->ObjNode.Type eq Type_Processor) ? RmE_NotNetwork :
d2768 2
a2769 2
  Uid = Obj->Uid;
  unless(RmReleaseUid(Obj))
d2772 1
a2772 1
  if (Obj->StructType ne RmL_New) Obj->Uid = Uid;
d2774 2
a2775 2
  (void) Remove(&(Obj->ObjNode.Node));
  Parent->DirNode.Nentries--;
d2777 2
a2778 2
  Obj->ObjNode.Parent = Null(struct DirNode);
  Obj->Root = (RmSet) NULL;
d2780 1
a2780 1
  if (Obj->StructType eq RmL_New)  
d2782 3
a2784 3
     if (Obj->Connections > 4)
      { (void) Free(Obj->OtherLinks);
        Obj->OtherLinks = Null(RmLink);
d2786 1
a2786 1
     Obj->Connections = 0;
d2788 4
a2791 4
      { Obj->DefaultLinks[i].Flags		= 0;
        Obj->DefaultLinks[i].Destination	= 0;
        /* Obj->Defaultlinks[i].Spare		= 0; */
        Obj->DefaultLinks[i].Target		= RmL_NoUid;
d2794 1
a2794 1
  return(Obj);
d2811 2
a2812 2
static int	RmRemoveSetAux(RmProcessor, ...);
static int	RmRemoveSetAux2(RmProcessor, ...);
d2814 3
a2816 3
static RmSet	RmRemoveSet(RmSet Set)
{ RmSet	Parent, Root;
  int	i;
d2818 1
a2818 1
  Parent = (RmSet) Set->DirNode.Parent;
d2820 7
a2826 7
  if (Set->DirNode.Nentries eq 0)
   { (void) Remove(&(Set->DirNode.Node));
     Parent->DirNode.Nentries--;
     Parent->NoSubsets--;
     Set->Root = (struct RmSetStruct *) Set;
     Set->Root = (struct RmSetStruct *) Set;
     return(Set);
d2829 4
a2832 4
  Parent = (RmSet) Set->DirNode.Parent;
  Root   = (RmSet) Set->Root;
  if ((Parent eq (RmSet) NULL) || (Root eq (RmSet) NULL))
   { RmErrno = (Set->DirNode.Type eq Type_Network) ? RmE_NotNetwork :
d2837 2
a2838 2
  for(i = 0; i < Root->NoTables; i++)
   if (!RmExtendFreeQ(Set))
d2841 3
a2843 3
       (void) Free(Set->Tables[j]);
      (void) Free(Set->Tables);
      Set->NoTables = 0;
d2847 6
a2852 6
  (void) Remove(&(Set->DirNode.Node));
  Parent->DirNode.Nentries--;
  Parent->NoSubsets--;
  Set->DirNode.Parent = Null(struct DirNode);
  Set->Root = (struct RmSetStruct *) Set;
  if (RmApplyNetwork((RmNetwork) Set, &RmRemoveSetAux, Set))
d2855 2
a2856 2
  (void) RmApplyNetwork((RmNetwork) Set, &RmRemoveSetAux2);
  return(Set);
d2859 6
a2864 6
static int RmRemoveSetAux(RmProcessor Obj, ...)
{ va_list 	args;
  RmNetwork	Root;
  int		temp;
  va_start(args, Obj);
  Root = va_arg(args, RmNetwork);
d2867 2
a2868 2
  if ((Obj->ObjNode.Type & Type_Flags) eq Type_Directory)
   return(RmApplyNetwork((RmNetwork) Obj, &RmRemoveSetAux, Root));
d2870 5
a2874 5
  temp = Obj->Uid;
  unless(RmReleaseUid((RmObject) Obj)) return(1);
  Obj->Uid   = temp;
  Obj->Root  = (RmNetwork) Root;
  unless(RmObtainUid((RmSet) Root, (RmObject) Obj)) return(1);
d2878 1
a2878 1
static int	RmRemoveSetAux2(RmProcessor Processor, ...)
d2880 2
a2881 2
  if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &RmRemoveSetAux2));
d2883 2
a2884 2
  for (i = 0; i < Processor->Connections; i++)
   { RmLink *link = RmGetLinkEntry((RmObject) Processor, i);
d2887 1
a2887 1
         RmFindTableEntry((RmSet) Processor->Root, link->Target);
d2894 3
a2896 2

/**
d2902 2
a2903 3
*** The first routine, RmGetLinkEntry(), simply returns a pointer to the
*** appropriate RmLink structure given the object. It is called internally
*** when the argument is known to be valid.
d2906 2
a2907 2
static RmLink	*RmGetLinkEntry(RmObject Obj, int linkno) 
{ if (linkno >= Obj->Connections)
d2910 1
a2910 1
   return(&(Obj->DefaultLinks[linkno]));
d2912 1
a2912 1
   return(&(Obj->OtherLinks[linkno - 4]));
d2922 2
a2923 2
static int	RmMakeConn(RmObject, int, RmObject, int, int recurse);
static int	RmBreakConn(RmObject, int, int recurse);
d2925 1
d2927 2
a2928 2
int		RmMakeLink(RmProcessor source, int sourcelink, 
			   RmProcessor dest,   int destlink)
a2932 3
  if ((source->StructType ne RmL_New) && (source->StructType ne RmL_Obtained))
   return(RmErrno = source->Errno = RmE_ReadOnly);
   
d2942 2
a2943 2
int		RmMakeChannel(RmTask source, int sourcechan,
			      RmTask dest, int destchan)
d2958 1
a2958 1
int		RmBreakLink(RmProcessor Processor, int link)
d2961 1
a2961 1
  CheckProcessor(Processor);
d2963 3
a2965 3
  if ((link < 0) || (link >= Processor->Connections))
   return(RmErrno = Processor->Errno = RmE_BadArgument);
  if ((rc = RmBreakConn((RmObject) Processor, link, TRUE))
d2967 1
a2967 1
   RmErrno = Processor->Errno = rc;
d2975 1
a2975 1
int		RmBreakChannel(RmTask Task, int channel)
d2978 1
a2978 1
  CheckTask(Task);
d2980 2
a2981 2
  if ((channel < 0) || (channel >= Task->Connections))
   return(RmErrno = Task->Errno = RmE_BadArgument);
d2983 1
a2983 1
  if (RmFollowChannel(Task, channel, Null(int)) eq RmM_ExternalTask)
d2987 1
a2987 1
     result	= RmGetObjectAttribute((RmObject) Task, buf, TRUE);
d2990 1
a2990 1
        (void) RmRemoveObjectAttribute((RmObject) Task, result, TRUE);
d2993 1
a2993 1
  if ((rc = RmBreakConn((RmObject) Task, channel, TRUE))
d2995 1
a2995 1
   RmErrno = Task->Errno = rc;
d2999 3
a3001 5
int		RmCountLinks(RmProcessor Processor)
{ 
  CheckProcessorFail(Processor, -1);

  return(Processor->Connections);
d3004 3
a3006 5
int		RmCountChannels(RmTask Task)
{
  CheckTaskFail(Task, -1);	

  return(Task->Connections);
d3009 1
a3009 1
RmProcessor	RmFollowLink(RmProcessor Processor, int link, int *dlink)
d3014 1
a3014 1
  if (Processor eq (RmProcessor) NULL)
d3016 1
a3016 1
  if (Processor->ObjNode.Type ne Type_Processor)
d3019 1
a3019 1
  if ((result = (RmProcessor) RmFollowConn((RmObject) Processor, link, dlink))
d3021 1
a3021 1
   Processor->Errno = RmErrno;
d3025 1
a3025 1
RmTask		RmFollowChannel(RmTask Task, int channel, int *dchannel)
d3030 1
a3030 1
  if (Task eq (RmTask) NULL)
d3032 1
a3032 1
  if (Task->ObjNode.Type ne Type_Task)
d3034 1
a3034 1
  if ((result = (RmTask) RmFollowConn((RmObject) Task, channel, dchannel))
d3036 1
a3036 1
   Task->Errno = RmErrno;
d3040 1
a3040 1
int		RmGetLinkFlags(RmProcessor Processor, int link)
d3043 1
a3043 1
  CheckProcessorFail(Processor, -1);
d3045 3
a3047 3
  if ((link < 0) || (link >= Processor->Connections))
   return(RmErrno = Processor->Errno = RmE_BadArgument, -1);
  res = RmGetLinkEntry((RmObject) Processor, link);
d3054 1
a3054 1
int		RmGetChannelFlags(RmTask Task, int channel)
d3057 1
a3057 1
  CheckTaskFail(Task, -1);
d3059 3
a3061 3
  if ((channel < 0) || (channel >= Task->Connections))
   return(RmErrno = Task->Errno = RmE_BadArgument, -1);
  res = RmGetLinkEntry((RmObject) Task, channel);
d3063 1
a3063 1
   return(RmErrno = Task->Errno = RmE_BadChannel, -1);
a3068 7
*** Undocumented routine needed by the Network Server
**/
RmLink	*RmFindLink(RmProcessor Processor, int link)
{ return(RmGetLinkEntry((RmObject) Processor, link));
}

/**
d3073 2
a3074 4
**/

/**
*** fill in an attribute name depending on the channel number. For example,
d3078 1
a3078 1
static void	 build_fd_string(char *buf, int channel)
d3100 1
a3100 1
int	RmConnectChannelToFile(RmTask task, int channelno, char *name, int mode)
d3200 1
a3200 1
{ RmLink *curr_link = RmGetLinkEntry(source, linkno);
d3219 1
a3219 1
static int add_link(RmObject Processor, int linkno, RmObject dest,
d3227 1
a3227 1
  for (i = (Processor->Connections <= 4) ? 0 : Processor->Connections - 4;
d3234 4
a3237 4
  if (Processor->Connections > 4)
   { memcpy((void *) new_links, (void *) Processor->OtherLinks,
          (Processor->Connections - 4) * sizeof(RmLink));
     Free(Processor->OtherLinks);
d3240 3
a3242 3
  Processor->OtherLinks  = new_links;
  Processor->Connections = linkno + 1;
  return(fill_in_link(Processor, linkno, dest, destlink));
d3266 1
a3266 1
static int	RmMakeConn(RmObject source, int sourcelink, 
a3281 3
/**
*** BLV - throw away all this junk
**/           
d3291 1
a3291 1
      { RmLink *curr_link = RmGetLinkEntry(source, i);
d3306 1
a3306 1
        RmLink	*Link = RmGetLinkEntry(source, linkno);
d3309 1
a3309 1
        Link->Flags |= RmF_AnyLink;
d3317 1
a3317 1
        RmLink *Link;
d3319 2
a3320 2
        Link = RmGetLinkEntry(source, linkno);
        Link->Flags |= RmF_AnyLink;
d3352 1
a3352 1
   { RmLink *Link = RmGetLinkEntry(source, sourcelink);
d3354 1
a3354 1
     if (Link->Target eq RmL_NoUid)
d3361 3
a3363 3
    if (Link->Target eq dest->Uid)
     { Link->Destination = destlink;
       Link->Flags	&= ~RmF_AnyLink;
d3367 3
a3369 3
    if (Link->Flags & RmF_AnyLink)
     { RmObject	Obj	= RmFindUid(source->Root, Link->Target);
       int	destlink = Link->Destination;
d3373 2
a3374 2
       if (Obj ne (RmObject)NULL)
        { result = RmMakeConn(source, RmM_AnyLink, Obj, destlink, FALSE);
d3396 1
a3396 1
static int	RmBreakConn(RmObject source, int sourcelink, int recurse)
d3399 1
a3399 1
  RmLink	*Link;
d3405 5
a3409 5
  Link = RmGetLinkEntry(source, sourcelink);
  if (Link eq Null(RmLink)) return(RmErrno = RmE_Corruption);
  if (recurse && (Link->Target ne RmL_NoUid) && (Link->Target ne RmL_ExtUid))
   { dest = RmFindUid(source->Root, Link->Target);
     destlink = Link->Destination;
d3415 3
a3417 3
  Link->Target  = RmL_NoUid;
  Link->Destination = 0;
  Link->Flags &= ~(RmF_AnyLink + RmF_ToFile);
d3429 2
a3430 2
static RmObject RmFollowConn(RmObject Processor, int link, int *dlink)
{ RmLink   *Link;
d3433 1
a3433 1
  if ((link eq RmM_AnyLink) || (link < 0) || (link >= Processor->Connections))
d3435 4
a3438 4
  Link = RmGetLinkEntry(Processor, link);
  if (Link->Target eq RmL_ExtUid)
   { *dlink = Link->Destination; return(RmL_ExternalObject); }
  elif (Link->Target eq RmL_NoUid)
d3441 1
a3441 1
  Target = RmFindUid(Processor->Root, Link->Target);
d3445 1
a3445 1
   *dlink = Link->Destination;
d3451 1
a3451 2


@


1.8
log
@Major update of networking sources, to match Helios1_2_2_native_beta
@
text
@d19 1
a19 1
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/rmlib1.c,v 1.3 1991/08/21 16:02:10 bart Exp $";
d60 1
d62 1
a62 1
#define	VersionNumber	"1.10"
d95 1
a270 1
***
d398 2
a399 1
  
d1039 15
d1818 1
d1921 13
@


1.7
log
@RmRemoveSet was free'ing the wrong bit of memory on error
@
text
@d19 1
a19 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib1.c,v 1.6 1990/12/01 15:36:16 bart Exp bart $";
d29 1
d39 1
a41 1
#if 0
d43 6
d58 6
d83 1
a83 1
  RmT_Names[RmT_H1]	= "H1";
d93 1
d110 1
a110 1
   return((RmProcessor) NULL);
d123 1
a123 1
  Result->ObjNode.Size		= RmP_Helios;
d126 1
a126 1
  Result->RmLib			=
a130 1
     /* Result->DefaultLinks[i].Spare		= 0;*/
d143 1
a143 1
  Result->MemorySize		= 0;	/* Irrelevant */
d147 2
d151 4
d168 1
a168 3
  if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  if (Processor->ObjNode.Parent ne Null(struct DirNode)) return(RmE_InUse);
d170 3
d175 1
a175 1
    return(RmE_Corruption);
d179 1
a179 1
    return(RmE_Corruption);
d183 1
a183 1
    return(RmE_Corruption);
d189 1
a189 1
    return(RmE_Corruption);
d192 2
a193 1
  if (Free(Processor) ne Err_Null) return(RmE_Corruption);
d201 4
a204 3
int		RmGetProcessorMemory(RmProcessor Processor)
{ if (Processor eq (RmProcessor) NULL) return(-1);
  if (Processor->ObjNode.Type ne Type_Processor) return(-1);
d213 6
a218 4
int		RmSetProcessorMemory(RmProcessor Processor, int size)
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  if (Processor->StructType ne RmL_New) return(RmE_ReadOnly);
d229 4
a232 3
const RmID	RmGetProcessorID(RmProcessor Processor)
{ if (Processor eq (RmProcessor) NULL) return((RmID) NULL);
  if (Processor->ObjNode.Type ne Type_Processor) return((RmID) NULL);
d241 8
a248 5
int		RmSetProcessorID(RmProcessor Processor, RmID name)
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  if (Processor->StructType ne RmL_New) return(RmE_ReadOnly);
  if (strlen(name) >= NameMax) return(RmE_TooLong);
d254 2
a255 2
*** The processor purpose is encoded into the bottom nibble of the size
*** field, and can be one of RmP_Helios, RmP_System, RmP_Native and RmP_IO.
d259 4
a262 3
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  return(Processor->ObjNode.Size & RmP_Mask);
a269 3
BLV - possibly system programs should be able to bypass these restrictions,
BLV to implement sfnc. Alternatively they could poke the value directly
BLV rather than use a library call
d273 6
a278 11
  if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  if (Processor->StructType eq RmL_New)
   { if ((Purpose eq RmP_Helios) || (Purpose eq RmP_System) ||
         (Purpose eq RmP_IO) || (Purpose eq RmP_Native))
      { Processor->ObjNode.Size = (Processor->ObjNode.Size & ~RmP_Mask) |
				  Purpose;
        return(RmE_Success);
      }
     else
      return(RmE_BadArgument);
d281 6
a286 7
   { if ((Purpose ne RmP_Helios) && (Purpose ne RmP_Native))
      return(RmE_BadArgument);
     if (((Processor->ObjNode.Size & RmP_Mask) ne RmP_Helios) &&
         ((Processor->ObjNode.Size & RmP_Mask) ne RmP_Native) )
      return(RmE_ReadOnly);
     Processor->ObjNode.Size = (Processor->ObjNode.Size & ~RmP_Mask) |
      				Purpose;
d290 1
a290 1
   return(RmE_ReadOnly);
d294 1
a294 3
*** Getting a processor state is always allowed. However, I have not
*** yet decided what the state should be.
BLV - restrictions because of error codes
d297 4
a300 3
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  return(Processor->ObjNode.Size & ~ RmP_Mask);
d304 3
a306 5
{ int	temp;
  if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  temp = (Processor->ObjNode.Size & RmP_Mask) | state;
  Processor->ObjNode.Size = temp;
d314 2
a315 2
BLV - problem with error codes, these restrict processor types to less
BLV than 256. That will not be enough in the long run.
d318 3
a320 2
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
d329 7
a335 4
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  if (Processor->StructType ne RmL_New) return(RmE_ReadOnly);
  if ((type < RmT_Unknown) || (type >= RmT_Known)) return(RmE_BadArgument);
d345 3
a347 2
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
d365 2
a366 2
  if (env eq Null(Environ)) return(0);
  if (env->Objv eq Null(Object *)) return(0);
d372 1
a372 1
  if (session eq (Object *) MinInt) return(0);
d466 6
a471 3
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  if (Processor->StructType ne RmL_New) return(RmE_ReadOnly);
d473 4
a476 1
  return(RmAddObjectAttribute((RmObject) Processor, attr, FALSE));
d480 8
a487 3
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  return(RmAddObjectAttribute((RmObject) Task, attr, FALSE));
d542 10
a551 4
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  if (Processor->StructType ne RmL_New) return(RmE_ReadOnly);
  return(RmRemoveObjectAttribute((RmObject) Processor, attr, FALSE));
d555 8
a562 3
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  return(RmRemoveObjectAttribute((RmObject) Task, attr, FALSE));
d591 17
d626 9
a634 4
int		RmIsAProcessorAttribute(RmProcessor Processor, char *attr)
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  return(RmIsAnObjectAttribute((RmObject) Processor, attr, FALSE));
d637 9
a645 4
int		RmIsATaskAttribute(RmTask Task, char *attr)
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  return(RmIsAnObjectAttribute((RmObject) Task, attr, FALSE));
d673 3
a675 2
{ if (Processor eq (RmProcessor) NULL) return(-1);
  if (Processor->ObjNode.Type ne Type_Processor) return(-1);
d680 3
a682 2
{ if (Task eq (RmTask) NULL) return(-1);
  if (Task->ObjNode.Type ne Type_Task) return(-1);
d713 8
a720 3
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  return(RmListObjectAttributes((RmObject) Processor, table, FALSE));
d724 8
a731 3
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  return(RmListObjectAttributes((RmObject) Task, table, FALSE));
d746 3
a748 2
  if (Processor eq (RmProcessor) NULL) return(Null(char));
  if (Processor->ObjNode.Type ne Type_Processor) return(Null(char));
a768 4
      
  if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
  if (Processor->StructType ne RmL_New) return(RmE_ReadOnly);
d770 5
d790 1
a790 1
      return(RmE_Corruption);
d796 2
d804 1
a804 1
*** These routines are undocumented.
d806 6
a811 2
void	RmSetProcessorPrivate(RmProcessor processor, int x)
{ processor->RmLib = x;
d814 8
d823 4
a826 1
{ return(processor->RmLib);
d828 22
a849 1
	
d851 4
a854 1
{ return(processor->Uid);
d864 8
d884 4
a887 1
   
d902 1
a902 1
  Result->RmLib			=
d918 1
a918 1
  Result->MemorySize		= 0;
d930 3
d941 2
a942 3
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (Task->ObjNode.Parent ne Null(struct DirNode)) return(RmE_InUse);
d944 3
d949 1
a949 1
    return(RmE_Corruption);
d953 1
a953 1
    return(RmE_Corruption);
d957 1
a957 1
    return(RmE_Corruption);
d961 1
a961 1
    return(RmE_Corruption);
d965 1
a965 1
    return(RmE_Corruption);
d971 1
a971 1
    return(RmE_Corruption);
d974 2
a975 1
  if (Free(Task) ne Err_Null) return(RmE_Corruption);
d982 4
a985 3
int		RmGetTaskMemory(RmTask Task)
{ if (Task eq (RmTask) NULL) return(-1);
  if (Task->ObjNode.Type ne Type_Task) return(-1);
d989 6
a994 4
int		RmSetTaskMemory(RmTask Task, int size)
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (Task->StructType ne RmL_New) return(RmE_ReadOnly);
d999 4
a1002 3
const RmID	RmGetTaskID(RmTask Task)
{ if (Task eq (RmTask)NULL) return((RmID) NULL);
  if (Task->ObjNode.Type ne Type_Task) return((RmID) NULL);
d1006 8
a1013 5
int		RmSetTaskID(RmTask Task, RmID name)
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (Task->StructType ne RmL_New) return(RmE_ReadOnly);
  if (strlen(name) >= NameMax) return(RmE_TooLong);
d1019 3
a1021 2
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
d1026 7
a1032 4
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (Task->StructType ne RmL_New) return(RmE_ReadOnly);
  if ((type < RmT_Unknown) || (type >= RmT_Known)) return(RmE_BadArgument);
d1039 3
a1041 2
  if (Task eq (RmTask) NULL) return(Null(char));
  if (Task->ObjNode.Type ne Type_Task) return(Null(char));
d1053 8
a1060 5
     
  if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (Task->StructType ne RmL_New) return(RmE_ReadOnly);
  if (file eq Null(char)) return(RmE_BadArgument);
a1061 1

d1063 2
a1064 1
  if (buffer eq Null(char)) return(RmE_NoMemory);
d1071 2
a1072 1
        if (rc ne RmE_Success) return(rc);
d1079 4
a1082 1
   
d1086 6
a1091 5
/**
*** These are undocumented.
**/
void	RmSetTaskPrivate(RmTask task, int x)
{ task->RmLib = x;
d1094 8
d1103 4
a1106 1
{ return(task->RmLib);
d1109 21
d1131 4
a1134 1
{ return(task->Uid);
d1148 1
a1148 1
int		RmSetTaskArgument(RmTask Task, int number, char *str)
d1150 6
a1155 6
  if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (Task->StructType ne RmL_New) return(RmE_ReadOnly);
  if (Task->IsNative) return(RmE_Native);
  if ((number < 1) || (number > Task->NextArgIndex)) return(RmE_TooLong);
  if (str eq Null(char)) return(RmE_BadArgument);
d1166 2
a1167 1
     if (Task->ArgIndex eq Null(int)) return(RmE_NoMemory);
d1170 2
a1171 1
     if (Task->ArgStrings eq Null(char)) return(RmE_NoMemory);
d1179 2
a1180 1
     if (temp eq Null(int)) return(RmE_NoMemory);
d1185 2
a1186 1
     if (rc ne Err_Null) return(RmE_Corruption);
d1192 2
a1193 1
     if (temp eq Null(char)) return(RmE_NoMemory);
d1199 2
a1200 1
     if (rc ne Err_Null) return(RmE_Corruption);
d1228 2
a1229 1
  if (new_buffer eq Null(char)) return(RmE_NoMemory);
d1264 6
a1269 4
{ if (task eq (RmTask)NULL) return(Null(char));
  if (task->ObjNode.Type ne Type_Task) return(Null(char));
  if (argc eq 0) return(RmGetTaskID(task));
  if ((argc < 1) || (argc >= task->NextArgIndex)) return(Null(char));
d1274 3
a1276 2
{ if (task eq (RmTask) NULL) return(-1);
  if (task->ObjNode.Type ne Type_Task) return(-1);
d1307 2
a1308 1
  if (Result eq (RmNetwork) NULL) return((RmNetwork) NULL);
d1328 2
d1352 1
a1352 1
   return(RmE_Corruption);
a1358 4
 
  if (Network eq (RmNetwork) NULL) return(RmE_NotNetwork);
  if (Network->DirNode.Type ne Type_Network) return(RmE_NotNetwork);
  if (Network->DirNode.Parent ne Null(struct DirNode)) return(RmE_InUse);
d1360 5
d1367 2
a1368 1
     if (result ne RmE_Success) return(result);
d1373 1
a1373 1
   return(result);
d1378 1
a1378 1
       return(RmE_Corruption);
d1380 1
a1380 1
       return(RmE_Corruption);
d1385 1
a1385 1
   return(RmE_Corruption);
d1394 4
a1397 3
const RmID	RmGetNetworkID(RmNetwork Network)
{ if (Network eq (RmNetwork) NULL) return((RmID) NULL);
  if (Network->DirNode.Type ne Type_Network) return((RmID) NULL);
d1401 8
a1408 5
int		RmSetNetworkID(RmNetwork Network, RmID name)
{ if (Network eq (RmNetwork) NULL) return(RmE_NotNetwork);
  if (Network->DirNode.Type ne Type_Network) return(RmE_NotNetwork);
  if (Network->StructType ne RmL_New) return(RmE_ReadOnly);
  if (strlen(name) >= NameMax) return(RmE_TooLong);
d1413 6
a1418 5
/**
*** Undocumented routines.
**/
void	RmSetNetworkPrivate(RmNetwork network, int x)
{ network->RmLib = x;
d1421 8
d1430 4
a1433 1
{ return(network->RmLib);
d1436 19
d1460 4
a1463 3
{ if (Network eq (RmNetwork) NULL) return((RmProcessor) NULL);
  if (Network->DirNode.Type ne Type_Network) return((RmProcessor) NULL);
  if (Network->DirNode.Nentries < 1) return((RmProcessor) NULL);
d1468 3
a1470 2
{ if (Network eq (RmNetwork) NULL) return((RmProcessor) NULL);
  if (Network->DirNode.Type ne Type_Network) return((RmProcessor) NULL);
d1481 3
a1483 1
{ if (Processor eq (RmProcessor) NULL) return((RmProcessor) NULL);
d1485 1
a1485 1
   return((RmProcessor) NULL);
d1496 3
a1498 2
  
  if (Processor eq (RmProcessor) NULL) return((RmProcessor) NULL);
d1500 2
a1501 1
  if (Parent eq (RmNetwork) NULL) return((RmProcessor) NULL); 
d1514 4
a1517 3
bool		RmEmptyNetwork(RmNetwork Network)
{ if (Network eq (RmNetwork) NULL) return(TRUE);
  if (Network->DirNode.Type ne Type_Network) return(TRUE);
d1522 3
a1524 2
{ if (Network eq (RmNetwork) NULL) return(-1);
  if (Network->DirNode.Type ne Type_Network) return(-1);
d1531 3
a1533 3
  
  if (Network eq (RmNetwork)NULL) return(-1);
  if (Network->DirNode.Type ne Type_Network) return(-1);
d1551 5
a1555 2
{ if (Processor eq (RmProcessor) NULL) return((RmNetwork) NULL);
  if (Processor->Root eq (RmNetwork) NULL) return((RmNetwork) NULL);
d1571 3
a1573 3
  
  if (Network eq (RmNetwork) NULL) return(-1);
  if (Network->DirNode.Type ne Type_Network) return(-1);
d1595 3
a1597 3
  
  if (Network eq (RmNetwork) NULL) return(-1);
  if (Network->DirNode.Type ne Type_Network) return(-1);
d1608 55
d1668 2
a1669 1
{ if (Processor eq (RmProcessor) NULL) return((RmNetwork) NULL);
d1674 2
a1675 1
{ if (Processor eq (RmProcessor)NULL) return(FALSE);
d1680 2
a1681 1
{ if (Processor eq (RmProcessor)NULL) return(FALSE);
a1695 4
  
  if (Network eq (RmNetwork)NULL) return(RmE_NotNetwork);
  if (Network->DirNode.Type ne Type_Network) return(RmE_NotNetwork);
  if (Reset eq Null(RmHardwareFacility)) return(RmE_BadArgument);
d1697 5
d1705 1
a1705 1
   return(RmE_NoMemory);
d1724 2
a1726 3
  if (Network eq (RmNetwork)NULL) return(-1);
  if (Network->DirNode.Type ne Type_Network) return(-1);
  
d1749 2
a1751 3
  if (Network eq (RmNetwork)NULL) return(-1);
  if (Network->DirNode.Type ne Type_Network) return(-1);
  
d1777 3
a1779 1
  if (Result eq (RmTaskforce) NULL) return((RmTaskforce) NULL);
d1798 3
a1816 4
 
  if (Taskforce eq (RmTaskforce) NULL) return(RmE_NotTaskforce);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(RmE_NotTaskforce);
  if (Taskforce->DirNode.Parent ne Null(struct DirNode)) return(RmE_InUse);
d1818 5
d1825 2
a1826 1
     if (result ne RmE_Success) return(result);
d1832 1
a1832 1
       return(RmE_Corruption);
d1834 1
a1834 1
       return(RmE_Corruption);
d1842 4
a1845 3
const RmID	RmGetTaskforceID(RmTaskforce Taskforce)
{ if (Taskforce eq (RmTaskforce) NULL) return((RmID) NULL);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return((RmID) NULL);
d1849 8
a1856 5
int		RmSetTaskforceID(RmTaskforce Taskforce, RmID name)
{ if (Taskforce eq (RmTaskforce) NULL) return(RmE_NotTaskforce);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(RmE_NotTaskforce);
  if (Taskforce->StructType ne RmL_New) return(RmE_ReadOnly);
  if (strlen(name) >= NameMax) return(RmE_TooLong);
d1861 6
a1866 2
void		RmSetTaskforcePrivate(RmTaskforce taskforce, int x)
{ taskforce->RmLib = x;
d1869 8
d1878 4
a1881 1
{ return(taskforce->RmLib);
d1884 21
d1906 5
a1910 3
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (Task->StructType ne RmL_New) return(RmE_ReadOnly);
d1916 3
a1918 2
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
d1922 3
a1924 7
int		RmSetTaskNormal(RmTask Task)
{ if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (Task->StructType ne RmL_New) return(RmE_ReadOnly);
  Task->IsNative = FALSE;
  return(RmE_Success);
}
d1926 1
a1926 5
static int RmSetTaskNativeAux(RmTask Task, ...)
{ if (RmIsTaskforce(Task))
   return(RmSearchTaskforce((RmTaskforce) Task, &RmSetTaskNativeAux));
  else
   return(RmSetTaskNative(Task));
d1929 3
a1931 6
static int RmSetTaskNormalAux(RmTask Task, ...)
{ if (RmIsTaskforce(Task))
   return(RmSearchTaskforce((RmTaskforce) Task, &RmSetTaskNormalAux));
  else
   return(RmSetTaskNormal(Task));
}
d1933 4
a1936 4
int		RmSetTaskforceNative(RmTaskforce Taskforce)
{ if (Taskforce eq (RmTaskforce) NULL) return(RmE_NotTaskforce);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(RmE_NotTaskforce);
  return(RmSearchTaskforce(Taskforce, &RmSetTaskNativeAux));
d1939 3
a1941 5
int		RmSetTaskforceNormal(RmTaskforce Taskforce)
{ if (Taskforce eq (RmTaskforce) NULL) return(RmE_NotTaskforce);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(RmE_NotTaskforce);
  return(RmSearchTaskforce(Taskforce, &RmSetTaskNormalAux));
}
d1943 2
a1944 4
RmTask		RmFirstTask(RmTaskforce Taskforce)
{ if (Taskforce eq (RmTaskforce) NULL) return((RmTask) NULL);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return((RmTask) NULL);
  if (Taskforce->DirNode.Nentries < 1) return((RmTask) NULL);
d1949 5
a1953 3
{ if (Taskforce eq (RmTaskforce) NULL) return((RmTask) NULL);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return((RmTask) NULL);
  if (Taskforce->DirNode.Nentries < 1) return((RmTask) NULL);
d1958 3
a1960 1
{ if (Task eq (RmTask) NULL) return((RmTask) NULL);
d1962 1
a1962 1
   return((RmTask) NULL);
d1973 3
a1975 2
  
  if (Task eq (RmTask) NULL) return((RmTask) NULL);
d1977 2
a1978 1
  if (Parent eq (RmTaskforce) NULL) return((RmTask) NULL); 
d1985 4
a1988 3
bool		RmEmptyTaskforce(RmTaskforce Taskforce)
{ if (Taskforce eq (RmTaskforce) NULL) return(TRUE);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(TRUE);
d1993 3
a1995 2
{ if (Taskforce eq (RmTaskforce) NULL) return(-1);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(-1);
a2001 3
  
  if (Taskforce eq (RmTaskforce) NULL) return(-1);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(-1);
d2003 2
d2016 7
a2022 3
{ if (Task eq (RmTask) NULL) return((RmTaskforce) NULL);
  if (Task->Root eq (RmTaskforce) NULL) return((RmTaskforce) NULL);
  if (Task->Root eq (RmTaskforce) Task) return((RmTaskforce) NULL);
d2037 3
a2039 3
  
  if (Taskforce eq (RmTaskforce) NULL) return(-1);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(-1);
d2062 3
a2064 3
  
  if (Taskforce eq (RmTaskforce) NULL) return(-1);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(-1);
d2075 54
d2130 2
a2131 1
{ if (Task eq (RmTask) NULL) return((RmTaskforce) NULL);
d2136 2
a2137 1
{ if (Task eq (RmTask)NULL) return(FALSE);
d2142 2
a2143 1
{ if (Task eq (RmTask)NULL) return(FALSE);
d2365 2
a2366 5
  if ((Network eq (RmNetwork)NULL) || (Processor eq (RmProcessor)NULL))
   return((RmProcessor)NULL);
  if ((Network->DirNode.Type ne Type_Network) ||
      (Processor->ObjNode.Type ne Type_Processor))
   return((RmProcessor)NULL);
d2368 3
a2370 3
  if ((Network->StructType ne RmL_Obtained) ||
      (Processor->StructType ne RmL_Obtained))
   return((RmProcessor) NULL);
d2373 3
a2375 1
  if (netname eq Null(char)) return((RmProcessor) NULL);
d2380 2
a2381 1
   return((RmProcessor) NULL);
d2388 2
a2389 1
      return((RmProcessor)NULL);
d2427 1
a2427 1
RmProcessor	RmAddTailProcessor(RmNetwork Network, RmProcessor Processor)
d2437 1
a2437 1
RmProcessor	RmAddHeadProcessor(RmNetwork Network, RmProcessor Processor)
d2447 1
a2447 1
RmProcessor	RmPreInsertProcessor(RmProcessor ProcA, RmProcessor ProcB)
d2470 1
a2470 1
RmProcessor	RmPostInsertProcessor(RmProcessor ProcA, RmProcessor ProcB)
d2493 1
a2493 1
RmTask	RmAddTailTask(RmTaskforce Taskforce, RmTask Task)
d2503 1
a2503 1
RmTask	RmAddHeadTask(RmTaskforce Taskforce, RmTask Task)
d2513 1
a2513 1
RmTask	RmPreInsertTask(RmTask TaskA, RmTask TaskB)
d2536 1
a2536 1
RmTask	RmPostInsertTask(RmTask TaskA, RmTask TaskB)
d2567 6
a2572 4
{ if ((Taskforce eq (RmTaskforce) NULL) || (Task eq (RmTask) NULL))
   return((RmTask) NULL);
  if (Taskforce->DirNode.Type ne Type_Taskforce)
   return((RmTask) NULL);
d2575 7
a2581 5
   return((RmTask) NULL);
  if ((Task->StructType eq RmL_New) && (Taskforce->StructType eq RmL_New))
   return((RmTask) RmAddObject((RmSet) Taskforce, (RmObject) Task, new));
  else
   return((RmTask) NULL);
d2586 6
a2591 5
{
  if ((Network eq (RmNetwork) NULL) || (Processor eq (RmProcessor)NULL))
   return((RmProcessor) NULL);
  if (Network->DirNode.Type ne Type_Network)
   return((RmProcessor) NULL);
d2594 1
a2594 1
   return((RmProcessor) NULL);
d2599 2
a2600 2
      return((RmProcessor)
             RmAddObject((RmSet) Network, (RmObject) Processor, new));
d2602 1
a2602 1
      return((RmProcessor) NULL);
d2606 2
a2607 2
     return((RmProcessor)
             RmAddObject((RmSet) Network, (RmObject) Processor, new));
d2610 5
a2614 1
   return((RmProcessor) NULL);
d2634 2
a2635 1
  if (Set eq (RmSet) Obj) return((RmObject) NULL);
d2639 1
a2639 1
      return((RmObject) NULL);
d2674 1
a2674 1
    return((RmSet) NULL);
d2693 1
a2693 1
     return((RmObject) NULL);
d2717 2
a2718 5
  if ((domain eq (RmNetwork) NULL) || (obtained eq (RmNetwork) NULL))
   return(RmE_NotNetwork);
  if ((domain->DirNode.Type ne Type_Network) || 
      (obtained->DirNode.Type ne Type_Network))
   return(RmE_NotNetwork);
d2721 1
a2721 1
   return(rc);
d2724 1
a2724 1
   return(rc);
d2726 3
a2728 1
  rc = RmSearchNetwork(obtained, &RmMergeNetworksAux2, domain);
d2811 1
a2811 1
  Processor->RmLib = Processor->Uid;
d2839 1
a2839 1
   { Processor->Uid = Processor->RmLib;
d2849 1
a2849 1
  Processor->Uid  = Processor->RmLib;
d2856 1
a2856 1
  if (Processor->Uid ne Processor->RmLib)
d2902 4
a2905 1
{ if (Processor eq (RmProcessor) NULL) return((RmProcessor) NULL);
d2907 5
a2911 1
   return((RmProcessor) RmRemoveObject((RmObject) Processor));
d2913 7
a2919 1
   return((RmProcessor) RmRemoveSet((RmSet) Processor));
d2921 1
a2921 1
   return((RmProcessor) NULL);
d2925 4
a2928 1
{ if (Task eq (RmTask)NULL) return((RmTask) NULL);
d2930 5
a2934 1
   return((RmTask) RmRemoveObject((RmObject) Task));
d2936 7
a2942 1
   return((RmTask) RmRemoveSet((RmSet) Task));
d2944 1
a2944 1
   return((RmTask) NULL);
d2968 5
a2972 1
  if (Parent eq (RmSet)NULL) return((RmObject) NULL);
d2975 3
a2977 1
  unless(RmReleaseUid(Obj)) return((RmObject) NULL);
d3038 5
a3042 2
   return((RmSet) NULL);

d3050 1
a3050 1
      return((RmSet) NULL);
d3059 1
a3059 1
   return((RmSet) NULL);
d3068 1
a3068 1

d3076 1
a3076 1
  Obj->RmLib = Obj->Uid;
d3078 1
a3078 1
  Obj->Uid   = Obj->RmLib;
d3114 1
a3114 1
   return(Null(RmLink));
a3130 1
static int	RmResolveConns(RmSet);
d3134 4
a3137 3
{
  if (source eq (RmProcessor)NULL) return(RmE_NotProcessor);
  if (source->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
d3139 1
a3139 1
   return(RmE_ReadOnly);
d3142 1
a3142 3
   { if (dest eq (RmProcessor) NULL) return(RmE_NotProcessor);
     if (dest->ObjNode.Type ne Type_Processor)
      return(RmE_NotProcessor);
d3144 4
a3147 2
  return(RmMakeConn((RmObject) source, sourcelink, (RmObject) dest, destlink,
  			TRUE));
d3152 4
a3155 3
{
  if (source eq (RmTask) NULL) return(RmE_NotTask);
  if (source->ObjNode.Type ne Type_Task) return(RmE_NotTask);
d3157 1
a3157 2
   { if (dest eq (RmTask) NULL) return(RmE_NotTask);
     if (dest->ObjNode.Type ne Type_Task) return(RmE_NotTask);
d3159 4
a3162 2
  return(RmMakeConn((RmObject) source, sourcechan, (RmObject) dest, destchan,
  			TRUE));
d3167 4
a3170 2
{ if (Processor eq (RmProcessor) NULL) return(RmE_NotProcessor);
  if (Processor->ObjNode.Type ne Type_Processor) return(RmE_NotProcessor);
d3172 5
a3176 2
   return(RmE_BadArgument);
  return(RmBreakConn((RmObject) Processor, link, TRUE));
d3184 4
a3187 3
{ 
  if (Task eq (RmTask) NULL) return(RmE_NotTask);
  if (Task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
d3189 1
a3189 1
   return(RmE_BadArgument);
d3201 4
a3204 1
  return(RmBreakConn((RmObject) Task, channel, TRUE));
d3207 3
a3209 6
int		RmResolveLinks(RmNetwork Network)
{ if (Network eq (RmNetwork) NULL) return(-1);
  if (Network->DirNode.Type ne Type_Network) return(-1);
  if (Network->StructType eq RmL_Existing) return(-1);
  return(RmResolveConns((RmSet) Network));
}
a3210 10
int		RmResolveChannels(RmTaskforce Taskforce)
{ if (Taskforce eq (RmTaskforce)NULL) return(-1);
  if (Taskforce->DirNode.Type ne Type_Taskforce) return(-1);
  if (Taskforce->StructType ne RmL_New) return(-1);
  return(RmResolveConns((RmSet) Taskforce));
}

int		RmCountLinks(RmProcessor Processor)
{ if (Processor eq (RmProcessor) NULL) return(-1);
  if (Processor->ObjNode.Type ne Type_Processor) return(-1);
d3215 3
a3217 2
{ if (Task eq (RmTask) NULL) return(-1);
  if (Task->ObjNode.Type ne Type_Task) return(-1);
d3222 2
a3223 1
{ int junk;
d3227 1
a3227 1
   { *dlink = RmE_NotProcessor; return(RmM_NoProcessor); }
d3229 6
a3234 2
   { *dlink = RmE_NotProcessor; return(RmM_NoProcessor); }
  return((RmProcessor) RmFollowConn((RmObject) Processor, link, dlink)); 
d3238 2
a3239 1
{ int junk;
d3241 1
d3243 1
a3243 1
   { *dchannel = RmE_NotTask; return(RmM_NoTask); }
d3245 5
a3249 2
   { *dchannel = RmE_NotTask; return(RmM_NoTask); }
  return((RmTask) RmFollowConn((RmObject) Task, channel, dchannel));
d3254 5
a3258 3
  if (Processor eq (RmProcessor) NULL) return(-1);
  if (Processor->ObjNode.Type ne Type_Processor) return(-1);
  if ((link < 0) || (link >= Processor->Connections)) return(-1);
d3261 1
a3261 1
   return(-1);
d3269 4
a3272 3
  if (Task eq (RmTask) NULL) return(-1);
  if (Task->ObjNode.Type ne Type_Task) return(-1);
  if ((channel < 0) || (channel >= Task->Connections)) return(-1);
d3275 1
a3275 1
   return(-1);
d3327 1
a3327 5
  if (task eq (RmTask) NULL) return(RmE_NotTask);
  if (task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
  if (name eq Null(char)) return(RmE_BadArgument);
  if (strlen(name) < 1) return(RmE_BadArgument);
  if ((channelno eq RmM_AnyLink) || (channelno < 0)) return(RmE_BadArgument);
d3329 5
d3338 2
a3339 1
     if (buffer eq Null(BYTE)) return(RmE_NoMemory);
d3349 2
a3350 1
     if (env eq Null(Environ)) return(RmE_NoMemory);
d3355 2
a3356 1
     if (buffer eq Null(BYTE)) return(RmE_NoMemory);
d3368 1
a3368 1
     return(rc);
d3374 3
a3376 1
   (void) RmBreakConn((RmObject) task, channelno, FALSE);
d3389 4
a3392 2
  if (task eq (RmTask) NULL) goto done;
  if (task->ObjNode.Type ne Type_Task) goto done;
d3408 1
a3408 1
   { *mode_ptr = rc; return(Null(char)); }
d3446 2
a3447 1
  if (new_links eq Null(RmLink)) return(RmE_NoMemory);
d3495 1
a3495 1
   return(RmE_BadArgument);
d3499 2
a3500 1
      return(RmE_WrongNetwork);
d3502 4
a3505 1
           
d3519 1
a3519 1
           if (result ne RmE_Success) return(result);
d3532 1
a3532 1
        if (result ne RmE_Success) return(result);
d3542 1
a3542 1
	if (result ne RmE_Success) return(result);
d3551 1
a3551 1
  if (sourcelink < 0) return(RmE_BadArgument);
d3561 1
a3561 1
        if (result ne RmE_Success) return(result);
d3566 1
a3566 1
         if (result ne RmE_Success) return(result);
d3580 1
a3580 1
        if (result ne RmE_Success) return(result);
d3596 1
a3596 1
       if (result ne RmE_Success) return(result);
d3599 1
a3599 1
          if (result ne RmE_Success) return(result);
d3602 1
a3602 1
    return(RmE_InUse);
d3627 1
a3627 1
   return(RmE_BadArgument);
d3630 1
a3630 1
  if (Link eq Null(RmLink)) return(RmE_Corruption);
d3641 1
a3641 1
  Link->Flags = 0;
d3658 1
a3658 1
   { *dlink = RmE_BadArgument; return((RmObject) NULL); }
a3675 211
/**
*** Resolving connections. The Set is guaranteed to be valid and writeable.
*** 1) in the case of networks or native taskforces, it is necessary to test
***    the number of connections between objects and get rid of the excess.
***    If too few have been specified, fill in the remainder to be not
***    connected.
*** 2) for all connections that have been specified completely, do a
***    validation
*** 3) for all connections about which information is scanty, see if there
***    is any more info to be had.
**/

static int RmResolve1(RmProcessor Processor, ...)
{ int ptype = RmGetProcessorType(Processor);
  int links;
  int sum = 0;

  if ((Processor->ObjNode.Type & Type_Flags) eq Type_Directory)
   return(RmApplyNetwork((RmNetwork) Processor, &RmResolve1));
     
 	/* First figure out how many connections this object should have */
  switch(ptype)
   { case RmT_T800 :
     case RmT_T414 :
     case RmT_T425 :
     case RmT_T212 :
     case RmT_H1   :	/* probably */
     			links = 4; break;
     case RmT_T400 :	links = 2; break;
     default	   :	/* not known how many links, so take the user's word */
     			/* for it. */
     		     return(0);
   }

	/* If the object has too few connections, add some more. Making a */
	/* connection to RmM_NoProcessor simply extends the table if	  */
	/* necessary. 							  */   
  while (links > Processor->Connections)
   { if (RmMakeLink(Processor, Processor->Connections, RmM_NoProcessor, 0) ne
         RmE_Success)
      return(-100000);
     sum++;
   }
  
 	/* If the object has too many connections, the remainder must be */
 	/* broken. This may involve free'ing the OtherLinks bit of the   */
 	/* structure. Some more work could be done here. If the object   */
 	/* can have six connections and currently has eight, then after  */
 	/* breaking connections 6 and 7 the OtherLinks table should be   */
 	/* realloc'ed. This is unlikely to be worthwhile.		 */
  if (links < Processor->Connections)
   { int i;
     for (i = links; i < Processor->Connections; i++)
      { if (RmBreakLink(Processor, i) ne RmE_Success)
         return(-100000);
        sum++;
      }
     if ((links <= 4) && (Processor->Connections > 4))
      (void) Free(Processor->OtherLinks);
     Processor->Connections = links;
   }
  return(sum);
}

static int RmResolve2(RmProcessor Processor, ...)
{ int count = RmCountLinks(Processor);
  int i;
  int sum = 0;

  if ((Processor->ObjNode.Type & Type_Flags) eq Type_Directory)
   return(RmApplyNetwork((RmNetwork) Processor, &RmResolve2));
   
	/* Examine every link, one by one. */    
  for (i = 0; i < count; i++)
   { RmLink *Link = RmGetLinkEntry((RmObject) Processor, i);
     RmProcessor Target;
      
     	/* Unconnected links and external ones can be ignored, there */
     	/* is no verification to be done.			     */
     if ((Link->Target eq RmL_NoUid) || (Link->Target eq RmL_ExtUid))
      continue;
     
    	/* Check that the object at the other end of the connection */
    	/* really does exist. If not, break the connection.	    */
     Target = (RmProcessor) RmFindUid((RmSet) Processor->Root, Link->Target);
     if (Target eq RmM_NoProcessor) goto error;

	/* This code should never get executed. It implies a funny UID */
     if (Target eq RmM_ExternalProcessor)
      { Link->Target = RmL_ExtUid;
        Link->Destination = 0;
        Link->Flags	 &= ~RmF_AnyLink;
        continue;
      }

	/* If the two objects are in different sets then there is something */
	/* very funny going on. However, there is little that can be done   */
	/* to recover.							    */
     if (Target->Root ne Processor->Root) goto error;

	/* If the connecting link on the target processor is known, it is */
	/* possible to check the other end immediately.			  */
     if (Link->Destination ne RmM_AnyLink)
      { RmLink *TargetLink = RmGetLinkEntry((RmObject) Target,
      					    Link->Destination);
	/* Failing this test means that Destination is wrong. */
        if (TargetLink eq Null(RmLink)) goto error;
        
       	/* This is an inconsistency error. ProcA goes to ProcB but not */
       	/* vice versa */
        if (TargetLink->Target ne Processor->Uid) goto error;

	/* If the other object knows which link it is connected to, but this */
	/* object does not, the other object must be confused. */
        if (TargetLink->Flags & RmF_AnyLink)
         { Link->Destination = RmM_AnyLink;
           goto skip;
         }

       	/* If the other end does not know which link it is connected to but */
       	/* this end is happy, then the other end can be updated. */
        if (TargetLink->Destination eq RmM_AnyLink)
         { if ((Link->Flags & RmF_AnyLink) eq 0)
            { TargetLink->Destination = i;
              sum++;
            }
         }
        /* If the other end thinks it is connected to a different link than */
        /* this end, there is something wrong. */
        elif(TargetLink->Destination ne i)
         goto error;

        /* And I cannot think of any more tests. */
        continue;
      }
skip:         
	/* I know that link i of object Processor is connected to some link */
	/* of object Target, but not which link. */
     { int count = RmCountLinks(Target);
       int j;
       int possibles = 0;
       RmLink *TargetLink;
	/* Follow all the connections in Target, to see which one(s) match */
       for (j = 0; j < count; j++)
        { TargetLink = RmGetLinkEntry((RmObject) Target, j);
          if (TargetLink->Target ne Processor->Uid) continue;
		/* There is a possibility that the other side knows */
		/* all the required information. */
          if (TargetLink->Destination eq i)
           { possibles = -100000;
             if (TargetLink->Flags & RmF_AnyLink)
              break;	/* no more information to be had */
             Link->Destination = j;
             sum++;
             break;
           }
           	/* This may be the right link, but it is only worth */
           	/* worrying if it is non-floating */
          if ((TargetLink->Destination eq RmM_AnyLink) &&
              ((TargetLink->Flags & RmF_AnyLink) eq 0))
           possibles++;
        }
        	/* If there is exactly one fixed link connected to this */
        	/* Processor then some information can be filled in.	*/
       if (possibles eq 1)
        { int count = RmCountLinks(Target);
          int j;
          RmLink *TargetLink;

          	/* Find it again */
          for (j = 0; j < count; j++)
           { TargetLink = RmGetLinkEntry((RmObject) Target, j);
             if ((TargetLink->Target eq Processor->Uid) &&
                 (TargetLink->Destination eq RmM_AnyLink) &&
                 ((TargetLink->Flags & RmF_AnyLink) eq 0))
              { /* And fill it in */
                Link->Destination = j; sum++;
                if ((Link->Flags & RmF_AnyLink) eq 0)
                 { TargetLink->Destination = i; sum++; }
                break;
              }
           }
        }
     }
     continue;
error:
     Link->Destination = RmM_AnyLink;
     (void) RmBreakLink(Processor, i);
     sum++;
   }
  return(sum);
}

static int RmResolveConns(RmSet Set)
{ int	sum = 0;

  if (Set->DirNode.Nentries <= 0) return(0);
  
  { RmNetwork Network	  = (RmNetwork) Set;
    RmProcessor Processor = RmFirstProcessor(Network);
    RmTask	Task	  = (RmTask) Processor;

    if (RmIsProcessor(Processor))
     sum += RmApplyNetwork(Network, &RmResolve1);
    elif (RmIsTask(Task))
     if (RmIsTaskNative(Task))
      sum += RmApplyNetwork(Network, &RmResolve1);
  }
  
  return(sum + RmApplyNetwork((RmNetwork) Set, &RmResolve2));
}
@


1.6
log
@the type fields for processors, networks, etc. are now cleared when
the object is RmFree'd. This prevents accidental reuse of a freed
object.
@
text
@d19 1
a19 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/rmlib1.c,v 1.2 90/09/20 17:43:34 bart Exp $";
d2583 1
a2583 1
       (void) Free(Set->Tables[i]);
@


1.5
log
@added some initialisation code for new processors and tasks, to cope
with mapping of tasks onto processors
,
@
text
@d170 2
a171 1
             
d831 1
d1169 2
d1514 1
@


1.4
log
@sources update after visit to Parsytec 22.10.90-31.10.90
@
text
@d135 1
d790 2
a791 2
  Result->MappedTo		= 0;
  memset((void *) &(Result->MappedCap), 0, sizeof(Capability));
d2242 1
@


1.3
log
@Plugged various memory leaks
@
text
@d40 1
d42 1
d1888 2
a1889 2
     if (tabno > Root->NoTables)
      { while(tabno > Root->NoTables)
a1896 1

d2772 1
a2772 1
int		RmGetLinksFlags(RmProcessor Processor, int link)
@


1.2
log
@now compiles on ARM compiler, which is more restrictive
@
text
@d19 1
a19 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/rmlib1.c,v 1.1 90/09/12 14:52:35 jon Exp Locker: bart $";
d1164 3
d1507 1
@


1.1
log
@Initial revision
@
text
@d19 1
a19 1
static char *rcsid = "$Header$";
d1133 1
a1133 1
static int FreeHardware(RmHardwareFacility *reset)
d1552 14
d1569 1
a1569 1
  return(RmApplyTaskforce(Taskforce, &RmSetTaskNative));
d1575 1
a1575 1
  return(RmApplyTaskforce(Taskforce, &RmSetTaskNormal));
@
