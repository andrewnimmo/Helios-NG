head	1.12;
access;
symbols
	Helios_C40_1_3_Official_Release:1.8
	Alenia_release:1.6
	Helios1_3:1.6
	C40_Field_Test_2:1.6
	C40_Field_Test_R1:1.4
	Helios13_beta:1.4
	Helios1_2_2_Fault:1.2
	Helios1_2_2_Native:1.1
	Helios1_2_2_native_beta:1.1;
locks; strict;
comment	@ * @;


1.12
date	93.12.08.17.57.24;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	93.08.12.11.15.47;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	93.08.11.11.15.09;	author bart;	state Exp;
branches;
next	1.9;

1.9
date	93.08.06.10.24.28;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	93.04.14.16.17.16;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	93.01.08.12.34.37;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	92.10.07.13.32.32;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	92.09.09.11.45.00;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	92.05.08.16.42.58;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	92.03.25.18.03.41;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	92.01.15.11.04.39;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	92.01.14.14.23.22;	author bart;	state Exp;
branches;
next	;


desc
@The part of the Resource management library that sends requests and
gets replies from the networking servers
@


1.12
log
@fixed compile time warnings from ARM compiler
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990 - 1993, Perihelion Software Ltd.      --
--                        All Rights Reserved.                          --
--                                                                      --
-- rmlib3.c								--
--                                                                      --
--	The ``real work'' module. This module provides the routines	--
--	that actually interact with servers, using the facilities	--
--	provided by rmlib2.c, and the data structures provided by	--
--	rmlib1.c.							--
--                                                                      --
--	Author:  BLV 1/5/90						--
--                                                                      --
------------------------------------------------------------------------*/
/* RcsId: $Header: /hsrc/network/RCS/rmlib3.c,v 1.11 1993/08/12 11:15:47 nickc Exp nickc $*/

#define in_rmlib	1

/*{{{  Headers */
#if defined(__SUN4) || defined(RS6000)
#include </hsrc/include/memory.h>
#include </hsrc/include/link.h>
#define _link_h
#endif
#include <syslib.h>
#include <stdarg.h>
#include <string.h>
#include <root.h>
#include <posix.h>
#include <gsp.h>
#include <nonansi.h>
#include <stddef.h>

#include "exports.h"
#include "private.h"
#include "rmlib.h"

#ifdef Malloc		/* courtesy of servlib.h */
#undef Malloc
#endif
/*}}}*/
/*{{{  Compile-time options */

#ifdef __TRAN
#pragma -f0		/* 0 == disable vector stack			*/
#pragma -g0		/* remove names from code			*/
#endif

#ifdef STACKCHECK
#pragma	-s0
#else
#pragma -s1
#endif
/*}}}*/
/*{{{  The current network */
RmNetwork	RmGetNetwork(void)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  request.FnRc = RmC_GetNetwork;
  rc = RmXch(&RmNetworkServer, &request, &reply);
  if (rc ne RmE_Success) RmErrno = rc;
  return(reply.Network);
}

RmNetwork	RmGetNetworkAndHardware(void)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  request.FnRc = RmC_GetNetworkHardware;
  rc = RmXch(&RmNetworkServer, &request, &reply);
  if (rc ne RmE_Success) RmErrno = rc;
  return(reply.Network);
}

RmNetwork	RmGetNetworkHierarchy(void)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  request.FnRc = RmC_GetHierarchy;
  rc = RmXch(&RmNetworkServer, &request, &reply);
  if (rc ne RmE_Success) RmErrno = rc;
  return(reply.Network);
}

RmNetwork	RmGetDomain(void)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  request.FnRc = RmC_GetNetwork;
  rc = RmXch(&RmParent, &request, &reply);
  if (rc ne RmE_Success) RmErrno = rc;
  return(reply.Network);
}
/*}}}*/
/*{{{  Time stamps */
int		RmLastChangeDomain(void)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  request.FnRc = RmC_LastChange;
  rc = RmXch(&RmParent, &request, &reply);
  if (rc ne RmE_Success)
   { RmErrno = rc; return(-1); }
  else
   return(reply.Reply1);
}

int		RmLastChangeNetwork(void)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  request.FnRc = RmC_LastChange;
  rc = RmXch(&RmNetworkServer, &request, &reply);
  if (rc ne RmE_Success)
   { RmErrno = rc; return(-1); }
  else
   return(reply.Reply1);
}
/*}}}*/
/*{{{  Obtaining and releasing single processor */

/**
*** Obtaining a processor. This involves sending a template to the
*** parent server, i.e. to the Taskforce Manager or the Network
*** server.
**/
RmProcessor	RmObtainProcessor(RmProcessor Template)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  CheckProcessorFail(Template, (RmProcessor) NULL);

  if ((Template->StructType ne RmL_Existing) &&
      (Template->StructType ne RmL_New))
   { RmErrno = Template->Errno = RmE_BadArgument; return((RmProcessor)NULL); }

  Clear(request); Clear(reply);
  request.FnRc		= RmC_ObtainProcessor;
  request.Processor	= Template;

  rc = RmXch(&RmParent, &request, &reply);
  if (rc ne RmE_Success) RmErrno = Template->Errno = rc;
  return(reply.Processor);
}

/**
*** releasing a processor. This involves sending a packet to the parent,
*** giving the processor uid and capability. Also, once the processor
*** has been released the structure type must change.
**/
int		RmReleaseProcessor(RmProcessor processor)
{ int			rc;
  RmRequest		request;
  RmReply		reply;

  CheckProcessor(processor);
  if (processor->StructType ne RmL_Obtained) 
   return(RmErrno = processor->Errno = RmE_NoAccess);

  Clear(request); Clear(reply);
  request.FnRc	= RmC_ReleaseProcessor;
  request.Uid	= processor->Uid;
  request.Cap	= processor->NsCap;
  rc = RmXch(&RmParent, &request, &reply);
  if (rc ne RmE_Success)
   RmErrno = processor->Errno = rc;
  else
   processor->StructType = RmL_Existing;
  return(rc);
}

bool	RmIsProcessorFree(RmProcessor processor)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  CheckProcessorFail(processor, FALSE);
  if ((processor->StructType ne RmL_Existing) &&
      (processor->StructType ne RmL_Obtained))
   return(processor->Errno = RmErrno = RmE_BadProcessor);

  Clear(request); Clear(reply);
  request.FnRc	= RmC_IsProcessorFree;
  request.Uid	= processor->Uid;

  rc = RmXch(&RmParent, &request, &reply);

  if (rc eq RmE_Success)
   return(TRUE);
  elif (rc eq RmE_InUse)
   return(FALSE);
  else
   return(processor->Errno = RmErrno = rc, FALSE);
}

/*}}}*/
/*{{{  Processor allocation options */
/**
*** Manipulating processor and network allocation strategies. These
*** only happen between clients and the Taskforce Manager
**/
static		int RmSetProcessorAllocation(int fnrc, RmProcessor processor)
{ int		rc;
  RmRequest	request;  
  RmReply	reply;

  Clear(request); Clear(reply);

  request.FnRc	= fnrc;
  request.Uid	= processor->Uid;
  request.Cap	= processor->NsCap;
  rc = RmXch(&RmParent, &request, &reply);
  if (rc ne RmE_Success) RmErrno = processor->Errno = rc;
  return(rc);     
}

int		RmSetProcessorShareable(RmProcessor processor)
{ 
  CheckProcessor(processor);

  if ((processor->StructType eq RmL_New) || 
      (processor->StructType eq RmL_Existing))
   { processor->AllocationFlags &= ~RmF_Exclusive;
     return(RmE_Success);
   }
  if (processor->StructType ne RmL_Obtained)
   return(RmErrno = processor->Errno = RmE_NoAccess);

  return(RmSetProcessorAllocation(RmC_ProcessorShareable, processor));
}

int		RmSetProcessorExclusive(RmProcessor processor)
{
  CheckProcessor(processor);

  if ((processor->StructType eq RmL_New) ||
      (processor->StructType eq RmL_Existing))
   { processor->AllocationFlags |= RmF_Exclusive;
     return(RmE_Success);
   }
  if (processor->StructType ne RmL_Obtained)
   return(RmErrno = processor->Errno = RmE_NoAccess);

  return(RmSetProcessorAllocation(RmC_ProcessorExclusive, processor));   
}

bool	RmIsProcessorShareable(RmProcessor processor)
{
  CheckProcessorFail(processor, FALSE); 

  if (processor->AllocationFlags & RmF_Exclusive)
   return(FALSE);
  else
   return(TRUE);
}

bool	RmIsProcessorExclusive(RmProcessor processor)
{
  CheckProcessorFail(processor, FALSE);

  if (processor->AllocationFlags & RmF_Exclusive)
   return(TRUE);
  else
   return(FALSE);
}

int		RmSetProcessorTemporary(RmProcessor processor)
{
  CheckProcessor(processor);

  if ((processor->StructType eq RmL_New) ||
      (processor->StructType eq RmL_Existing))
   { processor->AllocationFlags &= ~RmF_Permanent;
     return(RmE_Success);
   }
  if (processor->StructType ne RmL_Obtained)
   return(RmErrno = processor->Errno = RmE_NoAccess);
  return(RmSetProcessorAllocation(RmC_ProcessorTemporary, processor));   
}

int		RmSetProcessorPermanent(RmProcessor processor)
{
  CheckProcessor(processor);

  if ((processor->StructType eq RmL_New) ||
      (processor->StructType eq RmL_Existing))
   { processor->AllocationFlags |= RmF_Permanent;
     return(RmE_Success);
   }
  if (processor->StructType ne RmL_Obtained)
   return(RmErrno = processor->Errno = RmE_NoAccess);
  return(RmSetProcessorAllocation(RmC_ProcessorPermanent, processor));   
}

bool		RmIsProcessorTemporary(RmProcessor processor)
{
  CheckProcessorFail(processor, FALSE);	

  if (processor->AllocationFlags & RmF_Permanent)
   return(FALSE);
  else
   return(TRUE);
}

bool		RmIsProcessorPermanent(RmProcessor processor)
{
  CheckProcessorFail(processor, FALSE);

  if (processor->AllocationFlags & RmF_Permanent)
   return(TRUE);
  else
   return(FALSE);
}

int		RmSetProcessorCancelled(RmProcessor processor)
{ 
  CheckProcessor(processor);

  if ((processor->StructType eq RmL_New) || 
      (processor->StructType eq RmL_Existing))
   { processor->AllocationFlags &= ~RmF_Booked;
     return(RmE_Success);
   }
  if (processor->StructType ne RmL_Obtained)
   return(RmErrno = processor->Errno = RmE_NoAccess);

  return(RmSetProcessorAllocation(RmC_ProcessorCancelled, processor));
}

int		RmSetProcessorBooked(RmProcessor processor)
{
  CheckProcessor(processor);

  if ((processor->StructType eq RmL_New) ||
      (processor->StructType eq RmL_Existing))
   { processor->AllocationFlags |= RmF_Booked;
     return(RmE_Success);
   }
  if (processor->StructType ne RmL_Obtained)
   return(RmErrno = processor->Errno = RmE_NoAccess);

  return(RmSetProcessorAllocation(RmC_ProcessorBooked, processor));   
}
/*}}}*/
/*{{{  Obtaining a network or group of processors */

/**----------------------------------------------------------------------------
*** Obtaining a network. This involves the following stages.
*** 1) check the network passed as argument. Every processor should be
***    either new or existing for now. Also, if the network is empty
***    forget it.
*** 2) start a new job. Send it the function code RmC_ObtainNetwork or
***    RmC_ObtainExactNetwork, together with the magic integer
***    RmStartSearchHere, and then the template network.
*** 3) wait around a long time for a reply. This reply may be 0 to indicate
***    complete success, RmE_PartialSuccess indicate partial success, 
***    or an error code. In the first two cases read in a network
*** 4) in the template, fill in the appropriate mapping info.
**/

static		int RmObtainAux1(RmProcessor Processor, ...);
static		int RmObtainAux2(RmProcessor Processor, ...);

RmNetwork	RmObtainNetwork(RmNetwork network, bool exact, int *rc_ptr)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  CheckNetworkFail(network, (RmNetwork) NULL);

  unless(network->Root eq (RmSet) network)
   return(network->Errno = RmErrno = RmE_NotRootNetwork, (RmNetwork) NULL);
   
  if ((rc = RmSearchProcessors(network, &RmObtainAux1)) ne RmE_Success)
   goto done;

  Clear(request); Clear(reply);
  request.FnRc		= (exact) ? RmC_ObtainExactNetwork : RmC_ObtainNetwork;
  request.Arg1		= RmStartSearchHere;
  request.Network	= network;

  rc = RmXch(&RmParent, &request, &reply);

  (void) RmApplyProcessors(reply.Network, &RmObtainAux2, network);

done:
  if (rc_ptr ne Null(int)) *rc_ptr = rc;
  if (rc ne RmE_Success) RmErrno = network->Errno = rc;
  return(reply.Network);
}

static		int RmObtainAux1(RmProcessor processor, ...)
{ 
  if ((processor->StructType ne RmL_New) &&
      (processor->StructType ne RmL_Existing))
   return(RmE_BadArgument);

  processor->MappedTo = 0;  
  return(0);
}

static		int RmObtainAux2(RmProcessor processor, ...)
{ va_list	args;
  RmNetwork	Template;
  RmProcessor	match;
  
  va_start(args, processor);
  Template = va_arg(args, RmNetwork);
  va_end(args);

	/* it is possible to get a processor without asking */
  if (processor->MappedTo eq 0) return(RmE_Success);

  match = RmFindProcessor(Template, processor->MappedTo);
  if (match ne (RmProcessor) NULL)
   match->MappedTo = processor->Uid;
  return(RmE_Success);
}


static	int	RmObtainProcessorsAux2(RmProcessor, ...);

RmNetwork RmObtainProcessors(int count, RmProcessor *processors, bool exact, int *rc_ptr)
{ RmJob		job;
  int		rc;
  RmNetwork	result = (RmNetwork) NULL;
  Stream	*pipe;
  bool		got_job = FALSE;
  int		real_count, i;
  RmRequest	request;
  RmReply	reply;

  if (processors eq Null(RmProcessor))
   return(RmErrno = RmE_BadArgument, (RmNetwork) NULL);
   
  for (real_count = 0, i = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    { if (processors[i]->ObjNode.Type ne Type_Processor)
       return(RmErrno = RmE_BadArgument, (RmNetwork) NULL);
      elif ((processors[i]->StructType ne RmL_New) &&
            (processors[i]->StructType ne RmL_Existing))
        return(RmErrno = RmE_BadArgument, (RmNetwork) NULL);
      else
       { real_count++;
         processors[i]->MappedTo = 0;
       }
    }

  if (real_count eq 0)
   { if ((result = RmNewNetwork()) eq (RmNetwork) NULL)
      RmErrno = RmE_NoMemory;
     return(result);
   }
    
  rc		= RmNewJob(&RmParent, &job);
  if (rc ne RmE_Success) goto done;
  got_job	= TRUE;
  pipe		= job->Server->Pipe_ctos;

  Clear(request); Clear(reply);
  request.FnRc		= (exact) ? RmC_ObtainExactProcessors : RmC_ObtainProcessors;
  request.Arg1		= RmStartSearchHere;
  request.Arg2		= real_count;

  if ((rc = RmTx(job, &request)) ne RmE_Success)
   goto done;
  for (i = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    if ((rc = RmWriteProcessor(pipe, processors[i], (RmFilter) NULL)) 
        ne RmE_Success)
     { RmUnlockWrite(job); goto done; }

  rc = RmRx(job, &reply);
  if ((rc ne RmE_Success) && (rc ne RmE_PartialSuccess)) goto done;

  (void) RmApplyProcessors(result, &RmObtainProcessorsAux2, processors, count);

done:
  if (got_job) RmFinishedJob(job);
  if (rc_ptr ne Null(int)) *rc_ptr = rc;
  if (rc ne RmE_Success) RmErrno = rc;
  return(reply.Network);
}

static	int	RmObtainProcessorsAux2(RmProcessor processor, ...)
{ va_list	args;
  RmProcessor	*Template;
  int		i, count;
    
  va_start(args, processor);
  Template = va_arg(args, RmProcessor *);
  count	   = va_arg(args, int);
  va_end(args);
  
  if (processor->MappedTo eq 0) return(RmE_Success);
  for (i = 0; i < count; i++)
   if (Template[i] ne (RmProcessor) NULL)
    if (Template[i]->Uid eq processor->MappedTo)
     Template[i]->MappedTo = processor->Uid;
    
  return(RmE_Success);
}

/*}}}*/
/*{{{  Releasing a network of processors */

/**-----------------------------------------------------------------------------
*** Releasing a network. This involves sending the uid and capability for
*** every processor in the network.
**/

static int	RmReleaseAux1(RmProcessor processor, ...);

int		RmReleaseNetwork(RmNetwork network) 
{ int			rc;
  RmRequest		request;
  RmReply		reply;
  int			count;

  CheckNetwork(network);
  unless(network->Root eq (RmSet) network)
   return(network->Errno = RmErrno = RmE_NotRootNetwork);
   
  count = RmCountProcessors(network);
  if (count eq 0)
   return(RmE_Success);
  elif (count < 0)
   return(RmE_NotNetwork);

  Clear(request); Clear(reply);
  request.VariableSize = count * sizeof(ProcessorDetails);
  request.VariableData = (char *)Malloc(request.VariableSize);
  if (request.VariableData eq NULL)
   return(RmE_NoMemory);

  count		= 0;
  rc	= RmApplyProcessors(network, &RmReleaseAux1, request.VariableData, &count);
  if (rc ne RmE_Success)
   { Free(request.VariableData); return(rc); }
  request.FnRc	= RmC_ReleaseNetwork;
  request.Arg1	= count;

  rc = RmXch(&RmParent, &request, &reply);
  Free(request.VariableData);
  if (rc ne RmE_Success) RmErrno = network->Errno = rc;
  return(rc);
}

static int RmReleaseAux1(RmProcessor processor, ...)
{ va_list		args;
  ProcessorDetails	*details;
  int			*count;
  
  va_start(args, processor);
  details	= va_arg(args, ProcessorDetails *);
  count		= va_arg(args, int *);
  va_end(args);
  
  if (processor->StructType ne RmL_Obtained) return(RmE_NoAccess);
  details[*count].Uid	= processor->Uid;
  details[*count].Cap	= processor->NsCap;
  *count += 1;

  processor->StructType = RmL_Existing;
  return(RmE_Success);
}

/*}}}*/
/*{{{  Link stuff */
/**
*** Manipulating link modes
**/
int		RmGetLinkMode(RmProcessor processor, int link, int *mode)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  CheckProcessor(processor);  

  if ((processor->StructType ne RmL_Existing) &&
      (processor->StructType ne RmL_Obtained))
   return(RmErrno = RmE_BadArgument);
  if ((link < 0) || (link > processor->Connections) || (mode eq Null(int)))
   return(RmErrno = RmE_BadArgument);

  Clear(request); Clear(reply);
  request.FnRc	= RmC_GetLinkMode;
  request.Uid	= processor->Uid;
  request.Arg1	= link;
  rc = RmXch(&RmNetworkServer, &request, &reply);

  if (rc ne RmE_Success) 
   RmErrno = processor->Errno = rc;
  else
   *mode = reply.Reply1;

  return(rc);
}

int		RmSetLinkMode(RmProcessor processor, int link, int mode)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  CheckProcessor(processor);  

  if ((processor->StructType ne RmL_Existing) &&
      (processor->StructType ne RmL_Obtained))
   return(RmErrno = processor->Errno = RmE_BadArgument);
  if ((link < 0) || (link > processor->Connections) ||
      (mode < RmL_NotConnected) || (mode > RmL_Dead))
   return(RmErrno = RmE_BadArgument);

  Clear(request); Clear(reply);
  request.FnRc	= RmC_SetLinkMode;
  request.Uid	= processor->Uid;
  request.Arg1	= link;
  request.Arg2	= mode;
  rc = RmXch(&RmNetworkServer, &request, &reply);
  if (rc ne RmE_Success) RmErrno = processor->Errno = rc;
  return(rc);
}
/*}}}*/
/*{{{  Reporting problems */
/**-----------------------------------------------------------------------------
*** Reporting problems.
**/
int RmReportProcessor(RmProcessor processor)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  CheckProcessor(processor);
  if ((processor->StructType ne RmL_Existing) &&
      (processor->StructType ne RmL_Obtained))
   return(RmErrno = processor->Errno = RmE_BadArgument);

  Clear(request); Clear(reply);
  request.FnRc	= RmC_ReportProcessor;
  request.Uid	= processor->Uid;
  rc = RmXch(&RmParent, &request, &reply);
  if (rc ne RmE_Success) RmErrno = processor->Errno = rc;
  return(rc);
}
/*}}}*/
/*{{{  Examining the current task/taskforce */
/**----------------------------------------------------------------------------
*** Examining the current taskforce/task.
**/

RmTaskforce RmGetTaskforce(void)
{ RmRequest	request;
  RmReply	reply;
  int		result;
  Environ	*env	= getenviron();
  Object	*tf  	= env->Objv[OV_TForce];

  if ((tf eq Null(Object)) || (tf eq (Object *) MinInt))
   return(RmErrno = RmE_NotTaskforce, (RmTaskforce) NULL);
  { char *tmp = objname(tf->Name);
    if (strncmp(&(tmp[-5]), "/tfm/", 5))
     return(RmErrno = RmE_NotTaskforce, (RmTaskforce) NULL);
  }

  Clear(request); Clear(reply);
  request.FnRc		= RmC_GetTaskforce;
  request.VariableData	= objname(tf->Name);
  request.VariableSize	= strlen(request.VariableData) + 1;
  result		= RmXch(&RmParent, &request, &reply);

  if (result eq RmE_Success)
   return(reply.Taskforce);
  else
   { RmErrno = result; return((RmTaskforce) NULL); }
}

RmTask RmGetTask(void)
{ RmRequest	request;
  RmReply	reply;
  int		result;
  Environ	*env	= getenviron();
  Object	*tf  	= env->Objv[OV_TForce];

  if ((tf eq Null(Object)) || (tf eq (Object *) MinInt))
   return(RmErrno = RmE_NotTask, (RmTask) NULL);
  { char *tmp = objname(tf->Name);
    if (strcmp(&(tmp[-5]), "/tfm/"))
     return(RmErrno = RmE_NotTask, (RmTask) NULL);
  }

  Clear(request); Clear(reply);
  request.FnRc		= RmC_GetTask;
  request.VariableData	= objname(tf->Name);
  request.VariableSize	= strlen(request.VariableData + 1);
  result		= RmXch(&RmParent, &request, &reply);

  if (result eq RmE_Success)
   return(reply.Task);
  else
   { RmErrno = result; return((RmTask) NULL); }
}  
/*}}}*/
/*{{{  Task and taskforce execution */

/*{{{  Execution */

/**-----------------------------------------------------------------------------
*** Executing tasks and taskforces
**/
/*{{{  Environment */

/**
*** Constructing environment information. This is similar but not identical
*** to the environment construction in execve() (posix/exec.c) and the
*** system library routine SendEnv() (nucleus/syslib/task.c), munged
*** together. The aim is to construct a single vector with all the
*** required environment information, which can be sent off in the
*** execution request.
***
*** a) determine the size of the required vector. This involves scanning
***     1) the supplied argument vector
***     2) the current program's environment vector
***     3) the current program's context, i.e. the object vector. Only some
***        of the objects should be passed, but space in the control vector
***        is still required for the remainder to make life easier for the TFM
***     4) standard streams
***    Note that all of the data structures will have to be aligned to
***    word boundaries.
*** b) allocate a suitable vector
*** c) put all the data in the vector. This uses the system library's
***    marshalling routines  so an MCB is faked up.
*** d) put the data vector and the size in the request.
**/
static int  count_object_size(Object **, int);
static void add_object(MCB *, Object **, int);

static bool buildenv(RmRequest *request, char **argv)
{ int		  argc, envc, objc, strc;
  int		  args, envs, objs, strs;
  Environ	 *my_environ = getenviron();
  char		**my_envv;
  Object	**my_objv;
  BYTE		 *datavec;
  int		  datasize;
  int		  i, j;
  MCB		  m;

  if (argv eq NULL)
   argc = args = 0;
  else
   for (i = 0, argc = 0, args = 0; argv[i] ne Null(char); i++, argc++)
    args = wordlen(args + strlen(argv[i]) + 1);

  my_envv = my_environ->Envv;
  for (i = 0, envc = 0, envs = 0; my_envv[i] ne Null(char); i++, envc++)
   envs = wordlen(envs + strlen(my_envv[i]) + 1);

	/* The following objects need to be sent: Cdir, Parent, Home,	  */
	/* Console, CServer, Session, TFM. The TFM takes care of the rest */
  my_objv = my_environ->Objv;
  objc = OV_End;
  objs = count_object_size(my_objv, OV_Cdir) +
  	 count_object_size(my_objv, OV_Task) +
  	 count_object_size(my_objv, OV_Home) +
  	 count_object_size(my_objv, OV_Console) +
  	 count_object_size(my_objv, OV_CServer) +
	 count_object_size(my_objv, OV_Session) +
	 count_object_size(my_objv, OV_TFM);

	 /* Only stdin, stdout, stderr, and stdlog are inherited. Care	*/
	 /* has to be taken with replicated streams. The library has no	*/
	 /* access to the CloseOnExec flag, so there is no simple way	*/
	 /* of implementing the full inheritance.			*/
  strc = 4; strs = 0;
  { Stream	*stream_tab[4];
    for (i = 0; i < 4; i++)
     { if ((stream_tab[i] = fdstream(i)) eq Null(Stream))
        continue;
       else
        { for (j = 0; j < i; j++)
           if (stream_tab[j] eq stream_tab[i])
            { stream_tab[j] = (Stream *) MinInt;
              goto skipstream;
            }  
 	  strs += sizeof(StrDesc) + strlen(stream_tab[i]->Name);
	  strs = wordlen(strs);
 	}
skipstream:
       j = i;
     }
  }

	/* Allocate the necessary amount of space	*/
  datasize  = sizeof(WORD) * (argc + envc + objc + strc +4);
  datasize += args + envs + strs + objs;
  datavec   = (BYTE *)Malloc(datasize);
  if (datavec eq NULL)
   return(FALSE);

	/* Initialise an MCB to allow marshalling	*/
  m.MsgHdr.ContSize = m.MsgHdr.DataSize = 0;
  m.Control = (WORD *) datavec;
  m.Data    = &(datavec[sizeof(WORD) * (argc + envc + strc + objc + 4)]);

  if (argv ne NULL)
   { for (i = 0; i < argc; i++)
      if (*(argv[i]) ne '\0')	/* test for empty string */
       MarshalString(&m, argv[i]);
      else
       { word  zero = 0;
         MarshalOffset(&m);
         MarshalData(&m, 4, (BYTE *) &zero);
       }
   }
  MarshalWord(&m, -1);

  my_envv = my_environ->Envv;
  for (i  = 0; i < envc; i++)
   MarshalString(&m, my_envv[i]);
  MarshalWord(&m, -1);

  my_objv = my_environ->Objv;
  add_object(&m, my_objv, OV_Cdir);
  MarshalWord(&m, MinInt);		/* OV_Task   */
  MarshalWord(&m, MinInt);		/* OV_Code   */
  MarshalWord(&m, MinInt);		/* OV_Source */
  add_object(&m, my_objv, OV_Task);	/* OV_Parent */
  add_object(&m, my_objv, OV_Home);
  add_object(&m, my_objv, OV_Console);
  add_object(&m, my_objv, OV_CServer);
  add_object(&m, my_objv, OV_Session);
  add_object(&m, my_objv, OV_TFM);
  MarshalWord(&m, MinInt);		/* OV_TForce */
  MarshalWord(&m, -1);

  { Stream	*stream_tab[4];
    for (i = 0; i < 4; i++)
     { if ((stream_tab[i] = fdstream(i)) eq Null(Stream))
        { MarshalWord(&m, MinInt); continue; }
       for (j = 0; j < i; j++)
        if (stream_tab[j] eq stream_tab[i])
         { MarshalWord(&m, (0xFFFF0000L | (word)j)); goto skip_stream2; }
       MarshalStream(&m, stream_tab[i]);
skip_stream2:
       j = i;
     }
  }
  MarshalWord(&m, -1);

	/* And put the vector into the request		*/
  request->VariableData	= datavec;
  request->VariableSize	= datasize;
  return(TRUE);
}

static int count_object_size(Object **my_objv, int index)
{ int	i, result;
  for (i = 0; i <= index; i++)
   if (my_objv[i] eq NULL)
    return(0);
  if (my_objv[index] eq (Object *) MinInt)
   return(0);
  result = sizeof(ObjDesc) + strlen(my_objv[index]->Name);
  return(wordlen(result));
}

static void add_object(MCB *m, Object **my_objv, int index)
{ int i;

  for (i = 0; i <= index; i++)
   if (my_objv[i] eq NULL)
    { MarshalWord(m, MinInt); return; }

  if (my_objv[index] ne (Object *) MinInt)
   MarshalObject(m, my_objv[index]);
  else
   MarshalWord(m, MinInt);
}

/*}}}*/
/*{{{  Single task */
/**
*** Executing a single task.
*** a) the task must not be running or have terminated already
*** b) if a processor is specified then this processor must have been
***    obtained.
*** c) the request is constructed. The TFM is going to need full details
***    of the task, plus the uid and capability of the processor if any
*** d) the environment information is gathered together
*** e) the request is sent off to the TFM. The reply should be another
***    task structure with type RmL_Executing
**/
RmTask	RmExecuteTask(RmProcessor processor, RmTask task, char **argv)
{ RmRequest	request;
  RmReply	reply;
  int		rc;
  
  Clear(request); Clear(reply);
  
  CheckTaskFail(task, (RmTask) NULL);
  unless(task->StructType eq RmL_New)
   return(RmErrno = task->Errno = RmE_InUse, (RmTask) NULL);

  if (processor ne (RmProcessor) NULL)
   { if (processor->ObjNode.Type ne Type_Processor)
      return(RmErrno = task->Errno = RmE_NotProcessor, (RmTask) NULL);
     unless(processor->StructType eq RmL_Obtained)
      return(RmErrno = task->Errno = RmE_NoAccess, (RmTask) NULL);
   }

  request.FnRc		= RmC_Execute;
  request.Task		= task;
  request.Uid		= processor->Uid;
  request.Cap		= processor->NsCap;
  unless(buildenv(&request, argv))
   return(RmErrno = task->Errno = RmE_BadArgument, (RmTask) NULL);

  rc = RmXch(&RmParent, &request, &reply);
  Free(request.VariableData);
  if (rc ne RmE_Success) RmErrno = task->Errno = rc;
  return(reply.Task);
}

/*}}}*/
/*{{{  Taskforce */
/**
*** Executing a taskforce is very similar. In this case the various components'
*** mapped processors have to be checked using an RmSearch. The whole network
*** is sent off to the TFM.
**/
static int RmExecuteTaskforce_aux1(RmTask task, ...);

RmTaskforce RmExecuteTaskforce(RmNetwork network, RmTaskforce taskforce, char **argv)
{ RmRequest	request;
  RmReply	reply;
  int		rc;

  Clear(request); Clear(reply);

  CheckTaskforceFail(taskforce, (RmTaskforce) NULL);
  unless(taskforce->StructType eq RmL_New)
   return(RmErrno = taskforce->Errno = RmE_InUse, (RmTaskforce) NULL);

  if (network ne (RmNetwork) NULL)
   if (network->DirNode.Type ne Type_Network)
    return(RmErrno = RmE_NotNetwork, (RmTaskforce) NULL);

  rc = RmSearchTasks(taskforce, &RmExecuteTaskforce_aux1, network);
  if (rc ne RmE_Success)
   return(RmErrno = taskforce->Errno = rc, (RmTaskforce) NULL);

  request.FnRc		= RmC_Execute;
  request.Taskforce	= taskforce;
  request.Network	= network;
  unless(buildenv(&request, argv))
   return(RmErrno = taskforce->Errno = RmE_BadArgument, (RmTaskforce) NULL);

  rc = RmXch(&RmParent, &request, &reply);
  Free(request.VariableData);
  if (rc ne RmE_Success) RmErrno = taskforce->Errno = rc;
  return(reply.Taskforce);
}

static int RmExecuteTaskforce_aux1(RmTask task, ...)
{ va_list	args;
  RmNetwork	network;
  RmProcessor	processor;

  va_start(args, task);
  network = va_arg(args, RmNetwork);
  va_end(args);

  unless(task->StructType eq RmL_New)
   return(RmErrno = task->Errno = RmE_InUse);

  if ((network ne (RmNetwork) NULL) && (task->MappedTo ne RmL_NoUid))
   { processor = RmFindProcessor(network, task->MappedTo);
     if (processor eq (RmProcessor) NULL)
      return(RmErrno = task->Errno = RmE_NotProcessor);
     unless (processor->StructType eq RmL_Obtained)
      return(RmErrno = task->Errno = RmE_NoAccess);
   }

  return(RmE_Success);
}

/*}}}*/

/*}}}*/
/*{{{  Status */

/**
*** Return codes, checking tasks whether they are still running, etc.
*** 1) if the relevant task or taskforce is of type RmL_New then it has
***    not been submitted to the TFM, so the request is illegal.
*** 2) if the relevant task or taskforce is of type RmL_Done then
***    the TFM has already informed this client about the termination.
***    Hence the routine can return immediately.
*** 3) if the relevant task or taskforce is of type RmL_Executing then
***    things are a bit more complicated:
***    a) it is necessary to update the task or taskforce, i.e. give the
***       TFM a chance to fill in termination status and return code. For
***       some requests this operation should block if the task is still
***       running.
***    b) if the TFM does not know about the relevant task or taskforce then
***       chances are that the object has already disappeared.
***    c) otherwise the TFM does the necessary work.
**/
static int update_tasks(int, RmTask *, bool wait);

int	RmGetTaskReturncode(RmTask task)
{ int	rc;

  CheckTaskFail(task, -1);
  unless((task->StructType eq RmL_Executing) || (task->StructType eq RmL_Done))
   return(RmErrno = task->Errno = RmE_BadArgument, -1);
   
  if (task->StructType eq RmL_Executing)
   if ((rc= update_tasks(1, &task, FALSE)) ne RmE_Success)
    return(RmErrno = task->Errno = rc, -1);

  if (task->StructType eq RmL_Executing)
   return(RmErrno = task->Errno = RmE_InUse, -1);
  else
   return(task->ReturnCode);
}

int	RmGetTaskforceReturncode(RmTaskforce taskforce)
{ int	rc;

  CheckTaskforceFail(taskforce, -1);
  unless((taskforce->StructType eq RmL_Executing) ||
         (taskforce->StructType eq RmL_Done))
   return(RmErrno = taskforce->Errno = RmE_BadArgument, -1);

  if (taskforce->StructType eq RmL_Executing)
   if ((rc = update_tasks(1, (RmTask *) &taskforce, FALSE)) ne RmE_Success)
    return(RmErrno = taskforce->Errno = rc, -1);

  if (taskforce->StructType eq RmL_Executing)
   return(RmErrno = taskforce->Errno = RmE_InUse, -1);
  else  
   return(taskforce->ReturnCode);
}

bool	RmIsTaskRunning(RmTask task)
{ int	rc;

  CheckTaskFail(task, FALSE);
  unless((task->StructType eq RmL_Executing) || (task->StructType eq RmL_Done))
   return(RmErrno = task->Errno = RmE_BadArgument, FALSE);
   
  if (task->StructType eq RmL_Executing)
   if ((rc = update_tasks(1, &task, FALSE)) ne RmE_Success)
    return(RmErrno = task->Errno = rc, FALSE);

  if (task->StructType eq RmL_Executing)
   return(TRUE);
  else
   return(FALSE);
}

bool	RmIsTaskforceRunning(RmTaskforce taskforce)
{ int rc;

  CheckTaskforceFail(taskforce, FALSE);
  unless((taskforce->StructType eq RmL_Executing) ||
         (taskforce->StructType eq RmL_Done))
   return(RmErrno = taskforce->Errno = RmE_BadArgument, FALSE);

  if (taskforce->StructType eq RmL_Executing)
   if ((rc = update_tasks(1, (RmTask *) &taskforce, FALSE)) ne RmE_Success)
    return(RmErrno = taskforce->Errno = rc, FALSE);

  if (taskforce->StructType eq RmL_Executing)
   return(TRUE);
  else  
   return(FALSE);
}

int	RmWaitforTask(RmTask task)
{ int	rc;

  CheckTask(task);
  unless((task->StructType eq RmL_Executing) || (task->StructType eq RmL_Done))
   return(RmErrno = task->Errno = RmE_BadArgument);
   
  if (task->StructType eq RmL_Executing)
   if ((rc = update_tasks(1, &task, TRUE)) ne RmE_Success)
    return(RmErrno = task->Errno = rc);

  if (task->StructType eq RmL_Done)
   return(RmE_Success);
  else
   return(RmE_BadArgument);
}

int	RmWaitforTaskforce(RmTaskforce taskforce)
{ int	rc;

  CheckTaskforce(taskforce);
  unless((taskforce->StructType eq RmL_Executing) ||
         (taskforce->StructType eq RmL_Done))
   return(RmErrno = taskforce->Errno = RmE_BadArgument);

  if (taskforce->StructType eq RmL_Executing)
   if ((rc = update_tasks(1, (RmTask *) &taskforce, TRUE)) ne RmE_Success)
    return(RmErrno = taskforce->Errno = rc);

  if (taskforce->StructType eq RmL_Done)
   return(RmE_Success);
  else  
   return(RmE_BadArgument);
}


int	RmWaitforTasks(int count, RmTask *tasks)
{ int		i;
  int		rc;
  
  for (i = 0; i < count; i++)
   { RmTask	task = tasks[i];
     if (task eq (RmTask) NULL) continue;
     if (task->ObjNode.Type ne Type_Task) return(RmE_NotTask);
     if (task->StructType eq RmL_Done)
      return(RmE_Success);
     if (task->StructType ne RmL_Executing)
      return(RmErrno = task->Errno = RmE_BadArgument);
   }

  if ((rc = update_tasks(count, tasks, TRUE)) ne RmE_Success)
   return(RmErrno = rc);

  for (i = 0; i < count; i++)
   { RmTask	task = tasks[i];
     if (task eq (RmTask) NULL) continue;
     if (task->StructType eq RmL_Done) return(RmE_Success);
   }
  return(RmErrno = RmE_BadArgument);
}

/**
*** Waiting for any component task to finish involves building up a table
*** of all the component tasks.
**/
static int RmWaitforAnyTask_aux1(RmTask, ...);

int	RmWaitforAnyTask(RmTaskforce taskforce)
{ int		number_tasks	= RmCountTasks(taskforce);
  RmTask	*task_table	= Null(RmTask);
  int		rc;
  int		i;
  
  CheckTaskforce(taskforce);
  if (number_tasks eq 0) return(RmE_Success);
  task_table = (RmTask *)Malloc((word) number_tasks * sizeof(RmTask));
  if (task_table eq Null(RmTask))
   return(RmErrno = taskforce->Errno = RmE_NoMemory);

  i = 0;
  (void) RmApplyTasks(taskforce, &RmWaitforAnyTask_aux1, task_table, &i);

  rc = RmWaitforTasks(number_tasks, task_table);
  Free(task_table);
  return(rc);
}

static int RmWaitforAnyTask_aux1(RmTask task, ...)
{ va_list	args;
  RmTask	*task_table;
  int		*i_ptr;
  
  va_start(args, task);
  task_table = va_arg(args, RmTask *);
  i_ptr	     = va_arg(args, int *);
  va_end(args);

  task_table[*i_ptr] = task;
  *i_ptr += 1;
  return(0);
}

/**
*** Update the information associated with one or more tasks or taskforces.
*** If an entire taskforce has terminated then all its components should
*** be set to terminated using an RmApply.
**/
static int update_tasks_aux1(RmTask task, ...)
{ task->StructType = RmL_Done;
  return(0);
}

static int update_tasks(int count, RmTask *tasks, bool wait)
{ RmRequest	request;
  RmReply	reply;
  int		rc;
  int		i;
  TaskDetails	*details = (TaskDetails *)Malloc((word) count * sizeof(TaskDetails));
  TaskUpdate	*info;

  if (details eq Null(TaskDetails)) return(RmE_NoMemory);
  for (i = 0; i < count; i++)
   { RmTask	task = tasks[i];

     if (task eq (RmTask) NULL)
      details[i].Name[0] = '\0';
     elif (task->ObjNode.Type eq Type_Taskforce)
      { RmTaskforce taskforce = (RmTaskforce) task;
        strcpy(details[i].Name, taskforce->DirNode.Name);
        details[i].Uid = RmL_NoUid;
        details[i].Cap = taskforce->TfmCap;
      }
     elif (task->Root eq (RmTaskforce) NULL)
      { strcpy(details[i].Name, task->ObjNode.Name);
	details[i].Uid = RmL_NoUid;
	details[i].Cap = task->TfmCap;
      }
     else
      { RmTaskforce taskforce = task->Root;
        strcpy(details[i].Name, taskforce->DirNode.Name);
        details[i].Uid = task->Uid;
        details[i].Cap = task->TfmCap;
      }
   }
     
  Clear(request); Clear(reply);
  if (wait)
   request.FnRc		= RmC_Wait;
  else
   request.FnRc		= RmC_Update;
  request.VariableData	= (BYTE *) details;
  request.VariableSize	= count * sizeof(TaskDetails);

  rc = RmXch(&RmParent, &request, &reply);
  Free(details);
  if (rc ne RmE_Success) return(rc);

  info = (TaskUpdate *) reply.VariableData;
  for (i = 0; i < count; i++)
   { RmTask	task    = tasks[i];
     TaskUpdate	*update = &(info[i]);

     if (task eq (RmTask) NULL)    continue;
     if (update->Errno eq RmE_Skip) continue;

     if (task->ObjNode.Type eq Type_Taskforce)
      { RmTaskforce taskforce = (RmTaskforce) task;
        if (update->Errno ne RmE_Success)
         taskforce->Errno = update->Errno;
        taskforce->StructType = update->StructType;
        taskforce->ReturnCode = update->ReturnCode;
        if (taskforce->StructType eq RmL_Done)
         (void) RmApplyTasks(taskforce, &update_tasks_aux1);
      }
     else
      { if (update->Errno ne RmE_Success)
         task->Errno = update->Errno;
        task->StructType = update->StructType;
        task->ReturnCode = update->ReturnCode;
      }
   }
  Free(info);
  return(RmE_Success);
}

/*}}}*/
/*{{{  Detaching */
int	RmLeaveTask(RmTask task)
{ RmRequest	request;
  RmReply	reply;
  TaskDetails	details;
  
  CheckTask(task);
  unless(task->StructType eq RmL_Executing)
   return(RmErrno = task->Errno = RmE_BadArgument);
  if (task->Root ne (RmTaskforce) NULL)
   return(RmErrno = task->Errno = RmE_InUse);
   
  Clear(request); Clear(reply);
  request.FnRc		= RmC_Leave;
  strcpy(details.Name, task->ObjNode.Name);
  details.Uid		= RmL_NoUid;
  details.Cap		= task->TfmCap;
  request.VariableData	= (BYTE *) &details;
  request.VariableSize	= sizeof(TaskDetails);
  return(RmXch(&RmParent, &request, &reply));
}

int	RmLeaveTaskforce(RmTaskforce taskforce)
{ RmRequest	request;
  RmReply	reply;
  TaskDetails	details;
  
  CheckTaskforce(taskforce);
  unless(taskforce->StructType eq RmL_Executing)
   return(RmErrno = taskforce->Errno = RmE_BadArgument);
  if (taskforce->Root ne (RmSet) taskforce)
   return(RmErrno = taskforce->Errno = RmE_NotRootTaskforce);
   
  Clear(request); Clear(reply);
  request.FnRc	= RmC_Leave;
  strcpy(details.Name, taskforce->DirNode.Name);
  details.Uid	= RmL_NoUid;
  details.Cap	= taskforce->TfmCap;
  request.VariableData	= (BYTE *) &details;
  request.VariableSize	= sizeof(TaskDetails);
  return(RmXch(&RmParent, &request, &reply));
}

/*}}}*/
/*{{{  Signals */
int	RmSendTaskSignal(RmTask task, int signo)
{ RmRequest	request;
  RmReply	reply;
  TaskDetails	details;

  CheckTask(task);
  unless(task->StructType eq RmL_Executing)
   return(RmErrno = task->Errno = RmE_BadArgument);

  Clear(request); Clear(reply);
  if (task->Root eq (RmTaskforce) NULL)
   { strcpy(details.Name, task->ObjNode.Name);
     details.Uid	= RmL_NoUid;
     details.Cap	= task->TfmCap;
   }
  else
   { RmTaskforce taskforce = task->Root;
     strcpy(details.Name, taskforce->DirNode.Name);
     details.Uid	= task->Uid;
     details.Cap	= task->TfmCap;
   }
  request.FnRc		= RmC_SendSignal;
  request.Arg1		= signo;
  request.VariableData	= (BYTE *) &details;
  request.VariableSize	= sizeof(TaskDetails);
  return(RmXch(&RmParent, &request, &reply));
}

int	RmSendTaskforceSignal(RmTaskforce taskforce, int signo)
{ RmRequest	request;
  RmReply	reply;
  TaskDetails	details;
  
  CheckTaskforce(taskforce);
  unless(taskforce->StructType eq RmL_Executing)
   return(RmErrno = taskforce->Errno = RmE_BadArgument);

  Clear(request); Clear(reply);
  strcpy(details.Name, taskforce->DirNode.Name);
  details.Uid	= RmL_NoUid;
  details.Cap	= taskforce->TfmCap;

  request.FnRc		= RmC_SendSignal;
  request.Arg1		= signo;
  request.VariableData	= (BYTE *) &details;
  request.VariableSize	= sizeof(TaskDetails);
  return(RmXch(&RmParent, &request, &reply));
}
/*}}}*/
/*{{{  Task->Taskforce */

/**
*** Converting a task to a taskforce requires the following:
*** 1) check that the arguments are valid
*** 2) check that the controller is part of the taskforce
*** 3) set the TfmFlags_Special flag in the controller
*** 4) add a puid attribute to the controller identifying the task. This
***    is necessary to let the TFM monitor the task correctly.
*** 5) do an RmExecuteTaskforce() to make the TFM do the hard work
*** 6) modify the OV_TForce entry in the environment to reflect that this
***    program is now part of a taskforce.
**/
RmTaskforce	RmConvertTaskToTaskforce(RmTask controller, RmTaskforce taskforce)
{ char		*tid		= NULL;
  Environ	*env		= getenviron();
  Object	*this_task	= env->Objv[OV_Task];
  int		 rc;
  RmTaskforce	 result;
  Object	*new_taskforce;

  CheckTaskFail(controller, NULL);
  CheckTaskforceFail(taskforce, NULL);

  if (RmRootTaskforce(controller) ne taskforce)
   { RmErrno = RmE_WrongTaskforce; return(NULL); }

  controller->ObjNode.Flags |= 0x08000000;	/* see tfmaux.h */
  tid = (char *)Malloc(4 + 17 + 1 + (word) strlen(this_task->Name));
  if (tid eq NULL)
   { RmErrno = RmE_NoMemory; return(NULL); }
  strcpy(tid, "tid=");
  DecodeCapability(&(tid[4]), &(this_task->Access));
  strcpy(&(tid[21]), this_task->Name);
  rc = RmAddObjectAttribute((RmObject) controller, tid, TRUE);
  Free(tid);
  if (rc ne RmE_Success)
   { RmErrno = rc; return(NULL); }
  
  result = RmExecuteTaskforce(NULL, taskforce, NULL);
  if (result eq NULL) return(NULL);

  new_taskforce = Locate(env->Objv[OV_TFM], result->DirNode.Name);
  if (new_taskforce eq NULL) return(result);	/* BLV recovery ??? */

  if (env->Objv[OV_TForce] ne (Object *) MinInt)
   Close(env->Objv[OV_TForce]);
  env->Objv[OV_TForce] = new_taskforce;
  return(result);
}

/*}}}*/

/*}}}*/
#ifdef __TRAN
/*{{{  Native network support */
/**----------------------------------------------------------------------------
*** Native network support
**/

static	bool	CheckConnections(int count, LinkConnection *, bool, bool);
static	int	MakeConnections(int count, LinkConnection *, bool, bool);

bool	RmIsLinkPossible(RmProcessor source, int sourcelink, RmProcessor dest,
		int destlink)
{ LinkConnection	conn;

  CheckProcessorFail(source, FALSE);
  if ((source->StructType ne RmL_Existing) &&
      (source->StructType ne RmL_Obtained))
   return(RmErrno = source->Errno = RmE_BadProcessor, FALSE);

  if ((sourcelink < 0) || (sourcelink >= source->Connections))
   return(RmErrno = source->Errno  = RmE_BadLink, FALSE);

  conn.SourceUid	= source->Uid;
  conn.SourceCap	= source->NsCap;
  conn.SourceLink	= sourcelink;
 
  if (dest eq RmM_ExternalProcessor)
   { conn.DestUid	= RmL_ExtUid;
     conn.DestLink	= destlink;
   }
  else
   { CheckProcessorFail(dest, FALSE);
     if ((dest->StructType ne RmL_Existing) &&
         (dest->StructType ne RmL_Obtained))
      return(RmErrno = dest->Errno = RmE_BadProcessor, FALSE);
     if ((destlink < 0) || (destlink >= dest->Connections))
      return(RmErrno = dest->Errno = RmE_BadLink, FALSE);

     conn.DestUid	= dest->Uid;
     conn.DestCap	= dest->NsCap;
     conn.DestLink	= destlink;
   }

  return(CheckConnections(1, &conn, TRUE, TRUE));    
}

static	int Plausibility_aux1(RmProcessor processor, ...);
static	int Plausibility_aux2(RmProcessor processor, ...);

bool	RmIsNetworkPossible(RmNetwork network, bool exact, bool preserve)
{ LinkConnection	*conns;
  int			rc;
  int			conns_count = 0;
  bool			result;
      
  CheckNetworkFail(network, FALSE);
  unless(network->Root eq (RmSet) network)
   return(network->Errno = RmErrno = RmE_NotRootNetwork);
   
  rc = RmSearchProcessors(network, &Plausibility_aux1, &conns_count);
  if (rc ne RmE_Success)
   return(RmErrno = rc, FALSE);
   
  conns = Malloc(conns_count * sizeof(LinkConnection));
  if (conns eq Null(LinkConnection))
   return(RmErrno = RmE_NoMemory, FALSE);
   
  conns_count = 0;
  rc = RmSearchProcessors(network, &Plausibility_aux2, conns, &conns_count);
  if (rc ne RmE_Success)
   { Free(conns);
     return(RmErrno = rc, FALSE);
   }

  result = CheckConnections(conns_count, conns, exact, preserve);
  Free(conns);
  return(result);
}

bool	RmAreProcessorsPossible(int count, RmProcessor *processors, bool exact,
		bool preserve)
{ int			real_count, i;
  int			rc;
  int			conns_count;
  bool			result;
  LinkConnection	*conns;
      
  if (processors eq Null(RmProcessor))
   return(RmErrno = RmE_BadArgument, FALSE);
   
  for (i = 0, real_count = 0, conns_count = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    { real_count++;
      unless((rc = Plausibility_aux1(processors[i], &conns_count)) eq RmE_Success)
       return(RmErrno = rc, FALSE);
    }

  if (real_count eq 0)
   return(RmErrno = RmE_BadArgument, FALSE);
        
  conns = Malloc(conns_count * sizeof(LinkConnection));
  if (conns eq Null(LinkConnection))
   return(RmErrno = RmE_NoMemory, FALSE);
   
  conns_count = 0;
  for (i = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    if ((rc = Plausibility_aux2(processors[i], conns, &conns_count))
        ne RmE_Success)
     { Free(conns);
       return(RmErrno = rc, FALSE);
     }
     
  result = CheckConnections(conns_count, conns, exact, preserve);
  Free(conns);
  return(result);    
}

static	int Plausibility_aux1(RmProcessor processor, ...)
{ va_list	args;
  int		*conns_count;
  
  va_start(args, processor);
  conns_count = va_arg(args, int *);
  va_end(args);

  CheckProcessor(processor);
  unless((processor->StructType eq RmL_Existing) ||
         (processor->StructType eq RmL_Obtained))
   return(RmErrno = processor->Errno = RmE_BadProcessor);
  *conns_count += processor->Connections;
  return(RmE_Success);
}

static	int Plausibility_aux2(RmProcessor processor, ...)
{ va_list		args;
  int			*conns_count_ptr;
  int			conns_count;
  LinkConnection	*conns;
  int			i;
  RmProcessor		neighbour;
  int			destlink;
      
  va_start(args, processor);
  conns		  = va_arg(args, LinkConnection *);
  conns_count_ptr = va_arg(args, int *);
  va_end(args);
  conns_count	  = *conns_count_ptr;
  
  for (i = 0; i < processor->Connections; i++)
   {
     neighbour = RmFollowLink(processor, i, &destlink);
     if (neighbour eq (RmProcessor) NULL)
      { conns[conns_count].SourceUid	= processor->Uid;
        conns[conns_count].SourceCap	= processor->NsCap;
        conns[conns_count].SourceLink	= i;
        conns[conns_count].DestUid	= RmL_NoUid;
        conns[conns_count].DestLink	= destlink;
        conns_count++;
        continue;
      }
      	/* probably a processor outside the user's network */
     if (neighbour eq RmM_ExternalProcessor)
      { RmLink *link = RmFindLink(processor, i);
        conns[conns_count].SourceUid	= processor->Uid;
        conns[conns_count].SourceCap	= processor->NsCap;
        conns[conns_count].SourceLink	= i;
        conns[conns_count].DestUid	= link->Target;
        conns[conns_count].DestLink	= link->Destination;
        conns[conns_count].DestCap.Access = 0;
        conns_count++;
        continue;
      }

     conns[conns_count].SourceUid	= processor->Uid;
     conns[conns_count].SourceCap	= processor->NsCap;
     conns[conns_count].SourceLink	= i;
     conns[conns_count].DestUid		= neighbour->Uid;
     conns[conns_count].DestCap		= neighbour->NsCap;
     conns[conns_count].DestLink	= destlink;
     conns_count++;
   }
           
  *conns_count_ptr = conns_count;
  return(RmE_Success);
}

static	bool	CheckConnections(int count, LinkConnection *conns,
		bool exact, bool preserve)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  request.FnRc		= RmC_TestConnections;
  request.Arg1		= count;
  request.Arg2		= (int)exact;
  request.Arg3		= (int)preserve;
  request.VariableSize	= count * sizeof(LinkConnection);
  request.VariableData	= (BYTE *) conns;
  rc = RmXch(&RmNetworkServer, &request, &reply);
  return(rc eq RmE_Success ? TRUE : FALSE);
}

static	int	MakeConnections(int count, LinkConnection *conns,
		bool exact, bool preserve)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  if (exact eq 666)
   request.FnRc = RmC_Revert;
  else
   request.FnRc = RmC_MakeConnections;
  request.Arg1		= count;
  request.Arg2		= (int)exact;
  request.Arg3		= (int)preserve;
  request.VariableSize	= count * sizeof(LinkConnection);
  request.VariableData	= (BYTE *) conns;

  reply.VariableData	= (BYTE *) conns;

  rc = RmXch(&RmParent, &request, &reply);
  return(rc);
}
		
int	RmReconfigureNetwork(RmNetwork network, bool exact, bool preserve)
{ LinkConnection	*conns;
  int			rc;
  int			conns_count = 0;
  int			i;

  CheckNetwork(network);
  unless(network->Root eq (RmSet) network)
   return(network->Errno = RmErrno = RmE_NotRootNetwork);
   
  rc = RmSearchProcessors(network, &Plausibility_aux1, &conns_count);
  if (rc ne RmE_Success)  
   return(RmErrno = rc, FALSE);

  conns = Malloc(conns_count * sizeof(LinkConnection));
  if (conns eq Null(LinkConnection))
   return(RmErrno = RmE_NoMemory, FALSE);

  conns_count = 0;
  rc = RmSearchProcessors(network, &Plausibility_aux2, conns, &conns_count);
  if (rc ne RmE_Success)
   { Free(conns);
     return(RmErrno = rc);
   }

  if ((rc = MakeConnections(conns_count, conns, exact, preserve))  
      ne RmE_Success)
   { Free(conns);
     return(RmErrno = network->Errno = rc);
   }

  for (i = 0; i < conns_count; i++)
   { RmProcessor source = RmFindProcessor(network, conns[i].SourceUid);
     RmLink		*link;

     if (source eq (RmProcessor) NULL) continue;
		
     link = RmFindLink(source, conns[i].SourceLink);
     { RmProcessor neighbour;	/* update the old neighbour, if appropriate */
       int	   destlink;
       neighbour = RmFollowLink(source, conns[i].SourceLink, &destlink);
       if ((neighbour ne RmM_NoProcessor) && (neighbour ne RmM_ExternalProcessor))
        { RmLink *link = RmFindLink(neighbour, destlink);
          if ((link->Target eq source->Uid) &&
              (link->Destination eq conns[i].SourceLink))
           { link->Destination = -1;
             link->Target = RmL_NoUid;
           }
        }
     }
     	/* update the current processor */
     link->Destination	= conns[i].DestLink;
     link->Target	= conns[i].DestUid;
     
    	/* update the new neighbour */
     if ((conns[i].DestUid ne RmL_NoUid) &&
         (conns[i].DestUid ne RmL_ExtUid))
      { source = RmFindProcessor(network, conns[i].DestUid);
        if (source eq (RmProcessor) NULL) continue;
        link = RmFindLink(source, conns[i].DestLink);
        link->Destination = conns[i].SourceLink;
        link->Target	  = conns[i].SourceUid;
      }        
   }
   
  Free(conns);
  return(rc);     
}

int	RmReconfigureProcessors(int count, RmProcessor *processors,
		bool exact, bool preserve)
{ int			real_count, i, j;
  int			rc;
  int			conns_count;
  LinkConnection	*conns;

  if (processors eq Null(RmProcessor))
   return(RmErrno = RmE_BadArgument, FALSE);

  for (i = 0, real_count = 0, conns_count = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    { real_count++;
      unless((rc = Plausibility_aux1(processors[i], &conns_count)) eq RmE_Success)
       return(RmErrno = rc);
    }
  if (real_count eq 0)
   return(RmErrno = RmE_BadArgument);
   
  conns = Malloc(conns_count * sizeof(LinkConnection));
  if (conns eq Null(LinkConnection))
   return(RmErrno = RmE_NoMemory);
   
  conns_count = 0;
  for (i = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    if ((rc = Plausibility_aux2(processors[i], conns, &conns_count))
        ne RmE_Success)
     { Free(conns);
       return(RmErrno = rc);
     }

   if ((rc = MakeConnections(conns_count, conns, exact, preserve))
        ne RmE_Success)
    { Free(conns);
      return(RmErrno = rc);
    }
    
  for (i = 0; i < conns_count; i++)
   for (j = 0; j < count; j++)
    { RmLink		*link;
      
      if (processors[j] eq (RmProcessor) NULL) continue;
      if (processors[j]->Uid ne conns[i].SourceUid) continue;
      link = RmFindLink(processors[j], conns[i].SourceLink);
      { RmProcessor neighbour;	/* update the old neighbour, if appropriate */
        int	    destlink;
        neighbour = RmFollowLink(processors[j], conns[i].SourceLink, &destlink);
        if ((neighbour ne RmM_NoProcessor) && (neighbour ne RmM_ExternalProcessor))
         { RmLink *link = RmFindLink(neighbour, destlink);
           if ((link->Target eq processors[j]->Uid) &&
               (link->Destination eq conns[i].SourceLink))
            { link->Destination = -1;
              link->Target = RmL_NoUid;
            }
         }
      }
		/* update this processor */
      link->Destination = conns[i].DestLink;
      link->Target	= conns[i].DestUid;
      
     		/* update the new neighbour, if appropriate */
      if ((conns[i].DestUid ne RmL_NoUid) &&
          (conns[i].DestUid ne RmL_ExtUid))
       { RmProcessor neighbour;
         neighbour = RmFindProcessor(RmRootNetwork(processors[j]), conns[i].DestUid);
         if ((neighbour ne RmM_NoProcessor) && (neighbour ne RmM_ExternalProcessor))
          { link = RmFindLink(neighbour, conns[i].DestLink);
            link->Destination = conns[i].SourceLink;
            link->Target	= conns[i].SourceUid;
            break;
          }
       }
      break;	/* out of j loop, for next i */
    }
    
  Free(conns);
  return(rc);
}

int	RmRevertNetwork(RmNetwork network)
{ LinkConnection	*conns;
  int			rc;
  int			conns_count = 0;
  int			i;

  CheckNetwork(network);
  unless(network->Root eq (RmSet) network)
   return(network->Errno = RmErrno = RmE_NotRootNetwork);
   
  rc = RmSearchProcessors(network, &Plausibility_aux1, &conns_count);
  if (rc ne RmE_Success)  
   return(RmErrno = network->Errno = rc, FALSE);

  conns = Malloc(conns_count * sizeof(LinkConnection));
  if (conns eq Null(LinkConnection))
   return(RmErrno = RmE_NoMemory, FALSE);

  conns_count = 0;
  rc = RmSearchProcessors(network, &Plausibility_aux2, conns, &conns_count);
  if (rc ne RmE_Success)
   { Free(conns);
     return(RmErrno = network->Errno = rc);
   }

  if ((rc = MakeConnections(conns_count, conns, 666, 666))  
      ne RmE_Success)
   { Free(conns);
     return(RmErrno = network->Errno = rc);
   }

  for (i = 0; i < conns_count; i++)
   { RmProcessor source = RmFindProcessor(network, conns[i].SourceUid);
     RmLink		*link;
     
     if (source eq (RmProcessor) NULL) continue;
     link = RmFindLink(source, conns[i].SourceLink);
     { RmProcessor neighbour;
       int	   destlink;
       neighbour = RmFollowLink(source, conns[i].SourceLink, &destlink);
       if ((neighbour ne RmM_NoProcessor) && (neighbour ne RmM_ExternalProcessor))
        { RmLink *link = RmFindLink(neighbour, destlink);
          if ((link->Target eq source->Uid) &&
              (link->Destination eq conns[i].SourceLink))
           { link->Destination = -1;
             link->Target = RmL_NoUid;
           }
        }
     }
     link->Destination	= conns[i].DestLink;
     link->Target	= conns[i].DestUid;
     if ((conns[i].DestUid ne RmL_NoUid) &&
         (conns[i].DestUid ne RmL_ExtUid))
      { source = RmFindProcessor(network, conns[i].DestUid);
        if (source eq (RmProcessor) NULL) continue;
        link = RmFindLink(source, conns[i].DestLink);
        link->Destination = conns[i].SourceLink;
        link->Target	  = conns[i].SourceUid;
      }        
   }
   
  Free(conns);
  return(rc);     
}

int	RmRevertProcessors(int count, RmProcessor *processors)
{ int			real_count, i, j;
  int			rc;
  int			conns_count;
  LinkConnection	*conns;

  if (processors eq Null(RmProcessor))
   return(RmErrno = RmE_BadArgument, FALSE);

  for (i = 0, real_count = 0, conns_count = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    { real_count++;
      unless((rc = Plausibility_aux1(processors[i], &conns_count)) eq RmE_Success)
       return(RmErrno = rc);
    }
  if (real_count eq 0)
   return(RmErrno = RmE_BadArgument);
   
  conns = Malloc(conns_count * sizeof(LinkConnection));
  if (conns eq Null(LinkConnection))
   return(RmErrno = RmE_NoMemory);
   
  conns_count = 0;
  for (i = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    if ((rc = Plausibility_aux2(processors[i], conns, &conns_count))
        ne RmE_Success)
     { Free(conns);
       return(RmErrno = rc);
     }

   if ((rc = MakeConnections(conns_count, conns, 666, 666))
        ne RmE_Success)
    { Free(conns);
      return(RmErrno = rc);
    }
    
  for (i = 0; i < conns_count; i++)
   for (j = 0; j < count; j++)
    { RmLink		*link;
      
      if (processors[j] eq (RmProcessor) NULL) continue;
      if (processors[j]->Uid ne conns[i].SourceUid) continue;
      link = RmFindLink(processors[j], conns[i].SourceLink);
      { RmProcessor neighbour;
        int	    destlink;
        neighbour = RmFollowLink(processors[j], conns[i].SourceLink, &destlink);
        if ((neighbour ne RmM_NoProcessor) && (neighbour ne RmM_ExternalProcessor))
         { RmLink *link = RmFindLink(neighbour, destlink);
           if ((link->Destination eq conns[i].SourceLink) &&
               (link->Target eq processors[j]->Uid))
            { link->Destination = -1;
              link->Target = RmL_NoUid;
            }
         }
      }
      link->Destination = conns[i].DestLink;
      link->Target	= conns[i].DestUid;
      if ((conns[i].DestUid ne RmL_NoUid) &&
          (conns[i].DestUid ne RmL_ExtUid))
       { int	k;
         for (k = 0; k < count; k++)
          if (processors[k] ne (RmProcessor) NULL)
           if (processors[k]->Uid eq conns[i].DestUid)
            { link = RmFindLink(processors[k], conns[i].DestLink);
              link->Destination = conns[i].SourceLink;
              link->Target	= conns[i].SourceUid;
              break;
            }
       }
      break;	/* out of j loop, for next i */
    }
    
  Free(conns);
  return(rc);
}

static	int	NetworkOp(RmNetwork, int);
static	int	ProcessorsOp(int count, RmProcessor *, int);

int	RmSetNetworkNative(RmNetwork network)
{ return(NetworkOp(network, RmC_SetNative));
}

int	RmSetProcessorsNative(int count, RmProcessor *processors)
{ return(ProcessorsOp(count, processors, RmC_SetNative));
}

int	RmResetNetwork(RmNetwork network)
{ return(NetworkOp(network, RmC_ResetProcessors));
}

int	RmResetProcessors(int count, RmProcessor *processors)
{ return(ProcessorsOp(count, processors, RmC_ResetProcessors));
}

int	RmRebootNetwork(RmNetwork network)
{ return(NetworkOp(network, RmC_Reboot));
}

int	RmRebootProcessors(int count, RmProcessor *processors)
{ return(ProcessorsOp(count, processors, RmC_Reboot));
}


static	int	GeneralOp(int count, ProcessorDetails *, ProcessorUpdate *,
			int op);
static	int	fill_in_details(RmProcessor processor, ...);

static	int	NetworkOp(RmNetwork network, int op)
{ int			count;
  ProcessorDetails	*details;
  ProcessorUpdate	*updates;
  int			rc;
  int			i;
  RmProcessor		current;

  CheckNetwork(network);
  unless(network->Root eq (RmSet) network)
   return(network->Errno = RmErrno = RmE_NotRootNetwork);
   
  count = RmCountProcessors(network);
  if (count <= 0)
   return(RmErrno = network->Errno = RmE_BadArgument);

  details = Malloc(count * sizeof(ProcessorDetails));
  if (details eq Null(ProcessorDetails))
   return(RmErrno = network->Errno = RmE_NoMemory);
  updates = Malloc(count * sizeof(ProcessorUpdate));
  if (updates eq Null(ProcessorUpdate))
   { Free(details); return(RmErrno = network->Errno = RmE_NoMemory); }
   
  count = 0; 
  if ((rc = RmSearchProcessors(network, &fill_in_details, details, &count))
      ne RmE_Success)
   { Free(details); Free(updates); return(RmErrno = network->Errno = rc); }

  rc = GeneralOp(count, details, updates, op);
  if ((rc eq RmE_Success) || (rc eq RmE_PartialSuccess))
   for (i = 0; i < count; i++)
    { current = RmFindProcessor(network, updates[i].Uid);
      if (current eq (RmProcessor) NULL) continue;
      current->ObjNode.Size = updates[i].State;
      current->Purpose = updates[i].Purpose;
    }
  else
   RmErrno = network->Errno = rc;
       
  Free(details);
  Free(updates);
  return(rc);     
}

static	int	ProcessorsOp(int count, RmProcessor *processors, int op)
{ int			real_count, i, j;
  ProcessorDetails	*details;
  ProcessorUpdate	*updates;
  int			rc;

  if (processors eq Null(RmProcessor))
   return(RmErrno = RmE_BadArgument);
     
  for (i = 0, real_count = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    { if (processors[i]->ObjNode.Type ne Type_Processor)
       return(RmErrno = RmE_NotProcessor);
      real_count++;
    }
    
  if (real_count eq 0)
   return(RmErrno = RmE_BadArgument);

  details = Malloc(real_count * sizeof(ProcessorDetails));
  if (details eq Null(ProcessorDetails))
   return(RmErrno = RmE_NoMemory);

  updates = Malloc(real_count * sizeof(ProcessorUpdate));
  if (updates eq Null(ProcessorUpdate))
   { Free(details); return(RmErrno = RmE_NoMemory); }
      
  for (i = 0, real_count = 0; i < count; i++)
   if (processors[i] ne (RmProcessor) NULL)
    if ((rc = fill_in_details(processors[i], details, &real_count))
        ne RmE_Success)
     { Free(details); Free(updates); return(RmErrno = rc); }
    
  rc = GeneralOp(real_count, details, updates, op);
  if ((rc eq RmE_Success) || (rc eq RmE_PartialSuccess))
   for (i = 0; i < real_count; i++)
    for (j = 0; j < count; j++)
     { if (processors[j] eq (RmProcessor) NULL) continue;
       if (processors[j]->Uid eq updates[i].Uid)
        { processors[j]->ObjNode.Size = updates[i].State;
          processors[j]->Purpose = updates[i].Purpose;
          break;
        }
     }
  else
   RmErrno = rc;
   
  Free(details);
  Free(updates);
  return(rc);
}

static	int	fill_in_details(RmProcessor processor, ...)
{ va_list		args;
  ProcessorDetails	*details;
  int			*real_count;
  
  if (processor->StructType ne RmL_Obtained)
   return(RmE_NoAccess);
  va_start(args, processor);
  details = va_arg(args, ProcessorDetails *);
  real_count = va_arg(args, int *);
  va_end(args);

	/* processors which are not set to native are ignored by these	*/
	/* routines.							*/
  if (RmGetProcessorPurpose(processor) ne RmP_Native)
   details[*real_count].Uid	= RmL_NoUid;
  else  
   { details[*real_count].Uid	= processor->Uid;
    details[*real_count].Cap	= processor->NsCap;
   }
  *real_count += 1;
  return(RmE_Success);
}

static	int	GeneralOp(int count, ProcessorDetails *details, 
		ProcessorUpdate *updates, int op)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  Clear(request); Clear(reply);
  request.FnRc		= op;
  request.Arg1		= count;
  request.VariableSize	= count * sizeof(ProcessorDetails);
  request.VariableData	= (BYTE *) details;
  reply.VariableData	= (BYTE *) updates;
  
  rc = RmXch(&RmParent, &request, &reply);
  return(rc);
}
/*}}}*/
#else
# ifdef __C40
/*{{{  Stubs needed for backward compatibility */
int RmRebootNetwork(RmNetwork network)
{
	network = network; return(RmE_YouMustBeJoking);
}

int RmRebootProcessors(int count, RmProcessor *processors)
{
	count = count; processors = processors; return(RmE_YouMustBeJoking);
}

int RmReconfigureNetwork(RmNetwork network, bool exact, bool preserve)
{
	network = network; exact = preserve; return(RmE_YouMustBeJoking);
}

int RmReconfigureProcessors(int count, RmProcessor *processors, bool exact, bool preserve)
{
	count = count; processors = processors; exact = preserve; return(RmE_YouMustBeJoking);
}

int RmResetNetwork(RmNetwork network)
{
	network = network; return(RmE_YouMustBeJoking);
}

int RmResetProcessors(int count, RmProcessor *processors)
{
	count = count; processors = processors; return(RmE_YouMustBeJoking);
}

int RmRevertNetwork(RmNetwork network)
{
	network = network; return(RmE_YouMustBeJoking);
}

int RmRevertProcessors(int count, RmProcessor *processors)
{
	count = count; processors = processors; return(RmE_YouMustBeJoking);
}

bool RmIsLinkPossible(RmProcessor source, int sourcelink, RmProcessor dest, int destlink)
{
	source = dest; sourcelink = destlink; return(FALSE);
}

bool RmIsNetworkPossible(RmNetwork network, bool exact, bool preserve)
{
	network = network; exact = preserve; return(FALSE);
}

bool RmAreProcessorsPossible(int count, RmProcessor *processors, bool exact, bool preserve)
{
	count = count; processors = processors; exact = preserve; return(FALSE);
}

int RmSetNetworkNative(RmNetwork network)
{
	network = network; return(RmE_YouMustBeJoking);
}

int RmSetProcessorsNative(int count, RmProcessor *processors)
{
	count = count; processors = processors; return(RmE_YouMustBeJoking);
}

/*}}}*/
# endif
#endif
/*{{{  Session and application ids */
/**-----------------------------------------------------------------------------
*** The processor identification routines requested by Telmat. The routines
*** RmGetSession() and RmGetApplication() are almost identical and
*** always go to the parent, usually the TFM, but if arg1 is set then
*** the TFM will forward the request to the Network Server.
**/
int	RmGetProcessorSession(RmProcessor Processor)
{
  CheckProcessorFail(Processor, -1);
  if ((Processor->StructType ne RmL_Existing) &&
      (Processor->StructType ne RmL_Obtained))
   { RmErrno = Processor->Errno = RmE_BadArgument; return(-1); }
  return(Processor->SessionId);
}

int RmGetProcessorApplication(RmProcessor Processor)
{
  CheckProcessorFail(Processor, -1);
  if ((Processor->StructType ne RmL_Existing) &&
      (Processor->StructType ne RmL_Obtained))
   { RmErrno = Processor->Errno = RmE_BadArgument; return(-1); }
  return(Processor->ApplicationId);
}

int RmGetSession()
{ RmRequest	request;
  RmReply	reply;
  int		result;

  Clear(request); Clear(reply);
  request.FnRc	= RmC_GetId;
  request.Arg1	= 1;
  result	= RmXch(&RmParent, &request, &reply);
  if (result eq RmE_Success)
   return(reply.Reply1);
  else
   { RmErrno = result; return(-1); }
}

int RmGetApplication()
{ RmRequest	request;
  RmReply	reply;
  int		result;

  Clear(request); Clear(reply);
  request.FnRc	= RmC_GetId;
  request.Arg1	= 0;
  result	= RmXch(&RmParent, &request, &reply);
  if (result eq RmE_Success)
   return(reply.Reply1);
  else
   { RmErrno = result; return(-1); }
}
/*}}}*/
@


1.11
log
@fixed compile time warnings
@
text
@d19 1
a19 1
/* RcsId: $Header: /hsrc/network/RCS/rmlib3.c,v 1.10 1993/08/11 11:15:09 bart Exp nickc $*/
d138 1
d144 1
a144 1
RmProcessor	RmObtainProcessor(RmProcessor template)
d149 1
a149 1
  CheckProcessorFail(template, (RmProcessor) NULL);
d151 3
a153 3
  if ((template->StructType ne RmL_Existing) &&
      (template->StructType ne RmL_New))
   { RmErrno = template->Errno = RmE_BadArgument; return((RmProcessor)NULL); }
d157 1
a157 1
  request.Processor	= template;
d160 1
a160 1
  if (rc ne RmE_Success) RmErrno = template->Errno = rc;
d213 1
d364 1
d422 1
a422 1
  RmNetwork	template;
d426 1
a426 1
  template = va_arg(args, RmNetwork);
d432 1
a432 1
  match = RmFindProcessor(template, processor->MappedTo);
d505 1
a505 1
  RmProcessor	*template;
d509 1
a509 1
  template = va_arg(args, RmProcessor *);
d515 3
a517 3
   if (template[i] ne (RmProcessor) NULL)
    if (template[i]->Uid eq processor->MappedTo)
     template[i]->MappedTo = processor->Uid;
d521 1
d524 1
d550 1
a550 1
  request.VariableData = Malloc(request.VariableSize);
d585 1
d724 1
d814 1
a814 1
  datavec   = Malloc(datasize);
d897 1
d1006 1
d1174 1
a1174 1
  task_table = Malloc((word) number_tasks * sizeof(RmTask));
d1216 1
a1216 1
  TaskDetails	*details = Malloc((word) count * sizeof(TaskDetails));
d1407 1
a1407 1
  tid = Malloc(4 + 17 + 1 + (word) strlen(this_task->Name));
@


1.10
log
@1) sorted out stack checking options
2) the native network support is now compiled in only for transputers.
   For C40 processors it is still necessary to provide stubs for
   backwards compatibility.
@
text
@d6 1
a6 1
--             Copyright (C) 1990, Perihelion Software Ltd.             --
d19 1
a19 1
/* RcsId: $Header: /hsrc/network/RCS/rmlib3.c,v 1.8 1993/04/14 16:17:16 nickc Exp $*/
d716 1
d853 1
a853 1
         { MarshalWord(&m, (word) (0xFFFF0000 | j)); goto skip_stream2; }
d1000 1
d1165 1
a1165 1
  task_table = Malloc(number_tasks * sizeof(RmTask));
d1207 1
a1207 1
  TaskDetails	*details = Malloc(count * sizeof(TaskDetails));
d1371 1
d1398 1
a1398 1
  tid = Malloc(4 + 17 + 1 + strlen(this_task->Name));
d1422 1
@


1.9
log
@fixed for compilation on RS6000
@
text
@d19 1
a19 1
/* rcsid = "$Header: /hsrc/network/RCS/rmlib3.c,v 1.8 1993/04/14 16:17:16 nickc Exp nickc $ */
d24 1
a24 1
#if defined __SUN4 || defined RS6000
d47 1
d50 1
d53 2
a54 3
#if 1
#pragma -s1		/* disable stack checking			*/
#pragma -g0		/* remove names from code			*/
d56 1
a56 2
#pragma -s0		/* enable stack checking			*/
#pragma -g1		/* put names into code				*/
d852 1
a852 1
         { MarshalWord(&m, 0xFFFF0000 | j); goto skip_stream2; }
d1420 1
d2106 71
@


1.8
log
@fixed for SUN4 compilation
@
text
@d19 1
a19 1
/* rcsid = "$Header: /hsrc/network/RCS/rmlib3.c,v 1.7 1993/01/08 12:34:37 bart Exp nickc $ */
d24 1
a24 1
#ifdef __SUN4
@


1.7
log
@sorted out pragmas
@
text
@d19 1
a19 1
/* rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib3.c,v 1.6 1992/10/07 13:32:32 bart Exp $ */
d24 5
@


1.6
log
@1) fixed a bug in RmGetTaskforce()
2) removed an IOdebug() from RmConvertTaskToTaskforce()
@
text
@d19 1
a19 1
/* rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib3.c,v 1.5 1992/09/09 11:45:00 bart Exp $ */
d42 4
d47 5
a51 3
#pragma -s1		/* disable stack checking */
#pragma -f0		/* and vector stack */
#pragma -g0		/* and do not put the names into the code */
@


1.5
log
@Added RmConvertTaskToTaskforce() for the farm library
@
text
@d19 1
a19 1
/* rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib3.c,v 1.4 1992/05/08 16:42:58 bart Exp $ */
d662 1
a662 1
    if (strcmp(&(tmp[-5]), "/tfm/"))
d1399 1
a1399 7
  if (new_taskforce eq NULL)
   { 
#if 1
	IOdebug("RmConvertTaskToTaskforce(): failed to find new taskforce");
#endif
     return(result);
   }
@


1.4
log
@Fixed bug in MakeConnections(), transmitted arguments incorrect
@
text
@d19 1
a19 1
/* rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib3.c,v 1.3 1992/03/25 18:03:41 bart Exp $ */
d648 1
a648 1
/**-----------------------------------------------------------------------------
d661 4
d687 4
d1358 53
a1410 3
RmTaskforce	RmConvertTaskToTaskforce(RmTask task, RmTaskforce taskforce)
{
  task = task; return((RmTaskforce) NULL);
d1609 2
a1610 2
  request.Arg2		= exact;
  request.Arg3		= preserve;
d1629 2
a1630 2
  request.Arg2		= exact;
  request.Arg3		= preserve;
@


1.3
log
@Various changes including:
1) first attempt at C40 support
2) RmLib execute support (not yet fully tested)
3) faster bootstrap, taskforce load, and better mapping
@
text
@d19 1
a19 1
/* rcsid = "$Header: /users/bart/hsrc/network/RCS/rmlib3.c,v 1.2 1992/01/15 11:04:39 bart Exp $ */
d1572 1
a1572 1
  request.Arg2		= preserve;
@


1.2
log
@Major update of networking sources, to incorporate the fault-tolerance
work as demonstrated at the IED meeting 10.1.92
@
text
@d19 1
a19 5
/**
BLV Some of these routines, for example RmObtainNetwork() and RmExecuteTaskforce(),
BLV should check that they have been applied to the root of a network
BLV rather than to a subnet, or the servers are likely to crash.
**/
a20 2
/* rcsid = "$Header: /usr/perihelion/Helios/network/RCS/rmlib3.c,v 1.7 90/12/01 15:37:21 bart Exp $ */

d23 1
d40 2
a41 1

d47 2
a48 4

			/* From rmlib2.c */
extern	word FullRead(Stream *pipe, BYTE *buffer, word amount, word timeout);

d96 2
a97 4

/**-----------------------------------------------------------------------------
*** Get hold of some time stamps from the system
**/
d125 2
a126 1

d157 1
a157 1
int		RmReleaseProcessor(RmProcessor Processor)
d162 3
a164 3
  CheckProcessor(Processor);
  if (Processor->StructType ne RmL_Obtained) 
   return(RmErrno = Processor->Errno = RmE_NoAccess);
d168 2
a169 2
  request.Uid	= Processor->Uid;
  request.Cap	= Processor->NsCap;
d172 1
a172 1
   RmErrno = Processor->Errno = rc;
d174 1
a174 1
   Processor->StructType = RmL_Existing;
d178 25
d207 1
a207 1
static		int RmSetProcessorAllocation(int fnrc, RmProcessor Processor)
d215 2
a216 2
  request.Uid	= Processor->Uid;
  request.Cap	= Processor->NsCap;
d218 1
a218 1
  if (rc ne RmE_Success) RmErrno = Processor->Errno = rc;
d222 1
a222 1
int		RmSetProcessorShareable(RmProcessor Processor)
d224 1
a224 1
  CheckProcessor(Processor);
d226 3
a228 3
  if ((Processor->StructType eq RmL_New) || 
      (Processor->StructType eq RmL_Existing))
   { Processor->AllocationFlags &= ~RmF_Exclusive;
d231 2
a232 2
  if (Processor->StructType ne RmL_Obtained)
   return(RmErrno = Processor->Errno = RmE_NoAccess);
d234 1
a234 1
  return(RmSetProcessorAllocation(RmC_ProcessorShareable, Processor));
d237 1
a237 1
int		RmSetProcessorExclusive(RmProcessor Processor)
d239 1
a239 1
  CheckProcessor(Processor);
d241 3
a243 3
  if ((Processor->StructType eq RmL_New) ||
      (Processor->StructType eq RmL_Existing))
   { Processor->AllocationFlags |= RmF_Exclusive;
d246 2
a247 2
  if (Processor->StructType ne RmL_Obtained)
   return(RmErrno = Processor->Errno = RmE_NoAccess);
d249 1
a249 1
  return(RmSetProcessorAllocation(RmC_ProcessorExclusive, Processor));   
d252 1
a252 1
bool	RmIsProcessorShareable(RmProcessor Processor)
d254 1
a254 1
  CheckProcessorFail(Processor, FALSE); 
d256 1
a256 1
  if (Processor->AllocationFlags & RmF_Exclusive)
d262 1
a262 1
bool	RmIsProcessorExclusive(RmProcessor Processor)
d264 1
a264 1
  CheckProcessorFail(Processor, FALSE);
d266 1
a266 1
  if (Processor->AllocationFlags & RmF_Exclusive)
d272 1
a272 1
int		RmSetProcessorTemporary(RmProcessor Processor)
d274 1
a274 1
  CheckProcessor(Processor);
d276 3
a278 3
  if ((Processor->StructType eq RmL_New) ||
      (Processor->StructType eq RmL_Existing))
   { Processor->AllocationFlags &= ~RmF_Permanent;
d281 3
a283 3
  if (Processor->StructType ne RmL_Obtained)
   return(RmErrno = Processor->Errno = RmE_NoAccess);
  return(RmSetProcessorAllocation(RmC_ProcessorTemporary, Processor));   
d286 1
a286 1
int		RmSetProcessorPermanent(RmProcessor Processor)
d288 1
a288 1
  CheckProcessor(Processor);
d290 3
a292 3
  if ((Processor->StructType eq RmL_New) ||
      (Processor->StructType eq RmL_Existing))
   { Processor->AllocationFlags |= RmF_Permanent;
d295 3
a297 3
  if (Processor->StructType ne RmL_Obtained)
   return(RmErrno = Processor->Errno = RmE_NoAccess);
  return(RmSetProcessorAllocation(RmC_ProcessorPermanent, Processor));   
d300 1
a300 1
bool		RmIsProcessorTemporary(RmProcessor Processor)
d302 1
a302 1
  CheckProcessorFail(Processor, FALSE);	
d304 1
a304 1
  if (Processor->AllocationFlags & RmF_Permanent)
d310 1
a310 1
bool		RmIsProcessorPermanent(RmProcessor Processor)
d312 1
a312 1
  CheckProcessorFail(Processor, FALSE);
d314 1
a314 1
  if (Processor->AllocationFlags & RmF_Permanent)
d320 1
a320 1
int		RmSetProcessorCancelled(RmProcessor Processor)
d322 1
a322 1
  CheckProcessor(Processor);
d324 3
a326 3
  if ((Processor->StructType eq RmL_New) || 
      (Processor->StructType eq RmL_Existing))
   { Processor->AllocationFlags &= ~RmF_Booked;
d329 2
a330 2
  if (Processor->StructType ne RmL_Obtained)
   return(RmErrno = Processor->Errno = RmE_NoAccess);
d332 1
a332 1
  return(RmSetProcessorAllocation(RmC_ProcessorCancelled, Processor));
d335 1
a335 1
int		RmSetProcessorBooked(RmProcessor Processor)
d337 1
a337 1
  CheckProcessor(Processor);
d339 3
a341 3
  if ((Processor->StructType eq RmL_New) ||
      (Processor->StructType eq RmL_Existing))
   { Processor->AllocationFlags |= RmF_Booked;
d344 2
a345 2
  if (Processor->StructType ne RmL_Obtained)
   return(RmErrno = Processor->Errno = RmE_NoAccess);
d347 1
a347 1
  return(RmSetProcessorAllocation(RmC_ProcessorBooked, Processor));   
d349 2
a350 1

d368 1
a368 1
RmNetwork	RmObtainNetwork(RmNetwork Network, bool exact, int *rc_ptr)
d373 4
a376 1
  CheckNetworkFail(Network, (RmNetwork) NULL);
d378 1
a378 1
  if ((rc = RmSearchProcessors(Network, &RmObtainAux1)) ne RmE_Success)
d384 1
a384 1
  request.Network	= Network;
d388 1
a388 1
  (void) RmApplyProcessors(reply.Network, &RmObtainAux2, Network);
d392 1
a392 1
  if (rc ne RmE_Success) RmErrno = Network->Errno = rc;
d396 1
a396 1
static		int RmObtainAux1(RmProcessor Processor, ...)
d398 2
a399 2
  if ((Processor->StructType ne RmL_New) &&
      (Processor->StructType ne RmL_Existing))
d402 1
a402 1
  Processor->MappedTo = 0;  
d406 1
a406 1
static		int RmObtainAux2(RmProcessor Processor, ...)
d411 1
a411 1
  va_start(args, Processor);
d416 1
a416 1
  if (Processor->MappedTo eq 0) return(RmE_Success);
d418 1
a418 1
  match = RmFindProcessor(template, Processor->MappedTo);
d420 1
a420 1
   match->MappedTo = Processor->Uid;
a424 39
RmProcessor	RmFindMatchingProcessor(RmProcessor Processor,
					RmNetwork Network)
{ RmProcessor	result;

  CheckProcessorFail(Processor, (RmProcessor) NULL);
  CheckNetworkFail(Network, (RmProcessor) NULL);

  if (Processor->MappedTo eq 0) 
   return(Processor->Errno = RmErrno = RmE_BadProcessor, (RmProcessor) NULL);
  result = RmFindProcessor(Network, Processor->MappedTo);
  if (result eq (RmProcessor) NULL)
   Processor->Errno = RmErrno = RmE_NotFound;
  return(result);   
}

bool	RmIsProcessorFree(RmProcessor processor)
{ int		rc;
  RmRequest	request;
  RmReply	reply;

  CheckProcessorFail(processor, FALSE);
  if ((processor->StructType ne RmL_Existing) &&
      (processor->StructType ne RmL_Obtained))
   return(processor->Errno = RmErrno = RmE_BadProcessor);

  Clear(request); Clear(reply);
  request.FnRc	= RmC_IsProcessorFree;
  request.Uid	= processor->Uid;

  rc = RmXch(&RmParent, &request, &reply);

  if (rc eq RmE_Success)
   return(TRUE);
  elif (rc eq RmE_InUse)
   return(FALSE);
  else
   return(processor->Errno = RmErrno = rc, FALSE);
}

d428 1
a428 1
{ RmJob		Job;
d431 1
a431 1
  Stream	*Pipe;
d459 1
a459 1
  rc		= RmNewJob(&RmParent, &Job);
d462 1
a462 1
  Pipe		= Job->Server->Pipe_ctos;
d469 1
a469 1
  if ((rc = RmTx(Job, &request)) ne RmE_Success)
d473 1
a473 1
    if ((rc = RmWriteProcessor(Pipe, processors[i], (RmFilter) NULL)) 
d475 1
a475 1
     { RmUnlockWrite(Job); goto done; }
d477 1
a477 1
  rc = RmRx(Job, &reply);
d483 1
a483 1
  if (got_job) RmFinishedJob(Job);
d507 2
a508 1

d514 1
a514 1
static int	RmReleaseAux1(RmProcessor Processor, ...);
d516 1
a516 1
int		RmReleaseNetwork(RmNetwork Network) 
d522 5
a526 2
  CheckNetwork(Network);      
  count = RmCountProcessors(Network);
d539 1
a539 1
  rc	= RmApplyProcessors(Network, &RmReleaseAux1, request.VariableData, &count);
d547 1
a547 1
  if (rc ne RmE_Success) RmErrno = Network->Errno = rc;
d551 1
a551 1
static int RmReleaseAux1(RmProcessor Processor, ...)
d556 1
a556 1
  va_start(args, Processor);
d561 3
a563 3
  if (Processor->StructType ne RmL_Obtained) return(RmE_NoAccess);
  details[*count].Uid	= Processor->Uid;
  details[*count].Cap	= Processor->NsCap;
d566 1
a566 1
  Processor->StructType = RmL_Existing;
d569 2
a570 1

d624 2
a625 1

d646 2
a647 1

d649 1
a649 1
*** Coping with task mappings
a650 11
int RmMapTask(RmProcessor processor, RmTask task)
{
  CheckProcessor(processor);
  CheckTask(task);
  
  if (task->MappedTo ne RmL_NoUid)
   return(RmErrno = task->Errno = RmE_InUse);
  AddTail(&(processor->MappedTasks), &(task->MappedNode));
  task->MappedTo = processor->Uid;
  return(RmE_Success);
}
d652 6
a657 3
static	int	RmCheckMappedTask(RmProcessor processor, RmTask task)
{ Node	*current;
  Node	*real;
d659 2
a660 2
  CheckProcessor(processor);
  CheckTask(task);  
d662 5
a666 9
  real = &(task->MappedNode);
  for (current = Head_(Node, processor->MappedTasks);
       !EndOfList_(current);
       current = Next_(Node, current))
   if (current eq real)
    return(RmE_Success);
    
  return(RmErrno = task->Errno = RmE_NotFound);       
}
d668 2
a669 3
bool		RmIsMappedTask(RmProcessor processor, RmTask task)
{ if (RmCheckMappedTask(processor, task) eq RmE_Success)
   return(TRUE);
d671 1
a671 1
   return(FALSE);
d674 6
a679 8
int		RmUnmapTask(RmProcessor Processor, RmTask task)
{ int	x = RmCheckMappedTask(Processor, task);
  if (x eq RmE_Success)
   { Remove(&(task->MappedNode));
     task->MappedTo = RmL_NoUid;
   }
  return(x);
}
d681 2
a682 4
RmProcessor	RmFollowTaskMapping(RmNetwork network, RmTask task)
{ 
  CheckNetworkFail(network, (RmProcessor) NULL);
  CheckTaskFail(task, (RmProcessor) NULL);
d684 5
a688 1
  if (task->MappedTo eq RmL_NoUid) return((RmProcessor) NULL);
d690 12
a701 2
  return(RmFindProcessor(network, task->MappedTo));
}
d703 24
a726 6
int		RmApplyMappedTasks(RmProcessor Processor, int (*fn)(RmTask, ...), ...)
{ Node	*current, *next;
  RmTask	temp;
  va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0; 
d728 10
a737 1
  CheckProcessorFail(Processor, -1);
d739 66
a804 12
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);
  
  for (current = Head_(Node, Processor->MappedTasks);
       !EndOfList_(current);
       current = next )
   { next = Next_(Node, current);
     temp = (RmTask) (((BYTE *) current) - offsetof(RmTaskStruct, MappedNode));
     result += (*fn)(temp, arg1, arg2, arg3);
d806 1
a806 2
  return(result);
}
d808 4
a811 6
int		RmSearchMappedTasks(RmProcessor Processor, int (*fn)(RmTask, ...), ...)
{ Node	*current, *next;
  RmTask	temp;
  va_list	args;
  int		arg1, arg2, arg3;
  int		result = 0; 
d813 13
a825 1
  CheckProcessorFail(Processor, -1);
d827 18
a844 15
  va_start(args, fn);
  arg1 = va_arg(args, int);
  arg2 = va_arg(args, int);
  arg3 = va_arg(args, int);
  va_end(args);
  
  for (current = Head_(Node, Processor->MappedTasks);
       !EndOfList_(current);
       current = next )
   { next = Next_(Node, current);
     temp = (RmTask) (((BYTE *) current) - offsetof(RmTaskStruct, MappedNode));
     result = (*fn)(temp, arg1, arg2, arg3);
     if (result ne 0) return(result);
   }
  return(result);
d847 10
a856 3
int	RmCountMappedTasks(RmProcessor Processor)
{ int	result = 0;
  Node	*temp;
d858 11
a868 7
  CheckProcessorFail(Processor, -1);  
  
  for (temp = Head_(Node, Processor->MappedTasks);
       !EndOfList_(temp);
       temp = Next_(Node, temp))
   result++;
  return(result);
d870 12
a881 3

/**-----------------------------------------------------------------------------
*** Executing tasks and taskforces, not currently implemented
a882 1

d884 6
a889 1
{ 
d893 1
d896 1
a896 1
      return(RmErrno = RmE_NotProcessor, (RmTask) NULL);
d898 1
a898 2
      return(RmErrno = task->Errno = processor->Errno = RmE_NoAccess,
      		(RmTask) NULL);
d900 12
a911 3
  argv = argv;
  RmErrno = task->Errno = RmE_YouMustBeJoking;
  return((RmTask) NULL);
d914 9
d924 6
a929 1
{ 
d933 1
a933 1
   
d938 14
a951 3
  argv = argv;
  RmErrno = taskforce->Errno = RmE_YouMustBeJoking;
  return((RmTaskforce) NULL);
d954 45
d1000 4
a1003 2
{ CheckTaskFail(task, -1);
  unless(task->StructType eq RmL_Executing)
d1006 8
a1013 2
  RmErrno = task->Errno = RmE_YouMustBeJoking;
  return(task->ReturnCode);
d1017 5
a1021 2
{ CheckTaskforceFail(taskforce, -1);
  unless(taskforce->StructType eq RmL_Executing)
d1023 9
a1031 3
   
  RmErrno = taskforce->Errno = RmE_YouMustBeJoking;
  return(taskforce->ReturnCode);
d1035 4
a1038 2
{ CheckTaskFail(task, FALSE);
  unless(task->StructType eq RmL_Executing)
d1041 8
a1048 2
  RmErrno = task->Errno = RmE_YouMustBeJoking;
  return(task->ReturnCode eq -1);
d1052 5
a1056 2
{ CheckTaskforceFail(taskforce, FALSE);
  unless(taskforce->StructType eq RmL_Executing)
d1058 9
a1066 3
   
  RmErrno = taskforce->Errno = RmE_YouMustBeJoking;
  return(taskforce->ReturnCode eq -1);
d1069 5
a1073 3
int	RmLeaveTask(RmTask task)
{ CheckTask(task);
  unless(task->StructType eq RmL_Executing)
d1076 8
a1083 1
  return(RmErrno = task->Errno = RmE_YouMustBeJoking);
d1086 6
a1091 3
int	RmLeaveTaskforce(RmTaskforce taskforce)
{ CheckTaskforce(taskforce);
  unless(taskforce->StructType eq RmL_Executing)
d1093 9
a1101 2
   
  return(RmErrno = taskforce->Errno = RmE_YouMustBeJoking);
d1104 158
a1261 2
int	RmSendTaskSignal(RmTask task, int signo)
{ CheckTask(task);
d1264 2
d1267 8
a1274 1
  return(RmErrno = task->Errno = RmE_YouMustBeJoking);
d1277 6
a1282 2
int	RmSendTaskforceSignal(RmTaskforce taskforce, int signo)
{ CheckTaskforce(taskforce);
d1285 2
d1288 8
a1295 1
  return(RmErrno = taskforce->Errno = RmE_YouMustBeJoking);
d1298 8
a1305 2
int	RmWaitforTask(RmTask task)
{ CheckTaskFail(task, -1);
d1308 18
a1325 2
   
  return(RmErrno = task->Errno = RmE_YouMustBeJoking, -1);
d1328 6
a1333 2
int	RmWaitforTaskforce(RmTaskforce taskforce)
{ CheckTaskforceFail(taskforce, -1);
a1335 3
   
  return(RmErrno = taskforce->Errno = RmE_YouMustBeJoking, -1);
}
d1337 4
a1340 2
int	RmWaitforTasks(int count, RmTask *tasks)
{ int	i;
d1342 5
a1346 23
  if (tasks eq Null(RmTask))
   return(RmErrno = RmE_NotTask, -1);
   
  for (i = 0; i < count; i++)
   { if (tasks[i] ne (RmTask) NULL)
      { if (tasks[i]->ObjNode.Type eq Type_Task)
         { if (tasks[i]->StructType eq RmL_Executing)
            continue;
           else
            return(RmErrno = RmE_BadArgument, -1);
         }
        elif (tasks[i]->ObjNode.Type eq Type_Taskforce)
         { RmTaskforce taskforce = (RmTaskforce) tasks[i];
           if (taskforce->StructType eq RmL_Executing)
            continue;
           else
            return(RmErrno = RmE_BadArgument, -1);
         }
        else
         return(RmErrno = RmE_NotTask, -1);
      }
   }
  return(-1);
d1348 6
d1355 3
d1411 3
a1413 1

d1589 3
d1738 3
d1914 3
a1916 1

d2041 2
a2042 1

d2096 1
a2096 50

/**-----------------------------------------------------------------------------
*** Examining the current taskforce/task.
**/

RmTaskforce RmGetTaskforce(void)
{ RmRequest	request;
  RmReply	reply;
  int		result;
  Environ	*env	= getenviron();
  Object	*tf  	= env->Objv[OV_TForce];

  if ((tf eq Null(Object)) || (tf eq (Object *) MinInt))
   return(RmErrno = RmE_NotTaskforce, (RmTaskforce) NULL);

  Clear(request); Clear(reply);
  request.FnRc		= RmC_GetTaskforce;
  request.VariableData	= objname(tf->Name);
  request.VariableSize	= strlen(request.VariableData) + 1;
  result		= RmXch(&RmParent, &request, &reply);

  if (result eq RmE_Success)
   return(reply.Taskforce);
  else
   { RmErrno = result; return((RmTaskforce) NULL); }
}

RmTask RmGetTask(void)
{ RmRequest	request;
  RmReply	reply;
  int		result;
  Environ	*env	= getenviron();
  Object	*tf  	= env->Objv[OV_TForce];

  if ((tf eq Null(Object)) || (tf eq (Object *) MinInt))
   return(RmErrno = RmE_NotTask, (RmTask) NULL);

  Clear(request); Clear(reply);
  request.FnRc		= RmC_GetTask;
  request.VariableData	= objname(tf->Name);
  request.VariableSize	= strlen(request.VariableData + 1);
  result		= RmXch(&RmParent, &request, &reply);

  if (result eq RmE_Success)
   return(reply.Task);
  else
   { RmErrno = result; return((RmTask) NULL); }
}


@


1.1
log
@Initial revision
@
text
@d25 1
a25 1
/* rcsid = "$Header: /users/bart/netbak/network/RCS/rmlib3.c,v 1.3 1991/08/21 16:04:02 bart Exp $ */
d479 1
a479 1
  Pipe		= Job->Server->Pipe;
d622 1
a622 1
   return(RmErrno = RmE_BadArgument);
d637 22
a658 1
/**-----------------------------------------------------------------------------     
d707 1
a707 2
{ RmProcessor	result;

d710 1
a710 1
  
a711 3
  
  result = RmFindProcessor(network, task->MappedTo);
  if (result eq (RmProcessor) NULL) return((RmProcessor) NULL);
d713 1
a713 4
  if (RmCheckMappedTask(result, task) ne RmE_Success)
   return((RmProcessor) NULL);
  else
   return(result);     
d1655 49
@
