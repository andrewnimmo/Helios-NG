head	1.35;
access;
symbols
	Helios_C40_1_3_Official_Release:1.31
	Alenia_release:1.29
	Helios1_3:1.28
	C40_Field_Test_2:1.27
	C40_Field_Test_R1:1.20
	Helios13_beta:1.20
	Helios1_2_2_Fault:1.18
	Helios1_2_2_Native:1.17
	Helios1_2_2_native_beta:1.16
	Helios1_2_2:1.15
	Helios1_2_2Beta:1.14
	Helios1_2_1:1.11
	Helios1_2:1.9;
locks; strict;
comment	@ * @;


1.35
date	93.09.28.14.59.39;	author richardp;	state Exp;
branches;
next	1.34;

1.34
date	93.08.12.13.48.55;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	93.08.12.13.40.15;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	93.08.11.10.33.36;	author bart;	state Exp;
branches;
next	1.31;

1.31
date	93.02.04.17.34.34;	author bart;	state Exp;
branches;
next	1.30;

1.30
date	93.01.18.11.40.16;	author bart;	state Exp;
branches;
next	1.29;

1.29
date	92.12.07.12.18.42;	author nick;	state Exp;
branches;
next	1.28;

1.28
date	92.10.26.17.43.59;	author bart;	state Exp;
branches;
next	1.27;

1.27
date	92.09.15.18.23.54;	author bart;	state Exp;
branches;
next	1.26;

1.26
date	92.08.21.13.18.39;	author bart;	state Exp;
branches;
next	1.25;

1.25
date	92.08.14.17.19.57;	author bart;	state Exp;
branches;
next	1.24;

1.24
date	92.07.21.11.01.08;	author bart;	state Exp;
branches;
next	1.23;

1.23
date	92.07.09.17.24.13;	author paul;	state Exp;
branches;
next	1.22;

1.22
date	92.07.08.12.02.10;	author paul;	state Exp;
branches;
next	1.21;

1.21
date	92.07.07.14.37.01;	author paul;	state Exp;
branches;
next	1.20;

1.20
date	92.05.08.16.36.25;	author bart;	state Exp;
branches;
next	1.19;

1.19
date	92.03.25.18.03.41;	author bart;	state Exp;
branches;
next	1.18;

1.18
date	92.01.15.11.04.39;	author bart;	state Exp;
branches;
next	1.17;

1.17
date	92.01.14.15.52.33;	author bart;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	92.01.14.14.20.34;	author bart;	state Exp;
branches;
next	1.15;

1.15
date	91.10.30.16.44.14;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	91.06.13.14.24.31;	author bart;	state Exp;
branches;
next	1.13;

1.13
date	91.06.03.13.46.15;	author bart;	state Exp;
branches;
next	1.12;

1.12
date	91.05.18.12.12.45;	author bart;	state Exp;
branches;
next	1.11;

1.11
date	91.02.27.16.33.04;	author bart;	state Exp;
branches;
next	1.10;

1.10
date	90.12.17.14.27.12;	author bart;	state Exp;
branches;
next	1.9;

1.9
date	90.12.01.15.33.11;	author bart;	state Exp;
branches;
next	1.8;

1.8
date	90.11.25.20.01.05;	author bart;	state Exp;
branches;
next	1.7;

1.7
date	90.11.01.16.34.34;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	90.11.01.14.50.54;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	90.10.18.14.12.51;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	90.10.18.13.26.05;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	90.09.27.13.24.09;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	90.09.24.18.49.19;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	90.09.12.14.37.05;	author jon;	state Exp;
branches;
next	;

1.17.1.1
date	92.02.04.12.59.03;	author bart;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Set spare[0] to 0 for Paul's new kstart
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- netboot.c								--
--                                                                      --
--	The bootstrap module of the Network Server			--
--                                                                      --
--	Author:  BLV 18/8/90						--
--                                                                      --
------------------------------------------------------------------------*/
/*$Header: /dsl/HeliosRoot/Helios/network/RCS/netboot.c,v 1.34 1993/08/12 13:48:55 nickc Exp richardp $*/

/*{{{  headers and compile-time options */
#define	__Netboot_Module
#define __NetworkServer

#include <stdio.h>
#include <syslib.h>
#include <servlib.h>
#include <link.h>
#include <root.h>
#include <config.h>
#include <sem.h>
#include <codes.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <posix.h>
#include <ctype.h>
#include <nonansi.h>
#include <stddef.h>
#include <c40.h>
#include "exports.h"
#include "private.h"
#include "netutils.h"
#include "rmlib.h"
#include "netaux.h"
/*}}}*/
/*{{{  forward declarations and statics */
/**
*** Bootstrap happens in the form of ``jobs''. The initial bootstrap is
*** one job. When processors are switched from native to Helios mode this
*** is another job. There are routines to create a new job, to add a processor
*** to a job, and to start a job. 
**/

#define 	SafetyMagic		0x73de190a
#define		MaxRetries		5

static	int	ProtectionMatrix;

static	void	BootstrapProcess(BootstrapJob *);
static	void	do_protection(RmProcessor);
static	void	ValidateProcessorDetails(RmProcessor);
static	int	execute_mapped_task(RmTask, ...);
static	void	set_pending(RmProcessor, BootstrapJob *);
static	void	set_enabled(RmProcessor, BootstrapJob *);

/**
*** Perform any one-off initialisation. In particular, work out the access
*** matrices to install on every processor.
**/
void InitBootstrap(void)
{ 
  if (get_config("processor_protection", nsrc_environ))
   ProtectionMatrix = 0x21212147;	/* rwdv, not a, for owner only */
   				/* currently read-only for the rest */ 
  else
   ProtectionMatrix = DefNameMatrix | AccMask_A;
}
/*}}}*/

/*{{{  start the initial network bootstrap */
/**
*** This routine is called from the main module netserv.c to initiate
*** the whole network bootstrap process.
***
*** First, the root processor, the I/O processor, etc. should be
*** updated. This involves modifying the name. There is a special case
*** situation for I/O Processors, where I cannot run the network agent
*** on the target processor.
**/
static int	StartBootstrapAux1(RmProcessor , ...);

void StartBootstrap(void)
{ BootstrapJob	*job	= NewBootstrapJob();

  Debug(dbg_Boot, ("initialising bootstrap"));
  
  if (job eq Null(BootstrapJob))
   fatal("not enough memory to initialise bootstrap");

  Debug(dbg_Boot, ("root processor is %P", RootProcessor));
  
  RmSetProcessorState(RootProcessor, RmS_Running);
  
  if (BootIOProcessor ne RmM_NoProcessor)
   { RmSetProcessorState(BootIOProcessor, RmS_Running);
     Debug(dbg_Boot, ("boot I/O processor is %P", BootIOProcessor));
   }
   
  if (BootIOProcessor ne RmM_NoProcessor)
   UpdateIOProcessor(BootIOProcessor, FALSE);
  UpdateProcessor(RootProcessor, FALSE);

	/* These hacks are necessary to cope with the fact that Object	*/
	/* names may have changed, and the next time the object is	*/
	/* used the name may get updated and overflow the allocated	*/
	/* buffer.							*/
  if (ThisProcessor ne Null(Object))
   { Object	*temp = ThisProcessor;
     ThisProcessor = Locate(Null(Object), ThisProcessor->Name);
     Close(temp);
   }
  if (NetAgent ne Null(Object))
   { Object	*temp = NetAgent;
     NetAgent = Locate(Null(Object), NetAgent->Name);
     NetAgent->Access = temp->Access;
     Close(temp);
   } 
    
  (void) RmApplyProcessors(Net, &StartBootstrapAux1, job);
  
  FullReset = FALSE;
  unless(StartBootstrapJob(job))
   fatal("not enough memory to start bootstrap job");

  if (get_config("waitfor_network", nsrc_environ) ne Null(char))
   WaitBootstrapJob(job);
}

static int StartBootstrapAux1(RmProcessor processor, ...)
{ va_list	args;
  BootstrapJob	*job;
  int		purpose;
    
  va_start(args, processor);
  job = va_arg(args, BootstrapJob *);
  va_end(args);

  if (processor eq RootProcessor)	return(0);
  if (processor eq BootIOProcessor)	return(0);

  purpose = RmGetProcessorPurpose(processor);

	/* BLV - do something, probably */
  if ((purpose & RmP_Mask) eq RmP_Router)
   return(0);

  if (!FullReset)
   { int	state = RmGetProcessorState(processor);
     RmSetProcessorState(processor, RmS_Special);
     if (CheckProcessor(processor))
      { if ((purpose & RmP_Mask) eq RmP_IO)
         UpdateIOProcessor(processor, FALSE);
        elif ((purpose & RmP_Mask) eq RmP_Helios)
         UpdateProcessor(processor, FALSE);
        RmSetProcessorState(processor, state);
        if ( CheckProcessor(processor))
         { RmSetProcessorState(processor, RmS_Running);
           return(0);
         }
      }
     else
      RmSetProcessorState(processor, state);
   }

  if ((purpose & RmP_Mask) eq RmP_IO)
   { RmSetProcessorState(processor, RmS_Crashed);
     return(0);
   }

  RmSetProcessorState(processor, RmS_Crashed);
  unless(AddProcessorToBootstrapJob(job, processor))
   fatal("not enough memory to initiate bootstrap");

  return(0);
}
/*}}}*/
/*{{{  bootstrap jobs - the main external interface */

/*{{{  NewBootstrapJob() */
BootstrapJob *NewBootstrapJob(void)
{ BootstrapJob	*new_job = New(BootstrapJob);
  static	int bootstrap_count = 0;
  
  if (new_job eq Null(BootstrapJob)) return(Null(BootstrapJob));
  new_job->Sequence		= bootstrap_count++;
  new_job->NumberProcessors	= 0;
  new_job->MaxProcessors	= 0;
  new_job->Next			= 0;
  new_job->Table		= Null(RmProcessor);
  new_job->Progress		= Null(RmProcessor);
  new_job->SafetyCheck		= SafetyMagic;
  InitSemaphore(&(new_job->Lock), 1);
  InitSemaphore(&(new_job->Finished), 0);
  InitSemaphore(&(new_job->ProcessesFinished), 0);
  InitSemaphore(&(new_job->LinksPending), 0);
  InitSemaphore(&(new_job->LinksEnabled), 0);
  InitSemaphore(&(new_job->ClearNames), 0);
  new_job->JobStarted		= FALSE;
  return(new_job);
}
/*}}}*/
/*{{{  AddProcessorToBootstrapJob() */

bool	AddProcessorToBootstrapJob(BootstrapJob *job, RmProcessor processor)
{ bool	result = FALSE;

  Wait(&(job->Lock));

  if (job->JobStarted) goto done;
  if (job->SafetyCheck ne SafetyMagic) goto done;
  
  if (job->NumberProcessors >= job->MaxProcessors)
   { int		amount = job->MaxProcessors;
     RmProcessor	*table = Null(RmProcessor);

     if (amount eq 0) amount = 4;
     amount *= 2;
     table = (RmProcessor *) Malloc(sizeof(RmProcessor) * (word)amount);
     if (table eq Null(RmProcessor)) goto  done;

     if (job->NumberProcessors > 0)
      { memcpy((void *) table, (void *) job->Table, 
      		job->NumberProcessors * sizeof(RmProcessor));
      	Free(job->Table);
      }

     job->Table = table;
     job->MaxProcessors	= amount;
   } 

  job->Table[job->NumberProcessors++] = processor;
  result = TRUE;

done:
  Signal(&(job->Lock));
  return(result);
}

/*}}}*/
/*{{{  StartBootstrapJob() */
bool	StartBootstrapJob(BootstrapJob *job)
{ RmProcessor	*progress_table;
  bool		result = FALSE;

  Wait(&(job->Lock));
  if (job->SafetyCheck ne SafetyMagic) goto done;
  if (job->JobStarted) goto done;
  job->JobStarted = TRUE;
  Signal(&(job->Lock));
  
  if (job->NumberProcessors eq 0)
   { result = TRUE; 
     Signal(&(job->Finished));
     Delay(2 * OneSec);
     Free(job); 
     goto done; 
   }

  progress_table = (RmProcessor *) 
  		Malloc((word) job->MaxProcessors * sizeof(RmProcessor));
  if (progress_table eq Null(RmProcessor)) goto done;
  job->Progress		= progress_table;

  if(Fork(Bootstrap_Stack, &BootstrapProcess, sizeof(BootstrapJob *), job))
   result = TRUE;
   
done:
  return(result);
}
/*}}}*/
/*{{{  WaitBootstrapJob() */
/**
*** Wait for the whole network bootstrap to finish.
*** Optionally used by startns to delay starting up the Session Manager
*** until the whole network is ready. Also used for native networks and
*** rebooting after faults. This routine is always called with a write lock.
**/
void	WaitBootstrapJob(BootstrapJob *job)
{ MRSW_SwitchRead();
  Wait(&(job->Finished));
  MRSW_FreeRead();
  MRSW_GetWrite();
}
/*}}}*/
/*{{{  AbortBootstrapJob() */
/**
*** Abandon a bootstrap job. This is used typically when filling in a
*** bootstrap job  causes memory failure.
**/
void	AbortBootstrapJob(BootstrapJob *job)
{ if (job->JobStarted) return;
  if (job->SafetyCheck ne SafetyMagic) return;
  job->SafetyCheck = 0;
  if (job->Table ne Null(RmProcessor)) Free(job->Table);
  if (job->Progress ne Null(RmProcessor)) Free(job->Progress);
  Free(job);
}
/*}}}*/

/*}}}*/
/*{{{  update processor */
/**
*** Updating processors. It is possible for a processor to be running
*** but not yet fully initialised. In particular, the root processor is
*** likely to come up as /00 instead of /Net/00. This causes a problem,
*** because the usual routines NetMapProcessorToObject() etc cannot be
*** used.
***
*** 1) Update processor. This involves running a network agent on the
***    target processor, building up the full network name, and sending
***    an update request to the network agent. After this the appropriate
***    protection mode is checked, and the processor's type and memory
***    sizes are checked. Also, links are handled.
***
*** 2) UpdateIOProcessor(). This involves running a network agent on
***    a neighbouring processor and asking it to rename a link.
**/

void UpdateProcessor(RmProcessor processor, bool name_only)
{ int			state		= RmGetProcessorState(processor);
  char			*procname	= Null(char);
  NA_Message		message;
  int			length;
  int			rc;
  int			number_links, i;
  RmProcessor		neighbour;
  bool			started_agent = FALSE;

  Debug(dbg_Boot, ("updating processor %P", processor));

  processor->ObjNode.Dates.Modified	=
  processor->ObjNode.Dates.Access	= GetDate();
          
  RmSetProcessorState(processor, RmS_Special);/* see NetMapProcessorToObject()*/

  unless(StartNetworkAgent(processor)) goto done;
  started_agent = TRUE;

  procname = (char *) Malloc(IOCDataMax);
  if (procname eq Null(char))
   { report("not enough memory to update processor %P", processor);
     goto done;
   }
  (void) BuildName(procname, processor);
  length		= strlen(procname) + 1;
  message.FnRc		= NA_Cupdate;
  message.Size		= length;
  message.Data		= procname;

  Debug(dbg_Boot, ("processor update, sending request to netagent"));

  rc = XchNetworkAgent(processor, &message, TRUE, 0, NULL);  
  if (rc ne Err_Null)
   report("warning, failed to update processor name for %P, fault %x",
   		processor, rc);

  if (name_only) goto done;
  
  do_protection(processor);

  ValidateProcessorDetails(processor);

	/* set any external links to pending. This includes links to I/O */
	/* processors other than the booting one.			 */
  number_links = RmCountLinks(processor);
  for (i = 0; i < number_links; i++)
   { int destlink;
     int current_mode;
      
     message.FnRc = NA_GetLinkMode;
     message.Arg1 = i;
     message.Size = 0;
     rc = XchNetworkAgent(processor, &message, TRUE, sizeof(int), (BYTE *) &current_mode);
     if (rc ne RmE_Success) goto done;
       
     neighbour = RmFollowLink(processor, i, &destlink);
     if (neighbour eq RmM_NoProcessor)
      { if (current_mode ne RmL_NotConnected)
         report("warning, processor %P, link %d, has a connection not shown in the resource map",
          		processor, i);
        continue;
      }

     if (neighbour ne RmM_ExternalProcessor)
      if ((RmGetProcessorPurpose(neighbour) & RmP_Mask) ne RmP_IO)
       continue;
       
     message.FnRc = NA_SetLinkMode;
     message.Arg1 = i;
     if (current_mode eq RmL_Running)
      message.Arg2 = RmL_Running;
     else
      message.Arg2 = RmL_Pending;
     message.Size  = 0;
     (void) XchNetworkAgent(processor, &message, TRUE, 0, NULL);     
   }

  (void) RmApplyMappedTasks(processor, &execute_mapped_task, processor);
done:

  Debug(dbg_Boot, ("update processor done"));
  
  if (started_agent) StopNetworkAgent(processor);
  RmSetProcessorState(processor, state);	/* restore */
  if (procname ne Null(char)) Free(procname);
}
/*}}}*/
/*{{{  update I/O processor */

void UpdateIOProcessor(RmProcessor processor, bool name_only)
{ RmProcessor		neighbour = 0;
  int			destlink;
  NA_Message		message;
  bool			netagent_started = FALSE;
  char			*procname = Null(char);
  int			state;
  int			purpose;
  int			length;
  word			rc;

  Debug(dbg_Boot, ("updating I/O processor %P", processor));

  processor->ObjNode.Dates.Modified =
  processor->ObjNode.Dates.Access   = GetDate();
  
  if (RmCountLinks(processor) ne 1)
   { report("error, I/O processor %P has more than one link",
   		processor);
     goto done;
   }
   
  neighbour = RmFollowLink(processor, 0, &destlink);
  if ((neighbour eq RmM_NoProcessor) || (neighbour eq RmM_ExternalProcessor))
   { report("error, I/O processor %P is not connected to the main network",
   		processor);
     goto done;
   }

  Debug(dbg_Boot, ("I/O processor's neighbour is %P", neighbour));

  state = RmGetProcessorState(neighbour);
  unless(state & RmS_Running) goto done;
  purpose = RmGetProcessorPurpose(neighbour);
  unless ((purpose & RmP_Mask) eq RmP_Helios) goto done;
       
  procname   = (char *) Malloc(IOCDataMax);  
  if (procname eq Null(char)) goto done;
  (void) BuildName(procname, processor);
  length	= strlen(procname) + 1;

  RmSetProcessorState(neighbour, RmS_Special);
  rc = StartNetworkAgent(neighbour);
  RmSetProcessorState(neighbour, state);
  unless (rc) goto done;
  
  netagent_started = TRUE;
    
  message.FnRc	= NA_UpdateIO;
  message.Arg1	= destlink;
  message.Size	= length;
  message.Data	= procname;
  Debug(dbg_Boot, ("sending request to netagent on neighbour"));
  rc = XchNetworkAgent(neighbour, &message, TRUE, 0, NULL);    
   
  if (rc ne Err_Null)
   report("warning, failed to update I/O processor %P, fault %x",
   	processor, rc);

  if (name_only) goto done;
  name_only = name_only;
    
done:
  Debug(dbg_Boot, ("update I/O Processor done"));
  
  if (netagent_started) StopNetworkAgent(neighbour);
  if (procname ne Null(char)) Free(procname); 
}

/*}}}*/
  
/*{{{  BootstrapProcess() - one per job */
/**
*** The real bootstrap code
***
*** A job consists of the following sequence of operations.
*** 1) attempt to reset every processor in the job. Do some admin work as
***    well, in particular invalidate capabilities and set the state.
***
*** Retry three times or as long as partial success is achieved
*** 2) find a processor to start the bootstrap from. This must be an active
***    Helios processor. Start a network agent on that processor and
***    initiate a parallel bootstrap. As each processor is booted up
***    a thread is spawned off to deal with things like protection.
*** 3) sort out all the connections for all the processors. This involves
***    setting some links to pending, then some links to running. The
***    work is done by waking up the various threads.
*** 4) clear the name tables of all the processors in this job, again by
***    waking up the various threads. At this point the various threads
***    will terminate.
**/

static	RmProcessor	find_starting_place(BootstrapJob *job, int *destlink);
static	int		actual_boot(BootstrapJob *job, RmProcessor, int link);
static	void		continue_boot(BootstrapJob *job, RmProcessor);

static void BootstrapProcess(BootstrapJob *job)
{ RmProcessor		*table = job->Table; 
  int			number = job->NumberProcessors;
  int			left   = number;
  int			i;
  int			count; 
  int			retries;
  RmProcessor		start;
  int			destlink;
  ProcessorEntry	*proc_entry;
  bool			all_done = TRUE;

  MRSW_GetRead();

  Debug(dbg_Boot, ("starting bootstrap job %d for %d processors", job->Sequence, number));
    
  for (i = 0; i < number; i++)
   { RmProcessor processor = table[i];
     int	 state     = RmGetProcessorState(processor);
     state &= ~(RmS_Running | RmS_Suspicious | RmS_Crashed | RmS_Dead);
     state |= RmS_Booting;
     (void) RmSetProcessorState(processor, state);
     proc_entry = GetProcEntry(processor);
     memset((void *) &(proc_entry->Owner), 0, 2 * sizeof(Capability));
   }

  Debug(dbg_Boot, ("attempting initial resets for job %d", job->Sequence));
       
  ResetProcessors(number, table);

	/* Native processors should not be considered further   */
  for (i = 0; i < number; i++)
   { RmProcessor processor = table[i];
     if ((RmGetProcessorPurpose(processor) & RmP_Mask) eq RmP_Native)
      { RmSetProcessorState(processor, RmS_Running);
        left--;	/* There is one less processor to boot up	*/
      }
   }

  for (retries = 0; (retries < MaxRetries) && (left > 0); )
   { 
     start = find_starting_place(job, &destlink);
     if (start eq (RmProcessor) NULL)
      {	report("error, cannot find a suitable processor from which to continue bootstrap");
	break;
      }

     Debug(dbg_Boot, ("bootstrap job %d, attempt %d, starting from %P", \
     	job->Sequence, retries+1, start));
     i = actual_boot(job, start, destlink);
     if (i eq 0)	/* None booted this time around */
      { retries++; continue; }
     left -= i;
   }

  Debug(dbg_Boot, ("bootstrap, enabling all the connections for job %d", job->Sequence));

	/* Step 1, let all the threads set suitable links to pending */
  for (i = 0, count = 0; i < job->NumberProcessors; i++)
   { RmProcessor processor	= job->Table[i];
     if ((RmGetProcessorPurpose(processor) & RmP_Mask) ne RmP_Helios) continue;
     unless(RmGetProcessorState(processor) & RmS_Running) continue;
     Signal(&(job->LinksPending));
     count++;
   }

  for (i = 0; i < count; i++)	/* wait for all the threads */
   Wait(&(job->ProcessesFinished));
  
	/* Step 2, let the same threads enable cross links */
  for (i = 0; i < count; i++)
   Signal(&(job->LinksEnabled));
  for (i = 0; i < count; i++)
   Wait(&(job->ProcessesFinished));

	/* Step 3, clear the name tables */	
  for (i = 0; i < count; i++)
   Signal(&(job->ClearNames));
  for (i = 0; i < count; i++)
   Wait(&(job->ProcessesFinished));

	/* Step 4, there might still be extra threads lying around	*/
	/* which have not been woken up because their processors have	*/
	/* crashed. I think this will only happen if count is currently	*/
	/* zero. Usually this will be a no-op.				*/
  for (i = 0; i < job->NumberProcessors; i++)
   Signal(&(job->LinksPending));

  Debug(dbg_Boot, ("bootstrap job %d done", job->Sequence));

	/* Final report on this job */
  for (i = 0; i < job->NumberProcessors; i++)
   { RmProcessor processor	= job->Table[i];
     int	 state 		= RmGetProcessorState(processor);
     if (state & RmS_Running)
      { state &= ~RmS_Booting;
        RmSetProcessorState(processor, state);
      }
     else
      { if (!(state & RmS_AutoBoot))
         report("failed to boot processor %P", processor);
        if (!(state & (RmS_Suspicious | RmS_Crashed)))
         { state |= RmS_Dead;
           state &= ~(RmS_AutoBoot | RmS_Booting | RmS_Running);
	   RmSetProcessorState(processor, state);
         }
        all_done = FALSE;
      }
   }

  if (job->Sequence eq 0)
   { if (all_done)
      report("network booted.");
     else
      report("network partly booted.");
   }

  MRSW_FreeRead();

  Signal(&(job->Finished));   	/* See WaitBootstrap() above */
  Free(job->Progress);
  Free(job->Table);
  Delay(OneSec);		/* Yukk, WaitBootstrap() may be waiting on */
  				/* a semaphore in this structure.	   */
  Free(job);
}
/*}}}*/
/*{{{  resetting processors */

/**
*** Try to reset every processor in a job. If a particular processor is already
*** reset skip it (to avoid executing tr_reset a hundred times etc.). Otherwise
*** assert a definite reset if there is one, otherwise a conditional reset
*** if there is one.
**/

static void TryResetCommand(RmProcessor processor, RmHardwareFacility *);

int ResetProcessors(int count, RmProcessor *table)
{ int			i, j, k, l, state;
  int			successes = 0;
  DriverRequest		*request;
  ProcessorEntry	*proc_entry;
  DriverEntry		*driver_entry;
  RmHardwareFacility	*hardware;
  NetworkDCB		*device;

  request = Malloc(sizeof(DriverRequest) + ((word)count * sizeof(RmProcessor)));
  if (request eq Null(DriverRequest))
   return(RmE_ServerMemory);

	/* Set all the processors to ShouldBeReset */
  for (i = 0; i < count; i++)
   table[i]->ObjNode.Size |= RmS_ShouldBeReset;
   
	/* Go through the list of processors three times.	*/
	/* First look for device drivers with a definite reset.	*/
	/* Then look for device drivers with a possible reset.	*/
	/* Then look for reset commands.			*/          
  for (i = 0; i < count; i++)	/* for every processor */
   { RmProcessor	processor	= table[i];

     state = RmGetProcessorState(processor);
     if ((state & RmS_Reset) || ((state & RmS_ShouldBeReset) eq 0))
      continue;

     proc_entry = GetProcEntry(processor);

     for (j = 0; j < proc_entry->NumberDrivers; j++)
      { driver_entry	= &(proc_entry->DriverEntry[j]);
        hardware	= driver_entry->Hardware;
	device		= hardware->Device;
	
        if ((hardware->Type ne RmH_ResetDriver) &&
            (hardware->Type ne RmH_ConfigureDriver))
         continue;	/* next driver */

        unless (driver_entry->Flags & DriverFlags_DefiniteReset)
         continue;	/* next driver */
         
        request->FnRc			= ND_Reset;
        request->NumberProcessors	= 1;
        request->Processor[0]		= processor;

		/* look for other processors controlled by the same driver */
        for (k = i + 1; k < count; k++)
	 { RmProcessor		temp = table[k];
	   ProcessorEntry	*temp_entry;

	   if (RmGetProcessorState(temp) & RmS_Reset) continue;

	   temp_entry = GetProcEntry(temp);
	   for (l = 0; l < temp_entry->NumberDrivers; l++)
	    { DriverEntry *driver = &(temp_entry->DriverEntry[l]);
	      if (driver->Hardware ne hardware) continue;
	      unless(driver->Flags & DriverFlags_DefiniteReset) continue;
	      request->Processor[request->NumberProcessors] = temp;
	      request->NumberProcessors++;
	      break;
	    }
	 }	/* for subsequent processors in the same job.	*/
	 
	(*(device->DCB.Operate))(device, request);
        if (RmGetProcessorState(processor) & RmS_Reset) break;
      }	/* for every driver in the current processor */
   } /* for every processor in the job */

	/* Look for possible resets only.	*/
  for (i = 0; i < count; i++)	/* for every processor */
   { RmProcessor	processor	= table[i];

     state = RmGetProcessorState(processor);
     if ((state & RmS_Reset) || ((state & RmS_ShouldBeReset) eq 0))
      continue;

     proc_entry = GetProcEntry(processor);

     for (j = 0; j < proc_entry->NumberDrivers; j++)
      { driver_entry	= &(proc_entry->DriverEntry[j]);
        hardware	= driver_entry->Hardware;
	device		= hardware->Device;
	
        if ((hardware->Type ne RmH_ResetDriver) &&
            (hardware->Type ne RmH_ConfigureDriver))
         continue;	/* next driver */
         
        unless (driver_entry->Flags & DriverFlags_PossibleReset)
         continue;	/* next driver */
         
        request->FnRc			= ND_Reset;
        request->NumberProcessors	= 1;
        request->Processor[0]		= processor;

		/* look for other processors controlled by the same driver */
        for (k = i + 1; k < count; k++)
	 { RmProcessor		temp = table[k];
	   ProcessorEntry	*temp_entry;

	   if (RmGetProcessorState(temp) & RmS_Reset) continue;

	   temp_entry = GetProcEntry(temp);
	   for (l = 0; l < temp_entry->NumberDrivers; l++)
	    { DriverEntry *driver = &(temp_entry->DriverEntry[l]);
	      if (driver->Hardware ne hardware) continue;
	      unless(driver->Flags & DriverFlags_PossibleReset) continue;
	      request->Processor[request->NumberProcessors] = temp;
	      request->NumberProcessors++;
	      break;
	    }
	 }	/* for subsequent processors in the same job.	*/
	 
	(*(device->DCB.Operate))(device, request);
        if (RmGetProcessorState(processor) & RmS_Reset) break;
      }	/* for every driver in the current processor */
   } /* for every processor in the job */

	/* Finally look for reset commands */
  for (i = 0; i < count; i++)	/* for every processor */
   { RmProcessor	processor	= table[i];

     state = RmGetProcessorState(processor);
     if ((state & RmS_Reset) || ((state & RmS_ShouldBeReset) eq 0))
      continue;

     proc_entry = GetProcEntry(processor);

     for (j = 0; j < proc_entry->NumberDrivers; j++)
      { driver_entry	= &(proc_entry->DriverEntry[j]);
        hardware	= driver_entry->Hardware;
	device		= hardware->Device;
	
        if (hardware->Type ne RmH_ResetCommand)
         continue;	/* next driver */

        TryResetCommand(processor, hardware);         

      }	/* for every driver in the current processor */
   } /* for every processor in the job */
   
  for (i = 0; i < count; i++)
   { RmProcessor processor = table[i];
     state = RmGetProcessorState(processor);
     if (state & RmS_Reset) successes++;
     state &= ~RmS_ShouldBeReset;
     RmSetProcessorState(processor, state);
   }

  Free(request);  
  if (successes eq count)
   return(RmE_Success);
  else
   return(RmE_PartialSuccess);
}

/**
*** Reset commands. Various conditions have to be met.
*** 1) if the processor is believed to be reset already, do not use this
***    command. The cost is excessive.
*** 2) if the controller processor is not running, the command cannot be
***    used.
*** 3) if any of the controlled processors should not be reset, do not
***    use this command.
*** Otherwise use the command and update all the processors.
**/
static	void TryResetCommand(RmProcessor processor, RmHardwareFacility *hardware)
{ RmProcessor	controller;
  int		i;
  int		state = RmGetProcessorState(processor);
  RmTask	task;
  Environ	env;
  Environ	*net_env;
    
  if ((state & RmS_Reset) ne 0) return;	/* do not reset again */

  controller = (RmProcessor) hardware->Essential;
  state = RmGetProcessorState(controller);
  unless ((state & RmS_Running) ne 0) return;
  
  for (i = 0; i < hardware->NumberProcessors; i++)
   { if (hardware->Processors[i] eq processor) continue;
     state = RmGetProcessorState(hardware->Processors[i]);
     unless ((state & RmS_ShouldBeReset) ne 0)
      return;
   }    
	/* OK, it looks like the command can be used.	*/
  task = (RmTask) hardware->Device;

  if (task->ObjNode.Name[0] eq '0')
   (void) rexec_task(controller, task, Null(Environ), 5 * OneSec);
  else
   { net_env	= getenviron();
     env.Strv	= net_env->Strv;
     env.Objv	= net_env->Objv;
     env.Envv	= net_env->Envv;
     (void) rexec_task(controller, task, &env, 5 * OneSec);
   }
 
  for (i = 0; i < hardware->NumberProcessors; i++)
   { state = RmGetProcessorState(hardware->Processors[i]);
     state |= RmS_Reset;
     (void) RmSetProcessorState(hardware->Processors[i], state);
   }
}   

/*}}}*/
/*{{{  find a starting place for the bootstrap */

/**
*** Find a processor to start the bootstrap from. This must satisfy the
*** following requirements.
*** 1) it must be adjacent to one of the processors in the job not already
***    booted.
*** 2) it must be running, or booting but not ShouldReset (implies booted in
***    this job)
*** 3) if successful, the boot job is rearranged somewhat to avoid finding
***    the same starting processor everytime.
*** There are special cases. If a bootstrap fails then that link is set to
*** Suspicious. The link will not be used again for a bootstrap unless
*** there is no choice. If a link is set to delayed mode then it has not
*** yet been made by the configuration/routing hardware and this routine
*** should wait a little while before continuing.
**/
static RmProcessor find_starting_place(BootstrapJob *job, int *destlink)
{ RmProcessor	processor;
  int		i, j;
  int		state;
  int		number_links;
  int		purpose;
  RmProcessor	neighbour;
  int		flags;
  RmProcessor	suspicious = (RmProcessor) NULL;
  int		suspect_link = 0;
  RmProcessor	delayed	= (RmProcessor) NULL;
  int		retries = 0;

retry:  
  for (i = 0; i < job->NumberProcessors; i++)
   { processor	= job->Table[i];
     state	= RmGetProcessorState(processor);

     unless ((state & RmS_Booting) && !(state & RmS_Running))
      continue;
      
     number_links = RmCountLinks(processor);
     for (j = 0; j < number_links; j++)
      { neighbour = RmFollowLink(processor, j, destlink);
        if ((neighbour eq RmM_NoProcessor) ||
           (neighbour eq RmM_ExternalProcessor))
         continue;

        purpose = RmGetProcessorPurpose(neighbour);
        unless((purpose & RmP_Mask) eq RmP_Helios) continue;

        state = RmGetProcessorState(neighbour);
        unless(state  & RmS_Running)
         continue;
         
	flags = RmGetLinkFlags(neighbour, *destlink);
	if (flags & RmF_Delayed)
         delayed = neighbour;
	elif (flags & RmF_Suspicious) 
	 { suspicious   = neighbour;
	   suspect_link = *destlink;
	 }
	else
         goto found;        
      }
   }
   
  if (delayed ne (RmProcessor) NULL)
   { if (++retries >= 5 * 60)
      { report("the link to processor %P is not appearing", delayed);
        goto done;
      }
     if ((retries % 10) eq 0)
      report("waiting for link to processor %P", delayed);
     Delay(OneSec);
     delayed = suspicious = (RmProcessor) NULL;
     goto retry;
   }
   
done:      
  if (suspicious ne (RmProcessor) NULL)
   { *destlink = suspect_link;
     return(suspicious);
   }
  else
   return((RmProcessor) NULL);

	/* Processor is a processor in this job which should be booted.  */
	/* neighbour is a suitable processor from which to start the	 */
	/* bootstrap. Swap Processor and the last processor in the table */
found:
  { RmProcessor	temp = job->Table[job->NumberProcessors - 1];       
    job->Table[job->NumberProcessors - 1] = processor;
    job->Table[i] = temp;
  }

  return(neighbour);
}

/*}}}*/
/*{{{  use the starting place to initiate the parallel bootstrap */

/**
*** actual_boot()
***
*** Attempt to initiate a parallel bootstrap from a given starting processor.
*** This means attempting to boot the first processor. If that is successful
*** a process is forked off to continue the bootstrap. Then the routine
*** waits for all the processes to terminate.
**/
static bool boot_down_link(RmProcessor start, int link);

static int actual_boot(BootstrapJob *job, RmProcessor start, int link)
{ RmProcessor	*progress = job->Progress;
  RmProcessor	next;
  int		destlink;
  int		booted;
  int		i, j;
    
  next = RmFollowLink(start, link, &destlink);

  unless(StartNetworkAgent(start)) return(0);

  booted = (int) boot_down_link(start, link);
  StopNetworkAgent(start);

  if (!booted) return(0);
  progress[job->Next++] = next;

  InitSemaphore(&(job->ProcessesFinished), 0);
  job->NumberProcesses = 1;
  
  if (!Fork(Bootstrap_Stack, &continue_boot, 8, job, next))
   return(1);
   
  for(i = 0; ; i++)
   { Wait(&(job->Lock));
     j = job->NumberProcesses;
     Signal(&(job->Lock));
     if (i eq j) break;
     Wait(&(job->ProcessesFinished));
   }

  return(job->NumberProcesses);
}

/*}}}*/
/*{{{  continue the bootstrap from a newly-booted processor, in parallel */

/**
*** Once a processor has been booted, this process is Fork'ed off
*** to see whether or not it is possible to do some more booting from
*** this processor, and then initialise the processor.
***
*** It is necessary to serialise the checks for each link, because a given
*** processor might be examined as a possible bootstrap target from more
*** than one other process. The locking is fairly brutal, but safe.
***
*** The newly-booted processor will already be running the Network Agent,
*** because that happens as the final test in boot_down_link(). The
*** agent is currently shut down at the end of this thread.
**/

static void continue_boot(BootstrapJob *job, RmProcessor current)
{ int	 		linkcount	= RmCountLinks(current);
  int	 		state;
  ProcessorEntry	*its_proc_entry;  
  int			j, k;
  int			destlink;
  RmProcessor		next;
  int			temp;

  unless(SilentMode)
   report("processor %P booted.", current);

	/* If there are any system programs that are supposed to run on	*/
	/* this processor, run them now.				*/
  (void) RmApplyMappedTasks(current, &execute_mapped_task, current);
        
  for (j = 0; j < linkcount; j++)
   { 
     Wait(&(job->Lock));
     
     next = RmFollowLink(current, j, &destlink);
     if ((next eq RmM_NoProcessor) || (next eq RmM_ExternalProcessor))
         goto next_link;
     state = RmGetProcessorState(next);
     unless((state & RmS_Booting) && !(state & RmS_Running))
      goto next_link;

     its_proc_entry = GetProcEntry(next);
     if (its_proc_entry->BeingBooted)
      goto next_link;

		/* Cope with the special case of subnet names		*/
		/* If there is a processor /Net/Cluster/07 and the	*/
		/* current processor is not inside /Net/Cluster and	*/
		/* some processor inside /Net/Cluster has been booted	*/
		/* already , do not boot down this link because the	*/
		/* system's distributed search will fail to find the	*/
		/* processor.						*/
     if (RmParentNetwork(current) ne RmParentNetwork(next))
      { RmNetwork	parent = RmParentNetwork(next);
	bool		first_in_subnet = TRUE;
        for (k = 0; k < job->Next; k++)
         if ((current ne job->Table[k]) && 
             (parent eq RmParentNetwork(job->Table[k])))
          { first_in_subnet = FALSE; break; }
        unless(first_in_subnet) goto next_link;
      }

		/* Check that the processor really is in this bootstrap	*/
		/* job. It is conceivable that there are two bootstrap	*/
		/* jobs at any one time, with connected processors.	*/
     { bool in_job	= FALSE;
       for (k = 0; k < job->NumberProcessors; k++)
        if (next eq job->Table[k])
         { in_job = TRUE; break; }
       if (!in_job) goto next_link;
     }

		/* prevent other processes from booting this processor	*/
		/* at the same time.					*/
     its_proc_entry->BeingBooted = TRUE;
     
		/* let other processes check whether or not they can	*/
		/* do some booting.					*/
     Signal(&(job->Lock));

     temp = (int) boot_down_link(current, j);

		/* Re-lock, before storing the results.			*/
     Wait(&(job->Lock));		

     its_proc_entry->BeingBooted = FALSE;
     if (temp)
      { job->Progress[job->Next++] = next;
        if (job->Sequence eq 0)
         LastBooted = next;
        if (Fork(Bootstrap_Stack, &continue_boot, 8, job, next))
         job->NumberProcesses++;
      }

next_link:
     Signal(&(job->Lock));	/* unlock for this link			*/
   }

	/* Setting the protection and validating details like processor	*/
	/* type can be done immediately after bootstrap. In fact they	*/
	/* should be done at this point.				*/
  do_protection(current);
  ValidateProcessorDetails(current);

	/* If one of the system programs was console, clean up.		*/
  { ProcessorEntry *proc_entry = GetProcEntry(current);
    if (proc_entry->WindowServer != Null(Object))
     Close(proc_entry->WindowServer);
    if (proc_entry->ConsoleWindow != Null(Object))
     Close(proc_entry->ConsoleWindow);
    proc_entry->WindowServer = proc_entry->ConsoleWindow = Null(Object);
  }

	/* Inform the main bootstrap process that this thread is ready	*/
  Signal(&(job->ProcessesFinished));

	/* At this point the thread has to block while the remaining	*/
	/* processors in the job get booted. Once that stage is		*/
	/* finished it is necessary to fiddle with cross-links etc.	*/
  Wait(&(job->LinksPending));

	/* There is a problem here if the processor being handled by	*/
	/* this thread has failed after all the commands have run but	*/
	/* before the main bootstrap thread is ready to enable cross	*/
	/* links. This thread may have received a wake-up it should not	*/
	/* have. 							*/
  if ((!(RmGetProcessorState(current) & RmS_Running)) ||
      ((RmGetProcessorPurpose(current) & RmP_Mask) ne RmP_Helios))
   { Signal(&(job->LinksPending)); goto done; }

	/* Set certain links to pending.				*/
  set_pending(current, job);

	/* Synchronise with the other threads.				*/
  Signal(&(job->ProcessesFinished));
  Wait(&(job->LinksEnabled));

	/* Set other links to running.					*/
  if (RmGetProcessorState(current) & RmS_Running)
   set_enabled(current, job);

	/* Synchronise again.						*/
  Signal(&(job->ProcessesFinished));
  Wait(&(job->ClearNames));

	/* There are problems in the Processor Manager when		*/
	/* deleting names while system tasks are starting up. This	*/
	/* should bypass the problems.					*/
  if ((RmCountMappedTasks(current) eq 0) &&
      (RmGetProcessorState(current) & RmS_Running))
   { NA_Message	    message;
     message.FnRc = NA_ClearNames;
     message.Size = 0;
     XchNetworkAgent(current, &message, FALSE, 0, NULL);
   }

	/* And finish off */
  Signal(&(job->ProcessesFinished));  
done:
  StopNetworkAgent(current);
}

/*}}}*/
/*{{{  boot down link */

/**
*** Boot the neighbour of the given processor down the link specified.
*** If any of the device drivers indicate a special bootstrap, the
*** bootstrap routine is executed. If that fails the network server will
*** default to the standard bootstrap mechanism.
***
*** First a configuration vector is built up. This may include a field
*** for the nucleus if the target and current processors are of incompatible
*** type, or if a special nucleus has been specified for either of them.
*** Next, the processor is reset again. Even if the processor was reset
*** earlier on in the bootstrap sequence there is no guarantee that
*** it is still reset, and better safe than sorry. If there are several
*** different ways to reset a processor only the first successful
*** one is used.
***
**/
/*{{{  build a transputer configuration vector */

/**
*** Build a configuration vector suitable for booting processor dest
*** through its link destlink, from processor source through its
*** sourcelink. This is not easy.
***
*** The first step is to figure out which nucleus to use. This depends
*** on whether or not special nuclei have been specified in the resource
*** map, on the processor types, etc. Default nuclei for different
*** processors are handled by the following routine.
**/

static char	*default_nucleus(RmProcessor processor)
{ int	type = RmGetProcessorType(processor);
  switch(type)
   { case	RmT_Default	:
     case	RmT_T800	:
     case	RmT_T414	:
     case	RmT_T425	:
     case	RmT_T400	:
     case	RmT_i860	:
     case	RmT_C40		: /* until heterogenous networks... */
				  return("/helios/lib/nucleus");
     default			: return(Null(char));
   }
}

/**
*** If the resource map specifies a nucleus for either source or destination
*** processor, and the two are different, then it is easy to pick a
*** nucleus. Otherwise default nuclei are obtained for both processors
*** and compared. If the same, easy.
**/

bool		BuildTRANConfig(RmProcessor source,
	RmProcessor dest, int destlink, Config **config_vec, word *confsize)
{ char			*nucleus_string = "";
  char			*source_nuc	= (char *)RmGetProcessorNucleus(source);
  char			*dest_nuc	= (char *)RmGetProcessorNucleus(dest);  
  char			*buffer		= Null(char);
  int			length = 0, temp_length;
  int			number_links;
  int			i;
  bool			result		= FALSE;
  Config		*config;
  ProcessorEntry	*proc_entry;      

  proc_entry = GetProcEntry(dest);

  if (source_nuc ne Null(char))
   if (source_nuc[0] eq '\0')
    source_nuc = Null(char);

  if (dest_nuc ne Null(char))
   if (dest_nuc[0] eq '\0')
    dest_nuc = Null(char);
          
  if ((source_nuc eq Null(char)) && (dest_nuc ne Null(char)))
   { nucleus_string = dest_nuc; goto done_nuc; }

  if ((source_nuc ne Null(char)) && (dest_nuc eq Null(char)))
   { nucleus_string = default_nucleus(dest); goto done_nuc; }

  if ((source_nuc ne Null(char)) && (dest_nuc ne Null(char)))
   { if (strcmp(source_nuc, dest_nuc)) nucleus_string = dest_nuc;
     goto done_nuc;
   }

  source_nuc = default_nucleus(source);
  dest_nuc   = default_nucleus(source);
  if (source_nuc ne dest_nuc)		/* Assumes constant strings */
   nucleus_string = dest_nuc;
  
done_nuc:
  temp_length = strlen(nucleus_string) + 1;
  temp_length = (temp_length + 3) & ~3;

  buffer = (char *) Malloc(IOCDataMax);
  if (buffer eq Null(char)) goto done;
  
  (void) BuildName(buffer, source);
  temp_length += strlen(buffer) + 1;
  (void) BuildName(buffer, dest);
  temp_length += strlen(buffer) + 1;

  temp_length += sizeof(Config);
  number_links = RmCountLinks(dest);
  if (number_links > 4)
   temp_length = temp_length + ((number_links - 4) * sizeof(LinkConf));
  length = (temp_length + 3) & ~3;
  
  if (length > IOCDataMax)
   { report("internal error, the bootstrap information for %P is too large", dest);
     goto done;
   }

  strcpy(buffer, nucleus_string);
  temp_length = strlen(nucleus_string) + 1;
  temp_length = (temp_length + 3) & ~3;
  
  config = (Config *) &(buffer[temp_length]);
  config->PortTabSize	= 32;
  config->Incarnation	= proc_entry->Incarnation++;
  config->ImageSize	= 0;	/* Filled in by Netagent */
  config->Date		= 0;	/* Ditto.		 */
  config->MemSize	= RmGetProcessorMemory(dest);
  config->NLinks	= number_links;
  config->FirstProg	= 6;
  config->Flags		= 0;
  config->LoadBase	= (MPtr) 0x80001000;

  for (i = 0; i < number_links; i++)
   { config->LinkConf[i].Flags	= 0;
     config->LinkConf[i].Mode	= Link_Mode_Null;
     config->LinkConf[i].State	= Link_State_Null;
     config->LinkConf[i].Id	= i;
   }
  config->LinkConf[destlink].Flags	=
  		 (Link_Flags_parent + Link_Flags_debug);
  config->LinkConf[destlink].Mode	= Link_Mode_Intelligent;
  config->LinkConf[destlink].State	= Link_State_Running;

  { char *temp  = (char *) config;
    temp = &(temp[sizeof(Config)]);
    if (number_links > 4)
     temp = &(temp[(number_links - 4) * sizeof(LinkConf)]);
    config->MyName	= temp - (char *) &(config->MyName);
    temp		= BuildName(temp, dest);
    config->ParentName	= temp - (char *) &(config->ParentName);
    (void)BuildName(++temp, source);
  }

  result = TRUE;

done:
  if (result)
   { *config_vec	= (Config *) buffer;
     *confsize		= length;
   }
  else
   { *config_vec	= Null(Config);
     *confsize		= 0;
     if (buffer ne Null(char)) Free(buffer);
   }
  return(result);
}

/*}}}*/
/*{{{  build a C40 configuration vector */

/*{{{  decode() */
/** This little routine decodes ascii strings back to binary. Ascii
*** strings are used to hold the hardware configuration word and
*** the idrom info.
**/
static void decode(char *text, byte *dest)
{ while (*text ne '\0')
   { int x;
     if ((*text >= '0') && (*text <= '9'))
      x = *text - '0';
     else
      x = *text - 'a' + 10;
     x = (x << 4) & 0x0F0;
     text++;
     if ((*text >= '0') && (*text <= '9'))
      x += *text - '0';
     else
      x += *text - 'a' + 10;
     text++;
     *dest++ = x;
   }
}
/*}}}*/

bool		BuildC40Config(RmProcessor source,
	RmProcessor dest, int destlink, Config **config_vec, word *confsize)
{ char			*nucleus_string = "";
  char			*source_nuc	= (char *)RmGetProcessorNucleus(source);
  char			*dest_nuc	= (char *)RmGetProcessorNucleus(dest);  
  char			*bootfile	= RmGetObjectAttribute((RmObject) dest, "bootfile", TRUE);
  char			*hwconfig	= RmGetObjectAttribute((RmObject) dest, "hwconfig", TRUE);
  char			*idrom		= RmGetObjectAttribute((RmObject) dest, "idrom", TRUE);
  char			*buffer		= Null(char);
  int			length;
  int			number_links;
  int			i;
  bool			result		= FALSE;
  Config		*config;
  int			 config_length;
  ProcessorEntry	*proc_entry;      
  C40_Bootstrap		*boot_info = NULL;

  proc_entry = GetProcEntry(dest);

  if (source_nuc ne Null(char))
   if (source_nuc[0] eq '\0')
    source_nuc = Null(char);

  if (dest_nuc ne Null(char))
   if (dest_nuc[0] eq '\0')
    dest_nuc = Null(char);
          
  if ((source_nuc eq Null(char)) && (dest_nuc ne Null(char)))
   { nucleus_string = dest_nuc; goto done_nuc; }

  if ((source_nuc ne Null(char)) && (dest_nuc eq Null(char)))
   { nucleus_string = default_nucleus(dest); goto done_nuc; }

  if ((source_nuc ne Null(char)) && (dest_nuc ne Null(char)))
   { if (strcmp(source_nuc, dest_nuc)) nucleus_string = dest_nuc;
     goto done_nuc;
   }

  source_nuc = default_nucleus(source);
  dest_nuc   = default_nucleus(source);
  if (source_nuc ne dest_nuc)		/* Assumes constant strings */
   nucleus_string = dest_nuc;
  
done_nuc:

	/* Work out the size of the C40 bootstrap structure.		*/
  length	= sizeof(C40_Bootstrap);

  if (nucleus_string[0] ne '\0')
   length += strlen(nucleus_string) + 1;

  if (bootfile ne NULL)
   length += strlen(bootfile) + 1;

	/* Now add on the size of the configuration vector. This	*/
	/* requires knowing the size of the two processor names, for	*/
	/* which I need a buffer. This same buffer can then be used for	*/
	/* the actual bootstrap info.					*/
  buffer = (char *) Malloc(IOCDataMax);
  if (buffer eq Null(char)) goto done;

  config_length	= sizeof(Config);
  (void) BuildName(buffer, source);
  config_length	+= strlen(buffer) + 1;
  (void) BuildName(buffer, dest);
  config_length	+= strlen(buffer) + 1;

  number_links = RmCountLinks(dest);
  if (number_links > 4)
     config_length	+= ((number_links - 4) * sizeof(LinkConf));
  config_length = (config_length + 3) & ~3;

  length -= sizeof(Config);	/* Do not count this twice	*/
  length += config_length;
  length  = (length + 3) & ~3;

  if (length > IOCDataMax)
   { report("internal error, the bootstrap information for %P is too large", dest);
     goto done;
   }

  boot_info		= (C40_Bootstrap *) buffer;
  config		= &(boot_info->Config);
  boot_info->Nucleus	= 0;
  boot_info->Bootfile	= 0;

  if (hwconfig eq NULL)
   {	/* If there is no hardware config information in an idrom file	*/
	/* then I want to default to values used in the bootstrap of	*/
	/* the root processor, i.e. the host.con values.		*/
#ifndef __C40
	/* Heterogenous network, there is no hwconfig word...		*/
     boot_info->Hwconfig	= 0;
#else
     word this_hwconfig	= GetHWConfig();
     boot_info->Hwconfig	= 0;
     if (this_hwconfig & HW_NucleusLocalS1)
      boot_info->Hwconfig	|= HW_NucleusLocalS1;
     elif (this_hwconfig & HW_NucleusGlobalS0)
      boot_info->Hwconfig	|= HW_NucleusGlobalS0;
     elif (this_hwconfig & HW_NucleusGlobalS1)
      boot_info->Hwconfig	|= HW_NucleusGlobalS1;
     if (this_hwconfig & HW_CacheOff)
      boot_info->Hwconfig	|= HW_CacheOff;
#endif
   }
  else
   decode(hwconfig, (BYTE *) &(boot_info->Hwconfig));

  if (idrom ne NULL)
   decode(idrom, (BYTE *) &(boot_info->Idrom));
  boot_info->ConfigSize	= config_length;

  buffer	 = (BYTE *) boot_info;
  buffer	+= offsetof(C40_Bootstrap, Config);
  buffer	+= config_length;

  if (nucleus_string[0] ne '\0')
   { strcpy(buffer, nucleus_string);
     boot_info->Nucleus = (RPTR) buffer;
     boot_info->Nucleus = ATOR(boot_info->Nucleus);
     buffer += strlen(nucleus_string) + 1;
   }
  if (bootfile ne NULL)
   { strcpy(buffer, bootfile);
     boot_info->Bootfile = (RPTR) buffer;
     boot_info->Bootfile = ATOR(boot_info->Bootfile);
   }

  config->PortTabSize	= 32;
  config->Incarnation	= proc_entry->Incarnation++;
  config->ImageSize	= 0;	/* Filled in by Netagent */
  config->Date		= 0;	/* Ditto.		 */
  config->MemSize	= RmGetProcessorMemory(dest);
  config->NLinks	= number_links;
  config->FirstProg	= 6;
  config->Flags		= 0;
  config->Spare[0]      = 0;
  if (boot_info->Hwconfig & HW_CacheOff)
   config->Flags |= Root_Flags_CacheOff;
  config->LoadBase	= 0;
  for (i = 0; i < number_links; i++)
   { config->LinkConf[i].Flags	= 0;
     config->LinkConf[i].Mode	= Link_Mode_Null;
     config->LinkConf[i].State	= Link_State_Null;
     config->LinkConf[i].Id	= i;
   }
  config->LinkConf[destlink].Flags	=
  		 (Link_Flags_parent + Link_Flags_debug);
  config->LinkConf[destlink].Mode	= Link_Mode_Intelligent;
  config->LinkConf[destlink].State	= Link_State_Running;

  { char *temp  = (char *) config;
    temp = &(temp[sizeof(Config)]);
    if (number_links > 4)
     temp = &(temp[(number_links - 4) * sizeof(LinkConf)]);
    config->MyName	= temp - (char *) &(config->MyName);
    temp		= BuildName(temp, dest);
    config->ParentName	= temp - (char *) &(config->ParentName);
    (void)BuildName(++temp, source);
  }

  result = TRUE;

done:
  if (result)
   { *config_vec	= (Config *) boot_info;
     *confsize		= length;
   }
  else
   { *config_vec	= Null(Config);
     *confsize		= 0;
     if (buffer ne Null(char)) Free(buffer);
   }
  return(result);
}

/*}}}*/
/*{{{  build an i860 configuration vector */

bool Build_i860Config(RmProcessor source,
	RmProcessor dest, int destlink, Config **config_vec, word *confsize)
{ char			*nucleus_string = "";
  char			*source_nuc	= (char *)RmGetProcessorNucleus(source);
  char			*dest_nuc	= (char *)RmGetProcessorNucleus(dest);  
  char			*buffer		= Null(char);
  int			length = 0, temp_length;
  int			number_links;
  int			i;
  bool			result		= FALSE;
  Config		*config;
  ProcessorEntry	*proc_entry;      

  proc_entry = GetProcEntry(dest);

  if (source_nuc ne Null(char))
   if (source_nuc[0] eq '\0')
    source_nuc = Null(char);

  if (dest_nuc ne Null(char))
   if (dest_nuc[0] eq '\0')
    dest_nuc = Null(char);
          
  if ((source_nuc eq Null(char)) && (dest_nuc ne Null(char)))
   { nucleus_string = dest_nuc; goto done_nuc; }

  if ((source_nuc ne Null(char)) && (dest_nuc eq Null(char)))
   { nucleus_string = default_nucleus(dest); goto done_nuc; }

  if ((source_nuc ne Null(char)) && (dest_nuc ne Null(char)))
   { if (strcmp(source_nuc, dest_nuc)) nucleus_string = dest_nuc;
     goto done_nuc;
   }

  source_nuc = default_nucleus(source);
  dest_nuc   = default_nucleus(source);
  if (source_nuc ne dest_nuc)		/* Assumes constant strings */
   nucleus_string = dest_nuc;
  
done_nuc:

  temp_length = strlen(nucleus_string) + 1;
  temp_length = (temp_length + 3) & ~3;

  buffer = (char *) Malloc(IOCDataMax);
  if (buffer eq Null(char)) goto done;
  
  (void) BuildName(buffer, source);
  temp_length += strlen(buffer) + 1;
  (void) BuildName(buffer, dest);
  temp_length += strlen(buffer) + 1;

  temp_length += sizeof(Config);
  number_links = RmCountLinks(dest);
  if (number_links > 4)
   temp_length = temp_length + ((number_links - 4) * sizeof(LinkConf));
  length = (temp_length + 3) & ~3;
  
  if (length > IOCDataMax)
   { report("internal error, the bootstrap information for %P is too large", dest);
     goto done;
   }

  strcpy(buffer, nucleus_string);
  temp_length = strlen(nucleus_string) + 1;
  temp_length = (temp_length + 3) & ~3;
  
  config = (Config *) &(buffer[temp_length]);
  config->PortTabSize	= 32;
  config->Incarnation	= proc_entry->Incarnation++;
  config->ImageSize	= 0;	/* Filled in by Netagent */
  config->Date		= 0;	/* Ditto.		 */
  config->MemSize	= RmGetProcessorMemory(dest);
  config->NLinks	= number_links;
  /* Work to be done */

  for (i = 0; i < number_links; i++)
   { config->LinkConf[i].Flags	= 0;
     config->LinkConf[i].Mode	= Link_Mode_Null;
     config->LinkConf[i].State	= Link_State_Null;
     config->LinkConf[i].Id	= i;
   }
  config->LinkConf[destlink].Flags	=
  		 (Link_Flags_parent + Link_Flags_debug);
  config->LinkConf[destlink].Mode	= Link_Mode_Intelligent;
  config->LinkConf[destlink].State	= Link_State_Running;

  { char *temp  = (char *) config;
    temp = &(temp[sizeof(Config)]);
    if (number_links > 4)
     temp = &(temp[(number_links - 4) * sizeof(LinkConf)]);
    config->MyName	= temp - (char *) &(config->MyName);
    temp		= BuildName(temp, dest);
    config->ParentName	= temp - (char *) &(config->ParentName);
    (void)BuildName(++temp, source);
  }

  result = TRUE;

done:
  if (result)
   { *config_vec	= (Config *) buffer;
     *confsize		= length;
   }
  else
   { *config_vec	= Null(Config);
     *confsize		= 0;
     if (buffer ne Null(char)) Free(buffer);
   }
  return(result);
}

/*}}}*/


static bool boot_down_link(RmProcessor start, int link)
{ RmProcessor		target;
  int			destlink;
  ProcessorEntry	*proc_entry;
  Config		*config = Null(Config);
  word			confsize;
  bool			result = FALSE;
  int			i;
  int			NetagentRequest;

  target = RmFollowLink(start, link, &destlink);
  if ((target eq RmM_NoProcessor) || (target eq RmM_ExternalProcessor))
   return(FALSE);

  Debug(dbg_Boot, ("attempting to boot processor %P via link %d of %P",\
  		target, link, start));

	/* Check for any special bootstrap facilities.			    */
	/* If there is one, invoke it. If successful, update the processor. */
  proc_entry = GetProcEntry(target);
  for (i = 0; i < proc_entry->NumberDrivers; i++)
   { DriverEntry	*driver_entry	= &(proc_entry->DriverEntry[i]);
     RmHardwareFacility	*hardware	= driver_entry->Hardware;
     if ((hardware->Type ne RmH_ResetDriver) &&
         (hardware->Type ne RmH_ConfigureDriver))
      continue;
     if (driver_entry->Flags & DriverFlags_SpecialBootstrap)
      { NetworkDCB	*device = (NetworkDCB *) hardware->Device;
        DriverRequest	request;
        request.FnRc			= ND_Boot;
        request.NumberProcessors	= link;
	request.Processor[0]		= start;
        (*(device->DCB.Operate))(device, &request);
        if (request.FnRc eq Err_Null) goto success;
        if ((request.FnRc & EC_Mask) >= EC_Error) goto fail;
      }
   }

	/* Build a suitable configuration vector. This is done in a	*/
	/* separate routine which may be called from device drivers.	*/
	/* Also, select the correct processor type. This may need	*/
	/* updating in future, to allow for combinations of bootstrap.	*/
	/* e.g. a different bootstrap is needed for trannie->trannie	*/
	/* than for i860->trannie.					*/
  switch (RmGetProcessorType(target))
   {
#ifdef __TRAN
  case		RmT_Default	:
#endif
  case		RmT_T800	:
  case		RmT_T414	:
  case		RmT_T425	:
  case		RmT_T400	:
		unless(BuildTRANConfig(start, target, destlink, &config, &confsize))
			goto fail;
		NetagentRequest = NA_TransputerBoot;
		break;
#ifdef __C40
     case RmT_Default :
#endif
     case RmT_C40     :
		unless(BuildC40Config(start, target, destlink, &config, &confsize))
			goto fail;
		NetagentRequest	= NA_C40Boot;
		break;

#ifdef __I860
     case	RmT_Default	:
#endif
     case	RmT_i860	:
		unless(Build_i860Config(start, target, destlink, &config, &confsize))
			goto fail;
		NetagentRequest = NA_i860Boot;
		break;

     default :
     	report("this version cannot boot up processor %P, a %s",
	       target, RmT_Names[RmGetProcessorType(target)]);
	goto	fail;			
   }

	/* Reset the processor again if possible */
  (void) ResetProcessors(1, &target);     
  { int state = RmGetProcessorState(target);
    unless(state & RmS_Reset)
     report("warning, trying to boot processor %P which has not been reset",
     		target);
  }
	/* Try to access the Network agent running on the start processor */
  { NA_Message		message;
    word		reply;
    int			state;

    message.FnRc = NetagentRequest;
    message.Arg1 = link;
    message.Size = confsize;
    message.Data = (BYTE *) config;
    reply = XchNetworkAgent(start, &message, TRUE, 0, NULL);

    state = RmGetProcessorState(target);
    state &= ~RmS_Reset;
    RmSetProcessorState(target, state);

    if (reply ne Err_Null)
     { report("failed to boot processor %P via link %d of processor %P",
     		target, link, start);
       report("reported fault was %x", reply);

       goto fail;
     }
  }

	/* Check that the processor really has come up, by	*/
	/* starting a network agent on it.			*/
  unless(StartNetworkAgent(target))
   { SetLinkMode(start, link, RmL_NotConnected);
     report("failed to start Network Agent on newly-booted processor %P",
		target);
     goto fail;
   }
    
success:
  RmSetProcessorState(target, RmS_Running | RmS_Booting);
  LastChange = target->ObjNode.Dates.Modified = GetDate();
  result = TRUE;
  goto done;
    
fail:
  { RmLink *linkstruct = RmFindLink(start, link);
    int	    state = RmGetProcessorState(target);
    linkstruct->Flags |= RmF_Suspicious;
    state &= ~RmS_Reset;
    RmSetProcessorState(target, state);
  }

done:  
  if (config ne Null(Config)) Free(config);
  return(result);
}

/*}}}*/

/*{{{  install the protection on a processor */
/**
*** do_protection(). For every processor in the bootstrap job set up the
*** appropriate protection modes and initialise some capabilities. This
*** involves interacting with the network agent on that processor.
***
*** 1) The Network agent is guaranteed to be running already.
*** 3) construct a protect message. This involves a single argument, the
***    protection matrix to use, which is filled in during initialisation
***    in routine InitBootstrap() above. The message is followed by
***    the current capability, which may be the only capability in the
***    system with alter permission.
*** 4) send the message and get a reply. This reply consists of
***    an error code followed by three capabilities, one for the owner, one
***    read-only, and one for the network server itself.
**/
static void do_protection(RmProcessor processor)
{ ProcessorEntry	*proc_entry;
  NA_Message		message;
  WORD			rc;

  proc_entry = GetProcEntry(processor);

  Debug(dbg_Boot, ("setting protection on processor %P", processor));
     	
  message.FnRc = NA_Protect;
  message.Arg1 = ProtectionMatrix;
  message.Size = sizeof(Capability);
  message.Data = (BYTE *) &(proc_entry->Full);
  rc = XchNetworkAgent(processor, &message, TRUE, 3 * sizeof(Capability), 
		(BYTE *) &(proc_entry->Owner));

  if (rc ne Err_Null)
   { report("warning, failed to set protection on processor %P, fault %x",
      		processor, rc);
     memset((void *) &(proc_entry->Owner), 0, 3 * sizeof(Capability));
   }
  else
   { memcpy(&(processor->RealCap), &(proc_entry->Full), sizeof(Capability));
     memcpy(&(processor->ReadOnlyCap), &(proc_entry->General), 
        		sizeof(Capability));
   }
}
/*}}}*/
/*{{{  validate details of a processor, e.g. processor type */

/**
*** ValidateProcessor. Check out some of the details in the resource map. In
*** particular, validate the processor type and the amount of memory.
**/

static void	ValidateProcessorDetails(RmProcessor processor)
{ int		state		= RmGetProcessorState(processor);
  Object	*real_processor = Null(Object);
  ProcStats	*stats		= Null(ProcStats);
  int		number_links	= RmCountLinks(processor);
  int		proc_type	= RmGetProcessorType(processor);
  int		real_type;

  unless (state & (RmS_Running | RmS_Special)) return;
  real_processor = NetMapProcessorToObject(processor);
  if (real_processor eq Null(Object))
   { MarkProcessor(processor, TRUE); goto done; }
  stats = (ProcStats *) Malloc(sizeof(ProcStats) + 
  		((word) number_links * (sizeof(LinkConf) + 3 * sizeof(WORD))) +
  		IOCDataMax);
  if (stats eq Null(ProcStats)) goto done;

  if (ServerInfo(real_processor, (BYTE *) stats) < Err_Null)
   { report("error %x when attempting to validate processor %P",
   		Result2(real_processor), processor);
     MarkProcessor(processor, TRUE);
     goto done;
   }

	/* the memory information returned by ServerInfo does not include */
	/* the nucleus, trace vector, root structure, and other kernel	  */
	/* data. Hence I align the memory to the next 512K boundary.	  */
  if (RmGetProcessorMemory(processor) eq 0)
   { word	memory = stats->MemMax;
     memory	= memory + (512 * 1024) - 1;
     memory	&= ~((512 * 1024) - 1);
     (void) RmSetProcessorMemory(processor, memory);
   }
	/* if an amount was specified in the resource map then this	*/
	/* was used to boot up the processor. Hence there is no point	*/
	/* in adjusting the memory size, except possibly for the root	*/
	/* processor.							*/

	/* Next job, check the processor type.				*/
  switch(stats->Type)
   { case	800	: 
     case	805	:
     case	801	:
   			  real_type = RmT_T800; break;
     case	414	: real_type = RmT_T414; break;
     case	425	: real_type = RmT_T425; break;
     case	400	: real_type = RmT_T400; break;
     case	0xA3	: real_type = RmT_Arm;  break;
     case	0x320C40: real_type = RmT_C40;  break;
     case	0x86	: real_type = RmT_i860; break;

     default :	report("warning, processor %P is of unknown type %d",
			processor, stats->Type);
     		goto done;
   }

  if (proc_type eq RmT_Default)
   RmSetProcessorType(processor, real_type);
  elif (proc_type ne real_type)
   { report(
     "warning, processor %P is a %s, not a %s as specified in the resource map",
	       processor, RmT_Names[real_type], RmT_Names[proc_type]);
     RmSetProcessorType(processor, real_type);
   }

done:
  if (real_processor ne Null(Object)) Close(real_processor);
  if (stats ne Null(ProcStats)) Free(stats);
}

/*}}}*/
/*{{{  cross-links, pending phase */
/**
*** set_pending(processor, job). This routine is called during the
*** first stage of enabling the cross links. There is guaranteed to be
*** a netagent running already. The routine performs the following
*** operations for each link:
***  1) if the link is not connected or goes to a native processor
***     it is ignored, as the link will have been set to not-connected
***     during the bootstrap.
***  2) if the link goes to a processor that is not currently running
***     it is set to not-connected. The recovery code should do the
***     rest.
***  3) if the link is external to the network it is set to pending.
***     Similarly for I/O processors.
***  4) if the link is to a processor outside the bootstrap job then
***     a netagent is started on the other processor, the other link is
***     set to pending, and this link is enabled.
***  5) if the link goes to another link on the same processor then set
***     it pending or ignore it, depending on the order of the links
***  6) if the link goes to a processor that was booted later on in the
***     job then the link is set to pending.
BLV This code does not currently know which links were used for the
BLV bootstrap. Hence it may attempt to fiddle with some links that are
BLV already running. The netagent sorts that out.
**/
static void set_pending(RmProcessor processor, BootstrapJob *job)
{ int		this_position;
  int		its_position;
  int		number_links;
  int		link;
  int		destlink;
  int		mode;
  int		its_purpose;
  RmProcessor	neighbour;
  NA_Message	message;

	/* Determine this processor's position within the job */
  for (this_position = 0; this_position < job->Next; this_position++)
   if (job->Progress[this_position] eq processor)
    break;

  number_links = RmCountLinks(processor);

  for (link = 0; link < number_links; link++)
   { neighbour = RmFollowLink(processor, link, &destlink);

     if (neighbour eq RmM_NoProcessor) continue;

     if (neighbour eq RmM_ExternalProcessor)
      { mode = RmL_Pending; goto set_link; }

     its_purpose = RmGetProcessorPurpose(neighbour) & RmP_Mask;

     if (its_purpose eq RmP_IO)
      { mode = RmL_Pending; goto set_link; }

     if (its_purpose ne RmP_Helios)
      continue;

     if (!(RmGetProcessorState(neighbour) & RmS_Running))
      { mode = RmL_NotConnected; goto set_link; }

     if (processor eq neighbour)
      { if (link < destlink)
         { mode = RmL_Pending; goto set_link; }
        else
         continue;
      }

     for (its_position = 0; its_position < job->Next; its_position++)
      if (job->Progress[its_position] eq neighbour)
       break;

     if (its_position >= job->Next)
      { SetLinkMode(neighbour, destlink, RmL_Pending);
        mode = RmL_Running;
        goto set_link;
      }

    if (its_position < this_position)
     continue;

    mode = RmL_Pending;

set_link:
    Debug(dbg_Links, ("processor %P, setting link %d to %L",\
		processor, link, mode));

    message.FnRc	= NA_SetLinkMode;
    message.Arg1	= link;
    message.Arg2	= mode;
    message.Size	= 0;
    XchNetworkAgent(processor, &message, TRUE, 0, NULL);
  }
}
/*}}}*/
/*{{{  cross-links, enabling phase */
/**
*** set_enabled(processor, job). This routine complements the previous one.
*** For links within the bootstrap job one end will have been set to pending.
*** The other end should now be set to running and enabled.
**/
static void set_enabled(RmProcessor processor, BootstrapJob *job)
{ int		this_position;
  int		its_position;
  int		number_links;
  int		link;
  int		destlink;
  int		mode;
  int		its_purpose;
  RmProcessor	neighbour;
  NA_Message	message;

	/* Determine this processor's position within the job */
  for (this_position = 0; this_position < job->Next; this_position++)
   if (job->Progress[this_position] eq processor)
    break;

  number_links = RmCountLinks(processor);

  for (link = 0; link < number_links; link++)
   { neighbour = RmFollowLink(processor, link, &destlink);

     if ((neighbour eq RmM_NoProcessor) || (neighbour eq RmM_ExternalProcessor))
	continue;

     its_purpose = RmGetProcessorPurpose(neighbour) & RmP_Mask;
     if (its_purpose ne RmP_Helios)
      continue;

     if (!(RmGetProcessorState(neighbour) & RmS_Running))
      continue;

     if (processor eq neighbour)
      { if (link > destlink)
         { mode = RmL_Running; goto set_link; }
        else
         continue;
      }

     for (its_position = 0; its_position < job->Next; its_position++)
      if (job->Progress[its_position] eq neighbour)
       break;

     if (its_position >= job->Next)
      continue;

    if (its_position >= this_position)
     continue;

    mode = RmL_Running;

set_link:
    Debug(dbg_Links, ("processor %P, setting link %d to %L",\
		processor, link, mode));

    message.FnRc	= NA_SetLinkMode;
    message.Arg1	= link;
    message.Arg2	= mode;
    message.Size	= 0;
    XchNetworkAgent(processor, &message, TRUE, 0, NULL);
  }
}
/*}}}*/
/*{{{  executing system tasks defined in the resource map */

/**
*** Execute_mapped_task(). The network resource map may contain various tasks
*** that may have been mapped onto a processor. This routine is used to
*** execute the appropriate task. In addition to ordinary commands the
*** tasks may include the specials waitfor and console
**/
/*{{{  waitfor command */
static	void	execute_waitfor(RmTask task, RmProcessor processor)
{ char		*server_name = (char *) RmGetTaskArgument(task, 1);
  int		i = 1;
  Object	*server;

  if (server_name[0] ne '/')
   { report("processor %P, invalid server name %s in waitfor",
		processor, server_name);
     return;
   }

  forever
   { server = Locate(Null(Object), server_name);
     if (server != Null(Object))
      { Close(server); return; }
     if ((i++ % 30) == 0)
      report("processor %P, still waiting for %s", processor, server_name);
     Delay(OneSec);
   }
}
/*}}}*/
/*{{{  console command */
static void	execute_console(RmTask task, RmProcessor processor)
{ ProcessorEntry	*proc_entry;
  Object		*window_server = Null(Object);
  char			*server_name;
  char			*window_name;

  proc_entry = GetProcEntry(processor);

  server_name = (char *) RmGetTaskArgument(task, 1);
  if (server_name[0] ne '/')
   { report("processor %P, invalid console server %s", processor,
		server_name);
     return;
   }

  window_server = Locate(Null(Object), server_name);
  if (window_server eq Null(Object))
   { report("processor %P, cannot find window server %s", processor,
		server_name);
     return;
   }

  if (proc_entry->WindowServer != Null(Object))
   Close(proc_entry->WindowServer);
  if (proc_entry->ConsoleWindow != Null(Object))
   Close(proc_entry->ConsoleWindow);

  if (RmCountTaskArguments(task) eq 2) /* console /logger */
   { proc_entry->WindowServer = Null(Object);
     proc_entry->ConsoleWindow = window_server;
     return;
   }

  window_name = (char *) RmGetTaskArgument(task, 2);
  proc_entry->WindowServer = window_server;
  proc_entry->ConsoleWindow = Create(window_server, window_name, 
			Type_File, 0, NULL);
  if (proc_entry->ConsoleWindow eq Null(Object))
   { report("processor %P, failed to create window %s/%s", processor,
		window_server->Name, window_name);
     proc_entry->WindowServer = Null(Object);
     return;
   }
}
/*}}}*/

static	int	execute_mapped_task(RmTask task, ...)
{ va_list		args;
  RmProcessor		processor;
  ProcessorEntry	*proc_entry;

  va_start(args, task);
  processor = va_arg(args, RmProcessor);
  va_end(args);

  if (!strcmp(task->ObjNode.Name, "waitfor"))
   { execute_waitfor(task, processor); return(0); }
  if (!strcmp(task->ObjNode.Name, "console"))
   { execute_console(task, processor); return(0); }

	/* Must be an ordinary command */

  proc_entry = GetProcEntry(processor);
  proc_entry->CommandDate = (word) GetDate() + 2;
  
  if (task->ObjNode.Name[0] eq '0')	/* hack for no -e, see rmgen */
   return((int) rexec_task(processor, task, Null(Environ), 0));

  { Environ	env;
    Environ	*net_env = getenviron();
    Stream	*strv[5];
    Object	*objv[OV_End + 1];
    int		i;

	/* By default, inherit context and streams from Network Server */
    for (i = 0; (net_env->Objv[i] ne Null(Object)) && (i <= OV_End); i++)
     objv[i] = net_env->Objv[i];
    objv[OV_End] = Null(Object);
    for (i = 0; i < 4; i++)
     strv[i] = net_env->Strv[i];
    strv[4] = Null(Stream);

    if (proc_entry->WindowServer ne Null(Object))
     objv[OV_CServer] = proc_entry->WindowServer;

    if (proc_entry->ConsoleWindow ne Null(Object))
     { objv[OV_Console] = proc_entry->ConsoleWindow;
       strv[0] = Open(proc_entry->ConsoleWindow, Null(char), O_ReadOnly);
       strv[1] = Open(proc_entry->ConsoleWindow, Null(char), O_WriteOnly);
       strv[2] = strv[1];
     }
    env.Strv	= strv;
    env.Objv	= objv;
    env.Envv	= net_env->Envv;
    env.Argv	= Null(char *);
    
    i = (int) rexec_task(processor, task, &env, 0);
    if (proc_entry->ConsoleWindow ne Null(Object))
     { Close(strv[0]); Close(strv[1]); }
    return(i);
  }
}

/*}}}*/

/*{{{  manipulating link modes outside a bootstrap */

/*{{{  HandleGetLinkMode() */
/**
*** Code to deal with requests for manipulating link modes. This is temporary.
*** NB the network server is not locked up while this is going on.
**/
void	HandleGetLinkMode(NsConn connection, int job_id,
		RmRequest *request, RmReply *reply)
{ RmProcessor		processor;
  int			rc = RmE_Success;
  NA_Message		message;
  bool			agent_started	= FALSE;
  int			mode;    

  processor = RmFindProcessor(Net, request->Uid);

  if (processor eq (RmProcessor) NULL)   
   { rc = RmE_BadProcessor; goto done; }
  if ((RmGetProcessorPurpose(processor) & RmP_Mask) ne RmP_Helios)
   { rc = RmE_BadProcessor; goto done; }

  unless(StartNetworkAgent(processor))
   { rc = RmE_BadProcessor; goto done; }
  agent_started = TRUE;
  
  message.FnRc	= NA_GetLinkMode;
  message.Arg1	= request->Arg1;  
  message.Size	= 0;
  rc = XchNetworkAgent(processor, &message, TRUE, sizeof(int), (BYTE *) &mode);

done:
  if (agent_started) StopNetworkAgent(processor);
  reply->FnRc	= rc;
  reply->Reply1	= mode;
  ReplyRmLib(connection, job_id, reply);
}
/*}}}*/
/*{{{  HandleSetLinkMode() */
void	HandleSetLinkMode(NsConn connection, int job_id,
		RmRequest *request, RmReply *reply)
{ RmProcessor		processor;
  int			rc = RmE_Success;

  processor = RmFindProcessor(Net, request->Uid);
  if (processor eq (RmProcessor) NULL)   
   { rc = RmE_BadProcessor; goto done; }
  if ((RmGetProcessorPurpose(processor) & RmP_Mask) ne RmP_Helios)
   { rc = RmE_BadProcessor; goto done; }

  rc = SetLinkMode(processor, request->Arg1, request->Arg2);
  
done:
  reply->FnRc	= rc;
  ReplyRmLib(connection, job_id, reply);
}
/*}}}*/
/*{{{  SetLinkMode() */
/**
*** Set a link to a particular mode. This is used for one-off changes,
*** when all the links need changing there are more efficient ways.
**/
int	SetLinkMode(RmProcessor processor, int link, int mode)
{ int			rc = RmE_Success;
  NA_Message		message;
  bool			agent_started	= FALSE;

  Debug(dbg_Links, ("setting link %d of %P to %L", link, processor, mode));

  unless(StartNetworkAgent(processor))
   { rc = RmE_BadProcessor; goto done; }
  agent_started = TRUE;  
  
  message.FnRc	= NA_SetLinkMode;
  message.Arg1	= link;
  message.Arg2	= mode;
  message.Size	= 0;
  rc = XchNetworkAgent(processor, &message, TRUE, 0, NULL);

done:
  if (agent_started) StopNetworkAgent(processor);
  return(rc);
}
/*}}}*/
/*{{{  GetLinkMode() */

int	GetLinkMode(RmProcessor processor, int link)
{ Object	*proc_obj;
  Object	*procman;
  BYTE		buf[IOCDataMax];
  ProcStats	*stats;
  word		rc;
  LinkConf	conf;

  proc_obj = NetMapProcessorToObject(processor);
  if (proc_obj eq Null(Object)) return(RmL_NotConnected);

  procman = Locate(proc_obj, "tasks");
  Close(proc_obj);
  if (procman eq Null(Object)) return(RmL_NotConnected);

  rc = ServerInfo(procman, buf);
  Close(procman);
  if (rc < Err_Null) return(RmL_NotConnected);

  stats = (ProcStats *) buf;
  if (link > stats->NLinks) return(RmL_NotConnected);
  conf  = stats->Link[link].Conf;
  if (conf.Mode eq Link_Mode_Null)
   return(RmL_NotConnected);
  if (conf.Mode eq Link_Mode_Dumb)
   return(RmL_Dumb);
  if (conf.State eq Link_State_Running)
   return(RmL_Running);
  if (conf.State eq Link_State_Dead)
   return(RmL_Pending);
  return(RmL_Dead);
}

/*}}}*/

/*}}}*/
/*{{{  clearing name tables */
#if 0
/*{{{  old code */
/**
*** Clearing names. This is yet another message to the network agent, for
*** most cases. However, when fiddling with native networks it is necessary
*** to clear the names of the root processor very frequently, so there
*** is a special case.
**/
static  void ClearLocalNames(void);

void	ClearNames(RmProcessor processor)
{ int			rc;
  NA_Message		message;
  bool			agent_started	= FALSE;

  if (processor eq RootProcessor)
   { ClearLocalNames(); return; }
     
  unless(StartNetworkAgent(processor)) goto done;
  agent_started = TRUE;
  
  message.FnRc	= NA_ClearNames;
  message.Size	= 0;
  rc = XchNetworkAgent(processor, &message, FALSE, 0, NULL);

done:  
  if (agent_started) StopNetworkAgent(processor);
}

static Object *local_procman = Null(Object);

static void ClearLocalNames(void)
{ MsgBuf	*r = New(MsgBuf);

  if (r eq Null(MsgBuf)) return;
  
  if (local_procman eq Null(Object))
   local_procman = Locate(Null(Object), "/tasks");
   
  InitMCB(&(r->mcb), MsgHdr_Flags_preserve, NullPort, NullPort,
  		FC_GSP + FG_Reconfigure);
  r->mcb.Control = r->control;
  r->mcb.Data	 = r->data;
  MarshalCommon(&(r->mcb), local_procman, Null(char));
  SendIOC(&(r->mcb));
  
  Free(r);
}
/*}}}*/
#else
/*{{{  current code */
	/* BLV - alternative approach, send the ClearNames() message	*/
	/* directly to the remote ProcMan.				*/
void	ClearNames(RmProcessor	processor)
{ Object	*proc_obj	= Null(Object);
  Object	*procman	= Null(Object);
  MsgBuf	*r;

  proc_obj	= NetMapProcessorToObject(processor);
  if (proc_obj eq Null(Object)) return;

  procman	= Locate(proc_obj, "tasks");
  Close(proc_obj);
  if (procman eq Null(Object)) return;

  r = New(MsgBuf);
  if (r eq Null(MsgBuf)) 
   { Close(procman); return; }
  r->mcb.Control	= r->control;
  r->mcb.Data		= r->data;
  InitMCB(&(r->mcb), MsgHdr_Flags_preserve, NullPort, NullPort,
		FC_GSP + FG_Reconfigure);
  MarshalCommon(&(r->mcb), procman, Null(char));

  SendIOC(&(r->mcb));

  Free(r);
  Close(procman);
}
/*}}}*/
#endif
/*}}}*/
@


1.34
log
@fixed compile time warnings
@
text
@d16 1
a16 1
/*$Header: /hsrc/network/RCS/netboot.c,v 1.33 1993/08/12 13:40:15 nickc Exp nickc $*/
d1499 1
@


1.33
log
@fixed compile time warnings
@
text
@d16 1
a16 1
/*$Header: /hsrc/network/RCS/netboot.c,v 1.32 1993/08/11 10:33:36 bart Exp nickc $*/
d186 1
d211 1
d226 1
a226 1
     table = (RmProcessor *) Malloc(sizeof(RmProcessor) * amount);
d246 1
d268 1
a268 1
  		Malloc(job->MaxProcessors * sizeof(RmProcessor));
d307 1
@


1.32
log
@stack sizes now declared in netaux.h
@
text
@d16 1
a16 1
/*$Header: /hsrc/network/RCS/netboot.c,v 1.31 1993/02/04 17:34:34 bart Exp $*/
d413 1
d415 1
a415 1
{ RmProcessor		neighbour;
d423 1
a423 1
  int			rc;
d482 1
d638 1
d657 1
a657 1
  request = Malloc(sizeof(DriverRequest) + (count * sizeof(RmProcessor)));
d853 1
d856 1
d881 1
a881 1
  int		suspect_link;
d950 1
d953 1
d975 1
a975 1
  booted = boot_down_link(start, link);
d997 1
d1000 1
d1081 1
a1081 1
     temp = boot_down_link(current, j);
d1162 1
d1165 1
d1183 1
d1223 1
a1223 1
  int			length, temp_length;
d1329 1
d1332 1
d1373 1
a1373 1
  C40_Bootstrap		*boot_info;
d1533 1
d1536 1
d1543 1
a1543 1
  int			length, temp_length;
d1648 1
d1791 1
d1839 1
d1858 1
a1858 1
  		(number_links * (sizeof(LinkConf) + 3 * sizeof(WORD))) +
d1914 1
d2081 1
d2174 1
a2174 1
  proc_entry->CommandDate = GetDate() + 2;
d2177 1
a2177 1
   return(rexec_task(processor, task, Null(Environ), 0));
d2207 1
a2207 1
    i = rexec_task(processor, task, &env, 0);
d2213 1
d2217 1
d2301 1
d2307 1
a2307 1
  int		rc;
d2334 1
d2336 1
@


1.31
log
@On C40 systems the CacheOff flag has to be set in the configuration
vector as well as in the hardware config word.
@
text
@d16 1
a16 1
/*$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.30 1993/01/18 11:40:16 bart Exp bart $*/
d269 1
a269 1
  if(Fork(BootstrapStack, &BootstrapProcess, sizeof(BootstrapJob *), job))
d977 1
a977 1
  if (!Fork(BootstrapStack, &continue_boot, 8, job, next))
d1082 1
a1082 1
        if (Fork(BootstrapStack, &continue_boot, 8, job, next))
@


1.30
log
@The hardware word configuration (load nucleus global S0 etc) is now
inherited from the root processor unless the user has used an IDROM
file in the resource map. This means that global memory should be used
by default in the majority of networks.
@
text
@d16 1
a16 1
/*$Header: /hsrc/network/RCS/netboot.c,v 1.29 1992/12/07 12:18:42 nick Exp $*/
d1481 2
@


1.29
log
@config->Loadbase assignment properly cast.
@
text
@d16 1
a16 1
/*$Header: /m/giga/HeliosRoot/Helios/network/RCS/netboot.c,v 1.28 1992/10/26 17:43:59 bart Exp nick $*/
d37 1
d1431 19
a1449 1
   boot_info->Hwconfig	= 0;
@


1.28
log
@Replaced a dubious use of MRSW_SwitchWrite() to a dubious use of
MRSW_FreeRead()/MRSW_GetWrite(), to reduce the probability of deadlock.
@
text
@d16 1
a16 1
/*$Header: netboot.c,v 1.27 92/09/15 18:23:54 bart Exp $*/
d1279 1
a1279 1
  config->LoadBase	= (word *) 0x80001000;
@


1.27
log
@The construction of configuration information has been heavily modified
to support IDRom info supplied in the resource map. The C40 code is
currently untested.
@
text
@d16 1
a16 1
/*$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.26 1992/08/21 13:18:39 bart Exp $*/
d285 2
a286 1
  MRSW_SwitchWrite();
@


1.26
log
@Patched to get around problem in Processor Manager when cleaning out the
name table.
@
text
@d16 1
a16 1
/*$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.25 1992/08/14 17:19:57 bart Exp $*/
d36 1
d1169 1
a1169 2

/*{{{  build a configuration vector for a processor */
d1203 1
a1203 1
bool		BuildConfig(RmProcessor source,
a1242 5
  if (nucleus_string eq Null(char))
   { report("this version of Helios has no nucleus for processor %P", dest);
     goto done;
   }

d1261 2
a1262 3
   { Free(buffer);
     buffer = (char *) Malloc(length);
     if (buffer eq Null(char)) goto done;
d1276 3
d1280 10
a1289 19
  switch(RmGetProcessorType(dest))
   { 
#ifdef __TRAN
     case	RmT_Default	:
#endif
     case	RmT_T800	:
     case	RmT_T414	:
     case	RmT_T425	:
     case	RmT_T400	: config->FirstProg	= 6;
				  config->Flags		= 0;
				  config->LoadBase	= (word *) 0x80001000;
				  break;
#ifdef __C40
     case	RmT_Default	:
#endif
     case	RmT_C40		: config->FirstProg	= 6;
     				  config->Flags		= 0;
     				  config->LoadBase	= 0;
     				  break;
d1291 16
a1306 10
#ifdef __I860
     case	RmT_Default	:
#endif
     case	RmT_i860	:
					/* Work to be done */
				  break;
     				  
     default : report("cannot yet build a configuration vector for ptype %s",
     		RmT_Names[RmGetProcessorType(dest)]);
     	       goto done;
d1308 32
d1341 121
d1487 113
d1612 1
d1653 1
a1653 4
  unless(BuildConfig(start, target, destlink, &config, &confsize))
   goto fail;

	/* Work out what type of bootstrap to use. This may need	*/
d1656 3
a1658 3
	/* than for i860>trannie.					*/
  switch(RmGetProcessorType(target))
   { 
d1660 1
a1660 1
     case	RmT_Default	:	/* default == transputer */
d1662 8
a1669 4
     case	RmT_T800	:
     case	RmT_T414	:
     case	RmT_T425	:
     case	RmT_T400	: NetagentRequest = NA_TransputerBoot; break;
d1671 1
a1671 1
     case	RmT_Default	:
d1673 6
a1678 1
     case	RmT_C40		: NetagentRequest = NA_C40Boot; break;
d1682 5
a1686 1
     case	RmT_i860	: NetagentRequest = NA_i860Boot; break;
@


1.25
log
@1) added i860 support
2) the I/O processor is now updated before the root processor. This
   stops problems with running tasks on the root processor
@
text
@d16 1
a16 1
/*$Header: /m/giga/HeliosRoot/Helios/network/RCS/netboot.c,v 1.23 1992/07/09 17:24:13 paul Exp $*/
d1134 5
a1138 1
  if (RmGetProcessorState(current) & RmS_Running)
@


1.24
log
@1) tidied up the diagnostics.
2) switched from NetLookupProcessor to RmLookupProcessor
3) preloaded netagent code is now protected so that it cannot be deleted
   during cleaning.
@
text
@a104 1
  UpdateProcessor(RootProcessor, FALSE);
d107 1
d451 5
a455 1
  unless(StartNetworkAgent(neighbour)) goto done;
d1185 1
d1298 7
d1394 1
a1394 1
	/* than for i860->trannie.					*/
d1408 5
d1578 2
@


1.23
log
@fixup for correct defaults on C40 systems - i.e. dont default to booting
neighbours as transputers!
@
text
@d16 1
a16 1
/*$Header: /m/giga/HeliosRoot/Helios/network/RCS/netboot.c,v 1.22 1992/07/08 12:02:10 paul Exp paul $*/
d68 1
a68 1
  if (get_config("processor_protection", environ))
d96 1
a96 1
  Debug(dbg_Boot, ("root processor is %s", Procname(RootProcessor)));
d102 1
a102 1
     Debug(dbg_Boot, ("boot I/O processor is %s", Procname(BootIOProcessor)));
d131 1
a131 1
  if (get_config("waitfor_network", environ) ne Null(char))
d330 1
a330 1
  Debug(dbg_Boot, ("updating processor %s", Procname(processor)));
d342 1
a342 1
   { report("not enough memory to update processor %s", Procname(processor));
d355 2
a356 2
   report("warning, failed to update processor name for %s, fault %x",
   		Procname(processor), rc);
d380 2
a381 2
         report("warning, processor %s, link %d, has a connection not shown in the resource map",
          		Procname(processor), i);
d421 1
a421 1
  Debug(dbg_Boot, ("updating I/O processor %s", Procname(processor)));
d427 2
a428 2
   { report("error, I/O processor %s has more than one link",
   		Procname(processor));
d434 2
a435 2
   { report("error, I/O processor %s is not connected to the main network",
   		Procname(processor));
d439 1
a439 1
  Debug(dbg_Boot, ("I/O processor's neighbour is %s", Procname(neighbour)));
d462 2
a463 2
   report("warning, failed to update I/O processor %s, fault %x",
   	Procname(processor), rc);
d548 2
a549 2
     Debug(dbg_Boot, ("bootstrap job %d, attempt %d, starting from %s", \
     	job->Sequence, retries+1, Procname(start)));
d601 1
a601 1
         report("failed to boot processor %s", Procname(processor));
d909 1
a909 1
      { report("the link to processor %s is not appearing", Procname(delayed));
d913 1
a913 1
      report("waiting for link to processor %s", Procname(delayed));
d1009 1
a1009 1
   report("processor %s booted.", Procname(current));
d1235 1
a1235 2
   { report("this version of Helios has no nucleus for processor %s",
   		Procname(dest));
d1350 2
a1351 2
  Debug(dbg_Boot, ("attempting to boot processor %s via link %d of %s",\
  	Procname(target), link, Procname(start)));
d1397 2
a1398 2
     	report("this version cannot boot up processor %s, a %s",
	       Procname(target), RmT_Names[RmGetProcessorType(target)]);
d1406 2
a1407 2
     report("warning, trying to boot processor %s which has not been reset",
     		Procname(target));
d1425 2
a1426 2
     { report("failed to boot processor %s via link %d of processor %s",
     		Procname(target), link, Procname(start));
d1437 2
a1438 2
     report("failed to start Network Agent on newly-booted processor %s",
		Procname(target));
d1485 1
a1485 2
  Debug(dbg_Boot, ("setting protection on processor %s",\
 	Procname(processor)));
d1495 2
a1496 2
   { report("warning, failed to set protection on processor %s, fault %x",
      		Procname(processor), rc);
d1530 2
a1531 2
   { report("error %x when attempting to validate processor %s",
   		Result2(real_processor), Procname(processor));
d1561 2
a1562 2
     default :	report("warning, processor %s is of unknown type %d",
			Procname(processor), stats->Type);
d1570 2
a1571 2
     "warning, processor %s is a %s, not a %s as specified in the resource map",
       Procname(processor), RmT_Names[real_type], RmT_Names[proc_type]);
d1665 2
a1666 2
    Debug(dbg_Links, ("processor %s, setting link %d to %L",\
		Procname(processor), link, mode));
d1733 2
a1734 2
    Debug(dbg_Links, ("processor %s, setting link %d to %L",\
		Procname(processor), link, mode));
d1758 2
a1759 2
   { report("processor %s, invalid server name %s in waitfor",
		Procname(processor), server_name);
d1768 1
a1768 2
      report("processor %s, still waiting for %s", Procname(processor),
		server_name);
d1784 1
a1784 1
   { report("processor %s, invalid console server %s", Procname(processor),
d1791 1
a1791 1
   { report("processor %s, cannot find window server %s", Procname(processor),
d1812 1
a1812 1
   { report("processor %s, failed to create window %s/%s", Procname(processor),
d1944 1
a1944 1
  Debug(dbg_Links, ("setting link %d of %s to %L", link, Procname(processor), mode));
@


1.22
log
@Now copes with nuclei larger than 256K when determining a processor's
memory size
@
text
@d16 1
a16 1
/*$Header: /m/giga/HeliosRoot/Helios/network/RCS/netboot.c,v 1.21 1992/07/07 14:37:01 paul Exp paul $*/
d1276 4
a1279 1
   { case	RmT_Default	:
d1287 3
a1289 1

d1385 4
a1388 1
   { case	RmT_Default	:	/* default == transputer */
d1393 3
@


1.21
log
@fixed for C40
@
text
@d16 1
a16 1
/*$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.20 1992/05/08 16:36:25 bart Exp $*/
d1529 1
a1529 1
	/* data. Hence I align the memory to the next 256K boundary.	  */
d1532 2
a1533 2
     memory	= memory + (256 * 1024) - 1;
     memory	&= ~((256 * 1024) - 1);
@


1.20
log
@1) changed the communication between netserv and netagent from pipes to
   client-server message passing
2) folded the network server sources
@
text
@d16 1
a16 1
/*$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.19 1992/03/25 18:03:41 bart Exp $*/
d1551 1
a1551 1
     case	0xC40	: real_type = RmT_C40;  break;
@


1.19
log
@Various changes including:
1) first attempt at C40 support
2) RmLib execute support (not yet fully tested)
3) faster bootstrap, taskforce load, and better mapping
@
text
@d16 1
a16 1
/*$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.18 1992/01/15 11:04:39 bart Exp $*/
d18 1
d41 2
a42 1

d74 1
d76 1
d182 3
a184 4
  
/**
*** The basic administration of boot jobs.
**/
d206 2
a207 1

d242 2
a243 1

d273 2
a274 1

d286 2
a287 1

d300 3
a302 1

a317 1
BLV    Again protection should be handled.
d348 2
a349 1
  message.Arg1		= length;
d353 1
a353 2
  rc = XchNetworkAgent(processor, &message, length, procname,
			TRUE, 0, NULL);  
d373 2
a374 2
     rc = XchNetworkAgent(processor, &message, 0, NULL,
		TRUE, sizeof(int), (BYTE *) &current_mode);
d395 2
a396 3

     (void) XchNetworkAgent(processor, &message, 0, NULL,
		TRUE, 0, NULL);     
d408 2
a409 1

d456 2
a457 2
  message.Arg2	= length;
  
d459 1
a459 2
  rc = XchNetworkAgent(neighbour, &message, length, procname,
			TRUE, 0, NULL);    
d474 3
a476 1

d627 2
a628 1

d843 2
a844 1

d938 2
a939 1

d983 2
a984 1

d1133 2
a1134 1
     XchNetworkAgent(current, &message, 0, NULL, FALSE, 0, NULL);
d1142 2
a1143 1

d1161 1
a1161 119
static bool boot_down_link(RmProcessor start, int link)
{ RmProcessor		target;
  int			destlink;
  ProcessorEntry	*proc_entry;
  Config		*config = Null(Config);
  word			confsize;
  bool			result = FALSE;
  int			i;
  int			NetagentRequest;

  target = RmFollowLink(start, link, &destlink);
  if ((target eq RmM_NoProcessor) || (target eq RmM_ExternalProcessor))
   return(FALSE);

  Debug(dbg_Boot, ("attempting to boot processor %s via link %d of %s",\
  	Procname(target), link, Procname(start)));

	/* Check for any special bootstrap facilities.			    */
	/* If there is one, invoke it. If successful, update the processor. */
  proc_entry = GetProcEntry(target);
  for (i = 0; i < proc_entry->NumberDrivers; i++)
   { DriverEntry	*driver_entry	= &(proc_entry->DriverEntry[i]);
     RmHardwareFacility	*hardware	= driver_entry->Hardware;
     if ((hardware->Type ne RmH_ResetDriver) &&
         (hardware->Type ne RmH_ConfigureDriver))
      continue;
     if (driver_entry->Flags & DriverFlags_SpecialBootstrap)
      { NetworkDCB	*device = (NetworkDCB *) hardware->Device;
        DriverRequest	request;
        request.FnRc			= ND_Boot;
        request.NumberProcessors	= link;
	request.Processor[0]		= start;
        (*(device->DCB.Operate))(device, &request);
        if (request.FnRc eq Err_Null) goto success;
        if ((request.FnRc & EC_Mask) >= EC_Error) goto fail;
      }
   }

	/* Build a suitable configuration vector. This is done in a	*/
	/* separate routine which may be called from device drivers.	*/
  unless(BuildConfig(start, target, destlink, &config, &confsize))
   goto fail;

	/* Work out what type of bootstrap to use. This may need	*/
	/* updating in future, to allow for combinations of bootstrap.	*/
	/* e.g. a different bootstrap is needed for trannie->trannie	*/
	/* than for i860->trannie.					*/
  switch(RmGetProcessorType(target))
   { case	RmT_Default	:	/* default == transputer */
     case	RmT_T800	:
     case	RmT_T414	:
     case	RmT_T425	:
     case	RmT_T400	: NetagentRequest = NA_TransputerBoot; break;
     case	RmT_C40		: NetagentRequest = NA_C40Boot; break;
     default :
     	report("this version cannot boot up processor %s, a %s",
	       Procname(target), RmT_Names[RmGetProcessorType(target)]);
	goto	fail;			
   }

	/* Reset the processor again if possible */
  (void) ResetProcessors(1, &target);     
  { int state = RmGetProcessorState(target);
    unless(state & RmS_Reset)
     report("warning, trying to boot processor %s which has not been reset",
     		Procname(target));
  }
	/* Try to access the Network agent running on the start processor */
  { NA_Message		message;
    word		reply;
    int			state;

    message.FnRc = NetagentRequest;
    message.Arg1 = link;
    message.Arg2 = confsize;

    reply = XchNetworkAgent(start, &message, confsize, (BYTE *) config,
			TRUE, 0, NULL);

    state = RmGetProcessorState(target);
    state &= ~RmS_Reset;
    RmSetProcessorState(target, state);

    if (reply ne Err_Null)
     { report("failed to boot processor %s via link %d of processor %s",
     		Procname(target), link, Procname(start));
       report("reported fault was %x", reply);
       goto fail;
     }
  }

	/* Check that the processor really has come up, by	*/
	/* starting a network agent on it.			*/
  unless(StartNetworkAgent(target))
   { SetLinkMode(start, link, RmL_NotConnected);
     report("failed to start Network Agent on newly-booted processor %s",
		Procname(target));
     goto fail;
   }
    
success:
  RmSetProcessorState(target, RmS_Running | RmS_Booting);
  LastChange = target->ObjNode.Dates.Modified = GetDate();
  result = TRUE;
  goto done;
    
fail:
  { RmLink *linkstruct = RmFindLink(start, link);
    int	    state = RmGetProcessorState(target);
    linkstruct->Flags |= RmF_Suspicious;
    state &= ~RmS_Reset;
    RmSetProcessorState(target, state);
  }

done:  
  if (config ne Null(Config)) Free(config);
  return(result);
}

d1329 2
a1330 1
}	
d1332 121
d1480 3
a1482 4

  rc = XchNetworkAgent(processor, &message,
		sizeof(Capability), (BYTE *) &(proc_entry->Full),
		TRUE, 3 * sizeof(Capability), 
d1496 2
a1497 1

d1570 2
a1571 1

d1662 2
a1663 1
    XchNetworkAgent(processor, &message, 0, NULL, TRUE, 0, NULL);
d1666 2
a1667 1

d1730 2
a1731 1
    XchNetworkAgent(processor, &message, 0, NULL, TRUE, 0, NULL);
d1734 2
a1735 1

d1742 1
a1742 60
static  void	execute_waitfor(RmTask task, RmProcessor processor);
static	void	execute_console(RmTask task, RmProcessor processor);

static	int	execute_mapped_task(RmTask task, ...)
{ va_list		args;
  RmProcessor		processor;
  ProcessorEntry	*proc_entry;

  va_start(args, task);
  processor = va_arg(args, RmProcessor);
  va_end(args);

  if (!strcmp(task->ObjNode.Name, "waitfor"))
   { execute_waitfor(task, processor); return(0); }
  if (!strcmp(task->ObjNode.Name, "console"))
   { execute_console(task, processor); return(0); }

	/* Must be an ordinary command */

  proc_entry = GetProcEntry(processor);
  proc_entry->CommandDate = GetDate() + 2;
  
  if (task->ObjNode.Name[0] eq '0')	/* hack for no -e, see rmgen */
   return(rexec_task(processor, task, Null(Environ), 0));

  { Environ	env;
    Environ	*net_env = getenviron();
    Stream	*strv[5];
    Object	*objv[OV_End + 1];
    int		i;

	/* By default, inherit context and streams from Network Server */
    for (i = 0; (net_env->Objv[i] ne Null(Object)) && (i <= OV_End); i++)
     objv[i] = net_env->Objv[i];
    objv[OV_End] = Null(Object);
    for (i = 0; i < 4; i++)
     strv[i] = net_env->Strv[i];
    strv[4] = Null(Stream);

    if (proc_entry->WindowServer ne Null(Object))
     objv[OV_CServer] = proc_entry->WindowServer;

    if (proc_entry->ConsoleWindow ne Null(Object))
     { objv[OV_Console] = proc_entry->ConsoleWindow;
       strv[0] = Open(proc_entry->ConsoleWindow, Null(char), O_ReadOnly);
       strv[1] = Open(proc_entry->ConsoleWindow, Null(char), O_WriteOnly);
       strv[2] = strv[1];
     }
    env.Strv	= strv;
    env.Objv	= objv;
    env.Envv	= net_env->Envv;
    env.Argv	= Null(char *);
    
    i = rexec_task(processor, task, &env, 0);
    if (proc_entry->ConsoleWindow ne Null(Object))
     { Close(strv[0]); Close(strv[1]); }
    return(i);
  }
}

d1764 2
a1765 1

d1810 1
d1812 60
d1897 2
a1898 2
  rc = XchNetworkAgent(processor, &message, 0, NULL, TRUE, 
		sizeof(int), (BYTE *) &mode);
d1906 2
a1907 1

d1925 2
a1926 1

d1945 2
a1947 2
  rc = XchNetworkAgent(processor, &message, 0, NULL, TRUE, 0, NULL);

d1952 2
a1953 1

d1986 3
a1988 1

d1990 1
d2011 2
a2012 1
  rc = XchNetworkAgent(processor, &message, 0, NULL, FALSE, 0, NULL);
d2037 1
d2039 1
d2068 1
d2070 1
a2070 3



@


1.18
log
@Major update of networking sources, to incorporate the fault-tolerance
work as demonstrated at the IED meeting 10.1.92
@
text
@d16 1
a16 1
/*$Header: /usr/sparkygiga/Helios/network/RCS/netboot.c,v 1.10 90/12/17 14:27:12 bart Exp $*/
a48 1
#define		BootstrapStack		4096
d57 2
a59 1

d196 4
d383 2
a384 2
     if (current_mode eq RmL_Intelligent)
      message.Arg2 = RmL_Intelligent + RmL_Report;
d386 1
a386 1
      message.Arg2 = RmL_Pending + RmL_Report;
d389 1
a389 1
		FALSE, 0, NULL);     
d476 10
a485 8
***  2) find a processor to start the bootstrap from. This must be an active
***     Helios processor. Start a network agent on that processor
***  3) perform a breadth-first sequential bootstrap of every processor.
***     As processors are booted a network agent is run on every processor.
***     This involves attempting to reset the processors again, just in case.
*** 3) sort out the protection for all the processors.
*** 4) sort out all the connections for all the processors.
*** 5) clear the name tables of all the processors
a490 1
static	void		do_connections(BootstrapJob *job);
d496 2
a497 1
  int			i; 
d522 1
a522 2
	/* Native processors without declared stand-alone code should	*/
	/* not be considered further.					*/
a524 1
     
d548 32
a579 1
  do_connections(job);
d581 1
a581 1
  
d958 1
a958 1
  if (!Fork(2000, &continue_boot, 8, job, next))
a994 3
  if ((RmGetProcessorPurpose(current) & RmP_Mask) eq RmP_Native)
   goto done;

d997 4
d1062 1
a1062 1
        if (Fork(2000, &continue_boot, 8, job, next))
d1070 3
a1074 1
  StopNetworkAgent(current);
d1076 8
a1083 1
  (void) RmApplyMappedTasks(current, &execute_mapped_task, current);
d1085 40
d1126 1
a1126 1
  Signal(&(job->ProcessesFinished));
a1162 8
	/* Native processors should not be booted by the Network Server	*/
	/* Instead sarun or equivalent should be run on an adjacent	*/
	/* Helios node.							*/
  if ((RmGetProcessorPurpose(target) & RmP_Mask) eq RmP_Native)
   { Debug(dbg_Boot, ("target %s is native", Procname(target)));
     goto success;
   }
  	
d1199 1
d1240 1
a1240 1
   { SetLinkMode(start, link, RmL_NotConnected | RmL_Report);
d1283 3
a1285 1
     case	RmT_T400	: return("/helios/lib/nucleus");
d1358 1
a1358 1
  length = temp_length;
d1387 6
d1531 2
a1532 1
     case	0xA3	: real_type = RmT_Arm; break;
d1553 22
a1574 14
*** do_connections(). For every processor in the bootstrap job, sort
*** out the links. As follows:
***  1) if the link is to a processor outside the bootstrap job
***     then run the network agent on the other processor, set the
***     other link to pending, and enable this link
***  2) if the link is to the same processor, then if it is to a
***     later link set the link to pending, otherwise enable it
***  3) if the link is to an earlier processor in the bootstrap job,
***     simply enable the link. It will be in a pending mode already.
***  4) if the link is to a later processor in the bootstrap job, just
***     set it to pending.
***  5) if the link is external, set it to pending.
*** All the above are modified if the other processor is not currently
*** running.
d1576 10
a1585 2
static void do_connections(BootstrapJob *job)
{ int	i;
d1587 4
a1590 37
	/* For every processor booted in this job... */
  for (i = (job->Next - 1); i >= 0; i--)
   { RmProcessor	processor = job->Progress[i];
     int		state	  = RmGetProcessorState(processor);
     int		number_links;
     int		link;
     int		destlink;
     RmProcessor	neighbour;
     int		neighbour_state;
     int		j;
     int		mode;
     NA_Message		message;
     BYTE		default_modes[16];
     BYTE		*link_modes;     
     
	/* If the processor is running happily... */          
     if ((RmGetProcessorPurpose(processor) & RmP_Mask) eq RmP_Native)
      continue;
     unless(state & RmS_Running) continue;
     unless(StartNetworkAgent(processor)) continue;
     
    	/* then for every link.... */
     number_links = RmCountLinks(processor);
     if (number_links > 16)
      { link_modes = Malloc(number_links);
        if (link_modes eq Null(BYTE))
         fatal("out of memory when enabling cross links");
      }
     else
      link_modes = default_modes;
      
     for (link = 0; link < number_links; link++)
      { int	purpose;
      
        neighbour = RmFollowLink(processor, link, &destlink);
	
	/* figure out what to do. */
d1592 1
a1592 2
        if (neighbour eq RmM_NoProcessor)
         { mode = RmL_NotConnected; goto set_link; }
d1594 2
a1595 2
        if (neighbour eq RmM_ExternalProcessor)
         { mode = RmL_Pending; goto set_link; }
d1597 1
a1597 3
	purpose = RmGetProcessorPurpose(neighbour);
        if ((purpose & RmP_Mask) eq RmP_Native)
         { mode = RmL_Dumb; goto set_link; }
d1599 16
a1614 4
	  /* BLV - what to do about routers ? */
	  
	  /* I/O Processors may connect in at any time. */
        if ((purpose & RmP_Mask) eq RmP_IO)
d1616 3
a1618 4
          
        neighbour_state = RmGetProcessorState(neighbour);
        unless(neighbour_state & RmS_Running)
         { mode = RmL_NotConnected; goto set_link; }
d1620 3
a1622 8
	/* Somebody somewhere will do this... */
        if (neighbour eq processor)
         { if (link < destlink)
            mode = RmL_Pending;
           else
            mode = RmL_Intelligent;
           goto set_link;
         }
d1624 5
a1628 4
	/* See if the neighbour is part of the same job */
        for (j = i + 1; j < job->Next; j++)
         if (neighbour eq job->Progress[j])
          { mode = RmL_Intelligent; goto set_link; }
d1630 2
a1631 3
        for (j = 0; j < i; j++)
         if (neighbour eq job->Progress[j])
          { mode = RmL_Pending; goto set_link; }
d1633 1
a1633 4
	/* Oh dear, a processor outside this job */
	(void) SetLinkMode(neighbour, destlink, RmL_Pending);
        
        mode = RmL_Intelligent;
a1634 1
	/* The link can now be set to the correct mode */        
d1636 1
a1636 1
	Debug(dbg_Links, ("processor %s, setting link %d to mode %x",\
d1638 49
a1686 2
	
 	link_modes[link] = mode | RmL_Report;
a1687 6
	
     message.FnRc	= NA_SetLinkMode;
     message.Arg1	= -1;
     message.Arg2	= number_links;
     (void) XchNetworkAgent(processor, &message,
		number_links, link_modes, FALSE, 0, NULL);
d1689 3
a1691 8
		/* Now clear the names */
     message.FnRc = NA_ClearNames;
     (void) XchNetworkAgent(processor, &message, 0, NULL, TRUE, 0, NULL);
     
     StopNetworkAgent(processor);
     if (number_links > 16) Free(link_modes);
   }
}           
d1693 19
d1715 2
a1716 1
*** execute the appropriate task.
d1718 3
d1725 1
a1725 1
  
d1730 7
d1745 23
a1767 3
    
    env.Strv	= net_env->Strv;
    env.Objv	= net_env->Objv;
d1771 4
a1774 1
    return(rexec_task(processor, task, &env, 0));
d1778 67
d1907 1
a1907 1
  Debug(dbg_Links, ("setting link %d of %s to %x", link, Procname(processor), mode));
d1917 1
a1917 1
  rc = XchNetworkAgent(processor, &message, 0, NULL, FALSE, 0, NULL);
d1951 1
a1951 1
   return(RmL_Intelligent);
d1978 1
a1978 1
  rc = XchNetworkAgent(processor, &message, 0, NULL, TRUE, 0, NULL);
@


1.17
log
@Minor changes to match Helios1_2_2_Native final release
@
text
@d16 1
a17 2
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/netboot.c,v 1.5 1991/09/26 10:27:58 bart Exp $";

d50 1
a50 2
#define		AgentMonitorStack	1024
#define		MaxRetries		3
a54 1
static	void	NetagentMonitor(void);
a70 3

  if (!Fork(AgentMonitorStack, &NetagentMonitor, 0))
   fatal("not enough memory to monitor network agents");
d82 1
a82 1
static int	StartBootstrapAux1(RmProcessor Processor, ...);
d92 1
a92 1
  Debug(dbg_Boot, ("root processor is %s", RootProcessor->ObjNode.Name));
d98 1
a98 1
     Debug(dbg_Boot, ("boot I/O processor is %s", BootIOProcessor->ObjNode.Name));
d126 1
d131 1
a131 1
static int StartBootstrapAux1(RmProcessor Processor, ...)
d136 1
a136 1
  va_start(args, Processor);
d140 2
a141 2
  if (Processor eq RootProcessor)	return(0);
  if (Processor eq BootIOProcessor)	return(0);
d143 1
a143 1
  purpose = RmGetProcessorPurpose(Processor);
a148 6
	/* For native processors, only incorporate them into the	*/
	/* bootstrap if there is some stand-alone code to be run.	*/
  if ((purpose & RmP_Mask) eq RmP_Native)
   if (RmCountMappedTasks(Processor) eq 0)
    return(0);

d150 3
a152 3
   { int	state = RmGetProcessorState(Processor);
     RmSetProcessorState(Processor, RmS_Special);
     if (CheckProcessor(Processor))
d154 1
a154 1
         UpdateIOProcessor(Processor, FALSE);
d156 4
a159 4
         UpdateProcessor(Processor, FALSE);
        RmSetProcessorState(Processor, state);
        if ( CheckProcessor(Processor))
         { RmSetProcessorState(Processor, RmS_Running);
d164 1
a164 1
      RmSetProcessorState(Processor, state);
d168 1
a168 1
   { RmSetProcessorState(Processor, RmS_Crashed);
d172 2
a173 2
  RmSetProcessorState(Processor, RmS_Crashed);
  unless(AddProcessorToBootstrapJob(job, Processor))
d200 1
a200 1
bool	AddProcessorToBootstrapJob(BootstrapJob *job, RmProcessor Processor)
d227 1
a227 1
  job->Table[job->NumberProcessors++] = Processor;
d268 2
a269 1
*** until the whole network is ready. Also used for native networks.
d272 3
a274 1
{ Wait(&(job->Finished));
d308 2
a309 2
void UpdateProcessor(RmProcessor Processor, bool name_only)
{ int			state		= RmGetProcessorState(Processor);
a316 2
  
  Debug(dbg_Boot, ("updating processor %s", Processor->ObjNode.Name));
d318 4
a321 2
  Processor->ObjNode.Dates.Modified	=
  Processor->ObjNode.Dates.Access	= GetDate();
d323 1
a323 1
  RmSetProcessorState(Processor, RmS_Special);/* see NetMapProcessorToObject()*/
d325 1
a325 1
  unless(StartNetworkAgent(Processor)) goto done;
d330 1
a330 2
   { report("not enough memory to update processor %s",
   		 Processor->ObjNode.Name);
d333 1
a333 1
  (void) BuildName(procname, Processor);
d340 1
a340 1
  rc = XchNetworkAgent(Processor, FALSE, &message, length, procname,
d344 1
a344 1
   		Processor->ObjNode.Name, rc);
d348 1
a348 1
  do_protection(Processor);
d350 1
a350 1
  ValidateProcessorDetails(Processor);
d354 1
a354 1
  number_links = RmCountLinks(Processor);
d361 1
a361 1
     rc = XchNetworkAgent(Processor, FALSE, &message, 0, NULL,
d365 1
a365 1
     neighbour = RmFollowLink(Processor, i, &destlink);
d369 1
a369 1
          		Processor->ObjNode.Name, i);
d384 1
a384 1
     (void) XchNetworkAgent(Processor, FALSE, &message, 0, NULL,
d388 1
a388 1
  (void) RmApplyMappedTasks(Processor, &execute_mapped_task, Processor);
d390 1
a390 1
  
d393 2
a394 2
  if (started_agent) StopNetworkAgent(Processor);
  RmSetProcessorState(Processor, state);	/* restore */
d398 1
a398 1
void UpdateIOProcessor(RmProcessor Processor, bool name_only)
d409 1
a409 1
  Debug(dbg_Boot, ("updating I/O processor %s", Processor->ObjNode.Name));
d411 2
a412 2
  Processor->ObjNode.Dates.Modified =
  Processor->ObjNode.Dates.Access   = GetDate();
d414 1
a414 1
  if (RmCountLinks(Processor) ne 1)
d416 1
a416 1
   		Processor->ObjNode.Name);
d420 1
a420 1
  neighbour = RmFollowLink(Processor, 0, &destlink);
d423 1
a423 1
   		Processor->ObjNode.Name);
d427 1
a427 1
  Debug(dbg_Boot, ("I/O processor's neighbour is %s", neighbour->ObjNode.Name));
d436 1
a436 1
  (void) BuildName(procname, Processor);
d447 1
a447 1
  rc = XchNetworkAgent(neighbour, FALSE, &message, length, procname,
d452 1
a452 1
   	Processor->ObjNode.Name, rc);
a457 1

d496 1
d498 2
d503 2
a504 2
   { RmProcessor Processor = table[i];
     int	 state     = RmGetProcessorState(Processor);
d507 2
a508 2
     (void) RmSetProcessorState(Processor, state);
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
d515 13
a527 2
  
  for (retries = 0; retries < MaxRetries; )
d536 1
a536 2
     	job->Sequence, retries+1, start->ObjNode.Name));
     		
a540 1
     if (left eq 0) break;
d549 2
a550 2
   { RmProcessor Processor	= job->Table[i];
     int	    state 	= RmGetProcessorState(Processor);
d552 2
a553 3
      { 
	state &= ~RmS_Booting;
        RmSetProcessorState(Processor, state);
d557 1
a557 1
         report("failed to boot processor %s", Processor->ObjNode.Name);
d561 1
a561 1
	   RmSetProcessorState(Processor, state);
d563 1
d568 5
a572 1
   report("network booted.");
d574 2
d591 1
a591 1
static void TryResetCommand(RmProcessor Processor, RmHardwareFacility *);
d601 1
a601 1
    
d615 1
a615 1
   { RmProcessor	Processor	= table[i];
d617 1
a617 1
     state = RmGetProcessorState(Processor);
d621 1
a621 1
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
d631 1
a631 1
         
d637 1
a637 1
        request->Processor[0]		= Processor;
d646 1
a646 1
	   temp_entry = (ProcessorEntry *) RmGetProcessorPrivate(temp);
d658 1
a658 1
        if (RmGetProcessorState(Processor) & RmS_Reset) break;
d664 1
a664 1
   { RmProcessor	Processor	= table[i];
d666 1
a666 1
     state = RmGetProcessorState(Processor);
d670 1
a670 1
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
d686 1
a686 1
        request->Processor[0]		= Processor;
d695 1
a695 1
	   temp_entry = (ProcessorEntry *) RmGetProcessorPrivate(temp);
d707 1
a707 1
        if (RmGetProcessorState(Processor) & RmS_Reset) break;
d713 1
a713 1
   { RmProcessor	Processor	= table[i];
d715 1
a715 1
     state = RmGetProcessorState(Processor);
d719 1
a719 1
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
d729 1
a729 1
        TryResetCommand(Processor, hardware);         
d735 2
a736 2
   { RmProcessor Processor = table[i];
     state = RmGetProcessorState(Processor);
d739 1
a739 1
     RmSetProcessorState(Processor, state);
d759 1
a759 1
static	void TryResetCommand(RmProcessor Processor, RmHardwareFacility *hardware)
d762 1
a762 1
  int		state = RmGetProcessorState(Processor);
d774 1
a774 1
   { if (hardware->Processors[i] eq Processor) continue;
d815 1
a815 1
{ RmProcessor	Processor;
d829 2
a830 2
   { Processor	= job->Table[i];
     state	= RmGetProcessorState(Processor);
d835 1
a835 1
     number_links = RmCountLinks(Processor);
d837 1
a837 1
      { neighbour = RmFollowLink(Processor, j, destlink);
d863 1
a863 1
      { report("the link to processor %s is not appearing", delayed->ObjNode.Name);
d867 1
a867 1
      report("waiting for link to processor %s", delayed->ObjNode.Name);
d886 1
a886 1
    job->Table[job->NumberProcessors - 1] = Processor;
d964 1
a964 1
   report("processor %s booted.", current->ObjNode.Name);
d977 1
a977 1
     its_proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(next);
d1076 1
a1076 2
  	target->ObjNode.Name, link, start->ObjNode.Name));
	/* BLV - boot stand-alone code into native processors ? */
d1078 3
d1082 1
a1082 1
   { Debug(dbg_Boot, ("target %s is native", target->ObjNode.Name));
d1088 1
a1088 1
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(target);
d1124 1
a1124 1
	       target->ObjNode.Name, RmT_Names[RmGetProcessorType(target)]);
d1133 1
a1133 1
     		target->ObjNode.Name);
d1144 1
a1144 1
    reply = XchNetworkAgent(start, FALSE, &message, confsize, (BYTE *) config,
d1153 1
a1153 1
     		target->ObjNode.Name, link, start->ObjNode.Name);
d1162 1
a1162 1
   { SetLinkMode(start, link, RmL_NotConnected);
d1164 1
a1164 1
		target->ObjNode.Name);
d1198 2
a1199 2
static char	*default_nucleus(RmProcessor Processor)
{ int	type = RmGetProcessorType(Processor);
d1230 1
a1230 1
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(dest);
d1259 1
a1259 1
   		dest->ObjNode.Name);
d1363 1
a1363 1
static void do_protection(RmProcessor Processor)
d1368 1
a1368 1
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
d1371 1
a1371 1
 	Processor->ObjNode.Name));
d1376 1
a1376 1
  rc = XchNetworkAgent(Processor, FALSE, &message,
d1383 1
a1383 1
      		Processor->ObjNode.Name, rc);
d1387 2
a1388 2
   { memcpy(&(Processor->RealCap), &(proc_entry->Full), sizeof(Capability));
     memcpy(&(Processor->ReadOnlyCap), &(proc_entry->General), 
d1398 2
a1399 2
static void	ValidateProcessorDetails(RmProcessor Processor)
{ int		state		= RmGetProcessorState(Processor);
d1402 2
a1403 2
  int		number_links	= RmCountLinks(Processor);
  int		proc_type	= RmGetProcessorType(Processor);
d1407 1
a1407 1
  real_processor = NetMapProcessorToObject(Processor);
d1409 1
a1409 1
   { MarkProcessor(Processor); goto done; }
d1417 2
a1418 2
   		Result2(real_processor), Processor->ObjNode.Name);
     MarkProcessor(Processor);
d1425 1
a1425 1
  if (RmGetProcessorMemory(Processor) eq 0)
d1429 1
a1429 1
     (void) RmSetProcessorMemory(Processor, memory);
d1447 1
a1447 1
			Processor->ObjNode.Name, stats->Type);
d1452 1
a1452 1
   RmSetProcessorType(Processor, real_type);
d1456 2
a1457 2
       Processor->ObjNode.Name, RmT_Names[real_type], RmT_Names[proc_type]);
     RmSetProcessorType(Processor, real_type);
d1486 2
a1487 2
   { RmProcessor	Processor = job->Progress[i];
     int		state	  = RmGetProcessorState(Processor);
d1491 1
a1491 1
     RmProcessor	Neighbour;
d1500 1
a1500 1
     if ((RmGetProcessorPurpose(Processor) & RmP_Mask) eq RmP_Native)
d1503 1
a1503 1
     unless(StartNetworkAgent(Processor)) continue;
d1506 1
a1506 1
     number_links = RmCountLinks(Processor);
d1518 1
a1518 1
        Neighbour = RmFollowLink(Processor, link, &destlink);
d1522 1
a1522 1
        if (Neighbour eq RmM_NoProcessor)
d1525 2
a1526 2
        if (Neighbour eq RmM_ExternalProcessor)
         { mode = RmL_Pending + RmL_Report; goto set_link; }
d1528 1
a1528 1
	purpose = RmGetProcessorPurpose(Neighbour);
d1532 1
a1532 1
	  /* BLV - what to do about routers */
d1536 1
a1536 1
         { mode = RmL_Pending | RmL_Report; goto set_link; }
d1538 1
a1538 1
        neighbour_state = RmGetProcessorState(Neighbour);
d1543 1
a1543 1
        if (Neighbour eq Processor)
d1553 1
a1553 1
         if (Neighbour eq job->Progress[j])
d1557 1
a1557 1
         if (Neighbour eq job->Progress[j])
d1561 1
a1561 1
	(void) SetLinkMode(Neighbour, destlink, RmL_Pending);
d1567 2
a1568 2
	Debug(dbg_Links, ("processor %s, setting link %d to mode %d",\
		Processor->ObjNode.Name, link, mode));
d1570 1
a1570 1
 	link_modes[link] = mode;
d1576 1
a1576 1
     (void) XchNetworkAgent(Processor, FALSE, &message,
d1581 1
a1581 1
     (void) XchNetworkAgent(Processor, FALSE, &message, 0, NULL, TRUE, 0, NULL);
d1583 1
a1583 1
     StopNetworkAgent(Processor);
d1602 1
a1602 1
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(processor);
a1619 61
/**-----------------------------------------------------------------------------
*** Various utilities
***
*** NetagentMonitor(). During the bootstrap process I want to have netagents
*** staying around for a while, but not for too long. Hence there is a little
*** process monitoring the network agents on every processor, stopping
*** ones that have been idle for 10 seconds or more. Obviously this routine
*** should only wake up when there are network agents running.
**/
static	Semaphore	NetagentQueueCount;
static	Semaphore	NetagentStructLock;
static	List		NetagentList;

static void NetagentMonitor(void)
{ ProcessorEntry	*proc_entry;
  ProcessorEntry	*next_entry;
  int			Date;

  InitSemaphore(&NetagentQueueCount, 0);
  InitSemaphore(&NetagentStructLock, 1);
  InitList(&(NetagentList));

  forever
   { 
     Wait(&NetagentQueueCount);		/* wait if there are no netagents */
     Signal(&NetagentQueueCount);	/* the number has not changed yet */
     Delay(10 * OneSec);

     Wait(&NetagentStructLock);
     Date = GetDate(); 
     for (proc_entry = Head_(ProcessorEntry, NetagentList);
          !EndOfList_(proc_entry);
          proc_entry = next_entry)
      { next_entry = Next_(ProcessorEntry, proc_entry);

        Wait(&(proc_entry->NetagentLock));
        if ((proc_entry->NetagentCount eq 0) &&
            ((Date - proc_entry->NetagentDate) > 10))
         { if (proc_entry->NetagentPipe ne Null(Stream))
            { NA_Message	message;
              message.FnRc	= NA_Quit;

	      Debug(dbg_Execute, ("killing network agent on %s",\
		   proc_entry->Processor->ObjNode.Name));

              (void) Write(proc_entry->NetagentPipe, (BYTE *) &message, 
                        sizeof(NA_Message), 5 * OneSec);

              (void) Close(proc_entry->NetagentPipe);
              proc_entry->NetagentPipe = Null(Stream);
            }
           Remove(&(proc_entry->NetagentNode));
	   proc_entry->NetagentDate = 0;
           Wait(&(NetagentQueueCount));
         }
        Signal(&(proc_entry->NetagentLock));
      }     
     Signal(&NetagentStructLock);
   }
}

a1620 361
*** StartNetworkAgent(). Start the network agent on the specified processor. 
*** If it is already running, this is a no-op. The environment sent is
*** minimal, only the first stream is defined and this is a pipe back to
*** the Network Server.
**/

bool StartNetworkAgent(RmProcessor processor)
{ ProcessorEntry *proc_entry;
  Object	 *pipe;
  char		 namebuf[NameMax + 5];
  static int	 pipenum = 1;
  bool		 result = FALSE;
  Environ	 Env;
  char		*Argv[1];
  char		*Envv[1];
  Object	*Objv[1];
  Stream	*Strv[2];
  word		rc;

  Debug(dbg_Execute, ("starting network agent on %s", processor->ObjNode.Name));

  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(processor);

  Wait(&NetagentStructLock);
  Wait(&(proc_entry->NetagentLock));

  if (proc_entry->NetagentPipe ne Null(Stream))
   { result = TRUE; goto done; }

  strcpy(namebuf, "pipe/netagent.");
  addint(namebuf, pipenum++);
  pipe = Create(ThisProcessor, namebuf, Type_Pipe, 0, Null(BYTE));
  if (pipe eq Null(Object))
   { report("warning, failed to create pipe on root processor, fault %x",
   		Result2(ThisProcessor));
     goto done;
   }

  Strv[0]	= PseudoStream(pipe, O_ReadWrite);
  if (Strv[0] eq Null(Stream))
   { report("warning, failed to access pipe on root processor, fault %x",
   		Result2(pipe));
     (void) Delete(pipe, Null(char)); Close(pipe);
     goto done;
   }
  proc_entry->NetagentPipe = PseudoStream(pipe, O_ReadWrite);
  if (proc_entry->NetagentPipe eq Null(Stream))
   { report("warning, failed to open pipe to network agent, fault %x",
   	Result2(pipe));
     Close(Strv[0]);
     (void) Delete(pipe, Null(char)); Close(pipe);
     goto done;
   }
  Close(pipe);
     
  Strv[1]	= Null(Stream);
  Objv[0]	= Null(Object);
  Argv[0]	= Null(char);
  Envv[0]	= Null(char);
  Env.Strv	= Strv;
  Env.Objv	= Objv;
  Env.Argv	= Argv;
  Env.Envv	= Envv;
  rc		= rexec(processor, NetAgent, &Env, 0);

  Close(Strv[0]);

  if (rc ne Err_Null)
   { 
     Close(proc_entry->NetagentPipe);
     proc_entry->NetagentPipe = Null(Stream);
     MarkProcessor(processor);
     (void) Delete(pipe, Null(char));
     report("warning, failed to execute netagent on processor %s, fault %x",
		processor->ObjNode.Name, rc);
     goto done;
   }

  result = TRUE;

	/* After a processor terminate the netagent node could still    */
	/* be in the netagent queue, to avoid deadlock problems.	*/
	/* Hence an additional test is needed.				*/
  if (proc_entry->NetagentDate == 0)
   { AddTail(&NetagentList, &(proc_entry->NetagentNode));
     Signal(&NetagentQueueCount);
   }
  
done:

  if (result)
   { Debug(dbg_Execute, ("network agent now running on %s", processor->ObjNode.Name));
     proc_entry->NetagentCount++;
     proc_entry->NetagentDate = GetDate();
   }  
  Signal(&(proc_entry->NetagentLock));
  Signal(&NetagentStructLock);
  return(result);  
}

/**
*** StopNetworkAgent(). This is used to get rid of a network agent once
*** it is no longer needed, e.g. at the end of a boot job.
**/
bool StopNetworkAgent(RmProcessor processor)
{ ProcessorEntry *proc_entry;

  Debug(dbg_Execute, ("stopping network agent on processor %s", processor->ObjNode.Name));

  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(processor);
  Wait(&(proc_entry->NetagentLock));
  if (proc_entry->NetagentPipe ne Null(Stream))
   proc_entry->NetagentCount--;
  Signal(&(proc_entry->NetagentLock));
  return(TRUE);
}

/**
*** Perform some communication with a Network Agent. Take suitable action
*** if the communication fails, typically because the Network Agent has gone.
**/
int XchNetworkAgent(RmProcessor processor, bool locked, NA_Message *message,
	int wsize1, BYTE *wdata1, bool read_rc, int rsize1, BYTE *rdata1)
{ ProcessorEntry *proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(processor);
  Stream	 *pipe;
  int		result = RmE_Success;
  int		step = 0;

  unless(locked)
   Wait(&(proc_entry->NetagentLock));

  pipe = proc_entry->NetagentPipe;

  if (Write(pipe, (BYTE *) message, sizeof(NA_Message), 2 * OneSec) ne
      sizeof(NA_Message))
   goto agent_broken;
  step++;

  if (wsize1 > 0)
   if (Write(pipe, wdata1, wsize1, 2 * OneSec) ne wsize1)
    goto agent_broken;
  step++;

  unless(read_rc) goto done;
  if (Read(pipe, (BYTE *) &result, sizeof(WORD), 2 * OneSec) ne sizeof(WORD))
   goto agent_broken;
  step++;

  if ((result eq RmE_Success) && (rsize1 > 0))
   if (Read(pipe, rdata1, rsize1, 2 * OneSec) ne rsize1)
    goto agent_broken;
  step++;

  goto done;

agent_broken:
  report("failed to communicate with Network Agent on processor %s",
		processor->ObjNode.Name);

/* BLV - recover properly, possibly try to restart the network agent */
  result = RmE_CommsBreakdown;
  Close(proc_entry->NetagentPipe);
  proc_entry->NetagentPipe = Null(Stream);

done:  
  unless(locked)
   Signal(&(proc_entry->NetagentLock));
  return(result);
}

/**
*** Remotely execute the specified program on the specified processor,
*** using the environment given. If the delay is 0 do not wait for
*** termination. Otherwise return the result.
**/  
word rexec(RmProcessor processor, Object *code, Environ *env, word delay)
{ Object *proc		= Null(Object);
  Object *procman	= Null(Object);
  Object *program	= Null(Object);
  Stream *prog_stream	= Null(Stream);
  int	 rc		= Err_Null;

  Debug(dbg_Execute, ("rexec, running program %s on processor %s", code->Name, \
  	processor->ObjNode.Name));
  	
  proc = NetMapProcessorToObject(processor);  
  if (proc eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Invalid + EO_Processor; goto done; }

  Debug(dbg_Execute, ("rexec, full processor name is %s", proc->Name));
  
  procman = Locate(proc, "tasks");
  if (procman eq Null(Object))
   { rc = Result2(proc); goto done; }

  program = Execute(procman, code);
  if (program eq Null(Object))
   { rc = Result2(procman); goto done; }

  Debug(dbg_Execute, ("rexec, program %s is now running on %s",\
	code->Name, processor->ObjNode.Name));
     
  if ((env ne Null(Environ)) || (delay ne 0))
   { prog_stream = Open(program, Null(char), O_ReadWrite);
     if (prog_stream eq Null(Stream))
      { rc = Result2(prog_stream); goto done; }
   }

  if (env ne Null(Environ))
   { if (env->Objv[0] ne Null(Object))
      {  env->Objv[OV_Code]	= (Object *) MinInt;
         env->Objv[OV_Task]	= program;
         env->Objv[OV_Source]	= code;
      }
     if (SendEnv(prog_stream->Server, env) < Err_Null)
      { rc = Result2(prog_stream); goto done; }
   }

  if (delay ne 0)
   { 
     Debug(dbg_Execute, ("rexec, waiting for program termination"));
     if ((rc = InitProgramInfo(prog_stream, PS_Terminate)) < Err_Null)
      goto done;
     rc = GetProgramInfo(prog_stream, Null(WORD), delay);
   }
   
done:
  Debug(dbg_Execute, ("rexec for program %s on %s %s", \
	code->Name, processor->ObjNode.Name, (rc eq Err_Null) ? "done" : "failed"));
  
  if (prog_stream ne Null(Stream)) Close(prog_stream);
  if (rc < Err_Null)
   { if (program ne Null(Object))
      { (void) Delete(program, Null(char));
        (void) Delete(program, Null(char));
        (void) Delete(program, Null(char));
      }
   }
  if (program ne Null(Object))	Close(program);
  if (proc ne Null(Object))	Close(proc);
  if (procman ne Null(Object))	Close(procman);
  return(rc);
}

/**
*** Similar to rexec, but instead of taking an Object this routine
*** takes an RmTask pointer. Also, the arguments are filled in from
*** the RmTask structure.
**/
word	rexec_task(RmProcessor processor, RmTask task, Environ *env, word delay)
{ char		*procname	= (char *) RmGetTaskCode(task);
  Object	*program	= Null(Object);
  int		number_args	= RmCountTaskArguments(task);
  int		i;
  char		*argv[8];
  word		result;
    
  if (procname[0] eq '/')
   program = Locate(Null(Object), procname);
  else
   { Object *heliosbin = Locate(Null(Object), "/helios/bin");
     if (heliosbin ne Null(Object))
      { program = Locate(heliosbin, procname);
        Close(heliosbin);
      }
   }
  if (program eq Null(Object))
   { report("warning, failed to locate program %s.", procname);
     return(0);
   }
 
  if (env eq Null(Environ))
   { result = rexec(processor, program, Null(Environ), delay);
     goto done;
   }

  if (number_args < 7)	/* allow for terminator */
   env->Argv = argv;
  else
   { env->Argv = (char **) Malloc((number_args + 1) * sizeof(char *));
     if (env->Argv eq Null(char *))
      { report("warning, out of memory when trying to run program.");
        goto done;
      }
   }

  env->Argv[0] = objname(program->Name);
  for (i = 1; i < number_args; i++)
   env->Argv[i] = (char *) RmGetTaskArgument(task, i);
  env->Argv[i] = Null(char);
  
  result = rexec(processor, program, env, delay);
  
done:
  if (env ne Null(Environ))
   if (number_args >= 7)
    Free(env->Argv);
  if (program ne Null(Object))
   Close(program);
  return(result);
}
/**
*** Mapping an RmProcessor structure onto a Helios object, e.g. for
*** executing programs. This only makes sense if the processor is
*** currently up and running, so NewObject()/Locate() are used.
***
*** The first step is to build up the full network name of the processor.
*** The object can then be located/newobject()'ed, as required. There is
*** a problem in that the processor may not yet have a full network name.
*** This is only likely in a few special cases, which set the processor
*** state to RmS_Special to indicate this.
**/

char *BuildName(char *buffer, RmProcessor Processor)
{ const char *name;

  if (Processor eq (RmProcessor) RmRootNetwork(Processor))
   { 
     name = NetworkName;
     *buffer++ = '/';
     for ( ; *name ne '\0'; ) *buffer++ = *name++;
     return(buffer);
   }
  else
   { 
     buffer = BuildName(buffer, (RmProcessor) RmParentNetwork(Processor));
     *buffer++ = '/';
     name = (RmIsNetwork(Processor)) ? RmGetNetworkId((RmNetwork) Processor) :
     			(const char *) Processor->ObjNode.Name;
     for ( ; *name ne '\0'; ) *buffer++ = *name++;
     *buffer = '\0';
     return(buffer);
   }
}

Object	*NetMapProcessorToObject(RmProcessor Processor)
{ char		*buf = RmGetObjectAttribute((RmObject) Processor, "PUID", TRUE);
  Object	*result;
  Capability	*Cap;

  Cap = RmGetProcessorCapability(Processor, TRUE);
  if ((*((word *) Cap) eq 0) || (RmGetProcessorState(Processor) eq RmS_Special))
   result = Locate(Null(Object), buf);
  else
   result = NewObject(buf, Cap);
   
  if (result eq Null(Object))
   if (RmGetProcessorState(Processor) eq RmS_Special)
    { char	*temp = &(buf[1]);

      for ( ; *temp ne '\0'; temp++)
       if (*temp eq '/') 
        { result = Locate(Null(Object), temp);
          if (result ne Null(Object)) goto done;
        }
    }
done:       
  return(result);
}

/**
d1624 1
a1624 1
void	HandleGetLinkMode(NsConn Connection, int JobId,
a1632 1
  Signal(&(SingleStep));
d1645 1
a1645 1
  rc = XchNetworkAgent(processor, FALSE, &message, 0, NULL, TRUE, 
a1648 1
  Wait(&(SingleStep));
d1652 1
a1652 1
  ReplyRmLib(Connection, JobId, reply);
d1655 1
a1655 1
void	HandleSetLinkMode(NsConn Connection, int JobId,
a1660 2
  Signal(&(SingleStep));

a1668 1
  Wait(&(SingleStep));
d1670 1
a1670 1
  ReplyRmLib(Connection, JobId, reply);
d1682 2
d1692 1
a1692 1
  rc = XchNetworkAgent(processor, FALSE, &message, 0, NULL, FALSE, 0, NULL);
d1699 34
d1741 1
a1741 1
void	ClearNames(RmProcessor Processor)
d1746 1
a1746 1
  if (Processor eq RootProcessor)
d1749 1
a1749 1
  unless(StartNetworkAgent(Processor)) goto done;
d1753 1
a1753 1
  rc = XchNetworkAgent(Processor, FALSE, &message, 0, NULL, TRUE, 0, NULL);
d1756 1
a1756 1
  if (agent_started) StopNetworkAgent(Processor);
d1778 7
d1786 2
a1787 13
/**
*** Terminating a processor. This is slightly unusual because during the
*** terminate the pipe will have gone away and must be ignored.
**/
void	TerminateProcessor(RmProcessor Processor)
{ NA_Message		message;
  bool			agent_started = FALSE;
  bool			agent_locked  = TRUE;
  ProcessorEntry	*proc_entry;
 
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
  unless(StartNetworkAgent(Processor)) goto done;
  agent_started = TRUE;
d1789 3
a1791 7
  message.FnRc = NA_Terminate;
  Wait(&(proc_entry->NetagentLock));
  agent_locked = TRUE;
  (void) XchNetworkAgent(Processor, TRUE, &message, 0, NULL, FALSE, 0, NULL);
  Close(proc_entry->NetagentPipe);
  proc_entry->NetagentPipe = Null(Stream);
  proc_entry->NetagentCount--;
d1793 13
a1805 5
  Processor->ObjNode.Size &= ~(RmS_Running | RmS_Suspicious | RmS_Crashed
  	 | RmS_Dead | RmS_Booting | RmS_AutoBoot);
  
done:
  if (agent_locked) Signal(&(proc_entry->NetagentLock));
d1807 2
@


1.17.1.1
log
@Suppressed a warning when a network being rebooted contained inaccessible
native processors.
@
text
@d522 1
a522 12

	/* BLV 21.1.92, avoid yet more warnings for native processors */
  for (i = 0; i < number; i++)
   { RmProcessor processor = table[i];
     int	 purpose = RmGetProcessorPurpose(processor);
     if (((purpose & RmP_Mask) eq RmP_Native) &&
         (RmCountMappedTasks(processor) eq 0))
      { RmSetProcessorState(processor, RmS_Running | RmS_Booting);
        left--;
      }
   }  
     
@


1.16
log
@Major update of networking sources, to match Helios1_2_2_native_beta
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/netboot.c,v 1.4 1991/08/20 14:11:48 bart Exp $";
d149 1
d153 6
@


1.15
log
@Now recognises T801 processors.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.14 1991/06/13 14:24:31 bart Exp bart $";
a56 2
static	void	TryToReset(RmProcessor);
static	bool	InitProcessor(RmProcessor);
d58 1
d127 1
a127 1
  (void) RmApplyNetwork(Net, &StartBootstrapAux1, job);
a144 3
  if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &StartBootstrapAux1, job));
   
d149 3
a151 1
  if (purpose eq RmP_Native) return(0);
d153 20
a172 6
  if (purpose eq RmP_IO)
   { if (!FullReset)
      if (CheckProcessor(Processor))
       { RmSetProcessorState(Processor, RmS_Running); return(0); }
    
     RmSetProcessorState(Processor, RmS_Crashed);
a175 5
	/* Purpose is Helios or system */
  if (!FullReset)
   if (CheckProcessor(Processor))
    { RmSetProcessorState(Processor, RmS_Running); return(0); }

d272 1
a272 1
*** until the whole network is ready
d279 13
a310 1
  ProcessorEntry	*proc_entry;
a311 2
  bool			started_agent	= FALSE;
  bool			agent_locked	= FALSE;
d317 1
a338 4
  
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
  Wait(&(proc_entry->NetagentLock));
  agent_locked = TRUE;
a340 7
	  
  if (Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
  	5 * OneSec) ne sizeof(NA_Message))
   { MarkProcessor(Processor); goto done; }
  if (Write(proc_entry->NetagentPipe, (BYTE *) procname, length, 5 * OneSec) ne
       length)
   { MarkProcessor(Processor); goto done; }
d342 2
a343 6
  Debug(dbg_Boot, ("processor update, waiting for reply from netagent"));
  
  if (Read(proc_entry->NetagentPipe, (BYTE *) &rc, sizeof(WORD), 5 * OneSec) ne
  	sizeof(WORD))
   { MarkProcessor(Processor); goto done; }
   
d350 1
a350 10
   Debug(dbg_Boot, ("processor update, doing protection"));
   
   message.FnRc = NA_Protect;
   message.Arg1 = ProtectionMatrix;
   if (Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
   	5 * OneSec) ne sizeof(NA_Message))
    { MarkProcessor(Processor); goto done; }
   if (Write(proc_entry->NetagentPipe, (BYTE *) &(proc_entry->Full),
   	sizeof(Capability), 5 * OneSec) ne sizeof(Capability))
    { MarkProcessor(Processor); goto done; }
d352 1
a352 17
   if (Read(proc_entry->NetagentPipe, (BYTE *) &rc, sizeof(WORD), 5 * OneSec)
   	ne sizeof(WORD))
    { MarkProcessor(Processor);
      memset((void *) &(proc_entry->Owner), 0, 3 * sizeof(Capability));
      goto done;
    }   
   if (rc ne Err_Null)
    { report("warning, failed to set protection on processor %s, fault %x",
		Processor->ObjNode.Name, rc);
      goto done;
    }
   if (Read(proc_entry->NetagentPipe, (BYTE *) &(proc_entry->Owner),
 	  	3 * sizeof(Capability), 5 * OneSec) ne (3 * sizeof(Capability)))
    { MarkProcessor(Processor);
      memset((void *) &(proc_entry->Owner), 0, 3 * sizeof(Capability));
    }
   memcpy(&(Processor->RealCap), &(proc_entry->Full), sizeof(Capability));
d354 20
a373 1
   ValidateProcessorDetails(Processor);
d375 9
a383 12
	/* set any external links to pending. BLV, do a proper check of	*/
	/* all the links.						*/
   number_links = RmCountLinks(Processor);
   for (i = 0; i < number_links; i++)
    { int destlink;
      neighbour = RmFollowLink(Processor, i, &destlink);
      if (neighbour eq RmM_NoProcessor) continue;
      if (neighbour ne RmM_ExternalProcessor)
       if (RmGetProcessorPurpose(neighbour) ne RmP_IO)
        continue;
      message.FnRc = NA_SetLinkMode;
      message.Arg1 = i;
a384 5
      
      if (Write(proc_entry->NetagentPipe, (BYTE *) &message,
      		sizeof(NA_Message), 5 * OneSec) ne sizeof(NA_Message))
       { MarkProcessor(Processor); goto done; }
    }
d386 5
a390 1
   (void) RmApplyMappedTasks(Processor, &execute_mapped_task, Processor);
a394 1
  if (agent_locked) Signal(&(proc_entry->NetagentLock));
a404 1
  bool			netagent_locked  = FALSE;
a405 1
  ProcessorEntry	*proc_entry;
d434 1
a434 1
  unless ((purpose eq RmP_Helios) || (purpose eq RmP_System)) goto done;
a435 4
  unless(StartNetworkAgent(neighbour)) goto done;
  netagent_started = TRUE;

  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(neighbour);
d440 3
a447 3
  Wait(&(proc_entry->NetagentLock));
  netagent_locked = TRUE;

d449 2
a450 13
    
  if (Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
  	5 * OneSec) ne sizeof(NA_Message))
   { MarkProcessor(neighbour); goto done; }
  if (Write(proc_entry->NetagentPipe, (BYTE *) procname, length, 5 * OneSec)
  	ne length)
   { MarkProcessor(neighbour); goto done; }

  Debug(dbg_Boot, ("waiting for reply from netagent"));
  
  if (Read(proc_entry->NetagentPipe, (BYTE *) &rc, sizeof(WORD), 5 * OneSec)
  	ne sizeof(WORD))
   { MarkProcessor(neighbour); goto done; }
a462 1
  if (netagent_locked) Signal(&(proc_entry->NetagentLock));
d471 3
a473 1
*** 1) attempt to reset every processor in the job
a482 4
BLV This may fail for disconnected bootstrap jobs if part of the bootstrap
BLV is unsuccessful - I think. The solution involves splitting the set
BLV of processors up into disjoint subnets every time around the retry
BLV loop, and try to reboot the disjoint subnets separately.
a484 1
static void initial_resets(BootstrapJob *job);
a487 1
static	void		do_protection(RmProcessor);
d491 8
a498 7
{ RmProcessor	*table = job->Table; 
  int		number = job->NumberProcessors;
  int		left   = number;
  int		i; 
  int		retries;
  RmProcessor	start;
  int		destlink;
d500 1
a500 1
  Debug(dbg_Boot, ("starting bootstrap job for %d processors", number));
d506 1
a506 1
     state |=  (RmS_ShouldBeReset + RmS_Booting);
d508 2
d512 1
a512 1
  Debug(dbg_Boot, ("attempting initial resets"));
d514 2
a515 1
  initial_resets(job);
d524 2
a525 2
     Debug(dbg_Boot, ("bootstrap job, attempt %d, starting from %s", retries+1,\
     		start->ObjNode.Name));
d534 1
a534 1
  Debug(dbg_Boot, ("bootstrap, enabling all the connections"));
d536 1
a536 1
  Debug(dbg_Boot, ("bootstrap job done"));
d543 2
a544 1
      { state &= ~RmS_Booting;
d551 2
a552 2
         { state |= (RmS_ShouldBeReset | RmS_Dead);
           state &= ~RmS_AutoBoot;
a573 3
BLV Currently this resets every processor one by one. It can be optimised
BLV greatly for telmat and meiko hardware by attempting to reset multiple
BLV processors in one go.
d575 17
a591 5
static void initial_resets(BootstrapJob *job)
{ RmProcessor	*table	= job->Table;
  int		count	= job->NumberProcessors;
  int		i;
  
d593 7
a600 5
     int		state		= RmGetProcessorState(Processor);
     if (state & RmS_Reset) continue;
     TryToReset(Processor);
   }
}
d602 3
a604 1
static void TryResetCommand(RmProcessor Processor, RmHardwareFacility *);
d606 1
a606 10
static void TryToReset(RmProcessor Processor)
{ ProcessorEntry	*proc_entry;
  int			j;
  
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
  for (j = 0; j < proc_entry->NumberDrivers; j++)
   { DriverEntry	*driver_entry = &(proc_entry->DriverEntry[j]);
     RmHardwareFacility	*hardware     = driver_entry->Hardware;
     
     if (hardware->Type eq RmH_ConfigureDriver) continue;
d608 15
a622 2
     if (hardware->Type eq RmH_ResetCommand)
      TryResetCommand(Processor, hardware);
d624 4
a627 5
     if (hardware->Type eq RmH_ResetDriver)
      { if (driver_entry->Flags & DriverFlags_DefiniteReset)
         { DriverRequest	request;
           RmHardwareFacility	*hardware = driver_entry->Hardware;
           NetworkDCB		*device = (NetworkDCB *) hardware->Device;
d629 1
a629 10
           request.FnRc	 		= ND_Reset;
           request.NumberProcessors	= 1;
           request.Processor[0]		= Processor;
           (*(device->DCB.Operate))(device, &request);
	   if (request.FnRc eq Err_Null) break;
         }
        elif (driver_entry->Flags & DriverFlags_PossibleReset)
         { DriverRequest	 request;
           RmHardwareFacility	*hardware = driver_entry->Hardware;
           NetworkDCB		*device   = (NetworkDCB *) hardware->Device;
d631 101
a731 8
           request.FnRc	 		= ND_ConditionalReset;
           request.NumberProcessors	= 1;
           request.Processor[0]		= Processor;
           (*(device->DCB.Operate))(device, &request);
	   if (request.FnRc eq Err_Null) break;
         }
      }
   } 
d793 5
d808 5
a812 1
      
d816 2
a817 2
     unless ((state & RmS_Booting) && (state & RmS_ShouldBeReset) &&
     	     !(state & RmS_Running))
d819 1
d828 1
a828 2
        unless((purpose eq RmP_Helios) || (purpose eq RmP_System))
         continue;
d831 1
a831 2
        unless ( (state  & RmS_Running) || 
        	((state & RmS_Booting) && !(state & RmS_ShouldBeReset)))
d833 1
d835 8
a842 3
	if (flags & RmF_Suspicious) 
	 suspicious = neighbour;
        goto found;        
d845 14
d860 3
a862 1
   return(suspicious);
d898 1
d908 1
a908 1
  if (!Fork(1000, &continue_boot, 8, job, next))
d930 4
d944 6
a972 1
		/* BLV - this does not work when processors get rebooted*/
a1000 7
		/* attempt the actual bootstrap.			*/
     unless(StartNetworkAgent(current))
      {	/* %&$*~"! How am I meant to recover from this */
        its_proc_entry->BeingBooted = FALSE;
        Signal(&(job->ProcessesFinished));
       	return;
      }        
a1001 1
     StopNetworkAgent(current);
d1009 3
a1011 1
        if (Fork(1000, &continue_boot, 8, job, next))
d1021 2
d1024 2
a1049 1
  ProcessorEntry	*my_proc_entry;
a1054 1
  bool    		netagent_locked = FALSE;
d1062 6
d1075 3
a1077 1
     if (hardware->Type ne RmH_ResetDriver) continue;
d1112 1
a1112 1
  TryToReset(target);     
d1121 1
a1122 4
    my_proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(start);
    Wait(&(my_proc_entry->NetagentLock));
    netagent_locked = TRUE;

d1127 2
a1128 3
    if (Write(my_proc_entry->NetagentPipe, (BYTE *) &message, 
    		sizeof(NA_Message), 5 * OneSec) ne sizeof(NA_Message))
     { MarkProcessor(start); goto fail; }
d1130 3
a1132 3
    if (Write(my_proc_entry->NetagentPipe, (BYTE *) config,
    		confsize, 5 * OneSec) ne confsize)
     { MarkProcessor(start); goto fail; }
a1133 4
    if (Read(my_proc_entry->NetagentPipe, (BYTE *) &reply, sizeof(WORD),
    		5 * OneSec) ne sizeof(WORD))
     { MarkProcessor(start); goto fail; }

d1142 8
a1149 2
  Signal(&(my_proc_entry->NetagentLock));
  netagent_locked = FALSE;
d1152 1
a1152 2
  (void) RmSetProcessorState(target, RmS_Running | RmS_Booting);
  result = InitProcessor(target);
d1154 1
d1159 1
d1161 2
a1166 1
  if (netagent_locked) Signal(&(my_proc_entry->NetagentLock));
d1181 1
a1181 1
static const char	*default_nucleus(RmProcessor Processor)
d1202 3
a1204 3
{ const char		*nucleus_string = "";
  const char		*source_nuc	= RmGetProcessorNucleus(source);
  const char		*dest_nuc	= RmGetProcessorNucleus(dest);  
d1215 1
a1215 1
  if (source_nuc ne Null(const char))
d1217 1
a1217 1
    source_nuc = Null(const char);
d1219 1
a1219 1
  if (dest_nuc ne Null(const char))
d1221 1
a1221 1
    dest_nuc = Null(const char);
d1223 1
a1223 1
  if ((source_nuc eq Null(const char)) && (dest_nuc ne Null(const char)))
d1226 1
a1226 1
  if ((source_nuc ne Null(const char)) && (dest_nuc eq Null(const char)))
d1229 1
a1229 1
  if ((source_nuc ne Null(const char)) && (dest_nuc ne Null(const char)))
d1240 1
a1240 1
  if (nucleus_string eq Null(const char))
a1331 16
*** On a newly-booted processor all the old capabilities are invalid.
*** Also, it may be necessary to run a command on the target processor.
**/
static bool InitProcessor(RmProcessor processor)
{ ProcessorEntry	*proc_entry;

  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(processor);
  memset((void *) &(proc_entry->Owner), 0, 2 * sizeof(Capability));

  unless(SilentMode)
   report("processor %s booted.", processor->ObjNode.Name);

  return(TRUE);
}

/**
d1336 1
a1336 3
*** 1) start the network agent on the target processor. This may
***    be a no-op if the agent is already running.
*** 2) get exclusive access to the agent.
a1349 2
               
  if (!StartNetworkAgent(Processor)) return;
d1351 2
a1355 3
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
  Wait(&(proc_entry->NetagentLock));

d1357 1
a1357 7
  message.Arg1 = ProtectionMatrix;     
  if (Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
     	       5 * OneSec) ne sizeof(NA_Message))
   { MarkProcessor(Processor); goto done; }
  if (Write(proc_entry->NetagentPipe, (BYTE *) &(proc_entry->Full),
  	 sizeof(Capability), 5 * OneSec) ne sizeof(Capability))
   { MarkProcessor(Processor); goto done; }
d1359 5
a1363 7
	/* Get the first reply, an error code */
  if (Read(proc_entry->NetagentPipe, (BYTE *) &rc,
     		sizeof(WORD), 5 * OneSec) ne sizeof(WORD))
   { MarkProcessor(Processor);
     memset((void *) &(proc_entry->Owner), 0, 3 * sizeof(Capability));
     goto done;
   }
a1366 5
     goto done;
   }
  if (Read(proc_entry->NetagentPipe, (BYTE *) &(proc_entry->Owner),
     	      3 * sizeof(Capability), 5 * OneSec) ne (3 * sizeof(Capability)))
   { MarkProcessor(Processor);
d1369 5
a1373 7
  memcpy(&(Processor->RealCap), &(proc_entry->Full), sizeof(Capability));
  memcpy(&(Processor->ReadOnlyCap), &(proc_entry->General), 
     		sizeof(Capability));
     
done:
  Signal(&(proc_entry->NetagentLock));
  StopNetworkAgent(Processor);
d1422 1
a1422 1
     case	805	: 
d1424 1
a1424 1
			  real_type = RmT_T800; break;
a1476 1
     ProcessorEntry	*proc_entry;
d1483 2
d1499 4
a1502 2
      { Neighbour = RmFollowLink(Processor, link, &destlink);

d1511 2
a1512 1
        if (RmGetProcessorPurpose(Neighbour) eq RmP_Native)
d1515 2
d1518 1
a1518 1
        if (RmGetProcessorPurpose(Neighbour) eq RmP_IO)
d1559 2
a1560 6
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
     Wait(&(proc_entry->NetagentLock));
     (void) Write(proc_entry->NetagentPipe, (BYTE *) &message,
			   sizeof(NA_Message), 5 * OneSec);
     (void) Write(proc_entry->NetagentPipe, link_modes, number_links,
     		 	5 * OneSec);
d1564 1
a1564 3
     (void) Write(proc_entry->NetagentPipe, (BYTE *) &message,
     	 sizeof(NA_Message), 5 * OneSec);
     (void) Read(proc_entry->NetagentPipe, (BYTE *) &j, sizeof(word), 5 * OneSec);
a1565 1
     Signal(&(proc_entry->NetagentLock));
d1637 1
d1641 8
a1648 5
         { NA_Message	message;
           Debug(dbg_Execute, ("killing network agent on %s",\
           	proc_entry->Processor->ObjNode.Name));
           message.FnRc	= NA_Quit;
           (void) Write(proc_entry->NetagentPipe, (BYTE *) &message, 
d1650 4
a1653 2
           (void) Close(proc_entry->NetagentPipe);
           proc_entry->NetagentPipe = Null(Stream);
d1655 1
d1688 1
d1690 1
d1729 1
d1731 1
a1731 1
  
d1733 1
a1733 1
   { MarkProcessor(processor);
d1735 2
d1744 8
a1751 4
  Wait(&NetagentStructLock);
  AddTail(&NetagentList, &(proc_entry->NetagentNode));
  Signal(&NetagentStructLock);
  Signal(&NetagentQueueCount);
a1753 1
  Debug(dbg_Execute, ("network agent now running on %s", processor->ObjNode.Name));
d1756 2
a1757 1
   { proc_entry->NetagentCount++;
d1761 1
d1783 53
d1865 1
a1865 1
  	code->Name, processor->ObjNode.Name));
d1892 2
a1893 2
  Debug(dbg_Execute, ("rexec for program %s on %s done", \
  	code->Name, processor->ObjNode.Name));
d1941 1
a1941 1
  if (number_args < 7)		/* allow for terminator */
d1992 2
a1993 2
     name = (RmIsNetwork(Processor)) ? RmGetNetworkID((RmNetwork) Processor) :
     			Processor->ObjNode.Name;
d2029 3
a2031 4
void	HandleGetLinkMode(NsConn Connection, int JobId, int request)
{ Stream		*Pipe = Connection->Pipe;
  LinkDetails		details;
  RmProcessor		processor;
a2033 1
  ProcessorEntry    	*proc_entry;
d2035 1
a2035 5
  bool			agent_locked	= FALSE;
    
  if (FullRead(Pipe, (BYTE *) &details, sizeof(LinkDetails), -1) ne
  	sizeof(LinkDetails))
   return;
d2037 1
d2039 1
a2039 2
  
  processor = (RmProcessor) RmFindUid((RmSet) Net, details.Uid);
d2042 1
a2042 2
  if ((RmGetProcessorPurpose(processor) ne RmP_Helios) &&
      (RmGetProcessorPurpose(processor) ne RmP_System))
a2044 1
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(processor);
a2048 3
  Wait(&(proc_entry->NetagentLock));
  agent_locked = TRUE;

d2050 3
a2052 4
  message.Arg1	= details.Link;  
  if (Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
  	5 * OneSec) ne sizeof(NA_Message))
   { MarkProcessor(processor); goto done; }
a2053 16
  if (Read(proc_entry->NetagentPipe, (BYTE *) &rc, sizeof(int), 5 * OneSec) ne
  		sizeof(int))
   { MarkProcessor(processor); 
     rc = RmE_CommsBreakdown;
     goto done; 
   }
  if (rc eq RmE_Success)
   if (Read(proc_entry->NetagentPipe, (BYTE *) &(details.Mode), sizeof(int),
  		5 * OneSec) ne sizeof(int))
   { MarkProcessor(processor); 
     rc = RmE_CommsBreakdown;
     goto done; 
   }

  rc = RmE_Success;

a2055 1
  if (agent_locked) Signal(&(proc_entry->NetagentLock));
d2057 3
a2059 6
  (void) Write(Pipe, (BYTE *) &JobId, sizeof(int), -1);
  (void) Write(Pipe, (BYTE *) &rc, sizeof(int), -1);
  if (rc eq RmE_Success)  
   (void) Write(Pipe, (BYTE *) &(details.Mode), sizeof(int), -1);
  Signal(&(Connection->WriteLock));
  request = request;
d2062 3
a2064 4
void	HandleSetLinkMode(NsConn Connection, int JobId, int request)
{ Stream		*Pipe = Connection->Pipe;
  LinkDetails		details;
  RmProcessor		processor;
d2067 2
a2068 3
  if (FullRead(Pipe, (BYTE *) &details, sizeof(LinkDetails), -1) ne
  	sizeof(LinkDetails))
   return;
a2069 2
  Signal(&(SingleStep));
  processor = (RmProcessor) RmFindUid((RmSet) Net, details.Uid);
d2072 1
a2072 2
  if ((RmGetProcessorPurpose(processor) ne RmP_Helios) &&
      (RmGetProcessorPurpose(processor) ne RmP_System))
d2075 1
a2075 1
  rc = SetLinkMode(processor, details.Link, details.Mode);
d2079 2
a2080 4
  (void) Write(Pipe, (BYTE *) &JobId, sizeof(int), -1);
  (void) Write(Pipe, (BYTE *) &rc, sizeof(int), -1);
  Signal(&(Connection->WriteLock));
  request = request;
d2088 1
a2088 2
{ ProcessorEntry	*proc_entry;
  int			rc = RmE_Success;
a2090 1
  bool			agent_locked	= FALSE;
a2091 1
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(processor);
a2095 2
  Wait(&(proc_entry->NetagentLock));
  agent_locked = TRUE;
d2100 1
a2100 4
  if (Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
  	5 * OneSec) ne sizeof(NA_Message))
   { MarkProcessor(processor); goto done; }
  rc = RmE_Success;
a2102 1
  if (agent_locked) Signal(&(proc_entry->NetagentLock));
d2107 8
d2116 1
a2116 2
{ ProcessorEntry	*proc_entry;
  int			rc;
d2119 6
a2124 1
  bool			agent_locked	= FALSE;
d2126 37
d2166 2
a2167 1
  
d2170 7
d2178 1
a2178 6
  message.FnRc	= NA_ClearNames;
  (void) Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
  	5 * OneSec);
  (void) Read(proc_entry->NetagentPipe, (BYTE *) &rc, sizeof(WORD), 5 * OneSec);

done:  
a2179 1
  if (agent_started) StopNetworkAgent(Processor);
d2181 2
@


1.14
log
@Improved the routine NetMapProcessorToObject() to use the PUID
attribute held with every processor, rather than build the name
by walking back up the directory tree.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.13 1991/06/03 13:46:15 bart Exp $";
d1339 3
a1341 1
     case	805	: real_type = RmT_T800; break;
@


1.13
log
@Improved some of the debugging messages to show the processor affected.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.12 1991/05/18 12:12:45 bart Exp $";
d1847 1
a1847 1
{ char		*buf = (char *) Malloc(IOCDataMax);
a1850 3
  if (buf eq Null(char)) return(Null(Object));
  (void) BuildName(buf, Processor);
		
a1867 1
  Free(buf);
@


1.12
log
@corrected an error message which used an integer instead of a string.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netboot.c,v 1.11 1991/02/27 16:33:04 bart Exp bart $";
d1338 2
a1339 1
   { case	800	: real_type = RmT_T800; break;
d1557 2
a1558 1
           Debug(dbg_Execute, ("killing network agent"));
d1654 1
a1654 1
  Debug(dbg_Execute, ("network agent now running"));
d1710 2
a1711 1
  Debug(dbg_Execute, ("rexec, program is now running"));
d1738 2
a1739 1
  Debug(dbg_Execute, ("rexec done"));
@


1.11
log
@memory corruption bug in rexec_task(), if given eight arguments
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /giga/Helios/network/RCS/netboot.c,v 1.10 90/12/17 14:27:12 bart Exp Locker: bart $";
d1344 1
a1344 1
     			stats->Type);
@


1.10
log
@some changes to the error recovery code, when partial bootstrap failures occur.
This code is going to need a lot more attention.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netboot.c,v 1.9 90/12/01 15:33:11 bart Exp $";
d1783 1
a1783 1
  if (number_args < 8)
d1786 1
a1786 1
   { env->Argv = (char **) Malloc(number_args * sizeof(char *));
d1802 1
a1802 1
   if (number_args >= 8)
@


1.9
log
@added a clearnames() routine, and debugged the code coping with different
nuclei.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netboot.c,v 1.7 90/11/01 16:34:34 bart Exp $";
d727 2
a728 1
    
a749 1

d751 2
a752 2
	if (flags & RmF_Suspicious) continue;
	
d756 4
a759 1
  return((RmProcessor) NULL);
d887 6
a892 1
     unless(StartNetworkAgent(current)) break;
d949 3
@


1.8
log
@programs specified in the resource map are now started automatically.
Reset commands are supported.
@
text
@d243 6
a248 1
   { result = TRUE; Free(job); goto done; }
a344 1

d384 4
a387 1
      if (neighbour ne RmM_ExternalProcessor) continue;
d390 1
a390 1
      message.Arg2 = RmL_Pending;
d1027 2
a1028 1
  
d1033 2
d1084 9
a1092 1
  
d1107 1
a1107 2
   goto done_nuc;
  nucleus_string = dest_nuc;
d1467 2
a1468 1
           				
d1838 1
a1838 1

d1840 1
a1840 1
  if (*((word *) Cap) eq 0)
d1844 1
a1844 1

d1848 1
d1862 1
d1878 2
d1918 1
d1939 1
d1950 1
d1990 23
@


1.7
log
@more header file problems
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netboot.c,v 1.6 90/11/01 14:50:54 bart Exp Locker: bart $";
d61 1
d63 1
d108 1
a108 1
  UpdateProcessor(RootProcessor);
d110 1
a110 1
   UpdateIOProcessor(BootIOProcessor);
d284 1
a284 1
void UpdateProcessor(RmProcessor Processor)
d340 3
d389 2
a390 1
    
d401 1
a401 1
void UpdateIOProcessor(RmProcessor Processor)
d473 4
a476 1
  
d609 2
d623 1
a623 3
       {
	/* BLV - implement */
       }
d653 50
d871 1
a871 1

d897 1
a900 1

a1363 1
     ProcessorEntry	*neighbour_proc_entry;
d1390 1
d1392 1
a1392 1
         { mode = RmL_Pending; goto set_link; }
d1397 4
d1424 1
a1424 13
        link_modes[link] = RmL_Intelligent;
        neighbour_proc_entry = (ProcessorEntry *) 
          RmGetProcessorPrivate(Neighbour);
        unless(StartNetworkAgent(Neighbour)) continue;
        Wait(&(neighbour_proc_entry->NetagentLock));
        message.FnRc	= NA_SetLinkMode;
        message.Arg1	= destlink;
        message.Arg2	= RmL_Pending;
        if (Write(neighbour_proc_entry->NetagentPipe, (BYTE *) &message,
        	sizeof(NA_Message), 5 * OneSec) ne sizeof(NA_Message))
         { MarkProcessor(Neighbour); continue; }
	Signal(&(neighbour_proc_entry->NetagentLock));
        StopNetworkAgent(Neighbour);
d1456 33
a1488 1
     
d1723 57
d1911 1
a1911 5
  NA_Message		message;
  ProcessorEntry    	*proc_entry;
  bool			agent_started	= FALSE;
  bool			agent_locked	= FALSE;
    
d1923 20
d1946 1
a1946 1
  agent_started = TRUE;
a1949 1
  
d1951 3
a1953 3
  message.Arg1	= details.Link;  
  message.Arg2	= details.Mode;
  
d1958 1
a1958 1
  
d1962 1
a1962 4
  (void) Write(Pipe, (BYTE *) &JobId, sizeof(int), -1);
  (void) Write(Pipe, (BYTE *) &rc, sizeof(int), -1);
  Signal(&(Connection->WriteLock));
  request = request;
a1963 1

@


1.6
log
@sources update after visit to Parsytec 22.10.90-31.10.90
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netboot.c,v 1.1 90/09/12 14:37:05 jon Exp $";
d25 3
@


1.5
log
@NHG has been fiddling with the header files
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netboot.c,v 1.4 90/10/18 13:26:05 bart Exp Locker: bart $";
a32 2
#include <root.h>
#include <link.h>
d94 1
a94 1
  Debug(dbg_Boot, ("root processor is %s", RmGetProcessorID(RootProcessor)));
d100 1
a100 1
     Debug(dbg_Boot, ("boot I/O processor is %s", RmGetProcessorID(BootIOProcessor)));
d128 2
d176 2
a177 1

d179 1
d187 2
d197 1
d233 3
a248 1
  unless(result) Signal(&(job->Lock));
d253 9
d272 1
a272 1
***    sizes are checked.
d288 4
a292 2
  Debug(dbg_Boot, ("updating processor %s", RmGetProcessorID(Processor)));

d304 1
a304 1
   		 RmGetProcessorID(Processor));
d333 1
a333 1
   		RmGetProcessorID(Processor), rc);
d354 1
a354 1
		RmGetProcessorID(Processor), rc);
d365 11
d377 5
d405 1
a405 1
  Debug(dbg_Boot, ("updating I/O processor %s", RmGetProcessorID(Processor)));
d412 1
a412 1
   		RmGetProcessorID(Processor));
d419 1
a419 1
   		RmGetProcessorID(Processor));
d423 1
a423 1
  Debug(dbg_Boot, ("I/O processor's neighbour is %s", RmGetProcessorID(neighbour)));
d463 1
a463 1
   	RmGetProcessorID(Processor), rc);
d495 5
a499 6
static RmProcessor find_starting_place(BootstrapJob *job, int *destlink);
static int actual_boot(BootstrapJob *job, RmProcessor, int link);
static void do_protection(BootstrapJob *job);
static void do_checks(BootstrapJob *job);
static void do_connections(BootstrapJob *job);
static void do_clearnames(BootstrapJob *job);
d532 1
a532 1
     		RmGetProcessorID(start)));
a540 4
  Debug(dbg_Boot, ("bootstrap, setting up processor protection"));  
  do_protection(job);
  Debug(dbg_Boot, ("bootstrap, checking processor details"));
  do_checks(job);
a542 2
  Debug(dbg_Boot, ("bootstrap, clearing out the name tables"));
  do_clearnames(job);
d555 1
a555 1
         report("failed to boot processor %s", RmGetProcessorID(Processor));
d564 4
d570 2
d657 2
a658 1
  
d681 3
d704 4
a707 6
*** 1) attempt to boot another processor in the boot job using a
***    processor known to be running. If successful, put the newly booted
***    processor into the progress table.
*** 2) if there is nothing left to boot, return
*** 3) use every processor currently in the progress table to attempt
***    to boot more processors in the same job.
d715 3
a717 3
  int		booted = 0;
  int		i, j, k;

a724 1
  booted = 0;
a725 1
  booted++;
d727 46
a772 1
  if (job->Next eq job->NumberProcessors) return(booted);
d774 3
a776 4
  for (i = 0; i < job->Next; i++)
   { RmProcessor current	= progress[i];
     int	 linkcount	= RmCountLinks(current);
     int	 state;
a777 10
     state = RmGetProcessorState(current);
     unless (state & RmS_Running) continue;
          
     for (j = 0; j < linkcount; j++)
      { next = RmFollowLink(current, j, &destlink);
        if ((next eq RmM_NoProcessor) || (next eq RmM_ExternalProcessor))
         continue;
        state = RmGetProcessorState(next);
        unless((state & RmS_Booting) && !(state & RmS_Running)) continue;

d786 19
a804 12
        if (RmParentNetwork(current) ne RmParentNetwork(next))
         { RmNetwork	parent = RmParentNetwork(next);
	   bool		first_in_subnet = TRUE;
           for (k = i+1; k < job->Next; k++)
            if (parent eq RmParentNetwork(job->Table[k]))
             { first_in_subnet = FALSE; break; }
           unless(first_in_subnet) continue;
         }
           
        for (k = 0; k < job->NumberProcessors; k++)
         if (next eq job->Table[k])
          { bool temp;
d806 3
a808 13
            unless(StartNetworkAgent(current)) break;
            temp = boot_down_link(current, j);
            StopNetworkAgent(current);

            if (temp)
             { progress[job->Next++] = next;
               booted++;
               if (job->Next eq job->NumberProcessors) return(booted);
             }
            break;
          }
      }
   }
d810 26
a835 1
  return(booted);   
d838 1
d887 1
d908 1
a908 1
	       RmGetProcessorID(target), RmT_Names[RmGetProcessorType(target)]);
d917 1
a917 1
     		RmGetProcessorID(target));
d945 1
a945 1
     		RmGetProcessorID(target), link, RmGetProcessorID(start));
d960 3
d1033 1
a1033 1
   		RmGetProcessorID(dest));
d1133 1
a1133 1
   report("processor %s booted.", RmGetProcessorID(processor));
d1155 4
a1158 8
static void do_protection(BootstrapJob *job)
{ int	i;

  for (i = 0; i < job->Next; i++)
   { RmProcessor	Processor = job->Progress[i];
     ProcessorEntry	*proc_entry;
     NA_Message		message;
     WORD		rc;
d1160 1
a1160 1
     if (!StartNetworkAgent(Processor)) continue;
d1162 2
a1163 2
     Debug(dbg_Boot, ("setting protection on processor %s",\
     	RmGetProcessorID(Processor)));
d1165 2
a1166 2
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
     Wait(&(proc_entry->NetagentLock));
d1168 3
a1170 3
     message.FnRc = NA_Protect;
     message.Arg1 = ProtectionMatrix;     
     if (Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
d1172 4
a1175 4
      { MarkProcessor(Processor); goto loop; }
     if (Write(proc_entry->NetagentPipe, (BYTE *) &(proc_entry->Full),
     	 sizeof(Capability), 5 * OneSec) ne sizeof(Capability))
      { MarkProcessor(Processor); goto loop; }
d1178 1
a1178 1
     if (Read(proc_entry->NetagentPipe, (BYTE *) &rc,
d1180 10
a1189 10
      { MarkProcessor(Processor);
        memset((void *) &(proc_entry->Owner), 0, 3 * sizeof(Capability));
	goto loop;
      }
     if (rc ne Err_Null)
      { report("warning, failed to set protection on processor %s, fault %x",
      		RmGetProcessorID(Processor), rc);
      	goto loop;
      }
     if (Read(proc_entry->NetagentPipe, (BYTE *) &(proc_entry->Owner),
d1191 5
a1195 5
      { MarkProcessor(Processor);
        memset((void *) &(proc_entry->Owner), 0, 3 * sizeof(Capability));
      }
     memcpy(&(Processor->RealCap), &(proc_entry->Full), sizeof(Capability));
     memcpy(&(Processor->ReadOnlyCap), &(proc_entry->General), 
d1198 3
a1200 4
loop:
     Signal(&(proc_entry->NetagentLock));
     StopNetworkAgent(Processor);
   }
d1204 1
a1204 1
*** do_checks(). Check out some of the details in the resource map. In
a1206 2
static void do_checks(BootstrapJob *job)
{ int	i;
a1207 4
  for (i = 0; i < job->Next; i++)
   ValidateProcessorDetails(job->Progress[i]);
}

d1227 1
a1227 1
   		Result2(real_processor), RmGetProcessorID(Processor));
d1263 1
a1263 1
       RmGetProcessorID(Processor), RmT_Names[real_type], RmT_Names[proc_type]);
d1292 1
a1292 1
  for (i = 0; i < job->Next; i++)
d1349 1
a1349 1
        for (j = 0; j < i; j++)
d1353 1
a1353 1
        for (j = i+1; j < job->Next; j++)
d1377 1
a1377 1
		RmGetProcessorID(Processor), link, mode));
d1391 6
a1401 25

/**
*** do_clearnames(). For every processor that has been booted, in reverse
*** order, send a clear-name request to the network agent on that processor.
*** There is a single word reply, mostly for synchronisation.
BLV
BLV the current processor manager does not seem to require a capability
BLV for this operation (pm_private, FG_Reconfigure). This seems dubious
**/
static void do_clearnames(BootstrapJob *job)
{ int	i;

  for (i = (job->Next - 1); i >=0 ; i--)
   { RmProcessor	Processor = job->Progress[i];
     int		state     = RmGetProcessorState(Processor);
     ProcessorEntry	*proc_entry;
     NA_Message		message;
     int		rc;
          
     unless(state & RmS_Running) continue;
     
     unless(StartNetworkAgent(Processor))
      { MarkProcessor(Processor); continue; }

     Debug(dbg_Boot, ("clearing names in processor %s", RmGetProcessorID(Processor)));
a1402 14
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
     Wait(&(proc_entry->NetagentLock));
     message.FnRc = NA_ClearNames;
     if (Write(proc_entry->NetagentPipe, (BYTE *) &message, sizeof(NA_Message),
     	  5 * OneSec) ne sizeof(NA_Message))
      MarkProcessor(Processor);
     elif (Read(proc_entry->NetagentPipe, (BYTE *) &rc, sizeof(WORD), 5 * OneSec)
         ne sizeof(WORD))
      MarkProcessor(Processor);
     Signal(&(proc_entry->NetagentLock));
     StopNetworkAgent(Processor);
   }
}
     
d1476 1
a1476 1
  Debug(dbg_Execute, ("starting network agent on %s", RmGetProcessorID(processor)));
d1526 1
a1526 1
		RmGetProcessorID(processor), rc);
d1554 1
a1554 1
  Debug(dbg_Execute, ("stopping network agent on processor %s", RmGetProcessorID(processor)));
d1577 1
a1577 1
  	RmGetProcessorID(processor)));
d1663 1
a1663 1
     			RmGetProcessorID(Processor);
d1697 113
@


1.4
log
@minor bug fixes in time for Helios 1.2 beta1 release
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netboot.c,v 1.1 90/09/12 14:37:05 jon Exp $";
d33 2
@


1.3
log
@preparing beta1 release before holiday
@
text
@d107 16
@


1.2
log
@Plugged various memory leaks
@
text
@d1528 1
a1528 1
   { prog_stream = Open(program, Null(char), O_Execute);
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char *rcsid = "$Header$";
d1564 1
a1564 1
  if (procman ne Null(Object))	Close(proc);
@
