head	1.7;
access;
symbols
	Helios_C40_1_3_Official_Release:1.5
	Alenia_release:1.5
	Helios1_3:1.5
	C40_Field_Test_2:1.5
	C40_Field_Test_R1:1.3
	Helios13_beta:1.3
	Helios1_2_2_Fault:1.1;
locks; strict;
comment	@ * @;


1.7
date	93.12.20.13.35.00;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	93.08.12.14.21.08;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	92.09.30.16.02.45;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	92.07.21.11.04.51;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	92.04.24.15.47.49;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	92.03.25.18.03.41;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	92.01.15.11.07.10;	author bart;	state Exp;
branches;
next	;


desc
@The mapping routines contained in the TFM
@


1.7
log
@fixed compile time warnings (ARM world)
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- tfmmap.c								--
--                                                                      --
--	This module of the Taskforce Manager deals with mapping		--
--	taskforces onto the available processors.			--
--                                                                      --
--	Author:  BLV 4/9/90						--
--                                                                      --
------------------------------------------------------------------------*/
/*$Header: /hsrc/network/RCS/tfmmap.c,v 1.6 1993/08/12 14:21:08 nickc Exp nickc $*/

/*{{{  headers */
#include <stdio.h>
#include <syslib.h>
#include <servlib.h>
#include <sem.h>
#include <codes.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <posix.h>
#include <ctype.h>
#include <nonansi.h>
#include <attrib.h>
#include <pwd.h>
#include <signal.h>
#include <module.h>
#include "exports.h"
#include "private.h"
#include "netutils.h"
#include "rmlib.h"
#include "tfmaux.h"
/*}}}*/
/*{{{  statics and module initialisation */
static int	AllocationId;
static void	SortDomain(RmNetwork);

void InitMap(void)
{ AllocationId = 1;
}
/*}}}*/
/*{{{  HandleObtainProcessor() */

/**----------------------------------------------------------------------------
*** ObtainProcessor(). This is where the fun starts.
***
*** 1) housekeeping, read the processor template from the client, allocate
***    any buffers required, check that the client is authorised to obtain
***    processors inside this TFM...
*** 2) if the request is for an existing processor, then this may or may
***    not be inside the current domain. If it is fine. Otherwise an
***    attempt is made to get the specified processor from the system pool.
*** 3) if the request contains a puid attribute life is much the same as
***    in step 2.
*** 4) an initial search is made in the domain to find a processor that
***    may be suitable. This search is quite restrictive. However, the
***    best match to date is remembered (this may be null for a weird request)
*** 5) if the search is unsuccessful an attempt is made to get another
***    processor from the system pool. If that succeeds fine.
*** 6) otherwise if the search revealed any suitable processor at all,
***    that processor is used. If the domain does not contain a suitable
***    processor and the system pool could not provide one, tough.
**/
static int		ObtainProcessor_filter(RmProcessor, RmProcessor);
static RmProcessor	GetFromPool(RmProcessor Template, int *rc);
static int		ObtainProcessorSearch(RmProcessor, ...);

void HandleObtainProcessor(TfmConn Connection, int JobId,
		RmRequest *request, RmReply *reply)
{ RmProcessor		Template	= (RmProcessor) NULL;
  RmProcessor		result		= (RmProcessor) NULL;
  RmFilterStruct	filter;
  DomainEntry		*domain_entry;
  int			rc;
  int			i;
  RmProcessor		LeastBusy;
  int			LowestCost;

  Debug(dbg_Allocate, ("request for a single processor"));
           
  Template = request->Processor;

  if (Template->StructType eq RmL_Existing)
   { 
     Debug(dbg_Allocate, ("request is for an existing processor"));
     result = RmFindProcessor(Domain, Template->Uid);
     if ((result eq RmM_NoProcessor) || (result eq RmM_ExternalProcessor))
      if (!DomainLocked)
       if ((result = GetFromPool(Template, &rc)) eq (RmProcessor)NULL)
        goto done;

     goto found;
   }

  { char *puid = RmGetObjectAttribute((RmObject) Template, "puid", FALSE);
    
    if (puid ne Null(char))
     { Debug(dbg_Allocate, ("puid has been specified"));
       result = RmLookupProcessor(Domain, puid);
       if (result eq (RmProcessor)NULL)
        if (!DomainLocked)
         if ((result = GetFromPool(Template, &rc)) eq (RmProcessor) NULL)
          { rc = RmE_NotFound; goto done; }
       goto found;
     }
  }

	/* No particular processor is required. Perform a search of the	*/
	/* current domain.						*/
   LeastBusy	= (RmProcessor) NULL;
   LowestCost	= (int) MaxInt;
   Debug(dbg_Allocate, ("searching current domain for a free processor"));

   result = (RmProcessor) RmSearchProcessors(Domain, &ObtainProcessorSearch,
   		Template, &LeastBusy, &LowestCost);
   if (result ne (RmProcessor) NULL) goto found;

   if (!DomainLocked)
    { result = GetFromPool(Template, &rc);
      if (result ne (RmProcessor) NULL) goto found;
    }
    
   if (LeastBusy eq (RmProcessor) NULL) goto done;
   Debug(dbg_Allocate, ("making do with an existing processor"));
   result = LeastBusy;
        
	/* At this point, result should point to a valid processor	*/
	/* that meets the user's requirements. This does not mean	*/
	/* it is safe to allocate...					*/
	/* BLV - check processor purpose as well */
found:

  Debug(dbg_Allocate, ("selected processor %P", result));

  domain_entry = GetDomainEntry(result);
  if (domain_entry->NumberUsers >= MaxUsersPerProcessor)
   { rc = RmE_InUse; goto done; }
  if ((result->AllocationFlags & RmF_Exclusive) &&
      (domain_entry->NumberUsers > 0))
   { rc = RmE_InUse; goto done; }
  for (i = 0; i < MaxUsersPerProcessor; i++)
   if (domain_entry->AllocationTable[i].Connection eq Connection)
    { rc = RmE_InUse; goto done; }
  for (i = 0; i < MaxUsersPerProcessor; i++)    
   if (domain_entry->AllocationTable[i].Id eq 0)
    { domain_entry->AllocationTable[i].Id		= AllocationId++;
      domain_entry->AllocationTable[i].Connection	= Connection;
      AddTail(	&(Connection->Processors),
      		&(domain_entry->AllocationTable[i].Node));
      break;
    }

  Debug(dbg_Allocate, ("successfully obtained a processor"));
  rc = RmE_Success;
  domain_entry->NumberUsers++;
  if (Template->AllocationFlags & RmF_Exclusive)
   { result->AllocationFlags	|= RmF_Exclusive;
     result->ApplicationId 	 = Connection->Id;
   }
  else
   result->ApplicationId	= -1;

  LastChange = result->ObjNode.Dates.Access = GetDate();
  
done:
  reply->FnRc = rc;
  if (rc eq RmE_Success)
   { filter.Processor	= &ObtainProcessor_filter;
     reply->Filter	= &filter;     
     reply->Processor	= result;
   }
  (void) ReplyRmLib(Connection, JobId, reply);
}

static	int	ObtainProcessor_filter(RmProcessor real, RmProcessor copy)
{ DomainEntry	*domain_entry;

  domain_entry = GetDomainEntry(real);
  copy->ObjNode.Key	= 0;
  copy->ObjNode.Parent	= Null(DirNode);
  copy->Root		= (RmNetwork) NULL;
  copy->StructType	= RmL_Obtained;
  NewCap(&(copy->NsCap), &(real->ObjNode), AccMask_R + AccMask_W + AccMask_D);
  copy->Private		= 0;
  return(RmE_Success);
}

static	int	ObtainProcessorSearch(RmProcessor Processor, ...)
{ va_list	args;
  RmProcessor	Template;
  DomainEntry	*domain_entry;
  RmProcessor	*LeastBusy;
  int		*LowestCost;
  int		cost_factor;
    
  va_start(args, Processor);
  Template	= va_arg(args, RmProcessor);
  LeastBusy	= va_arg(args, RmProcessor *);
  LowestCost	= va_arg(args, int *);
  va_end(args);
  
	/* Booked access means that the processor cannot be allocated	 */
	/* to meet an arbitrary request.				 */
  if (Processor->AllocationFlags & RmF_Booked) return(0);

	/* If the processor does not match the Template's requirements	*/
	/* forget it							*/  
  unless(MatchProcessor(Processor, Template)) return(0);

      	/* This processor appears to stand a chance. If the number of	*/
      	/* users is currently zero than this processor is ideal.	*/
  domain_entry = GetDomainEntry(Processor);
  if (domain_entry->NumberUsers eq 0) return((int) Processor);

 	/* If the number of users is greater than zero than it is	*/
 	/* necessary to calculate a cost factor for using this processor*/
 	/* This equation may need fine-tuning.				*/
  cost_factor = domain_entry->NumberUsers;
  if (RmGetProcessorMemory(Processor) > 0x100000) cost_factor--;
  if (cost_factor < *LowestCost)
   { *LeastBusy		= Processor;
     *LowestCost	= cost_factor;
   }

	/* However, this processor is not ideal and there may be a	*/
	/* better one.							*/
  return(0);
}

/*}}}*/
/*{{{  HandleReleaseProcessor() */
/**----------------------------------------------------------------------------
*** ReleaseProcessor(). A single set of Processor details will be sent.
*** If valid, the number of users for that processor is decremented and
*** the slot in the DomainEntry structure will be released. If the number
*** of users has decremented to zero then the processor may be returned to
*** the system pool.
**/
void HandleReleaseProcessor(TfmConn Connection, int JobId,
		RmRequest *request, RmReply *reply)
{ RmProcessor		Processor;
  DomainEntry		*domain_entry;
  int			rc;
  int			i;

  Debug(dbg_Release, ("release-processor request"));
    
  Processor = RmFindProcessor(Domain, request->Uid);
  if ((Processor eq RmM_NoProcessor) || (Processor eq RmM_ExternalProcessor))
   { rc = RmE_NotFound; goto done; }

  Debug(dbg_Release, ("processor affected is %P", Processor));
  unless(GetAccess(&(request->Cap), Processor->ObjNode.Key) &&
         (request->Cap.Access & AccMask_D))
   { rc = RmE_NoAccess; goto done; }

  LastChange = Processor->ObjNode.Dates.Access = GetDate();
  /* Processor->ApplicationId	= -1;*/
  
  domain_entry = GetDomainEntry(Processor);
  for (i = 0; i < MaxUsersPerProcessor; i++)
   if (domain_entry->AllocationTable[i].Connection eq Connection)
    { domain_entry->AllocationTable[i].Connection = (TfmConn) NULL;
      domain_entry->AllocationTable[i].Id	  = 0;
      Remove(&(domain_entry->AllocationTable[i].Node));
      break;
    }
  domain_entry->NumberUsers--;
  if (domain_entry->NumberUsers eq 0)
   { if ((Processor->AllocationFlags & (RmF_Permanent | RmF_TfmProcessor)) eq 0)
      ReturnProcessorToPool(Processor);
     else
      Processor->AllocationFlags &= ~RmF_Exclusive;
   }
  
  rc = RmE_Success;
         
done:
  reply->FnRc	= rc;
  ReplyRmLib(Connection, JobId, reply);
}
/*}}}*/
/*{{{  HandleObtainNetwork() */

/**----------------------------------------------------------------------------
*** ObtainNetwork(). This is the big one.
***
*** 1) do some housekeeping. Basically this involves reading in the
***    starting position from the search (which is ignored) and the template
***    network, and building a network hierarchy structure for the results
***    as they are produced.
*** 2) as a first step, walk down the template and look for existing processors
***    or processors with puid attributes. If these can be matched inside
***    the domain move them from the template to the allocation unit, zapping
***    the data structure. If the processor contains the NEW attribute then
***    step 3 should be skipped
*** 3) second step, try to match processors in the template with processors
***    in the domain (except the existing ones or ones with puid's). Again,
***    following a match move the processor from the template to the result
*** 4) the template now contains only processors which cannot be matched
***    satisfactorily with processors in the domain. A request is made to
***    the network server to get these from the system pool. Any processors
***    that matched can now be moved from the template to the result
*** 5) a final search is made in the template, to see if a less satisfactory
***    match can be found. I.e. is it possible to share certain processors
***    between users.
*** 6) the results are processed.
BLV
BLV the current algorithm only works for simple cases. What should happen
BLV is an initial search of the template, putting the processors into a
BLV linked list in order of how restrictive the template is. The processors
BLV should then be processed in that list order.
**/
static RmNetwork BuildHierarchy(void);
static int	 ObtainNetwork_Search1(RmProcessor, ...);
static int	 ObtainNetwork_Search2(RmProcessor, ...);
static int	 GetNetworkFromPool(RmNetwork, TfmConn, RmNetwork);
static int	 ObtainNetwork_Search3(RmProcessor, ...);
static void	 AbortObtainNetwork(RmNetwork, TfmConn);
static bool	 MoveProcessor(RmProcessor, RmProcessor, RmNetwork, TfmConn);
static void	 CleanOutResult(RmNetwork);
static bool	 CheckAvailable(RmProcessor real, TfmConn, RmProcessor);

static void ReallyObtainNetwork(TfmConn Connection, int JobId,
		RmRequest *request, RmReply *reply, RmNetwork Template);
	
void HandleObtainNetwork(TfmConn Connection, int JobId, 
		RmRequest *request, RmReply *reply)
{ 
  Debug(dbg_Allocate, ("request for a network of processors"));
  ReallyObtainNetwork(Connection, JobId, request, reply, request->Network);
}

void HandleObtainProcessors(TfmConn connection, int JobId, 
		RmRequest *request, RmReply *reply)
{ RmNetwork	Template = RmNewNetwork();
  int		count, i;
    
  Debug(dbg_Allocate, ("request for a group of processors"));

  count = request->Arg2;
  for (i = 0; i < count; i++)
   { RmProcessor	junk;
     if (RmReadProcessor(connection->Pipe_ctos, &junk, FALSE) ne RmE_Success)
      goto error;
     RmAddtailProcessor(Template, junk);
   }
  
  ReallyObtainNetwork(connection, JobId, request, reply, Template);
  return;

error:
	/* BLV - improve */
  Debug(dbg_Allocate, ("communication error"));
}

static	void ReallyObtainNetwork(TfmConn Connection, int JobId,
		RmRequest  *request, RmReply *reply, RmNetwork Template)
{ int		number_to_match;
  int		number_to_get;
  int		rc = RmE_Success;
  RmNetwork	result = (RmNetwork) NULL;

  result = BuildHierarchy();
  if (result eq (RmNetwork) NULL)
   { rc = RmE_ServerMemory; goto done; }
   
  number_to_get = number_to_match = RmCountProcessors(Template);
  if (number_to_match eq 0)
   { rc = RmE_Success; goto done; }

  Debug(dbg_Allocate, ("the request is for %d processors", number_to_match));
     
  number_to_match -= RmApplyProcessors(Template, &ObtainNetwork_Search1, Connection, result);
  if (number_to_match eq 0) goto finished;

  Debug(dbg_Allocate, ("examining domain for suitable processors"));
  number_to_match -= RmApplyProcessors(Template, &ObtainNetwork_Search2, Connection, result);
  if (number_to_match eq 0) goto finished;

  if (!DomainLocked)
   { Debug(dbg_Allocate, ("attempting to get some processors from the free pool"));
        number_to_match -= GetNetworkFromPool(Template, Connection, result);
     if (number_to_match eq 0) goto finished;
   }
   
  Debug(dbg_Allocate, ("trying to make do with existing processors"));
  number_to_match -= RmApplyProcessors(Template, &ObtainNetwork_Search3, Connection, result);

finished:

  number_to_match = RmCountProcessors(result);
  if (number_to_match eq 0)
   { rc = RmE_NotFound; goto done; }
   
  number_to_get -= number_to_match;
  if (number_to_get ne 0)
   { if ((request->FnRc eq RmC_ObtainExactNetwork) ||
         (request->FnRc eq RmC_ObtainExactProcessors))
      rc = RmE_NotFound;
     else
      rc = RmE_PartialSuccess;
   }

  Debug(dbg_Allocate, ("failed to match %d processors", number_to_get));
  
done:

  reply->FnRc	= rc;
  if ((rc eq RmE_Success) || (rc eq RmE_PartialSuccess))
   reply->Network = result;
  elif (result ne (RmNetwork) NULL)
   AbortObtainNetwork(result, Connection);
  ReplyRmLib(Connection, JobId, reply);
  if (result ne (RmNetwork) NULL) CleanOutResult(result);
}

/**
*** Make a copy of the network hierarchy. To avoid running out of memory at
*** an awkward moment, enough Uid tables are also allocated.
**/
static	int	BuildHierarchyAux(RmProcessor, ...);

static	RmNetwork	BuildHierarchy(void)
{ RmNetwork	result = RmNewNetwork();
  int		rc = RmE_Success;
  int		i, j;
  
  if (result eq (RmNetwork) NULL) return(result);
  strcpy(result->DirNode.Name, NetworkName);
  result->StructType = RmL_Obtained;
  
  { RmUidTableEntry	**tab;
    tab = (RmUidTableEntry **) Malloc((word) Domain->NoTables * sizeof(RmUidTableEntry *));
    if (tab eq Null(RmUidTableEntry *))
     { RmFreeNetwork(result); return((RmNetwork) NULL); }
    for (i = 0; i < Domain->NoTables; i++)
     { tab[i] = (RmUidTableEntry *) Malloc(RmL_SlotsPerTable * sizeof(RmUidTableEntry));
       if (tab[i] eq Null(RmUidTableEntry))
        { for (j = 0; j < i; j++) Free(tab[i]);
          Free(tab);
          RmFreeNetwork(result);
          return((RmNetwork) NULL);
        }
       for (j = 0; j < RmL_SlotsPerTable; j++)
        { (tab[i])[j].Cycle	= 0;
          (tab[i])[j].Free	= TRUE;
          (tab[i])[j].Target	= (void *) RmL_NoObject;
        }
     }
    result->NoTables	= Domain->NoTables;
    result->Tables	= tab;
  }
  
  if (Domain->NoSubnets > 0)
   rc = RmSearchNetwork(Domain, &BuildHierarchyAux, result);
  if (rc ne RmE_Success)
   { RmFreeNetwork(result); return((RmNetwork)NULL); }
  else
   return(result);
}

static int BuildHierarchyAux(RmProcessor Processor, ...)
{ va_list	args;
  RmNetwork	parent;
  RmNetwork	New;
  RmNetwork	actual;
    
  unless(RmIsNetwork(Processor)) return(RmE_Success);
  va_start(args, Processor);
  parent = va_arg(args, RmNetwork);
  va_end(args);

  actual	= (RmNetwork) Processor;
  New		= RmNewNetwork();
  if (New eq (RmNetwork)NULL) return(RmE_ServerMemory);
  strcpy(New->DirNode.Name, Processor->ObjNode.Name);
  New->StructType = RmL_Obtained;
  if (RmAddtailProcessor(parent, (RmProcessor) New) eq (RmProcessor) NULL)
   { RmFreeNetwork(New); return(RmE_Corruption); }

  if (actual->NoSubnets > 0)
   return(RmSearchNetwork(actual, &BuildHierarchyAux, New));
  else
   return(RmE_Success);
}

/**
*** The first phase in the mapping algorithm. For every processor in the
*** template that already exists or that has a puid:
*** 1) if the processor is already in the domain and is available, allocate
***    it.
*** 2) If it is not available remove it from the template and get rid of it.
*** 3) If it is not in the domain, leave it alone for a subsequent
***    RmObtainNetwork().
**/

static int	 ObtainNetwork_Search1(RmProcessor Template, ...)
{ va_list	args;
  TfmConn	Connection;
  RmNetwork	result;
  
  va_start(args, Template);
  Connection = va_arg(args, TfmConn);
  result     = va_arg(args, RmNetwork);
  va_end(args);
  
  Template->ObjNode.Account	= TfmProcessor->ObjNode.Account;
  
  RmSetProcessorPrivate(Template, 0);
  
  if (Template->StructType eq RmL_Existing)
   { RmProcessor match = RmFindProcessor(Domain, Template->Uid);

     Debug(dbg_Allocate, ("request for existing processor %P", Template));
     RmSetProcessorPrivate(Template, 1);
     
     if ((match eq RmM_NoProcessor) || (match eq RmM_ExternalProcessor))
      return(0);

     if (CheckAvailable(match, Connection, Template))
      if (MoveProcessor(Template, match, result, Connection))
       return(1); 
     RmFreeProcessor(RmRemoveProcessor(Template));
     return(1);
   }

  { char *puid = RmGetObjectAttribute((RmObject) Template, "puid", FALSE);
    if (puid ne Null(char))
     { RmProcessor match = RmLookupProcessor(Domain, puid);

       Debug(dbg_Allocate, ("puid has been specified"));
       RmSetProcessorPrivate(Template, 1);
       if (match eq (RmProcessor) NULL) return(0);
       
       if (CheckAvailable(match, Connection, Template))
        if (MoveProcessor(Template, match, result, Connection))
         return(1);
       RmFreeProcessor(RmRemoveProcessor(Template));
       return(1);
     }
  }

  if (RmGetObjectAttribute((RmObject) Template, "NEW", TRUE) ne Null(char))
   RmSetProcessorPrivate(Template, 1);

  return(0);     
}

/**
*** Phase 2 of the search. For every processor left in the template
*** that has not had its private field set to 1, search the domain
*** for a suitable processor. Only completely unused processors matching
*** the description are acceptable in this phase.
**/
static int	 ObtainNetwork_Search2Aux(RmProcessor, ...);

static int	 ObtainNetwork_Search2(RmProcessor Template, ...)
{ va_list	args;
  TfmConn	Connection;
  RmNetwork	result;
  RmProcessor	match;
  
  va_start(args, Template);
  Connection = va_arg(args, TfmConn);
  result     = va_arg(args, RmNetwork);
  va_end(args);
  
  if (RmGetProcessorPrivate(Template) eq 1) return(0);
  match = (RmProcessor) RmSearchProcessors(Domain, &ObtainNetwork_Search2Aux,
  		 Template, Connection);
  if (match eq (RmProcessor) NULL)
   return(0);
   
  if (MoveProcessor(Template, match, result, Connection))
   return(1);
  else
   return(0);
}

static	int ObtainNetwork_Search2Aux(RmProcessor real, ...)
{ va_list	args;
  RmProcessor	Template;
  TfmConn	Connection;
  DomainEntry	*domain_entry;

	/* booked processors cannot be allocated for this */
  if (real->AllocationFlags & RmF_Booked) return(0);
  
  va_start(args, real);
  Template   = va_arg(args, RmProcessor);
  Connection = va_arg(args, TfmConn);
  va_end(args);
  
  domain_entry = GetDomainEntry(real);
  if (domain_entry->NumberUsers > 0) return(0);
  
  unless(MatchProcessor(real, Template)) return(0);
  unless(CheckAvailable(real, Connection, Template)) return(0);
  return((int) real);
}

/**
*** The current domain is not big enough, so more processors have to be
*** obtained from the system pool. 
*** 1) Use what is left in the current template to get some more processors
*** 2) If more processors could be obtained, try to allocate DomainEntry
***    structures for them all.
*** 3) Then try to merge them in to the existing domain.
*** 4) for every processor in the template, if it was mapped onto a processor
***    in the result, allocate that processor.
**/   		

static int	GetNetworkFromPool_Aux1(RmProcessor, ...);
static int	GetNetworkFromPool_Aux2(RmProcessor, ...);
static int	GetNetworkFromPool_Aux3(RmProcessor, ...);

static int	 GetNetworkFromPool(RmNetwork Template, TfmConn Connection,
			RmNetwork result)
{ RmNetwork	obtained;
  int		rc;

  obtained = RmObtainNetwork(Template, FALSE, &rc);
  if (obtained eq (RmNetwork) NULL) return(0);

  Debug(dbg_Allocate, ("got some processors from the pool"));  
  if (RmSearchProcessors(obtained, &GetNetworkFromPool_Aux1) ne RmE_Success)
   { RmApplyProcessors(obtained, &GetNetworkFromPool_Aux2);
     RmReleaseNetwork(obtained);
     RmFreeNetwork(obtained);
     return(0);
   }
  Wait(&(Domain->DirNode.Lock));
  RmMergeNetworks(Domain, obtained);
  SortDomain(Domain);
  Signal(&(Domain->DirNode.Lock));
  RmFreeNetwork(obtained);
  return(RmApplyProcessors(Template, &GetNetworkFromPool_Aux3, Connection, result));
}

static int GetNetworkFromPool_Aux1(RmProcessor Processor, ...)
{ 
  if (!AddDomainEntry(Processor))
   return(1);

  Processor->ObjNode.Key = NewKey() + _cputime();
  LastChange = Processor->ObjNode.Dates.Access = GetDate();
  return(0);
}

static int GetNetworkFromPool_Aux2(RmProcessor Processor, ...)
{ DomainEntry	*domain_entry;

  domain_entry = GetDomainEntry(Processor);
  if (domain_entry ne Null(DomainEntry))
   Free(domain_entry);
  return(0);
}

static int GetNetworkFromPool_Aux3(RmProcessor Template, ...)
{ va_list	args;
  TfmConn	Connection;
  RmNetwork	result;
  RmProcessor	match;
  
  va_start(args, Template);
  Connection = va_arg(args, TfmConn);
  result     = va_arg(args, RmNetwork);
  va_end(args);
  
  match = RmFindMatchingProcessor(Template, Domain);
  if (match eq (RmProcessor) NULL) return(0);
  if (MoveProcessor(Template, match, result, Connection))
   return(1);
  else
   return(0);
}

/**
*** Final phase, similar to phase two but less restrictive.
**/
static int	 ObtainNetwork_Search3Aux(RmProcessor, ...);

static int	 ObtainNetwork_Search3(RmProcessor Template, ...)
{ va_list	args;
  TfmConn	Connection;
  RmNetwork	result;
  RmProcessor	match;

  va_start(args, Template);
  Connection = va_arg(args, TfmConn);
  result     = va_arg(args, RmNetwork);
  va_end(args);
  
  if (RmGetProcessorPrivate(Template) eq 1) return(0);
  match = (RmProcessor) RmSearchProcessors(Domain, &ObtainNetwork_Search3Aux,
  		 Template, Connection);
  if (match eq (RmProcessor) NULL)
   return(0);
   
  if (MoveProcessor(Template, match, result, Connection))
   return(1);
  else
   return(0);
}

static	int ObtainNetwork_Search3Aux(RmProcessor real, ...)
{ va_list	args;
  RmProcessor	Template;
  TfmConn	Connection;

	/* Booked means that the processor cannot be allocated	*/
	/* to meet an arbitrary request.			*/
  if (real->AllocationFlags & RmF_Booked) return(0);
	    
  va_start(args, real);
  Template   = va_arg(args, RmProcessor);
  Connection = va_arg(args, TfmConn);
  va_end(args);
  
  unless(MatchProcessor(real, Template)) return(0);
  unless(CheckAvailable(real, Connection, Template)) return(0);
  return((int) real);
}


/**
*** Abort the network in question. Every processor in the specified network
*** has been allocated to this connection. This must be undone.
**/
static int	AbortObtainAux(RmProcessor Processor, ...);

static void	AbortObtainNetwork(RmNetwork Network, TfmConn Connection)
{ Debug(dbg_Allocate, ("aborting network obtain request"));
  (void) RmApplyProcessors(Network, &AbortObtainAux, Connection);
}

static int	AbortObtainAux(RmProcessor Processor, ...)
{ va_list	args;
  TfmConn	Connection;
  DomainEntry	*domain_entry;
  int		i;
    
  va_start(args, Processor);
  Connection = va_arg(args, TfmConn);
  va_end(args);
  
  domain_entry = GetDomainEntry(Processor);
  for (i = 0; i < MaxUsersPerProcessor; i++)
   if (domain_entry->AllocationTable[i].Connection eq Connection)
    { domain_entry->AllocationTable[i].Connection	= (TfmConn) NULL;
      domain_entry->AllocationTable[i].Id		= 0;
      (void) Remove(&(domain_entry->AllocationTable[i].Node));
    }
  domain_entry->NumberUsers--;
  return(0);
}
  

/**
*** Check that a given processor can be allocated.
**/
static bool	CheckAvailable(RmProcessor match, TfmConn Connection,
		RmProcessor Template)     
{ DomainEntry *domain_entry;
  int	 i;

  domain_entry = GetDomainEntry(match);
  if (domain_entry->NumberUsers > 0)
   { if ((match->AllocationFlags & RmF_Exclusive) ||
         (Template->AllocationFlags & RmF_Exclusive))
      return(FALSE);
      
     if (domain_entry->NumberUsers >= MaxUsersPerProcessor)
      return(FALSE);
     for (i = 0; i < MaxUsersPerProcessor; i++)
      if (domain_entry->AllocationTable[i].Connection eq Connection)
       return(FALSE);
   }
   
  return(TRUE);
}

/**
*** A suitable processor has been found. It must be moved to the
*** appropriate position in the result network, complete with attribute
*** information, link information, etc.
**/
static bool MoveProcessor(RmProcessor Template, RmProcessor real, 
				RmNetwork result, TfmConn Connection)
{ RmProcessor	new_proc;
  DomainEntry	*domain_entry;
  int		i;

  new_proc = RmNewProcessor();  
  if (new_proc eq (RmProcessor) NULL) return(FALSE);

  Debug(dbg_Allocate, ("processor %P has been allocated", real));

  memcpy(new_proc, real, sizeof(RmProcessorStruct));  
  new_proc->ObjNode.Key		= 0;
  new_proc->StructType		= RmL_Obtained;
  new_proc->ObjNode.Parent	= Null(DirNode);
  new_proc->Root		= (RmNetwork) NULL;
  new_proc->MappedTo		= Template->Uid;
  NewCap(&(new_proc->NsCap), &(real->ObjNode), AccMask_R + AccMask_W + AccMask_D);
  InitList(&(new_proc->MappedTasks));

  RmInsertProcessor(result, new_proc);

  if (Template->AllocationFlags & RmF_Exclusive)
   { real->AllocationFlags	|= RmF_Exclusive;
     real->ApplicationId	 = Connection->Id;
     new_proc->ApplicationId	 = Connection->Id;
   }
  else
   real->ApplicationId = new_proc->ApplicationId = -1;

  RmRemoveProcessor(Template);
  RmFreeProcessor(Template);

  domain_entry	= GetDomainEntry(real);
  for (i = 0; i < MaxUsersPerProcessor; i++)
   if (domain_entry->AllocationTable[i].Id eq 0)
    { domain_entry->AllocationTable[i].Id		= AllocationId++;
      domain_entry->AllocationTable[i].Connection	= Connection;
      AddTail(	&(Connection->Processors),
      		&(domain_entry->AllocationTable[i].Node));
      break;
    }
  domain_entry->NumberUsers++;

  return(TRUE);   
}

/**
*** Cleaning out the result. The above code has cheated by duplicating
*** various fields rather than making a new copy. To avoid horrible
*** problems this must now be undone before the network is freed.
**/
static int	CleanOutAux1(RmProcessor, ...);

static void CleanOutResult(RmNetwork Network)
{
  (void) RmApplyProcessors(Network, &CleanOutAux1);
  RmFreeNetwork(Network);
}

static int CleanOutAux1(RmProcessor Processor, ...)
{ 
  Processor->Connections	= 0;
  Processor->OtherLinks		= Null(RmLink);
  Processor->AttribSize		= 0;
  Processor->AttribFree		= 0;
  Processor->AttribData		= Null(char);
  Processor->PAttribSize	= 0;
  Processor->PAttribFree	= 0;
  Processor->PAttribData	= Null(char);
  return(0);
}

/*}}}*/
/*{{{  HandleReleaseNetwork() */
/**----------------------------------------------------------------------------
*** Releasing a network is mostly a case of ReleaseProcessor() in a loop.
**/
void HandleReleaseNetwork(TfmConn Connection, int JobId,
		RmRequest *request, RmReply *reply)
{ int			rc = RmE_Success;
  ProcessorDetails	*details;
  RmProcessor		Processor;
  DomainEntry		*domain_entry;
  int			i, j;

  Debug(dbg_Release, ("release-network request"));
 
  details = (ProcessorDetails *) request->VariableData;

  for (i = 0; i < request->Arg1; i++)
   { Processor = RmFindProcessor(Domain, details[i].Uid);
     if ((Processor eq RmM_NoProcessor) ||(Processor eq RmM_ExternalProcessor))
      { rc = RmE_NotFound; continue; }

     Debug(dbg_Release, ("releasing processor %P", Processor));

     unless(GetAccess(&(details[i].Cap), Processor->ObjNode.Key) &&
            (details[i].Cap.Access & AccMask_D))
      { rc = RmE_NoAccess; continue; }

     LastChange = Processor->ObjNode.Dates.Access = GetDate();
     /* Processor->ApplicationId	= -1;*/
     
     domain_entry = GetDomainEntry(Processor);
     for (j = 0; j < MaxUsersPerProcessor; j++)
      if (domain_entry->AllocationTable[j].Connection eq Connection)
       { domain_entry->AllocationTable[j].Connection	= (TfmConn) NULL;
         domain_entry->AllocationTable[j].Id		= 0;
	 Remove(&(domain_entry->AllocationTable[j].Node));
         break;
       }
     domain_entry->NumberUsers--;
     if (domain_entry->NumberUsers eq 0)
      { if ((Processor->AllocationFlags & (RmF_Permanent | RmF_TfmProcessor))
      		 eq 0)
         ReturnProcessorToPool(Processor);
        else
         Processor->AllocationFlags &= ~RmF_Exclusive;
      }
   }

  reply->FnRc	= rc;
  ReplyRmLib(Connection, JobId, reply);
}
/*}}}*/
/*{{{  misc: SortDomain(), AddDomainEntry(), ... */

/**
*** Sort the current domain, thus ensuring that the processors within
*** the user's domain have the same or at least a very similar order to
*** the processors within the network. Given the fairly small size of a
*** domain a bubble-search should suffice.
**/
static void SortDomain(RmNetwork network)
{ RmProcessor	current;
  RmProcessor	next;
  bool		changes = TRUE;

  while (changes)
   { changes = FALSE;
     current = RmFirstProcessor(network);
     next    = RmNextProcessor(current);
     for ( ; next ne (RmProcessor) NULL; current = next, next = RmNextProcessor(current))
      { if (RmIsNetwork(current))
         { SortDomain((RmNetwork) current);
 	   continue;
         }
        if (RmIsNetwork(next))
         continue;
        if (current->Uid > next->Uid)
         { RmPreinsertProcessor(current, next);
           changes = TRUE;
           next = current;
	 }
      }
   }
}

/**
*** Add the DomainEntry structure to a newly-obtained processor
**/
bool	AddDomainEntry(RmProcessor Processor)
{ DomainEntry	*entry = New(DomainEntry);
  int		i;
  
  if (entry eq Null(DomainEntry)) return(FALSE);
  entry->NumberUsers		= 0;
  entry->Processor		= Processor;
  for (i = 0; i < MaxUsersPerProcessor; i++)
   { entry->AllocationTable[i].Processor	= Processor;
     entry->AllocationTable[i].Connection	= (TfmConn) NULL;
     entry->AllocationTable[i].Id		= 0;
   }
  RmSetProcessorPrivate(Processor, (int) entry);
  
  return(TRUE);
}


/**
*** When a client shuts down a connection every processor obtained by
*** that client must be freed. This routine is called in a WalkList
**/
word AutomaticRelease(Node *node)
{ DomainEntry		*domain_entry;
  RmProcessor		Processor;
  AllocationInfo	*info = (AllocationInfo *) node;

  Processor		= info->Processor;
  domain_entry		= GetDomainEntry(Processor);
  Debug(dbg_Release, ("automatic processor release activated on %P", Processor));

  domain_entry->NumberUsers--;
  info->Connection	= (TfmConn) NULL;
  info->Id		= 0;

  /*Processor->ApplicationId	= -1;*/
  
  if (domain_entry->NumberUsers eq 0)
   { if ((Processor->AllocationFlags & (RmF_Permanent | RmF_TfmProcessor)) eq 0)
      ReturnProcessorToPool(Processor);
     else
      Processor->AllocationFlags &= ~RmF_Exclusive;
   }
  return(0);
}

/**
*** Returning a processor to the pool involves removing it from the directory
*** structure, free'ing its domain info, and calling ReleaseProcessor()
**/
void	ReturnProcessorToPool(RmProcessor Processor)
{ DomainEntry	*domain_entry;

  if (DomainLocked) return;
  
  Debug(dbg_Release, ("returning processor %P to the system pool", Processor));  
  if (RmRemoveProcessor(Processor) eq (RmProcessor) NULL)
   { /* report("internal error returning processor %s to system pool",
   		Processor->ObjNode.Name); */
     return;
   }

  domain_entry = GetDomainEntry(Processor);
  Free(domain_entry);
  (void) RmReleaseProcessor(Processor);
  RmFreeProcessor(Processor);
}

/**
*** Getting a processor from the pool is another question entirely.
**/
static RmProcessor GetFromPool(RmProcessor Template, int *rc_ptr)
{ int		rc;
  RmProcessor	result;

  if (DomainLocked)
   { *rc_ptr = RmE_InUse; return((RmProcessor) NULL); }
   
  Debug(dbg_Allocate, ("attempting to get a processor from the free pool"));
      
  Template->ObjNode.Account	= TfmProcessor->ObjNode.Account;
  result = RmObtainProcessor(Template);
  if (result eq (RmProcessor) NULL) { rc = RmErrno; goto done; }
  Debug(dbg_Allocate, ("got a processor from the pool"));
  
  unless(AddDomainEntry(result))
   { RmReleaseProcessor(result); 
     RmFreeProcessor(result);
     rc = RmE_ServerMemory; 
     goto done; 
   }

  if (RmInsertProcessor(Domain, result) eq (RmProcessor) NULL)
   { DomainEntry *domain_entry;
     domain_entry = GetDomainEntry(result);
     Free(domain_entry);
     RmReleaseProcessor(result);
     RmFreeProcessor(result);
     rc = RmE_Corruption;
     goto done;
   }
  SortDomain(Domain);

  result->AllocationFlags = 0;
  if ((Template->AllocationFlags & RmF_Exclusive) ne 0)
   result->AllocationFlags |= RmF_Exclusive;

  LastChange = result->ObjNode.Dates.Access = GetDate();
  result->ObjNode.Key = NewKey() + _cputime();
  
  rc = RmE_Success;
     
done:
  *rc_ptr = rc;
  if (rc eq RmE_Success)
   return(result);
  else
   return((RmProcessor) NULL);
} 

/*}}}*/

/*{{{  domain_FillInTaskMapping() */
/**
*** Given a task and a processor that has been selected to run this task,
*** associate the task with that processor. This involves RmMapTask()
*** plus some additional work to update the TaskEntry and DomainEntry
*** fields, allowing the TFM to keep track of how many users there are
*** for every processor. 
**/
bool	domain_FillInTaskMapping(RmTask task, RmProcessor processor)
{ TaskEntry	*task_entry	= GetTaskEntry(task);
  DomainEntry	*domain_entry	= GetDomainEntry(processor);
  int		 i;

  if (domain_entry->NumberUsers >= MaxUsersPerProcessor)
   return(FALSE);

  for (i = 0; i < MaxUsersPerProcessor; i++)
   if (domain_entry->AllocationTable[i].Id eq 0)
    { domain_entry->AllocationTable[i].Id = AllocationId;
      break;
    }
  domain_entry->NumberUsers++;
  RmMapTask(processor, task);
  task_entry->Mapped = AllocationId++;
  return(TRUE);
}
/*}}}*/
/*{{{  domain_MapTask() */

/*------------------------------------------------------------------------------
***
*** This code deals with mapping tasks and taskforces automatically onto
*** the available domain, expanding the domain as required.
***
*** domain_MapTask() is based very closely on HandleObtainProcessor()
***
*** 1) if the request is for an existing processor, then this may or may
***    not be inside the current domain. If it is fine. Otherwise an
***    attempt is made to get the specified processor from the system pool.
*** 2) an initial search is made in the domain to find a processor that
***    may be suitable. This search is quite restrictive. However, the
***    best match to date is remembered (this may be null for a weird request)
*** 3) if the search is unsuccessful an attempt is made to get another
***    processor from the system pool. If that succeeds fine.
*** 4) otherwise if the search revealed any suitable processor at all,
***    that processor is used. If the domain does not contain a suitable
***    processor and the system pool could not provide one, tough.
**/
static int		MapTask_Search(RmProcessor, ...);

bool	domain_MapTask(RmTask task)
{ RmProcessor		Template	= (RmProcessor) NULL;
  RmProcessor		result		= (RmProcessor) NULL;
  int			rc;
  RmProcessor		LeastBusy;
  int			LowestCost;

  Debug(dbg_Mapping, ("mapping a single task"));
        
  { char *puid = RmGetObjectAttribute((RmObject) task, "puid", FALSE);
    
    if (puid ne Null(char))
     { Debug(dbg_Mapping, ("puid has been specified"));
       result = RmLookupProcessor(Domain, puid);
       if (result eq (RmProcessor)NULL)
        if (!DomainLocked)
         { Template = RmNewProcessor();
           if (Template eq (RmProcessor) NULL) goto done;
           RmAddProcessorAttribute(Template, &(puid[-5]));
           if ((result = GetFromPool(Template, &rc)) eq (RmProcessor) NULL)
            { rc = RmE_NotFound; goto done; }
         }
       goto found;
     }
  }

	/* No particular processor is required. Perform a search of the	*/
	/* current domain.						*/
   LeastBusy	= (RmProcessor) NULL;
   LowestCost	= (int) MaxInt;
   Debug(dbg_Mapping, ("searching current domain for a free processor"));

   result = (RmProcessor) RmSearchProcessors(Domain, &MapTask_Search,
   		task, &LeastBusy, &LowestCost);
   if (result ne (RmProcessor) NULL) goto found;

   if (LowestCost < 3)	/* tfm, shell, one other on same processor */
    { result = LeastBusy; goto found; }

   if (!DomainLocked)    
    { Debug(dbg_Mapping, ("attempting to get another processor from the pool"));
      Template = RmNewProcessor();
      if (Template ne (RmProcessor) NULL)
       { int	attribs;
         RmSetProcessorType(Template, RmGetTaskType(task));
         RmSetProcessorMemory(Template, RmGetTaskMemory(task));
         attribs = RmCountTaskAttributes(task);
         if (attribs > 0)
          { char	*default_attribs[10];
            char	**real_attribs;
            if (attribs > 10)
             real_attribs = (char **) Malloc((word) attribs * sizeof(char *));
            else
             real_attribs = default_attribs;
            if (real_attribs ne Null(char *))
             { int i;
               RmListTaskAttributes(task, real_attribs);
               for (i = 0; i < attribs; i++)
                RmAddProcessorAttribute(Template, real_attribs[i]);
               if (attribs > 10)
                Free(real_attribs);
             }    
          }
         result = GetFromPool(Template, &rc);
         if (result ne (RmProcessor) NULL) goto found;
       }
    }
    
   if (LeastBusy eq (RmProcessor) NULL) goto done;
   Debug(dbg_Mapping, ("making do with an existing processor"));
   result = LeastBusy;
        
	/* At this point, result should point to a valid processor	*/
	/* that meets the user's requirements. This does not mean	*/
	/* it is safe to allocate...					*/
found:

  Debug(dbg_Mapping, ("selected processor %P", result));
  if (domain_FillInTaskMapping(task, result))
   { Debug(dbg_Mapping, ("successfully obtained a processor"));
     rc = RmE_Success;
     LastChange = result->ObjNode.Dates.Access = GetDate();
   }
  else
   { Debug(dbg_Mapping, ("processor %P is overused", result));
     rc = RmE_InUse;
   }

done:
  if (Template ne (RmProcessor) NULL) RmFreeProcessor(Template);  
  return((rc eq RmE_Success) ? TRUE : FALSE);
}

static	int	MapTask_Search(RmProcessor Processor, ...)
{ va_list	args;
  RmTask	Template;
  DomainEntry	*domain_entry;
  RmProcessor	*LeastBusy;
  int		*LowestCost;
  int		cost_factor;
    
  va_start(args, Processor);
  Template	= va_arg(args, RmTask);
  LeastBusy	= va_arg(args, RmProcessor *);
  LowestCost	= va_arg(args, int *);
  va_end(args);
  
	/* Booked means that the processor cannot be allocated	*/
	/* to meet an arbitrary request.			*/
  if ((Processor->AllocationFlags & RmF_Booked) ne 0) return(0);

	/* If the processor does not match the Template's requirements	*/
	/* forget it							*/  
  unless(MatchTask(Processor, Template)) return(0);

      	/* This processor appears to stand a chance. If the number of	*/
      	/* users is currently zero than this processor is ideal.	*/
  domain_entry = GetDomainEntry(Processor);
  if (domain_entry->NumberUsers eq 0) return((int) Processor);

 	/* If the number of users is greater than zero than it is	*/
 	/* necessary to calculate a cost factor for using this processor*/
 	/* This equation may need fine-tuning.				*/
  cost_factor = domain_entry->NumberUsers;
  if (RmGetProcessorMemory(Processor) > 0x100000) cost_factor--;
  if (cost_factor < *LowestCost)
   { *LeastBusy		= Processor;
     *LowestCost	= cost_factor;
   }

	/* However, this processor is not ideal and there may be a	*/
	/* better one.							*/
  return(0);
}

/*}}}*/
/*{{{  domain_UnmapTask() and domain_UnmapTaskforce() */
/**----------------------------------------------------------------------------
*** Unmapping a task. This is a bit like HandleReleaseProcessor()
**/
void	domain_UnmapTask(RmTask task)
{ RmProcessor		processor;
  DomainEntry		*domain_entry;
  TaskEntry		*task_entry;
  int			i;

  Debug(dbg_Mapping, ("unmapping a task"));
  processor	= RmFollowTaskMapping(Domain, task);
  if (processor eq (RmProcessor) NULL) return;

  RmUnmapTask(processor, task);

  domain_entry	= GetDomainEntry(processor);
  task_entry	= GetTaskEntry(task);
  LastChange	= processor->ObjNode.Dates.Access = GetDate();  
  for (i = 0; i < MaxUsersPerProcessor; i++)
   if (domain_entry->AllocationTable[i].Id eq task_entry->Mapped)
    domain_entry->AllocationTable[i].Id	= 0;
  domain_entry->NumberUsers--;
  if (domain_entry->NumberUsers eq 0)
   { if ((processor->AllocationFlags & (RmF_Permanent | RmF_TfmProcessor)) eq 0)
      ReturnProcessorToPool(processor);
     else
      processor->AllocationFlags &= ~RmF_Exclusive;
   }

  task_entry->Mapped = 0;
}

/**
*** Releasing a taskforce. This is very similar to releasing a single task
**/
static int domain_UnmapTaskforceAux(RmTask task, ...);

void		domain_UnmapTaskforce(RmTaskforce taskforce)
{ (void) RmApplyTasks(taskforce, &domain_UnmapTaskforceAux);
}

static	int domain_UnmapTaskforceAux(RmTask task, ...)
{ 
  if (RmFollowTaskMapping(Domain, task) ne (RmProcessor) NULL)
   domain_UnmapTask(task);
  return(0);
}
/*}}}*/
/*{{{  domain_MapTaskforce() */

/*{{{  General description */

/**-----------------------------------------------------------------------------
*** Mapping a taskforce, this is where the fun starts.
***
*** 1) do some housekeeping.
*** 2) check the network passed as argument, if any. If the taskforce has
***    already been mapped partially or completely and all the required
***    processors are in the domain, the mapping is easy. If one or more
***    of the required processors is not yet in the domain life gets
***    a bit more difficult.
*** 3) next, walk down the template and look for 
***    tasks processors with puid attributes. If these can be matched inside
***    the domain move them from the template to the allocation unit, zapping
***    the data structure. 
*** 4) try to match tasks in the template with processors
***    in the domain (except the existing ones or ones with puid's). Again,
***    following a match assign the processor. This search is responsible
***    for making the mappings efficient if possible.
*** 5) the template now contains only tasks which cannot be matched
***    satisfactorily with processors in the domain. A request is made to
***    the network server to get these from the system pool.
*** 6) the taskforce is checked again for tasks with puid attributes or
***    tasks that were already mapped to processors. If the required
***    processor is still not in the domain then the mapping can be
***    aborted.
*** 7) step 4 is repeated. This allows for the case where there were no
***    specific requirements but the required processors had not been
***    pre-allocated.
*** 8) a check is made to ensure that the taskforce can be mapped at all.
***    In particular, for every task with particular requirements the
***    domain is searched for a processor with these requirements.
*** 9) a final search is made in the template, to see if a less satisfactory
***    match can be found. A manifest in tfmaux.h, set to 32 at the time of
***    writing, controls the maximum number of components permitted per
***    processor.
*** 9) the results are processed.
**/

/*}}}*/
/*{{{  forward declarations */
static int	MapTaskforce_SearchExisting(RmTask, ...);
static int	MapTaskforce_SearchExisting2(RmTask, ...);
static int	MapTaskforce_SearchPuid(RmTask, ...);
static int	MapTaskforce_SearchPuid2(RmTask, ...);
static int	MapTaskforce_MainSearch(RmTask, ...);
static int	MapTaskforce_Check(RmTask, ...);
static void	Map_GetNetworkFromPool(RmTaskforce);
static void	AbortMapTaskforce(RmTaskforce);
static bool	AllocProcessor(RmTask, RmProcessor);
static bool	Map_CheckAvailable(RmProcessor);

#define MappingFailure	1000000
/*}}}*/

/*{{{  MapTaskforce()     : the main routine */
bool		domain_MapTaskforce(RmNetwork network, RmTaskforce Taskforce)
{ int		number_to_match;
  int		limit;
    
  Debug(dbg_Mapping, ("mapping a taskforce"));
 
  number_to_match = RmCountTasks(Taskforce);
  if (number_to_match <= 0) goto finished;

  Debug(dbg_Mapping, ("the request is for %d tasks", number_to_match));

  if (network ne (RmNetwork) NULL)
   { number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_SearchExisting, network);
     Debug(dbg_Mapping, ("after comparing supplied network and the domain, %d tasks left", number_to_match));
     if (number_to_match <= 0) goto finished;
   }

  number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_SearchPuid);
  Debug(dbg_Mapping, ("after checking for puid's, %d tasks left", number_to_match));
  if (number_to_match <= 0) goto finished;

  Debug(dbg_Mapping, ("examining current domain for suitable processors"));
  number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_MainSearch, 0);
  Debug(dbg_Mapping, ("after checking for empty processors, %d tasks left", number_to_match));
  if (number_to_match <= 0) goto finished;

  if (!DomainLocked)
   { Debug(dbg_Mapping, ("attempting to get some processors from the free pool"));
     Map_GetNetworkFromPool(Taskforce);
   }
  else
   Debug(dbg_Mapping, ("domain is locked, cannot get additional processors"));

  Debug(dbg_Mapping, ("checking puids again"));
  number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_SearchExisting2);
  if (number_to_match <= 0) goto finished;
  number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_SearchPuid2);
  if (number_to_match <= 0) goto finished;

  Debug(dbg_Mapping, ("trying to make do with existing processors, limit 0"));
  number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_MainSearch, 0);
  if (number_to_match <= 0) goto finished;

  Debug(dbg_Mapping, ("checking taskforce feasibility"));
  if (RmSearchTasks(Taskforce, &MapTaskforce_Check) ne 0)
   goto finished;
   
  for (limit = 1; limit < MaxComponentsPerProcessor; limit++)
   { Debug(dbg_Allocate, ("trying to make do with existing processors, limit %d", limit));
     number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_MainSearch, limit);
     if (number_to_match <= 0) goto finished;
   }

finished:

  if (number_to_match ne 0)
   { Debug(dbg_Allocate, ("failed to map taskforce"));
     AbortMapTaskforce(Taskforce);
   }
  return(number_to_match eq 0);
}
/*}}}*/

/*{{{  SearchExisting     : check the supplied network */
/**
*** With the Resource Management library the application may have partially
*** or wholly mapped the taskforce onto the existing domain. Alternative
*** an RmLib binary object may be being executed, containing both a
*** network and a mapped taskforce. This routine matches the network supplied
*** with the current domain. If a task can be re-mapped immediately this
*** happens. Otherwise the task is unmapped but given a UID private
*** attribute, which will then be passed to the Network Server. Effectively
*** the same mechanisms are used as for PUID attributes.
**/
static int MapTaskforce_SearchExisting(RmTask task, ...)
{ RmNetwork	network;
  va_list	args;
  RmProcessor	supplied;
  RmProcessor	domain_proc;
  char		buf[32];

  va_start(args, task);
  network = va_arg(args, RmNetwork);
  va_end(args);

  if (task->MappedTo eq RmL_NoUid) return(0);
  supplied = RmFindProcessor(network, task->MappedTo);
  RmUnmapTask(supplied, task);
  if (supplied eq (RmProcessor) NULL)	/* What ??? */
   { report("internal error, received mapped task without a matching processor");
     task->MappedTo = RmL_NoUid;
     return(0);
   }

  domain_proc = RmFindProcessor(Domain, supplied->Uid);
  if (domain_proc ne (RmProcessor) NULL)
   { Debug(dbg_Create, ("component %T has been mapped already to processor %P",\
		task, domain_proc));
     if (AllocProcessor(task, domain_proc))
      return(1);
     else
      return(MappingFailure);
   }

	/* If the processor is not currently in the user's domain then	*/
	/* the taskforce probably came from a file, i.e. the user had	*/
	/* pre-mapped an application and written the mapping to a file.	*/
	/* The task is given a PUID attribute which will be passed on	*/
	/* to the Network Server.					*/
  strcpy(buf, "puid=#");
  addint(buf, supplied->Uid);
  RmAddTaskAttribute(task, buf);
  task->MappedTo = -1;
  return(0);  
}  

/**
*** SearchExisting2 : this is called after additional processors have been
*** obtained from the network. If the given task has a puid attribute of the
*** form #1234 and has not been mapped yet then there should now be
*** a processor with Uid 1234 in the domain. The puid attribute should be
*** removed at this point to avoid confusion.
**/
static int MapTaskforce_SearchExisting2(RmTask task, ...)
{ char 		*puid;
  int		 uid;
  RmProcessor	 match;

  if (task->MappedTo ne -1) return(0);
  puid = RmGetObjectAttribute((RmObject) task, "puid", FALSE);
  if ((puid eq Null(char)) || (*puid ne '#'))
   return(0);

  uid = atoi(&(puid[1]));
  RmRemoveTaskAttribute(task, &(puid[-5]));

  match = RmFindProcessor(Domain, uid);
  if (match eq (RmProcessor) NULL)
   { Debug(dbg_Create, ("failed to obtain mapped processor for component %T", task));
     return(MappingFailure);
   }
  if (AllocProcessor(task, match))
   return(1);
  else
   return(MappingFailure);
}

/*}}}*/
/*{{{  SearchPuid         : check for puid attributes */

/**
*** The second phase in the mapping algorithm.  For every task in the
*** template that has a puid attribute:
*** 1) if the processor is already in the domain and is available, allocate
***    it.
*** 2) If it is in the domain but not available, error
*** 3) If it is not in the domain, leave it alone for a subsequent
***    RmObtainNetwork().
**/

static int	 MapTaskforce_SearchPuid(RmTask task, ...)
{ char		*puid;
  RmProcessor	 match;

  if (task->MappedTo ne RmL_NoUid) return(0);

  puid = RmGetObjectAttribute((RmObject) task, "puid", FALSE);
  if ((puid ne Null(char)) && (*puid ne '#'))
   { Debug(dbg_Mapping, ("component %T, puid has been specified", task));
     match = RmLookupProcessor(Domain, puid);
     if (match eq (RmProcessor) NULL)
      { task->MappedTo = -1; return(0); }
       
     if (AllocProcessor(task, match))
      return(1);
     else
      return(MappingFailure);
   }
  return(0);     
}

static int MapTaskforce_SearchPuid2(RmTask task, ...)
{ char		*puid;
  RmProcessor	 match;

  if (task->MappedTo ne -1) return(0);
  puid = RmGetObjectAttribute((RmObject) task, "puid", FALSE);
  if (puid eq Null(char))
   return(0);

  match = RmLookupProcessor(Domain, puid);
  if ((match eq (RmProcessor) NULL) || !AllocProcessor(task, match))
   { Debug(dbg_Mapping, ("component %T, cannot satisfy PUID %s", task, puid));
     return(MappingFailure);
   }
  return(1);
}

/*}}}*/
/*{{{  MainSearch         : the general case */
/**
*** This routine is the heart of the taskforce mapping algorithm.
*** It is applied to every task in the taskforce. If the task has already
*** been mapped nothing more can be done. Otherwise the current domain
*** is searched for a processor that can run this task given the current
*** usage limit. 
***
*** The clever stuff happens when a match is found. At this point all
*** connected component tasks and all connected processors are considered.
*** If a match is found then the appropriate task and processor are mapped,
*** and the search continues from that match. Note that the search does
*** not continue with the same task, as the mapping performance for pipelines
*** and rings is better that way. The mapping never
*** backtracks. Furthermore the search is always linear rather than
*** breadth-first. Hence the mapping should still take a linear amount of
*** time.
**/
static int MapTaskforce_MainSearch_aux1(RmProcessor, ...);
static int MapTaskforce_MainSearch_continue(RmTask, RmProcessor, int limit);

static int MapTaskforce_MainSearch(RmTask task, ...)
{ va_list	args;
  int		usage_limit;
  RmProcessor	match;

  va_start(args, task);
  usage_limit = va_arg(args, int);
  va_end(args);

  if (task->MappedTo ne RmL_NoUid) return(0);

  match = (RmProcessor) RmSearchProcessors(Domain, &MapTaskforce_MainSearch_aux1, task, usage_limit);
  if (match eq (RmProcessor) NULL)
   return(0);

  return(1 + MapTaskforce_MainSearch_continue(task, match, usage_limit)); 
}

static int MapTaskforce_MainSearch_aux1(RmProcessor processor, ...)
{ va_list	args;
  RmTask	task;
  int		usage_limit;
  DomainEntry	*domain_entry;

  va_start(args, processor);
  task		= va_arg(args, RmTask);
  usage_limit	= va_arg(args, int);
  va_end(args);

  domain_entry = GetDomainEntry(processor);

  if (   (domain_entry->NumberUsers > usage_limit) ||
	! Map_CheckAvailable(processor) ||
	! MatchTask(processor,task) ||
        ! AllocProcessor(task, processor))
   return(0);

  return((int) processor);
}

static MapTaskforce_MainSearch_continue(RmTask task, RmProcessor processor, int usage_limit)
{ RmProcessor	 neighbour_processor;
  RmTask	 neighbour_task;
  int		 number_links, link, destlink;
  int		 number_channels, channel, destchannel;
  RmTask	 current_task;
  RmProcessor 	 current_processor;
  DomainEntry	*domain_entry;
  int		 result = 0;

  while (task ne (RmTask) NULL)
   { current_task	= task;
     current_processor	= processor;
     task 		= (RmTask) NULL;
     processor		= (RmProcessor) NULL;

     number_channels	= RmCountChannels(current_task);
     number_links	= RmCountLinks(current_processor);
     
     for (channel = 0; channel < number_channels; channel++)
      { neighbour_task = RmFollowChannel(current_task, channel, &destchannel);
        if ((neighbour_task eq RmM_NoTask) ||
	    (neighbour_task eq RmM_ExternalTask) ||
	    (neighbour_task->MappedTo ne RmL_NoUid))
         continue;

	for (link = 0; link < number_links; link++)
	 { neighbour_processor = RmFollowLink(current_processor, link, &destlink);
	   if ((neighbour_processor eq RmM_NoProcessor) ||
	       (neighbour_processor eq RmM_ExternalProcessor))
	    continue;

	   domain_entry = GetDomainEntry(neighbour_processor);
	   if ( (domain_entry->NumberUsers > usage_limit) ||
		!Map_CheckAvailable(neighbour_processor)  ||
		!MatchTask(neighbour_processor, neighbour_task) ||
		!AllocProcessor(neighbour_task, neighbour_processor))
	    continue;
	   else
	    { result++;
	      if (task eq (RmTask) NULL)
	       { task = neighbour_task; processor = neighbour_processor; }
	      goto done_task;
	    }

	 }	/* for each link		*/
      }		/* for each channel		*/
done_task:
    task = task;
   }		/* while partial success	*/
  return(result);
}
  
/*}}}*/
/*{{{  MapTaskforce_Check : check the feasibility of mapping this taskforce */
/**
*** Check that the taskforce can be mapped at all.
**/

static int MapTaskforce_CheckAux(RmProcessor, ...);

static int MapTaskforce_Check(RmTask task, ...)
{
  if (task->MappedTo > 0) return(0);
  
  if (RmSearchProcessors(Domain, &MapTaskforce_CheckAux, task) eq 0)
   { Debug(dbg_Mapping, ("cannot map %T in the current domain", task));
     return(1);
   }
  else 
   return(0);
}  

static int MapTaskforce_CheckAux(RmProcessor processor, ...)
{ va_list	args;
  RmTask	task;
  
  va_start(args, processor);
  task = va_arg(args, RmTask);
  va_end(args);
  
  if ((Map_CheckAvailable(processor)) &&
      (MatchTask(processor, task)))
   return(1);
  else
   return(0);
}
/*}}}*/
/*{{{  GetNetworkFromPool : request additional resources */

/**
*** The current domain is not big enough, so more processors have to be
*** obtained from the system pool. 
*** 1) build a template to get some more processors
*** 2) If more processors could be obtained, try to allocate DomainEntry
***    structures for them all.
*** 3) Then try to merge them in to the existing domain.
**/   		
static int	Map_BuildTemplate(RmTask Task, ...);

static void	 Map_GetNetworkFromPool(RmTaskforce Taskforce)
{ RmNetwork	Template = RmNewNetwork();
  RmNetwork	obtained;
  int		rc;
  
  if (Template eq (RmNetwork) NULL) goto fail;

  Debug(dbg_Mapping, ("building network template"));
  
  if (RmSearchTasks(Taskforce, &Map_BuildTemplate, Template) ne RmE_Success)
   goto fail;
   
  obtained = RmObtainNetwork(Template, FALSE, &rc);
  RmFreeNetwork(Template);
  if (obtained eq (RmNetwork) NULL) goto fail;

  Debug(dbg_Mapping, ("got some processors from the pool"));  
  if (RmSearchProcessors(obtained, &GetNetworkFromPool_Aux1) ne RmE_Success)
   { RmApplyProcessors(obtained, &GetNetworkFromPool_Aux2);
     RmReleaseNetwork(obtained);
     RmFreeNetwork(obtained);
     goto fail;
   }
  Wait(&(Domain->DirNode.Lock));
  RmMergeNetworks(Domain, obtained);
  SortDomain(Domain);
  Signal(&(Domain->DirNode.Lock));

  RmFreeNetwork(obtained);
  return;

fail:
  Debug(dbg_Mapping, ("failed to get additional processors from free pool"));
}

static int Map_BuildTemplate(RmTask Task, ...)
{ va_list	args;
  RmNetwork	Template;
  RmProcessor	New;
  int		attribs;
    
  va_start(args, Task);
  Template = va_arg(args, RmNetwork);
  va_end(args);
  
  if (Task->MappedTo > 0) return(0);

  New = RmNewProcessor();
  if (New eq (RmProcessor) NULL) return(1);
  New->ObjNode.Account	= TfmProcessor->ObjNode.Account;
  
  if (Task->MappedTo eq -1)
   { char *puid = RmGetObjectAttribute((RmObject) Task, "puid", FALSE);
     if ((puid eq Null(char)) || 
         (RmAddProcessorAttribute(New, &(puid[-5])) ne RmE_Success) ||
         (RmAddtailProcessor(Template, New) eq (RmProcessor) NULL) )
      { RmFreeProcessor(New); return(1); }
     return(0);      
   }
     
  RmSetProcessorType(New, RmGetTaskType(Task));
  RmSetProcessorMemory(New, RmGetTaskMemory(Task));
  attribs = RmCountTaskAttributes(Task);
  if (attribs > 0)
   { char	*default_attribs[10];
     char	**real_attribs;
     int	i;
     
     if (attribs > 10)
      real_attribs = (char **) Malloc((word) attribs * sizeof(char *));
     else
      real_attribs = default_attribs;
     if (real_attribs eq Null(char *))
      { RmFreeProcessor(New); return(1); }
     RmListTaskAttributes(Task, real_attribs);
     for (i = 0; i < attribs; i++)
      RmAddProcessorAttribute(New, real_attribs[i]);
     if (attribs > 10)
      Free(real_attribs);
   } 
  if (RmAddtailProcessor(Template, New) eq (RmProcessor) NULL)
   { RmFreeProcessor(New); return(1); }
  else
   return(0);
}

/*}}}*/
/*{{{  AbortMapTaskforce  : this taskforce cannot be mapped */
/**
*** Abort the mapping. Some of the tasks in the taskforce may have been
*** mapped already. This must now be undone.
**/
static int	AbortMapTaskforceAux(RmTask Task, ...);

static void	AbortMapTaskforce(RmTaskforce Taskforce)
{ Debug(dbg_Mapping, ("aborting mapping"));
  (void) RmApplyTasks(Taskforce, &AbortMapTaskforceAux);
}

static int	AbortMapTaskforceAux(RmTask Task, ...)
{ RmProcessor	mapped_to;
  TaskEntry	*task_entry;
  DomainEntry	*domain_entry;
  int		i;

  mapped_to = RmFollowTaskMapping(Domain, Task);
  if (mapped_to eq RmM_NoProcessor) return(0);

  RmUnmapTask(mapped_to, Task);
  domain_entry = GetDomainEntry(mapped_to);
  task_entry   = GetTaskEntry(Task);  
  for (i = 0; i < MaxUsersPerProcessor; i++)
   if (domain_entry->AllocationTable[i].Id eq task_entry->Mapped)
    { domain_entry->AllocationTable[i].Id = 0; break; }
  domain_entry->NumberUsers--;
  task_entry->Mapped = 0;
  if (domain_entry->NumberUsers eq 0)
   if ((mapped_to->AllocationFlags & (RmF_Permanent || RmF_TfmProcessor)) eq 0)
    ReturnProcessorToPool(mapped_to);
  return(0);
}
/*}}}*/
/*{{{  CheckAvailable     : is a particular processor available */
/**
*** Check that a given processor can be allocated
**/
static bool	Map_CheckAvailable(RmProcessor match)
{ DomainEntry *domain_entry;

  if (match->AllocationFlags & RmF_Booked) return(FALSE);
  domain_entry = GetDomainEntry(match);
  if (domain_entry->NumberUsers >= MaxUsersPerProcessor) return(FALSE);
  if (domain_entry->NumberUsers > 0)
   if (match->AllocationFlags & RmF_Exclusive)
    return(FALSE);
  return(TRUE);
}
/*}}}*/
/*{{{  AllocProcessor     : map a task to a processor */

/**
*** A suitable processor has been found.
**/
static bool AllocProcessor(RmTask Template, RmProcessor match)
{ DomainEntry	*domain_entry;
  TaskEntry	*task_entry;
  int		i;

  Debug(dbg_Mapping, ("using processor %P for %T", match, Template));

  domain_entry	= GetDomainEntry(match);
  for (i = 0; i < MaxUsersPerProcessor; i++)
   if (domain_entry->AllocationTable[i].Id eq 0)
    { domain_entry->AllocationTable[i].Id = AllocationId;
      domain_entry->NumberUsers++;
      task_entry		= GetTaskEntry(Template);
      task_entry->Mapped	= AllocationId++;
      Template->MappedTo	= 0;	/* could have been -1 if PUID specified */
      RmMapTask(match, Template);
      return(TRUE);   
    }
  Debug(dbg_Mapping, ("failure, processor %P is overused", match));
  return(FALSE);
}

/*}}}*/

/*}}}*/





@


1.6
log
@fixed compile time warnings
@
text
@d17 1
a17 1
/*$Header: /hsrc/network/RCS/tfmmap.c,v 1.5 1992/09/30 16:02:45 bart Exp nickc $*/
d72 1
a72 1
static RmProcessor	GetFromPool(RmProcessor template, int *rc);
d77 1
a77 1
{ RmProcessor		template	= (RmProcessor) NULL;
d88 1
a88 1
  template = request->Processor;
d90 1
a90 1
  if (template->StructType eq RmL_Existing)
d93 1
a93 1
     result = RmFindProcessor(Domain, template->Uid);
d96 1
a96 1
       if ((result = GetFromPool(template, &rc)) eq (RmProcessor)NULL)
d102 1
a102 1
  { char *puid = RmGetObjectAttribute((RmObject) template, "puid", FALSE);
d109 1
a109 1
         if ((result = GetFromPool(template, &rc)) eq (RmProcessor) NULL)
d122 1
a122 1
   		template, &LeastBusy, &LowestCost);
d126 1
a126 1
    { result = GetFromPool(template, &rc);
d163 1
a163 1
  if (template->AllocationFlags & RmF_Exclusive)
d197 1
a197 1
  RmProcessor	template;
d204 1
a204 1
  template	= va_arg(args, RmProcessor);
d213 1
a213 1
	/* If the processor does not match the template's requirements	*/
d215 1
a215 1
  unless(MatchProcessor(Processor, template)) return(0);
d332 1
a332 1
		RmRequest *request, RmReply *reply, RmNetwork template);
d343 1
a343 1
{ RmNetwork	template = RmNewNetwork();
d353 1
a353 1
     RmAddtailProcessor(template, junk);
d356 1
a356 1
  ReallyObtainNetwork(connection, JobId, request, reply, template);
d365 1
a365 1
		RmRequest  *request, RmReply *reply, RmNetwork template)
d375 1
a375 1
  number_to_get = number_to_match = RmCountProcessors(template);
d381 1
a381 1
  number_to_match -= RmApplyProcessors(template, &ObtainNetwork_Search1, Connection, result);
d385 1
a385 1
  number_to_match -= RmApplyProcessors(template, &ObtainNetwork_Search2, Connection, result);
d390 1
a390 1
        number_to_match -= GetNetworkFromPool(template, Connection, result);
d395 1
a395 1
  number_to_match -= RmApplyProcessors(template, &ObtainNetwork_Search3, Connection, result);
d473 1
a473 1
  RmNetwork	new;
d482 6
a487 6
  new		= RmNewNetwork();
  if (new eq (RmNetwork)NULL) return(RmE_ServerMemory);
  strcpy(new->DirNode.Name, Processor->ObjNode.Name);
  new->StructType = RmL_Obtained;
  if (RmAddtailProcessor(parent, (RmProcessor) new) eq (RmProcessor) NULL)
   { RmFreeNetwork(new); return(RmE_Corruption); }
d490 1
a490 1
   return(RmSearchNetwork(actual, &BuildHierarchyAux, new));
d505 1
a505 1
static int	 ObtainNetwork_Search1(RmProcessor template, ...)
d510 1
a510 1
  va_start(args, template);
d515 1
a515 1
  template->ObjNode.Account	= TfmProcessor->ObjNode.Account;
d517 1
a517 1
  RmSetProcessorPrivate(template, 0);
d519 2
a520 2
  if (template->StructType eq RmL_Existing)
   { RmProcessor match = RmFindProcessor(Domain, template->Uid);
d522 2
a523 2
     Debug(dbg_Allocate, ("request for existing processor %P", template));
     RmSetProcessorPrivate(template, 1);
d528 2
a529 2
     if (CheckAvailable(match, Connection, template))
      if (MoveProcessor(template, match, result, Connection))
d531 1
a531 1
     RmFreeProcessor(RmRemoveProcessor(template));
d535 1
a535 1
  { char *puid = RmGetObjectAttribute((RmObject) template, "puid", FALSE);
d540 1
a540 1
       RmSetProcessorPrivate(template, 1);
d543 2
a544 2
       if (CheckAvailable(match, Connection, template))
        if (MoveProcessor(template, match, result, Connection))
d546 1
a546 1
       RmFreeProcessor(RmRemoveProcessor(template));
d551 2
a552 2
  if (RmGetObjectAttribute((RmObject) template, "NEW", TRUE) ne Null(char))
   RmSetProcessorPrivate(template, 1);
d565 1
a565 1
static int	 ObtainNetwork_Search2(RmProcessor template, ...)
d571 1
a571 1
  va_start(args, template);
d576 1
a576 1
  if (RmGetProcessorPrivate(template) eq 1) return(0);
d578 1
a578 1
  		 template, Connection);
d582 1
a582 1
  if (MoveProcessor(template, match, result, Connection))
d590 1
a590 1
  RmProcessor	template;
d598 1
a598 1
  template   = va_arg(args, RmProcessor);
d605 2
a606 2
  unless(MatchProcessor(real, template)) return(0);
  unless(CheckAvailable(real, Connection, template)) return(0);
d625 1
a625 1
static int	 GetNetworkFromPool(RmNetwork template, TfmConn Connection,
d630 1
a630 1
  obtained = RmObtainNetwork(template, FALSE, &rc);
d645 1
a645 1
  return(RmApplyProcessors(template, &GetNetworkFromPool_Aux3, Connection, result));
d667 1
a667 1
static int GetNetworkFromPool_Aux3(RmProcessor template, ...)
d673 1
a673 1
  va_start(args, template);
d678 1
a678 1
  match = RmFindMatchingProcessor(template, Domain);
d680 1
a680 1
  if (MoveProcessor(template, match, result, Connection))
d691 1
a691 1
static int	 ObtainNetwork_Search3(RmProcessor template, ...)
d697 1
a697 1
  va_start(args, template);
d702 1
a702 1
  if (RmGetProcessorPrivate(template) eq 1) return(0);
d704 1
a704 1
  		 template, Connection);
d708 1
a708 1
  if (MoveProcessor(template, match, result, Connection))
d716 1
a716 1
  RmProcessor	template;
d724 1
a724 1
  template   = va_arg(args, RmProcessor);
d728 2
a729 2
  unless(MatchProcessor(real, template)) return(0);
  unless(CheckAvailable(real, Connection, template)) return(0);
d771 1
a771 1
		RmProcessor template)     
d778 1
a778 1
         (template->AllocationFlags & RmF_Exclusive))
d796 1
a796 1
static bool MoveProcessor(RmProcessor template, RmProcessor real, 
d812 1
a812 1
  new_proc->MappedTo		= template->Uid;
d818 1
a818 1
  if (template->AllocationFlags & RmF_Exclusive)
d826 2
a827 2
  RmRemoveProcessor(template);
  RmFreeProcessor(template);
d923 1
d1029 1
a1029 1
static RmProcessor GetFromPool(RmProcessor template, int *rc_ptr)
d1038 2
a1039 2
  template->ObjNode.Account	= TfmProcessor->ObjNode.Account;
  result = RmObtainProcessor(template);
d1062 1
a1062 1
  if ((template->AllocationFlags & RmF_Exclusive) ne 0)
d1077 1
d1131 1
a1131 1
{ RmProcessor		template	= (RmProcessor) NULL;
d1146 4
a1149 4
         { template = RmNewProcessor();
           if (template eq (RmProcessor) NULL) goto done;
           RmAddProcessorAttribute(template, &(puid[-5]));
           if ((result = GetFromPool(template, &rc)) eq (RmProcessor) NULL)
d1171 2
a1172 2
      template = RmNewProcessor();
      if (template ne (RmProcessor) NULL)
d1174 2
a1175 2
         RmSetProcessorType(template, RmGetTaskType(task));
         RmSetProcessorMemory(template, RmGetTaskMemory(task));
d1188 1
a1188 1
                RmAddProcessorAttribute(template, real_attribs[i]);
d1193 1
a1193 1
         result = GetFromPool(template, &rc);
d1219 1
a1219 1
  if (template ne (RmProcessor) NULL) RmFreeProcessor(template);  
d1225 1
a1225 1
  RmTask	template;
d1232 1
a1232 1
  template	= va_arg(args, RmTask);
d1241 1
a1241 1
	/* If the processor does not match the template's requirements	*/
d1243 1
a1243 1
  unless(MatchTask(Processor, template)) return(0);
d1316 1
d1318 1
d1355 1
d1522 1
d1570 1
d1722 1
d1734 1
a1734 1
{ RmNetwork	template = RmNewNetwork();
d1738 1
a1738 1
  if (template eq (RmNetwork) NULL) goto fail;
d1742 1
a1742 1
  if (RmSearchTasks(Taskforce, &Map_BuildTemplate, template) ne RmE_Success)
d1745 2
a1746 2
  obtained = RmObtainNetwork(template, FALSE, &rc);
  RmFreeNetwork(template);
d1770 2
a1771 2
  RmNetwork	template;
  RmProcessor	new;
d1775 1
a1775 1
  template = va_arg(args, RmNetwork);
d1780 3
a1782 3
  new = RmNewProcessor();
  if (new eq (RmProcessor) NULL) return(1);
  new->ObjNode.Account	= TfmProcessor->ObjNode.Account;
d1787 3
a1789 3
         (RmAddProcessorAttribute(new, &(puid[-5])) ne RmE_Success) ||
         (RmAddtailProcessor(template, new) eq (RmProcessor) NULL) )
      { RmFreeProcessor(new); return(1); }
d1793 2
a1794 2
  RmSetProcessorType(new, RmGetTaskType(Task));
  RmSetProcessorMemory(new, RmGetTaskMemory(Task));
d1806 1
a1806 1
      { RmFreeProcessor(new); return(1); }
d1809 1
a1809 1
      RmAddProcessorAttribute(new, real_attribs[i]);
d1813 2
a1814 2
  if (RmAddtailProcessor(template, new) eq (RmProcessor) NULL)
   { RmFreeProcessor(new); return(1); }
d1872 1
d1876 1
a1876 1
static bool AllocProcessor(RmTask template, RmProcessor match)
d1881 1
a1881 1
  Debug(dbg_Mapping, ("using processor %P for %T", match, template));
d1888 1
a1888 1
      task_entry		= GetTaskEntry(template);
d1890 2
a1891 2
      template->MappedTo	= 0;	/* could have been -1 if PUID specified */
      RmMapTask(match, template);
d1897 1
@


1.5
log
@Fixed various potential buglets revealed by C40 C compiler
@
text
@d17 1
a17 1
/*$Header: /hsrc/network/RCS/tfmmap.c,v 1.4 1992/07/21 11:04:51 bart Exp $*/
d50 1
d118 1
a118 1
   LowestCost	= MaxInt;
d236 1
d291 1
d441 1
a441 1
    tab = (RmUidTableEntry **) Malloc(Domain->NoTables * sizeof(RmUidTableEntry *));
d868 1
d1106 1
d1157 1
a1157 1
   LowestCost	= MaxInt;
d1179 1
a1179 1
             real_attribs = (char **) Malloc(attribs * sizeof(char *));
d1262 1
d1794 1
a1794 1
      real_attribs = (char **) Malloc(attribs * sizeof(char *));
@


1.4
log
@1) cleaned up the diagnostics routines
2) now uses RmLookupProcessor instead of TfmLookupProcessor
3) fixed bug in executing mapped taskforces through the Resource Management
   library.
@
text
@d17 1
a17 1
/*$Header: /users/bart/hsrc/network/RCS/tfmmap.c,v 1.3 1992/04/24 15:47:49 bart Exp $*/
d996 1
@


1.3
log
@There was a problem in the network allocation code, a linked list not
being initialised
@
text
@d17 1
a17 1
/*$Header: /users/bart/hsrc/network/RCS/tfmmap.c,v 1.2 1992/03/25 18:03:41 bart Exp $*/
d105 1
a105 1
       result = LookupProcessor(Domain, puid);
d139 1
a139 1
  Debug(dbg_Allocate, ("selected processor %s", result->ObjNode.Name));
d257 1
a257 1
  Debug(dbg_Release, ("processor affected is %s", Processor->ObjNode.Name));
d519 1
a519 2
     Debug(dbg_Allocate, ("request for existing processor %s",\
     		template->ObjNode.Name));
d534 1
a534 1
     { RmProcessor match = LookupProcessor(Domain, puid);
d802 1
a802 1
  Debug(dbg_Allocate, ("processor %s has been allocated", real->ObjNode.Name));
d887 1
a887 1
     Debug(dbg_Release, ("releasing processor %s", Processor->ObjNode.Name));
d982 1
a982 1
  Debug(dbg_Release, ("automatic processor release activated on %x", Processor));
d1007 1
a1007 1
  Debug(dbg_Release, ("returning processor %s to the system pool", Processor->ObjNode.Name));  
d1135 1
a1135 1
       result = LookupProcessor(Domain, puid);
d1199 1
a1199 1
  Debug(dbg_Mapping, ("selected processor %s", result->ObjNode.Name));
d1206 2
a1207 2
   { Debug(dbg_Mapping, ("processor %s is overused", Procname(result));
     rc = RmE_InUse);
d1447 1
a1447 1
  supplied = RmFindProcessor(Domain, task->MappedTo);
d1457 2
a1458 2
   { Debug(dbg_Create, ("component %s has been mapped already to processor %s",\
		Taskname(task), Procname(domain_proc)));
d1499 1
a1499 1
   { Debug(dbg_Create, ("failed to obtain mapped processor for component %s", Taskname(task)));
d1528 2
a1529 2
   { Debug(dbg_Mapping, ("component %s, puid has been specified", Taskname(task)));
     match = LookupProcessor(Domain, puid);
d1550 1
a1550 1
  match = LookupProcessor(Domain, puid);
d1552 1
a1552 1
   { Debug(dbg_Mapping, ("component %s, cannot satisfy PUID %s", Taskname(task), puid));
d1685 1
a1685 1
   { Debug(dbg_Mapping, ("cannot map %s in the current domain", task->ObjNode.Name));
d1865 1
a1865 1
  Debug(dbg_Mapping, ("using processor %s for %s", Procname(match), Taskname(template)));
d1878 1
a1878 1
  Debug(dbg_Mapping, ("failure, processor %s is overused", Procname(match)));
@


1.2
log
@Various changes including:
1) first attempt at C40 support
2) RmLib execute support (not yet fully tested)
3) faster bootstrap, taskforce load, and better mapping
@
text
@d17 1
a17 1
/*$Header: /users/bart/hsrc/network/RCS/tfmmap.c,v 1.1 1992/01/15 11:07:10 bart Exp $*/
a86 2
  unless(Connection->FullAccess)
   { rc = RmE_NoAccess; goto done; }
a418 1

d812 1
d849 2
a850 1
{ (void) RmApplyProcessors(Network, &CleanOutAux1);
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
/*$Header: /users/bart/netbak/RCS/tfmjobs.c,v 1.3 1991/08/21 16:07:10 bart Exp $*/
d19 1
d40 2
a41 1

d43 1
d48 2
a49 1

d107 1
a107 1
       result = LookupProcessor(Domain, ++puid);
d143 1
a143 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(result);
d186 1
a186 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(real);
d220 1
a220 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(Processor);
d237 2
a238 1
  
d267 1
a267 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(Processor);
d289 2
a290 1

d365 1
a365 2
{ int		start_from	= request->Arg1;
  int		number_to_match;
d538 1
a538 1
     { RmProcessor match = LookupProcessor(Domain, ++puid);
d603 1
a603 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(real);
d643 1
d662 1
a662 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(Processor);
d697 1
a697 1
  
d719 5
a723 2
  DomainEntry	*domain_entry;
    
a728 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(real);
d756 1
a756 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(Processor);
d776 1
a776 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(match);
d829 1
a829 1
  domain_entry	= (DomainEntry *) RmGetProcessorPrivate(real);
d867 2
a868 1

a870 3
BLV A minor enhancements would be to collect together all the processors
BLV being released and call RmReleaseNetwork for the Network Server, but
BLV the savings are not worthwhile except for big networks
d898 1
a898 1
     domain_entry = (DomainEntry *) RmGetProcessorPrivate(Processor);
d919 12
d932 20
d983 1
a983 1
  domain_entry		= (DomainEntry *) RmGetProcessorPrivate(Processor);
d1016 1
a1016 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(Processor);
d1048 1
a1048 1
     domain_entry = (DomainEntry *) RmGetProcessorPrivate(result);
d1055 1
d1073 1
d1075 28
a1126 1
  DomainEntry		*domain_entry;
a1127 1
  int			i;
d1137 1
a1137 1
       result = LookupProcessor(Domain, ++puid);
a1198 1
	/* BLV - check processor purpose as well */
d1202 10
a1211 17
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(result);
  if (domain_entry->NumberUsers >= MaxUsersPerProcessor)
   { rc = RmE_InUse; goto done; }
  for (i = 0; i < MaxUsersPerProcessor; i++)    
   if (domain_entry->AllocationTable[i].Id eq 0)
    { domain_entry->AllocationTable[i].Id = AllocationId;
      break;
    }
  RmMapTask(result, task);
  { TaskEntry	*task_entry = GetTaskEntry(task);
    task_entry->Mapped = AllocationId++;
  }
  Debug(dbg_Mapping, ("successfully obtained a processor"));
  rc = RmE_Success;
  domain_entry->NumberUsers++;
  LastChange = result->ObjNode.Dates.Access = GetDate();
  
d1241 1
a1241 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(Processor);
d1258 2
a1259 2


d1275 1
a1275 1
  domain_entry	= (DomainEntry *) RmGetProcessorPrivate(processor);
d1307 3
a1309 1

d1314 6
a1319 1
*** 2) as a first step, walk down the template and look for 
d1323 1
a1323 1
*** 3) second step, try to match tasks in the template with processors
d1325 3
a1327 2
***    following a match assign the processor
*** 4) the template now contains only tasks which cannot be matched
d1330 11
a1340 5
*** 5) Two searches are made of the taskforce, to try to find a mapping
***    where every processor has a reasonable number of components.
*** 6) If the taskforce is still not mapped, a check is made to ensure that
***    it can be mapped at all.
*** 7) a final search is made in the template, to see if a less satisfactory
d1344 1
a1344 6
*** 7) the results are processed.
BLV
BLV the current algorithm only works for simple cases. What should happen
BLV is an initial search of the template, putting the processors into a
BLV linked list in order of how restrictive the template is. The processors
BLV should then be processed in that list order.
d1346 7
a1352 3

static int	MapTaskforce_Search1(RmTask, ...);
static int	MapTaskforce_Search2(RmTask, ...);
d1354 1
a1354 1
static int	Map_GetNetworkFromPool(RmTaskforce);
d1359 5
a1363 1
bool		domain_MapTaskforce(RmTaskforce Taskforce)
d1374 7
a1380 1
  number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_Search1);
d1384 2
a1385 2
  Debug(dbg_Mapping, ("examining domain for suitable processors"));
  number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_Search2, 0);
d1391 1
a1391 2
     number_to_match -= Map_GetNetworkFromPool(Taskforce);
     if (number_to_match <= 0) goto finished;
d1393 5
a1397 3
  
  Debug(dbg_Mapping, ("trying to make do with existing processors, limit 1"));
  number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_Search2, 1);
d1399 2
d1402 4
d1410 1
a1410 1
  for (limit = 2; limit < MaxComponentsPerProcessor; limit++)
d1412 1
a1412 1
     number_to_match -= RmApplyTasks(Taskforce, &MapTaskforce_Search2, limit);
d1424 1
d1426 1
d1428 87
a1514 2
*** The first phase in the mapping algorithm. For every task in the
*** template that has a puid:
d1522 3
a1524 7
static int	 MapTaskforce_Search1(RmTask template, ...)
{   
  if (template->MappedTo > 0) return(0);
  
  { char *puid = RmGetObjectAttribute((RmObject) template, "puid", FALSE);
    if (puid ne Null(char))
     { RmProcessor match = LookupProcessor(Domain, ++puid);
d1526 8
a1533 3
       Debug(dbg_Mapping, ("puid has been specified"));
       if (match eq (RmProcessor) NULL)
        { template->MappedTo = -1; return(0); }
d1535 5
a1539 5
       if (AllocProcessor(template, match))
         return(1);
       return(100000);
     }
  }
d1543 18
d1562 15
a1576 7
*** Phase 2 of the search. For every processor left in the template
*** that has not yet been mapped, search the domain
*** for a suitable processor. The number of existing users of that processor
*** is important, and a limit is passed as argument. The first time only
*** completely free processors will be used. If there are no completely
*** free processors more are obtained from the pool. If there are still
*** unmapped tasks the restrictions are gradually reduced.
d1578 2
a1579 1
static int	 MapTaskforce_Search2Aux(RmProcessor, ...);
d1581 1
a1581 1
static int	 MapTaskforce_Search2(RmTask template, ...)
d1583 1
d1585 3
a1587 4
  int		UsageLimit;
  
  va_start(args, template);
  UsageLimit = va_arg(args, int);
a1588 7
  
	/* If a puid was specified and this gets called after the	*/
	/* first search and after more processors have been obtained,	*/
	/* the mapping cannot be achieved.				*/
  if ((template->MappedTo eq -1) && (UsageLimit > 0))
   return(100000);
  if (template->MappedTo ne 0) return(0);   		
d1590 4
a1593 7
  match = (RmProcessor) RmSearchProcessors(Domain, &MapTaskforce_Search2Aux,
  		 template, UsageLimit);
  if (match eq (RmProcessor) NULL) return(0);
   
  if (AllocProcessor(template, match))
   return(1);
  else
d1595 2
d1599 1
a1599 1
static	int MapTaskforce_Search2Aux(RmProcessor real, ...)
d1601 2
a1602 2
  RmTask	template;
  int		UsageLimit;
d1604 4
a1607 4
    
  va_start(args, real);
  template	= va_arg(args, RmTask);
  UsageLimit	= va_arg(args, int);
d1609 10
a1618 7
  
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(real);
  if (domain_entry->NumberUsers > UsageLimit) return(0);
  
  unless(Map_CheckAvailable(real)) return(0);
  unless(MatchTask(real, template)) return(0);
  return((int) real);
d1621 55
d1708 2
a1709 1
  
a1716 1
*** 4) Do another two RmApplyTaskforces, checking for puids and 0 usage
a1718 1
static int	Map_CheckPuids(RmTask Task, ...);
d1720 1
a1720 1
static int	 Map_GetNetworkFromPool(RmTaskforce Taskforce)
a1723 1
  int		sum = 0;
d1725 1
a1725 1
  if (template eq (RmNetwork) NULL) goto final_check;
d1730 1
a1730 1
   goto final_check;
d1734 1
a1734 1
  if (obtained eq (RmNetwork) NULL) goto final_check;
d1741 1
a1741 1
     return(0);
d1745 1
d1749 4
a1752 8
  sum += RmApplyTasks(Taskforce, &MapTaskforce_Search1);
  sum += RmApplyTasks(Taskforce, &MapTaskforce_Search2, 0);
  
final_check:
  if (RmSearchTasks(Taskforce, &Map_CheckPuids))
   return(100000);
  else
   return(sum);
d1806 2
a1807 8
static int	Map_CheckPuids(RmTask Task, ...)
{ 
  if (Task->MappedTo eq -1)
   return(1);
  else
   return(0);
}

d1829 1
a1829 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(mapped_to);
d1841 2
a1842 2
  

d1850 1
a1850 1
  domain_entry = (DomainEntry *) RmGetProcessorPrivate(match);
d1857 2
a1858 1

d1869 1
a1869 1
  domain_entry	= (DomainEntry *) RmGetProcessorPrivate(match);
d1873 6
a1878 1
      break;
d1880 2
a1881 6
  domain_entry->NumberUsers++;
  task_entry		= GetTaskEntry(template);
  task_entry->Mapped	= AllocationId++;
  template->MappedTo	= 0;	/* could have been -1 if PUID specified */
  RmMapTask(match, template);
  return(TRUE);   
d1883 7
@
