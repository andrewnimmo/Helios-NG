head	1.31;
access;
symbols
	Helios_C40_1_3_Official_Release:1.29
	Alenia_release:1.26
	Helios1_3:1.25
	C40_Field_Test_2:1.24
	C40_Field_Test_R1:1.21
	Helios13_beta:1.21
	Helios1_2_2_Fault:1.17
	Helios1_2_2_Native:1.16
	Helios1_2_2_native_beta:1.16
	Helios1_2_2:1.15
	Helios1_2_2Beta:1.15
	Helios1_2_1:1.14
	Helios1_2:1.12;
locks; strict;
comment	@ * @;


1.31
date	93.08.12.12.02.43;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	93.08.11.10.36.11;	author bart;	state Exp;
branches;
next	1.29;

1.29
date	93.04.20.10.48.26;	author bart;	state Exp;
branches;
next	1.28;

1.28
date	93.01.13.11.07.56;	author bart;	state Exp;
branches;
next	1.27;

1.27
date	93.01.08.12.32.18;	author bart;	state Exp;
branches;
next	1.26;

1.26
date	92.12.14.15.31.30;	author bart;	state Exp;
branches;
next	1.25;

1.25
date	92.10.26.19.14.32;	author bart;	state Exp;
branches;
next	1.24;

1.24
date	92.09.15.18.24.33;	author bart;	state Exp;
branches;
next	1.23;

1.23
date	92.07.21.11.01.08;	author bart;	state Exp;
branches;
next	1.22;

1.22
date	92.07.10.16.46.21;	author bart;	state Exp;
branches;
next	1.21;

1.21
date	92.06.08.12.07.01;	author bart;	state Exp;
branches;
next	1.20;

1.20
date	92.06.07.16.28.35;	author bart;	state Exp;
branches;
next	1.19;

1.19
date	92.05.08.16.36.25;	author bart;	state Exp;
branches;
next	1.18;

1.18
date	92.03.25.18.03.41;	author bart;	state Exp;
branches;
next	1.17;

1.17
date	92.01.15.11.04.39;	author bart;	state Exp;
branches;
next	1.16;

1.16
date	92.01.14.14.20.34;	author bart;	state Exp;
branches;
next	1.15;

1.15
date	91.05.18.12.07.09;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	91.03.01.17.20.08;	author bart;	state Exp;
branches;
next	1.13;

1.13
date	90.12.17.14.26.37;	author bart;	state Exp;
branches;
next	1.12;

1.12
date	90.12.02.13.53.34;	author bart;	state Exp;
branches;
next	1.11;

1.11
date	90.12.01.15.34.30;	author bart;	state Exp;
branches;
next	1.10;

1.10
date	90.11.25.20.02.40;	author bart;	state Exp;
branches;
next	1.9;

1.9
date	90.11.02.20.38.40;	author bart;	state Exp;
branches;
next	1.8;

1.8
date	90.11.01.16.14.17;	author bart;	state Exp;
branches;
next	1.7;

1.7
date	90.11.01.14.51.46;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	90.10.18.14.12.26;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	90.10.18.13.26.39;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	90.09.27.13.28.24;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	90.09.24.18.48.46;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	90.09.20.17.42.14;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	90.09.12.14.38.58;	author jon;	state Exp;
branches;
next	;


desc
@@


1.31
log
@fixed compile time warnings
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- netserv.c								--
--                                                                      --
--	The main module of the Network Server				--
--                                                                      --
--	Author:  BLV 1/5/90						--
--                                                                      --
------------------------------------------------------------------------*/
/* RcsId: $Header: /hsrc/network/RCS/netserv.c,v 1.30 1993/08/11 10:36:11 bart Exp nickc $*/

/*{{{  version number and history */
static char *VersionNumber = "3.29";
/**
*** History :
*** 	      3.00, initial version
***           3.01, internal development
***           3.02, 1.2 beta 0 release
***           3.03, 1.2 beta 1 release
***           3.04, developed at Parsytec, 22.10.90-30.10.90
***           3.05, finishing off for the official 1.2 release
***           3.06, the real release
***	      3.07, first post 1.2 version
***           3.08, every processor now has a PUID attribute
***           ...
***           3.20, native network support added
***           3.21, cleaned up network agent interaction
***           3.22, cleaned up communication, added support for session ids
***           3.23, fault tolerance work
***           3.24, change of rmlib-server communication to sockets
***           3.25, further changes to netagent comms
***           3.26, C40 changes, plus fixed a memory corruption bug
***           3.27, C40 version now supports IDRom
***           3.28, minor fixes for final C40 release
***           3.29, memory reduction exercise for C40 1.3.1 release
**/
/*}}}*/
/*{{{  headers and compile-time options */
#define	__Netserv_Module
#define __NetworkServer

#include <stdio.h>
#include <syslib.h>
#include <servlib.h>
#include <link.h>
#include <sem.h>
#include <codes.h>
#include <string.h>
#include <stdlib.h>
#include <root.h>
#include <stdarg.h>
#include <posix.h>
#include <signal.h>
#include <ctype.h>
#include <stddef.h>
#include <nonansi.h>
#include <process.h>
#include <sys/socket.h>
#include <sys/un.h>
#include "exports.h"
#include "private.h"
#include "netutils.h"
#include "rmlib.h"
#include "netaux.h"

	/* Compile-time debugging options	*/
#define Use_Malloc_Debugging		0
#define Use_Objects_Debugging		0
#define ShowHeap_Debugging		0
#define Use_IOC_Debugging		0
#define Default_Diagnostics_Options	0
#define Use_Ports_Debugging		0
/*}}}*/
/*{{{  forward declarations and statics */
/**
*** Forward declarations.
**/
static void		do_open(ServInfo *);
static void		do_private(ServInfo *);
static void		show_startup(void);
static void		accept_rmlib(void);
static void		abort_socket(int);

/**
*** Variables, static and global ones
**/       
	char		ProcessorName[IOCDataMax];
	Object		*ThisProcessor;
	RmNetwork	Net;
	RmTaskforce	DefaultTaskforce;
	RmProcessor	RootProcessor = RmM_NoProcessor;
	RmProcessor	BootIOProcessor = RmM_NoProcessor;
static	Object		*NameEntry;
	char		NetworkName[NameMax];
	int		NumberProcessors = 0;
	Object		*NetAgent = Null(Object);
	bool		FullReset		= FALSE;
	bool		SilentMode		= FALSE;
static	bool		ReceivedNetwork		= FALSE;
static	bool		NameInstalled		= FALSE;
static	Stream		*DiagnosticsStream	= Null(Stream);
static	Stream		*DefaultDiagnostics	= Null(Stream); 
static	Semaphore	LibraryLock;
static	NetworkFuncs	Functions;
	WORD		DebugOptions		= Default_Diagnostics_Options;
	WORD		LastChange;
	RmProcessor	LastBooted		= RmM_NoProcessor;
static	int		Socket_ctos		= -1;
static	int		Socket_stoc		= -1;
	char		**nsrc_environ		= NULL;
	
static DispatchInfo NetservInfo =
	{ Null(DirNode),
	  NullPort,
	  SS_NetServ,
	  Null(char),
	  { do_private, NS_Stack },
	  {
	  	 { do_open,		NS_Stack	},
	  	 { InvalidFn,		0		},	/* Create */
	  	 { DoLocate,		0		},
	  	 { DoObjInfo,		0		},
	  	 { InvalidFn,		0		}, /* ServerInfo */
	  	 { InvalidFn,		0		}, /* Delete */
	  	 { InvalidFn,		0		}, /* Rename */
	  	 { InvalidFn,		0		}, /* Link   */
	  	 { DoProtect,		0		},
	  	 { InvalidFn,		0		}, /* SetDate */
	  	 { DoRefine,		0		},
	  	 { NullFn,		0		}, /* CloseObj */
	  	 { InvalidFn,		0		}, /* Revoke */
	  	 { InvalidFn,		0		}, /* reserved1 */
	  	 { InvalidFn,		0		}  /* reserved2 */
	  }
};
/*}}}*/
/*{{{  main() */
/**
*** main()
***
*** 1) check the arguments, to ensure that the Network Server was started
***    up by the Startns program.
***
*** 2) fill in the various structures, ready for starting up the server
***    Locate the network agent program
***
*** 3) call the various initialisation routines in the other modules
***
*** 4) Fork off a thread to accept incoming RmLib connections
***
*** 5) create the name table entry, storing the result in a static so that
***    it can be deleted when a terminate request has been received.
***
*** 6) call the dispatcher
***
*** Note that the Startns utility tries very hard to ensure that this program
*** runs only on the root processor.
**/

int main(int argc, char **argv)
{
#if Use_Malloc_Debugging
  PatchMalloc();
#endif
#if Use_Objects_Debugging
  PatchObjects();
#endif
#if Use_IOC_Debugging
  PatchIOC(1);
#endif
#if Use_Ports_Debugging
  PatchPorts();
#endif

#ifndef __TRAN
  SetPriority(HighServerPri);
#endif

  signal(SIGPIPE, SIG_IGN);
  
  DiagnosticsStream = DefaultDiagnostics = fdstream(1);
  InitSemaphore(&(LibraryLock), 1);
  MRSW_Init();

  LastChange = GetDate();
      
/**
*** Arguments : argv[0] = "startns-magic", just to confuse people
***             argv[1] = "-r"
***		argv[2] = "-q"
***		argv[3] = debugging options
***		argv[4]-> nsrc options
**/   
  argc		= argc;
  if (strcmp(*argv, "startns-magic"))
   { fatal("please use startns to start up the networking software");
     exit(1);
   }
  show_startup();
  
  if (!strcmp(argv[1], "-r")) FullReset		= TRUE;
  if (!strcmp(argv[2], "-q")) SilentMode	= TRUE;
  { char *temp = argv[3];
    for ( ; *temp ne '\0'; temp++)
     switch(*temp)
      { case	'b'	: DebugOptions |= dbg_Boot;	break;
        case	'e'	: DebugOptions |= dbg_Execute;	break;
        case	'a'	: DebugOptions |= dbg_Allocate;	break;
        case	'r'	: DebugOptions |= dbg_Release;	break;
        case	'm'	: DebugOptions |= dbg_Monitor;	break;
        case	'p'	: DebugOptions |= dbg_Problem;	break;
        case	'l'	: DebugOptions |= dbg_Links;	break;
	case	'i'	: DebugOptions |= dbg_Initialise;break;
	case	'n'	: DebugOptions |= dbg_Native;	break;
	case	'c'	: DebugOptions |= dbg_Comms;	break;
      }
  }   
  nsrc_environ = &(argv[4]);

  NetAgent = Locate(CurrentDir, NetAgentCode);
  if (NetAgent eq Null(Object))
   fatal("failed to locate network program %s", NetAgentCode);
  if (get_config("preload_netagent", nsrc_environ) ne Null(char))
   { Object	*loader = Locate(Null(Object), "/loader");
     Object	*link;
     if (loader ne Null(Object))
      { if (Link(loader, objname(NetAgent->Name), NetAgent) >= Err_Null)
         { Stream *tmp = Open(loader, objname(NetAgent->Name), O_ReadOnly);
	   if (tmp ne NULL)
	    { Close(tmp);	/* Sole purpose of Open is to load the code */
	      link = Locate(loader, objname(NetAgent->Name));
              if (link ne Null(Object))
               { 	/* Now that the code is loaded it can be protected */
	         Protect(link, NULL, 0x05050585);	/* rea:re;re:re */
	         Close(NetAgent);
                 NetAgent = link;
               }
            }
	 }
        Close(loader);
      }
   }
   
  Net = RmNewNetwork();
  if (Net eq (RmNetwork)NULL)
   fatal("insufficient memory to initialise");
  strcpy(Net->DirNode.Name, "ns");
  NetservInfo.Root = (DirNode *) Net;
  NetworkName[0] = '\0';
  
  if (MachineName(ProcessorName) ne Err_Null)
   fatal("MachineName failure");
   
  ThisProcessor = Locate(Null(Object), ProcessorName);
  if (ThisProcessor eq Null(Object))
   fatal("failed to locate own processor");

  if ((NetservInfo.ReqPort = NewPort()) eq NullPort)
   fatal("unable to allocate a message port");

	/* Initialise the constant table of network functions	*/
  Functions.report		= (VoidFnPtr) &report;
  Functions.fatal		= (VoidFnPtr) &fatal;
  Functions.LookupProcessor	= (WordFnPtr) &RmLookupProcessor;
  Functions.rexec		= (WordFnPtr) &rexec;
  Functions.BuildConfig		= (WordFnPtr) &BuildTRANConfig;
  Functions.StartNetworkAgent	= (WordFnPtr) &StartNetworkAgent;
  Functions.StopNetworkAgent	= (WordFnPtr) &StopNetworkAgent;
  Functions.XchNetworkAgent	= (WordFnPtr) &XchNetworkAgent;
  
	/*  Call initialisation code in the other modules.	*/
  InitBootstrap();
  InitMonitor();
  InitAlloc();
  InitNative();
  InitMisc();

	/* Prepare to receive incoming rmlib requests.		*/
  unless(Fork(AcceptRmLib_Stack, &accept_rmlib, 0))
   fatal("failed to spawn thread to handle incoming connections");
  
	/* Enter the name in the name table */
  { NameInfo name;
    name.Port   = NetservInfo.ReqPort;
    name.Flags  = Flags_StripName;
    name.Matrix = DefDirMatrix;		/* for now - will get updated later */
    name.LoadData = Null(WORD);
    NameEntry = Create(ThisProcessor, "ns", Type_Name, sizeof(NameInfo),
      (BYTE *) &name);
    if (NameEntry eq Null(Object))
     fatal("failed to enter name in name table, error code %x",
           Result2(ThisProcessor));
  }

  NameInstalled = TRUE;
  
  Dispatch(&NetservInfo);

	/* Dispatch returns when the name table entry is deleted by	*/
	/* TerminateNetworkServer() below.				*/	
  forever Delay(30 * 60 * OneSec);
  
  return(0);
}
/*}}}*/
/*{{{  diagnostics routines */
/*----------------------------------------------------------------------------*/
/**
*** Usual diagnostics routines.
**/
static char	output_buffer[256];
static char	*int_to_string(char *buffer, int x);

static int	process_format(char *init, char *format, va_list args)
{ char	*dest;
  char	*null_str= "<null>";

  strcpy(output_buffer, init);
  
  for (dest = output_buffer + strlen(output_buffer); *format ne '\0'; format++)
   { if (*format ne '%')
      { *dest++ = *format; continue; }
     switch (*(++format))
      { case	'\0': *dest++ = '%'; format--; break;
        case	'%' : *dest++ = '%'; break;
        case    'c' : *dest++ = (char) va_arg(args, int); break;

	case	'W' :	/* C40 string in Global memory, for device drivers.		*/
#ifdef __C40		/* Assumes netserv and driver are loaded into the same strobe	*/
		      { char		buf[80], *temp;
			int		format_mp, code_mp;

			format_mp   = (int)  va_arg(args, char *);
			format_mp >>= 2;
			format_mp  += (int) _DataToFuncConvert(NULL);
			code_mp     = (int) &process_format;
			code_mp    &= 0xC0000000;
			format_mp  |= code_mp;
			MP_GetData(buf, format_mp, 0, 80 / sizeof(int));
			for (temp = buf; *temp ne '\0'; *dest++ = *temp++);
			break;
		      }
#endif	/* for non-C40, 'W' == 's' so just drop through	*/

        case	's' : { char	*temp = va_arg(args, char *);
			if (temp eq Null(char)) temp = null_str;
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
	case	'S' : { Stream	*x = va_arg(args, Stream *);
			char	*temp;
			if (x eq NULL) 
			 temp = null_str;
			else
			 temp = x->Name;
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
	case	'O' : { Object *x = va_arg(args, Object *);
			char	*temp;
			if (x eq NULL) 
			 temp = null_str;
			else
			 temp = x->Name;
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
	case	'P' :
	case	'N' :
	case	'T' : { RmProcessor x = va_arg(args, RmProcessor);
			char	*temp;
			if (x eq NULL) 
			 temp = null_str;
			else
			 temp = x->ObjNode.Name;
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
        case	'x' : { int	x = va_arg(args, int);
        		int	shift;
        		*dest++ = '0'; *dest++ = 'x';
        		for (shift = 28; shift >= 0; shift -= 4)
        		 { int temp = (x >> shift) & 0x0F;
        		   if (temp <= 9)
        		    *dest++ = '0' + temp;
        		   else 
        		    *dest++ = 'a' + temp - 10;
        		 }
        		break;
        	      }
	case	'd' : { int	temp = va_arg(args, int);
	   		dest = int_to_string(dest, temp);
	   		break;
		      }  

	case	'L' : { int   temp = va_arg(args, int);
			char *str;
			switch(temp)
			 { case RmL_NotConnected : str = "NotConnected"; break;
			   case RmL_Dumb	 : str = "Dumb"; break;
			   case RmL_Intelligent  : str = "Running"; break;
			   case RmL_Pending	 : str = "Pending"; break;
			   case RmL_Dead	 : str = "Dead"; break;
			   default		 : str = "<unknown>";
			 }
			while (*str ne '\0') *dest++ = *str++;
			break;
		      }
		      
	default	    : *dest++ = '%'; *dest++ = *format; break;
      }
    }
  if (DiagnosticsStream->Flags & Flags_Interactive)
   *dest++ = '\r';
  *dest++ = '\n';
  return(dest - output_buffer);
}

static char	*int_to_string_aux(char *buffer, unsigned int i)
{ if (i > 9) buffer = int_to_string_aux(buffer, i / 10);
  *buffer++	= (i % 10) + '0';
  return(buffer);
}

static char	*int_to_string(char *buffer, int x)
{ if (x < 0) { x = -x; *buffer++ = '-'; }
  return(int_to_string_aux(buffer, (unsigned int ) x));
}

void fatal(char *format, ...)
{ va_list	list;
  int		length;
  static	char *message = "ns: error is fatal, exiting.\n";
  
  Wait(&(LibraryLock));
  va_start(list, format);
  length = process_format("ns: ", format, list);
  va_end(list);

  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  (void) Write(DiagnosticsStream, message, strlen(message), -1);
  Signal(&LibraryLock);

  if (NameInstalled) (void) Delete(NameEntry, Null(char));

	/* If the sockets have been created, get rid of them	*/
  if (Socket_ctos >= 0) abort_socket(Socket_ctos);
      
  Exit(EXIT_FAILURE << 8);
}

static void abort_socket(int fd)
{ struct sockaddr_un	address;
  int			sock_ctos = -1;
  int			sock_stoc = -1;
  Stream		*real_socket	= fdstream(fd);
  int			len;
  Capability		cap;

  sock_ctos = socket(AF_UNIX, SOCK_STREAM, 0); 
  if (sock_ctos < 0) goto done;
  sock_stoc = socket(AF_UNIX, SOCK_STREAM, 0);
  if (sock_stoc < 0) goto done;

  address.sun_family	= AF_UNIX;
  strcpy(address.sun_path, objname(real_socket->Name));
  len = sizeof(address.sun_family) + strlen(address.sun_path) + 1;

  if (connect(sock_ctos, (struct sockaddr *) &address, len) < 0) goto done;

  address.sun_family	= AF_UNIX;
  strcpy(address.sun_path, objname(real_socket->Name));
  len = strlen(address.sun_path);
  address.sun_path[len - 1] = 'c';
  address.sun_path[len - 4] = 's';
  len = sizeof(address.sun_family) + strlen(address.sun_path) + 1;
  
  if (connect(sock_stoc, (struct sockaddr *) &address, len) < 0) goto done;

  memset(&cap, 0, sizeof(Capability));
  (void) write(sock_ctos, (BYTE *) &cap, sizeof(Capability));
  len	= -1;
  (void) write(sock_ctos, (BYTE *) &len, sizeof(len));

done:
  if (sock_ctos >= 0) close(sock_ctos);
  if (sock_stoc >= 0) close(sock_stoc);
}

void report(char *format, ...)
{ va_list	args;
  int		length;  
  
  va_start(args, format);
  
  Wait(&LibraryLock);
  length = process_format("ns: ", format, args);
  va_end(args);
  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  Signal(&LibraryLock);
}

void debug(char *format, ...)
{ va_list	args;
  int		length;
  
  va_start(args, format);
  
  Wait(&LibraryLock);
  length = process_format("ns.debug: ", format, args);
  va_end(args);
  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  Signal(&LibraryLock);
}
  
static void show_startup(void)
{ int	length;
  strcpy(output_buffer, "Network Server version ");
  strcat(output_buffer, VersionNumber);
  strcat(output_buffer, ".\n");
  length = strlen(output_buffer);
  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  strcpy(output_buffer, "Resource Management library version ");
  strcat(output_buffer, RmVersionNumber);
  strcat(output_buffer, ".\n");
  length = strlen(output_buffer);
  (void) Write(DiagnosticsStream, output_buffer, length, -1);
}
/*}}}*/
/*{{{  Terminate the Network Server */
/**
*** Terminate the Network Server cleanly. This is used mainly in joinnet,
*** when the subnet has been integrated and the subnet's Network Server
*** should exit. It is important to destroy
*** the ctos and stoc sockets as soon as possible, to prevent further
*** clients connecting to this server. 
**/
void	TerminateNetworkServer(void)
{
  if (Socket_ctos >= 0)
   { struct sockaddr_un	 address;
     int		 sock_ctos	= -1;
     int		 sock_stoc	= -1;
     Stream		*real_socket	= fdstream(Socket_ctos);
     int		 len;
     Capability		 cap;

     sock_ctos = socket(AF_UNIX, SOCK_STREAM, 0);
     if (sock_ctos < 0) goto done;
     sock_stoc = socket(AF_UNIX, SOCK_STREAM, 0);
     if (sock_stoc < 0) goto done;

     address.sun_family	= AF_UNIX;
     strcpy(address.sun_path, objname(real_socket->Name));
     len = sizeof(address.sun_family) + strlen(address.sun_path) + 1;

     if (connect(sock_ctos, (struct sockaddr *) &address, len) < 0) goto done;

     address.sun_family = AF_UNIX;
     strcpy(address.sun_path, objname(real_socket->Name));
     len = strlen(address.sun_path);
     address.sun_path[len - 1] = 'c';
     address.sun_path[len - 4] = 's';
     len = sizeof(address.sun_family) + strlen(address.sun_path) + 1;

     if (connect(sock_stoc, (struct sockaddr *) &address, len) < 0) goto done;

     memset(&cap, 0, sizeof(Capability));
     (void) write(sock_ctos, (BYTE *) &cap, sizeof(Capability));
     len = -1;
     (void) write(sock_ctos, (BYTE *) &len, sizeof(len));

done:
     if (sock_ctos >= 0) close(sock_ctos);
     if (sock_stoc >= 0) close(sock_stoc);
   }

  Delete(NameEntry, Null(char));
  FreePort(NetservInfo.ReqPort);
  Delay(15 * OneSec);	/* to let the netagents finish */
  Exit(0);  
}
/*}}}*/
/*{{{  Kick the Session Manager when a problem has been detected */
	/* A little utility to inform the Session Manager when it	*/
	/* should check its world, e.g. after a processor crash.	*/
	/* This sends a private protocol IOC message to /sm, with a	*/
	/* capability for the Network Server. The Session Manager can	*/
	/* use this capability to validate the source of the message.	*/
void KickSessionManager(void)
{ MsgBuf	*m = New(MsgBuf);
  Object	*session_manager = Locate(Null(Object), "/sm/Windows");
  Capability	cap;

  if ((m eq Null(MsgBuf)) || (session_manager eq Null(Object)))
   goto done;

  Debug(dbg_Problem, ("reporting problem to the Session Manager"));

  m->mcb.Data		= m->data;
  m->mcb.Control	= m->control;

  InitMCB(&(m->mcb), MsgHdr_Flags_preserve, NullPort, NullPort,
		FC_GSP | SS_NetServ | FG_NetStatus);
  MarshalCommon(&m->mcb, session_manager, Null(char));
  NewCap(&cap, (ObjNode *) &(Net->DirNode),
		AccMask_R + AccMask_W + AccMask_D + AccMask_A);
  MarshalCap(&m->mcb, &cap);
  SendIOC(&m->mcb);

done:
  if (session_manager ne Null(Object)) Close(session_manager);
  if (m ne Null(MsgBuf)) Free(m);
}
/*}}}*/

/*{{{  do_open() */
static void do_open(ServInfo *servinfo)
{ MCB           *m          = servinfo->m;
  MsgBuf        *r;
  char          *pathname   = servinfo->Pathname;
  Port          reqport;
  ObjNode       *f;

	/* do_open() can only be used to read directories. No special	*/
	/* access rights are required.					*/
  f = GetTarget(servinfo);
  if (f eq Null(ObjNode))
   { ErrorMsg(m, EO_Object); return; }
    
  if ((f->Type & Type_Flags) ne Type_Directory)
   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return; }

  r = New(MsgBuf);
  if( r eq Null(MsgBuf))
   { ErrorMsg(m,EC_Error+EG_NoMemory); return; }

  FormOpenReply(r, m, f, Flags_Server | Flags_Closeable, pathname);
  reqport = NewPort();  
  r->mcb.MsgHdr.Reply = reqport;
  PutMsg(&r->mcb);
  Free(r);

  MRSW_GetRead();
  DirServer(servinfo, m, reqport);
  MRSW_FreeRead();
  FreePort(reqport);
}
/*}}}*/
/*{{{  do_private() - debugging options */
static void do_debug(ServInfo *servinfo);
static void do_private(ServInfo *servinfo)
{ MCB            *m          = servinfo->m;
  ObjNode        *f;

  f = GetTarget(servinfo);
  if (f eq Null(ObjNode)) 
   { ErrorMsg(m, Err_Null); return; }

	/* BLV access should be checked here, to limit debugging	*/
	/* to the system administrator.					*/

	/* All private messages must refer to the root object */
  if (f ne (ObjNode *) servinfo->DispatchInfo->Root)
   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return; }

  UnLockTarget(servinfo);

  if ((servinfo->FnCode & FG_Mask) eq FG_NetStatus)
   { HandleLinkChange(servinfo); return; }
   
  if ((servinfo->FnCode & FG_Mask) eq FG_GetInfo)
   { do_debug(servinfo); return; }
   
  if ((servinfo->FnCode & FG_Mask) ne FG_Terminate)
   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return; }

  if (get_config("single_user", nsrc_environ) eq Null(char))
   { ErrorMsg(m, EC_Error + EG_Protected + EO_Server); return; }

  ErrorMsg(m, Err_Null);

  TerminateNetworkServer();  
}

static void	do_debug(ServInfo *servinfo)
{ MCB		*m	= servinfo->m;
  IOCMsg2	*req	= (IOCMsg2 *) m->Control;
  
  if (req->Arg.Mode eq dbg_Revert)
   { DiagnosticsStream = DefaultDiagnostics;
     m->MsgHdr.FnRc = 0;
     ErrorMsg(m, Err_Null);
     return;
   }
  
  if (req->Arg.Mode eq dbg_Redirect)
   { static	char	*message = "ns: output redirected\n";
     int	length	= strlen(message);
     Stream	*stream;
     WORD	index	= m->Control[6];
     StrDesc	*desc	= (StrDesc *) &(m->Data[index]);
     stream		= NewStream(desc->Name, &(desc->Cap), desc->Mode);
     stream->Pos	= desc->Pos;
     
     if (Write(stream, (BYTE *) message, length, -1) ne length)
      { ErrorMsg(m, EC_Error + EG_Open + EO_Stream);
        Close(stream);
        return;
      }
     if (DiagnosticsStream ne DefaultDiagnostics) Close(DiagnosticsStream);
     DiagnosticsStream = stream;
     m->MsgHdr.FnRc = 0;
     ErrorMsg(m, Err_Null);
     return;
   } 
   
  if (req->Arg.Mode ne dbg_Inquire)   
   DebugOptions = req->Arg.Mode;
  if (DebugOptions & dbg_Memory)
   { report("currently %d bytes are free, the heap size is %d", Malloc(-1),
   		Malloc(-3));
     DebugOptions &= ~dbg_Memory;
#if ShowHeap_Debugging
     ShowHeap();
#endif
   }
  if (DebugOptions & dbg_Lock)
   { MRSW_Info	buf;
     MRSW_GetInfo(&buf);
     report("lock status: ar %d, rr %d, aw %d, rw %d, sw %d",
		buf.ar, buf.rr, buf.aw, buf.rw, buf.sw);
     DebugOptions &= ~dbg_Lock;
   }
#if Use_IOC_Debugging
  if (DebugOptions & dbg_IOC)
   { ShowIOC();
     DebugOptions &= ~dbg_IOC;
   }
#endif

  m->MsgHdr.FnRc = DebugOptions;
  ErrorMsg(m, Err_Null);  
}
/*}}}*/

/*{{{  accept RmLib connection */
/**-----------------------------------------------------------------------------
*** The main purpose of the Network Server is to support requests generated
*** by the Resource Management library. This is done via Unix-domain sockets.
*** The Network Server has a thread running continuously accepting new
*** connections from clients, and this will start up a ConnectionGuardian thread
*** per connection.
**/
static	void	connection_guardian(NsConn);

static	void	accept_rmlib(void)
{ struct sockaddr	address;
  int			next_connection = 0;
  int			len;
  Capability		cap;
  NsConn		new_conn;

  Socket_ctos	= socket(AF_UNIX, SOCK_STREAM, 0);
  Socket_stoc	= socket(AF_UNIX, SOCK_STREAM, 0);
  if ((Socket_ctos < 0) || (Socket_stoc < 0))
   fatal("unable to set up sockets");

  address.sa_family	= AF_UNIX;
  strcpy(address.sa_data, ".NS_ctos");
  if (bind(Socket_ctos, &address, sizeof(address)) ne 0)
   fatal("failed to bind socket name");

  address.sa_family	= AF_UNIX;
  strcpy(address.sa_data, ".NS_stoc");
  if (bind(Socket_stoc, &address, sizeof(address)) ne 0)
   fatal("failed to bind socket name");

  listen(Socket_ctos, SOMAXCONN);
  listen(Socket_stoc, SOMAXCONN);

  forever
   { new_conn = Malloc(sizeof(NsConnStruct));
     if (new_conn eq (NsConn) NULL)
      { Delay(2 * OneSec); continue; }

     InitSemaphore(&(new_conn->WriteLock), 1);
     InitList(&(new_conn->Processors));
     new_conn->Id = next_connection++;

     while ((new_conn->Socket_ctos = accept(Socket_ctos, NULL, NULL)) < 0)
      Delay(5 * OneSec);

	/* Pray that the client has not crashed in between...	*/
     new_conn->Socket_stoc = accept(Socket_stoc, NULL, NULL);

	/* Perform some initial communication to ensure that things	*/
	/* are working.							*/
     if (read(new_conn->Socket_ctos, (BYTE *) &cap, sizeof(Capability))
		ne sizeof(Capability))
      goto fail;

	/* Check that a capability has been supplied, that it is a	*/
	/* valid capability, and that it gives the required access.	*/
     new_conn->FullAccess	= FALSE;
     if (cap.Access ne 0)
      if (GetAccess(&cap, Net->DirNode.Key))
       if (cap.Access & AccMask_D)
        new_conn->FullAccess	= TRUE;

     if (read(new_conn->Socket_ctos, (BYTE *) &(new_conn->Program), sizeof(int)) ne sizeof(int))
      goto fail;

     if (new_conn->Program eq -1)
      { close(new_conn->Socket_ctos);
        close(new_conn->Socket_stoc);
        goto terminate;
      }

     len = 0;
     if (write(new_conn->Socket_stoc, (BYTE *) &len, sizeof(int)) ne sizeof(int))
      goto fail;

	/* System library calls are currently preferred, because	*/
	/* timeouts are necessary for fault tolerance.			*/
     new_conn->Pipe_ctos = fdstream(new_conn->Socket_ctos);
     new_conn->Pipe_stoc = fdstream(new_conn->Socket_stoc);

	/* Spawn a connection guardian and accept the next connection	*/
     if (Fork(ConnectionGuardian_Stack, &connection_guardian, sizeof(NsConn), new_conn))
      continue;

fail:
     close(new_conn->Socket_ctos);
     close(new_conn->Socket_stoc);
     Free(new_conn);
   }  

terminate:
  close(Socket_ctos);
  close(Socket_stoc);
}
/*}}}*/
/*{{{  the ConnectionGuardian thread */

/**
*** The ConnectionGuardian process. Essentially this is just another
*** dispatcher. It reads two integers from the pipe, a job id and
*** a request code.
**/

typedef void NsRequestHandler(NsConn, int, RmRequest *, RmReply *);
typedef struct	NsRequestTableEntry {
	int			FnCode;
	bool			Protected;
	bool			WriteLock;
	NsRequestHandler	*handler;
} NsRequestTableEntry;
	
static void	HandleStartns		(NsConn, int, RmRequest *, RmReply *);
static void	HandleRegisterTfm	(NsConn, int, RmRequest *, RmReply *);
static void	HandleGetId		(NsConn, int, RmRequest *, RmReply *);
static NsConn	FindConnection		(RmProcessor);

NsRequestTableEntry	request_handlers[] =
{
 { RmC_Startns,			FALSE,	TRUE,	HandleStartns		},
 { RmC_GetNetwork,		FALSE,	FALSE,	HandleGetNetwork	},
 { RmC_GetNetworkHardware,	FALSE,	FALSE,	HandleGetNetwork	},
 { RmC_GetHierarchy,		FALSE,	FALSE,	HandleGetNetwork	},
 { RmC_ObtainProcessor,		TRUE,	FALSE,	HandleObtainProcessor	},
 { RmC_ReleaseProcessor,	TRUE,	FALSE,	HandleReleaseProcessor	},
 { RmC_LastChange,		FALSE,	FALSE,	HandleLastChange	},
 { RmC_ObtainExactNetwork,	TRUE,	FALSE,	HandleObtainNetwork	},
 { RmC_ObtainNetwork,		TRUE,	FALSE,	HandleObtainNetwork	},
 { RmC_ReleaseNetwork,		TRUE,	FALSE,	HandleReleaseNetwork	},
 { RmC_GetLinkMode,		FALSE,	FALSE,	HandleGetLinkMode	},
 { RmC_SetLinkMode,	/* ? */	FALSE,	FALSE,	HandleSetLinkMode	},
#if Joinnet_Supported
 { RmC_AcceptNetwork,		FALSE,	FALSE,	HandleAcceptNetwork	},
 { RmC_JoinNetwork,		FALSE,	FALSE,	HandleJoinNetwork	},
#endif
 { RmC_IsProcessorFree,		FALSE,	FALSE,	HandleIsProcessorFree	},
#if Native_Supported
 { RmC_SetNative,		TRUE,	TRUE,	HandleNative		},
 { RmC_ResetProcessors,		TRUE,	FALSE,	HandleNative		},
 { RmC_Reboot,			TRUE,	TRUE,	HandleNative		},
 { RmC_TestConnections,		FALSE,	TRUE,	HandleConnections	},
 { RmC_MakeConnections,		TRUE,	TRUE,	HandleConnections	},
 { RmC_Revert,			TRUE,	TRUE,	HandleConnections	},
#endif
 { RmC_GetId,			TRUE,	FALSE,	HandleGetId		},
 { RmC_RegisterTfm,		TRUE,	FALSE,	HandleRegisterTfm	},
 { RmC_ReportProcessor,		TRUE,	FALSE,	HandleReportProcessor	},
 { -1,				FALSE,	FALSE,	NULL			}
};

 
static void connection_guardian(NsConn connection)
{ int		job_id;
  RmRequest	request;
  RmReply	reply;
  Stream	*pipe	= connection->Pipe_ctos;
  bool		broken	= FALSE;
  int		i;
  word		rc;

  while (!broken)
   { 
     Clear(request); Clear(reply);
	 
     rc = Read(pipe, (BYTE *) &job_id, sizeof(int), 70 * OneSec);
     if (rc <= 0)
      { if (connection->Program eq Rm_Session)
	 report("warning, Session Manager has terminated");
	goto broken;
      }

     if ((job_id & RmR_Private) ne 0)
      { if ((job_id & ~RmR_Private) eq RmR_Synch) continue;
        IOdebug("Netserv : private protocol received down pipe");
        continue;
      }

     rc = FullRead(pipe, (BYTE *) &request, sizeof(RmRequest), -1);
     if (rc ne sizeof(RmRequest)) goto broken;

     if ((request.Network ne (RmNetwork) NULL) ||
         (request.Taskforce ne (RmTaskforce) NULL))
      if ((rc = RmReadStream(pipe, &(request.Network), &(request.Taskforce)))
          ne RmE_Success)
       goto broken;

     if (request.Processor ne (RmProcessor) NULL)
      if ((rc = RmReadProcessor(pipe, &(request.Processor), FALSE))
          ne RmE_Success)
       goto broken;

     if (request.Task ne (RmTask) NULL)
      if ((rc = RmReadTask(pipe, &(request.Task), FALSE))
          ne RmE_Success)
       goto broken;

     if (request.VariableSize > 0)
      { request.VariableData = Malloc(request.VariableSize);
        if (request.VariableData eq NULL)
         goto broken;
        if (FullRead(pipe, request.VariableData, request.VariableSize, -1) < 0)
	 goto broken;
      }

     if (DebugOptions & dbg_Comms)
      debug("request %x, jobid %x, Network %N, \n          Taskforce %T, Processor %P, Task %T, size %d",
		request.FnRc, job_id, request.Network, request.Taskforce, 
		request.Processor, request.Task,
		request.VariableSize);

     for (i = 0; request_handlers[i].handler ne NULL; i++)
      if (request.FnRc eq request_handlers[i].FnCode)
       break;
     if (request_handlers[i].handler ne NULL)
      { if (request_handlers[i].Protected && !(connection->FullAccess))
	 { reply.FnRc	= RmE_NoAccess;
	   ReplyRmLib(connection, job_id, &reply);
         }
        else
	 { if (request_handlers[i].WriteLock)
	    MRSW_GetWrite();
	   else
	    MRSW_GetRead();
           (*request_handlers[i].handler)(connection, job_id, &request, &reply);
	   if (request_handlers[i].WriteLock)
	    MRSW_FreeWrite();
	   else
	    MRSW_FreeRead();
         }
      }
     else
      { report("unexpected request %x", request.FnRc);
	broken = TRUE;
      }

     if (request.Network ne (RmNetwork) NULL) RmFreeNetwork(request.Network);
     if (request.Taskforce ne (RmTaskforce) NULL) RmFreeTaskforce(request.Taskforce);
     if (request.Processor ne (RmProcessor) NULL) RmFreeProcessor(request.Processor);
     if (request.Task ne (RmTask) NULL) RmFreeTask(request.Task);
     if (request.VariableData ne NULL) Free(request.VariableData);

	/* the connection may have been broken synchronously or	*/
	/* asynchronously, via ReplyRmLib() or as a result of a	*/
	/* detected crash and a call to RemConnection().	*/
     if (connection->Pipe_ctos eq Null(Stream)) goto done;
   }

broken:
	/* Write()s do not appear to timeout, this should avoid deadlocks */
	/* at the risk of Abort(NULL), I think.				  */
  Abort(connection->Pipe_stoc);
  MRSW_GetRead();	/* Necessary to manipulate owned processors	*/
  AbortConnection(connection);
  MRSW_FreeRead();

done:
  Free(connection);
}

/*}}}*/
/*{{{  ReplyRmLib() - send a reply back to a client */
/**
*** This is called from a request handler called by the above
*** ConnectionGuardian() to send a reply back to the client. It will
*** be called with at least a read lock.
**/
int ReplyRmLib(NsConn connection, int job_id, RmReply *reply)
{ int		rc 	= RmE_CommsBreakdown;
  Stream	*pipe	= connection->Pipe_stoc;

  if (DebugOptions & dbg_Comms)
   debug("reply %x, jobid %x, Network %N,\n          Taskforce %T, Processor %P, Task %T, size %d",
	reply->FnRc, job_id, reply->Network, reply->Taskforce,
	reply->Processor, reply->Task, reply->VariableSize);

  Wait(&(connection->WriteLock));
  if (Write(pipe, (BYTE *) &job_id, sizeof(int), -1) ne sizeof(int))
   goto fail;

  if (Write(pipe, (BYTE *) reply, sizeof(RmReply), -1) ne sizeof(RmReply))
   goto fail;

  if ((reply->Network ne (RmNetwork) NULL) ||
      (reply->Taskforce ne (RmTaskforce) NULL))
   if ((rc = RmWriteStream(pipe, reply->Network, reply->Taskforce, reply->Filter))
       ne RmE_Success)
    goto fail;

  if (reply->Processor ne (RmProcessor) NULL)
   if ((rc = RmWriteProcessor(pipe, reply->Processor, reply->Filter))
       ne RmE_Success)
    goto fail;

  if (reply->Task ne (RmTask) NULL)
   if ((rc = RmWriteTask(pipe, reply->Task, reply->Filter))
       ne RmE_Success)
    goto fail;

  if (reply->VariableSize > 0)
   if (Write(pipe, reply->VariableData, reply->VariableSize, -1)
       ne reply->VariableSize)
    { rc = RmE_CommsBreakdown; goto fail; }

  Signal(&(connection->WriteLock));
  return(RmE_Success);

fail:
  Signal(&(connection->WriteLock));
  AbortConnection(connection);
  return(rc);
}
/*}}}*/
/*{{{  connection-related exception handling */
/**
*** If a processor disappears from the network, e.g. because an
*** external subnet has disconnected, and this processor is owned
*** then the processor has to be removed from the connection and
*** the owner has to be informed. This routine will be called
*** with a write lock.
***
*** The routine may also be called if the network server decides to
*** reclaim a processor from its current owner. The reason can be one
*** of RmR_Crashed or RmR_Reclaimed.
***
*** Locking status: this routine is called with a write lock so there
*** can be no processor allocation, freeing, or modification happening.
*** If the processor is currently owned by a connection then it will
*** have a session id other than -1. Hence this provides a safe check.
***
*** Care has to be taken if the connection is breaking or broken...
**/

void RemConnection(RmProcessor processor, int reason)
{ ProcessorEntry	*proc_entry;
  NsConn		connection;

  Debug(dbg_Problem, ("checking ownership of %P", processor));

  connection = FindConnection(processor);
  if (connection eq (NsConn) NULL) return;

	/* Now inform the owner about what has happened. This is only	*/
	/* possible if there is still an owner...			*/
	/* If this processor is running the session's TFM, ouch !!!	*/
  if (processor->ObjNode.Flags & NsFlags_TfmProcessor)
   { Debug(dbg_Problem, ("TFM processor has gone, aborting connection"));
     AbortConnection(connection);
     return;
   }

  if (connection->Pipe_stoc ne Null(Stream))
   { InformConnection(processor, reason);
     processor->SessionId	= -1;
     proc_entry = GetProcEntry(processor);
     Remove(&(proc_entry->Connection));
   }
}

void InformConnection(RmProcessor processor, int reason)
{ NsConn	connection = FindConnection(processor);
  int		x;
  Stream	*pipe;

  if (connection eq (NsConn) NULL) return;
  if (connection->Pipe_stoc eq Null(Stream)) return;

  Debug(dbg_Problem, ("informing owning client about %P", processor));

  Wait(&(connection->WriteLock));
  pipe = connection->Pipe_stoc;
  reason |= RmR_Private;
  if (Write(pipe, (BYTE *) &reason, sizeof(word), 10 * OneSec) ne sizeof(word)) goto fail;
  x = sizeof(word);	/* data size */
  if (Write(pipe, (BYTE *) &x, sizeof(x), 10 * OneSec) ne sizeof(x)) goto fail;
  if (Write(pipe, (BYTE *) &processor->Uid, sizeof(RmUid), 10 * OneSec) ne sizeof(RmUid)) goto fail;
  Signal(&(connection->WriteLock));
  return;

fail:
  Signal(&(connection->WriteLock));
  Debug(dbg_Problem, ("failed to write to owning client"));
}

/**
*** This routine aborts a connection if there is a communication failure
*** with the relevant client. It may be called from the ConnectionGuardian
*** or ReplyRmLib() with a read lock, or from RemConnection() if the TFM
*** processor has crashed, with a write lock. 
**/
void AbortConnection(NsConn connection)
{
  if (connection->Pipe_stoc ne Null(Stream))
   { connection->Pipe_stoc	= Null(Stream);
     connection->Pipe_ctos	= Null(Stream);
     Abort(fdstream(connection->Socket_stoc));
     Abort(fdstream(connection->Socket_ctos));
     close(connection->Socket_ctos);
     close(connection->Socket_stoc);
   }
  unless(EmptyList_(connection->Processors))
   { Debug(dbg_Problem, ("AbortConnection, releasing processors"));
     WalkList(&(connection->Processors), &AutomaticRelease);
   }
}

/**
*** utility to find the connection owning this processor, if any.
**/
static NsConn	FindConnection(RmProcessor processor)
{ NsConn		connection;
  Node			*node;
  ProcessorEntry	*proc_entry;
  int			i = NumberProcessors + 1;	/* safety */

  if (processor->SessionId eq -1) return((NsConn) NULL);

  proc_entry = GetProcEntry(processor);
  node = &(proc_entry->Connection);
  while ((Prev_(Node, node) ne Null(Node)) && (i-- > 0))
    node = Prev_(Node, node);
  if (i <= 0) return((NsConn) NULL);

  connection = (NsConn) (((BYTE *) node) - offsetof(NsConnStruct, Processors));

  return(connection);
}
/*}}}*/

/*{{{  HandleGetId() */
/**----------------------------------------------------------------------------
*** GetId(), return the Id corresponding to this connection.
**/
static void HandleGetId(NsConn connection, int job_id,
			RmRequest *request, RmReply *reply)
{
  reply->FnRc	= RmE_Success;
  reply->Reply1	= connection->Id;
  ReplyRmLib(connection, job_id, reply);
  request	= request;
}
/*}}}*/
/*{{{  HandleRegisterTFM() */
/**----------------------------------------------------------------------------
*** RegisterTfm(), allow a TFM to set the session Id of the processor
*** obtained by the Session Manager to run the TFM. Ownership of the 
*** processor is transferred from the Session Manager's connection to
*** the TFM's connection. Hence if the TFM's connection is broken this
*** processor will be cleaned up along with all the other processors owned,
*** without worrying the Session Manager. Note that the Session Manager
*** monitors all TFM's and login windows, so that it can restart a login
*** if necessary.
**/
static void HandleRegisterTfm(NsConn connection, int job_id,
			RmRequest *request, RmReply *reply)
{ RmProcessor		processor;
  int			rc = RmE_Success;
  ProcessorEntry	*proc_entry;

  if (connection->Program ne Rm_TFM)
   { rc = RmE_NoAccess; goto done; }

  processor = RmFindProcessor(Net, request->Uid);
  if (processor eq (RmProcessor) NULL)
   { rc = RmE_BadProcessor; goto done; }
  processor->SessionId		 = connection->Id;
  processor->ObjNode.Flags	|= NsFlags_TfmProcessor;

  proc_entry = GetProcEntry(processor);
  Remove(&(proc_entry->Connection));
  AddHead(&(connection->Processors),  &(proc_entry->Connection));

done:
  reply->FnRc	= rc;
  reply->Reply1 = NumberProcessors;
  ReplyRmLib(connection, job_id, reply);
}
/*}}}*/
/*{{{  HandleStartns() */

/**----------------------------------------------------------------------------
***
*** HandleStartns(). The client side will send a complete Network and
*** Taskforce, including hardware facilities. If a Network has been
*** received already then things have gone somewhat wrong. Otherwise
*** the network is processed.
*** The reply consists of the JobID, as usual, followed by a success code
*** and a capability for the Network Server.
*** N.B. The incoming network and taskforce have to be cleared out of
*** the incoming request message, or the ConnectionGuardian will free them.
**/

static void StartnsAux(RmNetwork);

static void HandleStartns(NsConn connection, int job_id, 
		RmRequest *request, RmReply *reply)
{ RmNetwork	network;

  if (ReceivedNetwork)
   { reply->FnRc	= RmE_InUse;
     ReplyRmLib(connection, job_id, reply);
     return;
   }

  network		= request->Network;
  DefaultTaskforce	= request->Taskforce;
  request->Network	= (RmNetwork) NULL;
  request->Taskforce	= (RmTaskforce) NULL;

  StartnsAux(network);   /* Sort out the data */

  reply->FnRc		= RmE_Success;
  NewCap( (Capability *) &(reply->Reply1), (ObjNode *) &(network->DirNode), 
    	AccMask_R + AccMask_W + AccMask_D + AccMask_A);
  ReplyRmLib(connection, job_id, reply);
  return;
}

/**
*** Once a network has been read in there is a lot of work to be done.
*** 1) put the network into the directory structure. This means
***    remembering the network name and making the network the root
***    directory. The old root can now be freed.
*** 2) figure out which of the processors in the network structure the
***    network server is running on.
*** 3) modify every network and processor structure, in particular fill in
***    the key, matrix and other fields. Also check every hardware facility
***    in the network, loading the device drivers, and for every processor
***    work out how many facilities affect the processor. Add a PUID
***    attribute to every processor.
*** 4) create a ProcessorEntry field for every processor. This includes
***    details of all the hardware facilities.
*** 5) call all the device driver initialisation routines.
*** 6) copy all the current links into the default links held in the
***    proc_entry field.
*** 7) count the number of processors
*** 8) work out what is to be done with the new network, by calling a
***    routine in the netboot.c module.
**/
static int		StartnsAux2(RmNetwork);
static int		StartnsAux3(RmProcessor, ...);
static int		StartnsAux4(RmHardwareFacility *, ...);
static int		StartnsAux5(RmProcessor, ...);
static int		StartnsAux6(RmNetwork, ...);
static int		StartnsAux7(RmProcessor, ...);
static int		StartnsAux8(RmHardwareFacility *, ...);
static int		StartnsAux9(RmProcessor, ...);
static RmProcessor	DetermineRoot(RmNetwork);
static RmProcessor	DetermineIO(RmProcessor);

static void	StartnsAux(RmNetwork network)
{ 
  strcpy(NetworkName, network->DirNode.Name);
  RmRootName = NetworkName;
  strcpy(network->DirNode.Name, "ns");  
  { RmNetwork old_root = (RmNetwork) NetservInfo.Root;
    Net = (RmNetwork) (NetservInfo.Root = &(network->DirNode));
    RmFreeNetwork(old_root);
  }

  NumberProcessors = RmCountProcessors(network);
  { extern void PreallocMsgBufs(int);
    PreallocMsgBufs(NumberProcessors + 4);
  }
  RootProcessor		= DetermineRoot(network);
  LastBooted		= RootProcessor;
  BootIOProcessor	= DetermineIO(RootProcessor);
  (void) StartnsAux2(network);
  (void) RmApplyProcessors(network, &StartnsAux5);
  (void) StartnsAux6(network);
  (void) RmApplyProcessors(network, &StartnsAux9);
  if ((get_config("single_user", nsrc_environ) eq Null(char)) ||
      (get_config("share_root_processor", nsrc_environ) eq Null(char)))
   RootProcessor->ObjNode.Account = RmO_System;
   
  StartBootstrap();
}

static int  StartnsAux2(RmNetwork network)
{ 
  network->DirNode.Matrix = 0x21212147;	/* rz : rz : rz : rwvd */
  network->DirNode.Key	  = NewKey() + _cputime() + (int) network;
  network->DirNode.Dates.Creation =
  network->DirNode.Dates.Modified =
  network->DirNode.Dates.Access   = GetDate();
  network->DirNode.Account	  = 0;

	/* Rearrange things so that subnets are at the back */
  if (network->NoSubnets > 0)
   { RmProcessor	current, next;
     int		i;
     next = RmFirstProcessor(network);
     for (i = 0; i < network->DirNode.Nentries; i++)
      { current = next;
        next    = RmNextProcessor(current);
        if (RmIsNetwork(current))
         { (void) Remove(&(current->ObjNode.Node));
           (void) AddTail(&(network->DirNode.Entries), &(current->ObjNode.Node));
         }
      }
   }
   
  (void) RmApplyNetwork(network, &StartnsAux3);
  (void) RmApplyHardwareFacilities(network, &StartnsAux4);
  return(0);
}

static void add_puid_attribute(RmProcessor);

static int  StartnsAux3(RmProcessor processor, ...)
{
  if (RmIsNetwork(processor)) return(StartnsAux2((RmNetwork) processor));

  processor->ObjNode.Matrix = 0x01010143;	/* r:r:r:drw */
  processor->ObjNode.Key    = GetDate() + _cputime() + (int) processor;
  processor->ObjNode.Dates.Creation = GetDate();
  processor->ObjNode.Dates.Modified = 0;
  processor->ObjNode.Dates.Access   = 0;
  if ((RmGetProcessorPurpose(processor) & RmP_System) eq 0)
   processor->ObjNode.Account = RmO_FreePool;
  else
   processor->ObjNode.Account = RmO_System;

  processor->StructType	= RmL_New;	/* ensure that the Network Server */
  					/* can fiddle with the structures */
  processor->ObjNode.Size	= 0;	/* State currently undefined.	  */
  RmSetProcessorPrivate(processor, 0);
  processor->SessionId		= -1;
  processor->ApplicationId	= -1;
  add_puid_attribute(processor);  
  return(0);
}

/**
*** Add the puid attribute in a separate routine, because it involves using
*** a lot of stack.
**/
static void add_puid_attribute(RmProcessor processor)
{ char namebuf[IOCDataMax];
  strcpy(namebuf, "PUID=");
  BuildName(&(namebuf[5]), processor);
  RmAddObjectAttribute((RmObject) processor, namebuf, TRUE);
}

/**
*** Part of the hardware initialisation. Load every device driver needed
*** by this network. Update every processor affected by this hardware
*** facility.
**/
static	void StartnsAux4_resetcommand(RmHardwareFacility *);

static int StartnsAux4(RmHardwareFacility *hardware, ...)
{ int i;

  if ((hardware->Type eq RmH_ResetDriver) || 
      (hardware->Type eq RmH_ConfigureDriver))
   { NetworkDCB	*network_dcb = New(NetworkDCB);
     if (network_dcb eq Null(NetworkDCB))
      fatal("out of memory when initialising network data structures");
     network_dcb->NetworkName		= NetworkName;
     network_dcb->Net			= (RmNetwork) NetservInfo.Root;
     network_dcb->RootProcessor		= RootProcessor;
     network_dcb->HardwareFacility	= hardware;
     network_dcb->Functions		= &Functions;
     hardware->Device = (void *) OpenDevice(hardware->Name, network_dcb);
     if (hardware->Device eq Null(void))
      fatal("failed to load device driver %s", hardware->Name);
   }

  if (hardware->Type eq RmH_ResetCommand)
   StartnsAux4_resetcommand(hardware);
   
  for (i = 0; i < hardware->NumberProcessors; i++)
   { RmProcessor processor = hardware->Processors[i];
     int temp = RmGetProcessorPrivate(processor);
     RmSetProcessorPrivate(processor, temp + 1);
   }

  return(0);
}

/**
*** Cope with reset commands. These have the following characteristics:
*** 1) hardware->Option contains the name of a processor, e.g. /Cluster/00
*** 2) hardware->Name contains a command that must be parsed,
***    e.g. -e /helios/bin/pa_reset pa_reset 3
**/

static void StartnsAux4_resetcommand(RmHardwareFacility *hardware)
{ RmTask	task = RmNewTask();
  Object	*program = Null(Object);
  RmProcessor	processor;
  char		*progname;
  char		*temp;
  int		arg = 0;
      
  processor = RmLookupProcessor(Net, hardware->Option);
  if (processor eq (RmProcessor) NULL)
   fatal("control processor %s for reset command is not in the network",
   		hardware->Option);

  hardware->Essential = processor;

  if (task eq (RmTask) NULL)
   fatal("out of memory when initialising reset command");
  hardware->Device = task;

  temp = hardware->Name;
  if ((temp[0] eq '-') && 
      ((temp[1] eq 'e') || (temp[1] eq 'E')) &&
      isspace(temp[2]))
   { RmSetTaskId(task, "1");
     temp = &(temp[3]);
   }
  else
   RmSetTaskId(task, "0");
   
  while (isspace(*temp)) temp++;
  progname = temp;
  until ((*temp eq '\0') || isspace(*temp)) temp++;
  if (*temp eq '\0') goto done_args;
  
  *temp++ = '\0';
  until (*temp eq '\0')
   { char	*argname;
     char	junk;
     
     while (isspace(*temp)) temp++;
     if (*temp eq '\0') goto done_args;
     argname = temp;
     until ((*temp eq '\0') || isspace(*temp)) temp++;
     junk = *temp;
     *temp = '\0';
     if (arg ne 0) RmAddTaskArgument(task, arg++, argname);
     arg++;
     *temp = junk;
   }
   
done_args:

  if (progname[0] eq '/')
   program = Locate(Null(Object), progname);
  else 
   { Object	*heliosbin = Locate(Null(Object), "/helios/bin");
     if (heliosbin ne Null(Object))
      { program = Locate(heliosbin, progname);
        Close(heliosbin);
      }
   }

  if (program eq Null(Object))
   fatal("failed to locate reset command %s", progname);
  else
   RmSetTaskCode(task, program->Name);
  Close(program);
}      

/**
*** For every processor in the network allocate and initialise a
*** ProcessorEntry structure. This will contain all the information
*** needed by the Network Server to maintain this processor, after
*** the remaining initialisation.
**/
static int	StartnsAux5(RmProcessor processor, ...)
{ int			hardware_count;
  int			number_links;
  int			size;
  ProcessorEntry	*proc_entry;
    
  hardware_count = RmGetProcessorPrivate(processor);
  number_links	 = RmCountLinks(processor);
  size = (hardware_count * sizeof(DriverEntry)) + 
  	 (number_links * sizeof(RmLink)) +
  	 sizeof(ProcessorEntry);
  proc_entry = (ProcessorEntry *) Malloc(size);  	 
  if (proc_entry eq Null(ProcessorEntry))
   fatal("out of memory when initialising processor data structures");
  memset((void *) proc_entry, 0, size);

  proc_entry->Incarnation	= 1;
  proc_entry->NumberDrivers	= hardware_count;
  proc_entry->DriverEntry	= (DriverEntry *)
  				((BYTE *) proc_entry + sizeof(ProcessorEntry));
  proc_entry->StandardLinks	= (RmLink *) ((BYTE *)proc_entry->DriverEntry 
                                  + (hardware_count * sizeof(DriverEntry)));
  proc_entry->Purpose		= RmGetProcessorPurpose(processor);
  proc_entry->Netagent		= Null(Stream);
  proc_entry->NetagentDate	= 0;
  proc_entry->BeingBooted	= FALSE;
  proc_entry->CommandDate	= GetDate();
  InitSemaphore(&(proc_entry->NetagentLock), 1);
  proc_entry->Processor		= processor;
  proc_entry->WindowServer	= Null(Object);
  proc_entry->ConsoleWindow	= Null(Object);
  RmSetProcessorPrivate(processor, (int) proc_entry);
  return(0);
}

/**
*** Call the initialisation routines for all the device drivers.
**/
static int  StartnsAux6(RmNetwork network, ...)
{ (void) RmApplyHardwareFacilities(network, &StartnsAux8);
  (void) RmApplyNetwork(network, &StartnsAux7);
  return(0);
}

static int  StartnsAux7(RmProcessor processor, ...)
{ if (RmIsNetwork(processor))
   return(StartnsAux6((RmNetwork) processor));
  else
   return(0);
}

static int  StartnsAux8(RmHardwareFacility *hardware, ...)
{ DriverRequest	request;
  DCB		*device;
  int		i, j;

  for (i = 0; i < hardware->NumberProcessors; i++)
   { RmProcessor	processor = hardware->Processors[i];
     ProcessorEntry	*proc_entry;
     proc_entry = GetProcEntry(processor);
     
     for (j = 0; j < proc_entry->NumberDrivers; j++)
      { DriverEntry	*driver_entry = &(proc_entry->DriverEntry[j]);
        if (driver_entry->Hardware ne Null(RmHardwareFacility)) continue;
        driver_entry->Hardware = hardware;
        switch(hardware->Type)
         { case RmH_ResetDriver : 
         	driver_entry->Flags = DriverFlags_ResetDriver; break;
           case RmH_ConfigureDriver :
           	driver_entry->Flags = DriverFlags_ConfigureDriver; break;
           case RmH_ResetCommand :
           	driver_entry->Flags = DriverFlags_ResetCommand; break;
         }
        break;
      }
   }

  if (hardware->Type eq RmH_ResetDriver)
   { device			= (DCB *) hardware->Device;
     request.FnRc		= ND_Initialise;
     request.NumberProcessors	= 0;
     (*(device->Operate))(device, &request);
     if (request.FnRc ne Err_Null)
      report("warning, failed to initialise driver %s, fault %x",
      		hardware->Name, request.FnRc);
   }
  if (hardware->Type eq RmH_ConfigureDriver)
   { device			= (DCB *) hardware->Device;
     request.FnRc		= ND_Initialise;
     request.NumberProcessors	= 0;
     (*(device->Operate))(device, &request);
     if (request.FnRc ne Err_Null)
      { report("warning, failed to initialise driver %s, fault %x",
      		hardware->Name, request.FnRc);
      	goto done;
      }

     request.FnRc		= ND_ObtainProcessors;
     request.NumberProcessors	= -1;
     (*(device->Operate))(device, &request);
     if (request.FnRc ne Err_Null)
      { report("warning, driver %s failed to obtain its processors, fault %x",
      		hardware->Name, request.FnRc);
      	goto done;
      }
     
     request.FnRc		= ND_MakeInitialLinks;
     request.NumberProcessors	= -1;
     (*(device->Operate))(device, &request);
     if (request.FnRc ne Err_Null)
      report("warning, driver %s failed to make its initial links, fault %x",
      		hardware->Name, request.FnRc);
   }

done:
  return(0);
}

/**
*** For every processor in the network, make a copy of the current links in
*** the ProcessorEntry structure. This allows the Network Server to restore
*** the default links when required. Also work out the amount of control
*** provided by the hardware drivers.
***
*** NB some device drivers may have to change the saved links, if the
*** initialisation phase has to be delayed. For example, on Telmat machines
*** the final machine configuration is not known until the initial
*** connections are made.
**/
static int	StartnsAux9(RmProcessor processor, ...)
{ ProcessorEntry	*proc_entry;
  int			number_links;
  int			i;
  int			control = RmC_FixedMapping + RmC_FixedLinks;
  int			purpose;

  proc_entry = GetProcEntry(processor);
  number_links = RmCountLinks(processor);
  for (i = 0; i < number_links; i++)
   { RmLink	*link = RmFindLink(processor, i);
     memcpy((void *) &(proc_entry->StandardLinks[i]), (void *) link,
     		sizeof(RmLink));
   }

  purpose = RmGetProcessorPurpose(processor) & RmP_Mask;
  if ((purpose eq RmP_IO) || (purpose eq RmP_Router))
   { processor->Control = RmC_FixedMapping + RmC_FixedLinks;
     return(0);
   }
   
  for (i = 0; i < proc_entry->NumberDrivers; i++)
   { DriverEntry	*driver_entry = &(proc_entry->DriverEntry[i]);
     if (driver_entry->Flags eq DriverFlags_ConfigureDriver)
      { int i, number_links, flags;
        number_links = RmCountLinks(processor);
        for (i = 0; i < number_links; i++)
         { flags = RmGetLinkFlags(processor, i);
           if (flags & RmF_Configurable)
      	    { control &=  ~RmC_FixedLinks; break; }
      	 }
      }
     if (driver_entry->Flags & DriverFlags_PossibleReset)
      control |= RmC_PossibleReset;
     if (driver_entry->Flags & DriverFlags_DefiniteReset)
      control |= RmC_Reset;
     if (driver_entry->Flags & DriverFlags_NativePossible)
      control |= RmC_Native;
     if (driver_entry->Flags & DriverFlags_MappingFlexible)
      control &= ~RmC_FixedMapping;
     if (driver_entry->Flags & DriverFlags_Reclaim)
      control |= RmC_Reclaim;
   }
  processor->Control = control;
     
  return(0);
}
/**
*** Figure out which of the processors in the network map the program
*** is running on.
*** 1) I can work out the current processor name by a system call. This
***    could be /Cluster/00, /00, or something silly.
*** 2) If the current name is /Cluster/00 then I can assume that the
***    processor has been booted up with the full network name, or that
***    a previous incarnation of the network server produced the full
***    network name. Hence I look up the name, and if the result is sensible
***    everything is happy.
*** 3) If the name is /00 or something like that matters become more difficult.
***    The network is searched for all entries that match the name.
***    If there is no match or exactly one match life is easy. If there is
***    more than one match, some heuristics have to be used. The routine
***    simply sees if any of the candidates have a root at the top level,
***    and if so that candidate is chosen. Otherwise an error message is given.
***    If there are problems the user can always resolve them via the nsrc file.
**/

static int		DetermineAux1(RmProcessor, ...);

static RmProcessor	DetermineRoot(RmNetwork network)
{ char	*temp = ProcessorName + strlen(ProcessorName);
  RmProcessor	*candidates = Null(RmProcessor);
  int		next_candidate = 0;

	/* Distinguish between /00 and /Cluster/00 */  
  for ( ; (temp > ProcessorName) && (*temp ne '/'); temp--);
  
  if (temp ne ProcessorName)
   {	/* The current processor name is already something like /Cluster/00 */
   	/* Hence I can lookup the real processor.			    */
     RmProcessor result;

     result = RmLookupProcessor(network, ProcessorName);
     if (result eq (RmProcessor) NULL)
      fatal("cannot find processor %s in the resource map", ProcessorName);
     if (RmIsProcessor(result)) return(result);
     fatal("in the resource map %s is not a processor", ProcessorName);
   }

	/* The current name is /00 or similar. Search the whole network */   
  (void) RmApplyProcessors(network, &DetermineAux1, ++temp, &candidates,
  			 &next_candidate);

  	/* If there are no candidates then something is very wrong. */
  if (next_candidate eq 0)
   fatal("none of the processors in the resource map correspond to %s",
   		ProcessorName);
   		
   	/* If there is exactly one candidate then life is easy */
  if (next_candidate eq 1)
   { RmProcessor result = candidates[0];
     Free(candidates);
     return(result);
   }

  { int	i;
    for (i = 0; i < next_candidate; i++)
     { RmProcessor processor	 = candidates[i];
       if (RmParentNetwork(processor) eq RmRootNetwork(processor))
        { Free(candidates);
          return(processor);
        }
     }
  }

  fatal("internal error determining the root of the network");
  return(NULL);
}

static int DetermineAux1(RmProcessor processor, ...)
{ va_list	args;
  char		*proc_name;
  RmProcessor	**candidates;
  int		*next_candidate;
  RmProcessor	*new_candidates;
  
  va_start(args, processor);
  proc_name		= va_arg(args, char *);
  candidates		= va_arg(args, RmProcessor **);
  next_candidate	= va_arg(args, int *);
  va_end(args);
  
	/* If the name does not match then everything is easy */
  if (strcmp(Procname(processor), proc_name)) return(0);

	/* Expand the table of candidates */
  new_candidates = (RmProcessor *)
  		Malloc((1 + (word) *next_candidate) * sizeof(RmProcessor));
  if (new_candidates eq Null(RmProcessor))
  	fatal("out of memory when determining root processor");

  if (*next_candidate ne 0)
   memcpy(new_candidates, *candidates, sizeof(RmProcessor) * *next_candidate);
  new_candidates[*next_candidate] = processor;
  *next_candidate += 1;
  if (candidates ne NULL) Free(*candidates);
  *candidates = new_candidates;
  return(0);
}

/**
*** Given the root processor, determine the I/O processor if any.
*** This must satisfy the following restrictions:
*** 1) it must be of type I/O
*** 2) the link flags for that link must have the Link_Flags_parent bit set
***
*** It is perfectly possible for there to be no I/O boot processor, if
*** the system is rom-booted.
**/
static RmProcessor	DetermineIO(RmProcessor root_processor)
{ LinkInfo	info;
  int		number_links = RmCountLinks(root_processor);
  int		i;
  
  for (i = 0; i < number_links; i++)
   { if (LinkData(i, &info) < Err_Null) continue;
     if ((info.Flags & Link_Flags_parent) && 
         (info.Mode eq Link_Mode_Intelligent))
      { RmProcessor	neighbour;
        int		destlink;
	int		purpose;
	
        neighbour = RmFollowLink(root_processor, i, &destlink);
        if (neighbour eq RmM_NoProcessor)
         { report("root processor %P was booted from link %d",
                   root_processor, i);
           fatal("the resource map has no processor on that link");
         }
	purpose = RmGetProcessorPurpose(neighbour);
	if ((purpose & RmP_Mask) eq RmP_IO) return(neighbour);
	if ((purpose & RmP_Mask) eq RmP_Native) return(RmM_NoProcessor);
	report("root processor %P was booted from link %d",
		root_processor, i);
	fatal("the resource map has an invalid processor on that link");
      }
   }
  return(RmM_NoProcessor);
}

/*}}}*/
@


1.30
log
@1) stack sizes now controlled in netaux.h
2) joinnet and native networks now supported only on particular types
   of processor
3) new version number
@
text
@d16 1
a16 1
/* RcsId: $Header: /hsrc/network/RCS/netserv.c,v 1.29 1993/04/20 10:48:26 bart Exp $*/
d851 1
d912 1
a912 1
  int		rc;
d1012 1
d1232 1
d1781 1
a1781 1
  		Malloc((1 + *next_candidate) * sizeof(RmProcessor));
d1832 1
@


1.29
log
@updated C40 debugs to cope with ir0 != 0
@
text
@d16 1
a17 3
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netserv.c,v 1.28 1993/01/13 11:07:56 bart Exp $";


d19 1
a19 1
static char *VersionNumber = "3.28";
d41 1
d123 1
a123 1
	  { do_private, 2000 },
d125 15
a139 15
	  	 { do_open,		2000 },
	  	 { InvalidFn,		2000 },	/* Create */
	  	 { DoLocate,		2000 },
	  	 { DoObjInfo,		2000 },
	  	 { InvalidFn,		2000 }, /* ServerInfo */
	  	 { InvalidFn,		2000 }, /* Delete */
	  	 { InvalidFn,		2000 }, /* Rename */
	  	 { InvalidFn,		2000 }, /* Link   */
	  	 { DoProtect,		2000 },
	  	 { InvalidFn,		2000 }, /* SetDate */
	  	 { DoRefine,		2000 },
	  	 { NullFn,		2000 }, /* CloseObj */
	  	 { InvalidFn,		2000 }, /* Revoke */
	  	 { InvalidFn,		2000 },	/* reserved1 */
	  	 { InvalidFn,		2000 }	/* reserved2 */
d285 1
a285 1
  unless(Fork(2000, &accept_rmlib, 0))
d836 1
a836 1
     if (Fork(2000, &connection_guardian, sizeof(NsConn), new_conn))
d884 1
d887 1
d889 1
d896 1
@


1.28
log
@Increased priority to a level higher than ordinary applications
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/netserv.c,v 1.27 1993/01/08 12:32:18 bart Exp bart $";
d342 1
@


1.27
log
@Incremented version number and removed compiler warning
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netserv.c,v 1.26 1992/12/14 15:31:30 bart Exp $";
d64 1
d180 4
@


1.26
log
@Added support for strings in C40 global memory to the diagnostics
routines, for use by device drivers.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /hsrc/network/RCS/netserv.c,v 1.25 1992/10/26 19:14:32 bart Exp $";
d21 1
a21 1
static char *VersionNumber = "3.27";
d42 1
d1748 1
@


1.25
log
@Now checks the device driver Reclaim flag
@
text
@d17 1
a17 1
static char *rcsid = "$Header: netserv.c,v 1.24 92/09/15 18:24:33 bart Exp $";
d56 1
d328 17
d901 1
d904 1
a904 2
   { int rc;

a1818 6






@


1.24
log
@version 3.27 supports IDRom info supplied in the resource map
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/netserv.c,v 1.23 1992/07/21 11:01:08 bart Exp $";
d1654 2
@


1.23
log
@1) tidied up the diagnostics.
2) switched from NetLookupProcessor to RmLookupProcessor
3) preloaded netagent code is now protected so that it cannot be deleted
   during cleaning.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/netserv.c,v 1.21 1992/06/08 12:07:01 bart Exp $";
d21 1
a21 1
static char *VersionNumber = "3.26";
d41 1
d266 1
a266 1
  Functions.BuildConfig		= (WordFnPtr) &BuildConfig;
@


1.22
log
@Fixed bug in network allocation code resulting in null pointer problem,
updated version number
@
text
@d40 1
d113 1
d191 1
d193 1
a193 1
  argc = argc;
d217 1
d222 1
a222 1
  if (get_config("preload_netagent", environ) ne Null(char))
d227 10
a236 4
         { link = Locate(loader, objname(NetAgent->Name));
           if (link ne Null(Object))
            { Close(NetAgent);
              NetAgent = link;
d238 1
a238 1
         }
d263 1
a263 1
  Functions.LookupProcessor	= (WordFnPtr) &LookupProcessor;
d315 1
d327 1
a327 5
			if (temp eq Null(char))
			 { *dest++ = '<'; *dest++ = 'n'; *dest++ = 'u';
			   *dest++ = 'l'; *dest++ = 'l'; *dest++ = '>';
			   break;
			 }
d331 29
d659 1
a659 1
  if (get_config("single_user", environ) eq Null(char))
d929 1
a929 1
      debug("request %x, jobid %x, Network %x, \n          Taskforce %x, Processor %x, Task %x, size %d",
d994 1
a994 1
   debug("reply %x, jobid %x, Network %x,\n          Taskforce %x, Processor %x, Task %x, size %d",
d1059 1
a1059 1
  Debug(dbg_Problem, ("checking ownership of %s", Procname(processor)));
d1089 1
a1089 1
  Debug(dbg_Problem, ("informing owning client about %s", Procname(processor)));
d1274 1
d1292 2
a1293 2
  if ((get_config("single_user", environ) eq Null(char)) ||
      (get_config("share_root_processor", environ) eq Null(char)))
d1417 1
a1417 1
  processor = LookupProcessor(Net, &(hardware->Option[1]));
d1692 1
a1692 1
     result = LookupProcessor(network, &(ProcessorName[1]));
d1783 2
a1784 2
         { report("root processor %s was booted from link %d",
                   Procname(root_processor), i);
d1790 2
a1791 2
	report("root processor %s was booted from link %d",
		Procname(root_processor), i);
@


1.21
log
@Compiled in the call to PreallocMsgbufs()
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netserv.c,v 1.20 1992/06/07 16:28:35 bart Exp bart $";
d21 1
a21 1
static char *VersionNumber = "3.25";
@


1.20
log
@Termination was not handled properly, incorporated the same socket
shutdown code used in the TFM
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netserv.c,v 1.18 1992/03/25 18:03:41 bart Exp $";
a1244 1
#if 0
a1247 1
#endif  
@


1.19
log
@1) changed the communication between netserv and netagent from pipes to
   client-server message passing
2) folded the network server sources
@
text
@d477 5
a481 1
*** Terminate the Network Server cleanly.
a484 1
	/* If the sockets have been created, get rid of them	*/
d486 35
a520 12
   { Stream	*s = fdstream(Socket_ctos);
     Object	*o = NewObject(s->Name, &(s->Access));
     close(Socket_ctos);
     Delete(o, Null(char));
     Close(o);
   }
  if (Socket_stoc >= 0)
   { Stream	*s = fdstream(Socket_stoc);
     Object	*o = NewObject(s->Name, &(s->Access));
     close(Socket_stoc);
     Delete(o, Null(char));
     Close(o);
@


1.18
log
@Various changes including:
1) first attempt at C40 support
2) RmLib execute support (not yet fully tested)
3) faster bootstrap, taskforce load, and better mapping
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netserv.c,v 1.17 1992/01/15 11:04:39 bart Exp $";
d19 3
a21 1
static char *VersionNumber = "3.24";
d39 1
d41 2
d68 9
a77 5
*** Manifests such as stacksizes etc.
**/
#define	NetAgentCode		"/helios/lib/netagent"

/**
d107 1
a107 1
	WORD		DebugOptions		= 0;
d120 1
a120 1
	  	 { do_open,		4000 },
d137 2
a138 1

d163 1
a163 1
#if 0
d166 4
a169 1
#if 1
d172 3
d294 2
a295 1

d474 4
a477 6

/**-----------------------------------------------------------------------------
*** The Server Library routines. These are fairly useless since the
*** Network Server's main job is to interact with the Resource Management
*** library, which it does via sockets. 
*** do_private is used for the terminate message and for debugging options.
d479 17
d497 40
d568 2
a569 1

d643 3
d654 1
a654 1
#if 1
d664 1
d666 1
a666 58
/**
*** Terminate the Network Server cleanly.
**/
void	TerminateNetworkServer(void)
{
	/* If the sockets have been created, get rid of them	*/
  if (Socket_ctos >= 0)
   { Stream	*s = fdstream(Socket_ctos);
     Object	*o = NewObject(s->Name, &(s->Access));
     close(Socket_ctos);
     Delete(o, Null(char));
     Close(o);
   }
  if (Socket_stoc >= 0)
   { Stream	*s = fdstream(Socket_stoc);
     Object	*o = NewObject(s->Name, &(s->Access));
     close(Socket_stoc);
     Delete(o, Null(char));
     Close(o);
   }

  Delete(NameEntry, Null(char));
  FreePort(NetservInfo.ReqPort);
  Delay(15 * OneSec);	/* to let the netagents finish */
  Exit(0);  
}

	/* A little utility to inform the Session Manager when it	*/
	/* should check its world, e.g. after a processor crash.	*/
	/* This sends a private protocol IOC message to /sm, with a	*/
	/* capability for the Network Server. The Session Manager can	*/
	/* use this capability to validate the source of the message.	*/
void KickSessionManager(void)
{ MsgBuf	*m = New(MsgBuf);
  Object	*session_manager = Locate(Null(Object), "/sm/Windows");
  Capability	cap;

  if ((m eq Null(MsgBuf)) || (session_manager eq Null(Object)))
   goto done;

  Debug(dbg_Problem, ("reporting problem to the Session Manager"));

  m->mcb.Data		= m->data;
  m->mcb.Control	= m->control;

  InitMCB(&(m->mcb), MsgHdr_Flags_preserve, NullPort, NullPort,
		FC_GSP | SS_NetServ | FG_NetStatus);
  MarshalCommon(&m->mcb, session_manager, Null(char));
  NewCap(&cap, (ObjNode *) &(Net->DirNode),
		AccMask_R + AccMask_W + AccMask_D + AccMask_A);
  MarshalCap(&m->mcb, &cap);
  SendIOC(&m->mcb);

done:
  if (session_manager ne Null(Object)) Close(session_manager);
  if (m ne Null(MsgBuf)) Free(m);
}

d762 2
a763 1

d770 8
d783 30
d817 3
a819 1
  Stream	*pipe = connection->Pipe_ctos;
d821 1
a821 1
  forever
d872 19
a890 66
     MRSW_GetRead();
     
     switch(request.FnRc)
      { case RmC_Startns :	
		HandleStartns(connection, job_id, &request, &reply);
		endcase;
	case RmC_GetNetwork :	
	case RmC_GetNetworkHardware :
	case RmC_GetHierarchy :
		HandleGetNetwork(connection, job_id, &request, &reply);
		endcase;
	case RmC_ObtainProcessor :
		HandleObtainProcessor(connection, job_id, &request, &reply);
		endcase;
	case RmC_ReleaseProcessor :
		HandleReleaseProcessor(connection, job_id, &request, &reply);
		endcase;
	case RmC_LastChange :
		HandleLastChange(connection, job_id, &request, &reply);
		endcase;
	case RmC_ObtainExactNetwork :
	case RmC_ObtainNetwork :
		HandleObtainNetwork(connection, job_id, &request, &reply);
		endcase;
	case RmC_ReleaseNetwork :
		HandleReleaseNetwork(connection, job_id, &request, &reply);
		endcase;
	case RmC_GetLinkMode :
		HandleGetLinkMode(connection, job_id, &request, &reply);
		endcase;
	case RmC_SetLinkMode :
		HandleSetLinkMode(connection, job_id, &request, &reply);
		endcase;
	case RmC_AcceptNetwork	:
		HandleAcceptNetwork(connection, job_id, &request, &reply);
		endcase;
	case RmC_JoinNetwork	:
		HandleJoinNetwork(connection, job_id, &request, &reply);
		endcase;
	case RmC_IsProcessorFree :
		HandleIsProcessorFree(connection, job_id, &request, &reply);
		endcase;
	case RmC_SetNative	 :
	case RmC_ResetProcessors :
	case RmC_Reboot		 :
		HandleNative(connection, job_id, &request, &reply);
		endcase;
	case RmC_TestConnections	:
	case RmC_MakeConnections	:
	case RmC_Revert			:
		HandleConnections(connection, job_id, &request, &reply);
		endcase;
	case RmC_GetId	:
		HandleGetId(connection, job_id, &request, &reply);
		endcase;
	case RmC_RegisterTfm :
		HandleRegisterTfm(connection, job_id, &request, &reply);
		endcase;
	case RmC_ReportProcessor :
		HandleReportProcessor(connection, job_id, &request, &reply);
		endcase;

      	default : report("unexpected request %x from pipe %s", request.FnRc,
			pipe->Name);
		  MRSW_FreeRead();
		  goto broken;
d892 4
a895 1
     MRSW_FreeRead();
a918 1
  return;
d920 2
a921 1

d972 2
a973 1

d1087 1
d1089 1
d1101 2
a1102 1

d1134 1
d1137 2
a1138 1

a1162 3
  MRSW_FreeRead();
  MRSW_GetWrite();

a1169 2
  MRSW_SwitchRead();

d1219 5
d1446 1
a1446 1
  proc_entry->NetagentPipe	= Null(Stream);
d1736 4
@


1.17
log
@Major update of networking sources, to incorporate the fault-tolerance
work as demonstrated at the IED meeting 10.1.92
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/sparkygiga/Helios/network/RCS/netserv.c,v 1.13 90/12/17 14:26:37 bart Exp $";
d324 14
d1429 2
@


1.16
log
@Major update of networking sources, to match Helios1_2_2_native_beta
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/netserv.c,v 1.4 1991/08/21 15:56:38 bart Exp $";
d19 1
a19 1
static char *VersionNumber = "3.22";
d35 2
d53 1
d55 2
a71 1
static void		do_serverinfo(ServInfo *);
d74 2
d98 1
a98 2
	WORD		DebugOptions = 0;
	Semaphore	SingleStep;
d100 3
a102 1
	RmProcessor	LastBooted = RmM_NoProcessor;
d115 1
a115 1
	  	 { do_serverinfo,	2000 },
d140 3
a142 1
*** 4) create the name table entry, storing the result in a static so that
d145 1
a145 1
*** 5) call the dispatcher
d156 3
d164 1
a164 1
  InitSemaphore(&(SingleStep), 1);
d249 5
a281 2
BLV possible improvement, check for errors from Write() and, if so, 
BLV go back to the default stream.
d359 3
d366 38
d444 4
a447 7
/**
*** The Server Library routines. The most important one is do_open().
*** In addition to simply listing the directory, Open'ing the /ns
*** directory with a private mode is used by the Resource Management
*** library for all useful work - the resulting Stream port can be
*** used without any worries about private protocols. do_serverinfo()
*** can be used to get additional information about a network or processor.
a450 3

static	void	accept_connection(MCB *, bool);

a453 1
  IOCMsg2       *req        = (IOCMsg2 *)(m->Control);
a455 1
  DirNode       *d;
d457 6
a462 2
  byte          *data = m->Data;
  bool		FullAccess = FALSE;
d464 2
a465 7
	/* In a protected mode the Network Server itself is protected	*/
	/* by a suitable capability, one Startns has sent the network	*/
	/* map. This capability should be supplied with the context	*/
	/* object of RmOpenServer(), and is checked automatically by	*/
	/* GetTargetDir().						*/
  d = (DirNode *) GetTargetDir(servinfo);
  if (d eq Null(DirNode)) { ErrorMsg(m, Err_Null); return; }
d467 3
a469 2
  f = GetTargetObj(servinfo);
  if (f eq Null(ObjNode)) { ErrorMsg(m, Err_Null); return; }
a470 36
	/* There are limitations on what can be opened. A program like	*/
	/* ls can open the root directory and any subdirectory. However,*/
	/* RmOpenServer() can open only the root directory. Under no	*/
	/* circumstances is it legal to open a processor in the network	*/
	/* because it does not make sense... I think.			*/
  if (req->Arg.Mode eq O_Private)
   { if (f ne (ObjNode *) Net)
      { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return; }
   }  
  else
   { if ((f->Type & Type_Flags) ne Type_Directory)
      { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return; }
   }

	/* When the Resource Management library does an OpenServer() to	*/
	/* the Network Server, it can do so in two ways. Normally it is	*/
	/* a read-only connection from some user application.		*/
	/* The Session Manager and Network Server, and certain system	*/
	/* programs get a special capability for the Network Server	*/
	/* to allow greater access. The Delete bit is used for this.	*/	
	/* For just reading directories etc., the access mask simply	*/
	/* has to match.						*/
  if (req->Arg.Mode eq O_Private)
   { 
     if (CheckMask(req->Common.Access.Access, AccMask_D))
      FullAccess = TRUE;
     elif (!CheckMask(req->Common.Access.Access, AccMask_R))
      { ErrorMsg(m, EC_Error + EG_Protected + EO_File); return; }
   }
  else
   { unless( CheckMask(req->Common.Access.Access,req->Arg.Mode&Flags_Mode) ) 
      { ErrorMsg(m,EC_Error+EG_Protected+EO_File); return; }
   }

  r = New(MsgBuf);
  if( r eq Null(MsgBuf)) { ErrorMsg(m,EC_Error+EG_NoMemory); return; }
d477 3
a479 53
	/* If the client is simply something like ls, let it read the	*/
	/* directory. This can be handled by the Server library. All	*/
	/* the necessary checks have been made already.			*/
  if (req->Arg.Mode ne O_Private)
   { DirServer(servinfo, m, reqport);
     FreePort(reqport);
     return;
   }

	/* The usual Stream loop, but currently without a timeout.	*/
	/* BLV - do something about timeouts.				*/
	/* The recognised messages at present are a private protocol	*/
	/* one for creating a new connection, and the GSP Close request.*/
	/* The accept_connection() is the important one, this sets up	*/
	/* general communication between client and server.		*/
  f->Account++;
  UnLockTarget(servinfo);
  forever
   { word e;
     m->MsgHdr.Dest = reqport;
     m->Timeout     = -1;
     m->Data        = data;

     e = GetMsg(m);
     if (e == EK_Timeout) break;
     if (e < Err_Null) continue;
     
     Wait(&f->Lock);
     
     m->MsgHdr.FnRc = SS_NetServ;

     if (e eq (FC_Private + RmC_Init))
      accept_connection(m, FullAccess);
     elif ((e & FC_Mask) ne FC_GSP)
      ErrorMsg(m, EC_Error + EG_WrongFn + EO_Message);
     else
      switch(e & FG_Mask)
       {
         case FG_Close :
                     if (m->MsgHdr.Reply != NullPort) ErrorMsg(m, Err_Null);
                     Signal(&f->Lock);
                     goto done;
                     
         default       :
                     ErrorMsg(m, EC_Error + SS_NetServ + EG_FnCode + EO_File);
                     break;
       }

     Signal(&f->Lock);
   }

done:
  f->Account--;
a482 33

static void do_serverinfo(ServInfo *servinfo)
{ MCB            *m          = servinfo->m;
  MsgBuf         *r;
  DirNode        *d;
  ObjNode        *f;
    
  d = (DirNode *) GetTargetDir(servinfo);
  if (d == Null(DirNode))
   { ErrorMsg(m, Err_Null);
     return;
   }
  
  f = GetTargetObj(servinfo);

  r = New(MsgBuf);
  if( r == Null(MsgBuf) )
   { ErrorMsg(m,EC_Error+EG_NoMemory);
     return;
   }

     /* Does object exist now ? */
  if (f == Null(ObjNode)) 
   { ErrorMsg(m, Err_Null);
     Free(r);
     return;
   }
   
  ErrorMsg(m, EC_Error + EG_WrongFn + EO_Server);
  Free(r);
}


a485 1
  DirNode        *d;
d488 1
a488 5
  d = (DirNode *) GetTargetDir(servinfo);
  if (d eq Null(DirNode))
   { ErrorMsg(m, Err_Null); return; }
  
  f = GetTargetObj(servinfo);
d492 2
a493 1
	/* BLV access should be checked here, to limit debugging options */
d499 2
d557 14
d579 17
a595 1
{ 
d602 37
a638 12
/**
*** Private protocol messages. The only private protocol message currently
*** sent to a stream is RmC_Init, requesting a new pipe connection. Space
*** is allocated for a suitable data structure to remember details about
*** this connection, then a ``new'' pipe is created. The current pipe
*** server does not guarantee that Create() will produce a new unique
*** object, it will fail if the specified pipe already exists. If the
*** pipe can be created and opened happily, a reply is sent to the client
*** with details of the new pipe. The Resource Management library
*** immediately opens its own end of this pipe, writes a synchronisation
*** integer, and reads one back. On this end I can now create a
*** ConnectionGuardian process.
d640 1
a640 1
static void	ConnectionGuardian(NsConn Connection);
d642 6
a647 9
static	void	accept_connection(MCB *m, bool FullAccess)
{ NsConn	Connection		= Malloc(sizeof(NsConnStruct));
  Object	*PipeServer		= Null(Object);
  Object	*NewPipe		= Null(Object);
  char		PipeName[16];
  static int	NextPipeID		= 1;
  static int	NextConnectionId	= 1;
  int		rc;
  int		retries;
d649 4
a652 12
  if (Connection eq (NsConn)NULL)
   { rc = EC_Error + EG_NoMemory + EO_Server; goto error1; }
  Connection->Pipe		= Null(Stream);
  Connection->FullAccess	= FullAccess;
  Connection->Program		= m->Control[0];
  InitSemaphore(&(Connection->WriteLock), 1);
  InitList(&(Connection->Processors));
  Connection->Id		= NextConnectionId++;
      
  PipeServer = Locate(Null(Object), "/pipe");
  if (PipeServer eq Null(Object))
   { rc = EC_Error + EG_Unknown + EO_Pipe; goto error1; }
d654 4
a657 9
	/* Attempt to create a unique pipe, but do not try very hard */
  strcpy(PipeName, "NetServ");
  addint(PipeName, NextPipeID++);
  
  NewPipe = Create(PipeServer, PipeName, Type_Pipe, 0, Null(BYTE));
  Close(PipeServer);
   
  if (NewPipe eq Null(Object))
   { rc = EC_Error + EG_Create + EO_Pipe; goto error1; }
d659 4
a662 3
  Connection->Pipe = PseudoStream(NewPipe, O_ReadWrite);
  if (Connection->Pipe eq Null(Stream))
   { rc = EC_Error + EG_Open + EO_Pipe; goto error1; }
d664 2
a665 5
	/* Send a reply back to the client with enough info for it to */
	/* open its end of the pipe */
  InitMCB(m, 0, m->MsgHdr.Reply, NullPort, Err_Null);
  MarshalStream(m, Connection->Pipe);
  if (PutMsg(m) ne Err_Null) goto error2;
d667 4
a670 2
	/* Attempt to synchronise with the client */
  rc = EC_Error;  
d672 3
a674 12
  for (retries = 0; retries < 10; retries++)
   { WORD synch;
     if (Read(Connection->Pipe, (BYTE *) &synch, sizeof(WORD), OneSec) eq
     	 sizeof(WORD))
      { rc = Err_Null; break; }
     else
      Delay(OneSec / 4);
   }
   
  if (Write(Connection->Pipe, (BYTE *) &rc, sizeof(WORD), OneSec) ne
            sizeof(WORD))
   goto error2;
d676 28
a703 2
 	/* Both sides are happy, Fork off the ConnectionGuardian() */
  unless(Fork(2000, ConnectionGuardian, 4, Connection)) goto error2;
d705 22
a726 17
  Close(NewPipe);
  
  return;
  
error1:
  ErrorMsg(m, rc);
error2:
  if (Connection ne (NsConn)NULL)
   { if (Connection->Pipe ne Null(Stream))
      Close(Connection->Pipe);
     Free(Connection);
   }
  if (NewPipe ne Null(Object))
   { (void) Delete(NewPipe, Null(char));
     Close(NewPipe);
   }
  return;
d735 4
a738 6
static void HandleStartns		(NsConn, int, RmRequest *, RmReply *);
static void HandleGetNetwork		(NsConn, int, RmRequest *, RmReply *);
static void HandleLastChange		(NsConn, int, RmRequest *, RmReply *);
static void HandleIsProcessorFree	(NsConn, int, RmRequest *, RmReply *);
static void HandleRegisterTfm		(NsConn, int, RmRequest *, RmReply *);
static void HandleGetId			(NsConn, int, RmRequest *, RmReply *);
d740 2
a741 2
static void ConnectionGuardian(NsConn Connection)
{ int		JobId;
d744 1
d751 1
a751 1
     rc = Read(Connection->Pipe, (BYTE *) &JobId, sizeof(int), 70 * OneSec);
d753 1
a753 1
      { if (Connection->Program eq Rm_Session)
d758 2
a759 2
     if ((JobId & RmR_Private) ne 0)
      { if ((JobId & ~RmR_Private) eq RmR_Synch) continue;
d764 2
a765 2
     rc = FullRead(Connection->Pipe, (BYTE *) &request, sizeof(RmRequest), -1);
     if (rc < sizeof(RmRequest)) goto broken;
d769 1
a769 1
      if ((rc = RmReadStream(Connection->Pipe, &(request.Network), &(request.Taskforce)))
d774 1
a774 1
      if ((rc = RmReadProcessor(Connection->Pipe, &(request.Processor), FALSE))
d779 1
a779 1
      if ((rc = RmReadTask(Connection->Pipe, &(request.Task), FALSE))
d787 1
a787 1
        if (FullRead(Connection->Pipe, request.VariableData, request.VariableSize, -1) < 0)
d793 1
a793 1
		request.FnRc, JobId, request.Network, request.Taskforce, 
d797 1
a797 1
     Wait(&(SingleStep));
d801 2
a802 2
		HandleStartns(Connection, JobId, &request, &reply);
		break;
d806 2
a807 2
		HandleGetNetwork(Connection, JobId, &request, &reply);
		break;
d809 2
a810 2
		HandleObtainProcessor(Connection, JobId, &request, &reply);
		break;
d812 2
a813 2
		HandleReleaseProcessor(Connection, JobId, &request, &reply);
		break;
d815 2
a816 2
		HandleLastChange(Connection, JobId, &request, &reply);
		break;
d819 2
a820 2
		HandleObtainNetwork(Connection, JobId, &request, &reply);
		break;
d822 2
a823 2
		HandleReleaseNetwork(Connection, JobId, &request, &reply);
		break;
d825 2
a826 2
		HandleGetLinkMode(Connection, JobId, &request, &reply);
		break;
d828 2
a829 2
		HandleSetLinkMode(Connection, JobId, &request, &reply);
		break;
d831 2
a832 2
		HandleAcceptNetwork(Connection, JobId, &request, &reply);
		break;
d834 2
a835 2
		HandleJoinNetwork(Connection, JobId, &request, &reply);
		break;
d837 2
a838 2
		HandleIsProcessorFree(Connection, JobId, &request, &reply);
		break;
d842 2
a843 2
		HandleNative(Connection, JobId, &request, &reply);
		break;
d847 2
a848 2
		HandleConnections(Connection, JobId, &request, &reply);
		break;
d850 2
a851 2
		HandleGetId(Connection, JobId, &request, &reply);
		break;
d853 6
a858 2
		HandleRegisterTfm(Connection, JobId, &request, &reply);
		break;
d860 2
a861 2
			Connection->Pipe->Name);
		  Signal(&SingleStep);
d864 1
a864 1
     Signal(&(SingleStep));
d871 5
a877 2
	/* Recovery code for communication failures, rather primitive	*/
	/* at present.							*/
d879 6
d886 2
a887 7
  Close(Connection->Pipe);
  unless(EmptyList_(Connection->Processors))
   { Wait(&SingleStep);
     (void) WalkList(&(Connection->Processors), &AutomaticRelease);
     Signal(&SingleStep);
   }
  Free(Connection);
d891 8
a898 2
int ReplyRmLib(NsConn Connection, int JobId, RmReply *reply)
{ int rc = RmE_CommsBreakdown;
d902 1
a902 1
	reply->FnRc, JobId, reply->Network, reply->Taskforce,
d905 2
a906 2
  Wait(&(Connection->WriteLock));
  if (Write(Connection->Pipe, (BYTE *) &JobId, sizeof(int), -1) ne sizeof(int))
d909 1
a909 1
  if (Write(Connection->Pipe, (BYTE *) reply, sizeof(RmReply), -1) ne sizeof(RmReply))
d914 1
a914 1
   if ((rc = RmWriteStream(Connection->Pipe, reply->Network, reply->Taskforce, reply->Filter))
d919 1
a919 1
   if ((rc = RmWriteProcessor(Connection->Pipe, reply->Processor, reply->Filter))
d924 1
a924 1
   if ((rc = RmWriteTask(Connection->Pipe, reply->Task, reply->Filter))
d929 1
a929 1
   if (Write(Connection->Pipe, reply->VariableData, reply->VariableSize, -1)
d933 1
a933 1
  Signal(&(Connection->WriteLock));
d937 2
a938 5
#ifdef SYSDEB
  IOdebug("netserv, ReplyRmLib: failed to send reply down pipe %s",
		Connection->Pipe->Name);
#endif
  Signal(&(Connection->WriteLock));
d942 17
a958 5
/**----------------------------------------------------------------------------
*** HandleGetNetwork(). This is used to obtain full details of the current
*** network. It is also used to get network hardware details and network
*** hierarchies, i.e. the name of the root network and all subnets but
*** no details of any processors.
a959 4
static int  GetNetwork_NetworkFilter(RmNetwork, RmNetwork);
static int  GetNetwork_ProcessorFilter(RmProcessor, RmProcessor);
static int  GetHierarchy_NetworkFilter(RmNetwork, RmNetwork);
static int  GetHierarchy_ProcessorFilter(RmProcessor, RmProcessor);
d961 3
a963 3
static void HandleGetNetwork(NsConn Connection, int JobId,
		RmRequest *request, RmReply *reply)
{ RmFilterStruct	filter;
d965 1
a965 14
  if (request->FnRc eq RmC_GetNetworkHardware)
   filter.SendHardware = TRUE;
  else
   filter.SendHardware = FALSE;
  if (request->FnRc eq RmC_GetHierarchy)
   { filter.Network	= &GetHierarchy_NetworkFilter;
     filter.Processor	= &GetHierarchy_ProcessorFilter;
   }
  else
   { filter.Network	= &GetNetwork_NetworkFilter;
     filter.Processor	= &GetNetwork_ProcessorFilter;
   }
  filter.Taskforce	= NULL;
  filter.Task		= NULL;
d967 2
a968 5
  reply->FnRc		= RmE_Success;
  reply->Network	= Net;
  reply->Filter		= &filter;
  ReplyRmLib(Connection, JobId, reply);
}
d970 8
a977 8
static int GetNetwork_NetworkFilter(RmNetwork real, RmNetwork copy)
{
  copy->DirNode.Key	= 0;
  copy->StructType	= RmL_Existing;
  if (real eq RmRootNetwork((RmProcessor) real))
   strcpy(copy->DirNode.Name, NetworkName);
  return(RmE_Success);
}
d979 5
a983 11
static int GetNetwork_ProcessorFilter(RmProcessor real, RmProcessor copy)
{
  copy->ObjNode.Key	= 0;
  copy->StructType	= RmL_Existing;
  memset(&(copy->NsCap), 0, sizeof(Capability));
  if (copy->ObjNode.Flags & NsFlags_DenyReadOnly)
   memset(&(copy->RealCap), 0, sizeof(Capability));
  else
   { ProcessorEntry	*proc_entry;
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(real);
     memcpy(&(copy->RealCap), &(proc_entry->General), sizeof(Capability));
a984 3
  copy->Private = 0;
  
  return(RmE_Success);
d987 23
a1009 8
static int GetHierarchy_NetworkFilter(RmNetwork real, RmNetwork copy)
{ 
  copy->DirNode.Nentries	= copy->NoSubnets;
  copy->DirNode.Key		= 0;
  copy->StructType		= RmL_Obtained;
  if (real eq RmRootNetwork((RmProcessor) real))
   strcpy(copy->DirNode.Name, NetworkName);
  return(RmE_Success);
d1012 7
a1018 1
static int GetHierarchy_ProcessorFilter(RmProcessor real, RmProcessor copy)
d1020 12
a1031 2
  real = real; copy = copy;
  return(RmE_Skip);
d1034 2
a1035 2
/**----------------------------------------------------------------------------
*** Handle last change. A very simple routine to send back a single integer
d1037 5
a1041 8
static void HandleLastChange(NsConn Connection, int JobId,
		RmRequest *request, RmReply *reply)
{ 
  reply->FnRc	= RmE_Success;
  reply->Reply1	= LastChange;
  ReplyRmLib(Connection, JobId, reply);
  request = request;
}
d1043 11
a1053 22
/**----------------------------------------------------------------------------
*** IsProcessorFree(), a simple routine for the Network Server
**/
static	void HandleIsProcessorFree(NsConn Connection, int JobId, 
		RmRequest *request, RmReply *reply)
{ RmProcessor		processor;
  int			rc;
  int			state;
    
  processor = RmFindProcessor(Net, request->Uid);
  if (processor eq (RmProcessor) NULL)
   { rc = RmE_BadProcessor; goto done; }
  if (processor->ObjNode.Account ne RmO_FreePool)
   { rc = RmE_InUse; goto done; }
  state = RmGetProcessorState(processor);
  if ((state & RmS_Running) eq 0)
   { rc = RmE_InUse; goto done; }
  rc = RmE_Success;
  
done:
  reply->FnRc	= rc;
  ReplyRmLib(Connection, JobId, reply);
d1059 1
a1059 1
static void HandleGetId(NsConn Connection, int JobId,
d1063 2
a1064 2
  reply->Reply1	= Connection->Id;
  ReplyRmLib(Connection, JobId, reply);
d1070 7
a1076 1
*** obtained by the Session Manager to run the TFM.
d1078 1
a1078 1
static void HandleRegisterTfm(NsConn Connection, int JobId,
d1080 3
a1082 2
{ RmProcessor	Processor;
  int		rc = RmE_Success;
d1084 1
a1084 1
  if (Connection->Program ne Rm_TFM)
d1087 2
a1088 2
  Processor = RmFindProcessor(Net, request->Uid);
  if (Processor eq (RmProcessor) NULL)
d1090 2
a1091 1
  Processor->SessionId	= Connection->Id;
d1093 4
d1099 1
a1099 1
  ReplyRmLib(Connection, JobId, reply);
d1116 1
a1116 1
static void HandleStartns(NsConn Connection, int JobId, 
d1118 1
a1118 1
{ RmNetwork	Network;
d1122 1
a1122 1
     ReplyRmLib(Connection, JobId, reply);
d1126 4
a1129 1
  Network		= request->Network;
d1134 1
a1134 1
  StartnsAux(Network);   /* Sort out the data */
d1136 2
d1139 1
a1139 1
  NewCap( (Capability *) &(reply->Reply1), (ObjNode *) &(Network->DirNode), 
d1141 1
a1141 1
  ReplyRmLib(Connection, JobId, reply);
d1177 1
a1177 1
static void	StartnsAux(RmNetwork Network)
d1179 5
a1183 5
  strcpy(NetworkName, Network->DirNode.Name);
  strcpy(Network->DirNode.Name, "ns");  
  { RmNetwork OldRoot = (RmNetwork) NetservInfo.Root;
    Net = (RmNetwork) (NetservInfo.Root = &(Network->DirNode));
    RmFreeNetwork(OldRoot);
a1184 1
  NumberProcessors = RmCountProcessors(Network);
d1186 2
a1187 1
  RootProcessor		= DetermineRoot(Network);
d1190 4
a1193 4
  (void) StartnsAux2(Network);
  (void) RmApplyProcessors(Network, &StartnsAux5);
  (void) StartnsAux6(Network);
  (void) RmApplyProcessors(Network, &StartnsAux9);
d1201 1
a1201 1
static int  StartnsAux2(RmNetwork Network)
d1203 6
a1208 6
  Network->DirNode.Matrix = 0x21212147;	/* rz : rz : rz : rwvd */
  Network->DirNode.Key	  = NewKey() + _cputime() + (int) Network;
  Network->DirNode.Dates.Creation =
  Network->DirNode.Dates.Modified =
  Network->DirNode.Dates.Access   = GetDate();
  Network->DirNode.Account	  = 0;
d1211 2
a1212 2
  if (Network->NoSubnets > 0)
   { RmProcessor	Current, Next;
d1214 7
a1220 7
     Next = RmFirstProcessor(Network);
     for (i = 0; i < Network->DirNode.Nentries; i++)
      { Current = Next;
        Next    = RmNextProcessor(Current);
        if (RmIsNetwork(Current))
         { (void) Remove(&(Current->ObjNode.Node));
           (void) AddTail(&(Network->DirNode.Entries), &(Current->ObjNode.Node));
d1225 2
a1226 2
  (void) RmApplyNetwork(Network, &StartnsAux3);
  (void) RmApplyHardwareFacilities(Network, &StartnsAux4);
d1232 1
a1232 1
static int  StartnsAux3(RmProcessor Processor, ...)
d1234 1
a1234 1
  if (RmIsNetwork(Processor)) return(StartnsAux2((RmNetwork) Processor));
d1236 7
a1242 7
  Processor->ObjNode.Matrix = 0x01010143;	/* r:r:r:drw */
  Processor->ObjNode.Key    = GetDate() + _cputime() + (int) Processor;
  Processor->ObjNode.Dates.Creation = GetDate();
  Processor->ObjNode.Dates.Modified = 0;
  Processor->ObjNode.Dates.Access   = 0;
  if ((RmGetProcessorPurpose(Processor) & RmP_System) eq 0)
   Processor->ObjNode.Account = RmO_FreePool;
d1244 1
a1244 1
   Processor->ObjNode.Account = RmO_System;
d1246 1
a1246 1
  Processor->StructType	= RmL_New;	/* ensure that the Network Server */
d1248 5
a1252 5
  Processor->ObjNode.Size	= 0;	/* State currently undefined.	  */
  RmSetProcessorPrivate(Processor, 0);
  Processor->SessionId		= -1;
  Processor->ApplicationId	= -1;
  add_puid_attribute(Processor);  
d1260 1
a1260 1
static void add_puid_attribute(RmProcessor Processor)
d1263 2
a1264 2
  BuildName(&(namebuf[5]), Processor);
  RmAddObjectAttribute((RmObject) Processor, namebuf, TRUE);
d1386 1
a1386 1
static int	StartnsAux5(RmProcessor Processor, ...)
d1392 2
a1393 2
  hardware_count = RmGetProcessorPrivate(Processor);
  number_links	 = RmCountLinks(Processor);
d1408 1
a1408 1
  proc_entry->Purpose		= RmGetProcessorPurpose(Processor);
d1414 2
a1415 2
  proc_entry->Processor		= Processor;
  RmSetProcessorPrivate(Processor, (int) proc_entry);
d1422 3
a1424 3
static int  StartnsAux6(RmNetwork Network, ...)
{ (void) RmApplyHardwareFacilities(Network, &StartnsAux8);
  (void) RmApplyNetwork(Network, &StartnsAux7);
d1428 3
a1430 3
static int  StartnsAux7(RmProcessor Processor, ...)
{ if (RmIsNetwork(Processor))
   return(StartnsAux6((RmNetwork) Processor));
d1443 1
a1443 1
     proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(processor);
d1513 1
a1513 1
static int	StartnsAux9(RmProcessor Processor, ...)
d1520 2
a1521 2
  proc_entry = (ProcessorEntry *) RmGetProcessorPrivate(Processor);
  number_links = RmCountLinks(Processor);
d1523 1
a1523 1
   { RmLink	*link = RmFindLink(Processor, i);
d1528 1
a1528 1
  purpose = RmGetProcessorPurpose(Processor) & RmP_Mask;
d1530 1
a1530 1
   { Processor->Control = RmC_FixedMapping + RmC_FixedLinks;
d1538 1
a1538 1
        number_links = RmCountLinks(Processor);
d1540 1
a1540 1
         { flags = RmGetLinkFlags(Processor, i);
d1554 1
a1554 1
  Processor->Control = control;
d1574 1
a1574 3
BLV    A possible improvement involve checking all the links, and if any are
BLV    intelligent determining the processor at the other end (probably /IO)
BLV    and working out what is happening.
d1579 1
a1579 1
static RmProcessor	DetermineRoot(RmNetwork Network)
d1592 1
a1592 1
     result = LookupProcessor(Network, &(ProcessorName[1]));
d1600 1
a1600 1
  (void) RmApplyProcessors(Network, &DetermineAux1, ++temp, &candidates,
d1617 2
a1618 2
     { RmProcessor Processor	 = candidates[i];
       if (RmParentNetwork(Processor) eq RmRootNetwork(Processor))
d1620 1
a1620 1
          return(Processor);
d1628 1
a1628 1
static int DetermineAux1(RmProcessor Processor, ...)
d1635 1
a1635 1
  va_start(args, Processor);
d1642 1
a1642 1
  if (strcmp(Processor->ObjNode.Name, proc_name)) return(0);
d1652 1
a1652 1
  new_candidates[*next_candidate] = Processor;
d1668 1
a1668 1
static RmProcessor	DetermineIO(RmProcessor RootProcessor)
d1670 1
a1670 1
  int		number_links = RmCountLinks(RootProcessor);
d1677 1
a1677 1
      { RmProcessor	Neighbour;
d1681 2
a1682 2
        Neighbour = RmFollowLink(RootProcessor, i, &destlink);
        if (Neighbour eq RmM_NoProcessor)
d1684 1
a1684 1
                   RootProcessor->ObjNode.Name, i);
d1687 2
a1688 2
	purpose = RmGetProcessorPurpose(Neighbour);
	if ((purpose & RmP_Mask) eq RmP_IO) return(Neighbour);
d1691 1
a1691 1
		RootProcessor->ObjNode.Name, i);
a1697 57
/**
*** Given a network, look up the processor. Allow for the fact that
*** the root name is different.
*** Arguments : Network, the root structure or a subnet
***             name, something like Cluster/00
*** 
*** The routine determines the last bit of the name, e.g. 00, and
*** searches the network. When a processor is reached whose ID matches
*** this last bit of the name, the search goes back up the tree trying
*** to match all the parents.
**/
static int	LookupAux1(RmProcessor, ...);

RmProcessor	LookupProcessor(RmNetwork Network, char *name)
{ char		*temp = name + strlen(name);
  
  for ( ; (temp >= name) && (*temp ne '/'); temp--);

  return((RmProcessor) RmSearchProcessors(Network, &LookupAux1, name, ++temp));
}

static int LookupAux1(RmProcessor Processor, ...)
{ va_list	args;
  char		*name;
  char		*last_name;
  RmNetwork	current;
  RmNetwork	root_net;
  int		amount;
      
  va_start(args, Processor);
  name		= va_arg(args, char *);
  last_name	= va_arg(args, char *);
  va_end(args);
  
	/* Unless the last bit matches, do not bother to check */  
  if (strcmp(Processor->ObjNode.Name, last_name)) return(0);

  current	= (RmNetwork) Processor;
  root_net	= RmRootNetwork(Processor);
  
  while (last_name > name)	/* If name is 00, match is immediate	*/
   { last_name--; last_name--;  /* Skip the / and get to last char	*/
     for ( amount = 0; (last_name >= name) && (*last_name ne '/'); 
           last_name--, amount++);
     last_name++;		/* should now be Cluster */
     current = RmParentNetwork((RmProcessor) current);
     if (current eq (RmNetwork) NULL) return(0);

     if (current eq root_net)
      { if (strncmp(NetworkName, last_name, amount)) return(0);
      }
     else
      { if (strncmp(current->DirNode.Name, last_name, amount)) return(0); 
      }
   }
  return((int) Processor);
}
@


1.15
log
@Every processor is now given a private PUID attribute to facilitate
ObtainProcessor requests. The version number has been updated.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netserv.c,v 1.14 1991/03/01 17:20:08 bart Exp $";
d19 1
a19 1
static char *VersionNumber = "3.08";
d31 4
d95 2
a96 1
			
d181 3
a183 1
	case	'i'	: DebugOptions |= dbg_Initialise;	break;
d230 1
d236 1
d381 5
d661 3
a663 3
{ NsConn	Connection = Malloc(sizeof(NsConnStruct));
  Object	*PipeServer = Null(Object);
  Object	*NewPipe = Null(Object);
d665 2
a666 1
  static int	NextPipeID = 1;
d677 1
d747 6
a752 5
static void HandleStartns(NsConn, int, int);
static void HandleGetNetwork(NsConn, int, int);
static void HandleGetHierarchy(NsConn, int, int);
static void HandleLastChange(NsConn, int, int);
static void HandleGetNetworkAndHardware(NsConn, int, int);
d755 4
a758 3
{ int	JobId;
  int	Request;
  
d761 2
d768 1
a768 9
	Close(Connection->Pipe);
	unless(EmptyList_(Connection->Processors))
	 { 
	   Wait(&SingleStep);
	   (void) WalkList(&(Connection->Processors), &AutomaticRelease);
	   Signal(&SingleStep);
	 }
	Free(Connection);
     	return;
d777 25
a801 4
     rc = Read(Connection->Pipe, (BYTE *) &Request, sizeof(int), -1);
     if (rc < 0)
      {
      	 return;	/* BLV - release resources */
d804 6
d812 1
a812 1
     switch(Request)
d814 2
a815 2
      			HandleStartns(Connection, JobId, Request);
      			break;
d817 1
a817 2
			HandleGetNetwork(Connection, JobId, Request);
			break;
d819 2
a820 2
			HandleGetHierarchy(Connection, JobId, Request);
			break;
d822 2
a823 2
			HandleObtainProcessor(Connection, JobId, Request);
			break;
d825 2
a826 2
			HandleReleaseProcessor(Connection, JobId, Request);
			break;
d828 2
a829 2
			HandleLastChange(Connection, JobId, Request);
			break;
d832 2
a833 2
			HandleObtainNetwork(Connection, JobId, Request);
			break;
d835 2
a836 7
			HandleReleaseNetwork(Connection, JobId, Request);
			break;

	case RmC_GetNetworkHardware :
			HandleGetNetworkAndHardware(Connection, JobId, Request);
			break;

d838 2
a839 3
			HandleGetLinkMode(Connection, JobId, Request);
			break;

d841 2
a842 3
			HandleSetLinkMode(Connection, JobId, Request);
			break;

d844 2
a845 3
			HandleAcceptNetwork(Connection, JobId, Request);
			break;
			
d847 23
a869 6
			HandleJoinNetwork(Connection, JobId, Request);
			break;
			
      	default : report("unexpected request %x", Request);
		  Close(Connection->Pipe);
		  (void) WalkList(&(Connection->Processors), &AutomaticRelease);
d871 1
a871 2
		  Free(Connection);
		  return;
d874 6
d881 13
d896 48
d946 3
a948 2
*** network. There are two versions, one which sends the hardware details,
*** and one which does not.
d952 2
d955 3
a957 3
static void HandleGetNetwork(NsConn Connection, int JobId, int Request)
{ int	rc;
  RmFilterStruct	filter;
d959 12
a970 3
  filter.SendHardware	= FALSE;
  filter.Network	= &GetNetwork_NetworkFilter;
  filter.Processor	= &GetNetwork_ProcessorFilter;
d974 4
a977 7
  Wait(&(Connection->WriteLock));
  (void) Write(Connection->Pipe, (BYTE *) &JobId, sizeof(int), -1);
  rc = RmE_Success;
  (void) Write(Connection->Pipe, (BYTE *) &rc, sizeof(int), -1);
  rc = RmWriteStream(Connection->Pipe, Net, (RmTaskforce) NULL, &filter);
  Signal(&(Connection->WriteLock));
  Request = Request;
a979 19
static void HandleGetNetworkAndHardware(NsConn Connection, int JobId, int Request)
{ int	rc;
  RmFilterStruct	filter;

  filter.SendHardware	= TRUE;
  filter.Network	= &GetNetwork_NetworkFilter;
  filter.Processor	= &GetNetwork_ProcessorFilter;
  filter.Taskforce	= NULL;
  filter.Task		= NULL;

  Wait(&(Connection->WriteLock));
  (void) Write(Connection->Pipe, (BYTE *) &JobId, sizeof(int), -1);
  rc = RmE_Success;
  (void) Write(Connection->Pipe, (BYTE *) &rc, sizeof(int), -1);
  rc = RmWriteStream(Connection->Pipe, Net, (RmTaskforce) NULL, &filter);
  Signal(&(Connection->WriteLock));
  Request = Request;
}

d1001 1
a1001 1
  copy->RmLib	= 0;
a1005 27
/**----------------------------------------------------------------------------
*** HandleGetHierarchy(). This is used to obtain full details of the current
*** network hierarchy, i.e. the name of the root network and all subnets,
*** but no details of any processors.
**/
static int  GetHierarchy_NetworkFilter(RmNetwork, RmNetwork);
static int  GetHierarchy_ProcessorFilter(RmProcessor, RmProcessor);

static void HandleGetHierarchy(NsConn Connection, int JobId, int Request)
{ int			rc;
  RmFilterStruct	filter;

  filter.SendHardware	= FALSE;
  filter.Network	= &GetHierarchy_NetworkFilter;
  filter.Processor	= &GetHierarchy_ProcessorFilter;
  filter.Taskforce	= NULL;
  filter.Task		= NULL;

  Wait(&(Connection->WriteLock));
  (void) Write(Connection->Pipe, (BYTE *) &JobId, sizeof(int), -1);
  rc = RmE_Success;
  (void) Write(Connection->Pipe, (BYTE *) &rc, sizeof(int), -1);
  rc = RmWriteStream(Connection->Pipe, Net, (RmTaskforce) NULL, &filter);
  Signal(&(Connection->WriteLock));
  Request = Request;
}

d1008 3
a1010 3
  copy->DirNode.Nentries = copy->NoSubnets;
  copy->DirNode.Key	= 0;
  copy->StructType	= RmL_Obtained;
d1025 2
a1026 1
static void HandleLastChange(NsConn Connection, int JobId, int request)
d1028 3
a1031 4
  Wait(&(Connection->WriteLock));
  (void) Write(Connection->Pipe, (BYTE *) &JobId, sizeof(int), -1);
  (void) Write(Connection->Pipe, (BYTE *) &LastChange, sizeof(int), -1);
  Signal(&(Connection->WriteLock));
d1035 58
d1100 2
d1106 2
a1107 1
static void HandleStartns(NsConn Connection, int JobId, int Request)
a1108 1
  int		rc;
a1109 5
  Request = Request;
  rc = RmReadStream(Connection->Pipe, &Network, &DefaultTaskforce);
  if (rc ne RmE_Success)
   goto error; 

d1111 4
a1114 1
   { rc = RmE_InUse; goto error; }
d1116 5
d1123 2
a1124 2
  { Capability	Cap;
    NewCap(&Cap, (ObjNode *) &(Network->DirNode), 
d1126 1
a1126 8
    Wait(&(Connection->WriteLock));
    (void) Write(Connection->Pipe, (BYTE *) &JobId, sizeof(int), -1);
    rc = RmE_Success;
    (void) Write(Connection->Pipe, (BYTE *) &rc, sizeof(int), -1);
    (void) Write(Connection->Pipe, (BYTE *) &Cap, sizeof(Capability), -1);
    Signal(&(Connection->WriteLock));
  }

a1127 6
error:
  Wait(&(Connection->WriteLock));
  (void) Write(Connection->Pipe, (BYTE *) &JobId, sizeof(int), -1);
  (void) Write(Connection->Pipe, (BYTE *) &rc, sizeof(int), -1);
  Signal(&(Connection->WriteLock));
  return;
d1173 1
d1176 1
a1176 1
  (void) RmApplyNetwork(Network, &StartnsAux5);
d1178 1
a1178 1
  (void) RmApplyNetwork(Network, &StartnsAux9);
d1187 1
a1187 1
{
d1218 1
a1218 1
{ 
d1226 8
a1233 8
  switch(RmGetProcessorPurpose(Processor))
   { case	RmP_Helios	:
     case	RmP_IO		:
     case	RmP_Native	: Processor->ObjNode.Account = RmO_SystemPool;
     				  break;
     case	RmP_System	: 
     default			: Processor->ObjNode.Account = RmO_System;
   }
d1235 3
a1237 3

  add_puid_attribute(Processor);
    
d1319 1
a1319 1
   { RmSetTaskID(task, "1");
d1323 1
a1323 1
   RmSetTaskID(task, "0");
d1341 1
a1341 1
     if (arg ne 0) RmSetTaskArgument(task, arg++, argname);
a1376 3
  if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &StartnsAux5));

d1395 1
d1424 1
a1424 1
  
d1490 7
a1496 1
*** the default links when required.
d1502 2
a1503 3
  
  if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &StartnsAux9));
d1512 29
d1587 1
a1587 1
  (void) RmApplyNetwork(Network, &DetermineAux1, ++temp, &candidates,
a1627 4
  if (RmIsNetwork(Processor))
   return(RmApplyNetwork((RmNetwork) Processor, &DetermineAux1, proc_name,
   		candidates, next_candidate));

d1675 2
a1676 2
	if (purpose eq RmP_IO) return(Neighbour);
	if (purpose eq RmP_Native) return(RmM_NoProcessor);
d1703 1
a1703 1
  return((RmProcessor) RmSearchNetwork(Network, &LookupAux1, name, ++temp));
a1718 3
  if (RmIsNetwork(Processor))
   return(RmSearchNetwork((RmNetwork) Processor, &LookupAux1, name, last_name));

@


1.14
log
@Various files had been left checked out somehow, tidying up.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /giga/Helios/network/RCS/netserv.c,v 1.13 90/12/17 14:26:37 bart Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.07";
d30 1
d238 1
a238 1
     fatal("failed to enter name in name table, error code 0x%08x",
d303 2
a685 1
Connection->Pipe->Flags |= 0x00100000;
d1014 2
a1015 1
***    work out how many facilities affect the processor.
d1088 2
d1108 3
a1110 1
  
d1112 11
@


1.13
log
@just changing the version number printed out
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/sparkygiga/Helios/network/RCS/netserv.c,v 1.12 90/12/02 13:53:34 bart Exp Locker: bart $";
@


1.12
log
@just updating the version numbers
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netserv.c,v 1.11 90/12/01 15:34:30 bart Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.06";
d29 1
@


1.11
log
@changed the timeout handling of connections. Every client now needs to
handshake with the Network Server every 30 seconds, or the connection
is aborted and all resources are reclaimed. This is done automatically
by rmlib2.c However, if the client is running in an external network
that has been disconnected then this code will be triggered.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netserv.c,v 1.9 90/11/02 20:38:40 bart Exp $";
d19 1
a19 1
static char *VersionNumber = "3.05";
d28 1
@


1.10
log
@added support for reset commands.
@
text
@d42 1
d140 2
d242 4
d540 1
a540 1
    
d620 1
d622 2
a623 4
  Delete(NameEntry, Null(char));
  Delay(2 * OneSec);
  exit(0);  

a735 1
  int	timeouts = 0;
d740 1
a740 1
     rc = Read(Connection->Pipe, (BYTE *) &JobId, sizeof(int), 60 * OneSec);
d742 1
a742 6
      { if (rc eq 0)
         { timeouts++;
           if (timeouts < 5) continue;
         }
        if ((Result2(Connection->Pipe) & EG_Mask) eq EG_Timeout) continue;
	if (Connection->Program eq Rm_Session)
d746 2
a747 1
	 { Wait(&SingleStep);
a754 1
     timeouts = 0;
d1466 1
a1466 1
  Free(*candidates);
@


1.9
log
@changes to work with new resource map generator
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netserv.c,v 1.8 90/11/01 16:14:17 bart Exp $";
d548 3
d561 2
a562 5
  
  FreePort(NetservInfo.ReqPort);
  Delete(NameEntry, Null(char));
  Delay(2 * OneSec);
  exit(0);  
d609 12
d807 8
d1110 2
d1129 3
a1138 2
/* BLV - do something about the reset commands, i.e. check that they exist */
/* BLV and locate suitable objects. */
d1143 76
d1252 1
d1337 1
@


1.8
log
@more header file problems
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netserv.c,v 1.7 90/11/01 14:51:46 bart Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.04";
d27 1
d1080 2
a1081 1

a1138 1

@


1.7
log
@sources update after visit to Parsytec 22.10.90-31.10.90
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netserv.c,v 1.1 90/09/12 14:38:58 jon Exp $";
d34 1
@


1.6
log
@NHG has been fiddling with the header files
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netserv.c,v 1.5 90/10/18 13:26:39 bart Exp Locker: bart $";
d19 9
a27 2
static char *VersionNumber = "3.03";

a41 2
#include <root.h>
#include <link.h>
a599 3
#if 0
     ShowHeap();
#endif   		
d645 1
d661 1
d711 1
d716 2
a717 1

d721 6
a726 3
     rc = Read(Connection->Pipe, (BYTE *) &JobId, sizeof(int), -1);
     if (rc < 0)
      { 
d740 1
d742 2
a743 1
      { IOdebug("Netserv : private protocol received down pipe");
d781 12
d807 2
a808 1
*** network.
d832 19
d1149 2
a1150 1
  proc_entry->NetagentPipe	= Null(Stream);                         
d1351 1
a1351 1
  if (strcmp(RmGetProcessorID(Processor), proc_name)) return(0);
d1384 2
a1385 1
     if (info.Flags & Link_Flags_parent)
d1393 1
a1393 1
                   RmGetProcessorID(RootProcessor), i);
d1400 1
a1400 1
		RmGetProcessorID(RootProcessor), i);
d1445 1
a1445 1
  if (strcmp(RmGetProcessorID(Processor), last_name)) return(0);
d1462 1
a1462 1
      { if (strncmp(RmGetNetworkID(current), last_name, amount)) return(0); 
@


1.5
log
@minor bug fixes in time for Helios 1.2 beta1 release
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netserv.c,v 1.1 90/09/12 14:38:58 jon Exp $";
d35 2
@


1.4
log
@preparing beta1 release before holiday
@
text
@d19 1
a19 1
static char *VersionNumber = "3.02";
d57 1
a57 1
	char		ProcessorName[128];
d411 2
a412 1
   { if (CheckMask(req->Common.Access.Access, AccMask_D))
@


1.3
log
@Plugged various memory leaks
@
text
@d97 4
a100 1
	  	 { NullFn,		2000 }  /* CloseObj */
@


1.2
log
@now compiles with arm compiler (sizeof(char) problems in va_arg)
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netserv.c,v 1.1 90/09/12 14:38:58 jon Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.00";
d123 4
d639 1
d672 1
a672 1
  Close(NewPipe);   
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char *rcsid = "$Header$";
d247 1
a247 1
        case    'c' : *dest++ = va_arg(args, char); break;
@
