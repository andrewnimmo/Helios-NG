head	1.19;
access;
symbols
	Helios_C40_1_3_Official_Release:1.17
	Alenia_release:1.16
	Helios1_3:1.16
	C40_Field_Test_2:1.16
	C40_Field_Test_R1:1.13
	Helios13_beta:1.13
	Helios1_2_2_Fault:1.12
	Helios1_2_2_Native:1.11
	Helios1_2_2_native_beta:1.11
	Helios1_2_2:1.10
	Helios1_2_2Beta:1.10
	Helios1_2_1:1.9
	Helios1_2:1.8;
locks; strict;
comment	@ * @;


1.19
date	93.08.12.13.52.06;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	93.08.11.10.49.07;	author bart;	state Exp;
branches;
next	1.17;

1.17
date	93.01.13.11.07.56;	author bart;	state Exp;
branches;
next	1.16;

1.16
date	92.10.07.13.41.18;	author bart;	state Exp;
branches;
next	1.15;

1.15
date	92.08.13.18.29.04;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	92.07.21.11.07.21;	author bart;	state Exp;
branches;
next	1.13;

1.13
date	92.04.24.15.44.34;	author bart;	state Exp;
branches;
next	1.12;

1.12
date	92.01.15.11.04.39;	author bart;	state Exp;
branches;
next	1.11;

1.11
date	92.01.14.14.20.34;	author bart;	state Exp;
branches;
next	1.10;

1.10
date	91.04.07.13.20.21;	author bart;	state Exp;
branches;
next	1.9;

1.9
date	91.02.27.16.18.43;	author bart;	state Exp;
branches;
next	1.8;

1.8
date	90.12.02.13.55.41;	author bart;	state Exp;
branches;
next	1.7;

1.7
date	90.12.01.15.38.24;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	90.11.25.20.07.20;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	90.11.01.15.00.58;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	90.10.18.13.27.04;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	90.09.27.13.24.56;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	90.09.24.18.48.33;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	90.09.12.15.00.50;	author jon;	state Exp;
branches;
next	;


desc
@@


1.19
log
@fixed compile time warnings
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- session.c								--
--                                                                      --
--	Main module of the Session Manager				--
--                                                                      --
--	Author:  BLV 1/5/90						--
--                                                                      --
------------------------------------------------------------------------*/
/* RcsId: $Header: /hsrc/network/RCS/session.c,v 1.18 1993/08/11 10:49:07 bart Exp nickc $*/

/*{{{  version number and history */
static char *VersionNumber = "3.12";
/**
*** History :
***          3.00, initial version
***          3.01, Helios 1.2 beta 0 release
***          3.02, Helios 1.2 beta 1 release
***          3.03, developed at Parsytec, 22.10.90-30.10.90
***          3.04, finishing off for the official 1.2 release
***          3.05, the real 1.2 release
***          3.06, first non-1.2 version
***          3.07, now supports single-processor version of Helios
***          3.08, clean up for fault tolerance
***          3.09, fix relating to TFM startup delays, plus diagnostics
***	     3.10, fixed bug relating to simultaneous logins
***          3.11, password encryption
***          3.12, reduced memory requirements for C40 1.3.1 release
**/
/*}}}*/
/*{{{  header files and compile-time options */
#include <stdio.h>
#include <syslib.h>
#include <servlib.h>
#include <sem.h>
#include <codes.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <posix.h>
#include <ctype.h>
#include <nonansi.h>
#include <process.h>
#include <attrib.h>
#include <pwd.h>
#include <signal.h>
#include "exports.h"
#include "private.h"
#include "netutils.h"
#include "session.h"
#include "rmlib.h"
#include "sessaux.h"

	/* Compile-time debugging options	*/
#define Use_Malloc_Debugging		0
#define Use_Objects_Debugging		0
#define ShowHeap_Debugging		0
#define Use_IOC_Debugging		0
#define Default_Diagnostics_Options	0
#define Use_Ports_Debugging		0
/*}}}*/
/*{{{  forward declarations and statics */
/**-----------------------------------------------------------------------------
*** Forward declarations and statics.
***
*** At present the Session Manager /sm contains two types of entry:
***
***   1) there is a /Windows subdirectory containing details of all registered
***      windows, each of which is a WindowNode structure. The Session Manager
***      runs login in all of these windows, via a separate getty thread.
***   2) the top level contains details of all current sessions, each in a
***      SessionNode structure. Note that there is some theoretical overlap
***      between the /Windows entries and the sessions, but this is ignored.
***
*** When passwords are fully supported there will be a third entry,
*** /UserDatabase, which can be accessed in order to examine and manipulate
*** passwords and related information.
**/

static void	do_open(ServInfo *);
static void	do_create(ServInfo *);
static void	do_private(ServInfo *);
static void	do_delete(ServInfo *);
static void	monitor_thread(void);
static void	check_world(void);
static void	show_startup(void);
static void	getty_process(WindowNode *node);
static int	start_tfm(SessionNode *node);

static Object		*NameEntry		= Null(Object);
static Object		*ThisProcessor		= Null(Object);
static Stream		*DiagnosticsStream	= Null(Stream);
static Stream		*DefaultDiagnostics	= Null(Stream);
static DirNode		SessionRoot;
static DirNode		Windows;
static bool		SingleUserMode		= FALSE;
       bool		PasswordChecking	= FALSE;
static int		MonitorInterval;
       int		DebugOptions		= Default_Diagnostics_Options;
static Object		*LoginProgram;
static Object		*TaskforceManager;
static Environ		*my_environ;
       Semaphore	LibraryLock;
       char		**nsrc_environ		= NULL;
       
static DispatchInfo SessionInfo =
	{ &SessionRoot,
	  NullPort,
	  SS_SM,
	  Null(char),
	  { do_private, SM_Stack },
	  {
	  	 { do_open,		SM_Stack	},
	  	 { do_create,		SM_Stack	}, /* Create */
	  	 { DoLocate,		0		},
	  	 { DoObjInfo,		0		},
	  	 { InvalidFn,		0		}, /* ServerInfo */
	  	 { do_delete,		SM_Stack	}, /* Delete */
	  	 { InvalidFn,		0		}, /* Rename */
	  	 { InvalidFn,		0		}, /* Link   */
	  	 { DoProtect,		0		},
	  	 { InvalidFn,		0		}, /* SetDate */
	  	 { DoRefine,		0		},
	  	 { NullFn,		0		}, /* CloseObj */
	  	 { InvalidFn,		0		}, /* Revoke */
	  	 { InvalidFn,		0		}, /* Reserved1 */
	  	 { InvalidFn,		0		}  /* Reserved2 */
	  }
};
/*}}}*/
/*{{{  main() */
/*----------------------------------------------------------------------------*/
/**
*** main()
***
*** 1) check the arguments, to ensure that the Session Manager was started
***    up by the Startns program. 
***
*** 2) fill in the various globals etc.
***
*** 3) initialise the user database, and add the resulting DirEntry to
***    the root data structure. (mostly a no-op in Helios 1.2.x)
***
*** 4) add the Windows subdirectory, for windows added by the newuser
***    command
***
*** 5) if network monitoring is enabled, start up a thread to check
***    every session and window at regular intervals.
***
*** 6) create the name table entry and call the dispatcher
***
*** Note that the Startns utility tries very hard to ensure that this program
*** runs only on the root processor.
**/

int main(int argc, char **argv)
{ char ProcessorName[128];

#ifndef __TRAN
  SetPriority(HighServerPri);
#endif

  signal(SIGPIPE, SIG_IGN);

#if Use_Malloc_Debugging
  PatchMalloc();
#endif
#if Use_Objects_Debugging
  PatchObjects();
#endif
#if Use_IOC_Debugging
  PatchIOC(1);
#endif
#if Use_Ports_Debugging
  PatchPorts();
#endif

  DiagnosticsStream	= fdstream(1);
  DefaultDiagnostics	= DiagnosticsStream;

  my_environ		= getenviron();
  InitSemaphore(&(LibraryLock), 1);

  if (strcmp(argv[0], "startns-magic"))
   fatal("please use startns to start up the networking software");
  nsrc_environ	= &(argv[4]);
  argc		= argc;
  show_startup();

#ifndef SingleProcessor  
	/* Inform the resource management library who I am */
  RmProgram	= Rm_Session;
  (void) EncodeCapability(argv[1], &RmLib_Cap);
#endif
  
  if (MachineName(ProcessorName) ne Err_Null)
   fatal("MachineName failure");

  SingleUserMode   = (get_config("single_user", nsrc_environ) ne Null(char));
  PasswordChecking = (get_config("password_checking", nsrc_environ) ne Null(char));
  MonitorInterval  = get_int_config("monitor_interval", nsrc_environ);
    
  ThisProcessor = Locate(Null(Object), ProcessorName);
  if (ThisProcessor eq Null(Object))
   fatal("failed to locate own processor");

  LoginProgram = Locate(CurrentDir, LoginName);
  if (LoginProgram eq Null(Object))
   fatal("failed to locate login program %s", LoginName);

  if (get_config("no_taskforce_manager", nsrc_environ) eq Null(char))
   { TaskforceManager = Locate(CurrentDir, TfmName);
     if (TaskforceManager eq Null(Object))
      fatal("failed to locate Taskforce Manager %s", TfmName);
   }
		/* Access to /sm : darwv:rx:ry:rz */
		/* This prevents arbitrary users getting hold of a capability */
		/* for somebody else's Taskforce Manager */
  InitNode((ObjNode *) &SessionRoot, "sm", Type_Directory, 
  	(PasswordChecking) ? RmFlags_PasswordChecking : 0, 0x211109c7);   
  InitList(&(SessionRoot.Entries));
  SessionRoot.Nentries = 0;
  if ((SessionInfo.ReqPort = NewPort()) eq NullPort)
   fatal("unable to allocate a message port");

#if 0
  if (!InitUserDatabase())
   fatal("failed to initialise user database");

	/* Full user database is not yet supported	*/
  Insert(&SessionRoot, &UserDatabase, FALSE);
#endif

  InitNode((ObjNode *) &Windows, "Windows", Type_Directory, 0, 0x211109c7);
  InitList(&(Windows.Entries));
  Windows.Nentries = 0;
  Insert(&SessionRoot, (ObjNode *) &Windows, FALSE);

  if (MonitorInterval eq Invalid_config)
   MonitorInterval = 30;
  elif (MonitorInterval > (30 * 60)) 
   MonitorInterval = 30 * 60;
  elif ((MonitorInterval >= 0) && (MonitorInterval < 20))
   MonitorInterval = 20;

  if (MonitorInterval >= 0)
   if (!Fork(Monitor_Stack, &monitor_thread, 0))
    fatal("not enough memory to initialise session monitoring");

  { NameInfo name;
    name.Port   = SessionInfo.ReqPort;
    name.Flags  = Flags_StripName;
    name.Matrix = 0x21212147;	/* rz: rz : rz : rwvd */
    name.LoadData = Null(WORD);
    NameEntry = Create(ThisProcessor, "sm", Type_Name, sizeof(NameInfo),
      (BYTE *) &name);
    if (NameEntry eq Null(Object))
     fatal("failed to enter name in name table, error code %x",
           Result2(ThisProcessor));
  }

  Dispatch(&SessionInfo);
  
  return(0);
}
/*}}}*/
/*{{{  diagnostics routines */
/*----------------------------------------------------------------------------*/
/**
*** Usual diagnostics routines.
**/
static char	output_buffer[256];
static char	*int_to_string(char *buffer, int x);

static int	process_format(char *init, char *format, va_list args)
{ char	*dest;

  strcpy(output_buffer, init);
  
  for (dest = output_buffer + strlen(output_buffer); *format ne '\0'; format++)
   { if (*format ne '%')
      { *dest++ = *format; continue; }
     switch (*(++format))
      { case	'\0': *dest++ = '%'; format--; break;
        case	'%' : *dest++ = '%'; break;
        case    'c' : *dest++ = (char) va_arg(args, int); break;
        case	's' : { char	*temp = va_arg(args, char *);
			if (temp eq Null(char))
			 { *dest++ = '<'; *dest++ = 'n'; *dest++ = 'u';
			   *dest++ = 'l'; *dest++ = 'l'; *dest++ = '>';
			   break;
			 }
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
        case	'x' : { int	x = va_arg(args, int);
        		int	shift;
        		*dest++ = '0'; *dest++ = 'x';
        		for (shift = 28; shift >= 0; shift -= 4)
        		 { int temp = (x >> shift) & 0x0F;
        		   if (temp <= 9)
        		    *dest++ = '0' + temp;
        		   else 
        		    *dest++ = 'a' + temp - 10;
        		 }
        		break;
        	      }
	case	'd' : { int	temp = va_arg(args, int);
	   		dest = int_to_string(dest, temp);
	   		break;
		      }  

	default	    : *dest++ = '%'; *dest++ = *format; break;
      }
    }
  if (DiagnosticsStream->Flags & Flags_Interactive)
   *dest++ = '\r';
  *dest++ = '\n';
  return(dest - output_buffer);
}

static char	*int_to_string_aux(char *buffer, unsigned int i)
{ if (i > 9) buffer = int_to_string_aux(buffer, i / 10);
  *buffer++	= (i % 10) + '0';
  return(buffer);
}

static char	*int_to_string(char *buffer, int x)
{ if (x < 0) { x = -x; *buffer++ = '-'; }
  return(int_to_string_aux(buffer, (unsigned int ) x));
}

void fatal(char *format, ...)
{ va_list	list;
  int		length;
  static	char *message = "sm: error is fatal, exiting.\n";
  
  Wait(&(LibraryLock));
  va_start(list, format);
  length = process_format("sm: ", format, list);
  va_end(list);

  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  (void) Write(DiagnosticsStream, message, strlen(message), -1);
  Signal(&LibraryLock);

  if (NameEntry ne Null(Object)) Delete(NameEntry, Null(char));
  Exit(EXIT_FAILURE << 8);
}

void report(char *format, ...)
{ va_list	args;
  int		length;  
  
  va_start(args, format);
  
  Wait(&LibraryLock);
  length = process_format("sm: ", format, args);
  va_end(args);
  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  Signal(&LibraryLock);
}

void window_report(Stream *window, char *format, ...)
{ va_list	args;
  int		length;

  va_start(args, format);
  Wait(&LibraryLock);
  length = process_format("sm: ", format, args);
  va_end(args);
  (void) Write(window, output_buffer, length, -1);
  Signal(&LibraryLock);
}

void debug(char *format, ...)
{ va_list	args;
  int		length;
  
  va_start(args, format);
  
  Wait(&LibraryLock);
  length = process_format("sm.debug: ", format, args);
  va_end(args);
  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  Signal(&LibraryLock);
}
  
static void show_startup(void)
{ int	length;
  strcpy(output_buffer, "Session Manager version ");
  strcat(output_buffer, VersionNumber);
  strcat(output_buffer, ".\n");
  length = strlen(output_buffer);
  (void) Write(DiagnosticsStream, output_buffer, length, -1);
}
/*}}}*/
/*{{{  do_Create() */
/**-----------------------------------------------------------------------------
*** The Server Library routines.
***
*** do_create() serves two purposes:
***
*** 1) It can be used by the newuser command or the RmRegisterWindow()
***    routine to add an entry to the /sm/Windows directory.
*** 2) It can be used by the login command, the RmCreateSession() routine,
***    or anything else that is interested, to start a new session. Details
***    of the password must usually be supplied.
**/
static void do_create_session(ServInfo *);
static void do_create_window(ServInfo *);

static void do_create(ServInfo *servinfo)
{ MCB		*m		= servinfo->m;
  IOCCreate	*req		= (IOCCreate *) m->Control;
  DirNode	*d;

  Debug(dbg_Create, ("create request received"));
  
  d = GetTargetDir(servinfo);
  if (d eq Null(DirNode))
   { ErrorMsg(m, Err_Null); return; }

 	/* Two types of Create() are legal : */
	/* 1) Create("/sm/windows", "pc.windows.console", Type_Device, ...); */
	/* 2) Create("/sm", "bart", Type_Session, ...); */

  if ((d eq &SessionRoot) && (req->Type eq Type_Session))
   do_create_session(servinfo);
  elif ((d eq &Windows) && (req->Type eq Type_Device))
   do_create_window(servinfo);
  else
   ErrorMsg(m, EC_Error | EG_WrongFn + EO_Server);
}

	/* Creating a new entry in /sm/Windows.			*/
static void do_create_window(ServInfo *servinfo)
{ MCB		*m		= servinfo->m;
  ObjNode	*f		= Null(ObjNode);
  char		*pathname 	= servinfo->Pathname;
  IOCCreate	*req 		= (IOCCreate *) m->Control;
  RmWindowInfo	*info;
  MsgBuf	*r 		= Null(MsgBuf);
  WindowNode	*window_node	= Null(WindowNode);

  Debug(dbg_Create, ("registering a window"));

  f = GetTargetObj(servinfo);
  if (f ne Null(ObjNode))	/* window names must be unique */
   { Debug(dbg_Create, ("name already in use"));
     ErrorMsg(m, EC_Error + EG_InUse + EO_Name);
     goto error;
   }
  m->MsgHdr.FnRc = SS_SM;

	/* Allocate space for a new WindowNode, and initialise it.	   */
  window_node = New(WindowNode);
  if (window_node eq Null(WindowNode))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Name); }

  InitNode(&(window_node->ObjNode), objname(pathname), Type_Device, 0,
		 DefFileMatrix);
  InitList(&(window_node->ObjNode.Contents));
  window_node->Window		= Null(Object);
  window_node->WindowStream	= Null(Stream);
  window_node->LoginProgram	= Null(Object);
  window_node->LoginStream	= Null(Stream);
  window_node->WindowServer	= Null(Object);
  window_node->DefaultUser[0]	= '\0';

	/* Extract the information sent by the client		*/
	/* First, the default user name if any.			*/
  info = (RmWindowInfo *) &(m->Data[req->Info]);
  if (info->UserName ne -1)
   { string name = (string) RTOA(info->UserName);
     if (strlen(name) >= NameMax)
      { ErrorMsg(m, EC_Error + EG_WrongSize + EO_Name); goto error; }
     strcpy(window_node->DefaultUser, name);
   }

	/* Check the window that has been supplied.			*/
  Debug(dbg_Create, ("attempting to access this window"));

  window_node->Window = NewObject(RTOA(info->WindowName), &(info->WindowCap));
  if (window_node->Window eq Null(Object))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Window); goto error; }

  window_node->WindowStream = Open(window_node->Window, Null(char), info->Flags & Flags_Mode);
  if (window_node->WindowStream eq Null(Stream))
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Window); goto error; }
  if ((window_node->WindowStream->Flags & Flags_Interactive) eq 0)
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Window); goto error; }
  if (info->Pos > 0)
   (void) Seek(window_node->WindowStream, S_Beginning, info->Pos);

	/* Access the window server supplied, if any.			*/
  if (info->WindowServerName ne MinInt);
   { window_node->WindowServer = 
         NewObject(RTOA(info->WindowServerName), &(info->WindowServerCap));
     if (window_node->WindowServer eq Null(Object))
      { ErrorMsg(m, EC_Error + EG_Invalid + EO_Server); goto error; }
   }

 	/* Allocate the message buffer for FormOpenReply */
  r = New(MsgBuf);
  if( r == Null(MsgBuf) )
   { ErrorMsg(m,EC_Error+EG_NoMemory); goto error; }

 	/* Try to Fork() off the getty process */
  Debug(dbg_Create, ("spawning getty thread"));
  unless(Fork(Getty_Stack, &getty_process, 4, window_node))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Session); goto error; }

  	/* Everything is ready, prepare and send off the reply, insert	*/
  	/* the ObjNode into the /sm/windows/directory, and finished.	*/
  FormOpenReply(r, m, &(window_node->ObjNode), Flags_Server, pathname);
  Insert(&Windows, &(window_node->ObjNode), TRUE);
  PutMsg(&(r->mcb));
  Free(r);
  return;
      
error:
  if (window_node ne Null(WindowNode))
   { if (window_node->Window ne Null(Object))
      Close(window_node->Window);
     if (window_node->WindowStream ne Null(Stream))
      Close(window_node->WindowStream);
     if (window_node->WindowServer ne Null(Object))
      Close(window_node->WindowServer);
     Free(window_node);
   }
}

static void do_create_session(ServInfo *servinfo)
{ static int	sequence_number	= 1;
  MCB		*m		= servinfo->m;
  char		*pathname	= servinfo->Pathname;
  IOCCreate	*req		= (IOCCreate *) m->Control;
  ObjNode	*f;
  SessionNode	*session_node	= Null(SessionNode);
  RmLoginInfo	*info;
  MsgBuf	*r		= Null(MsgBuf);  
#ifdef SingleProcessor
  bool		no_tfm		= TRUE;
#else
  bool		no_tfm		= FALSE;
#endif

  Debug(dbg_Create, ("request to create a session"));
  
	/* Check whether the user is already logged in. If so add	*/
	/* a sequence number to the username and go back to locking	*/
	/* the parent directory.					*/
  f = GetTargetObj(servinfo);
  if (f ne Null(ObjNode))	/* User already logged in */
   { UnLockTarget(servinfo);
     servinfo->Target = (ObjNode *) &SessionRoot;
     LockTarget(servinfo);
     strcat(pathname, ".");
     addint(pathname, sequence_number++);
   }
  else
   m->MsgHdr.FnRc = SS_SM;

	/* On a single-processor system, users may log in with or	*/
	/* without a TFM. This is controlled by a # character in front	*/
	/* of the name. For compatibility this is supported even for	*/
	/* multi-processor systems, but it has no effect since the	*/
	/* default for multi-processor systems is to run a TFM.		*/
  { char	*tmp = objname(pathname);
    char	*tmp2, *tmp3;
    ObjNode	*junk;
    char	tempbuf[NameMax + 1];
    Object	*junk_obj;

    if (*tmp eq '#')
     { no_tfm = FALSE;
       for (tmp2 = tmp3 = tmp; *tmp2 ne '\0'; ) *tmp2++ = *++tmp3;

	/* It is necessary to check for a duplicate name again....	*/
       junk = Lookup( &SessionRoot, tmp, TRUE);
       if (junk ne Null(ObjNode))
	{ strcat(tmp, "."); addint(tmp, sequence_number++); }
     }

	/* Allow for users called helios, root, etc. whose names clash	*/
	/* with existing names. This assumes that server names are	*/
	/* fairly sensible and do not have .123 suffixes.		*/
    tempbuf[0]	= '/';
    strcpy(&(tempbuf[1]), tmp);
    junk_obj = Locate(Null(Object), tempbuf);
    if (junk_obj ne Null(Object))
     { strcat(tmp, "."); addint(tmp, sequence_number++); Close(junk_obj);}
  }

  if (TaskforceManager eq Null(Object)) no_tfm = TRUE;

	/* After these basic checks it is possible to allocate and	*/
	/* initialise a SessionNode structure.				*/
  session_node = New(SessionNode);
  if (session_node eq Null(SessionNode))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Session); goto done; }

						/* access: rwda:r:r:r	*/
  InitNode(&(session_node->ObjNode), objname(pathname), Type_Session, 0,
		0x010101C3);

  session_node->Window			= Null(Object);
  session_node->WindowStream		= Null(Stream);
  session_node->CurrentDirectory	= Null(Object);
  session_node->Program			= Null(Object);
  session_node->TFMProgram		= Null(Object);
  session_node->TFMStream		= Null(Stream);
  session_node->TFM			= Null(Object);

	/* the Create request contains various bits of info, including	*/
	/* window details. For batch jobs this is a batch log file.	*/
  info = (RmLoginInfo *) &(m->Data[req->Info]);

  session_node->Window = NewObject(info->WindowName, &(info->Cap));
  if (session_node->Window eq Null(Object))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Session); goto done; }

  session_node->WindowStream = Open(session_node->Window, Null(char), O_ReadWrite);
  if (session_node->WindowStream eq Null(Stream))
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Window); goto done; }

  if (session_node->WindowStream->Flags & Flags_Interactive)
   session_node->ObjNode.Flags |= Flags_Interactive;

  Debug(dbg_Create, ("validating password"));

	/* Validate the name and password.				*/
  if (!VerifyPassword(info->UserName, info->Password))
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Password); goto done; }

	/* In a single-user mode, there can be only one */
	/* BLV - user database addition			*/
  if (SingleUserMode && (SessionRoot.Nentries ne 1))
   { window_report(session_node->WindowStream, "this is a single-user system");
     ErrorMsg(m, EC_Error + EG_NoResource + EO_Session);
     goto done;
   }

  Debug(dbg_Create, ("obtaining user database information for this session"));
  unless(FillInSessionNode(info->UserName, session_node))
   { window_report(session_node->WindowStream, "invalid entry in user database");
     report("error in user database for name %s", info->UserName);
     ErrorMsg(m, EC_Error + EG_Invalid + EO_Name);
     goto done;
   }

  r = New(MsgBuf);
  if (r eq Null(MsgBuf))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Message); goto done; }

	/* Everything is fine, insert the node into the SessionRoot	*/
	/* directory before releasing the lock on the parent directory. */
  Insert(&SessionRoot, &(session_node->ObjNode), TRUE);

	/* Start the TFM if appropriate					*/
  unless(no_tfm)
   { int rc;

     UnLockTarget(servinfo);
     Debug(dbg_Create, ("attempting to start TFM"));
     rc = start_tfm(session_node);
     LockTarget(servinfo);
     if (rc ne Err_Null)
      { Unlink(&(session_node->ObjNode), TRUE);
	ErrorMsg(m, rc); goto done;
      }
   }

	/* Now construct the reply					*/
  req->Common.Access.Access = AccMask_Full; 
  FormOpenReply(r, m, &(session_node->ObjNode), 0, pathname);
  (void) PutMsg(&(r->mcb));
  Free(r); r = Null(MsgBuf);

	/* Unusually, the do_create thread hangs around waiting for	*/
	/* the TFM to terminate. This means the end of the session, so	*/
	/* some cleaning up is possible. This is only possible if there	*/
	/* is a TFM, of course...					*/
  unless(no_tfm)
   { UnLockTarget(servinfo);
     InitProgramInfo(session_node->TFMStream, PS_Terminate);
     Debug(dbg_Create, ("waiting for TFM termination"));
     GetProgramInfo(session_node->TFMStream, Null(WORD), -1);
     Debug(dbg_Create, ("TFM %s has terminated", session_node->TFMStream->Name));
     LockTarget(servinfo);
     Unlink(&(session_node->ObjNode), TRUE);
   }

done:
  if (r ne Null(MsgBuf)) Free(r);
  if ((session_node ne Null(SessionNode)) && !no_tfm)
   { if (session_node->TFMStream ne Null(Stream))
      { SendSignal(session_node->TFMStream, SIGKILL);
        Close(session_node->TFMStream);
      }
     if (session_node->TFMProgram ne Null(Object))
      { session_node->TFMProgram->FnMod	= 2;
	Delete(session_node->TFMProgram, Null(char));
        Close(session_node->TFMProgram);
      }
     if (session_node->TFM ne Null(Object))
      Close(session_node->TFM);
     if (session_node->Program ne Null(Object))
      Close(session_node->Program);
     if (session_node->CurrentDirectory ne Null(Object))
      Close(session_node->CurrentDirectory);
     if (session_node->WindowStream ne Null(Stream))
      Close(session_node->WindowStream);
     if (session_node->Window ne Null(Object))
      Close(session_node->Window);
     Free(session_node);
   }
}
/*}}}*/
/*{{{  do_Open() */

	/* do_open() serves several purposes:				*/
	/* 1) listing the directories /sm and /sm/Windows		*/
	/* 2) interacting with /sm/UserDatabase in future		*/
	/* 3) getting window details about another user			*/
	/* 4) getting full details about a newly created session	*/
static void do_open(ServInfo *servinfo)
{ MCB		*m          = servinfo->m;
  MsgBuf	*r	    = Null(MsgBuf);
  IOCMsg2	*req        = (IOCMsg2 *)(m->Control);
  char		*pathname   = servinfo->Pathname;
  Port		reqport;
  ObjNode	*f;
  SessionNode	*session;
  byte		*data = m->Data;
  int		bufsize = 0;
  BYTE		*buffer;       

  f = GetTarget(servinfo);
  if (f == Null(ObjNode)) 
   { ErrorMsg(m, EO_Object); return; }

	/* There is no point in opening /sm/windows/pc.window.console */
  if (f->Type eq Type_Device)
   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Window); return; }

	/* O_Private is used to find out capabilities etc. */
  if ((req->Arg.Mode & Flags_Mode) eq O_Private)
   { unless(CheckMask(req->Common.Access.Access, AccMask_D))
      { ErrorMsg(m, EC_Error + EG_Protected + EO_Object); return; }
   }
  else
   { unless( CheckMask(req->Common.Access.Access,(int)(req->Arg.Mode&Flags_Mode)) ) 
      { ErrorMsg(m,EC_Error+EG_Protected+EO_File); return; }
   }

  r = New(MsgBuf);
  if( r == Null(MsgBuf) )
   { ErrorMsg(m,EC_Error+EG_NoMemory); return; }

  FormOpenReply(r, m, f, Flags_Server | Flags_Closeable, pathname);

  reqport = NewPort();  
  r->mcb.MsgHdr.Reply = reqport;
  PutMsg(&r->mcb);
  Free(r);
  f->Account++;

	/* Accessing either /sm or /sm/windows */  
  if ((f->Type & Type_Flags) eq Type_Directory)
   { DirServer(servinfo, m, reqport); FreePort(reqport); return; }

#if 0
	/* Accessing /sm/UserDatabase, which does not exist in 1.2.x	*/
  if (f eq &UserDatabase)
   { OpenUserDatabase(servinfo, m, reqport); FreePort(reqport); return; }
#endif
	/* The client appears to be trying to access a current session. */     
	/* This may be an arbitrary user attempting to find out about	*/
	/* the login window for that user, or it may be the login	*/
	/* program attempting to get hold of the session's Taskforce	*/
	/* Manager, name+capability. The O_Private open mode is used	*/
	/* for the latter, read-only for the former. A suitable byte	*/
	/* buffer is allocated and filled in, so that GetFileSize()	*/
	/* and Read() are easy.						*/
  session = (SessionNode *) f;

  if ((req->Arg.Mode & Flags_Mode) eq O_Private)
   { RmSessionAux *aux;
     char	  *temp;
     
     bufsize = sizeof(RmSessionAux) + strlen(session->CurrentDirectory->Name) +
     		 strlen(session->Program->Name) + 3;
     if (session->TFM ne  (Object *) NULL)
      bufsize += strlen(session->TFM->Name) + 1;
      
     buffer = (BYTE *) Malloc(bufsize);
     if (buffer eq Null(BYTE)) goto done;
     aux = (RmSessionAux *) buffer;
     strcpy(aux->UserName, session->UserName);
     aux->Uid		= session->Uid;
     aux->Gid		= session->Gid;
     strcpy(aux->Comment, session->Comment);
     aux->CurrentDirCap	= session->CurrentDirectory->Access;
     aux->ProgramCap	= session->Program->Access;
     temp		= &(buffer[sizeof(RmSessionAux)]);
     if (session->TFM eq Null(Object))
      { memset(&(aux->TFMCap), 0, sizeof(Capability)); aux->TFMName = 0; }
     else
      { aux->TFMCap	= session->TFM->Access;
        aux->TFMName	= (word) temp - (word) &(aux->TFMName);
        strcpy(temp, session->TFM->Name);
        temp		+= strlen(temp) + 1;
      }
     strcpy(temp, session->CurrentDirectory->Name);
     aux->CurrentDirName = (word) temp - (word) &(aux->CurrentDirName);     
     temp		+= strlen(temp) + 1;
     strcpy(temp, session->Program->Name);
     aux->ProgramName	 = (word) temp - (word) &(aux->ProgramName);
   }
  else
   { RmLoginWindow	*window;
     bufsize	 = sizeof(RmLoginWindow) + strlen(session->Window->Name);
     buffer	 = (BYTE *) Malloc(bufsize);
     if (buffer eq Null(BYTE)) goto done;

     window	 = (RmLoginWindow *) buffer;
     window->Cap = session->Window->Access;
     strcpy(window->WindowName, session->Window->Name);
   }

  UnLockTarget(servinfo);
  
  forever
   { word e;
     m->MsgHdr.Dest = reqport;
     m->Timeout     = StreamTimeout;
     m->Data        = data;

     e = GetMsg(m);
     if (e == EK_Timeout) break;
     if (e < Err_Null) continue;
     
     Wait(&f->Lock);

     m->MsgHdr.FnRc = 0;

     switch(e & FG_Mask)
      {
      	 case FG_Read  :
      	 		{ WORD	Pos	= m->Control[0];
      	 		  WORD  Size 	= m->Control[1];
      	 		  WORD	rc	= ReadRc_EOF;
      	 		  
      	 		  if ((Pos >= bufsize) || (Pos < 0))
      	 		   { ErrorMsg(m, EC_Error + EG_WrongSize + EO_Window);
      	 		     break;
      	 		   }

			  if ((Pos + Size) > bufsize)
			   { Size = bufsize - Pos;
			     rc   = ReadRc_EOF;
			   }
   			  InitMCB(m, 0, m->MsgHdr.Reply, NullPort, rc);
   			  m->MsgHdr.DataSize = (int) Size;
   			  m->Data = &(buffer[Pos]);
   			  PutMsg(m);
   			  break;
			}
			      	 
      	 case FG_GetSize :
      	 		InitMCB(m, 0, m->MsgHdr.Reply, NullPort, Err_Null);
      	 		MarshalWord(m, bufsize);
      	 		PutMsg(m);
      	 		break;
      	 
         case FG_Close :
                        if (m->MsgHdr.Reply != NullPort) ErrorMsg(m, Err_Null);
                        Signal(&f->Lock);
		        goto done;
         default       :
                        ErrorMsg(m, EC_Error + SS_SM + EG_FnCode + EO_File);
                        break;
       }

     Signal(&f->Lock);
   }

done:
  f->Account--;
  FreePort(reqport);
}

/*}}}*/
/*{{{  do_Delete() */

	/* do_delete() can be used under exceptional circumstances to	*/
	/* abort a newly-created session by sending a kill signal to	*/
	/* the TFM.							*/
static void do_delete(ServInfo *servinfo)
{ MCB		*m		= servinfo->m;
  ObjNode	*o		= GetTarget(servinfo);
  IOCCommon	*req		= (IOCCommon *) m->Control;
  SessionNode	*session_node;

  Debug(dbg_Delete, ("request to abort a session"));

  if (o eq Null(ObjNode))
   { ErrorMsg(m, EC_Error + EG_Unknown + EO_Session); return; }
  if (o->Type ne Type_Session)
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Session); return; }
  unless(CheckMask(req->Access.Access, AccMask_D))
   { ErrorMsg(m, EC_Error + EG_Protected + EO_Object); return; }

  Debug(dbg_Delete, ("session exists, access rights checked..."));

	/* remove the directory entry, and acknowledge.			*/
  UnLockTarget(servinfo);
  Wait(&SessionRoot.Lock);
  Unlink(o, TRUE);

  ErrorMsg(m, Err_Null);

  Debug(dbg_Delete, ("attempting to destroy a running session"));

	/* If the relevant session involved a TFM, send a signal to	*/
	/* it. This should wake up do_create_session(), which will tidy	*/
	/* up as required.						*/
  session_node = (SessionNode *) o;
  if (session_node->TFMStream ne Null(Stream))
   { Stream *current = session_node->TFMStream;
     Stream *tfm = NewStream(current->Name, &(current->Access), current->Flags);
     SendSignal(tfm, SIGTERM);
     Close(tfm);
   }
	/* If this Session did not involve a TFM, do_delete has to	*/
	/* do the cleaning up.						*/
  else
   { 
     if (session_node->TFMProgram ne Null(Object))
      { session_node->TFMProgram->FnMod	= 2;
	Delete(session_node->TFMProgram, Null(char));
        Close(session_node->TFMProgram);
      }
     if (session_node->TFM ne Null(Object))
      Close(session_node->TFM);
     if (session_node->Program ne Null(Object))
      Close(session_node->Program);
     if (session_node->CurrentDirectory ne Null(Object))
      Close(session_node->CurrentDirectory);
     if (session_node->WindowStream ne Null(Stream))
      Close(session_node->WindowStream);
     if (session_node->Window ne Null(Object))
      Close(session_node->Window);
     Free(session_node);
   }

  Signal(&SessionRoot.Lock); 
}

/*}}}*/
/*{{{  do_Private() */

	/* do_private() is used by the Network Server to indicate that	*/
	/* something has gone wrong in the network. The Network Server	*/
	/* will have sent its capability, which can be compared with	*/
	/* the capability received on start-up. It is also used in	*/
	/* conjunction with diag_sm.					*/
static void do_debug(ServInfo *servinfo);

static void do_private(ServInfo *servinfo)
{ MCB            *m          = servinfo->m;
  ObjNode        *f;

  f = GetTarget(servinfo);
  if (f == Null(ObjNode)) 
   { ErrorMsg(m, EO_Object); return; }

  UnLockTarget(servinfo);
  if ((servinfo->FnCode & FG_Mask) eq FG_NetStatus)
   { Capability *cap	= (Capability *) &(m->Control[5]);
     unless (memcmp(cap, &RmLib_Cap, sizeof(Capability)) eq 0)
      { ErrorMsg(m, EC_Error + EG_Protected + EO_Server); return; }
     ErrorMsg(m, Err_Null);
     check_world();
   }
  elif ((servinfo->FnCode & FG_Mask) eq FG_GetInfo)
   do_debug(servinfo);
  else
   ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object);
}

static void	do_debug(ServInfo *servinfo)
{ MCB		*m	= servinfo->m;
  IOCMsg2	*req	= (IOCMsg2 *) m->Control;
  
  if (req->Arg.Mode eq dbg_Revert)
   { DiagnosticsStream = DefaultDiagnostics;
     m->MsgHdr.FnRc = 0;
     ErrorMsg(m, Err_Null);
     return;
   }
  
  if (req->Arg.Mode eq dbg_Redirect)
   { static	char	*message = "sm: output redirected\n";
     int	length	= strlen(message);
     Stream	*stream;
     WORD	index	= m->Control[6];
     StrDesc	*desc	= (StrDesc *) &(m->Data[index]);
     stream		= NewStream(desc->Name, &(desc->Cap), desc->Mode);
     stream->Pos	= desc->Pos;
     
     if (Write(stream, (BYTE *) message, length, -1) ne length)
      { ErrorMsg(m, EC_Error + EG_Open + EO_Stream);
        Close(stream);
        return;
      }
     if (DiagnosticsStream ne DefaultDiagnostics) Close(DiagnosticsStream);
     DiagnosticsStream = stream;
     m->MsgHdr.FnRc = 0;
     ErrorMsg(m, Err_Null);
     return;
   } 
   
  if (req->Arg.Mode ne dbg_Inquire)   
   DebugOptions = (int) req->Arg.Mode;
  if (DebugOptions & dbg_Memory)
   { report("currently %d bytes are free, the heap size is %d", Malloc(-1),
   		Malloc(-3));
     DebugOptions &= ~dbg_Memory;
#if ShowHeap_Debugging
     ShowHeap();
#endif
   }

#if Use_IOC_Debugging
  if (DebugOptions & dbg_IOC)
   { ShowIOC();
     DebugOptions &= ~dbg_IOC;
   }
#endif

  m->MsgHdr.FnRc = DebugOptions;
  ErrorMsg(m, Err_Null);  
}

/*}}}*/
/*{{{  getty process */

/**-----------------------------------------------------------------------------
*** The getty process. This is Fork()'ed off for every window that the Session
*** Manager is supposed to be in charge off. It runs the login program in an
*** infinite loop.
**/
static void getty_process(WindowNode *window_node)
{ Environ	Env;
  char		*Argv[3];
  char		*Envv[1];
  Stream	*Strv[5];
  Object	*Objv[OV_End + 1];
  Stream	*window = window_node->WindowStream;

  window->Flags 	&= ~Flags_CloseOnSend;

	/* The login environment can be built statically		*/    
  Argv[0]		 = LoginArgv0;
  Argv[2]		 = Null(char);
  Envv[0]		 = Null(char);
  Strv[0]		 = window;
  Strv[1]		 = window;
  Strv[2]		 = window;
  Strv[3]		 = my_environ->Strv[3];	/* /logger */
  Strv[4]		 = Null(Stream);
  Objv[OV_Cdir]		 = my_environ->Objv[OV_Cdir];
  Objv[OV_Task]		 = (Object *) MinInt;
  Objv[OV_Code]		 = (Object *) MinInt;
  Objv[OV_Source]	 = LoginProgram;
  Objv[OV_Parent]	 = my_environ->Objv[OV_Task];
  Objv[OV_Home]		 = my_environ->Objv[OV_Home];
  Objv[OV_Console]	 = NewObject(window->Name, &(window->Access));
  Objv[OV_CServer]	 = window_node->WindowServer;
  Objv[OV_Session]	 = (Object *) MinInt;
  Objv[OV_TFM]		 = (Object *) MinInt;
  Objv[OV_TForce]	 = (Object *) MinInt;
  Objv[OV_End]		 = Null(Object);
  Env.Envv		 = Envv;
  Env.Strv		 = Strv;
  Env.Objv		 = Objv;
  Env.Argv		 = Argv;
  
  forever
   { window_node->LoginProgram = Execute(Null(Object), LoginProgram);
     if (window_node->LoginProgram eq Null(Object))
      { report("failed to run login program in window %s", window->Name);
        break;
      }
     Objv[OV_Task]	= window_node->LoginProgram;
     
     window_node->LoginStream = Open(window_node->LoginProgram, Null(char), O_ReadWrite);
     if (window_node->LoginStream eq Null(Stream))
      { report("failed to open login program %s in window %s",
		window_node->LoginProgram->Name, window->Name);
       	break;
      }

     if (window_node->DefaultUser[0] eq '\0')
      Argv[1] = Null(char);
     else
      Argv[1] = window_node->DefaultUser;
     if (SendEnv(window_node->LoginStream->Server, &Env) < Err_Null)
      { report("failed to send environment to login program %s in window %s",
      		 window_node->LoginStream->Name, window->Name);
      	break;
      }
     window_node->DefaultUser[0] = '\0';
     InitProgramInfo(window_node->LoginStream, PS_Terminate);        
     GetProgramInfo( window_node->LoginStream, NULL, -1);

     Close(window_node->LoginStream);
     window_node->LoginStream	= Null(Stream);
     Delete(window_node->LoginProgram, Null(char));
     Close(window_node->LoginProgram);
     window_node->LoginProgram	= Null(Object);

	/* Various checks to ensure that this window still exists	*/
     if (window_node->ObjNode.Parent eq Null(DirNode)) break;
      { Object	*temp = Locate(Null(Object), window_node->Window->Name);
        if (temp eq Null(Object)) 
	 break;
        else
         Close(temp);
      }
   }

  Wait(&Windows.Lock);  
  if (window_node->ObjNode.Parent ne Null(DirNode))
   Unlink(&(window_node->ObjNode), TRUE);
  if (window_node->Window ne Null(Object))
   Close(window_node->Window);
  if (window_node->WindowStream ne Null(Stream))
   Close(window_node->WindowStream);
  if (window_node->WindowServer ne Null(Object))
   Close(window_node->WindowServer);
  if (window_node->LoginStream ne Null(Stream))
   { SendSignal(window_node->LoginStream, SIGKILL);
     Close(window_node->LoginStream);
   }
  if (window_node->LoginProgram ne Null(Object))
   { window_node->LoginProgram->FnMod = 2;
     Delete(window_node->LoginProgram, Null(char));
     Close(window_node->LoginProgram);
   }
  Free(window_node);
  Signal(&Windows.Lock);
}

/*}}}*/
/*{{{  start TFM */

/**-----------------------------------------------------------------------------
*** Starting up a TFM. In the single processor system the TFM always runs
*** locally. Otherwise it is  necessary to obtain a processor from the
*** Network Server.
**/
static int	run_tfm(SessionNode *, Object *processor, RmProcessor);

static int	start_tfm(SessionNode *session_node)
{ word		rc;
  Object	*processor_obj	= Null(Object);
  RmProcessor	obtained = (RmProcessor) NULL;

#ifndef SingleProcessor
  RmProcessor	template = RmNewProcessor();
  int		length;
  char		*attrib;

  if (template eq (RmProcessor) NULL)
   { rc = EC_Error + EG_NoMemory + EO_Processor; goto done; }

  template->ObjNode.Account = session_node->ObjNode.Account;
  length = strlen(session_node->WindowStream->Name) + 6;
  attrib = (char *) Malloc(length);
  if (attrib eq Null(char))
   { rc = EC_Error + EG_NoMemory + EO_Processor; goto done; }

  strcpy(attrib, "NEAR=");
  strcat(attrib, session_node->WindowStream->Name);
  rc = RmAddProcessorAttribute(template, attrib);
  Free(attrib);
  if (rc ne RmE_Success)
   { rc += EC_Error + EG_RmLib; goto done; }

  obtained  = RmObtainProcessor(template);
  if (obtained eq (RmProcessor) NULL)
   { rc = EC_Error + EG_RmLib + RmErrno; goto done; }

  processor_obj = RmMapProcessorToObject(obtained);
#else
	/* On a single-processor system the current processor has to	*/
	/* be used for the TFM.						*/
  processor_obj = Locate(ThisProcessor, Null(char));
#endif

  if (processor_obj eq Null(Object))
   { rc = EC_Error + EG_Invalid + EO_Processor; goto done; }

  rc = run_tfm(session_node, processor_obj, obtained);

done:
  if (processor_obj ne Null(Object))
   Close(processor_obj);

#ifndef SingleProcessor
  if (template ne (RmProcessor) NULL) RmFreeProcessor(template);
  if (obtained ne (RmProcessor) NULL)
   { RmReleaseProcessor(obtained);
     RmFreeProcessor(obtained);
   }
#endif
  return( (int)rc);
}

static int run_tfm(SessionNode *session, Object *processor, RmProcessor obtained)
{ Object	*procman	= Null(Object);
  Object	*tfm		= Null(Object);
  Object	*tfm_program	= Null(Object);
  Stream	*tfm_stream	= Null(Stream);
  Stream	*window_stream	= session->WindowStream;
  Object	*pipe_server	= Null(Object);
  Object	*pipe		= Null(Object);
  Stream	*pipe_stream	= Null(Stream);
  Environ	env;
  Stream	*strv[5];
  Object	*objv[OV_End + 1];
  char		*argv[4];
  char		argv2[NameMax];
  char		pipe_name[NameMax];
  static	int pipe_number = 1;
  word		rc = Err_Null;

  strv[0]		= Null(Stream);
  objv[OV_Console]	= Null(Object);
      
  pipe_server	= Locate(Null(Object), "/pipe");
  if (pipe_server eq Null(Object))
   { window_report(window_stream, "internal error");
     report("error accessing pipe server");
     rc = EC_Error + EG_Broken + EO_Processor;
     goto done;
   }

  strcpy(pipe_name, "sm.");
  addint(pipe_name, pipe_number++);
  pipe = Create(pipe_server, pipe_name, Type_Pipe, 0, Null(BYTE));
  if (pipe eq Null(Object))
   { window_report(window_stream, "internal error");
     report("error creating pipe %s", pipe_name);
     rc = EC_Error + EG_Create + EO_Pipe;
     goto done;
   }

  pipe_stream = PseudoStream(pipe, O_ReadWrite);
  if (pipe_stream eq Null(Stream))
   { window_report(window_stream, "internal error");
     report("error opening pipe %s", pipe->Name);
     rc = EC_Error + EG_Open + EO_Pipe;
     goto done;
   }

  strv[0] = PseudoStream(pipe, O_ReadWrite);
  if (strv[0] eq Null(Stream))
   { window_report(window_stream, "internal error");
     report("error opening pipe %s", pipe->Name);
     rc = EC_Error + EG_Open + EO_Pipe;
     goto done;
   }
    
  procman = Locate(processor, "tasks");        
  if (procman eq Null(Object))
   { window_report(window_stream, "internal error"); 
     report("error contacting Processor Manager %s/tasks, fault %x",
	  processor->Name, Result2(processor));
     rc = EC_Error + EG_Broken + EO_Processor; 
     goto done; 
   }

  tfm_program = Execute(procman, TaskforceManager);
  if (tfm_program eq Null(Object))
   { window_report(window_stream, "internal error");
     report("failed to execute Taskforce Manager, 0x%08x", Result2(procman));
     rc = EC_Error + EG_Create + EO_TFM;
     goto done;
   }
  tfm_stream = Open(tfm_program, Null(char), O_ReadWrite);
  if (tfm_stream eq Null(Stream))
   { window_report(window_stream, "internal error");
     report("failed to access Taskforce Manager %s, %08x", tfm->Name,
       		 Result2(tfm));
     rc = EC_Error + EG_Open + EO_TFM;
     goto done;
   }

  window_stream->Flags &= ~Flags_CloseOnSend;
  objv[OV_Cdir]		= session->CurrentDirectory;
  objv[OV_Task]		= tfm_program;
  objv[OV_Code]		= (Object *) MinInt;
  objv[OV_Source]	= TaskforceManager;
  objv[OV_Parent]	= my_environ->Objv[OV_Task];
  objv[OV_Home]		= session->CurrentDirectory;
  objv[OV_Console]	= NewObject(window_stream->Name, &(window_stream->Access));
  objv[OV_CServer]	= (Object *) MinInt;
  objv[OV_Session]	= (Object *) MinInt;
  objv[OV_TFM]		= (Object *) MinInt;	/* does not yet exist */
  objv[OV_TForce]	= (Object *) MinInt;
  objv[OV_End]		= Null(Object);
  strv[1]		= window_stream;
  strv[2]		= window_stream;
  strv[3]		= my_environ->Strv[3];
  strv[4]		= Null(Stream);
  argv[0]		= "SessionManager";
  argv[1]		= session->ObjNode.Name;
  argv[2]		= argv2;
#ifdef SingleProcessor
  strcpy(argv2, "                ");
#else  
  (void) DecodeCapability(argv2, &RmLib_Cap); 
#endif  
  argv[3]		= Null(char);
  env.Objv		= objv;
  env.Strv		= strv;
  env.Argv		= argv;
  env.Envv		= environ;
    
  if (SendEnv(tfm_stream->Server, &env) < Err_Null)
   { window_report(window_stream, "internal error");
     report("failed to send environment to %s, fault %08x", tfm_stream->Name,
     		Result2(tfm_stream));
     rc = EC_Error + EG_Broken + EO_Program;
     goto done;
   }

  Close(strv[0]); strv[0] = Null(Stream);

#ifndef SingleProcessor
  rc = RmWriteProcessor(pipe_stream, obtained, (RmFilter) NULL);
  if (rc ne RmE_Success)
   { rc |= (EC_Error + EG_RmLib);
     goto done;
   }
#else
  obtained = obtained;
#endif   
  { Capability	cap;
    if (Read(pipe_stream, (BYTE *) &cap, sizeof(Capability), 60 * OneSec) ne sizeof(Capability))
     { rc = EC_Error + EG_Broken + EO_TFM; goto done; }

    Close(pipe_stream); pipe_stream = Null(Stream);
    Delay(OneSec / 2);	/* unfortunately needed */

    tfm = Locate(processor, session->ObjNode.Name);
    if (tfm eq Null(Object))
     { rc = EC_Error + EG_Broken + EO_TFM; goto done; } 
    tfm->Access = cap;
  }
  
  rc = Err_Null;
  
done:
  if (procman ne Null(Object))		Close(procman);
  if (pipe_stream ne Null(Stream))	Close(pipe_stream);
  if (strv[0] ne Null(Stream))		Close(strv[0]);
  if (pipe ne Null(Object))
   { Delete(pipe, Null(char)); Close(pipe); }
  if (pipe_server ne Null(Object))	Close(pipe_server);

  if (rc eq Err_Null)
   { session->TFM		= tfm;
     session->TFMStream		= tfm_stream;
     session->TFMProgram	= tfm_program;
   }
  else
   { if (tfm_stream ne Null(Stream))
      { SendSignal(tfm_stream, SIGKILL); Close(tfm_stream); }
     if (tfm_program ne Null(Object))
      { tfm_program->FnMod = 2; Delete(tfm_program, Null(char)); Close(tfm_program); }
     if (tfm ne Null(Object)) Close(tfm);
   }
  return( (int)rc);
}

/*}}}*/
/*{{{  monitoring and fault-tolerance */

/**-----------------------------------------------------------------------------
*** Fault tolerance support: code to monitor all sessions and windows, and
*** take suitable recovery action when things go wrong.
**/
static void monitor_thread(void)
{ forever
   { Delay(MonitorInterval * OneSec);
     check_world();
   }
}

static void check_world(void)
{ SessionNode	*session;
  Object	*thingy;
  WindowNode	*window;

	/* locking the root prevents any inserts and deletes	*/
  Wait(&SessionRoot.Lock);

  Debug(dbg_Monitor, ("checking the network's consistency"));

	/* Check all the sessions with running TFM's, that the TFM	*/
	/* still exists.						*/
  for ( session = Head_(SessionNode, SessionRoot.Entries); 
        !EndOfList_(session);
	session = Next_(SessionNode, session))
   { if (session->ObjNode.Type ne Type_Session) continue;
     if (session->TFM eq Null(Object)) continue;

     thingy = Locate(Null(Object), session->TFM->Name);
     if (thingy eq Null(Object))
      { Stream *tfm_stream = session->TFMStream;
        window_report(session->WindowStream, "lost contact with TFM %s", tfm_stream->Name);
	report("lost contact with TFM %s", tfm_stream->Name);
        AbortPort(tfm_stream->Reply, EC_Fatal);
      }
     else
      Close(thingy);
   }

  Signal(&SessionRoot.Lock);
  Wait(&Windows.Lock);

  for ( window = Head_(WindowNode, Windows.Entries);
	!EndOfList_(window);
	window = Next_(WindowNode, window))
   { Stream	*login_stream = window->LoginStream;
     if (login_stream eq Null(Stream)) continue;

     thingy = Locate(Null(Object), window->LoginProgram->Name);
     if (thingy eq Null(Object))
      { window_report(window->WindowStream, "lost contact with login program %s, restarting",
			window->LoginProgram->Name);
	AbortPort(login_stream->Reply, EC_Fatal);
	continue;
      }
     else
      Close(thingy);

     thingy = Locate(Null(Object), window->Window->Name);
     if (thingy eq Null(Object))
      { AbortPort(login_stream->Reply, EC_Fatal);
        continue;
      }
     else
      Close(thingy);
   }

  Signal(&Windows.Lock);
}

/*}}}*/

@


1.18
log
@1) sorted out stack sizes
2) /sm/userdb now completely eradicated
3) new version number
@
text
@d16 1
a16 1
/* RcsId: $Header: /hsrc/network/RCS/session.c,v 1.17 1993/01/13 11:07:56 bart Exp $*/
d728 1
d760 1
a760 1
   { unless( CheckMask(req->Common.Access.Access,req->Arg.Mode&Flags_Mode) ) 
d818 1
a818 1
        aux->TFMName	= (int) temp - (int) &(aux->TFMName);
d823 1
a823 1
     aux->CurrentDirName = (int) temp - (int) &(aux->CurrentDirName);     
d826 1
a826 1
     aux->ProgramName	 = (int) temp - (int) &(aux->ProgramName);
d872 1
a872 1
   			  m->MsgHdr.DataSize = Size;
d900 1
d903 1
d967 1
d970 1
d1033 1
a1033 1
   DebugOptions = req->Arg.Mode;
d1053 1
d1056 1
d1163 1
d1166 1
d1175 1
a1175 1
{ int		rc;
d1227 1
a1227 1
  return(rc);
d1246 1
a1246 1
  int		rc = Err_Null;
d1395 1
a1395 1
  return(rc);
d1397 1
d1400 1
d1471 1
@


1.17
log
@Increased priority to a level higher than ordinary applications
@
text
@d16 1
a17 2
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/session.c,v 1.16 1992/10/07 13:41:18 bart Exp bart $";

d19 1
a19 1
static char *VersionNumber = "3.11";
d34 1
d117 1
a117 1
	  { do_private, 4000 },
d119 15
a133 15
	  	 { do_open,		2000 },
	  	 { do_create,		2000 },	/* Create */
	  	 { DoLocate,		2000 },
	  	 { DoObjInfo,		2000 },
	  	 { InvalidFn,		2000 },	/* ServerInfo */
	  	 { do_delete,		2000 }, /* Delete */
	  	 { InvalidFn,		2000 }, /* Rename */
	  	 { InvalidFn,		2000 }, /* Link   */
	  	 { DoProtect,		2000 },
	  	 { InvalidFn,		2000 }, /* SetDate */
	  	 { DoRefine,		2000 },
	  	 { NullFn,		2000 }, /* CloseObj */
	  	 { InvalidFn,		2000 },	/* Revoke */
	  	 { InvalidFn,		2000 }, /* Reserved1 */
	  	 { InvalidFn,		2000 }	/* Reserved2 */
d232 1
a235 1
#if 0
d253 1
a253 1
   if (!Fork(2000, &monitor_thread, 0))
d517 1
a517 1
  unless(Fork(2000, &getty_process, 4, window_node))
d779 1
d783 1
a783 1

@


1.16
log
@updated version number for next release
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/session.c,v 1.15 1992/08/13 18:29:04 bart Exp $";
d49 1
d164 4
@


1.15
log
@Fixed bug relating to simultaneous logins
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/session.c,v 1.13 1992/04/24 15:44:34 bart Exp $";
d20 1
a20 1
static char *VersionNumber = "3.10";
d34 1
@


1.14
log
@Changed the nsrc handling to allow for inheritance of environment strings
@
text
@d20 1
a20 1
static char *VersionNumber = "3.09";
d33 1
d657 4
d670 3
a672 1
      { ErrorMsg(m, rc); goto done; }
d675 1
a675 4
	/* Everything is fine, insert the node into the SessionRoot	*/
	/* directory and construct the reply.				*/
  Insert(&SessionRoot, &(session_node->ObjNode), TRUE);

@


1.13
log
@Added diagnostics support
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/session.c,v 1.12 1992/01/15 11:04:39 bart Exp $";
d107 1
d183 1
a183 1
  if ((argc ne 3) || strcmp(argv[0], "startns-magic"))
d185 2
a186 1

d198 3
a200 3
  SingleUserMode   = (get_config("single_user", environ) ne Null(char));
  PasswordChecking = (get_config("password_checking", environ) ne Null(char));
  MonitorInterval  = get_int_config("monitor_interval", environ);
d210 1
a210 1
  if (get_config("no_taskforce_manager", environ) eq Null(char))
@


1.12
log
@Major update of networking sources, to incorporate the fault-tolerance
work as demonstrated at the IED meeting 10.1.92
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/session.c,v 1.8 90/12/02 13:55:41 bart Exp $";
d19 2
a20 1
static char *VersionNumber = "3.08";
d32 1
d34 2
d57 9
d96 1
d102 1
a102 1

d115 1
a115 1
	  	 { do_open,		4000 },
d132 2
a133 2


d163 13
d177 2
a181 1
  argc = argc;		/* Discard compiler warning */
d263 2
a264 1

d394 2
a395 1

d414 2
d443 2
d447 4
a450 1
   { ErrorMsg(m, EC_Error + EG_InUse + EO_Name); goto error; }
d467 1
a467 1
  
d479 2
d507 1
d545 2
d628 2
d641 2
a642 1
    
d659 1
d682 1
d684 1
d714 2
a715 1

d886 2
a887 1

d897 2
d906 2
d915 2
d951 2
a952 1

d956 4
a959 1
	/* the capability received on start-up.				*/
d967 1
d975 3
a977 1
   }     
d982 55
d1143 2
a1144 1

d1339 2
a1341 1
    (void) Read(pipe_stream, (BYTE *) &cap, sizeof(Capability), 2 * OneSec);
d1375 2
a1376 1

d1396 2
d1447 1
@


1.11
log
@Major update of networking sources, to match Helios1_2_2_native_beta
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/session.c,v 1.2 1991/08/20 14:20:19 bart Exp $";
d19 1
a19 1
static char *VersionNumber = "3.07";
d30 1
d51 1
d53 15
a67 7
/*----------------------------------------------------------------------------*/
/**
*** Maintaining the user database is handled by a separate module
*** userdb.c, not written by me. This creates an entry userdb which
*** is added to the Session Manager directory. The Posix routines
*** getpwnam() etc. read this file. The user database module is also
*** responsible for verifying passwords.
a68 5
extern ObjNode	UserDatabase;
extern bool	InitUserDatabase(void);
extern void	OpenUserDatabase(ServInfo *, MCB *, Port);
extern bool	VerifyPassword(char *username, char *password);
extern bool	FillInSessionNode(char *username, SessionNode *);
a69 22
/*----------------------------------------------------------------------------*/
/**
*** The following string(s) may have to be changed at some later point.
BLV
BLV Should I assume that /helios is the current directory ? The current
BLV directory is inherited from startns.
**/
#define LoginName	"/helios/bin/login"
#define LoginArgv0	"login"
#define TfmName		"/helios/lib/tfm"

/*----------------------------------------------------------------------------*/
/**
*** forward declarations and statics. The /sm directory contains three
*** different types of entry. First there is the UserDatabase entry,
*** /sm/UserDatabase, used to implement the Posix routines getpwnam() etc.
*** Second there is a /windows subdirectory, giving details of all the
*** windows on which the Session Manager is waiting.
*** Third there are entries for all the current sessions, e.g. /sm/bart,
*** /sm/bart.2, /sm/jon.
**/

d72 1
a72 1
static int	do_private(ServInfo *);
d74 5
a78 3
       void	fatal(char *, ...);
static void	save_session_details(void);
static void	restore_session_details(void);
d80 4
a83 6
static Object		*NameEntry;
static Object		*ThisProcessor;
static DirNode		Root;
static bool		SingleUserMode	 = FALSE;
static int		NumberSessions	 = 0;
       bool		PasswordChecking = FALSE;
d85 4
d95 1
a95 1
	{ &Root,
d99 1
a99 1
	  { (VoidFnPtr) do_private, 2000 },
d127 1
a127 1
*** 2) fill in the various structures, ready for starting up the server
d130 1
a130 1
***    the root data structure.
d132 1
a132 1
*** 4) add the windows subdirectory, for windows added by the newuser
d135 2
a136 2
*** 5) If the Session Manager has been restarted, restore details of the
***    previous session from file.
d138 1
a138 2
*** 6) create the name table entry, storing the result in a static so that
***    it can be deleted when a terminate request has been received.
a139 2
*** 7) call the dispatcher
***
a141 28
***
*** The following bits of code do the real work.
*** a) newuser does a Create("/sm/window", name, Type_Device, window details)
***    The Session Manager accepts this entry,
***    and Fork()'s off a process to monitor this window. Said  process
***    continuously Read()'s from this window with a long timeout, for the
***    user to hit any key (a bit like getty). Then it executes the Login
***    program in that window. The Create request is rejected unless the
***    window in question has not been used yet.
***
*** b) login does a Create("/sm", <user name>, Type_Session, password, window)
***    The password is verified, and the Create() will fail if the password
***    is wrong. If the login program was run by the Session Manager then
***    the "<newuser>.xxx" entry will be changed to the user name.
***    Otherwise a new DirEntry is created, as is the Taskforce Manager
***
*** c) It is possible to open any entry in the Session Manager directory
***    and read back details of the window. This allows programs like
***    wall and talk.
***
*** d) It is possible to open any entry in the Session Manager with
***    the right capability and get names and capabilities for the
***    Taskforce Manager, and details of the user database.
***
BLV This system does not yet cope with batch jobs. It must be possible
BLV for an existing session to obtain permission to create a new session
BLV without the user having to quote the password, or alternatively for
BLV an existing session to obtain the password.
d145 1
a145 2
{ char			ProcessorName[128];
  bool			restart = FALSE;
d147 1
a147 1
  fprintf(stderr, "Session Manager : version %s.\r\n", VersionNumber);
d149 2
a151 1
  signal(SIGPIPE, SIG_IGN);
d157 2
a161 1

a164 3
  if (strcmp(argv[2], "-r"))
   restart = TRUE;
  
d168 1
a168 1
  SingleUserMode = (get_config("single_user", environ) ne Null(char));
d170 1
a184 3

  my_environ	= getenviron();

d188 1
a188 1
  InitNode((ObjNode *) &Root, "sm", Type_Directory, 
d190 4
a193 2
  InitList(&(Root.Entries));
  Root.Nentries = 0;
d198 4
a201 3
/* There is no point in having a User database entry yet
  Insert(&Root, &UserDatabase, FALSE);
*/
d206 1
a206 1
  Insert(&Root, (ObjNode *) &Windows, FALSE);
d208 6
a213 5
  if (restart)
   restore_session_details();
    
  if ((SessionInfo.ReqPort = NewPort()) eq NullPort)
   fatal("unable to allocate a message port");
d215 4
d237 5
a241 2
void fatal(char *format, ...)
{ va_list list;
d243 4
a246 1
  Wait(&(LibraryLock));
d248 40
a287 8
  va_start(list, format);
  
  fputs("Session Manager : ", stderr);
  vfprintf(stderr, format, list);
  va_end(list);
  fputs(".\r\nSession Manager : exiting.\r\n", stderr);
  
  exit(EXIT_FAILURE);
d290 5
a294 2
void warn(char *format, ...)
{ va_list list;
d296 10
d308 1
a308 2
  fputs("Session Manager : warning, ",stderr);
  vfprintf(stderr, format, list);
a309 3
  fputs("\r\n", stderr);
  Signal(&(LibraryLock));
}  
d311 11
a321 4
void report(Stream *stream, char *format, ...)
{ static char buf[IOCDataMax];
  static char *message = "Session Manager: ";
  va_list args;
d326 1
a326 1
  vsprintf(buf, format, args);
d328 1
a328 3
  (void) Write(stream, message, strlen(message), -1);
  (void) Write(stream, buf, strlen(buf), -1);
  (void) Write(stream, ".\r\n", 3, -1);
d332 44
a375 8
/*----------------------------------------------------------------------------*/
/**
*** The Server Library routines. First do_create(). This serves two separate
*** purposes. The newuser command does a 
*** Create("/sm/window", "pc.windows.console", Type_Device, ...)
*** to register a window with the Session Manager. The login program and
*** similar programs do a Create("/sm", <username>, Type_Session) with
*** details of the password etc.
d377 2
a378 2
static void do_create_session(MCB *, ServInfo *);
static void do_create_window(MCB *,  ServInfo *);
d389 1
a389 6
	/* Do not bother to CheckMask() at this point, or else newuser	*/
	/* would have problems coping. N.B. the Session Manager uses	*/
	/* restricted protection only, because it can be accessed by	*/
	/* anything.							*/
	
	/* Two types of Create() are legal : */
a391 6
	
  if ((d eq &Root) && (req->Type eq Type_Session))
   { do_create_session(m, servinfo); return; }
  
  if ((d eq &Windows) && (req->Type eq Type_Device))
   { do_create_window(m, servinfo); return; }
d393 6
a398 1
  ErrorMsg(m, EC_Error | EG_WrongFn + EO_Server);
d401 9
a409 14
/*----------------------------------------------------------------------------*/
/**
*** do_create_window()
*** Called with DirNode Windows locked, and a Create request for some new
*** object inside the /sm/windows directory.
***
*** The NewUser command has packed various bits of info in the data vector.
*** This includes a default user name in the form of an rptr, and details
*** of the window. The routine has to extract the default user name if any
*** (-1 indicates no default), and Open a stream to the window. If the
*** stream cannot be opened something has gone screwy in the system.
*** The main job of this routine is to Fork() off a getty process, which
*** runs login programs inside the window.
**/
d411 4
a414 2
static void getty_process(Object *WindowServer, Stream *stream, ObjNode *f, 
			char *UserName);
d416 4
a419 9
static void do_create_window(MCB *m, ServInfo *servinfo)
{ ObjNode	*f = Null(ObjNode);
  char		*pathname = servinfo->Pathname;
  IOCCreate	*req = (IOCCreate *) m->Control;
  RmWindowInfo	*Info;
  char		*DefaultUser = Null(char);
  Stream	*WindowStream = Null(Stream);
  Object	*WindowServer = (Object *) MinInt;
  MsgBuf	*r = Null(MsgBuf);
d421 9
a429 5
  f = GetTargetObj(servinfo);

  if (f ne Null(ObjNode))	/* name must be unique */
   { ErrorMsg(m, EC_Error + EG_InUse + EO_Name); goto error; }
  m->MsgHdr.FnRc = SS_SM;	/* Clear error field again, was EG_Unknown */
d431 8
a438 12
	/* Try to extract the default user name, if any */
  Info = (RmWindowInfo *) &(m->Data[req->Info]);
  if (Info->UserName eq -1)
   DefaultUser = Null(char);
  else
   { char *username = (BYTE *)
          (Info->UserName + (int) ((BYTE *)&(Info->UserName)));
     DefaultUser = (char *) Malloc(strlen(username) + 1);
     if (DefaultUser eq Null(char))
      { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Window); goto error; }
     else
      strcpy(DefaultUser, username);
d441 4
a444 18
	/* Try to access the window supplied. N.B. For proper validation*/
	/* the Session Manager actually attempts to Open() the stream	*/
	/* rather than use NewStream().					*/
  { char *windowname = (char *)
         (Info->WindowName + (int) ((BYTE *)&(Info->WindowName)));
    Object	*window = NewObject(windowname, &Info->WindowCap);
    
    if (window eq Null(Object))
     { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Window); goto error; }
    WindowStream = Open(window, Null(char), Info->Flags & Flags_Mode);
    Close(window);
    if (WindowStream eq Null(Stream))
     { ErrorMsg(m, EC_Error + EG_Invalid + EO_Window); goto error; }
    if ((WindowStream->Flags & Flags_Interactive) eq 0)
     { ErrorMsg(m, EC_Error + EG_Invalid + EO_Window); goto error; }
    if (Info->Pos > 0)
     (void) Seek(WindowStream, S_Beginning, Info->Pos);
  }
d446 13
a458 8
	/* Try to access the window server supplied in the message,	*/
	/* if any. The RegisterWindow() routine obtains this from the	*/
	/* environment, and it gets inherited all the way from init	*/
  if (Info->WindowServerName ne MinInt);
   { char	*window_server_name = (char *)
  	(Info->WindowServerName + (int) ((BYTE *)&(Info->WindowServerName)));
     WindowServer = NewObject(window_server_name, &(Info->WindowServerCap));
     if (WindowServer eq Null(Object))
a461 25
	/* Check for Uniqueness of the Window name, N.B. not guaranteed */
	/* because network addresses may change				*/
	/* N.B. parent directory is still locked. */
  { ObjNode	*o = (ObjNode *) Windows.Entries.Head;
  
    for ( ; o->Node.Next ne Null(Node); o = (ObjNode *) o->Node.Next)
     { Stream *s = (Stream *) o->Contents.Head;
       if (!strcmp(s->Name, WindowStream->Name))
        { ErrorMsg(m, EC_Error + EG_InUse + EO_Window); goto error; }
     }
  }
     
	/* Allocate and initialise the ObjNode structure */
  if ( (f = New(ObjNode)) eq Null(ObjNode))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Window); return; }

  { char *name = pathname + strlen(pathname);
    for ( ; *name ne '/'; name--);
    if (strlen(++name) >= NameMax)
     { ErrorMsg(m, EC_Error +EG_WrongSize + EO_Name); Free(f); return; }
     
    InitNode(f, name, Type_Device, 0, DefFileMatrix);
    f->Contents.Head = (Node *) WindowStream;
  } 

d465 1
a465 1
   { ErrorMsg(m,EC_Error+EG_NoMemory); return; }
d468 1
a468 2
  unless(Fork(2000, &getty_process, 16, WindowServer, WindowStream, f,
  		 DefaultUser))
d473 2
a474 2
  FormOpenReply(r, m, f, Flags_Server, pathname);
  Insert(&Windows, f, TRUE);
d480 8
a487 110
  if (DefaultUser ne Null(char)) Free(DefaultUser);
  if (WindowStream ne Null(Stream)) Close(WindowStream);
  if ((WindowServer ne Null(Object)) && (WindowServer ne (Object *) MinInt))
   Close(WindowServer);
  if (r ne Null(MsgBuf)) Free(r);
  if (f ne Null(ObjNode)) Free(f);
}

/*----------------------------------------------------------------------------*/
/**
*** The getty process. This is Fork()'ed off for every window that the Session
*** Manager is supposed to be in charge off. It is supposed to wait for the
*** user to press a key in the given window, like getty, and then run a login
*** session in that window. In practice this is not compatible because
*** in Helios 1.1 the login prompt appears immediately. Hence in the infinite
*** loop the login program is run first.
BLV
BLV Questions :
BLV  1) should this process read in the user name, like Unix getty ?
BLV     That would leave login only having to cope with the password
BLV  2) should the login program be run remotely ?
**/
static void getty_process(Object *WindowServer, Stream *window, ObjNode *f, 
			char *UserName)
{ Environ	Env;
  char		*Argv[3];
  char		*Envv[1];
  Stream	*Strv[5];
  Object	*Objv[OV_End + 1];
  Object	*Program = Null(Object);
  Stream	*ProgStream = Null(Stream);
  WORD		ProgInfoSize;
  WORD		*ProgInfoVec;
    
  Argv[0]	= LoginArgv0;
  Argv[2]	= Null(char);
  Envv[0]	= Null(char);
  window->Flags &= ~Flags_CloseOnSend;
  Strv[0]	= window;
  Strv[1]	= window;
  Strv[2]	= window;
  Strv[3]	= my_environ->Strv[3];
  Strv[4]	= Null(Stream);
  Objv[OV_Cdir]		= my_environ->Objv[OV_Cdir];
  Objv[OV_Task]		= (Object *) MinInt;
  Objv[OV_Code]		= (Object *) MinInt;
  Objv[OV_Source]	= LoginProgram;
  Objv[OV_Parent]	= my_environ->Objv[OV_Task];
  Objv[OV_Home]		= my_environ->Objv[OV_Home];
  Objv[OV_Console]	= NewObject(window->Name, &(window->Access));
  Objv[OV_CServer]	= WindowServer;
  Objv[OV_Session]	= (Object *) MinInt;
  Objv[OV_TFM]		= (Object *) MinInt;
  Objv[OV_TForce]	= (Object *) MinInt;
  Objv[OV_End]		= Null(Object);
  Env.Envv	= Envv;
  Env.Strv	= Strv;
  Env.Objv	= Objv;
  Env.Argv	= Argv;
  
  forever
   { Program = Execute(Null(Object), LoginProgram);
     if (Program eq Null(Object))
      { warn("failed to run login program in window %s", window->Name);
        break;
      }
     Objv[OV_Task]	= Program;
     
     ProgStream = Open(Program, Null(char), O_ReadWrite);
     if (ProgStream eq Null(Stream))
      { warn("failed to open login program %s in window %s", Program->Name,
      		window->Name);
       	break;
      }
     f->Contents.Head	= (Node *) ProgStream; 
     Argv[1] = UserName;
     if (SendEnv(ProgStream->Server, &Env) < Err_Null)
      { warn("failed to send environment to login program %s in window %s",
      		 ProgStream->Name, window->Name);
      	break;
      }
      	/* The default UserName only applies first time around */
     if (UserName ne Null(char))
      { Free(UserName); UserName = Null(char); }
           
     ProgInfoSize = InitProgramInfo(ProgStream, PS_Terminate);
     if (ProgInfoSize eq 0)
      { warn("internal error, InitProgramInfo failed for login program %s, window %s",
             ProgStream->Name, window->Name);
        break;
      }
    ProgInfoVec = (WORD *) Malloc(ProgInfoSize * sizeof(WORD));
    if (ProgInfoVec eq Null(WORD))
     { warn("out of memory when running login program %s in window %s",
     		ProgStream->Name, window->Name);
       break;
     }

    (void) GetProgramInfo(ProgStream, ProgInfoVec, -1);
    Free(ProgInfoVec);
    Close(ProgStream);
    (void) Delete(Program, Null(char));
    Close(Program);
    Program = Null(Object);
    ProgStream = Null(Stream);
    if (f->Parent eq Null(DirNode)) break;
    { Object	*temp = Locate(Null(Object), window->Name);
      if (temp eq Null(Object)) break;
      Close(temp);
    }
a488 13
  
  if (f->Parent ne Null(DirNode))
   Unlink(f, FALSE);
  if (UserName ne Null(char)) Free(UserName);
  if (ProgStream ne Null(Stream))
   { (void) SendSignal(ProgStream, SIGTERM);
     Close(ProgStream);
   }
  if (Program ne Null(Object))
   { (void) Delete(Program, Null(char));
     (void) Close(Program);
   }
  Close(window);  
a489 17
/*----------------------------------------------------------------------------*/
/**
*** do_create_session(). Create an actual session, i.e. do the Session
*** Manager's main job. This involves the following steps.
***
*** 1) extract the User ID, password, and stream. Verify the password and
***    get the information about the session.
*** 2) Get space for the SessionNode structure and initialise it.
*** 3) Try to obtain a processor to run the Taskforce Manager. If this fails
***    then there are insufficient network resources.
*** 4) Run the Taskforce Manager on that processor, and pass it details
***    of the processor
*** 5) Insert the SessionNode into the directory, and return a success
***    message.
*** 6) Wait for the Taskforce Manager to terminate, and then unlink the
***    session node.
**/
d491 1
a491 5
static Stream	*do_start_tfm(int *rc_ptr, RmProcessor obtained,
	Object *processor, Stream *WindowStream, SessionNode *session,
		char *sessionname);

static void do_create_session(MCB *m, ServInfo *servinfo)
d493 1
a493 1
  SessionNode	*f		= Null(SessionNode);
d496 2
a499 4
  Stream	*WindowStream	= Null(Stream);
  Stream	*TfmStream	= Null(Stream);    
  Object	*Processor	= Null(Object);
  RmProcessor	Obtained	= (RmProcessor) NULL;
d509 2
a510 2
  f = (SessionNode *) GetTargetObj(servinfo);
  if (f ne Null(SessionNode))	/* User already logged in */
d512 1
a512 1
     servinfo->Target = (ObjNode *) &Root;
a515 1
     f = Null(SessionNode);
d525 6
a530 2
  { char *tmp = objname(pathname);
     
d532 2
a533 6
     { char	*tmp2, *tmp3;
       ObjNode *junk;
        
       no_tfm = FALSE;
       tmp2 = tmp; tmp3 = &(tmp[1]);
       until(*tmp2 eq '\0') *tmp2++ = *tmp3++;
d536 1
a536 1
       junk = Lookup( &Root, tmp, TRUE);
d538 1
a538 3
	{ strcat(pathname, ".");
	  addint(pathname, sequence_number++);
	}
d540 1
a540 1
  }
d544 5
a548 10
  { char	tempbuf[NameMax + 1];
    Object	*junk;
    tempbuf[0] = '/';
    strcpy(&(tempbuf[1]), objname(pathname));
    junk = Locate(Null(Object), tempbuf);
    if (junk ne Null(Object))
     { strcat(pathname, ".");
       addint(pathname, sequence_number++);
       Close(junk);
     }
d550 23
a572 1
	/* The stream passed must be reasonable */
a573 8
  { Object *Window = NewObject(info->WindowName, &(info->Cap));   
    if (Window eq Null(Object))
     { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Session); return; }
    WindowStream = Open(Window, Null(char), O_ReadWrite);
    Close(Window);
    if (WindowStream eq Null(Stream))
     { ErrorMsg(m, EC_Error + EG_Invalid + EO_Window); return; }
  }
d575 3
a577 4
	/* Validate the name and password sent to the Session Manager */   
  if (!VerifyPassword(info->UserName, (info->Password[0] eq '\0') ? Null(char) :
  			info->Password))
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Password); return; }
d579 11
d591 3
a593 2
  if (SingleUserMode && (NumberSessions ne 0))
   { report(WindowStream, "this is a single-user system");
d595 1
a595 1
     return;
d597 4
a600 25
  NumberSessions++;
  

	/* Time to fill in a SessionNode structure */
  f = New(SessionNode);
  if (f eq Null(SessionNode))
   { report(WindowStream, "out of memory");
     warn("out of memory");
     ErrorMsg(m, EC_Error + EG_NoMemory + EO_Session); 
     goto done; 
   }
  							/* access: rwda:r:r:r */
  InitNode(&(f->ObjNode), objname(pathname), Type_Session, 
  	   (WindowStream->Flags & Flags_Interactive), 0x010101C3);
  if ((WindowStream->Flags & Flags_Interactive) ne 0)
   f->ObjNode.Size = 1;
  f->Window		= WindowStream;
  f->TFM		= Null(Object);
  f->CurrentDirectory	= Null(Object);
  f->Program		= Null(Object);
  f->TFMProgram		= Null(Stream);
  
  unless(FillInSessionNode(info->UserName, f))
   { report(WindowStream, "invalid entry in user database");
     warn("error in user database for name %s", info->UserName);
d606 2
a607 1
  if (r eq Null(MsgBuf)) goto done;
d609 3
a611 18
  if (get_config("no_taskforce_manager", environ) ne Null(char))
   f->TFM = (Object *) MinInt;
#ifdef SingleProcessor
	/* On a SingleProcessor system, only create a TFM if the name	*/
	/* began with a # character.					*/
  elif (no_tfm)
   f->TFM = (Object *) MinInt;
#endif   
  else
   	/* Try to obtain a processor for the Taskforce Manager	*/
   	/* In a single-processor system this is irrelevant, as	*/
   	/* the TFM will be run locally.				*/
   { 
     int		rc;
#ifndef SingleProcessor
     RmProcessor	template = RmNewProcessor();
     int		length;
     char		*attrib;
d613 4
a616 40
     if (template eq (RmProcessor) NULL)
      { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Processor); goto done; }
     template->ObjNode.Account = f->ObjNode.Account;
     length = strlen(WindowStream->Name) + 6;
     attrib = (char *) Malloc(length);
     if (attrib eq Null(char))
      { RmFreeProcessor(template);
        ErrorMsg(m, EC_Error + EG_NoMemory + EO_Processor); 
        goto done; 
      }
     strcpy(attrib, "NEAR=");
     strcat(attrib, WindowStream->Name);
     rc = RmAddProcessorAttribute(template, attrib);
     Free(attrib);
     if (rc ne RmE_Success)
      { RmFreeProcessor(template);
        ErrorMsg(m, EC_Error + EG_RmLib + rc);
        goto done;
      }

     Obtained  = RmObtainProcessor(template);
     RmFreeProcessor(template);
     if (Obtained eq (RmProcessor) NULL)
      { ErrorMsg(m, EC_Error + EG_RmLib + RmErrno); goto done; }

     Processor = RmMapProcessorToObject(Obtained);
#else
	/* On a single-processor system the current processor has to	*/
	/* be used for the TFM.						*/
     Processor = Locate(ThisProcessor, Null(char));
#endif

     if (Processor eq Null(Object))
      { ErrorMsg(m, EC_Error + EG_Invalid + EO_Processor);
        goto done;
      }

     TfmStream = do_start_tfm(&rc, Obtained, Processor, WindowStream, f,
                              pathname);
     if (TfmStream eq Null(Stream))
a617 1
     f->TFMProgram = TfmStream;
d620 3
a623 8
	/* Add the entry to the /sm directory and wait for the Taskforce*/
	/* Manager to come up. During this time the Session Manager	*/
	/* must be unlocked in case the Taskforce Manager is trying	*/
	/* to access the Session Manager.				*/
  Insert(&Root, &(f->ObjNode), TRUE);
  UnLockTarget(servinfo);
  	
  LockTarget(servinfo);		/* while the reply is constructed */
d625 1
a625 2
  FormOpenReply(r, m, &(f->ObjNode), 0, pathname);
  UnLockTarget(servinfo);
d627 1
a627 2
  Free(r);
  r = Null(MsgBuf);
d629 10
a638 4
	/* Cope with the case of no_taskforce_manager */
  if (TfmStream eq Null(Stream))
   { if (WindowStream ne Null(Stream)) Close(WindowStream);
     return;
a639 8
   	/* Now wait for the Taskforce Manager to terminate.		*/
	/* That means the end of the session, so the entry must be	*/
	/* removed from the root directory.				*/
  if (InitProgramInfo(TfmStream, PS_Terminate) >= Err_Null)
   { (void) GetProgramInfo(TfmStream, Null(WORD), -1);
     Close(TfmStream);
     TfmStream = Null(Stream);
   }
a640 3
  LockTarget(servinfo);
  Unlink(&(f->ObjNode), TRUE);
  
a641 21
  NumberSessions--;
  if (TfmStream ne Null(Stream))
   { SendSignal(TfmStream, SIGKILL);
     Close(TfmStream);
   }
  if (f ne Null(SessionNode))
   { 
     if ((f->TFM ne Null(Object)) && (f->TFM ne (Object *) MinInt))
      Close(f->TFM);
     if (f->CurrentDirectory ne Null(Object)) Close(f->CurrentDirectory);
     if (f->Program ne Null(Object)) Close(f->Program);
     Free(f);
   }
  if (WindowStream ne Null(Stream)) Close(WindowStream);
  if (Processor ne Null(Object)) Close(Processor);

#ifndef SingleProcessor
  if (Obtained ne (RmProcessor) NULL)
   { RmReleaseProcessor(Obtained); RmFreeProcessor(Obtained); }
#endif
   
d643 4
a646 163
}

static Stream	*do_start_tfm(int *rc_ptr, RmProcessor Obtained,
	Object *Processor, Stream *WindowStream, SessionNode *session,
	char	*sessionname)
{ Object	*ProcMan	= Null(Object);
  Object	*TFM		= Null(Object);
  Stream	*TfmStream	= Null(Stream);
  Object	*PipeServer	= Null(Object);
  Object	*Pipe		= Null(Object);
  Stream	*PipeStream	= Null(Stream);
  Environ	Env;
  Stream	*Strv[5];
  Object	*Objv[OV_End + 1];
  char		*Argv[4];
  char		argv2[NameMax];
  char		pipe_name[NameMax];
  static	int pipe_number = 1;
  int		rc = Err_Null;

  Strv[0]		= Null(Stream);
  Objv[OV_Console]	= Null(Object);
      
  PipeServer	= Locate(Null(Object), "/pipe");
  if (PipeServer eq Null(Object))
   { report(WindowStream, "internal error");
     warn("error accessing pipe server");
     rc = EC_Error + EG_Broken + EO_Processor;
     goto done;
   }

  strcpy(pipe_name, "sm.");
  addint(pipe_name, pipe_number++);
  Pipe = Create(PipeServer, pipe_name, Type_Pipe, 0, Null(BYTE));
  Close(PipeServer); PipeServer = Null(Object);
  if (Pipe eq Null(Object))
   { report(WindowStream, "internal error");
     warn("error creating pipe %s", pipe_name);
     rc = EC_Error + EG_Create + EO_Pipe;
     goto done;
   }

  PipeStream = PseudoStream(Pipe, O_ReadWrite);
  if (PipeStream eq Null(Stream))
   { report(WindowStream, "internal error");
     warn("error opening pipe %s", Pipe->Name);
     rc = EC_Error + EG_Open + EO_Pipe;
     (void) Delete(Pipe, Null(char)); Close(Pipe); Pipe = Null(Object);
     goto done;
   }

  Strv[0] = PseudoStream(Pipe, O_ReadWrite);
  if (Strv[0] eq Null(Stream))
   { report(WindowStream, "internal error");
     warn("error opening pipe %s", Pipe->Name);
     rc = EC_Error + EG_Open + EO_Pipe;
     Close(PipeStream); PipeStream = Null(Stream);
     (void) Delete(Pipe, Null(char)); Close(Pipe); Pipe = Null(Object);
     goto done;
   }
    
  ProcMan = Locate(Processor, "tasks");        
  if (ProcMan eq Null(Object))
   { report(WindowStream, "internal error"); 
     warn("error contacting Processor Manager %s/tasks, fault %x",
	  Processor->Name, Result2(Processor));
     rc = EC_Error + EG_Broken + EO_Processor; 
     goto done; 
   }

  TFM = Execute(ProcMan, TaskforceManager);
  if (TFM eq Null(Object))
   { report(WindowStream, "internal error");
     warn("failed to execute Taskforce Manager, 0x%08x", Result2(ProcMan));
     rc = EC_Error + EG_Create + EO_TFM;
     goto done;
   }
  TfmStream = Open(TFM, Null(char), O_ReadWrite);
  if (TfmStream eq Null(Stream))
   { report(WindowStream, "internal error");
     warn("failed to access Taskforce Manager %s, %08x", TFM->Name,
       		 Result2(TFM));
     (void) Delete(TFM, Null(char));
     Close(TFM);
     rc = EC_Error + EG_Open + EO_TFM;
     goto done;
   }

  WindowStream->Flags &= ~Flags_CloseOnSend;
  Objv[OV_Cdir]		= session->CurrentDirectory;
  Objv[OV_Task]		= TFM;
  Objv[OV_Code]		= (Object *) MinInt;
  Objv[OV_Source]	= TaskforceManager;
  Objv[OV_Parent]	= my_environ->Objv[OV_Task];
  Objv[OV_Home]		= session->CurrentDirectory;
  Objv[OV_Console]	= NewObject(WindowStream->Name, &(WindowStream->Access));
  Objv[OV_CServer]	= (Object *) MinInt;
    	/* BLV PseudoObject in GetEnv needed here */
  Objv[OV_Session]	= (Object *) MinInt;
  Objv[OV_TFM]		= (Object *) MinInt;	/* does not yet exist */
  Objv[OV_TForce]	= (Object *) MinInt;
  Objv[OV_End]		= Null(Object);
  Strv[1]		= WindowStream;
  Strv[2]		= WindowStream;
  Strv[3]		= my_environ->Strv[3];
  Strv[4]		= Null(Stream);
  Argv[0]		= "SessionManager";
  Argv[1]		= objname(sessionname);
  Argv[2]		= argv2;
#ifdef SingleProcessor
  strcpy(argv2, "                ");
#else  
  (void) DecodeCapability(argv2, &RmLib_Cap); 
#endif  
  Argv[3]		= Null(char);
  Env.Objv		= Objv;
  Env.Strv		= Strv;
  Env.Argv		= Argv;
  Env.Envv		= environ;
    
  if (SendEnv(TfmStream->Server, &Env) < Err_Null)
   { 
     report(WindowStream, "internal error");
     warn("failed to send environment to %s, fault %08x", TfmStream->Name,
     		Result2(TfmStream));
     rc = EC_Error + EG_Broken + EO_Program;
     goto done;
   }

  Close(Strv[0]); Strv[0] = Null(Stream);
#ifndef SingleProcessor
  rc = RmWriteProcessor(PipeStream, Obtained, (RmFilter) NULL);
  if (rc ne RmE_Success)
   { rc |= (EC_Error + EG_RmLib);
     goto done;
   }
#else
  Obtained = Obtained;
#endif   
  { Capability	cap;
    Object	*x;
    (void) Read(PipeStream, (BYTE *) &cap, sizeof(Capability), 2 * OneSec);
    Delay(OneSec / 2);	/* unfortunately needed */
    x = Locate(Processor, objname(sessionname));
    session->TFM = NewObject(x->Name, &cap);
    Close(x);
  }
  
  Close(PipeStream); PipeStream = Null(Stream);

  rc = Err_Null;
  
done:
  if (ProcMan ne Null(Object)) Close(ProcMan);
  if (rc ne Err_Null)
   { if (TfmStream ne Null(Stream))
      { SendSignal(TfmStream, SIGKILL);
        Close(TfmStream);
        TfmStream = Null(Stream);
        if (TFM ne Null(Object))
         { (void) Delete(TFM, Null(char));
           Close(TFM);
         }
d648 16
a664 9
  if (TFM ne Null(Object)) Close(TFM);
  if (PipeServer ne Null(Object)) Close(PipeServer);
  if (Pipe ne Null(Object)) Close(Pipe);
  if (PipeStream ne Null(Stream)) Close(PipeStream);
  if (Strv[0] ne Null(Stream)) Close(Strv[0]);
  if (Objv[OV_Console] ne Null(Object)) Close(Objv[OV_Console]);
  
  *rc_ptr = rc;
  return(TfmStream);
d667 5
a671 14
/*----------------------------------------------------------------------------*/
/**
*** do_open(). This is used for several different things. First, it
*** can be used to read the /sm directory. This involves a call to
*** DirServer(), i.e. let the server library do the work. Second, it
*** can be used to access the user database. If so a routine in the
*** user database module is called to handle it. Third, it can be used
*** to read the directory /sm/windows, which gives details of the windows
*** currently being accessed. Otherwise the client
*** is trying to find out details of another user's window, or
*** login is attempting to obtain a capability for the session's
*** Taskforce Manager. 
**/

a677 1
  DirNode	*d;
d681 1
a681 1
  int		bufsize;
d684 1
a684 5
  d = (DirNode *) GetTargetDir(servinfo);
  if (d == Null(DirNode))
   { ErrorMsg(m, Err_Null); return; }

  f = GetTargetObj(servinfo);
d686 1
a686 1
   { ErrorMsg(m, Err_Null); return; }
d710 3
d716 1
a716 6
   { PutMsg(&r->mcb);
     Free(r);
     DirServer(servinfo, m, reqport);
     FreePort(reqport);
     return;
   }
d718 1
a718 1
	/* Accessing /sm/UserDatabase */
d720 1
a720 6
   { PutMsg(&r->mcb);
     Free(r);
     OpenUserDatabase(servinfo, m, reqport);
     FreePort(reqport);
     return;
   }
d736 4
a739 5
     bufsize = sizeof(RmSessionAux) +
     		strlen(session->CurrentDirectory->Name) +
     		strlen(session->Program->Name) + 3;
     if (session->TFM ne  (Object *) MinInt)
      bufsize += strlen(session->TFM->Name);
d742 1
a742 6
     if (buffer eq Null(BYTE))
      { ErrorMsg(m, EC_Error +EG_NoMemory + EO_Stream);
        FreePort(reqport);
	Free(r);
	return;
      }
d750 3
a752 6
     temp = &(buffer[sizeof(RmSessionAux)]);

     if (session->TFM eq (Object *) MinInt)
      { memset(&(aux->TFMCap), 0, sizeof(Capability));
        aux->TFMName	= 0;
      }
d755 1
a756 1
        aux->TFMName	= (int) temp - (int) &(aux->TFMName);
d767 6
a772 10
     bufsize = sizeof(RmLoginWindow) + strlen(session->Window->Name);
     buffer  = (BYTE *) Malloc(bufsize);
     if (buffer eq Null(BYTE))
      { ErrorMsg(m, EC_Error +EG_NoMemory + EO_Stream);
        FreePort(reqport);
	Free(r);
	return;
      }
     window = (RmLoginWindow *) buffer;
     window->Cap	= session->Window->Access;
a775 4
  PutMsg(&r->mcb);
  Free(r);

  f->Account++;
d789 1
a789 1
     
d822 3
a824 5
                     if (m->MsgHdr.Reply != NullPort) ErrorMsg(m, Err_Null);
                     FreePort(reqport);
                     f->Account--;
                     Signal(&f->Lock);
                     return;
d826 2
a827 2
                     ErrorMsg(m, EC_Error + SS_SM + EG_FnCode + EO_File);
                     break;
d833 1
d838 6
a843 16
/*----------------------------------------------------------------------------*/
/**
*** do_delete(). This serves two purposes. First, in the normal system
*** it may be necessary to abort a session. For example, if a user is logged in
*** over ethernet then the ethernet software may abort the session because
*** of a broken connection. Alternatively, if no taskforce manager is used
*** courtesy of the nsrc file then there is no simple way for the session
*** manager to work out when the session has finished. Either way, 
*** the login program will delete the session when appropriate.
***
*** There is not a lot the Session Manager can do to make sure that the
*** session really has gone away.
**/
static void do_delete(ServInfo *info)
{ MCB		*m		= info->m;
  ObjNode	*o		= GetTarget(info);
d845 1
a845 1
  SessionNode	*node;
d854 13
a866 3
  node = (SessionNode *) o;
  if (node->TFMProgram ne Null(Stream))
   { Stream *current = node->TFMProgram;
d871 23
a893 2
  Unlink(o, FALSE);
  ErrorMsg(m, Err_Null);
d896 5
a900 21
/*----------------------------------------------------------------------------*/
/**
*** do_private(). The main purpose of this routine is to support stopns
*** to terminate the Session Manager. This requires sending a private
*** protocol message FG_Terminate to /sm for object /sm, and will only
*** work in a single-user mode. If successful then the Session Manager's
*** server port is freed to prevent further requests, and the name table
*** entry is deleted. Then details of the Session Manager's current state
*** are saved, and a short delay later the program exits. This could be
*** unfortunate if some other application is currently accessing the
*** user database, but tough.
***
*** An alternative use of this routine copes with processors going away.
*** If the Network Server detects that a processor has crashed for
*** some reason then it will inform the Session Manager, which can abort
*** any sessions in that window.
**/

static void	handle_LostProcessor(ServInfo *info);

static int do_private(ServInfo *servinfo)
a901 1
  DirNode        *d;
d904 1
a904 5
  d = (DirNode *) GetTargetDir(servinfo);
  if (d == Null(DirNode))
   { ErrorMsg(m, Err_Null); return(1); }
  
  f = GetTargetObj(servinfo);
d906 12
a917 1
   { ErrorMsg(m, Err_Null); return(1); }
d919 12
a930 7
  if ((f eq (ObjNode *) &Windows) &&
      ((servinfo->FnCode & FG_Mask) eq FG_NetStatus))
   { handle_LostProcessor(servinfo); return(1); }
   
  if ((f != (ObjNode *) servinfo->DispatchInfo->Root) ||
      ((servinfo->FnCode & FG_Mask) ne FG_Terminate) )
   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return(1); }
d932 1
a932 2
  unless(SingleUserMode)
   { ErrorMsg(m, EC_Error + EG_Protected + EO_Server); return(1); }
d934 90
a1023 7
  ErrorMsg(m, Err_Null);
 
  FreePort(SessionInfo.ReqPort);
  Delete(NameEntry, Null(char));
  save_session_details();
  Delay(2 * OneSec);
  exit(0);  
d1026 4
a1029 6
/*----------------------------------------------------------------------------*/
/**
*** A Processor has gone away. The Network Server will detect this and will
*** inform the Session Manager. The Session Manager checks whether any
*** registered windows involve that processor, and if so it aborts the
*** login program.
d1031 1
a1031 5
static	void	handle_LostProcessor(ServInfo *info)
{ MCB		*m = info->m;
  char		*procname, *temp;
  int		len = 0;
  ObjNode	*f, *next;
d1033 4
a1036 3
	/* BLV - check the capability passed */    
  procname = &(m->Data[m->Control[7]]);
  procname++;
d1038 4
a1041 2
  for (temp = procname;  *temp ne '\0'; temp++)
   if (*temp eq '/') *temp = '.';
d1043 186
a1228 20
  until (*procname eq '\0')  
  { len = strlen(procname);
    for (f = Head_(ObjNode, Windows.Entries);
         !EndOfList_(&(f->Node));
         f = next)
     { next = Next_(ObjNode, f);
       if (!strncmp(procname, f->Name, len))
        { Stream	*progstream = (Stream *) f->Contents.Head;
          Stream	*copy = CopyStream(progstream);
          Unlink(f, TRUE);
          if (copy ne Null(Stream))
           { 
             SendSignal(copy, SIGTERM);
             Close(copy);
           }
        }
     }
   
    for (; (*procname ne '\0') && (*procname ne '.'); procname++);
    if (*procname eq '.') procname++;
d1230 24
d1256 3
a1258 10
/*----------------------------------------------------------------------------*/
/**
*** Saving and restoring the session details.
***
*** When the Session Manager is terminated in a single-user system, it
*** writes out details of all current sessions and active windows to
*** a file /helios/tmp/sessions. This can then be read again when the
*** Session Manager is restarted.
BLV
BLV implement
d1260 5
a1264 2
static void save_session_details(void)
{
d1267 56
a1322 2
static void restore_session_details(void)
{
@


1.10
log
@Added support for Tiny Helios. Various bits of the networking software can
now be compiled with options such as -DSingleProcessor, to produce reduced
versions of Helios.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /giga/HeliosRoot/Helios/network/RCS/session.c,v 1.9 91/02/27 16:18:43 bart Exp $";
d197 4
a203 1
#endif
a204 4
  argc = argc;		/* Discard compiler warning */
  if ((argc ne 3) || strcmp(argv[0], "startns-magic"))
   fatal("please use startns to start up the networking software");

d206 1
d236 1
a236 1
  InitNode((ObjNode *) &Root, "sm", Type_Directory,
d644 1
a644 1
        
d763 2
a764 1
   { int		rc;
d790 1
a790 1
     Obtained  = RmObtainProcessor(template, &rc);
d793 1
a793 1
      { ErrorMsg(m, EC_Error + EG_RmLib + rc); goto done; }
d868 1
a868 1

d934 2
a935 1
     warn("error contacting Processor Manager %s/tasks", Processor->Name );
d983 1
a983 1
#endif
a1352 1

@


1.9
log
@1) incremented version number to 3.06
2) put in a reset of the SS_SM field which was confusing error codes
3) improved the lost processor code for finding windows
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /giga/Helios/network/RCS/session.c,v 1.8 90/12/02 13:55:41 bart Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.06";
d28 2
d196 2
a197 1
  
d200 2
a201 1
  	  
d208 1
a208 1
  if (strcmp(argv[1], "-r"))
d236 2
a237 1
  InitNode((ObjNode *) &Root, "sm", Type_Directory, 0, 0x211109c7);   
d267 1
a267 1
     fatal("failed to enter name in name table, error code 0x%08x",
d639 5
d660 37
d753 6
d761 5
a765 2
   { RmProcessor	template = RmNewProcessor();
     int		rc;
d795 6
d862 2
d866 2
a867 1
   
d977 3
d981 1
d989 2
a990 1
   { report(WindowStream, "internal error");
d998 1
d1004 3
@


1.8
log
@just updating the version numbers
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/session.c,v 1.7 90/12/01 15:38:24 bart Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.05";
d647 2
d1277 1
d1289 23
a1311 19
   { if (*temp eq '/') *temp = '.';
     len++;
   }
  
  for (f = Head_(ObjNode, Windows.Entries);
       !EndOfList_(&(f->Node));
       f = next)
   { next = Next_(ObjNode, f);
     if (!strncmp(procname, f->Name, len))
      { Stream	*progstream = (Stream *) f->Contents.Head;
        Stream	*copy = CopyStream(progstream);
        Unlink(f, TRUE);
        if (copy ne Null(Stream))
         { 
           SendSignal(copy, SIGTERM);
           Close(copy);
         }
      }
   }
@


1.7
log
@the code for coping with lost processors now works.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/session.c,v 1.1 90/09/12 15:00:50 jon Exp $";
d19 1
a19 1
static char *VersionNumber = "3.04";
d27 1
@


1.6
log
@added support for the Network Server aborting sessions, e.g. because
an external I/O processor has suddenly terminated.
@
text
@d188 1
a188 1
  	
d192 2
a193 1

d581 4
d1277 1
a1277 1
  int		len = 1;
d1282 2
a1287 1
  *temp++ = ','; *temp = '\0';
a1288 1
  Wait(&(Windows.Lock));
d1298 2
a1299 1
         { SendSignal(copy, SIGTERM);
@


1.5
log
@sources update after visit to Parsytec 22.10.90-31.10.90
@
text
@d19 1
a19 1
static char *VersionNumber = "3.03";
d26 1
d237 1
d239 1
d548 1
d579 1
d582 2
a583 1
  Unlink(f, FALSE);
d868 1
a868 1
     warn("failed to execute Taskforce Manager, %08x", Result2(ProcMan));
d1211 1
a1211 1
*** do_private(). The sole purpose of this routine is to support stopns
d1220 5
d1227 2
d1242 4
d1260 38
@


1.4
log
@minor bug fixes in time for Helios 1.2 beta1 release
@
text
@d19 8
a26 2
static char *VersionNumber = "3.02";

d86 1
a86 1
/* BLV possibly do_delete() as well. */
d115 1
a115 1
	  	 { InvalidFn,		2000 }, /* Delete */
d218 5
a222 3
  TaskforceManager = Locate(CurrentDir, TfmName);
  if (TaskforceManager eq Null(Object))
   fatal("failed to locate Taskforce Manager %s", TfmName);
a574 1
/* BLV wait for a key press before the next login ? */    
a621 1
  int		rc;
d678 2
a688 26
  
	/* Try to obtain a processor for the Taskforce Manager	*/
  { RmProcessor	template = RmNewProcessor();
    int		rc;
    int		length;
    char	*attrib;

    if (template eq (RmProcessor) NULL)
     { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Processor); goto done; }
    template->ObjNode.Account = f->ObjNode.Account;
    length = strlen(WindowStream->Name) + 6;
    attrib = (char *) Malloc(length);
    if (attrib eq Null(char))
     { RmFreeProcessor(template);
       ErrorMsg(m, EC_Error + EG_NoMemory + EO_Processor); 
       goto done; 
     }
    strcpy(attrib, "NEAR=");
    strcat(attrib, WindowStream->Name);
    rc = RmAddProcessorAttribute(template, attrib);
    Free(attrib);
    if (rc ne RmE_Success)
     { RmFreeProcessor(template);
       ErrorMsg(m, EC_Error + EG_RmLib + rc);
       goto done;
     }
d690 46
a735 11
    Obtained  = RmObtainProcessor(template, &rc);
    RmFreeProcessor(template);
    if (Obtained eq (RmProcessor) NULL)
     { ErrorMsg(m, EC_Error + EG_RmLib + rc); goto done; }

    Processor = RmMapProcessorToObject(Obtained);
    if (Processor eq Null(Object))
     { ErrorMsg(m, EC_Error + EG_Invalid + EO_Processor);
       goto done;
     }
  }
a736 3
  TfmStream = do_start_tfm(&rc, Obtained, Processor, WindowStream, f, pathname);
  if (TfmStream eq Null(Stream))
   { ErrorMsg(m, rc); goto done; }
d753 6
a758 1
	/* Now wait for the Taskforce Manager to terminate.		*/
d766 1
a766 1
   
d778 2
a779 1
     if (f->TFM ne Null(Object)) Close(f->TFM);
d1046 1
a1046 1
     bufsize = sizeof(RmSessionAux) + strlen(session->TFM->Name) +
d1049 3
a1063 1
     aux->TFMCap	= session->TFM->Access;
d1067 11
a1077 3
     strcpy(temp, session->TFM->Name);
     aux->TFMName	= (int) temp - (int) &(aux->TFMName);
     temp		+= strlen(temp) + 1;
d1168 37
d1220 1
a1220 1
    
@


1.3
log
@preparing beta1 release before holiday
@
text
@d19 1
a19 1
static char *VersionNumber = "3.01";
@


1.2
log
@Plugged various memory leaks
@
text
@d115 4
a118 1
	  	 { NullFn,		2000 }  /* CloseObj */
d531 1
a531 1
     ProgStream = Open(Program, Null(char), O_Execute);
d846 1
a846 1
  TfmStream = Open(TFM, Null(char), O_Execute);
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char *rcsid = "$Header$";
d19 1
a19 1
static char *VersionNumber = "3.00";
@
