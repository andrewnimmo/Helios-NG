head	1.38;
access;
symbols
	Helios_C40_1_3_Official_Release:1.35
	Alenia_release:1.33
	Helios1_3:1.33
	C40_Field_Test_2:1.33
	C40_Field_Test_R1:1.27
	Helios13_beta:1.27
	Helios1_2_2_Fault:1.24
	Helios1_2_2_Native:1.23
	Helios1_2_2_native_beta:1.22
	Helios1_2_2:1.21
	Helios1_2_2Beta:1.19
	Helios1_2_1:1.14
	Helios1_2:1.11;
locks; strict;
comment	@ * @;


1.38
date	94.03.01.12.35.21;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	93.08.12.14.03.14;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	93.08.11.10.51.57;	author bart;	state Exp;
branches;
next	1.35;

1.35
date	93.01.26.16.41.58;	author bart;	state Exp;
branches;
next	1.34;

1.34
date	93.01.13.11.07.56;	author bart;	state Exp;
branches;
next	1.33;

1.33
date	92.10.07.13.38.00;	author bart;	state Exp;
branches;
next	1.32;

1.32
date	92.09.09.11.45.24;	author bart;	state Exp;
branches;
next	1.31;

1.31
date	92.08.17.15.57.40;	author bart;	state Exp;
branches;
next	1.30;

1.30
date	92.08.05.12.48.51;	author bart;	state Exp;
branches;
next	1.29;

1.29
date	92.07.21.11.04.51;	author bart;	state Exp;
branches;
next	1.28;

1.28
date	92.07.07.10.53.58;	author paul;	state Exp;
branches;
next	1.27;

1.27
date	92.06.08.12.12.53;	author bart;	state Exp;
branches;
next	1.26;

1.26
date	92.04.24.15.45.01;	author bart;	state Exp;
branches;
next	1.25;

1.25
date	92.03.25.18.03.41;	author bart;	state Exp;
branches;
next	1.24;

1.24
date	92.01.15.11.04.39;	author bart;	state Exp;
branches;
next	1.23;

1.23
date	92.01.14.15.52.33;	author bart;	state Exp;
branches;
next	1.22;

1.22
date	92.01.14.14.20.34;	author bart;	state Exp;
branches;
next	1.21;

1.21
date	91.10.30.16.39.21;	author bart;	state Exp;
branches;
next	1.20;

1.20
date	91.09.11.11.38.39;	author bart;	state Exp;
branches;
next	1.19;

1.19
date	91.06.06.13.46.50;	author bart;	state Exp;
branches;
next	1.18;

1.18
date	91.06.03.13.51.23;	author bart;	state Exp;
branches;
next	1.17;

1.17
date	91.05.18.12.09.03;	author bart;	state Exp;
branches;
next	1.16;

1.16
date	91.04.08.15.45.27;	author paul;	state Exp;
branches;
next	1.15;

1.15
date	91.04.07.13.20.21;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	91.03.15.14.43.58;	author bart;	state Exp;
branches;
next	1.13;

1.13
date	91.03.12.14.04.27;	author bart;	state Exp;
branches;
next	1.12;

1.12
date	90.12.17.14.32.07;	author bart;	state Exp;
branches;
next	1.11;

1.11
date	90.12.02.13.56.30;	author bart;	state Exp;
branches;
next	1.10;

1.10
date	90.12.01.15.39.12;	author bart;	state Exp;
branches;
next	1.9;

1.9
date	90.11.25.20.08.45;	author bart;	state Exp;
branches;
next	1.8;

1.8
date	90.11.01.15.03.40;	author bart;	state Exp;
branches;
next	1.7;

1.7
date	90.10.18.13.27.23;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	90.09.27.13.25.22;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	90.09.24.18.46.45;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	90.09.20.17.41.39;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	90.09.14.12.57.24;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	90.09.13.10.58.38;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	90.09.12.15.11.56;	author jon;	state Exp;
branches;
next	;


desc
@@


1.38
log
@fixed compile time warning from ARM world
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- tfm.c								--
--                                                                      --
--	Main module of the Taskforce Manager				--
--                                                                      --
--	Author:  BLV 1/5/90						--
--                                                                      --
------------------------------------------------------------------------*/
/* RcsId: $Header: /hsrc/network/RCS/tfm.c,v 1.37 1993/08/12 14:03:14 nickc Exp nickc $*/

/*{{{  version Number and history */
static char *VersionNumber = "3.30";
/**
*** History :
***           3.00, initial version
***           3.01, internal development
***           3.02, 1.2 beta 0 release
***           3.03, 1.2 beta 1 release
***           3.04, developed at Parsytec, 22.10.90-30.10.90
***           3.05, finishing off for the official 1.2 release
***           3.06, the real 1.2 release
***           3.07, first post 1.2 version, shipped with 1.2.1
***           3.08, changed the environment handling
***           3.09, added support for Tiny Helios
***           3.10, now generates errors if SendEnv/GetEnv fails
***           3.11, works around timing problems with the environments
***           ...
***           3.20, includes native network support
***           3.21, cleaned up the communication, added support for ids
***           3.22, minor bug fixes 30.10.91, absolute component names and
***                 shell scripts
***           3.23, change of communication to use sockets
***           3.24, extensions for fault tolerance
***	      3.25, added RmLib execute support
***           3.26, misc. bug fixes
***           3.27, C40 work
***           3.28, support for parallel libraries (TaskToTaskforce)
***           3.29, bug fixes
***           3.30, reduced memory requirements for C40 1.3.1 release
**/
/*}}}*/
/*{{{  headers and compile-time options */
#include <stdio.h>
#include <syslib.h>
#include <servlib.h>
#include <sem.h>
#include <codes.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <posix.h>
#include <ctype.h>
#include <nonansi.h>
#include <attrib.h>
#include <pwd.h>
#include <signal.h>
#include <module.h>
#include <root.h>
#include <process.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include "exports.h"
#include "private.h"
#include "netutils.h"
#include "rmlib.h"
#include "tfmaux.h"

	/* Compile-time debugging options	*/
#define Use_Malloc_Debugging		0
#define Use_Objects_Debugging		0
#define ShowHeap_Debugging		0
#define Use_IOC_Debugging		0
#define Redirect_To_Logger		0
#define Default_Diagnostics_Options	0
#define Use_Ports_Debugging		0
/*}}}*/
/*{{{  forward declarations and statics */
/*----------------------------------------------------------------------------*/
/**
*** forward declarations and statics. The /<username> directory contains two
*** different entries: domain and tfm. These are responsible for the processor
*** network and for the executing task forces respectively.
**/

static void		init_signals(void);
static void		show_startup(char *name);
static void		init_domain(void);
static void		do_open(ServInfo *);
static void		do_create(ServInfo *);
static void		do_delete(ServInfo *);
static void		do_private(ServInfo *);
static void		CheckWindow(void);
static void		abort_socket(int);

static	Object		*ThisProcessor;
	char		ProcessorName[IOCDataMax];
static	Object		*NameEntry;
	char		NetworkName[NameMax];
	DirNode		Root;
	DirNode		TFM;
	RmNetwork	Domain;
	Semaphore	LibraryLock;
	int		TaskSequenceNumber = 1;
	WORD		DebugOptions = Default_Diagnostics_Options;
static	Stream		*DiagnosticsStream;
static	Stream		*DefaultDiagnostics;
	RmProcessor	TfmProcessor;
	WORD		LastChange;
	Object		*PipeCode = Null(Object);

static DispatchInfo TFMInfo =
	{ &Root,
	  NullPort,
	  SS_TFM,
	  ProcessorName,
	  { do_private,	TFM_Stack },
	  {
	  	 { do_open,		TFM_Stack * 2	},
	  	 { do_create,		TFM_Stack	}, /* Create */
	  	 { DoLocate,		0		},
	  	 { DoObjInfo,		0		},
	  	 { InvalidFn,		0		}, /* ServerInfo */
	  	 { do_delete,		TFM_Stack	}, /* Delete */
	  	 { InvalidFn,		0		}, /* Rename */
	  	 { InvalidFn,		0		}, /* Link   */
	  	 { DoProtect,		0		},
	  	 { InvalidFn,		0		}, /* SetDate */
	  	 { DoRefine,		0		},
	  	 { NullFn,		0		}, /* CloseObj */
	  	 { InvalidFn,		0		}, /* Revoke */
	  	 { InvalidFn,		0		}, /* Reserved1 */
	  	 { InvalidFn,		0		}  /* Reserved2 */
	  }
};
/*}}}*/
/*{{{  main() */
/*----------------------------------------------------------------------------*/
/**
*** main()
***
*** argv[0] must be the string SessionManager, because only the Session
*** Manager is allowed to start up Taskforce Managers. argv[1]
*** corresponds to the name of the session, e.g. bart or bart.3
**/

int main(int argc, char **argv)
{
#ifndef __TRAN
  SetPriority(HighServerPri);
#endif
	
#if Use_Malloc_Debugging
  PatchMalloc();
#endif
#if Use_Objects_Debugging
  PatchObjects();
#endif
#if Use_IOC_Debugging
  PatchIOC(1);
#endif
#if Use_Ports_Debugging
  PatchPorts();
#endif
  
  DiagnosticsStream = DefaultDiagnostics = fdstream(1);
#if Redirect_To_Logger
  DiagnosticsStream = Open(cdobj(), "/logger", O_WriteOnly);
#endif

  LastChange = GetDate();

  signal(SIGPIPE, SIG_IGN);    
  InitSemaphore(&(LibraryLock), 1);
  RmProgram = Rm_TFM;
  MRSW_Init();
    
  if ((argc ne 3) || strcmp(argv[0], "SessionManager"))
    fatal("only the Session Manager can start up a Taskforce Manager");

  show_startup(argv[1]);
  
  EncodeCapability(argv[2], &RmLib_Cap);

	/* Initialise the other modules */
  InitJobs();
  InitMap();
  InitRun();
  InitMisc();
  
 	/* Initialise static data */
  if (MachineName(ProcessorName) ne Err_Null)
   fatal("MachineName failure");

  ThisProcessor = Locate(Null(Object), ProcessorName);
  if (ThisProcessor eq Null(Object))
   fatal("failed to locate own processor");
     
  InitNode((ObjNode *) &Root, argv[1], Type_Directory, 0, 0x211109c7);
  InitList(&(Root.Entries));
  InitNode((ObjNode *) &TFM, "tfm", Type_Directory, 0, 0x211109c7);
  InitList(&(TFM.Entries));
  Insert(&Root, (ObjNode *) &TFM, FALSE);

	/* Initialise the domain. This requires very different action	*/
	/* depending on whether or not this is a single-processor	*/
	/* system.							*/
  init_domain();

	/* Allow some signals to be handled asynchronously, since the	*/
	/* Posix library is rarely called.				*/
  init_signals();

	/* Start a process which will terminate the TFM if the current	*/
	/* window disappears.						*/
  if (MonitorDelay >= 0)
	  (void) Fork(CheckWindow_Stack, &CheckWindow, 0);

	/* Load the pipe server into memory	*/
  { Object	*junk = Locate(ThisProcessor, "pipe/xyz");
    if (junk ne Null(Object)) Close(junk);
    PipeCode = Locate(ThisProcessor, "loader/pipe");
    if (PipeCode eq Null(Object))
     report("warning, failed to load pipe server into memory");
  }

	/* Start up a thread to handle incoming RmLib connections	*/
  unless(Fork(AcceptConnections_Stack, &AcceptConnections, 0))
   fatal("out of memory spawning a thread to handle RmLib connections");

	/* Create a name-table entry */
  if ((TFMInfo.ReqPort = NewPort()) eq NullPort)
   fatal("unable to allocate a message port.");

  { NameInfo name;
    name.Port		= TFMInfo.ReqPort;
    name.Flags		= Flags_StripName;
    name.Matrix		= 0x21212147;	/* rz : rz : rz : rwvd */
    name.LoadData	= Null(WORD);   
    NameEntry = Create(ThisProcessor, argv[1], Type_Name, sizeof(NameInfo),
    		(BYTE *) &name);
    if (NameEntry eq Null(Object))
     fatal("failed to enter name in name table, error code %x",
     		Result2(ThisProcessor));
  }
	/* Send back a reply with a capability for the TFM. This ends	*/
	/* up in the environment of the login shell.			*/
  { Capability	cap;
    NewCap(&cap, (ObjNode *) &Root, AccMask_Full);
/* AccMask_R+AccMask_W+AccMask_D+AccMask_V);*/
    if (Write(fdstream(0), (BYTE *) &cap, sizeof(Capability), 5 * OneSec)
    		ne sizeof(Capability))
     fatal("failed to send back a capability for this Taskforce Manager");
  }
  close(0);
  Dispatch(&TFMInfo);
  forever Delay(30 * 60 * OneSec);
  return(0); 
}
/*}}}*/
/*{{{  initialising the domain */
/**-----------------------------------------------------------------------------
*** Initialising the domain. In a multi-processor system the TFM is started up
*** by the Session Manager, and it can get network details from the Network
*** Server. In addition the Session Manager will send it details of the
*** processor running the TFM, since SM obtained this processor to run the
*** TFM.
**/

#ifndef SingleProcessor
/*{{{  usual multi-processor case */
static void init_domain()
{ int i, rc;

  for (i = 0; i < 5; i++)
   { Domain = RmGetNetworkHierarchy();
     if (Domain ne (RmNetwork) NULL) break;
     switch(RmErrno)
      { case	RmE_CommsBreakdown :
       	  report("communications problems when interacting with network server");
     	  break;
        case	RmE_NoMemory :
       	  report("tfm out of memory"); break;
        case	RmE_ServerMemory :
       	  report("network server out of memory"); break;
        case	RmE_BadArgument :
       	  report("problem contacting network server"); break;
        default			:
          report("unexpected resource management library problem %s",
        	RmMapErrorToString(RmErrno));
      }
     report("retrying");
     Delay(OneSec);
   }

  if (Domain eq (RmNetwork) NULL)
   fatal("failed to initialise network hierarchy");

  strcpy(NetworkName, RmGetNetworkId(Domain));
  RmRootName = NetworkName;
  strcpy(Domain->DirNode.Name, "domain");
  Insert(&Root,  (ObjNode *) &(Domain->DirNode), FALSE);

  rc = RmReadProcessor(fdstream(0), &TfmProcessor, FALSE);
  if (rc ne RmE_Success)
    fatal(
    "failed to get processor details from Session Manager, RmLib error %s",
    		RmMapErrorToString(rc));
  else
   { DomainEntry *domain_entry;
   
     TfmProcessor->ObjNode.Key		= NewKey() + _cputime();
     TfmProcessor->AllocationFlags	= RmF_TfmProcessor | RmF_Permanent;
     RmStartSearchHere			= TfmProcessor->Uid;
     unless(AddDomainEntry(TfmProcessor))
      fatal("out of memory when initialising tfm's own processor");
     domain_entry = GetDomainEntry(TfmProcessor);
     domain_entry->NumberUsers = 1;
     if (RmInsertProcessor(Domain, TfmProcessor) eq (RmProcessor) NULL)
      fatal("failed to insert tfm processor into domain");
   }

	/* Install a handler for exceptions generated by the Network	*/
	/* Server via the Resource Management library			*/
  RmExceptionHandler = (VoidFnPtr) Tfm_ExceptionHandler;
	
	/* Tell the Network Server that the TFM's processor is owned	*/
	/* by this session, and not by the Session Manager.		*/
  { RmRequest	request;
    RmReply	reply;

    Clear(request); Clear(reply);
    request.FnRc	= RmC_RegisterTfm;
    request.Uid		= TfmProcessor->Uid;
    (void) RmXch(&RmParent, &request, &reply);
#ifndef __I860
    { extern void PreallocMsgBufs(int);
      PreallocMsgBufs(reply.Reply1 + 4);
    }
#endif
    TfmProcessor->SessionId = RmGetSession();
  }
}
/*}}}*/
#else
/*{{{  single-processor system, i.e. Tiny Helios */
	/* In a single processor system most of the information has to	*/
	/* be invented. There is definitely no Network Server. There	*/
	/* may or may not be a Session Manager.				*/
static void init_domain()
{ 
  Domain = RmNewNetwork();
  if (Domain eq (RmNetwork) NULL)
   fatal("failed to initialise domain");
   
  strcpy(Domain->DirNode.Name, "domain");
  NetworkName[0] = '\0';
  RmRootName	 = NetworkName;
  Insert(&Root, (ObjNode *) &(Domain->DirNode), FALSE);
    
  TfmProcessor = RmNewProcessor();
  if (TfmProcessor eq (RmProcessor) NULL)
   fatal("failed to initialise TFM processor");

  TfmProcessor->ObjNode.Key	= NewKey() + _cputime();
  TfmProcessor->AllocationFlags	= RmF_TfmProcessor | RmF_Permanent;
  TfmProcessor->ObjNode.Size	= RmS_Running + RmP_Helios;
  TfmProcessor->Connections	= 0;
  RmStartSearchHere		= TfmProcessor->Uid;
  unless(AddDomainEntry(TfmProcessor))
   fatal("out of memory when initialising tfm's own processor");
  strcpy(TfmProcessor->ObjNode.Name, objname(ThisProcessor->Name));

  { ProcStats	*stats = (ProcStats *)Malloc(sizeof(ProcStats) + 
  			(4 * (sizeof(LinkConf) + 3 * sizeof(WORD))) +
  			IOCDataMax);
    if (stats ne Null(ProcStats))
     { if (ServerInfo(ThisProcessor, (BYTE *) stats) eq Err_Null)
        { word	memory = stats->MemMax;
          memory = memory + (256 * 1024) - 1;
          memory &= ~((256 * 1024) - 1);
          TfmProcessor->MemorySize = memory;
          
          switch(stats->Type)
           { case	 800 :
	     case	 805 :
	     case	 801 : TfmProcessor->Type = RmT_T800; break;
             case	 414 : TfmProcessor->Type = RmT_T414; break;
             case	 425 : TfmProcessor->Type = RmT_T425; break;
             case	 400 : TfmProcessor->Type = RmT_T400; break;
             case	0xA3 : TfmProcessor->Type = RmT_Arm; break;
             case   0x320C40 : TfmProcessor->Type = RmT_C40; break;
	     case	0x86 : TfmProcessor->Type = RmT_i860; break;

             default : report("warning, unknown processor type %d", 
             		stats->Type);
           }
        }
       Free(stats);
     }
  }
        
  if (RmAddtailProcessor(Domain, TfmProcessor) eq (RmProcessor) NULL)
   fatal("failed to insert tfm processor into domain");

  TfmProcessor->StructType	= RmL_Obtained;
  Domain->StructType		= RmL_Obtained;
}
/*}}}*/
#endif
/*}}}*/
/*{{{  termination */
/*----------------------------------------------------------------------------*/
/**
*** Terminate the Taskforce Manager. This routine is called in a separate
*** process when the first task to be created, i.e. the shell, terminates.
*** All outstanding tasks and taskforces are aborted. Reclaiming the
*** processors is left to the Network Server, when it detects that the
*** connection has disappeared. Then the Taskforce Manager itself terminates
*** which should signal the Session Manager to unlink the entry for the user.
***
*** This code may also be called as a result of signals.
**/
void TerminateTFM(void)
{ int		number_thingies = 0;
  ObjNode	*node;
  static	bool already_called = FALSE;

	/* Step 1, lock the /tfm directory to avoid terminating	*/
	/* forces screwing up the directory as I walk through	*/
	/* it.							*/
  Wait(&(TFM.Lock));
  if (already_called)
   { Signal(&(TFM.Lock)); forever Delay(30 * 60 * OneSec); }
  else
   already_called = TRUE;

 	/* Step 2, walk through the /tfm directory killing	*/
 	/* off everything. A SIGKILL signal should do the job.	*/
  for (node = Head_(ObjNode, TFM.Entries);
       !EndOfList_(node);
       node = Next_(ObjNode, node))
   { 
     if (node->Type eq Type_Taskforce)
      taskforce_DoSignal((RmTaskforce) node, SIGKILL);
     elif (node->Type eq Type_Task)
      task_DoSignal((RmTask) node, SIGKILL);
     number_thingies++;
   }

	/* Step 3, unlock the directory again to allow things	*/
	/* to terminate completely.				*/
  Signal(&(TFM.Lock));

 	/* Step 4, wait a while to let the thingies die.	*/
  Delay(number_thingies * OneSec);

 	/* Step 5, clean out and exit.				*/ 	
  Delete(NameEntry, Null(char));

	/* At this point various other bits of the system could	*/
	/* start sending signals to the TFM which might foul	*/
	/* up the shutting down of the sockets.			*/
  signal(SIGTERM, SIG_IGN);

  if (Socket_ctos >= 0) abort_socket(Socket_ctos);

  Exit(0);
}

	/* Aborting a socket is unbelievably gruesome, it involves	*/
	/* connecting to that socket and sending it a shutdown message.	*/
static void abort_socket(int fd)
{ struct sockaddr_un	address;
  int			sock_ctos = -1;
  int			sock_stoc = -1;
  Stream		*real_socket	= fdstream(fd);
  int			len;
  Capability		cap;

  sock_ctos = socket(AF_UNIX, SOCK_STREAM, 0); 
  if (sock_ctos < 0) goto done;
  sock_stoc = socket(AF_UNIX, SOCK_STREAM, 0);
  if (sock_stoc < 0) goto done;

  address.sun_family	= AF_UNIX;
  strcpy(address.sun_path, objname(real_socket->Name));
  len = sizeof(address.sun_family) + strlen(address.sun_path) + 1;

  if (connect(sock_ctos, (struct sockaddr *) &address, len) < 0) goto done;

  address.sun_family	= AF_UNIX;
  strcpy(address.sun_path, objname(real_socket->Name));
  len = strlen(address.sun_path);
  address.sun_path[len - 1] = 'c';
  address.sun_path[len - 4] = 's';
  len = sizeof(address.sun_family) + strlen(address.sun_path) + 1;
  
  if (connect(sock_stoc, (struct sockaddr *) &address, len) < 0) goto done;

  NewCap(&cap, (ObjNode *) &TFM, AccMask_Full);
  (void) write(sock_ctos, (BYTE *) &cap, sizeof(Capability));
  len	= -1;
  (void) write(sock_ctos, (BYTE *) &len, sizeof(len));
  (void) read(sock_stoc, (BYTE *) &len, sizeof(len));

done:
	/* BLV - closing the various sockets at this point seems to be	*/
	/* a bad idea, there are all kinds of weird deadlock problems	*/
  len = 0;
}
/*}}}*/
/*{{{  signal handling */
/*----------------------------------------------------------------------------*/
/** Signal handling. Abort signals should cause the TFM to go through its
*** termination routine.
**/
static void	mysignalhandler(int);

static void init_signals(void)
{ struct sigaction	temp;
  if (sigaction(SIGINT, Null(struct sigaction), &temp) ne 0)
   { report("warning, failed to access signal handling facilities.");
     return;
   }
  temp.sa_handler	= &mysignalhandler;
  temp.sa_flags	|= SA_ASYNC;
  if (sigaction(SIGINT, &temp, Null(struct sigaction)) ne 0)
   { report("warning, failed to modify signal handling facilities.");
     return;
   }

  if (sigaction(SIGTERM, Null(struct sigaction), &temp) ne 0)
   { report("warning, failed to access signal handling facilities.");
     return;
   }

  temp.sa_handler	 = &mysignalhandler;
  temp.sa_flags		|= SA_ASYNC;
  if (sigaction(SIGTERM, &temp, Null(struct sigaction)) ne 0)
   { report("warning, failed to modify signal handling facilities.");
     return;
   }

  signal(SIGPIPE, SIG_IGN);
}

static void mysignalhandler(int x)
{ x = x;
  TerminateTFM();
}
/*}}}*/
/*{{{  checking the current world's consistency */
/*----------------------------------------------------------------------------*/
/**
*** This routine checks the current diagnostics stream at regular interval.s
*** If the stream has gone away then the TFM aborts.
**/
static	void CheckWindow(void)
{
  forever
   { Object	*x;
     Delay(30 * OneSec);
     Wait(&LibraryLock);
     x = Locate(Null(Object), DiagnosticsStream->Name);
     Signal(&LibraryLock);
     if (x eq Null(Object))
      TerminateTFM();
     Close(x);
   }     
}
/*}}}*/
/*{{{  diagnostics routines */
/*----------------------------------------------------------------------------*/
/**
*** Usual diagnostics routines.
**/
static char	output_buffer[256];
static char	*int_to_string(char *buffer, int x);

static int	process_format(char *format, va_list args)
{ char	*dest;
  char	*null_str= "<null>";

  strcpy(output_buffer, "tfm: ");
  
  for (dest = &(output_buffer[5]) ; *format ne '\0'; format++)
   { if (*format ne '%')
      { *dest++ = *format; continue; }
     switch (*(++format))
      { case	'\0': *dest++ = '%'; format--; break;
        case	'%' : *dest++ = '%'; break;
        case    'c' : *dest++ = (char) va_arg(args, int); break;
        case	's' : { char	*temp = va_arg(args, char *);
			if (temp eq Null(char)) temp = null_str;
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
	case	'S' : { Stream	*x = va_arg(args, Stream *);
			char	*temp;
			if (x eq NULL) 
			 temp = null_str;
			else
			 temp = x->Name;
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
	case	'O' : { Object *x = va_arg(args, Object *);
			char	*temp;
			if (x eq NULL) 
			 temp = null_str;
			else
			 temp = x->Name;
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
	case	'P' :
	case	'N' :
	case	'T' : { RmProcessor x = va_arg(args, RmProcessor);
			char	*temp;
			if (x eq NULL) 
			 temp = null_str;
			else
			 temp = x->ObjNode.Name;
                        while (*temp ne '\0') *dest++ = *temp++;
                        break;
                      }
        case	'x' : { int	x = va_arg(args, int);
        		int	shift;
        		*dest++ = '0'; *dest++ = 'x';
        		for (shift = 28; shift >= 0; shift -= 4)
        		 { int temp = (x >> shift) & 0x0F;
        		   if (temp <= 9)
        		    *dest++ = '0' + temp;
        		   else 
        		    *dest++ = 'a' + temp - 10;
        		 }
        		break;
        	      }
	case	'd' : { int	temp = va_arg(args, int);
	   		dest = int_to_string(dest, temp);
	   		break;
		      }  

	default	    : *dest++ = '%'; *dest++ = *format; break;
      }
    }
  if (DiagnosticsStream->Flags & Flags_Interactive)
   *dest++ = '\r';
  *dest++ = '\n';
  return(dest - output_buffer);
}

static char	*int_to_string_aux(char *buffer, unsigned int i)
{ if (i > 9) buffer = int_to_string_aux(buffer, i / 10);
  *buffer++	= (i % 10) + '0';
  return(buffer);
}

static char	*int_to_string(char *buffer, int x)
{ if (x < 0) { x = -x; *buffer++ = '-'; }
  return(int_to_string_aux(buffer, (unsigned int ) x));
}

void fatal(char *format, ...)
{ va_list	list;
  int		length;
  static	char *message = "TFM : error is fatal, exiting.\n";
  
  Wait(&(LibraryLock));
  va_start(list, format);
  length = process_format(format, list);
  va_end(list);

  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  (void) Write(DiagnosticsStream, message, strlen(message), -1);
  Signal(&LibraryLock);
    
  Exit(EXIT_FAILURE << 8);
}

void report(char *format, ...)
{ va_list	args;
  int		length;  
  
  va_start(args, format);
  
  Wait(&LibraryLock);
  length = process_format(format, args);
  va_end(args);
  (void) Write(DiagnosticsStream, output_buffer, length, -1);
  Signal(&LibraryLock);
}

static void show_startup_aux(char *format, ...)
{ va_list args;
  int	  length;
  
  va_start(args, format);
  length = process_format(format, args);
  va_end(args);
  (void) Write(DiagnosticsStream, &(output_buffer[5]), (word)length - 5, -1);
}
  
static void show_startup(char *session_name)
{ Object	*hushlogin = Locate(CurrentDir, ".hushlogin");
  
  if (hushlogin ne Null(Object))
   { Close(hushlogin); return; }
    
  show_startup_aux("\r\n\
\t\tTaskforce Manager version %s, session %s\r\n",
	VersionNumber, session_name);
}
/*}}}*/
/*{{{  main server library routines */

/*{{{  do_open */

/*----------------------------------------------------------------------------*/
/**
*** do_open(). This routine can be called in the following contexts.
*** 1) simply to look at the various directories
*** 2) to open a task or taskforce, in order to send it an environment etc.
**/
static void	do_open_task(ServInfo *, MCB *, Port);
static void	do_open_taskforce(ServInfo *, MCB *, Port);

static void	do_open(ServInfo *servinfo)
{ MCB		*m		= servinfo->m;
  MsgBuf	*r		= Null(MsgBuf);
  IOCMsg2	*req		= (IOCMsg2 *) m->Control;
  ObjNode	*f;
  char		*pathname	= servinfo->Pathname;
  Port		reqport;

  	/* The target object must exist, the O_Create bit is not supported */
  f = GetTarget(servinfo);
  if (f eq Null(ObjNode))
   { ErrorMsg(m, Err_Null); return; }
  
  unless( CheckMask(req->Common.Access.Access, (int)(req->Arg.Mode & Flags_Mode)))
   { ErrorMsg(m, EC_Error + EG_Protected + EO_Object); return; }
   
	/**
	*** Only the following may be opened:
	*** 1) any directory, including root, domain, tfm, networks, and
	***    taskforces
	*** 2) any task at the tfm top level
	**/
  if ((f->Type & Type_Flags) ne Type_Directory)
   if ((f->Type ne Type_Task) || (f->Parent ne &TFM))
    { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return; }

  r = New(MsgBuf);
  if (r eq Null(MsgBuf))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Stream); return; }
   
  FormOpenReply(r, m, f, Flags_Closeable, pathname);
  reqport = NewPort();
  r->mcb.MsgHdr.Reply = reqport;
  PutMsg(&(r->mcb));
  Free(r);

  if (((f->Type & Type_Flags) eq Type_Directory) &&
      (req->Arg.Mode eq O_ReadOnly))
   { DirServer(servinfo, m, reqport); FreePort(reqport); return; }

  if (f->Type eq Type_Task)
   do_open_task(servinfo, m, reqport);
  else
   do_open_taskforce(servinfo, m, reqport);
  FreePort(reqport);
}

/*}}}*/
/*{{{  do_create */

/*----------------------------------------------------------------------------*/
/**
*** do_create() should be called for only two things: creating tasks
*** and creating taskforces that are compatible with the processor manager
*** and the old TFM. It is only legal to create objects inside the /tfm
*** subdirectory, so this must be the context.
**/
static void do_create_task(ServInfo *, Object *, int size, int ptype);
static void do_create_taskforce(ServInfo *, Stream *, ImageHdr *, int size);

static void	do_create(ServInfo *servinfo)
{ MCB		*m 		= servinfo->m;
  IOCCreate	*req		= (IOCCreate *) m->Control;
  TaskInfo	*info		= (TaskInfo *) &(m->Data[req->Info]);
  DirNode	*d;
  Object	*o		= Null(Object);
  Stream	*s		= Null(Stream);
  int		ItsAProgram	= 0;
  int		Ptype;

  Debug(dbg_Create, ("Create request received"));

	/* NHG's Execute() is funny. It does not give the name of the	*/
	/* object to create. This has to be extracted from the program	*/
  d = (DirNode *) GetTarget(servinfo);
  if (d eq Null(DirNode))
   { ErrorMsg(m, EO_Directory); return; }

  unless (d eq &TFM)
   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Directory); return; }

  unless(CheckMask(req->Common.Access.Access, AccMask_W))
   { ErrorMsg(m, EC_Error + EG_Protected + EO_Directory); return; }

	/* The access mask currently refers to the parent. It must be	*/
	/* modified to refer to the actual task.			*/
  req->Common.Access.Access = AccMask_Full;

	/* Find out what the program is supposed to be */   
  o = NewObject(RTOA(info->Name), &(info->Cap));  
  if (o eq Null(Object))
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Program); return; }

  Debug(dbg_Create, ("testing program %O", o));
  { ImageHdr	Hdr;
    int		size;

    s = Open(o, Null(char), O_ReadOnly);      
    if (s eq Null(Stream))
     { ErrorMsg(m, EC_Error + EG_Invalid + EO_Program); goto done; }

    size = (int) GetFileSize(s);
    if (size < (int) sizeof(ImageHdr))
     { ErrorMsg(m, EC_Error + EG_WrongSize + EO_Program); goto done; }
     
    if (Read(s, (BYTE *) &Hdr, sizeof(ImageHdr), -1) ne sizeof(ImageHdr))
     { ErrorMsg(m, EC_Error + EG_WrongSize + EO_Program); goto done; }
    

    switch(Hdr.Magic)
     { case	Image_Magic :		/* standard program */
	 if (Hdr.Size <= 0)
	  { ErrorMsg(m, EC_Error + EG_Invalid + EO_Program); goto done; }
	 else
	  ItsAProgram	= (int) Hdr.Size;
         Ptype		= (int)((Hdr.Flags eq 0) ? RmT_Default : Hdr.Flags);
         do_create_task(servinfo, o, ItsAProgram, Ptype);
         break;

       case Taskforce_Magic :
       case RmLib_Magic	    :       	  
       	  ItsAProgram	= 0;
	  do_create_taskforce(servinfo, s, &Hdr, size);
	  s = Null(Stream);	/* closed automatically */
       	  break;

       default :
          ErrorMsg(m, EC_Error + EG_Invalid + EO_Program);
          goto done;
     }
  }     
    
done:
  if (s ne Null(Stream)) Close(s);
  if (o ne Null(Object)) Close(o);
}

/*}}}*/
/*{{{  do_delete */
/*----------------------------------------------------------------------------*/
/**
*** do_delete() may be applied either to a Taskforce or a task, provided it is
*** at the top level. The action to take depends on the KillState held
*** in the TaskEntry structure.
**/
static void do_delete_task(ServInfo *servinfo);
static void do_delete_taskforce(ServInfo *servinfo);

static void do_delete(ServInfo *servinfo)
{ MCB		*m		= servinfo->m;
  ObjNode	*f;
  IOCCommon	*req		= (IOCCommon *) m->Control;

  Debug(dbg_Delete, ("delete request received"));
    
  f = GetTarget(servinfo);
  if (f eq Null(ObjNode))
   { ErrorMsg(m, EO_Task); return; }

  unless(CheckMask(req->Access.Access, AccMask_D))
   { ErrorMsg(m, EC_Error + EG_Protected + EO_Task); return; }
 
  unless(f->Parent eq &TFM) 
   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return; }

  if (f->Type eq Type_Task)
   do_delete_task(servinfo);
  elif (f->Type eq Type_Taskforce)
   do_delete_taskforce(servinfo);
  else
   ErrorMsg(m, EC_Error + EG_Unknown + EO_Object);
}
/*}}}*/
/*{{{  do_private, debugging options */
/*----------------------------------------------------------------------------*/
/**
*** do_private(). This is used for enabling/disabling debugging.
**/
static void	do_private(ServInfo *servinfo)
{ MCB		*m	= servinfo->m;
  ObjNode	*f;
  IOCMsg2	*req	= (IOCMsg2 *) m->Control;
  
  f = GetTarget(servinfo);
  if (f eq Null(ObjNode))
   { ErrorMsg(m, Err_Null); return; }

  if ((f ne (ObjNode *) &TFM) || ((servinfo->FnCode & FG_Mask) ne FG_GetInfo))
   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object); return; }

  if (req->Arg.Mode eq dbg_Revert)
   { DiagnosticsStream = DefaultDiagnostics;
     m->MsgHdr.FnRc = 0;
     ErrorMsg(m, Err_Null);
     return;
   }

  UnLockTarget(servinfo);
  
  if (req->Arg.Mode eq dbg_Redirect)
   { static	char	*message = "tfm: output redirected\n";
     int	length	= strlen(message);
     Stream	*stream;
     WORD	index	= m->Control[6];
     StrDesc	*desc	= (StrDesc *) &(m->Data[index]);
     stream		= NewStream(desc->Name, &(desc->Cap), desc->Mode);
     stream->Pos	= desc->Pos;
     
     if (Write(stream, (BYTE *) message, length, -1) ne length)
      { ErrorMsg(m, EC_Error + EG_Open + EO_Stream);
        Close(stream);
        return;
      }
     if (DiagnosticsStream ne DefaultDiagnostics) Close(DiagnosticsStream);
     DiagnosticsStream = stream;
     m->MsgHdr.FnRc = 0;
     ErrorMsg(m, Err_Null);
     return;
   } 
   
  if (req->Arg.Mode ne dbg_Inquire)   
   DebugOptions = req->Arg.Mode;
  if (DebugOptions & dbg_Memory)
   { report("currently %d bytes are free, the heap size is %d", Malloc(-1),
   		Malloc(-3));
     DebugOptions &= ~dbg_Memory;
#if ShowHeap_Debugging
     ShowHeap();
#endif
   }
  if (DebugOptions & dbg_Lock)
   { MRSW_Info	buf;
     MRSW_GetInfo(&buf);
     report("lock status: ar %d, rr %d, aw %d, rw %d, sw %d",
		buf.ar, buf.rr, buf.aw, buf.rw, buf.sw);
     DebugOptions &= ~dbg_Lock;
   }
#if Use_IOC_Debugging
  if (DebugOptions & dbg_IOC)
   { ShowIOC();
     DebugOptions &= ~dbg_IOC;
   }
#endif

  m->MsgHdr.FnRc = DebugOptions;
  ErrorMsg(m, Err_Null);  
}
/*}}}*/

/*}}}*/

	/* These routines are called from the generic do_create() etc.	*/
	/* and do the real work.					*/
/*{{{  do_create_task() */

/*----------------------------------------------------------------------------*/
/**
*** This code deals with requests for individual tasks, e.g. /bart/tfm/shell.1
***
*** 1) do_create_task()
***   Given a Create request and an Object for the binary task,
***   together with some information about the target program,
***   start the task running.
***
***   a) obtain and fill in an RmTask structure. Eventually this will be
***      added to the /tfm directory.
***   b) try to get a suitable processor for running this program.
***   c) execute and run the program. Store the required information in the
***      RmTask structure (Object pointer and Stream).
***   d) retry this a number of times, in case the processor chosen
***      was short of memory
***   e) add the task to the /tfm subdirectory
***   f) all done. Construct the reply and send it.
**/

static void do_create_task(ServInfo *servinfo, Object *itsprogram,
			   int progsize, int ptype)
{ RmProcessor	processor	= (RmProcessor) NULL;
  RmTask	task		= (RmTask) NULL;
  MCB		*m		= servinfo->m;
  bool		success		= FALSE;
  MsgBuf	*r		= Null(MsgBuf);
  char		*pathname	= servinfo->Pathname;
  int		retries		= TaskRetries;
  TaskEntry	*task_entry;
  Object	*program	= CopyObject(itsprogram);
  word		rc		= EC_Error + EG_Create + EO_Program;

  Debug(dbg_Create, ("creating task"));

  UnLockTarget(servinfo);

  if (program eq Null(Object))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Message); goto done; }
  r = New(MsgBuf);
  
  if (r eq Null(MsgBuf))
   { Close(program);
     ErrorMsg(m, EC_Error + EG_NoMemory + EO_Message); 
     goto done; 
   }

  task = RmNewTask();             
  if (task eq (RmTask) NULL)
   { Close(program); 
     ErrorMsg(m, EC_Error + EG_NoMemory + EO_Task); 
     goto done; 
   }

  if (task_AddTaskEntry(task) ne RmE_Success)
   { Close(program); 
     ErrorMsg(m, EC_Error + EG_Invalid + EO_Taskforce); 
     goto done; 
   }
  task_entry		  = GetTaskEntry(task);
  task_entry->ProgramSize = progsize;
  task_entry->Program	  = program;
  
  if ((RmSetTaskId(task, objname(program->Name)) ne RmE_Success) ||
      (RmSetTaskType(task, ptype) ne RmE_Success) ||
      (RmSetTaskMemory(task, (3 * (unsigned long)progsize)) ne RmE_Success))
   { ErrorMsg(m, EC_Error + EG_Broken + EO_TFM); goto done; }

	/* Sort out the name.					*/
  	/* Allow five digits, . and the terminator		*/
  if (strlen(task->ObjNode.Name) > (NameMax - (5 + 1 + 1)))
   { ErrorMsg(m, EC_Error + EG_WrongSize + EO_Name); goto done; }
  strcat(&(task->ObjNode.Name[0]), ".");
  Wait(&LibraryLock);		/* TaskSequenceNumber must be locked */
  if (TaskSequenceNumber eq 1)
   task->ObjNode.Flags |= TfmFlags_FirstTask;
  addint(&(task->ObjNode.Name[0]), TaskSequenceNumber++);
  Signal(&LibraryLock);
  pathcat(pathname, task->ObjNode.Name);


  MRSW_GetWrite();

  for (retries = TaskRetries; retries > 0; retries--)
   { 
     Debug(dbg_Create, ("attempting mapping for %T", task));

     if (!domain_MapTask(task))
      { rc = EC_Error + EG_NoResource + EO_Processor; break; }

     processor = RmFollowTaskMapping(Domain, task);
     rc = task_Run(processor, task, program);
     if (rc eq Err_Null) 
      { success = TRUE; break; }

     Debug(dbg_Create, ("failed to execute task %T", task));
          
     if ((rc & EG_Mask) eq EG_NoMemory) break;
      
     MarkProcessor(processor);	/* This processor is suspicious */
     domain_UnmapTask(task);
   }

  if (success)  
   {	/* Add the task to the directory, and send back a reply */
     Debug(dbg_Create, ("task %T is running", task));
     Insert(&(TFM), &(task->ObjNode), FALSE);
     FormOpenReply(r, m, &(task->ObjNode), 0, pathname);
     PutMsg(&(r->mcb));
   }
  else
   ErrorMsg(m, rc);

  MRSW_FreeWrite();
   
done:
  if (!success && (task ne (RmTask) NULL))
   { MRSW_GetWrite();
     task_Destroy(task);
     MRSW_FreeWrite();
   }
  if (r ne Null(MsgBuf)) Free(r);
}

/*}}}*/
/*{{{  do_open_task() */

/**
*** 2) do_open_task().
***    This is used for the stream operations on a single
***    executing task. The current target in the servinfo structure is
***    an RmTask structure which is already being executed and monitored.
***    The Open() request has been acknowledged, so all this routine does
***    is accept requests and forward them down the appropriate stream.
**/

static void do_open_task(ServInfo *servinfo, MCB *m, Port reqport)
{ RmTask	task		= (RmTask) servinfo->Target;
  TaskEntry	*task_entry	= GetTaskEntry(task);
  BYTE		*Data		= m->Data;
  WORD		*Control	= m->Control;
  WORD		e;

  Debug(dbg_Create, ("open request for %T", task));
  
  task_entry->UseCount++;
  task->ObjNode.Account += 10000;

  UnLockTarget(servinfo);
  
  forever
   { m->MsgHdr.Dest	= reqport;
     m->Data		= Data;
     m->Control		= Control;
     m->Timeout		= StreamTimeout;

     e = GetMsg(m);
     if ((e < Err_Null) && (e ne EK_Timeout)) continue;
     Wait(&(task->ObjNode.Lock));
     task_entry = GetTaskEntry(task);

     if (e eq EK_Timeout)
      { unless(RmGetTaskState(task) & RmS_Running) task_GenProgInfo(task);
        break;
      }

     switch (m->MsgHdr.FnRc & FG_Mask)
      { case FG_SendEnv		:
		{ Environ received;
		  Port	  reply = tfm_GetEnv(reqport, m, &received);
		  word	  rc;
		  if (reply eq NullPort) break; /* tfm_GetEnv sent error */

		  MRSW_GetRead();
		  rc = task_HandleEnv(task, &received);
		  InitMCB(m, 0, reply, NullPort, rc);
		  PutMsg(m);
		  tfm_FreeEnv(&received);
		  if (rc < Err_Null)
		   task_DoSignal(task, SIGKILL);
		  MRSW_FreeRead();
		  break;
		}
      
        case FG_Signal 		:
		MRSW_GetRead();
        	task->ObjNode.Account += 10;
        	m->MsgHdr.FnRc = SS_TFM;
        	ErrorMsg(m, 0);
        	task_DoSignal(task, m->Control[0]);
        	task->ObjNode.Account += 10;
		MRSW_FreeRead();
        	break;
			        
        case FG_ProgramInfo	:
		{ Port	port		 = m->MsgHdr.Reply;
		  word	mask		 = m->Control[0];

		  MRSW_GetRead();
		  mask			&= PS_Terminate;
		  FreePort(task_entry->ProgInfoPort);
		  task->ObjNode.Account	+= 100;
		  task_entry->ProgInfoPort = (mask == 0) ? NullPort : port;
		  task_entry->ProgInfoMask = (int) mask;
		  InitMCB(m , (mask eq 0) ? 0 : MsgHdr_Flags_preserve,
		  	port, NullPort, Err_Null);
		  MarshalWord(m, mask);
		  MarshalWord(m, 1);
		  PutMsg(m);
		  task->ObjNode.Account += 100;
		  unless (RmGetTaskState(task) & RmS_Running)
		   task_GenProgInfo(task);
		  MRSW_FreeRead();
		  break;
		}

        case FG_Close		:
        	if (m->MsgHdr.Reply ne NullPort) ErrorMsg(m, 0);
        	m->MsgHdr.FnRc = SS_TFM;
        	goto done;
       
        default			:
        	ErrorMsg(m, EC_Error + EG_FnCode + EO_Task);
        	break;
      }
     
     Signal(&(task->ObjNode.Lock));
   }

done:
  task_entry->UseCount--;
  task->ObjNode.Account -= 10000;
  if (task_entry->UseCount eq 0)
   { MRSW_GetWrite();
     task_Destroy(task);
     MRSW_FreeWrite();
   }
  else
   Signal(&(task->ObjNode.Lock));
}

/*}}}*/
/*{{{  do_delete_task() */
/**
*** 3) do_delete_task().
***    As per the processor manager.
**/

static void	do_delete_task(ServInfo *servinfo)
{ MCB		*m		= servinfo->m;
  RmTask	task 		= (RmTask) servinfo->Target;
  TaskEntry	*task_entry	= GetTaskEntry(task);

  MRSW_GetRead();
  
  if (task_entry eq Null(TaskEntry))
   { ErrorMsg(m, EC_Error + EG_Broken + EO_Task); goto done; }
  if (task_entry->ProgramObject eq Null(Object))
   { ErrorMsg(m, EC_Error + EG_Broken + EO_Task); goto done; }

  Debug(dbg_Delete, ("deleting task %T, kill state %d", \
	  	task, task_entry->KillState));
  		
  switch(task_entry->KillState++)
   { case	0 : task_DoSignal(task, SIGINT); break;
     case	1 : task_DoSignal(task, SIGKILL); break;
     case	2 : task_Exterminate(task); break;
   }

  ErrorMsg(m, Err_Null);
done:
  MRSW_FreeRead();
}
/*}}}*/
/*{{{  do_create_taskforce() */
/*----------------------------------------------------------------------------*/
/**
*** Similar routines to the above, but for handling taskforces. Most
*** of these routines are similar to the routines for handling
*** single tasks, but tend to walk down the taskforce applying the operation
*** to every component.
***
*** 1) do_create_taskforce()
*/

static int  update_mapping(RmTask, ...);

static void do_create_taskforce(ServInfo *servinfo, Stream *CDLBinary, ImageHdr *hdr, int size)
{ RmTaskforce	taskforce	= (RmTaskforce) NULL;
  RmNetwork	network		= (RmNetwork) NULL;
  MCB		*m		= servinfo->m;
  bool		success		= FALSE;
  MsgBuf	*r		= Null(MsgBuf);
  char		*pathname	= servinfo->Pathname;
  int		retries;
  int		rc;
  TaskEntry	*task_entry	= Null(TaskEntry);
  
  Debug(dbg_Create, ("creating taskforce"));

  UnLockTarget(servinfo);
            
  r = New(MsgBuf);
  if (r eq Null(MsgBuf))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Message); goto done; }

	/* The binary object may be an old-style CDL binary or a binary	*/
	/* produced via the Resource Management library			*/
  if (hdr->Magic eq Taskforce_Magic)
   taskforce = RmReadCDL(CDLBinary, hdr, size);
  else
   { int *junk = (int *)hdr;
     rc = RmE_Success;
     if (junk[1])
      rc = RmReadNetwork(CDLBinary, &network, FALSE);
     if (junk[2] && (rc eq RmE_Success))
      rc = RmReadTaskforce(CDLBinary, &taskforce, FALSE);
     if ((network ne (RmNetwork) NULL) && (taskforce ne (RmTaskforce) NULL))
      (void) RmApplyTasks(taskforce, &update_mapping, network);
     Close(CDLBinary);
   }
  if (taskforce eq (RmTaskforce) NULL)
   { Debug(dbg_Create, ("error reading file"));
     ErrorMsg(m, EC_Error + EG_Invalid + EO_Taskforce); 
     goto done; 
   }

  if (task_AddTaskEntry((RmTask) taskforce) ne RmE_Success)
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Taskforce); goto done; }
  task_entry = (TaskEntry *) RmGetTaskforcePrivate(taskforce);

  rc = RmSearchTasks(taskforce, &task_AddTaskEntry);

  if (rc eq RmE_ServerMemory)
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Taskforce); goto done; }
  elif (rc eq RmE_NotFound)
   { ErrorMsg(m, EC_Error + EG_Unknown + EO_Program); goto done; }
  elif (rc ne RmE_Success)
   { ErrorMsg(m, EC_Error + EG_Broken + EO_Program); goto done; }
   
	/* Allow five digits, . and the terminator */
  if (strlen(taskforce->DirNode.Name) > (NameMax - (5 + 1 + 1)))
   { ErrorMsg(m, EC_Error + EG_WrongSize + EO_Name); goto done; }
  strcat(&(taskforce->DirNode.Name[0]), ".");
  Wait(&LibraryLock);		/* TaskSequenceNumber must be locked */
  if (TaskSequenceNumber eq 1)
   taskforce->DirNode.Flags |= TfmFlags_FirstTask;
  addint(&(taskforce->DirNode.Name[0]), TaskSequenceNumber++);
  Signal(&LibraryLock);
  pathcat(pathname, taskforce->DirNode.Name);

  for (retries = TaskforceRetries; retries > 0; retries--)
   { word e;

     Debug(dbg_Create, ("attempting to map taskforce %T", taskforce));

     MRSW_GetWrite();
     e = domain_MapTaskforce(network, taskforce);
     MRSW_FreeWrite();

     unless(e)
      { ErrorMsg(m, EC_Error + EG_NoResource + EO_Network); goto done; }
     task_entry->Mapped = TRUE;

     Debug(dbg_Create, ("attempting to start taskforce %T", taskforce));

     MRSW_GetRead();     	
     e = taskforce_Start(taskforce);
     MRSW_FreeRead();

     if (e eq Err_Null)   	/* The Taskforce is now up and running */
      { success = TRUE; break; }
     
     if ((e & EG_Mask) eq EG_NoMemory) break;

     MRSW_GetWrite();          
     domain_UnmapTaskforce(taskforce);
     MRSW_FreeWrite();

     task_entry->Mapped = FALSE;
   }
   
  if (success)      	
   {	/* Add it to the /tfm directory and send back a reply */
     Debug(dbg_Create, ("taskforce %T is running", taskforce));
     Insert(&(TFM), (ObjNode *) &(taskforce->DirNode),  FALSE);
     FormOpenReply(r, m, (ObjNode *) &(taskforce->DirNode), 0, pathname);
     PutMsg(&(r->mcb));
   }
  else
   ErrorMsg(m, EC_Error + EG_Create + EO_Taskforce);
      
done:
  if (!success && (taskforce ne (RmTaskforce) NULL))
   { MRSW_GetWrite();
     taskforce_Destroy(taskforce);
     MRSW_FreeWrite();
   }
  if (r ne Null(MsgBuf)) Free(r);
  if (network ne (RmNetwork) NULL)
   RmFreeNetwork(network);
}

	/* Because the network and taskforce are read separately rather	*/
	/* than via RmReadStream(), the task <-> processor mapping may	*/
	/* be screwed up. This code sorts out the mess.			*/
static int update_mapping(RmTask task, ...)
{ va_list	args;
  RmNetwork	network;
  RmProcessor	processor;

  va_start(args, task);
  network = va_arg(args, RmNetwork);
  va_end(args);

  if (task->MappedTo ne RmL_NoUid)
   { processor = RmFindProcessor(network, task->MappedTo);
     task->MappedTo = RmL_NoUid;
     if (processor ne (RmProcessor) NULL)
      RmMapTask(processor, task);
   }
  return(0);
}
/*}}}*/
/*{{{  do_open_taskforce() */

/*----------------------------------------------------------------------------*/
/**
*** 2) do_open_taskforce().
***    This is used for the stream operations on a single
***    executing taskforce. The current target in the servinfo structure is
***    an RmTaskforce structure which is already being executed and monitored.
***    The Open() request has been acknowledged, so all this routine does
***    is accept requests and forward them down the appropriate stream.
**/

static void do_open_taskforce(ServInfo *servinfo, MCB *m, Port reqport)
{ RmTaskforce	taskforce	= (RmTaskforce) servinfo->Target;
  TaskEntry	*task_entry	= (TaskEntry *) RmGetTaskforcePrivate(taskforce);
  BYTE		*Data		= m->Data;
  WORD		*Control	= m->Control;
  WORD		e;

  Debug(dbg_Create, ("open request for taskforce %T", taskforce));
  		
  task_entry->UseCount++;
  taskforce->DirNode.Account += 10000;

  UnLockTarget(servinfo);

  forever
   { m->MsgHdr.Dest	= reqport;
     m->Data		= Data;
     m->Control		= Control;
     m->Timeout		= StreamTimeout;

     e = GetMsg(m);

     if ((e < Err_Null) && (e ne EK_Timeout)) continue;
     Wait(&(taskforce->DirNode.Lock));
     task_entry = (TaskEntry *) RmGetTaskforcePrivate(taskforce);

     if (e eq EK_Timeout)
      { unless(RmGetTaskforceState(taskforce) & RmS_Running)
	 taskforce_GenProgInfo(taskforce);
        break;
      }
     
     m->MsgHdr.FnRc = 0;
     switch (e & FG_Mask)
      { case FG_SendEnv		:
		{ Environ	received;
		  Port		reply;
		  word		rc;

		  m->MsgHdr.FnRc = e;	/* needed by Tfm_GetEnv */
		  reply = tfm_GetEnv(reqport, m, &received);
		  if (reply eq NullPort) break; /* tfm_GetEnv sent error */

		  if (taskforce->DirNode.Flags & TfmFlags_GotEnviron)
		   { m->MsgHdr.FnRc = SS_TFM;
		     ErrorMsg(m, EC_Error + EG_InUse + EO_Stream);
		     break;
		   }
			/* Send back an initial message to the client	*/
			/* requesting a long timeout.			*/
		  InitMCB(m, MsgHdr_Flags_preserve, reply, NullPort,
				EC_Recover + EG_NewTimeout + 300);
		  PutMsg(m);

		  MRSW_GetRead();
		  rc = taskforce_HandleEnv(taskforce, &received);
		  InitMCB(m, 0, reply, NullPort, rc);
		  PutMsg(m);
		  tfm_FreeEnv(&received);
		  if (rc < Err_Null)
      		   taskforce_DoSignal(taskforce, SIGKILL);
                  taskforce->DirNode.Flags |= TfmFlags_GotEnviron;
		  MRSW_FreeRead();
      		  break;
		}
      
        case FG_Signal 		:
		MRSW_GetRead();
        	taskforce->DirNode.Account += 10;
        	m->MsgHdr.FnRc = SS_TFM;
        	ErrorMsg(m, 0);
        	taskforce_DoSignal(taskforce, m->Control[0]);
        	taskforce->DirNode.Account += 10;
		MRSW_FreeRead();
        	break;
			        
        case FG_ProgramInfo	:
		{ Port	port		 = m->MsgHdr.Reply;
		  word	mask		 = m->Control[0];
		  MRSW_GetRead();
		  mask			&= PS_Terminate;
		  FreePort(task_entry->ProgInfoPort);
		  taskforce->DirNode.Account	+= 100;
		  task_entry->ProgInfoPort = (mask == 0) ? NullPort : port;
		  task_entry->ProgInfoMask = (int) mask;
		  InitMCB(m , (mask eq 0) ? 0 : MsgHdr_Flags_preserve,
		  	port, NullPort, Err_Null);
		  MarshalWord(m, mask);
		  MarshalWord(m, 1);
		  PutMsg(m);
		  taskforce->DirNode.Account += 100;
		  unless(RmGetTaskforceState(taskforce) & RmS_Running)
                   taskforce_GenProgInfo(taskforce);

		  MRSW_FreeRead();
		  break;
		}

        case FG_Close		:
		Debug(dbg_Create, ("close request"));
        	if (m->MsgHdr.Reply ne NullPort) ErrorMsg(m, 0);
        	m->MsgHdr.FnRc = SS_TFM;
        	goto done;
       
        default			:
        	ErrorMsg(m, EC_Error + EG_FnCode + EO_Task);
        	break;
      }
     Signal(&(taskforce->DirNode.Lock));
   }

done:
  task_entry->UseCount--;
  taskforce->DirNode.Account -= 10000;
  if (task_entry->UseCount eq 0)
   { MRSW_GetWrite();
     taskforce_Destroy(taskforce);
     MRSW_FreeWrite();
   }
  else
   Signal(&(taskforce->DirNode.Lock));
}

/*}}}*/
/*{{{  do_delete_taskforce() */
/**
*** 3) do_delete_taskforce()
**/
static int	do_delete_taskforce_aux(RmTask task, ...);

static void	do_delete_taskforce(ServInfo *servinfo)
{ MCB		*m		= servinfo->m;
  RmTaskforce	Taskforce	= (RmTaskforce) servinfo->Target;
  TaskEntry	*task_entry	= (TaskEntry *) RmGetTaskforcePrivate(Taskforce);

  MRSW_GetRead();
  
  if (task_entry eq Null(TaskEntry))
   { ErrorMsg(m, EC_Error + EG_Broken + EO_Task); goto done; }

  Debug(dbg_Delete, ("deleting taskforce %T, current kill state is %d",\
	  	Taskforce, task_entry->KillState));
  	
  switch(task_entry->KillState++)
   { case	0 : taskforce_DoSignal(Taskforce, SIGINT); break;
     case	1 : taskforce_DoSignal(Taskforce, SIGKILL); break;
     case	2 : 
      (void) RmApplyTasks(Taskforce, &do_delete_taskforce_aux);
   }
  ErrorMsg(m, Err_Null);
done:
  MRSW_FreeRead();
}

static int do_delete_taskforce_aux(RmTask task, ...)
{ 
  task_Exterminate(task);
  return(0);
}
/*}}}*/





@


1.37
log
@fixed compile time warnings
@
text
@d16 1
a16 1
/* RcsId: $Header: /hsrc/network/RCS/tfm.c,v 1.36 1993/08/11 10:51:57 bart Exp nickc $*/
d381 1
a381 1
  { ProcStats	*stats = Malloc(sizeof(ProcStats) + 
@


1.36
log
@1) sorted out stack sizes.
2) the CheckWindow thread is only created if network monitoring is enabled
3) new version number
@
text
@d16 1
a16 1
/* RcsId: $Header: /hsrc/network/RCS/tfm.c,v 1.35 1993/01/26 16:41:58 bart Exp $*/
d709 1
a709 1
  (void) Write(DiagnosticsStream, &(output_buffer[5]), length - 5, -1);
d724 1
d726 1
d749 1
a749 1
  unless( CheckMask(req->Common.Access.Access, req->Arg.Mode & Flags_Mode))
d782 1
d785 1
d837 1
a837 1
    size = GetFileSize(s);
d850 2
a851 2
	  ItsAProgram	= Hdr.Size;
         Ptype		= (Hdr.Flags eq 0) ? RmT_Default : Hdr.Flags;
d872 1
d984 1
d990 1
d1056 1
a1056 1
      (RmSetTaskMemory(task, (unsigned long) (3 * progsize)) ne RmE_Success))
d1114 1
d1117 1
d1161 1
a1161 1
		  int	  rc;
d1194 1
a1194 1
		  task_entry->ProgInfoMask = mask;
d1231 1
d1416 1
d1464 1
a1464 1
		  int		rc;
d1511 1
a1511 1
		  task_entry->ProgInfoMask = mask;
d1549 1
@


1.35
log
@Attempted to fix various problems with the exit handling, cleaning up
the sockets etc.
@
text
@d16 1
a17 2
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.34 1993/01/13 11:07:56 bart Exp $";

d19 1
a19 1
static char *VersionNumber = "3.29";
d46 1
d118 1
a118 1
			       
d124 1
a124 1
	  { do_private,	2000 },
d126 15
a140 15
	  	 { do_open,		4000 },
	  	 { do_create,		2000 },	/* Create */
	  	 { DoLocate,		2000 },
	  	 { DoObjInfo,		2000 },
	  	 { InvalidFn,		2000 },	/* ServerInfo */
	  	 { do_delete,		2000 }, /* Delete */
	  	 { InvalidFn,		2000 }, /* Rename */
	  	 { InvalidFn,		2000 }, /* Link   */
	  	 { DoProtect,		2000 },
	  	 { InvalidFn,		2000 }, /* SetDate */
	  	 { DoRefine,		2000 },
	  	 { NullFn,		2000 }, /* CloseObj */
	  	 { InvalidFn,		2000 },	/* Revoke */
	  	 { InvalidFn,		2000 }, /* Reserved1 */
	  	 { InvalidFn,		2000 }	/* Reserved2 */
d223 2
a224 1
  (void) Fork(1000, &CheckWindow, 0);
d235 1
a235 1
  unless(Fork(2000, &AcceptConnections, 0))
@


1.34
log
@Increased priority to a level higher than ordinary applications
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/tfm.c,v 1.33 1992/10/07 13:38:00 bart Exp bart $";
d460 1
a460 1
  
d463 1
a463 1
  
d467 5
a473 3
#ifndef SingleProcessor
  while (RmCloseServer(RmNetworkServer) ne RmE_Success) Delay(10000);
#endif  
d507 1
a507 1
  memset(&cap, 0, sizeof(Capability));
d511 1
d514 3
a516 2
  if (sock_ctos >= 0) close(sock_ctos);
  if (sock_stoc >= 0) close(sock_stoc);
@


1.33
log
@Updated version number for next release
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.32 1992/09/09 11:45:24 bart Exp $";
d66 1
d156 3
@


1.32
log
@Updated version number, 3.28 supports the farm library
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.31 1992/08/17 15:57:40 bart Exp $";
d20 1
a20 1
static char *VersionNumber = "3.28";
d46 1
@


1.31
log
@Added i860 support
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/tfm.c,v 1.28 1992/07/07 10:53:58 paul Exp $";
d20 1
a20 1
static char *VersionNumber = "3.27";
d45 1
@


1.30
log
@Fixed error message
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.29 1992/07/21 11:04:51 bart Exp bart $";
d336 1
d340 1
d393 2
d556 2
a557 1
{ forever
d559 1
a559 1
     Delay(60 * OneSec);
@


1.29
log
@1) cleaned up the diagnostics routines
2) now uses RmLookupProcessor instead of TfmLookupProcessor
3) fixed bug in executing mapped taskforces through the Resource Management
   library.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/tfm.c,v 1.28 1992/07/07 10:53:58 paul Exp $";
d290 1
a290 1
        	RmMapErrorToString(rc));
@


1.28
log
@added c40
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.27 1992/06/08 12:12:53 bart Exp $";
d20 1
a20 1
static char *VersionNumber = "3.26";
d44 1
d300 1
d356 1
d574 1
d586 1
a586 5
			if (temp eq Null(char))
			 { *dest++ = '<'; *dest++ = 'n'; *dest++ = 'u';
			   *dest++ = 'l'; *dest++ = 'l'; *dest++ = '>';
			   break;
			 }
d590 29
d809 1
a809 1
  Debug(dbg_Create, ("testing program %s", o->Name));
d1053 1
a1053 1
     Debug(dbg_Create, ("attempting mapping for %s", task->ObjNode.Name));
d1063 1
a1063 1
     Debug(dbg_Create, ("failed to execute task %s", task->ObjNode.Name));
d1073 1
a1073 1
     Debug(dbg_Create, ("task %s is running", task->ObjNode.Name));
d1109 1
a1109 1
  Debug(dbg_Create, ("open request for %s", task->ObjNode.Name));
d1225 2
a1226 2
  Debug(dbg_Delete, ("deleting task %s, kill state %d", \
  	task->ObjNode.Name, task_entry->KillState));
d1319 1
a1319 2
     Debug(dbg_Create, ("attempting to map taskforce %s",\
     	 taskforce->DirNode.Name));
d1329 1
a1329 2
     Debug(dbg_Create, ("attempting to start taskforce %s",\
     	taskforce->DirNode.Name));
d1349 1
a1349 2
     Debug(dbg_Create, ("taskforce %s is running", \
     		taskforce->DirNode.Name));
d1407 1
a1407 1
  Debug(dbg_Create, ("open request for taskforce %s", Taskforcename(taskforce)));
d1539 2
a1540 2
  Debug(dbg_Delete, ("deleting taskforce %s, current kill state is %d",\
  	Taskforce->DirNode.Name, task_entry->KillState));
@


1.27
log
@Compiled in PreallocMsgbufs()
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.26 1992/04/24 15:45:01 bart Exp bart $";
a254 1

d387 1
d1395 1
d1467 1
@


1.26
log
@Fixed problems with the capability sent back to the client during
start-up. Added more diagnostics options.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.25 1992/03/25 18:03:41 bart Exp $";
a334 1
#if 0
a337 1
#endif    
@


1.25
log
@Various changes including:
1) first attempt at C40 support
2) RmLib execute support (not yet fully tested)
3) faster bootstrap, taskforce load, and better mapping
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.24 1992/01/15 11:04:39 bart Exp $";
d20 1
a20 1
static char *VersionNumber = "3.25";
d43 1
d74 3
a76 1
#define Use_IOC_Debugging		1
d79 1
d156 3
d162 3
a209 10
	/* Send back a reply with a capability for the TFM. This ends	*/
	/* up in the environment of the login shell.			*/
  { Capability	cap;
    NewCap(&cap, (ObjNode *) &Root, AccMask_R+AccMask_W+AccMask_D+AccMask_V);
    if (Write(fdstream(0), (BYTE *) &cap, sizeof(Capability), 5 * OneSec)
    		ne sizeof(Capability))
     fatal("failed to send back a capability for this Taskforce Manager");
  }
  close(0);

d245 10
d335 5
d914 3
@


1.24
log
@Major update of networking sources, to incorporate the fault-tolerance
work as demonstrated at the IED meeting 10.1.92
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/tfm.c,v 1.4 1991/09/11 11:16:28 bart Exp bart $";
d19 2
a20 1
static char *VersionNumber = "3.24";
d42 1
d44 2
a45 1

d71 7
d104 1
a104 5
#if 1
	WORD		DebugOptions = 0;
#else
	WORD		DebugOptions = -1;
#endif
d109 1
d135 2
a136 1

d149 1
a149 1
#if 0
d152 1
a152 1
#if 1
d157 1
a157 1
#if 0
d188 1
a188 1

d218 8
d250 2
a251 1

d261 1
d306 1
a306 1
     domain_entry = (DomainEntry *) RmGetProcessorPrivate(TfmProcessor);
d328 1
a328 1

d330 1
d389 4
a392 3

#endif	/* SingleProcessor */
	
d488 2
a489 1

d528 2
a529 1

d547 2
a548 1

d664 3
a666 1

d722 2
a723 1

d794 1
d799 1
a799 1
       	  
d810 2
d845 2
a846 1

d907 1
a907 1
#if 1
d917 2
d920 3
a922 1

d977 1
a977 2
  task_entry	= New(TaskEntry);
  if (task_entry eq Null(TaskEntry))
d982 1
a982 2
   
  RmSetTaskPrivate(task, (int) task_entry);
a992 1
	/* BLV - the processor name must be added as well...	*/
d1046 2
a1047 1

d1075 2
a1076 2
     m->Timeout		= 5 * OneSec;	/* StreamTimeout ?? */
     					/* 5 seconds useful for ProgInfo */
d1078 4
d1084 1
a1084 1
        continue;
d1086 1
a1086 3
     if (e < Err_Null) continue;
     
     Wait(&(task->ObjNode.Lock));
a1149 2
  Wait(&(task->ObjNode.Lock));

d1153 1
a1153 1
  if ( (!(RmGetTaskState(task) & RmS_Running)) && (task_entry->UseCount eq 0)) 
d1161 2
a1162 1

d1172 2
d1176 1
a1176 1
   { ErrorMsg(m, EC_Error + EG_Broken + EO_Task); return; }
d1178 1
a1178 1
   { ErrorMsg(m, EC_Error + EG_Broken + EO_Task); return; }
d1190 2
d1193 2
a1194 1

d1205 2
d1208 2
a1209 1
{ RmTaskforce	Taskforce	= (RmTaskforce) NULL;
a1216 1
  int		counter		= 0;
d1226 16
a1241 2
  Taskforce = RmReadCDL(CDLBinary, hdr, size);
  if (Taskforce eq (RmTaskforce) NULL)
d1247 1
a1247 2
  task_entry = New(TaskEntry);
  if (task_entry eq Null(TaskEntry))
d1249 1
a1249 16
  RmSetTaskforcePrivate(Taskforce, (int) task_entry);
  InitSemaphore(&(task_entry->AllFinished), 0);
  task_entry->UseCount		= 0;
  task_entry->ProgInfoPort	= NullPort;
  task_entry->ProgInfoMask	= 0;
  task_entry->TermCode		= 0;
  task_entry->KillState		= 0;
  task_entry->Mapped		= 0;
  task_entry->NumberTasks	= RmCountTasks(Taskforce);
  task_entry->TaskVec		= (RmTask *)
  		Malloc(task_entry->NumberTasks * sizeof(RmTask));
  if (task_entry->TaskVec eq Null(RmTask))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Taskforce); goto done; }
     		
  rc = RmSearchTasks(Taskforce, &taskforce_AddTaskEntry, 
  	&(task_entry->AllFinished), task_entry->TaskVec, &counter);
d1251 2
d1261 1
a1261 1
  if (strlen(Taskforce->DirNode.Name) > (NameMax - (5 + 1 + 1)))
d1263 1
a1263 1
  strcat(&(Taskforce->DirNode.Name[0]), ".");
d1266 2
a1267 2
   Taskforce->DirNode.Flags |= TfmFlags_FirstTask;
  addint(&(Taskforce->DirNode.Name[0]), TaskSequenceNumber++);
d1269 1
a1269 1
  pathcat(pathname, Taskforce->DirNode.Name);
d1275 1
a1275 1
     	 Taskforce->DirNode.Name));
d1278 1
a1278 1
     e = domain_MapTaskforce(Taskforce);
d1286 1
a1286 1
     	Taskforce->DirNode.Name));
d1289 1
a1289 1
     e = taskforce_Start(Taskforce);
d1298 1
a1298 1
     domain_UnmapTaskforce(Taskforce);
d1307 3
a1309 3
     		Taskforce->DirNode.Name));
     Insert(&(TFM), (ObjNode *) &(Taskforce->DirNode),  FALSE);
     FormOpenReply(r, m, (ObjNode *) &(Taskforce->DirNode), 0, pathname);
d1316 1
a1316 1
  if (!success && (Taskforce ne (RmTaskforce) NULL))
d1318 1
a1318 1
     taskforce_Destroy(Taskforce);
d1322 2
d1326 22
d1359 2
a1360 2
{ RmTaskforce	Taskforce	= (RmTaskforce) servinfo->Target;
  TaskEntry	*task_entry	= (TaskEntry *) RmGetTaskforcePrivate(Taskforce);
d1365 1
a1365 2
  Debug(dbg_Create, ("open request for taskforce %s", \
  		Taskforce->DirNode.Name));
d1368 1
a1368 1
  Taskforce->DirNode.Account += 10000;
d1376 2
a1377 2
     m->Timeout		= 5 * OneSec;	/* StreamTimeout ?? */
     					/* 5 seconds useful for ProgInfo */
d1379 4
d1384 3
a1386 3
      { unless(RmGetTaskforceState(Taskforce) & RmS_Running)
	 taskforce_GenProgInfo(Taskforce);
        continue;
a1387 1
     if (e < Err_Null) continue;
a1388 1
     Wait(&(Taskforce->DirNode.Lock));
d1400 1
a1400 1
		  if (Taskforce->DirNode.Flags & TfmFlags_GotEnviron)
d1412 1
a1412 1
		  rc = taskforce_HandleEnv(Taskforce, &received);
d1417 2
a1418 2
      		   taskforce_DoSignal(Taskforce, SIGKILL);
                  Taskforce->DirNode.Flags |= TfmFlags_GotEnviron;
d1425 1
a1425 1
        	Taskforce->DirNode.Account += 10;
d1428 2
a1429 2
        	taskforce_DoSignal(Taskforce, m->Control[0]);
        	Taskforce->DirNode.Account += 10;
d1439 1
a1439 1
		  Taskforce->DirNode.Account	+= 100;
d1447 3
a1449 3
		  Taskforce->DirNode.Account += 100;
		  unless(RmGetTaskforceState(Taskforce) & RmS_Running)
                   taskforce_GenProgInfo(Taskforce);
d1464 1
a1464 1
     Signal(&(Taskforce->DirNode.Lock));
a1465 1
  Wait(&(Taskforce->DirNode.Lock));
d1469 2
a1470 3
  Taskforce->DirNode.Account -= 10000;
  if ((!(RmGetTaskforceState(Taskforce) & RmS_Running)) && 
      (task_entry->UseCount eq 0)) 
d1472 1
a1472 1
     taskforce_Destroy(Taskforce);
d1476 1
a1476 1
   Signal(&(Taskforce->DirNode.Lock));
d1478 2
a1479 1

d1489 2
d1493 1
a1493 1
   { ErrorMsg(m, EC_Error + EG_Broken + EO_Task); return; }
d1505 2
d1514 5
@


1.23
log
@Minor changes to match Helios1_2_2_Native final release
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/tfm.c,v 1.6 1991/10/30 16:35:45 bart Exp $";
d19 1
a19 1
static char *VersionNumber = "3.22";
d39 2
d59 3
a77 1
static void		TerminateTFM(void);
a81 16
static void		monitor_task(RmTask);
static void 		task_GenProgInfo(RmTask);
static void 		task_Destroy(RmTask);
static void 		task_DoSignal(RmTask, word);
static word		task_HandleEnv(RmTask, Port, MCB *);
static Port		tfm_GetEnv(Port reqport, MCB *m, Environ *env);
static word		tfm_run_task(RmProcessor processor, RmTask task,
				 Object *code);
static void		exterminate_task(RmTask);
static int		taskforce_add_TaskEntry(RmTask, ...);
static word		taskforce_Start(RmTaskforce);
static void		monitor_taskforce(RmTaskforce);
static void		taskforce_GenProgInfo(RmTaskforce);
static void		taskforce_Destroy(RmTaskforce);
static void		taskforce_DoSignal(RmTaskforce, word);
static word		taskforce_HandleEnv(RmTaskforce, Port, MCB *);
d83 1
d86 2
a87 1
static	char		ProcessorName[IOCDataMax];
a88 1
static	Object		*NameEntry;
a101 1
	Semaphore	SingleStep;
d144 3
a156 1
  InitSemaphore(&(SingleStep), 1);
d158 1
d160 2
a161 1
  { char *message;
a162 10
    message =
     "only the Session Manager can start up a Taskforce Manager";
     
    if (argc ne 3)
     fatal(message);
   
    if (strcmp(argv[0], "SessionManager"))
     fatal(message);
  }

d166 6
d192 2
a193 1
	/* Send back a reply with a capability for the TFM */  
d195 1
a195 2
    NewCap(&cap, (ObjNode *) &Root,
    	AccMask_R + AccMask_W + AccMask_D + AccMask_V);
d202 12
a229 8
	/* Allow some signals to be handled asynchronously, since the	*/
	/* Posix library is rarely called.				*/
  init_signals();

	/* Start a process which will terminate the TFM if the current	*/
	/* window disappears.						*/
  (void) Fork(1000, &CheckWindow, 0);
      
d294 4
d377 3
a379 2
*** All outstanding tasks and taskforces are aborted. Then all processors are
*** returned to the system pool. Then the Taskforce Manager itself terminates
d384 1
a384 1
static void TerminateTFM(void)
d420 3
d429 40
d499 2
a646 2
*** 3) the Resource Management library opens the top level using the
***    mode O_Private.
d664 2
a665 8
  if (req->Arg.Mode eq O_Private)	/* the Resource Management library */
   { unless( CheckMask(req->Common.Access.Access, AccMask_D))
      { ErrorMsg(m, EC_Error + EG_Protected + EO_Object); return; }
   }
  else
   { unless( CheckMask(req->Common.Access.Access, req->Arg.Mode & Flags_Mode))
      { ErrorMsg(m, EC_Error + EG_Protected + EO_Object); return; }
   }
a676 32
	/**
	*** The valid open modes also vary between object types
	**/
  switch(req->Arg.Mode & Flags_Mode)
   { case O_Private	: if (f ne (ObjNode *)&TFM)
   			   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object);
   			     return;
   			   }
   			  break;

     default		: if ((f->Type eq Type_Network) || 
      			      (f eq (ObjNode *) &TFM) ||
      			      (f eq (ObjNode *) &Root))
      			   break;
     			  if ((f->Type ne Type_Task) &&
     			      (f->Type ne Type_Taskforce))
     			   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object);
     			     return;
     			   }
     			  if (f->Parent ne &TFM)
     			   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Task);
     			     return;
     			   }
			  unless( CheckMask(req->Common.Access.Access,
			  			O_WriteOnly))
			   { ErrorMsg(m, EC_Error + EG_Protected + EO_Object);
			     return;
			   }
     			  break;

   }

a689 3
   
  if (req->Arg.Mode eq O_Private)
   { do_open_rmlib(servinfo, m, reqport); FreePort(reqport); return; }
d750 1
a750 1
    if (size < sizeof(ImageHdr))
d808 1
a808 1
   
d839 2
d870 6
a875 54
  m->MsgHdr.FnRc = DebugOptions;
  ErrorMsg(m, Err_Null);  
}

/*----------------------------------------------------------------------------*/
/**
*** Utilities for running tasks.
***
*** 1) Given a processor on which to run a task, the RmTask structure, and
***    an object for the program to run, execute the task and start it going.
**/

static word	tfm_run_task(RmProcessor processor, RmTask task, 
			Object *program)
{ TaskEntry	*task_entry;
  WORD		e = Err_Null;
  Object	*real_processor = Null(Object);
  Object	*loader		= Null(Object);
  Object	*procman	= Null(Object);
  bool		processor_locked = FALSE;
  
  Debug(dbg_Create, ("running task %s (%s) on processor %s", \
  	task->ObjNode.Name, program->Name, processor->ObjNode.Name));
  	
  task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  if (task_entry eq Null(TaskEntry)) return(EC_Error + EG_Invalid + EO_Task);

  task_entry->Program		= program;
  task_entry->LoadedCode	= Null(Object);
  task_entry->ProgramObject	= Null(Object);
  task_entry->ProgramStream	= Null(Stream);
  task_entry->UseCount		= 0;
  task_entry->ProgInfoPort	= 0;
  task_entry->ProgInfoMask	= 0;
  task_entry->TermCode		= 0;
  task_entry->Running		= TRUE;
  task_entry->KillState		= 0;
  task_entry->ProgramSize	= 0;
  task_entry->Processor		= (RmProcessor) processor;
  
  Wait(&(processor->ObjNode.Lock));
  processor_locked = TRUE;
  
	/* Get all the details for the processor. */
  real_processor = TfmMapProcessorToObject(processor);
  if (real_processor eq Null(Object))
   { e = EC_Error + EG_NoMemory + EO_Processor; goto done; }

  loader = Locate(real_processor, "loader");
  if (loader eq Null(Object))
   { Debug(dbg_Create, ("failed to locate %s/loader, fault %x",\
   		 real_processor->Name, Result2(real_processor)));
     e = EC_Error + EG_Unknown + EO_Loader; 
     goto done; 
d877 4
a880 7

  procman = Locate(real_processor, "tasks");
  if (procman eq Null(Object))
   { Debug(dbg_Create, ("failed to locate %s/tasks, fault %x",\
   		real_processor->Name, Result2(real_processor)));
     e = EC_Error + EG_Unknown + EO_ProcMan; 
     goto done; 
d882 1
d884 2
a885 62
	/* Try to load the program onto the processor */  
  task_entry->LoadedCode = Load(loader, program);
  if (task_entry->LoadedCode eq Null(Object))
   { Debug(dbg_Create, ("failed to load program %s into %s, fault %x",\
   		 program->Name,	loader->Name, Result2(loader)));
     e = EC_Error + EG_Create + EO_Program; 
     goto done; 
   }

  	/* Then execute it. */
  task_entry->ProgramObject = Execute(procman, task_entry->LoadedCode);
  if (task_entry->ProgramObject eq Null(Object))
   { Debug(dbg_Create, ("failed to execute %s in %s, fault %x", \
   		task_entry->LoadedCode->Name, procman->Name, Result2(procman)));
     e = EC_Error + EG_Create + EO_Program;
     goto done; 
   }

  	/* Now open a stream to it. */
  task_entry->ProgramStream = 
  	Open(task_entry->ProgramObject, Null(char), O_ReadWrite);
  if (task_entry->ProgramStream eq Null(Stream))
   { Debug(dbg_Create, ("failed to open %s, fault %x",\
	task_entry->ProgramStream->Name, Result2(task_entry->ProgramStream)));
     e = EC_Error + EG_Open + EO_Program; 
     goto done; 
   }

	/* And start monitoring */   
  unless(Fork(MonitorStackSize, monitor_task, sizeof(RmTask), task))
   { Debug(dbg_Create, ("failed to fork() monitor process"));
     e =  EC_Error + EG_NoMemory + EO_Task; 
     goto done; 
   }
  
  e = Err_Null;
  
done:
  if (e ne Err_Null)
   { if (task_entry ne Null(TaskEntry))
      { if (task_entry->ProgramStream ne Null(Stream))
         { SendSignal(task_entry->ProgramStream, SIGKILL);
           Close(task_entry->ProgramStream);
           task_entry->ProgramStream = Null(Stream);
         }
        if (task_entry->ProgramObject ne Null(Object))
         { exterminate_task(task);
           Close(task_entry->ProgramObject);
           task_entry->ProgramObject = Null(Object);
         }
        if (task_entry->LoadedCode ne Null(Object))
         { (void) Delete(task_entry->LoadedCode, Null(char));
           Close(task_entry->LoadedCode);
           task_entry->LoadedCode = Null(Object);
         }
      }    
   }
  if (processor_locked) Signal(&(processor->ObjNode.Lock));
  if (real_processor ne Null(Object)) Close(real_processor);
  if (loader ne Null(Object)) Close(loader);
  if (procman ne Null(Object)) Close(procman);
  return(e);  
a887 9
/**
*** 2) Monitor a task, i.e. wait for it to finish. The action to take
***    when a task has finished depends on whether or not it is part
***    of a taskforce.
BLV
BLV At present this uses InitProgramInfo() and GetProgramInfo() which
BLV are pretty silly. For Helios 2.0 these should be replaced by a
BLV single WaitforTask() routine or something similar.
**/
a888 234
static void		monitor_task(RmTask task)
{ TaskEntry	*task_entry = (TaskEntry *) RmGetTaskPrivate(task);
 
  if (task_entry eq Null(TaskEntry)) return;
   
  if (InitProgramInfo(task_entry->ProgramStream, PS_Terminate) < Err_Null)
   { Debug(dbg_Monitor, ("error when starting to monitor %s",\
   		task_entry->ProgramStream->Name));
     task_entry->Running = FALSE;
     task_entry->UseCount = 0;
     if (task->ObjNode.Parent ne &TFM) Signal(task_entry->Finished);
     task_Destroy(task);
     return;
   }

  for ( task_entry->TermCode = EK_Timeout;
        task_entry->TermCode eq EK_Timeout;
      )
   { word junk[4];
     task_entry->TermCode = 
       GetProgramInfo(task_entry->ProgramStream, junk, MonitorDelay);
     if (task_entry->TermCode eq EK_Timeout)
      Debug(dbg_Monitor, ("component %s is still running", \
      		task_entry->ProgramStream->Name));
   }

  if ((task_entry->TermCode & SS_Mask) eq SS_TFM)
   { Debug(dbg_Monitor, ("component %s has been aborted internally",\
   		task_entry->ProgramStream->Name));
     return;
   }
   
  Debug(dbg_Monitor, ("component %s has terminated with %x",\
  	task_entry->ProgramStream->Name, task_entry->TermCode));
  Wait(&(task->ObjNode.Lock));
  task_entry->Running		 = FALSE;
  task->ObjNode.Account		+= 1000;  
  
 	/* If a single task terminates, generate the ProgInfo */
  if (task->ObjNode.Parent eq &TFM)
   { word flags = task->ObjNode.Flags;
     task_GenProgInfo(task);
     task->ObjNode.Account	+= 1000;
     if (task_entry->UseCount eq 0)
      task_Destroy(task);
     else
      Signal(&(task->ObjNode.Lock));
     if (flags & TfmFlags_FirstTask)
      while (!Fork(5000, TerminateTFM, 0));
   }
  else
  	/* If a component task has terminated, inform the supervisor monitor */
  	/* BLV - if a monitor routine has been installed, call it.	*/
   Signal(task_entry->Finished);
}

/**
*** 3) Exterminate a task. The processor manager should get rid of any task
***    when it has been deleted three times.
**/
static void exterminate_task(RmTask task)
{ TaskEntry	*task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  Object	*program;
  Object	*temp;

  if (task_entry eq Null(TaskEntry)) return;
  program = task_entry->ProgramObject;
  if (program eq Null(Object)) return;

  Debug(dbg_Delete, ("exterminating task %s", program->Name));

  temp = Locate(program, Null(char));
  if (temp eq Null(Object)) return;
  temp->FnMod |= 2;	/* to guarantee a kill */
  temp->Access = program->Access;
  (void) Delete(temp, Null(char));
  Close(temp);
}

/**
*** 4) get an environment. The system library's GetEnv cannot be used
***    because the initial message has been received already. This has been
***    copied from the system library with some modifications.
**/
static Port tfm_GetEnv(Port port, MCB *m, Environ *env)
{
	Port reply;
	word *control;
	word *buffer;
	byte *data;
	word e = Err_Null;
	word	*envsize = m->Control;
	bool	newenv = TRUE;
	bool	failed = FALSE;
	
	env->Argv = Null(char *);
	env->Envv = Null(char *);
	env->Objv = Null(Object *);
	env->Strv = Null(Stream *);
	
	newenv = m->MsgHdr.FnRc & 1;

	reply = m->MsgHdr.Reply;
	
	buffer = control = (word *)Malloc(envsize[0]*sizeof(word) + envsize[1]);

	if( control == Null(word) ) 
		e = EC_Error+SS_SysLib+EG_NoMemory+EO_Message;
	else
		e = newenv;
			
	InitMCB(m,0,reply,port,e);
        reply = NullPort;
        
	if((e = PutMsg(m)) < Err_Null) goto done;

	if( control == Null(word) ) goto done;
		
	/* we are now ready for the environment message */

	m->MsgHdr.Dest	= port;
	m->Control	= control;
	data		= (byte *)(control + envsize[0]);

	if (newenv) m->Data = (byte *) control;
	else	    m->Data = data;
	
	m->Timeout	= 30 * OneSec;

	if((e = GetMsg(m)) < Err_Null ) goto done;

	reply = m->MsgHdr.Reply;

	/* now we can un-marshal the environ ment data */

	/* argv first */
	env->Argv = (string *)control;
	while( *control != -1 ) 
	{
		*control = (word)&data[*control];
		control++;
	}
	*control++ = NULL;

	/* now envv */
	env->Envv = (string *)control;
	while( *control != -1 )
	{
		*control = (word)&data[*control];
		control++;
	}
	*control++ = NULL;

	/* now objects */
	env->Objv = (Object **)control;
	while( *control != -1 )
	{
		if( *control != MinInt )
		{	
			ObjDesc *o = (ObjDesc *)&data[*control];
			*control = (word)NewObject(o->Name,&o->Cap);
			if (*control == NULL)
			 { failed = TRUE; goto done; }
		}
		control++;
	}
	*control++ = NULL;
	
	/* and finally streams */
	env->Strv = (Stream **)control;
	while( *control != -1 )
	{
		if( *control != MinInt )
		{
			if( (*control&0xFFFF0000) == 0xFFFF0000 )
			{
				int ix = *control & 0x0000FFFF;
				*control = (word)(env->Strv[ix]);
			}
			else
			{
				StrDesc *s = (StrDesc *)&data[*control];
				int	openonget = (s->Mode & Flags_OpenOnGet);
				s->Mode &= ~Flags_OpenOnGet;
				*control = (word)NewStream(s->Name,&s->Cap,s->Mode);
				if (*control == NULL)
				 { failed = TRUE; goto done; }
				((Stream *)(*control))->Pos = s->Pos;
				if (openonget ne 0)
				 ((Stream *)(*control))->Flags |= Flags_OpenOnGet;
			}
		}
		control++;
	}
	*control++ = NULL;

  if (DebugOptions & dbg_Environ)
   { int i;
     report("received environment");
     for (i = 0; env->Argv[i] ne Null(char); i++)
      report("argument %d is %s", i, env->Argv[i]);
     for (i = 0; env->Envv[i] ne Null(char); i++)
      report("environment string %d is %s", i, env->Envv[i]);
     for (i = 0; env->Strv[i] ne Null(Stream); i++)
      if (env->Strv[i] ne (Stream *) MinInt)
       report("stream %d is %s", i, env->Strv[i]->Name);
     for (i = 0; env->Objv[i] ne Null(Object); i++)
      if (env->Objv[i] ne (Object *) MinInt)
       report("object %d is %s", i, env->Objv[i]->Name);
   }
   
done:

  if ((failed) && (buffer != Null(WORD)))
   { int i;
     Debug(dbg_Environ, ("error receiving environment"));
     if (env->Objv != Null(Object *))
      { for (i = 0; env->Objv[i] != Null(Object); i++)
         if (env->Objv[i] != (Object *) MinInt)
          Close(env->Objv[i]);
      }
     if (env->Strv != Null(Stream *))
      { for (i = 0; env->Strv[i] != Null(Stream); i++)
         if (env->Strv[i] != (Stream *) MinInt)
          Close(env->Strv[i]);
      }
     Free(buffer);
     InitMCB(m, 0, reply, NullPort, EC_Error + EG_NoMemory + EO_Message);
     PutMsg(m);
   }
   
  return(reply);
}

d920 2
a921 1
  
d924 2
d972 3
d976 2
a977 1
   { word e;
a978 2
     Debug(dbg_Create, ("attempting mapping for %s", task->ObjNode.Name));
        
d980 1
a980 5
      { ErrorMsg(m, EC_Error + EG_NoResource + EO_Processor); goto done; }
     processor = domain_FollowMapping(task);     
     e = tfm_run_task(processor, task, program);
     if (e eq Err_Null) 
      { success = TRUE; task_entry->Running = TRUE; break; }
d982 5
d989 1
a989 1
     if ((e & EG_Mask) eq EG_NoMemory) break;
d991 1
a991 1
     domain_MarkProcessor(processor);	/* This processor is suspicious */
a994 1

d998 1
a998 1
     Insert(&(TFM), &(task->ObjNode), TRUE);
d1003 3
a1005 1
   ErrorMsg(m, EC_Error + EG_Create + EO_Task);
d1008 5
a1012 1
  if (!success && (task ne (RmTask) NULL)) task_Destroy(task);
d1027 1
a1027 1
  TaskEntry	*task_entry	= (TaskEntry *) RmGetTaskPrivate(task);
d1036 2
a1038 2
  UnLockTarget(servinfo);

d1047 1
a1047 1
      { if (!task_entry->Running) task_GenProgInfo(task);
d1055 15
a1069 5
      		if (task_HandleEnv(task, reqport, m) < Err_Null)
      		 { task_DoSignal(task, SIGKILL);
      		   goto done;
      		 }
      		break;
d1072 1
d1078 1
d1084 2
d1097 3
a1099 1
		  if (!(task_entry->Running)) task_GenProgInfo(task);
d1121 5
a1125 2
  if ((!task_entry->Running) && (task_entry->UseCount eq 0)) 
   task_Destroy(task);
d1138 1
a1138 1
  TaskEntry	*task_entry	= (TaskEntry *) RmGetTaskPrivate(task);
d1151 1
a1151 1
     case	2 : exterminate_task(task); break;
a1156 162
/**
*** 4) task_GenProgInfo()
***    Generate a reply to an outstanding ProgInfo request.
**/
static void task_GenProgInfo(RmTask task)
{ TaskEntry	*task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  MCB		m;
  
 if ((task_entry->ProgInfoMask ne 0) && (task_entry->ProgInfoPort ne NullPort))
  { InitMCB(&m, MsgHdr_Flags_preserve, task_entry->ProgInfoPort, NullPort,
  		task_entry->TermCode);
    Debug(dbg_Delete, ("generating termination message for task %s",\
    		task->ObjNode.Name));
    task->ObjNode.Account += 100;
    PutMsg(&m);
    task->ObjNode.Account += 100;
  }
}


/**
*** 5) task_Destroy().
***    Kill/abort a task. The /tfm entry is made inaccessible.
***    If the task is running it is exterminated. All the data structures
***    are freed.
**/

static void task_Destroy(RmTask task)
{ TaskEntry	*task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  
  if ((task_entry->Running) || (task_entry->UseCount > 0)) return;

  Debug(dbg_Delete, ("destroying task %s", task->ObjNode.Name));

  Unlink(&(task->ObjNode), FALSE);
  task->ObjNode.Parent = Null(DirNode);

  if (task_entry->ProgInfoPort ne NullPort) FreePort(task_entry->ProgInfoPort);
  if (task_entry->ProgramStream ne Null(Stream))
   Close(task_entry->ProgramStream);
  if (task_entry->ProgramObject ne Null(Object))
   { exterminate_task(task);
     Close(task_entry->ProgramObject);
   }
  if (task_entry->LoadedCode ne Null(Object)) Close(task_entry->LoadedCode);
  if (task_entry->Program ne Null(Object))    Close(task_entry->Program);
  if (task_entry->Mapped) domain_UnmapTask(task);
  Free(task_entry);
  RmFreeTask(task);
}

/**
*** 6) task_DoSignal()
***    Send a signal to the specified task. This involves opening another
***    stream to the task because the current stream is used for monitoring.
**/
static void task_DoSignal(RmTask task, WORD signal)
{ TaskEntry	*task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  Stream	*s;

  if (task_entry eq Null(TaskEntry)) return;
  if (task_entry->ProgramObject eq Null(Object)) return;

  Debug(dbg_Signal, ("sending signal %d to task %s", signal, \
  		task->ObjNode.Name));  

  s = Open(task_entry->ProgramObject, Null(char), O_ReadWrite);
  if (s eq Null(Stream)) return;
  SendSignal(s, signal);
  Close(s);
}

/**
*** 7) task_HandleEnv()
***    This routine is called when the first message of a SendEnv request
***    has been received. The rest of the environment is obtained by
***    a modified form of the system's GetEnv() routine, tfm_GetEnv().
***    This environment is then adjusted as appropriate for the task,
***    and sent off.
**/

static word task_HandleEnv(RmTask task, Port port, MCB *m)
{ Environ	received, sending;
  Object	*Objv[OV_End + 1];
  TaskEntry	*task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  int		i;
  Stream	*program_stream = Null(Stream);
  Port		reply;
  word		result = Err_Null;
  
  if ((reply = tfm_GetEnv(port, m, &received)) eq NullPort)
   return(EC_Error + EG_NoMemory + EO_Message);

  sending.Argv		= received.Argv;
  sending.Envv		= received.Envv;
  sending.Strv		= received.Strv;
  Objv[OV_Cdir]		= received.Objv[OV_Cdir];
  Objv[OV_Task]		= task_entry->ProgramObject;
  Objv[OV_Code]		= task_entry->LoadedCode;
  Objv[OV_Source]	= task_entry->Program;
  Objv[OV_Parent]	= received.Objv[OV_Parent];
  Objv[OV_Home]		= received.Objv[OV_Home];
  Objv[OV_Console]	= received.Objv[OV_Console];
  Objv[OV_CServer]	= received.Objv[OV_CServer];
  Objv[OV_Session]	= received.Objv[OV_Session];
  Objv[OV_TFM]		= received.Objv[OV_TFM];
  Objv[OV_TForce]	= (Object *) MinInt;
  Objv[OV_End]		= Null(Object);
  for (i = 0; i < OV_End; i++)
   if (Objv[i] eq Null(Object))
    Objv[i] = (Object *) MinInt;
  sending.Objv		= Objv;

  if (DebugOptions & dbg_Environ)
   { int i;
     report("sending environment to task %s", task->ObjNode.Name);
     for (i = 0; sending.Argv[i] ne Null(char); i++)
      report("argument %d is %s", i, sending.Argv[i]);
     for (i = 0; sending.Envv[i] ne Null(char); i++)
      report("environment string %d is %s", i, sending.Envv[i]);
     for (i = 0; sending.Strv[i] ne Null(Stream); i++)
      if (sending.Strv[i] ne (Stream *) MinInt)
       report("stream %d is %s", i, sending.Strv[i]->Name);
     for (i = 0; sending.Objv[i] ne Null(Object); i++)
      if (sending.Objv[i] ne (Object *) MinInt)
       report("object %d is %s", i, sending.Objv[i]->Name);
   }
   
  program_stream = Open(task_entry->ProgramObject, Null(char), O_ReadWrite);
  if (program_stream eq Null(Stream)) 
   { result = EC_Error + EG_Open + EO_Program; goto done; }

  result = SendEnv(program_stream->Server, &sending);
  
done:
  if (program_stream ne Null(Stream)) Close(program_stream);
  { Stream **streams, **streams2;
    for (streams = received.Strv; *streams ne Null(Stream); streams++) 
     if (*streams ne (Stream *) MinInt)
      { Close(*streams);
		/* With the new environment, the same stream object may */
		/* be present more than once. It should be closed once	*/
		/* only.						*/
        for (streams2 = &(streams[1]); *streams2 ne Null(Stream); streams2++)
         if (*streams2 eq *streams)
          *streams2 = (Stream *) MinInt;
        *streams = (Stream *) MinInt;
      }
  }
  { Object **objects;
    for (objects = received.Objv; *objects ne Null(Object); objects++)
     if (*objects ne (Object *) MinInt)
      Close(*objects);
  }    
  Free(received.Argv);	/* Environment info starts here */
  
 	/* Acknowledge the environment */
  InitMCB(m, 0, reply, NullPort, result);
  PutMsg(m);
  return(result);
}

d1163 1
a1163 3
**/

/**
d1179 2
a1185 4
	/* It is wrong to keep the /tfm directory locked when starting	*/
	/* up a Taskforce, because that takes too long.			*/
  UnLockTarget(servinfo);
  
a1201 1
  task_entry->Running		= FALSE;
d1210 1
a1210 1
  rc = RmSearchTasks(Taskforce, &taskforce_add_TaskEntry, 
d1236 6
a1241 1
     unless(domain_MapTaskforce(Taskforce))
d1247 2
a1248 1
     	
d1250 2
d1253 1
a1253 1
      { success = TRUE; task_entry->Running = TRUE; break; }
d1256 2
a1257 1
          
d1259 2
d1277 4
a1280 1
   taskforce_Destroy(Taskforce);
a1281 1
  LockTarget(servinfo);
a1291 1
***    To do this it may need its own stream to the task.
d1308 1
a1308 1
    
d1317 2
a1318 1
      { if (!task_entry->Running) taskforce_GenProgInfo(Taskforce);
d1327 30
a1356 12
		if (Taskforce->DirNode.Flags & TfmFlags_GotEnviron)
		 { m->MsgHdr.FnRc = SS_TFM;
		   ErrorMsg(m, EC_Error + EG_InUse + EO_Stream);
		   break;
		 }
		m->MsgHdr.FnRc = e;	/* needed by Tfm_GetEnv */
      		if (taskforce_HandleEnv(Taskforce, reqport, m) < Err_Null)
      		 { taskforce_DoSignal(Taskforce, SIGKILL);
      		   goto done;
      		 }
      		Taskforce->DirNode.Flags |= TfmFlags_GotEnviron;
      		break;
d1359 1
d1365 1
d1371 1
d1383 3
a1385 1
		  if (!(task_entry->Running)) taskforce_GenProgInfo(Taskforce);
a1398 1
     
a1400 1

d1406 6
a1411 2
  if ((!task_entry->Running) && (task_entry->UseCount eq 0)) 
   taskforce_Destroy(Taskforce);
d1443 1
a1443 1
  exterminate_task(task);
a1444 929
}

/**
*** 4) taskforce_add_TaskEntry()
***    This routine is applied to a new taskforce, and should fill in the
***    tfm-specific information in separate TaskEntry structures.
**/
static int	taskforce_FindProgram(RmTask task, ...);

static int	taskforce_add_TaskEntry(RmTask task, ...)
{ TaskEntry	*task_entry;
  va_list	args;
  Semaphore	*sem;
  int		number_streams;
  char		*code_name;
  int		*counter;
  RmTask	*TaskVec;
    
  va_start(args, task);
  sem		= va_arg(args, Semaphore *);
  TaskVec	= va_arg(args, RmTask *);
  counter	= va_arg(args, int *);
  va_end(args);
  
  TaskVec[*counter] = task; *counter += 1;
  
	/* Find out how big the task_entry has to be. This depends on	*/
	/* number of channels.						*/
  number_streams = RmCountChannels(task);
  if (number_streams eq -1) return(RmE_Corruption);
  if (number_streams < DefaultStreams) number_streams = DefaultStreams;

  task_entry = Malloc(sizeof(TaskEntry) + (number_streams * sizeof(Stream *)));
  if (task_entry eq Null(TaskEntry)) return(RmE_ServerMemory);
  task_entry->Streams[number_streams--] = Null(Stream);
  for ( ; number_streams >= 0; number_streams--)
   task_entry->Streams[number_streams] = (Stream *) MinInt;

	/* extract the binary object for this task			*/
  code_name = (char *) RmGetTaskCode(task);
  if (code_name eq Null(char))
   { Free(task_entry); return(RmE_NotFound); }

	/* search the taskforce for components that share the same	*/
	/* code. The search aborts with -1 at the point where the	*/
	/* search encounters tasks not yet initialised.			*/
  task_entry->SameCode = (RmTask)
   RmSearchTasks(RmRootTaskforce(task), &taskforce_FindProgram, code_name);
  if (task_entry->SameCode eq (RmTask) -1) task_entry->SameCode = (RmTask) NULL;

	/* If the code is shared this is noted here. The LoaderCopy	*/
	/* flag is checked when actually starting up the taskforce.	*/
  if (task_entry->SameCode ne (RmTask) NULL)
   { task->ObjNode.Flags |= TfmFlags_LoaderCopy;
     task_entry->Program = Null(Object);
   }
  else   
   { task_entry->Program = Locate(Null(Object), (char *) RmGetTaskCode(task));
     if (task_entry->Program eq Null(Object))
      { Free(task_entry); return(RmE_NotFound); }
    }
     
  task_entry->LoadedCode	= Null(Object);
  task_entry->ProgramObject	= Null(Object);
  task_entry->ProgramStream	= Null(Stream);
  task_entry->UseCount		= 0;
  task_entry->ProgInfoPort	= NullPort;
  task_entry->ProgInfoMask	= 0;
  task_entry->TermCode		= 0;
  task_entry->Running		= FALSE;
  task_entry->KillState		= 0;
  task_entry->Processor		= (RmProcessor) NULL;
  task_entry->ProgramSize	= 0;
  task_entry->Finished		= sem;
  RmSetTaskPrivate(task, (int) task_entry);
  return(RmE_Success);
}

/**
*** In order to minimise disk accesses, a search is made for every component
*** to see if it shares the same code.
**/
static int taskforce_FindProgram(RmTask task, ...)
{ va_list	args;
  TaskEntry	*task_entry;
  char		*program_name;
  
  va_start(args, task);
  program_name = va_arg(args, char *);
  va_end(args);
  
  task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  if (task_entry eq Null(TaskEntry)) return(-1); /* end reached */
  if (strcmp(program_name, RmGetTaskCode(task))) return(0);
  return((int) task);
}

/**
*** 5) taskforce_Start().
***    This routine takes care of starting all the components in a taskforce,
***    once the taskforce has been fully mapped, resolved, and so on.
***    a) execute every task on the target processor. If this fails
***       mark the processor as suspicious and fail the whole attempt.
***    b) there is already a monitor process for every component task.
***       It is necessary to add a process to monitor the whole taskforce.
***    c) for every component check every stream and create it.
**/

static word	taskforce_SequentialStart(RmTaskforce);
#if ParallelStartup
static word	taskforce_ParallelStart(RmTaskforce, TaskEntry *);
#endif

static int	taskforce_StartAux1(RmTask task, ...);
static int	taskforce_StartAux2(RmTask task, ...);
static int	taskforce_StartAux3(RmTask task, ...);

static word	taskforce_Start(RmTaskforce Taskforce)
{ TaskEntry	*task_entry;

  task_entry = (TaskEntry *) RmGetTaskforcePrivate(Taskforce);
#if ParallelStartup
  if (task_entry->NumberTasks >= 32)  
   return(taskforce_ParallelStart(Taskforce, task_entry));
  else
#endif  
   return(taskforce_SequentialStart(Taskforce));
}

static word taskforce_SequentialStart(RmTaskforce Taskforce)
{ int	result;

  result = RmSearchTasks(Taskforce, &taskforce_StartAux1);
  if (result ne Err_Null) goto done;
  if (!Fork(MonitorStackSize, &monitor_taskforce, sizeof(RmTaskforce),
            Taskforce))
   { result = EC_Error + EG_NoMemory + EO_Taskforce; goto done; }

  result = RmSearchTasks(Taskforce, &taskforce_StartAux2);
done:
  if (result ne Err_Null)  
   (void) RmApplyTasks(Taskforce, &taskforce_StartAux3);
  return(result);
}

#if ParallelStartup
/**
*** Parallel taskforce. If there are more than 32 components then I start
*** up a separate process for every 16 of them. Each process is responsible
*** for starting up upto 16 components and initialising the standard streams.
***
BLV One process for every sixteen components seems silly. A better algorithm
BLV which avoids processes responsible for just one task is called for.
**/

static  void taskforce_ParallelAux(RmTask *, int count, Semaphore *, int *);

static	word taskforce_ParallelStart(RmTaskforce Taskforce, TaskEntry *task_entry)
{ int		number_tasks	= task_entry->NumberTasks;
  int		number_processes;
  int		i;
  int		result = 0;
  Semaphore	Done;
  
  InitSemaphore(&Done, 0);

  number_processes = (number_tasks + 15) / 16;  
  for (i = 0; i < number_processes; i++)
   { RmTask	*vec = &(task_entry->TaskVec[16 * i]);
     int	count = number_tasks - (i * 16);
     if (count > 16) count = 16;
     
     if (!Fork(1000, &taskforce_ParallelAux, 16, vec, count, &Done, &result))
      { int	j;
		/* wait for the existing processes to finish/abort	*/
        for (j = 0; j < i; j++) Wait(&Done);
        return(EC_Error + EG_NoMemory + EO_Taskforce);
      }
   }

  for (i = 0; i < number_processes; i++)
   Wait(&Done);

  if (result eq Err_Null)
   if (!Fork(MonitorStackSize, &monitor_taskforce, sizeof(RmTaskforce),
            Taskforce))
    result = EC_Error + EG_NoMemory + EO_Taskforce;
   
  return(result);
}

/**
*** ParallelAux : this process is responsible for starting between 1 and 16
*** components. It can do this by calling the same routines as for a
*** sequential taskforce startup. Error recovery is a little bit nasty.
**/
static void taskforce_ParallelAux(RmTask *TaskVec, int count, Semaphore *Done,
			int *result)
{ int	i;
  int	rc = Err_Null;

  for (i = 0; i < count; i++)
   { rc = taskforce_StartAux1(TaskVec[i]);
     if (rc ne Err_Null) goto done;
   }
  for (i = 0; i < count; i++)
   { rc = taskforce_StartAux2(TaskVec[i]);
     if (rc ne Err_Null) break;
   }

done:
  if (rc ne Err_Null) *result = rc;
  Signal(Done);
}	
#endif
		
/**
*** Phase 1, start the task running on the appropriate processor.
*** This may involve getting the code off disk, or from an existing
*** loader.
**/

static int	taskforce_StartAux1(RmTask task, ...)
{ RmProcessor	processor;
  word		rc;
  TaskEntry	*task_entry;
  Object	*program = Null(Object);
  int		i;
  
  task_entry	= (TaskEntry *) RmGetTaskPrivate(task);
  processor	= domain_FollowMapping(task);

  if ((task->ObjNode.Flags & TfmFlags_LoaderCopy) ne 0)
   { TaskEntry *sibling_task_entry;
     sibling_task_entry = (TaskEntry *) RmGetTaskPrivate(task_entry->SameCode);

	/* In a parallel start-up the code may not be loaded yet	*/
	/* because another process is in charge of it.			*/
     for (i = 0; i < 200; i++)
      { program = sibling_task_entry->LoadedCode;
        if (program ne Null(Object)) break;
	Delay(OneSec);
      }
   }
  else
   program = task_entry->Program;

  rc = tfm_run_task(processor, task, program);

  if (rc eq Err_Null)
   if ((task->ObjNode.Flags & TfmFlags_LoaderCopy) ne 0)
    { TaskEntry *sibling_task_entry;
      sibling_task_entry = (TaskEntry *) RmGetTaskPrivate(task_entry->SameCode);
      task_entry->Program = sibling_task_entry->Program;
    }
    
  if ((rc eq Err_Null) || ((rc & EG_Mask) eq EG_NoMemory)) return(rc);

  Debug(dbg_Create, ("failed to execute component %s on processor %s",\
  		task->ObjNode.Name, processor->ObjNode.Name));
  		
  domain_MarkProcessor(processor);	/* This processor is now suspicious */
  return(rc);
}


/**
*** Aborting when things go wrong, this is very nasty.
**/
static int taskforce_StartAux3(RmTask Task, ...)
{ TaskEntry	*task_entry;
  int		number_channels;
  int		i;
  
  Debug(dbg_Create, ("aborting create of %s", Task->ObjNode.Name));
  task_entry = (TaskEntry *) RmGetTaskPrivate(Task);
  if (task_entry->ProgramStream ne Null(Stream))
   { AbortPort(task_entry->ProgramStream->Reply, 
   		EC_Fatal + SS_TFM + EG_Create + EO_TaskForce);
     Close(task_entry->ProgramStream); 
     task_entry->ProgramStream = Null(Stream); 
   }
  if (task_entry->ProgramObject ne Null(Object))
   { exterminate_task(Task);
     Close(task_entry->ProgramObject);
     task_entry->ProgramObject = Null(Object);
   }
  if (task_entry->LoadedCode ne Null(Object))
   { Close(task_entry->LoadedCode); task_entry->LoadedCode = Null(Object); }

  number_channels = RmCountChannels(Task);
  for (i = 0; i < number_channels; i++)
   { Stream	*s = task_entry->Streams[i];
     if (s->Flags & TfmFlags_InternalStream)
      { Object *pipe = NewObject(s->Name, &(s->Access));
	Debug(dbg_Create, ("deleting pipe %s", pipe->Name));
        Close(pipe);
      }
     if ((s ne (Stream *) MinInt) && (s ne Null(Stream))) Close(s);
     task_entry->Streams[i] = (Stream *) MinInt;
   }
  task_entry->Streams[number_channels] = Null(Stream);
}

/**
*** Create the communication streams for this taskforce.
*** For every task, check every channel.
*** 1) if it is not connected, leave it.
*** 2) if it is external, i.e. a file, create a stream to that file creating
***    it if necessary.
*** 3) if it is a pipe, check the other end. If the Uid is less then the
***    pipe already exists. If the uid is greater then create it and set up
***    both ends. If they are the same, check the channel numbers.
**/
static int	taskforce_handle_file(RmTask task, int channel);
static void	build_pipe_name(char *buffer);

static int	taskforce_StartAux2(RmTask task, ...)  
{ int		number_channels;
  int		i;
  RmTask	dest;
  int		destlink;
  TaskEntry	*task_entry;
  RmProcessor	processor;
  Object	*real_processor = Null(Object);
  int		rc;
  bool		processor_locked = FALSE;
          
  Debug(dbg_Create, ("creating standard streams for component %s",\
  		task->ObjNode.Name));
  		
  processor = domain_FollowMapping(task);
  Wait(&(processor->ObjNode.Lock));
  processor_locked = TRUE;
	
  real_processor = TfmMapProcessorToObject(processor);
  if (real_processor eq Null(Object)) 
   { rc = EC_Error + EG_NoMemory + EO_Processor; goto done; }
   
  task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  
  number_channels = RmCountChannels(task);
  if (number_channels eq -1)
   { rc = EC_Error + EG_Broken + EO_Taskforce; goto done; }

	/* For every channel in this component */
  for (i = 0; i < number_channels; i++)
   { TaskEntry	*its_task_entry;
     dest = RmFollowChannel(task, i, &destlink);

	/* If not connected, ignore it */
     if (dest eq RmM_NoTask) continue;
     
    	/* external channels are filenames of some sort. */
     if (dest eq RmM_ExternalTask)
      { rc = taskforce_handle_file(task, i);
        if (rc ne Err_Null) goto done;
        continue;
      }

	/* The taskforce must have been fully resolved before it reaches here */
     if (destlink eq RmM_AnyChannel)
      { rc = EC_Error + EG_Invalid + EO_Pipe; goto done; }

     if ((dest->Uid < task->Uid) ||
         ((dest->Uid eq task->Uid) && (destlink < i)))
      { Debug(dbg_Create, ("channel %d, done elsewhere", i));
      	 continue;
      }
     its_task_entry = (TaskEntry *) RmGetTaskPrivate(dest);

	/* It is necessary to create a new pipe. This pipe is created on*/
	/* the same processor as the component, for efficiency.		*/
      { Object		*pipe;
	char		buffer[NameMax * 2];
	Stream		*my_stream = Null(Stream);
	Stream		*its_stream = Null(Stream);

	build_pipe_name(buffer);
	Debug(dbg_Create, ("channel %d, creating %s in processor %s", i, \
		buffer, real_processor->Name));

	pipe	= Create(real_processor, buffer, Type_Pipe, 0, Null(BYTE));
	if (pipe eq Null(Object))
	 { Debug(dbg_Create, ("failed to create pipe, fault %x", \
	 		Result2(real_processor)));
	   domain_MarkProcessor(processor);
	   rc = EC_Error + EG_Create + EO_Pipe;
	   goto done;
	 }

	my_stream	= PseudoStream(pipe, O_ReadWrite);
        if (my_stream ne Null(Stream))
 	 its_stream	= PseudoStream(pipe, O_ReadWrite);
        if ((my_stream eq Null(Stream)) ||(its_stream eq Null(Stream)))
         { if (my_stream  ne Null(Stream)) Close(my_stream);
           if (its_stream ne Null(Stream)) Close(its_stream);
	   Delete(pipe, Null(char));
           Debug(dbg_Create, ("failed to open both sides of %s, fault %x", \
           	pipe->Name, Result2(pipe)));
           Close(pipe);
           rc = EC_Error + EG_NoMemory + EO_Pipe;
           goto done;
         }
        Close(pipe);
        its_task_entry->Streams[destlink] = its_stream;
        task_entry->Streams[i] = my_stream;
        its_stream->Flags	|= (TfmFlags_InternalStream + Flags_Stream);
        my_stream->Flags	|= (TfmFlags_InternalStream + Flags_Stream);
        its_stream->Flags       &= ~Flags_CloseOnSend;
        my_stream->Flags	&= ~Flags_CloseOnSend;
      }
   }
   
  rc = Err_Null;
    
done:
  if (real_processor ne  Null(Object)) Close(real_processor);
  if (processor_locked) Signal(&(processor->ObjNode.Lock));
  return(rc);
}

/**
*** building a unique name for a pipe. This is quite tricky, because there
*** may be multiple components of one taskforce on the same processor
*** as well as components from different taskforces. Hence I cheat by
*** using a simple static counter.
**/
static void	build_pipe_name(char *buffer)
{ static	int counter = 1;
  strcpy(buffer, "pipe/x");
  Wait(&LibraryLock);
  addint(buffer, counter++);
  Signal(&LibraryLock);
}

/**
*** Handle redirection to/from a file. This involves extracting
*** the file name etc. from the RmTask structure. The file name can
*** take two forms:
*** 1) @@xxxxxxxxxxxxxxxxxx/helios/tmp:xx
***    This has a capability for the directory /helios/tmp
*** 2) /helios/tmp/xx
***    This is an absolute pathname without capability.
**/
static int	taskforce_handle_file(RmTask task, int channel)
{ int		mode;
  const char	*filename = RmFollowChannelToFile(task, channel, &mode);
  TaskEntry	*task_entry = (TaskEntry *) RmGetTaskPrivate(task);

  if (filename eq Null(const char)) return(EC_Error + EG_Broken + EO_Taskforce);

  Debug(dbg_Create, ("channel %d is a file, open mode %x", channel,\
  	filename, mode));
  	
  if (filename[0] eq '@@')
   { Capability		Access;
     Object		*directory; 
     char		*objname;
     char		*dirname;
     Stream		*result;
     
     dirname		= DecodeCapability((char *) filename, &Access);
     for (objname = dirname; (*objname ne ':') && (*objname ne '\0');
          objname++);
     if (*objname eq '\0') return(EC_Error + EG_Broken + EO_Taskforce);
     *objname = '\0';
      
     directory		= NewObject(dirname, &Access);
     *objname++		= ':';
     if (directory eq Null(Object)) return(EC_Error + EG_Invalid + EO_Capability);
     result		= Open(directory, objname, mode);
     Close(directory);
     if (result eq Null(Stream))
      { Debug(dbg_Create, ("failed to open file %s in directory %s, fault %x",\
                    objname, directory->Name, Result2(directory)));
        return(EC_Error + EG_Open + EO_File);
      }
      
     result->Flags |= TfmFlags_InternalStream;
     if (mode & O_Append) (void) Seek(result, S_End, 0);
    
     task_entry->Streams[channel] = result;
     return(Err_Null);
   }
  else
   { char	*obj_name = objname((char *) filename);
     Object	*directory;
     Stream	*result;
     
     obj_name[-1] = '\0';
     directory	  = Locate(Null(Object), (char *) filename);
     obj_name[-1] = '/';

     if (directory eq Null(Object)) return(EC_Error + EG_Unknown + EO_Directory);
     result	  = Open(directory, obj_name, mode);
     Close(directory);
     if (result eq Null(Stream)) 
      { Debug(dbg_Create, ("failed to open file %s in directory %s, fault %x",\
      		obj_name, directory->Name, Result2(directory)));
        return(EC_Error + EG_Open + EO_File);
      }
     result->Flags	|= TfmFlags_InternalStream;
     if (mode & O_Append) (void) Seek(result, S_End, 0);
      
     task_entry->Streams[channel] = result;
   }
  return(Err_Null); 
}

/**
*** 6) monitor_taskforce()
***
*** This routine waits for the termination of an entire taskforce.
*** Whenever a component is terminated or aborted a Semaphore will
*** be signalled. This routine waits for every component to signal,
*** and then takes care of the proginfo etc.
**/
static int	monitor_taskforce_aux2(RmTask task, ...);

static void	monitor_taskforce(RmTaskforce Taskforce)
{ int		count;
  TaskEntry	*task_entry = (TaskEntry *) RmGetTaskforcePrivate(Taskforce);
  word		flags;

  count = RmCountTasks(Taskforce);
  Debug(dbg_Monitor, ("monitoring taskforce %s", Taskforce->DirNode.Name));
  while (count-- > 0)
   { Wait(&(task_entry->AllFinished));
     Debug(dbg_Monitor, ("taskforce %s, %d components still running",\
     		Taskforce->DirNode.Name, count));
   }
  Wait(&(Taskforce->DirNode.Lock));
  task_entry->Running		 = FALSE;
  Taskforce->DirNode.Account	+= 1000;
  task_entry->TermCode		 = RmApplyTasks(Taskforce, 
  					&monitor_taskforce_aux2);
  taskforce_GenProgInfo(Taskforce);
  Taskforce->DirNode.Account	+= 1000;
  flags = Taskforce->DirNode.Flags;
  if (task_entry->UseCount eq 0)
   taskforce_Destroy(Taskforce);
  else
   Signal(&(Taskforce->DirNode.Lock));
  if (flags & TfmFlags_FirstTask)
   while (!Fork(5000, TerminateTFM, 0));
}

static int	monitor_taskforce_aux2(RmTask task, ...)
{ TaskEntry	*task_entry = (TaskEntry *) RmGetTaskPrivate(task);

  return(task_entry->TermCode);
}

/**
*** 7) taskforce_GenProgInfo()
***    This is called when all the components of a taskforce have
***    terminated.
**/
static void	taskforce_GenProgInfo(RmTaskforce Taskforce)
{ TaskEntry	*task_entry = (TaskEntry *) RmGetTaskforcePrivate(Taskforce);
  MCB		m;

  if ((task_entry->ProgInfoMask ne 0) && (task_entry->ProgInfoPort ne NullPort))
   { Debug(dbg_Delete,("generating termination message for taskforce %s",\
   		Taskforce->DirNode.Name));
     InitMCB(&m, MsgHdr_Flags_preserve, task_entry->ProgInfoPort, NullPort,
   		task_entry->TermCode);
     Taskforce->DirNode.Account	+= 100;
     PutMsg(&m);
     Taskforce->DirNode.Account += 100;
   }
}

/**
*** 8) taskforce_Destroy()
***    Destroy a Taskforce. This means destroying every single task in the
***    taskforce, including any pipes that may have been set up. This is not
***    allowed if the taskforce is still running. First the taskforce is
***    removed from the /bart/tfm directory so that nothing else can access
***    it. Then the various resources owned by this taskforce are freed,
***    most of them by walking down the taskforce.
**/

static int	taskforce_DestroyAux(RmTask task, ...);
static int	taskforce_DestroyAux2(RmTask task, ...);
		
static void	taskforce_Destroy(RmTaskforce Taskforce)
{ TaskEntry	*task_entry = (TaskEntry *) RmGetTaskforcePrivate(Taskforce);

  if (task_entry eq Null(TaskEntry)) return;
  
  if ((task_entry->Running) || (task_entry->UseCount > 0)) return;

  Debug(dbg_Delete, ("destroying taskforce %s", Taskforce->DirNode.Name));
  Unlink((ObjNode *) &(Taskforce->DirNode), FALSE);
  Taskforce->DirNode.Parent = Null(DirNode);

  (void) RmApplyTasks(Taskforce, &taskforce_DestroyAux);
  if (task_entry->Mapped) domain_UnmapTaskforce(Taskforce);
  (void) RmApplyTasks(Taskforce, &taskforce_DestroyAux2);

  if (task_entry->ProgInfoPort ne NullPort) FreePort(task_entry->ProgInfoPort);
  if (task_entry->TaskVec ne Null(RmTask)) Free(task_entry->TaskVec);
  Free(task_entry);

  Debug(dbg_Delete, ("freeing taskforce %s", Taskforce->DirNode.Name));
  RmFreeTaskforce(Taskforce);
  Debug(dbg_Delete, ("taskforce freed"));
}

static int	taskforce_DestroyAux(RmTask task, ...)
{ TaskEntry	*task_entry;
  int		i;
  
  task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  if (task_entry eq Null(TaskEntry)) return(RmE_Success);
  for (i = 0; task_entry->Streams[i] ne Null(Stream); i++)
   { Stream	*stream = task_entry->Streams[i];
     if (stream eq (Stream *) MinInt) continue;
     
     if (stream->Type ne Type_Pipe)	/* file redirection */
      Close(stream);
     else
      { Object	*o = NewObject(stream->Name, &(stream->Access));
        Close(stream);
        if (o ne Null(Object))
         { (void) Delete(o, Null(char)); Close(o); }
      }
   }
  if (task_entry->ProgramStream ne Null(Stream))
   Close(task_entry->ProgramStream);
  if (task_entry->ProgramObject ne Null(Object))
  { exterminate_task(task);
    Close(task_entry->ProgramObject);
  }
  if (task_entry->LoadedCode ne Null(Object))
   Close(task_entry->LoadedCode);
  if (task_entry->Program ne Null(Object))
   if ((task->ObjNode.Flags & TfmFlags_LoaderCopy) eq 0)
    Close(task_entry->Program);
  return(RmE_Success);
}

static int	taskforce_DestroyAux2(RmTask task, ...)
{ TaskEntry	*task_entry;
  
  task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  if (task_entry eq Null(TaskEntry)) return(RmE_Success);
  RmSetTaskPrivate(task, 0);
  Free(task_entry);
  return(RmE_Success);
}

/**
*** 9) taskforce_DoSignal()
***    A signal sent to a taskforce is simply propagated to all its components.
**/

static int	taskforce_DoSignalAux(RmTask task, ...);

static void	taskforce_DoSignal(RmTaskforce Taskforce, word Signal)
{ Debug(dbg_Signal, ("sending signal %d to taskforce %s", Signal, \
		Taskforce->DirNode.Name));
  (void) RmApplyTasks(Taskforce, &taskforce_DoSignalAux, Signal);
}

static int	taskforce_DoSignalAux(RmTask task, ...)
{ va_list	args;
  WORD		signal;
  TaskEntry	*task_entry;
   
  va_start(args, task);
  signal = va_arg(args, WORD);
  va_end(args);
  task_entry = (TaskEntry *) RmGetTaskPrivate(task);
  if (task_entry->Running)
   task_DoSignal(task, signal);

  return(0);
}

/**
*** 10) taskforce_HandleEnv()
***     This takes care of an environment sent to a taskforce. The environment
***     has to be accepted, propagated with suitable modifications to all
***     the components, and then freed.
**/

static int	taskforce_ParallelEnv(RmTaskforce, TaskEntry *, Environ *);
static int	taskforce_HandleEnvAux(RmTask task, ...);

static word	taskforce_HandleEnv(RmTaskforce Taskforce, Port port, MCB *m)
{ Environ	received;
  int		rc;
  int		length;
  char		*buffer;
  Capability	cap;
  TaskEntry	*task_entry;
  Port		reply;
          
  if ((reply = tfm_GetEnv(port, m, &received)) eq NullPort)
   return(EC_Error + EG_NoMemory + EO_Message);

	/* Send back an initial message to the parent, requesting	*/
	/* a long timeout.						*/
  InitMCB(m, MsgHdr_Flags_preserve, reply, NullPort,
  		EC_Recover + EG_NewTimeout + 300);
  PutMsg(m);
  
	/* The Taskforce Manager must zap one entry in the object	*/
	/* vector, that for the taskforce itself. This must be done	*/
	/* without actually accessing the taskforce because that would	*/
	/* deadlock. The name should be : /Cluster/00/bart/tfm/job.6	*/
  length = strlen(ProcessorName) + strlen(Root.Name) +
  	strlen(Taskforce->DirNode.Name) + 7;
  buffer = (char *) Malloc(length);
  if (buffer eq Null(char)) { rc = RmE_ServerMemory; goto done; }
  strcpy( buffer, ProcessorName);
  pathcat(buffer, Root.Name);
  strcat( buffer, "/tfm/");
  strcat( buffer, Taskforce->DirNode.Name);
  NewCap(&cap, (ObjNode *) &Root, AccMask_Full);
  if ((received.Objv[OV_TForce] ne Null(Object)) &&
      (received.Objv[OV_TForce] ne (Object *) MinInt))
   Close(received.Objv[OV_TForce]);
   
  received.Objv[OV_TForce] = NewObject(buffer, &cap);
  Free(buffer);
  if (received.Objv[OV_TForce] eq Null(Object))
   { rc = RmE_ServerMemory; goto done; }  

  Debug(dbg_Environ, ("sending environment to taskforce %s",\
  		Taskforce->DirNode.Name));
  task_entry = (TaskEntry *) RmGetTaskforcePrivate(Taskforce);
  if (task_entry->NumberTasks >= 32)
   rc = taskforce_ParallelEnv(Taskforce, task_entry, &received);
  else
   rc = RmSearchTasks(Taskforce, &taskforce_HandleEnvAux, &received);

done:

  Debug(dbg_Environ, ("releasing taskforce's environment"));
  
  { Stream	**streams, **streams2;
    for (streams = received.Strv; *streams ne Null(Stream); streams++)
     if (*streams ne (Stream *) MinInt)
      { Close(*streams);
		/* With the new environment, the same stream object may */
		/* be present more than once. It should be closed once	*/
		/* only.						*/
        for (streams2 = &(streams[1]); *streams2 ne Null(Stream); streams2++)
         if (*streams2 eq *streams)
          *streams2 = (Stream *) MinInt;
        *streams = (Stream *) MinInt;          
      }
  }
  { Object	**objects;
    for (objects = received.Objv; *objects ne Null(Object); objects++)
     if (*objects ne (Object *) MinInt)
      { Close(*objects); *objects = (Object *) MinInt; }
  }
  Free(received.Argv);	/* Environment info starts here */
  
 	/* Acknowledge the environment back to the parent */
  InitMCB(m, 0, reply, NullPort, (rc eq RmE_Success) ? Err_Null :
  		EC_Error + EG_NoMemory + EO_Message);
  PutMsg(m);
  if (rc ne RmE_Success)
   return(EC_Error + EG_NoMemory + EO_Message);
  else
   return(Err_Null);
}

static int	taskforce_HandleEnvAux(RmTask task, ...)
{ va_list	args;
  Environ	*received;
  TaskEntry	*task_entry;
  Object	*Objv[OV_End + 1];
  Environ	sending;
  Stream	*program_stream;
  char		**Argv = Null(char *);
  char		*default_Argv[4];
  int		rc;
    
  va_start(args, task);
  received = va_arg(args, Environ *);
  va_end(args);
  
  task_entry		= (TaskEntry *) RmGetTaskPrivate(task);
  sending.Strv		= task_entry->Streams;
  { int		i;

  	/* standard streams that have not been overloaded are	*/
  	/* inherited anyway, e.g. stderr			*/
    for (i = 0; (task_entry->Streams[i] ne Null(Stream)) &&
    		(received->Strv[i] ne Null(Stream));
         i++)
     if (task_entry->Streams[i] eq (Stream *) MinInt)
      task_entry->Streams[i] = received->Strv[i];
  }
  sending.Envv		= received->Envv;
  sending.Objv		= Objv;
  sending.Argv		= default_Argv;
  Objv[OV_Cdir]		= received->Objv[OV_Cdir];
  Objv[OV_Task]		= task_entry->ProgramObject;
  Objv[OV_Code]		= task_entry->LoadedCode;
  Objv[OV_Source]	= task_entry->Program;
  Objv[OV_Parent]	= received->Objv[OV_Parent];
  Objv[OV_Home]		= received->Objv[OV_Home];
  Objv[OV_Console]	= received->Objv[OV_Console];
  Objv[OV_CServer]	= received->Objv[OV_CServer];
  Objv[OV_Session]	= received->Objv[OV_Session];
  Objv[OV_TFM]		= received->Objv[OV_TFM];
  Objv[OV_TForce]	= received->Objv[OV_TForce];
  Objv[OV_End]		= Null(Object);
  { int	number_args = RmCountTaskArguments(task);
    int	i;
    
    if (number_args > 3)
     { Argv = (char **) Malloc((number_args + 1) * sizeof(char *));
       if (Argv eq Null(char *)) { rc = RmE_ServerMemory; goto done; }
       sending.Argv = Argv;       
     }
    for (i = 0; i < number_args; i++)
     { sending.Argv[i] = (char *) RmGetTaskArgument(task, i);
       if (*(sending.Argv[i]) eq '$')
        { int	offset = 0;
          char	*ptr   = &((sending.Argv[i])[1]);
          int	j;
          bool  got_null = FALSE;

          for ( ; ('0' <= *ptr) && (*ptr <= '9'); ptr++)
           offset = (10 * offset) + (*ptr - '0');          
          for (j = 0; j <= offset; j++)
           if (received->Argv[j] eq Null(char))
            { got_null = TRUE; break; }
          if (got_null)
           sending.Argv[i] = "";
          else
           sending.Argv[i] = received->Argv[offset];
        }
     }
    sending.Argv[i] = Null(char); 
  }

  if (DebugOptions & dbg_Environ)
   { int	i;
     report("sending environment to component %s", task->ObjNode.Name);
     for (i = 0; sending.Argv[i] ne Null(char); i++)
      report("argument %d is %s", i, sending.Argv[i]);
     for (i = 0; sending.Envv[i] ne Null(char); i++)
      report("environment string %d is %s", i, sending.Envv[i]);
     for (i = 0; sending.Strv[i] ne Null(Stream); i++)
      if (sending.Strv[i] ne (Stream *) MinInt)
       report("stream %d is %s", i, sending.Strv[i]->Name);
     for (i = 0; sending.Objv[i] ne Null(Object); i++)
      if (sending.Objv[i] ne (Object *) MinInt)
       report("object %d is %s", i, sending.Objv[i]->Name);
   }
      
  program_stream = task_entry->ProgramStream;
  rc = SendEnv(program_stream->Server, &sending);

  Debug(dbg_Environ, ("sent environment to component %s", task->ObjNode.Name));

done:
  { Stream	**streams;
    for (streams = sending.Strv; *streams ne Null(Stream); streams++)
     if (*streams ne (Stream *) MinInt)
      { if ((*streams)->Flags & TfmFlags_InternalStream)
         (void) Close(*streams); 
        *streams = (Stream *) MinInt; 
      }
  }
  if (Argv ne Null(char *)) Free(Argv);
  return(rc);
}

/**
*** Doing the same in parallel
**/
static void taskforce_ParallelEnvAux(RmTask *, int count, Semaphore *, int *,
			Environ *);
			
static int taskforce_ParallelEnv(RmTaskforce Taskforce, TaskEntry *task_entry,
		Environ *env)
{ int		number_tasks = task_entry->NumberTasks;
  int		number_processes;
  int		i;
  int		result = 0;
  Semaphore	Done;

  InitSemaphore(&Done, 0);
  number_processes = (number_tasks + 15) / 16;
  for (i = 0; i < number_processes; i++)
   { RmTask	*vec = &(task_entry->TaskVec[16 * i]);
     int	count = number_tasks - (i * 16);
     if (count > 16) count = 16;
     
     if (!Fork(1000, &taskforce_ParallelEnvAux, 20, vec, count, &Done, &result,
     			env))
      { int	j;
      			/* wait for the existing processes to finish/abort */
        for (j = 0; j < i; j++) Wait(&Done);
        return(EC_Error + EG_NoMemory + EO_Taskforce);
      }
   }

  for (i = 0; i < number_processes; i++)
   Wait(&Done);

  Taskforce = Taskforce;
      
  return(result);              			
}		

static void taskforce_ParallelEnvAux(RmTask *TaskVec, int count,
	Semaphore *Done, int *result, Environ *env)
{ int 	i;	
  int	rc = Err_Null;
  
  for (i = 0; i < count; i++)
   { rc = taskforce_HandleEnvAux(TaskVec[i], env);
     if (rc ne Err_Null) break;
   }
   
  if (rc ne Err_Null) *result = rc;
  Signal(Done);
@


1.22
log
@Major update of networking sources, to match Helios1_2_2_native_beta
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/tfm.c,v 1.3 1991/08/22 16:39:52 bart Exp $";
d19 1
a19 1
static char *VersionNumber = "3.21";
d37 2
d618 1
a618 1
   
d715 1
d720 1
a720 1
  
d736 1
a736 1
  
d743 1
a743 3
  
  { Stream	*s = Open(o, Null(char), O_ReadOnly);
    ImageHdr	Hdr;
d745 2
a746 1
      
d752 1
a752 1
     { Close(s); ErrorMsg(m, EC_Error + EG_WrongSize + EO_Program); goto done; }
d755 1
a755 1
     { Close(s); ErrorMsg(m, EC_Error + EG_WrongSize + EO_Program); goto done; }
a764 1
         Close(s);
d771 1
d781 1
d1676 1
a1676 1
   { Debug(dbg_Create, ("error reading file %s", CDLBinary));
d2440 1
a2440 1
  if (flags * TfmFlags_FirstTask)
@


1.21
log
@If asked to execute a shell script the TFM failed to close the shell
script after determining that it could not execute it. Also updated
version number.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.20 1991/09/11 11:38:39 bart Exp bart $";
d19 1
a19 1
static char *VersionNumber = "3.12";
d34 3
a36 2
***           3.12, minor bug fixes 30.10.91, absolute component names and
***                 shell scripts
d150 1
d168 1
a168 1
  
a190 1
							/* rwdav:rx:ry:rz */
d192 1
a192 1
  InitList(&(Root.Entries));				/* rwdav:rx:ry:rz */
d231 3
a233 3
  
 	/* Start a process which will terminate the TFM if the current	*/
 	/* window disappears.						*/
d254 1
a254 1
   { Domain = RmGetNetworkHierarchy(&rc);
d256 1
a256 1
     switch(rc)
d262 2
d267 2
a268 1
          report("unexpected resource management library problem %x", rc);
d277 1
a277 1
  strcpy(NetworkName, RmGetNetworkID(Domain));
d284 2
a285 1
    "failed to get processor details from Session Manager, RmLib error %x", rc);
d299 12
d351 3
a353 3
           { case	 800 : 
             case	 805 :
             case	 801 : TfmProcessor->Type = RmT_T800; break;
d366 1
a366 1
  if (RmAddTailProcessor(Domain, TfmProcessor) eq (RmProcessor) NULL)
d374 1
a374 1

d398 1
a398 1
   
d421 1
a421 1
#ifndef SingleProcessor  
d616 1
a616 1

a712 1
  Stream	*s		= Null(Stream);
d741 2
a742 1
  { ImageHdr	Hdr;
d744 1
a744 2

    s = Open(o, Null(char), O_ReadOnly);  
d750 1
a750 1
     { ErrorMsg(m, EC_Error + EG_WrongSize + EO_Program); goto done; }
d753 1
a753 1
     { ErrorMsg(m, EC_Error + EG_WrongSize + EO_Program); goto done; }
d763 1
a769 1
	  s = Null(Stream);	/* closed automatically */
a779 1
  if (s ne Null(Stream)) Close(s);
d957 1
a957 1
		
d1006 2
a1008 2
  if (task_entry eq Null(TaskEntry)) return;

d1044 1
a1044 1
   { word flags= task->ObjNode.Flags;
d1300 1
a1300 1
  if ((RmSetTaskID(task, (RmID) objname(program->Name)) ne RmE_Success) ||
d1302 1
a1302 1
      (RmSetTaskMemory(task, 3 * progsize) ne RmE_Success))
d1605 1
a1605 1
  if (program_stream eq Null(Stream))
d1607 1
a1607 1
		
d1634 1
a1634 1
  PutMsg(m); 	
d1673 1
a1673 1
   { Debug(dbg_Create, ("error reading file"));
d1696 1
a1696 1
  rc = RmSearchTaskforce(Taskforce, &taskforce_add_TaskEntry, 
d1699 1
a1699 1
  if (rc eq RmE_NoMemory)
a1789 1
     
d1808 1
a1808 1
      		   goto  done;
d1884 1
a1884 1
      (void) RmApplyTaskforce(Taskforce, &do_delete_taskforce_aux);
d1890 1
a1890 2
{ if (RmIsTaskforce(task))
   return(RmApplyTaskforce((RmTaskforce) task, &do_delete_taskforce_aux));
a1916 4
  if (RmIsTaskforce(task))
   return(RmSearchTaskforce((RmTaskforce) task, &taskforce_add_TaskEntry,
   		 sem, TaskVec, counter));

d1926 1
a1926 1
  if (task_entry eq Null(TaskEntry)) return(RmE_NoMemory);
d1940 1
a1940 1
   RmSearchTaskforce(RmRootTaskforce(task), &taskforce_FindProgram, code_name);
a1983 4
  if (RmIsTaskforce(task))
   return(RmSearchTaskforce((RmTaskforce) task,
   		&taskforce_FindProgram, program_name));
  
d2025 1
a2025 1
  result = RmSearchTaskforce(Taskforce, &taskforce_StartAux1);
d2031 1
a2031 1
  result = RmSearchTaskforce(Taskforce, &taskforce_StartAux2);
d2034 1
a2034 1
   (void) RmApplyTaskforce(Taskforce, &taskforce_StartAux3);
a2121 3
  if (RmIsTaskforce(task))
   return(RmSearchTaskforce((RmTaskforce) task, &taskforce_StartAux1));
       
a2166 3
  if (RmIsTaskforce(Task))
   return(RmApplyTaskforce((RmTaskforce) Task, &taskforce_StartAux3));

a2220 3
  if (RmIsTaskforce(task))
   return(RmSearchTaskforce((RmTaskforce) task, &taskforce_StartAux2));

a2296 1

d2373 1
a2373 1
     if (mode & RmO_Append) (void) Seek(result, S_End, 0);
d2396 1
a2396 1
     if (mode & RmO_Append) (void) Seek(result, S_End, 0);
d2417 1
a2417 1
  
a2419 1

d2428 1
a2428 1
  task_entry->TermCode		 = RmApplyTaskforce(Taskforce, 
d2437 1
a2437 1
  if (flags & TfmFlags_FirstTask)
d2444 1
a2444 4
  if (RmIsTaskforce(task))
   return(RmApplyTaskforce((RmTaskforce) task, &monitor_taskforce_aux2));
  else
   return(task_entry->TermCode);
d2491 1
a2491 1
  (void) RmApplyTaskforce(Taskforce, &taskforce_DestroyAux);
d2493 2
a2494 2
  (void) RmApplyTaskforce(Taskforce, &taskforce_DestroyAux2);
  
a2507 3
  if (RmIsTaskforce(task))
   return(RmApplyTaskforce((RmTaskforce) task, &taskforce_DestroyAux));

a2539 3
  if (RmIsTaskforce(task))
   return(RmApplyTaskforce((RmTaskforce) task, &taskforce_DestroyAux));

d2557 1
a2557 1
  (void) RmApplyTaskforce(Taskforce, &taskforce_DoSignalAux, Signal);
d2568 4
a2571 7
  if (RmIsTaskforce(task))
   return(RmApplyTaskforce((RmTaskforce) task, &taskforce_DoSignalAux, signal));
  else
   { task_entry = (TaskEntry *) RmGetTaskPrivate(task);
     if (task_entry->Running)
      task_DoSignal(task, signal);
   }
d2593 1
a2593 1
        
d2610 1
a2610 1
  if (buffer eq Null(char)) { rc = RmE_NoMemory; goto done; }
d2623 1
a2623 1
   { rc = RmE_NoMemory; goto done; }  
d2631 1
a2631 1
   rc = RmSearchTaskforce(Taskforce, &taskforce_HandleEnvAux, &received);
a2660 1

a2681 3
  if (RmIsTaskforce(task))
   return(RmSearchTaskforce((RmTaskforce) task, &taskforce_HandleEnvAux, received));
  
d2714 1
a2714 1
       if (Argv eq Null(char *)) { rc = RmE_NoMemory; goto done; }
d2757 2
d2804 3
a2806 1
    
@


1.20
log
@If the CDL binary contained an invalid taskforce then the TFM could
produce a silly diagnostics message. It attempted to print out the
name of the stream to the binary file. Unfortunately, not only did
it pass the stream itself instead of the Name sub-field, but also
this stream had been closed by the time the diagnostics message was
produced.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.19 1991/06/06 13:46:50 bart Exp bart $";
d19 1
a19 1
static char *VersionNumber = "3.11";
d34 2
d696 1
d725 1
a725 2
  { Stream	*s = Open(o, Null(char), O_ReadOnly);
    ImageHdr	Hdr;
d727 2
a728 1
      
d734 1
a734 1
     { Close(s); ErrorMsg(m, EC_Error + EG_WrongSize + EO_Program); goto done; }
d737 1
a737 1
     { Close(s); ErrorMsg(m, EC_Error + EG_WrongSize + EO_Program); goto done; }
a746 1
         Close(s);
d753 1
d764 1
@


1.19
log
@Changed taskforce_HandleEnv() so that it informs the parent program that
there may be a considerable delay before the environment has
been passed on to all the components. The 20 second timeout built in to
the system library/kernel is insufficient for large machines.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.18 1991/06/03 13:51:23 bart Exp $";
d1654 1
a1654 1
   { Debug(dbg_Create, ("error reading file %s", CDLBinary));
@


1.18
log
@Fixed memory corruption problem during taskforce clean-up, plus
various tidy-ups.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.17 1991/05/18 12:09:03 bart Exp $";
d19 1
a19 1
static char *VersionNumber = "3.10";
d33 1
d1771 1
d2611 6
d2675 1
@


1.17
log
@Improved the error handling when manipulating task and taskforce
environments. Incremented the version number.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/tfm.c,v 1.16 1991/04/08 15:45:27 paul Exp $";
d162 3
a164 1
  { static char *message =
d186 1
d188 1
a188 1
  InitList(&(Root.Entries));
d208 1
a208 1
	/* Create a name-table entry and dispatch the server */
d224 2
d227 3
d331 3
a333 1
           { case	 800 : TfmProcessor->Type = RmT_T800; break;
a592 1
  DirNode	*d;
a596 4
  d = GetTargetDir(servinfo);
  if (d eq Null(DirNode))
   { ErrorMsg(m, Err_Null); return; }
   
d598 1
a598 1
  f = GetTargetObj(servinfo);
d613 1
a613 1
	*** 1) any directory, including root, domain, and tfm, networks, and
d986 1
a986 1
 
d988 1
a988 1
   
d1024 2
a1025 1
   { task_GenProgInfo(task);
d1031 1
a1031 1
     if (task->ObjNode.Flags & TfmFlags_FirstTask)
d2415 2
a2416 1

d2419 1
d2432 1
d2437 1
a2437 1
  if (Taskforce->DirNode.Flags * TfmFlags_FirstTask)
d2481 1
a2494 1

d2496 2
d2504 1
d2540 12
@


1.16
log
@simple fix of wrongly defined error code
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/sparkygiga/HeliosRoot/Helios/network/RCS/tfm.c,v 1.15 1991/04/07 13:20:21 bart Exp paul $";
d19 1
a19 1
static char *VersionNumber = "3.09";
d22 1
a22 1
*** 	      3.00, initial version
d32 1
d76 1
a76 1
static void		task_HandleEnv(RmTask, Port, MCB *);
d87 1
a87 1
static void		taskforce_HandleEnv(RmTaskforce, Port, MCB *);
a1060 2
BLV recover from insufficient memory when calling NewObject() and
BLV PseudoStream.
d1066 1
d1071 7
a1077 1

d1082 1
a1082 1
	control = (word *)Malloc(envsize[0]*sizeof(word) + envsize[1]);
d1091 1
a1091 1

d1139 2
d1163 2
d1190 19
d1367 4
a1370 1
      		task_HandleEnv(task, reqport, m);
d1531 1
a1531 1
static void task_HandleEnv(RmTask task, Port port, MCB *m)
d1538 4
a1542 2
  if ((reply = tfm_GetEnv(port, m, &received)) eq NullPort) return;

a1555 1
	/* BLV this needs PseudoObject in GetEnv() */
d1579 2
a1580 1
  if (program_stream eq Null(Stream)) goto done;
d1582 1
a1582 2
	/* BLV - recover properly */
  (void) SendEnv(program_stream->Server, &sending);
d1607 1
a1607 1
  InitMCB(m, 0, reply, NullPort, Err_Null);
d1609 1
d1780 4
a1783 1
      		taskforce_HandleEnv(Taskforce, reqport, m);
d2573 1
a2573 1
static void	taskforce_HandleEnv(RmTaskforce Taskforce, Port port, MCB *m)
d2582 2
a2583 1
  if ((reply = tfm_GetEnv(port, m, &received)) eq NullPort) return;
a2615 2
  if (rc ne RmE_Success)
   taskforce_DoSignal(Taskforce, SIGKILL);	/* KILL */
d2640 2
a2641 1
  InitMCB(m, 0, reply, NullPort, Err_Null);
d2643 4
@


1.15
log
@Added support for Tiny Helios. Various bits of the networking software can
now be compiled with options such as -DSingleProcessor, to produce reduced
versions of Helios.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /giga/HeliosRoot/Helios/network/RCS/tfm.c,v 1.14 91/03/15 14:43:58 bart Exp $";
d724 1
a724 1
     { Close(s); ErrorMsg(m, EC_Error + EG_WrongSize * EO_Program); goto done; }
@


1.14
log
@Improved the environment handling. Environment acknowledgements back to the
parent are now sent only when the child has actually received the
environment, instead of when the tfm has received it. This used to cause
problems with pipes, for example popen() did not work if CDL was set.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /giga/HeliosRoot/Helios/network/RCS/tfm.c,v 1.13 91/03/12 14:04:27 bart Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.07";
d30 2
d49 1
a55 5
#if 0
#pragma	-s1
#pragma -g0
#endif

d65 1
d98 1
d100 3
d144 1
a144 3
{ int	rc;
  int	i;

d150 4
d179 4
d189 4
a192 19
  for (i = 0; i < 5; i++)
  { Domain = RmGetNetworkHierarchy(&rc);
    if (Domain ne (RmNetwork) NULL) break;
    switch(rc)
     { case	RmE_CommsBreakdown :
     	report("communications problems when interacting with network server");
     	break;
       case	RmE_NoMemory :
       	report("memory shortage problems"); break;
       case	RmE_BadArgument :
       	report("problem contacting network server"); break;
       default			:
        report("unexpected resource management library problem %x", rc);
     }
    report("retrying");
    Delay(OneSec);
  }
  if (Domain eq (RmNetwork) NULL)
   fatal("failed to initialise network hierarchy");
d194 1
a194 17
  rc = RmReadProcessor(fdstream(0), &TfmProcessor, FALSE);
  if (rc ne RmE_Success)
    fatal(
    "failed to get processor details from Session Manager, RmLib error %x", rc);
  else
   { DomainEntry *domain_entry;
   
     TfmProcessor->ObjNode.Key		= NewKey() + _cputime();
     TfmProcessor->AllocationFlags	= RmF_TfmProcessor | RmF_Permanent;
     RmStartSearchHere			= TfmProcessor->Uid;
     unless(AddDomainEntry(TfmProcessor))
      fatal("out of memory when initialising tfm's own processor");
     domain_entry = (DomainEntry *) RmGetProcessorPrivate(TfmProcessor);
     domain_entry->NumberUsers = 1;
     if (RmInsertProcessor(Domain, TfmProcessor) eq (RmProcessor) NULL)
      fatal("failed to insert tfm processor into domain");
   }
d204 1
a204 8
  strcpy(NetworkName, RmGetNetworkID(Domain));
  strcpy(Domain->DirNode.Name, "domain");
  Insert(&Root,  (ObjNode *) &(Domain->DirNode), FALSE);

  ThisProcessor = Locate(Null(Object), ProcessorName);
  if (ThisProcessor eq Null(Object))
   fatal("failed to locate own processor");
   
d228 116
d373 2
a374 1
   { if (node->Type eq Type_Taskforce)
d390 1
d392 1
d499 2
a1040 1
  int		i;
a1047 10
#if 0
  for (i = 0; i < 3; i++)
   { 
     temp = Locate(program, Null(char));
     if (temp eq Null(Object)) break;
     temp->Access = program->Access;
     (void) Delete(temp, Null(char));
     Close(temp);
   } 
#else
a1053 1
#endif
d1084 1
a1084 1
	reply = NullPort;
d2323 1
a2323 1
      { Debug(dbg_Create, ("failed to open file %s in directory %s, fault 0x%08x",\
@


1.13
log
@Changed the environment handling to cope with more than 256 entries,
as per the latest nucleus.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /giga/HeliosRoot/Helios/network/RCS/tfm.c,v 1.12 90/12/17 14:32:07 bart Exp Locker: bart $";
d77 1
a77 1
static bool		tfm_GetEnv(Port reqport, MCB *m, Environ *env);
d983 1
a983 1
static word tfm_GetEnv(Port port, MCB *m, Environ *env)
d1004 1
a1083 5
	/* now reply to the sender */

	InitMCB(m,0,reply,NullPort,e);
	PutMsg(m);
	
d1100 1
a1100 1
	return e;
d1425 1
d1427 1
a1427 1
  if (tfm_GetEnv(port, m, &received) ne Err_Null) return;
d1492 4
d2463 1
d2465 1
a2465 1
  if (tfm_GetEnv(port, m, &received) ne Err_Null) return;
d2522 4
@


1.12
log
@NHG has changed the nucleus to make it easier for me to exterminate
programs. This version of the TFM exploits the new facility.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/tfm.c,v 1.11 90/12/02 13:56:30 bart Exp $";
d29 1
a29 1
***           3.07, first post 1.2 version
d990 1
d992 2
d995 1
a995 1

d1000 3
a1002 1
	
d1013 5
a1017 1
	m->Data = data	= (byte *)(control + envsize[0]);
d1087 16
d1664 1
@


1.11
log
@just updating the version numbers
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/tfm.c,v 1.10 90/12/01 15:39:12 bart Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.06";
d29 1
d820 1
a820 1
   
d829 1
a829 1
   
d912 6
d957 1
d959 2
a960 1
   { temp = Locate(program, Null(char));
d962 1
d966 8
d2015 3
a2017 1
   { Close(task_entry->ProgramStream); 
@


1.10
log
@improved the handling of the various abort conditions, to cope with external
networks. Also, the tfm now checks regularly that its diagnostics stream
still exists and aborts if not.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/tfm.c,v 1.3 90/09/14 12:57:24 bart Exp $";
d19 1
a19 1
static char *VersionNumber = "3.05";
d28 1
@


1.9
log
@updated the version number printed during startup
@
text
@d86 1
d148 2
a149 1
    
d248 2
a249 1
    
d251 1
d269 1
a269 1
    
d275 1
a275 1
   { Signal(&(TFM.Lock)); return; }
a300 1
  
d343 18
d902 3
a904 2
   { task_entry->TermCode = 
       GetProgramInfo(task_entry->ProgramStream, Null(WORD), MonitorDelay);
@


1.8
log
@sources update after visit to Parsytec 22.10.90-31.10.90
@
text
@d19 1
a19 1
static char *VersionNumber = "3.04";
d27 1
@


1.7
log
@minor bug fixes in time for Helios 1.2 beta1 release
@
text
@d19 9
a27 1
static char *VersionNumber = "3.03";
d50 1
d53 1
d62 1
d78 7
d243 3
a245 1
  
d254 1
a254 1
*** All outstanding tasks and taskforces are aborted. All processors are
d257 2
d261 33
a293 1
{
d295 2
d300 36
d563 1
a563 1
static void do_create_taskforce(ServInfo *, Stream *, ImageHdr *);
d601 2
a602 1
  
d606 4
d627 1
a627 1
	  do_create_taskforce(servinfo, s, &Hdr);
d743 2
a744 1

d764 3
d781 1
a781 1
  if (loader eq Null(Object))
d845 1
a888 1
  	
d998 1
a998 1
		{
d1020 2
d1024 2
d1060 1
a1060 1
static void do_create_task(ServInfo *servinfo, Object *program,
d1070 3
d1074 2
a1075 2
  Debug(dbg_Create, ("creating task"));
          
d1077 1
d1079 4
a1082 1
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Message); goto done; }
d1086 4
a1089 1
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Task); goto done; }
d1093 5
a1097 1
   { ErrorMsg(m, EC_Error + EG_Invalid + EO_Taskforce); goto done; }
d1100 2
a1101 1

d1178 1
a1178 1
    
d1210 1
a1210 4
		  if (task_entry->ProgInfoPort != NullPort)
		   { ErrorMsg(m, EC_Error + EG_InUse + EO_Task);
		     break;
		   }
d1308 1
a1308 1
    
d1362 1
a1362 1
      
d1409 1
a1409 1
  { Stream **streams;
d1412 9
a1420 1
      Close(*streams);
a1437 8
static int	taskforce_add_TaskEntry(RmTask, ...);
static word	taskforce_Start(RmTaskforce);
static void	monitor_taskforce(RmTaskforce);
static void	taskforce_GenProgInfo(RmTaskforce);
static void	taskforce_Destroy(RmTaskforce);
static void	taskforce_DoSignal(RmTaskforce, word);
static void	taskforce_HandleEnv(RmTaskforce, Port, MCB *);

d1442 1
a1442 1
static void do_create_taskforce(ServInfo *servinfo, Stream *CDLBinary, ImageHdr *hdr)
d1451 2
a1452 1

d1463 1
a1463 1
  Taskforce = RmReadCDL(CDLBinary, hdr);
d1482 6
a1487 1
  
d1489 1
a1489 1
  			&(task_entry->AllFinished));
d1513 1
a1513 1
     	 RmGetTaskforceID(Taskforce)));
d1519 1
a1519 1
     	RmGetTaskforceID(Taskforce)));
d1534 1
a1534 1
     		RmGetTaskforceID(Taskforce)));
d1568 1
a1568 1
  		RmGetTaskforceID(Taskforce)));
d1613 1
a1613 4
		  if (task_entry->ProgInfoPort != NullPort)
		   { ErrorMsg(m, EC_Error + EG_InUse + EO_Task);
		     break;
		   }
d1666 1
a1666 1
  	RmGetTaskforceID(Taskforce), task_entry->KillState));
d1689 2
d1696 3
d1701 3
a1703 1
  sem = va_arg(args, Semaphore *);
d1707 2
a1708 1
   return(RmSearchTaskforce((RmTaskforce) task, &taskforce_add_TaskEntry, sem));
d1710 4
d1723 4
a1726 3
   
  task_entry->Program =	Locate(Null(Object), (char *) RmGetTaskCode(task));
  if (task_entry->Program eq Null(Object))
d1728 20
d1765 23
d1798 5
d1808 12
d1835 46
d1882 25
d1908 2
d1916 2
d1921 1
a1921 1

d1924 25
a1948 1
  rc = tfm_run_task(processor, task, task_entry->Program);
d1958 1
d1982 1
a1982 3
   { Close(task_entry->LoadedCode);
     task_entry->LoadedCode = Null(Object);
   }
a1989 1
IOdebug("DeletePipe returned %x", Delete(pipe, Null(char)));
d2004 3
a2006 2
*** 3) if it is a pipe, check the other end. If the pipe already exists
***    on the other end duplicate the stream. Otherwise create the pipe.
d2020 2
a2021 1
        
d2029 3
d2058 2
a2059 1
     if (destlink eq RmM_AnyChannel) return(EC_Error + EG_Invalid + EO_Pipe);
d2061 5
a2065 2
	/* Check whether the required pipe has already been created.	*/
	/* If it has, duplicate the stream. Otherwise create the pipe.	*/
d2067 1
a2067 21
  
     if (its_task_entry->Streams[destlink] ne (Stream *) MinInt)
      { Object	*pipe		= (Object *) its_task_entry->Streams[destlink];
        Stream	*its_stream	= PseudoStream(pipe, O_ReadWrite);
        Stream	*my_stream	= PseudoStream(pipe, O_ReadWrite);
        Debug(dbg_Create, ("channel %d is pipe %s", i, pipe->Name));
        if ((its_stream eq Null(Stream)) || (my_stream eq Null(Stream)))
         { if (its_stream ne Null(Stream)) Close(its_stream);
           if (my_stream  ne Null(Stream)) Close(my_stream);
           Delete(pipe, Null(char));
           Debug(dbg_Create, ("failed to open both sides of %s", pipe->Name));
           Close(pipe);
           return(EC_Error + EG_NoMemory + EO_Pipe);
         }
        Close(pipe);
        its_task_entry->Streams[destlink] = its_stream;
        task_entry->Streams[i] = my_stream;
        its_stream->Flags	|= TfmFlags_InternalStream;
        my_stream->Flags	|= TfmFlags_InternalStream;
      }
     else
d2070 4
a2073 4
	/* For now this only stores the object, and there are two calls	*/
	/* to PseudoStream when the other side is reached.		*/
      { Object	*pipe;
	char	buffer[NameMax * 2];
d2078 1
a2078 1
	
d2081 2
a2082 1
	 { Debug(dbg_Create, ("failed to create pipe"));
d2087 22
a2108 1
	task_entry->Streams[i] = (Stream *) pipe;
d2111 1
d2113 1
a2113 1
  
d2116 1
a2215 1
static int	monitor_taskforce_aux(RmTask task, ...);
d2222 2
a2223 2
  count = RmApplyTaskforce(Taskforce, &monitor_taskforce_aux);
  Debug(dbg_Monitor, ("monitoring taskforce %s", RmGetTaskforceID(Taskforce)));
d2227 1
a2227 1
     		RmGetTaskforceID(Taskforce), count));
a2243 7
static int	monitor_taskforce_aux(RmTask task, ...)
{ if (RmIsTaskforce(task))
   return(RmApplyTaskforce((RmTaskforce) task, &monitor_taskforce_aux));
  else
   return(1);
}

d2248 1
a2248 1
   return(RmApplyTaskforce((RmTaskforce) task, &monitor_taskforce_aux));
d2264 1
a2264 1
   		RmGetTaskforceID(Taskforce)));
d2292 1
a2292 1
  Debug(dbg_Delete, ("destroying taskforce %s", RmGetTaskforceID(Taskforce)));
d2295 3
d2300 1
a2301 1
  (void) RmApplyTaskforce(Taskforce, &taskforce_DestroyAux);
d2303 1
a2303 1
  Debug(dbg_Delete, ("freeing taskforce %s", RmGetTaskforceID(Taskforce)));
d2335 5
a2339 2
  if (task_entry->LoadedCode ne Null(Object)) Close(task_entry->LoadedCode);
  if (task_entry->Program ne Null(Object))    Close(task_entry->Program);
d2353 1
a2353 1
		RmGetTaskforceID(Taskforce)));
d2382 1
d2391 2
a2392 1
      
d2400 1
a2400 1
  	strlen(RmGetTaskforceID(Taskforce)) + 7;
d2406 1
a2406 1
  strcat( buffer, RmGetTaskforceID(Taskforce));
d2418 6
a2423 2
  		RmGetTaskforceID(Taskforce)));
  rc = RmSearchTaskforce(Taskforce, &taskforce_HandleEnvAux, &received);
d2429 3
a2431 1
  { Stream	**streams;
d2434 9
a2442 1
      { Close(*streams); *streams = (Stream *) MinInt; }
d2549 4
a2552 2
      if ((*streams)->Flags & TfmFlags_InternalStream)
       { (void) Close(*streams); *streams = (Stream *) MinInt; }
d2558 49
@


1.6
log
@preparing beta1 release before holiday
@
text
@d19 1
a19 1
static char *VersionNumber = "3.02";
d69 1
a69 1
static	char		ProcessorName[128];
@


1.5
log
@Plugged various memory leaks
@
text
@d102 4
a105 1
	  	 { NullFn,		2000 }  /* CloseObj */
d430 5
d647 2
a648 2
  Debug(dbg_Create, ("running task %s (%s) on processor %s", RmGetTaskID(task),\
  	program->Name, RmGetProcessorID(processor) ));
d707 1
a707 1
  	Open(task_entry->ProgramObject, Null(char), O_Execute);
d1003 1
a1003 1
     Debug(dbg_Create, ("attempting mapping for %s", RmGetTaskID(task)));
d1012 1
a1012 1
     Debug(dbg_Create, ("failed to execute task %s", RmGetTaskID(task)));
d1023 1
a1023 1
     Debug(dbg_Create, ("task %s is running", RmGetTaskID(task)));
d1052 1
a1052 1
  Debug(dbg_Create, ("open request for %s", RmGetTaskID(task)));
d1146 2
a1147 2
  Debug(dbg_Delete, ("deleting task %s, kill state %d", RmGetTaskID(task),\
  		task_entry->KillState));
d1170 1
a1170 1
    		RmGetTaskID(task)));
d1190 1
a1190 1
  Debug(dbg_Delete, ("destroying task %s", RmGetTaskID(task)));
d1221 2
a1222 1
  Debug(dbg_Signal, ("sending signal %d to task %s", signal, RmGetTaskID(task)));  
d1224 1
a1224 1
  s = Open(task_entry->ProgramObject, Null(char), O_Execute);
d1271 1
a1271 1
     report("sending environment to task %s", RmGetTaskID(task));
d1284 1
a1284 1
  program_stream = Open(task_entry->ProgramObject, Null(char), O_Execute);
d1624 1
d1630 1
a1630 1
  if (result ne Err_Null) return(result);
d1633 1
a1633 1
   return(EC_Error + EG_NoMemory + EO_Taskforce);
d1635 4
a1638 1
  result = RmSearchTaskforce(Taskforce, &taskforce_StartAux2);   
d1642 4
d1660 1
a1660 1
  		RmGetTaskID(task), RmGetProcessorID(processor)));
d1667 42
d1734 1
a1734 1
  		RmGetTaskID(task)));
d2212 1
a2212 1
     report("sending environment to component %s", RmGetTaskID(task));
d2238 1
@


1.4
log
@now compiles with arm compiler (sizeof(char) problems in va_arg)
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/tfm.c,v 1.3 90/09/14 12:57:24 bart Exp Locker: bart $";
d19 1
a19 1
static char *VersionNumber = "3.00";
d118 4
d375 1
a375 1
    
d414 1
a414 3
     case O_ReadOnly	:
     case O_ReadWrite	:
     case O_Execute	: if ((f->Type eq Type_Network) || 
a428 2
     default		: ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object);
     			  return;
d430 1
a430 1
     			  
d440 1
a440 1
  
d706 1
a706 1

d828 2
a829 4
***    copied from the system library with some modifications. PseudoObject()
***    is used because there is no point in forcing the Taskforce Manager
***    to Locate() every item in the object vector.
BLV recover from insufficient memory when calling PseudoObject() and
d891 1
a891 1
			*control = (word)PseudoObject(o->Name,&o->Cap);
a921 1

d1185 2
d1277 1
a1277 1

d1726 2
a1727 2
        its_stream->Flags	|= (TfmFlags_InternalStream /*| Flags_OpenOnGet*/);
        my_stream->Flags	|= (TfmFlags_InternalStream /*| Flags_OpenOnGet*/);
d1940 1
d2046 5
a2050 1
  received.Objv[OV_TForce] = PseudoObject(buffer, &cap);
a2053 5

#if 1
  Close(received.Objv[OV_TForce]);
  received.Objv[OV_TForce] = (Object *) MinInt;
#endif
@


1.3
log
@replaced a check for Flags_Pipe with a check for Type_Pipe, because NHG has
got rid of the flag.
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/tfm.c,v 1.2 90/09/13 10:58:38 bart Exp Locker: bart $";
d256 1
a256 1
        case    'c' : *dest++ = va_arg(args, char); break;
@


1.2
log
@had to change do_create_taskforce() to cope with fifo's, as used by the
shell and the CDL compiler. This involves having a stream and image
header already read in, rather than reopening the file object
@
text
@d17 1
a17 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/tfm.c,v 1.1 90/09/12 15:11:56 jon Exp Locker: bart $";
d1963 1
a1963 1
     if ((stream->Flags & Flags_Pipe) eq 0)	/* file redirection */
@


1.1
log
@Initial revision
@
text
@d17 1
a17 1
static char *rcsid = "$Header$";
d215 1
a215 1
     fatal("failed to enter name in name table, error code 0x%08x",
d410 7
a416 7
     case O_ReadOnly	: if ((f->Type & Type_Flags) ne Type_Directory)
     			   { ErrorMsg(m, EC_Error + EG_WrongFn + EO_Object);
     			     return;
     			   }
			  break;
			  
     case O_Execute	: if ((f->Type ne Type_Task) &&
a444 9
  if (req->Arg.Mode eq O_Execute)
   { if (f->Type eq Type_Task)
      do_open_task(servinfo, m, reqport);
     else
      do_open_taskforce(servinfo, m, reqport);
     FreePort(reqport);
     return;
   }
   
d447 6
d463 1
a463 1
static void do_create_taskforce(ServInfo *, Object *);
a507 1
    Close(s);
d516 2
d522 1
a530 5
  if (ItsAProgram)
   do_create_task(servinfo, o, ItsAProgram, Ptype);
  else
   do_create_taskforce(servinfo, o);
   
d1317 1
a1317 1
static void do_create_taskforce(ServInfo *servinfo, Object *CDLBinary)
d1337 1
a1337 1
  Taskforce = RmReadCDL(CDLBinary);
@
