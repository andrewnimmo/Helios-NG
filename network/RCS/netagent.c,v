head	1.39;
access;
symbols
	Helios_C40_1_3_Official_Release:1.35
	Alenia_release:1.31
	Helios1_3:1.26
	C40_Field_Test_2:1.25
	C40_Field_Test_R1:1.19
	Helios13_beta:1.19
	Helios1_2_2_Fault:1.16
	Helios1_2_2_Native:1.15
	Helios1_2_2_native_beta:1.15
	Helios1_2_2:1.14
	Helios1_2_2Beta:1.14
	Helios1_2_1:1.12
	Helios1_2:1.8;
locks; strict;
comment	@ * @;


1.39
date	93.08.12.11.56.00;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	93.08.11.10.32.04;	author bart;	state Exp;
branches;
next	1.37;

1.37
date	93.07.02.17.12.47;	author bart;	state Exp;
branches;
next	1.36;

1.36
date	93.06.16.13.37.09;	author bart;	state Exp;
branches;
next	1.35;

1.35
date	93.02.19.18.56.00;	author bart;	state Exp;
branches;
next	1.34;

1.34
date	93.01.26.16.40.56;	author bart;	state Exp;
branches;
next	1.33;

1.33
date	93.01.07.14.10.57;	author bart;	state Exp;
branches;
next	1.32;

1.32
date	92.12.21.16.52.51;	author bart;	state Exp;
branches;
next	1.31;

1.31
date	92.12.09.16.21.28;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	92.12.03.16.49.16;	author paul;	state Exp;
branches;
next	1.29;

1.29
date	92.11.24.17.28.43;	author nick;	state Exp;
branches;
next	1.28;

1.28
date	92.11.23.16.58.39;	author nick;	state Exp;
branches;
next	1.27;

1.27
date	92.11.23.10.17.10;	author paul;	state Exp;
branches;
next	1.26;

1.26
date	92.10.26.11.00.19;	author bart;	state Exp;
branches;
next	1.25;

1.25
date	92.10.07.13.31.18;	author bart;	state Exp;
branches;
next	1.24;

1.24
date	92.09.19.12.03.11;	author bart;	state Exp;
branches;
next	1.23;

1.23
date	92.09.15.18.22.32;	author bart;	state Exp;
branches;
next	1.22;

1.22
date	92.09.01.11.23.06;	author bart;	state Exp;
branches;
next	1.21;

1.21
date	92.08.24.16.50.39;	author bart;	state Exp;
branches;
next	1.20;

1.20
date	92.07.09.17.23.33;	author paul;	state Exp;
branches;
next	1.19;

1.19
date	92.05.08.16.36.25;	author bart;	state Exp;
branches;
next	1.18;

1.18
date	92.03.26.16.28.29;	author bart;	state Exp;
branches;
next	1.17;

1.17
date	92.03.25.18.19.15;	author bart;	state Exp;
branches;
next	1.16;

1.16
date	92.01.15.11.04.39;	author bart;	state Exp;
branches;
next	1.15;

1.15
date	92.01.14.14.20.34;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	91.07.10.13.49.14;	author bart;	state Exp;
branches;
next	1.13;

1.13
date	91.06.03.13.28.40;	author bart;	state Exp;
branches;
next	1.12;

1.12
date	91.03.17.14.46.24;	author bart;	state Exp;
branches;
next	1.11;

1.11
date	91.02.27.16.57.12;	author bart;	state Exp;
branches;
next	1.10;

1.10
date	91.02.27.16.10.27;	author bart;	state Exp;
branches;
next	1.9;

1.9
date	90.12.17.14.28.39;	author bart;	state Exp;
branches;
next	1.8;

1.8
date	90.12.01.15.31.05;	author bart;	state Exp;
branches;
next	1.7;

1.7
date	90.11.25.19.59.18;	author bart;	state Exp;
branches;
next	1.6;

1.6
date	90.11.01.14.50.03;	author bart;	state Exp;
branches;
next	1.5;

1.5
date	90.10.18.13.26.27;	author bart;	state Exp;
branches;
next	1.4;

1.4
date	90.09.20.17.42.29;	author bart;	state Exp;
branches;
next	1.3;

1.3
date	90.09.14.18.05.52;	author bart;	state Exp;
branches;
next	1.2;

1.2
date	90.09.14.12.48.58;	author bart;	state Exp;
branches;
next	1.1;

1.1
date	90.09.12.14.34.41;	author jon;	state Exp;
branches;
next	;


desc
@@


1.39
log
@fixed compile time warnings
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- netagent.c								--
--                                                                      --
--	This program is run by the Network Server on the various	--
--	processors in order to perform various operations, such as	--
--	enabling/disabling links.					--
--                                                                      --
--	Author:  BLV 14/8/90						--
--                                                                      --
------------------------------------------------------------------------*/
/* RcsId: $Header: /hsrc/network/RCS/netagent.c,v 1.38 1993/08/11 10:32:04 bart Exp nickc $*/

/**
*** The netagent can be compiled to work in two different ways, affecting
*** the way in which it communicates with the Network Server. The first
*** option involves a pipe created by the Network Server, supplied in an
*** environment. The second involves the netagent installing itself as
*** as a server and performing low-level message transactions. This
*** compile-time option determines the communication.
**/
#define PIPEIO 0

/*{{{  Header files and administration */

#include <stdio.h>
#include <stddef.h>
#include <syslib.h>
#include <task.h>
#include <codes.h>
#include <nonansi.h>
#include <string.h>
#include <root.h>
#include <module.h>
#include <signal.h>
#include <servlib.h>
#include <process.h>
#include <c40.h>
#include "private.h"
#include "rmlib.h"
#include "netaux.h"

#ifdef __TRAN
#include <asm.h>		/* needed for resetch */
#endif

#ifndef eq
#define eq ==
#define ne !=
#endif

/**
*** Ensure that the C library (plus posix and fplib) are not loaded
**/
static void _stack_error(Proc *p)
{ VoidFnPtr junk;
  junk = &_stack_error;
  IOdebug("Netagent: stack overflow in %s at %x",p->Name,&p);
  Exit(0x0080 | SIGSTAK);
}
/*}}}*/
/*{{{  Prototypes etc. */
/**
*** These routines support the various requests. The Network Server sends
*** NA_Message structures to the netagent which include a function code.
*** The structure and the various function codes are defined in netaux.h
*** There is a separate handler for every function code. Particular
*** processors may be unable to cope with particular function codes.
**/
static void	do_SetLinkMode(NA_Message *);
static void	do_Protect(NA_Message *);
static void	do_Revoke(NA_Message *);
static void	do_Cupdate(NA_Message *);
static void	do_Clean(NA_Message *);
static void	do_ClearNames(NA_Message *);
static void	do_UpdateIO(NA_Message *);
static void	do_GetLinkMode(NA_Message *);
static void	do_Terminate(NA_Message *);
#ifdef __TRAN
static void	do_TransputerBoot(NA_Message *, bool);
static void	do_ParsytecReset(NA_Message *);
static void	Parsytec_Reset(int link);
#endif
#ifdef __C40
static void	do_C40Boot(NA_Message *);
#endif

static char	ProcessorName[IOCDataMax];

#define	MainReadTimeout		(30 * OneSec)
#define ExtraReadTimeout	(10 * OneSec)
#define ReplyTimeout		(60 * OneSec)
/*}}}*/
#if PIPEIO
/*{{{  main() : receive requests from the Network Server via a pipe */
/**
*** Get the environment and the standard streams, which are a pipe from and
*** to the network server. The same pipe is used bi-directionally.
*** Then loop for ever reading request packets and invoke suitable handling
*** routines.
**/
static Stream	*Stdin;
static Stream	*Stdout;
static BYTE	Datavec[IOCDataMax];
static void	CommunicationsBreakdown(int);

int main(void)
{ Environ	env;
  NA_Message	message;
  word		rc;

#ifndef __TRAN
  SetPriority(HighServerPri);
#endif
  
  if (GetEnv(MyTask->Port, &env) < Err_Null)
   { IOdebug("netagent: failed to receive environment");
     Exit(0x100);
   }
  if ((env.Strv[0] eq Null(Stream)) || (env.Strv[0] eq (Stream *) MinInt))
   { IOdebug("netagent: failed to get communication streams");
     Exit(0x100);
   }
  Stdin		= env.Strv[0];
  Stdout    	= env.Strv[0];
  MachineName(ProcessorName);

	/* Initial communication */
  if (Read(Stdin, (BYTE *) &rc, sizeof(word), 5 * OneSec) ne sizeof(word))
   { IOdebug("netagent(%s): failed to get initial data", ProcessorName);
     Exit(0x100);
   }
  if (Write(Stdin, (BYTE *) &rc, sizeof(word), 5 * OneSec) ne sizeof(word))
   { IOdebug("netagent(%s): failed to respond to initial data", ProcessorName);
     Exit(0x100);
   }

  forever
   { if (Read(Stdin, (BYTE *) &message, sizeof(NA_Message), MainReadTimeout) ne
   		 sizeof(NA_Message))
	CommunicationsBreakdown(1);

     message.Data = Datavec;
     if (message.Size > 0)
      if (Read(Stdin, message.Data, message.Size, ExtraReadTimeout) ne message.Size)
       CommunicationsBreakdown(2);
    
    switch(message.FnRc)
     {	case NA_Quit		: Exit(0);
	case NA_Noop		: /* Just keep running */	break;
	case NA_SetLinkMode	: do_SetLinkMode(&message);	break;
	case NA_Protect		: do_Protect(&message);		break;
	case NA_Revoke		: do_Revoke(&message);		break;
	case NA_Cupdate		: do_Cupdate(&message);		break;
	case NA_Clean		: do_Clean(&message);		break;
	case NA_ClearNames	: do_ClearNames(&message);	break;
	case NA_UpdateIO	: do_UpdateIO(&message);	break;
	case NA_GetLinkMode	: do_GetLinkMode(&message);	break;
	case NA_Terminate	: do_Terminate(&message);	break;

#ifdef __TRAN
	case NA_TransputerBoot	: do_TransputerBoot(&message, FALSE);	break;
	case NA_ParsytecBoot	: do_TransputerBoot(&message, TRUE); 	break;
	case NA_ParsytecReset	: do_ParsytecReset(&message);		break;
#endif

#ifdef __C40
	case NA_C40Boot		: do_C40Boot(&message);		break;
#endif

       default : IOdebug("Netagent(%s): unexpected request 0x%x", ProcessorName,
       				message.FnRc);
		 Exit(0x100);
     }
   }
}

/**
*** If there are processor failures then the netagent may lose communication
*** with the Network Server. The netagent should fail silently, as the
*** Network Server contains recovery code to restart the agent etc.
**/
static void	CommunicationsBreakdown(int x)
{ /* IOdebug("netagent(%s): comms breakdown %d", ProcessorName, x); */
  Exit(0x100 | x);
}

/**
*** Send a reply message
**/
static void	Reply(NA_Message *message, int rc, int size, BYTE *data)
{ message = message;
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(3);
  if (size > 0)
   if (Write(Stdout, data, size, ReplyTimeout) ne size)
    CommunicationsBreakdown(4);
}
/*}}}*/
#else
/*{{{  main() : receive requests via message passing */
/*{{{  forward declarations and statics */
	/* This variable is used to keep track of the last received	*/
	/* message. If no message is received for a certain period of	*/
	/* time (30 seconds) the netagent aborts.			*/
static word		LastMessage;

static void		do_open(ServInfo *servinfo);

static ObjNode		Netagent_Root;
static DispatchInfo Netagent_Info = {
	(DirNode *)	&Netagent_Root,
	NullPort,
	SS_NetServ,
	Null(char),
	{ NULL, 0},
	{
		{ do_open,		3000 },
		{ InvalidFn,		2000 },	/* Create	*/
		{ DoLocate,		2000 },
		{ DoObjInfo,		2000 },
		{ InvalidFn,		2000 },	/* ServerInfo	*/
		{ InvalidFn,		2000 },	/* Delete	*/
		{ InvalidFn,		2000 },	/* Rename	*/
		{ InvalidFn,		2000 },	/* Link		*/
		{ InvalidFn,		2000 },	/* Protect	*/
		{ InvalidFn,		2000 },	/* SetDate	*/
		{ InvalidFn,		2000 }, /* Refine	*/
		{ InvalidFn,		2000 },	/* CloseObj	*/
		{ InvalidFn,		2000 },	/* Revoke	*/
		{ InvalidFn,		2000 },	/* Reserved1	*/
		{ InvalidFn,		2000 },	/* Reserved2	*/
	}
};
/*}}}*/
/*{{{  monitor thread, to abort the netagent if necessary */
static void netagent_monitor(void)
{ LastMessage	= GetDate();

  forever
   { Delay(5 * OneSec);
     if ((GetDate() - LastMessage) > 30)
      { AbortPort(Netagent_Info.ReqPort, EC_Fatal);
        break;
      }
   }
}
/*}}}*/
/*{{{  do_open() */
static void do_open(ServInfo *servinfo)
{ MCB		*m	= servinfo->m;
  MsgBuf	*r;
  ObjNode	*f;
  Port		 stream_port;
  NA_Message	*message= (NA_Message *) m->Control;
  BYTE		*data	= m->Data;

  f = GetTarget(servinfo);
  if (f == Null(ObjNode))
   { ErrorMsg(m, EO_File); return; }

  r = New(MsgBuf);
  if (r eq Null(MsgBuf))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Message); return; }

  FormOpenReply(r, m, f, Flags_Closeable, servinfo->Pathname);
  r->mcb.MsgHdr.Reply	= stream_port	= NewPort();
  PutMsg(&r->mcb);
  Free(r);

  f->Account++;
  UnLockTarget(servinfo);

  forever
   { word	errcode;

     m->MsgHdr.Dest	= stream_port;
     m->Timeout		= 30 * OneSec;
     m->Data		= data;
     m->Control		= (WORD *) message;
     errcode		= GetMsg(m);
     m->MsgHdr.FnRc	= SS_NetServ;

     if (errcode < Err_Null) break;	/* exit on any error */
     if ((errcode & FC_Mask) eq FC_GSP)
      { if ((errcode & FG_Mask) eq FG_Close)
         { if (m->MsgHdr.Reply ne NullPort)
            { m->MsgHdr.FnRc	= 0;
	      ErrorMsg(m, Err_Null);
	    }
	 }
	else
	 ErrorMsg(m, EC_Error + EG_Invalid + EO_Message);
	break;
      }

     message		= (NA_Message *) m->Control;
     message->Data	= m->Data;
     LastMessage	= GetDate();

     switch(message->FnRc)
      {	case NA_Quit		: /* wait for the close */
	case NA_Noop		: /* Just keep running */	break;
	case NA_SetLinkMode	: do_SetLinkMode(message);	break;
	case NA_Protect		: do_Protect(message);		break;
	case NA_Revoke		: do_Revoke(message);		break;
	case NA_Cupdate		: do_Cupdate(message);		break;
	case NA_Clean		: do_Clean(message);		break;
	case NA_ClearNames	: do_ClearNames(message);	break;
	case NA_UpdateIO	: do_UpdateIO(message);		break;
	case NA_GetLinkMode	: do_GetLinkMode(message);	break;
	case NA_Terminate	: do_Terminate(message);	break;

#ifdef __TRAN
	case NA_TransputerBoot	: do_TransputerBoot(message, FALSE);	break;
	case NA_ParsytecBoot	: do_TransputerBoot(message, TRUE); 	break;
	case NA_ParsytecReset	: do_ParsytecReset(message);		break;
#endif

#ifdef __C40
	case NA_C40Boot		: do_C40Boot(message);		break;
#endif

        default : IOdebug("Netagent(%s): unexpected request 0x%x", ProcessorName,
       				message->FnRc);
		 Exit(0x100);
      }
   }

  if (--(f->Account) eq 0)
   AbortPort(Netagent_Info.ReqPort, EC_Fatal);
}
/*}}}*/
/*{{{  Reply() */
static void Reply(NA_Message *message, int fnrc, int size, BYTE *data)
{ MCB	*m;

		/* The NA_Message is the control vector. I can step	*/
		/* back to get the MCB.					*/
  m = (MCB *) ((BYTE *) message - sizeof(MCB));
  InitMCB(m, 0, m->MsgHdr.Reply, NullPort, fnrc);
  m->MsgHdr.DataSize	= size;
  m->Data		= data;
  PutMsg(m);
}
/*}}}*/

int main(void)
{ Object	*nametable_entry;

#ifndef __TRAN
  SetPriority(HighServerPri);
#endif

  { extern int SafetySize; /* in the server library */
    SafetySize = 0;
  }
  InitNode(&Netagent_Root, ".netagent", Type_File, 0, DefFileMatrix);
  InitList(&Netagent_Root.Contents);
  Netagent_Root.Parent	= Null(DirNode);

  MachineName(ProcessorName);

  { NameInfo	 info;
    Object	*this_processor = Locate(Null(Object), ProcessorName);
    info.Port		= Netagent_Info.ReqPort	= NewPort();
    info.Flags		= Flags_StripName;
    info.Matrix		= DefNameMatrix;
    info.LoadData	= NULL;    
    nametable_entry	= Create(this_processor, ".netagent", Type_Name,
		sizeof(NameInfo), (BYTE *) &info);
    Close(this_processor);
  }

  if (nametable_entry ne Null(Object))
   { Fork(2000, &netagent_monitor, 0);
     Dispatch(&Netagent_Info);
     Delete(nametable_entry, Null(char));  /* after an AbortPort() */
   }

  Exit(0);
}
/*}}}*/
#endif
/*{{{  Set link mode */

/**
*** Set the link specified by Arg1 to the mode specified by Arg2. This mode
*** may be 0, 1, 2, or 3. For now ignore any errors.
**/
/*{{{  hardware link resets */

#ifdef __TRAN
	/* perform resetch_()'s on a particular link		*/
static void reset_link(int link)
{ int	x;
  int	*links	= (int *) MinInt;

  if ((x = resetch_(links[link])) != MinInt) runp_(x);
  if ((x = resetch_(links[link + 4])) != MinInt) runp_(x);
}
#else
#ifndef __C40
static void reset_link(int link)
{ link = link;
}
#endif
#endif

/*}}}*/

static void	do_SetLinkMode(NA_Message *message)
{ word		link = message->Arg1;
  word		mode = message->Arg2;
  LinkInfo	info;
  LinkConf	conf;
  
  if (LinkData(link, &info) < Err_Null) return;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags | Link_Flags_report;
   
	/* A dumb link that has been allocated must not be changed. */
  if ((info.Mode eq Link_Mode_Dumb) && (info.State eq Link_State_Running))
   goto done;

	/* If the link was not connected or dumb, reset the hardware now*/
#if 0
	/* BLV - this causes bootstrap failures during the cross-link	*/
	/* phase. This is highly suspicious, as the link guardian	*/
	/* should not be touching the link at the moment.		*/
  if (info.Mode ne Link_Mode_Intelligent)
   reset_link(link);
#endif

  switch(mode)
   { case RmL_NotConnected :
   		    conf.Mode	= Link_Mode_Null;
   		    conf.State	= Link_State_Null;
   		    break;

     case RmL_Dumb :
     		    conf.Mode	= Link_Mode_Dumb;
     		    conf.State	= Link_State_Dumb;
     		    break;
     		    
     case RmL_Running :
       		    conf.Mode	= Link_Mode_Intelligent;
     		    conf.State	= Link_State_Running;
     		    break;
     
     case RmL_Pending :
     			/* Unfortunately the Network Server does not	*/
     			/* currently keep track of which links were used*/
     			/* for bootstrap. Hence it could try to set	*/
     			/* bootlinks back to pending mode...		*/
     		    conf.Mode	= Link_Mode_Intelligent;
     		    if ((info.Mode eq Link_Mode_Intelligent) &&
     		    	(info.State eq Link_State_Running))
     		     conf.State = Link_State_Running;
     		    else
		     conf.State	= Link_State_Dead;
     		    break;

     case RmL_Dead :
		    conf.Mode	= Link_Mode_Intelligent;
		    conf.State	= Link_State_Crashed;
		    break;

     default	  : return;
   }

	/* Configure the link. Then possibly enable the link or reset	*/
	/* the link hardware.						*/
  if (Configure(conf) < Err_Null)
   IOdebug("netagent(%s): failed to configure link %d", ProcessorName, link);
  elif ((mode eq RmL_Running) &&
        ((info.Mode ne Link_Mode_Intelligent) || (info.State ne Link_State_Running)))
   EnableLink(link);
#if 0
	/* BLV - this causes reboots to fail. I suspect that the link	*/
	/* guardian is still timing out, i.e. the configure does not	*/
	/* block until the link guardian has setttled down.		*/
   elif ((mode ne RmL_Running) && (mode ne RmL_Pending))
      reset_link(link);
#endif  

done:

  Reply(message, RmE_Success, 0, NULL);
}

/*}}}*/
/*{{{  Get link mode */

/**
*** Get the current link mode
**/
static void	do_GetLinkMode(NA_Message *message)
{ word		link = message->Arg1;
  int		mode;
  LinkInfo	info;

  if (LinkData(link, &info) < Err_Null)
   { Reply(message, RmE_BadLink, 0, NULL); return; }

  switch(info.Mode)
   { case	Link_Mode_Null : mode = RmL_NotConnected; break;
     case	Link_Mode_Dumb : mode = RmL_Dumb; break;
     case	Link_Mode_Intelligent :
			     	if (info.State eq Link_State_Running)
			     	 mode = RmL_Intelligent;
			     	elif (info.State eq Link_State_Dead)
			     	 mode = RmL_Pending;
		     		else
		     		 mode = RmL_Dead;
				break;

     default :	Reply(message, RmE_BadLink, 0, NULL);
		return;
   }

  Reply(message, RmE_Success, sizeof(WORD), (BYTE *) &mode);
}

/*}}}*/
/*{{{  Protect processor */

/**
*** do_Protect(). This is used to set up the protection needed. The routine
*** should return three capabilities. The first is the owner capability,
*** which is passed on to the Taskforce Manager when the processor gets
*** allocated. The second is read-only, which may or may not be handed out.
*** The third is the full capability, which only the Network
*** Server needs. This full capability is the only capability in the whole
*** network which allows the access matrix to be altered again, and hence
*** it may be needed by this routine.
**/
static void	do_Protect(NA_Message *message)
{ Matrix	matrix		= (Matrix) message->Arg1;
  Capability	*full_cap	= (Capability *) message->Data;
  Capability	result[3];
  Object	*processor;
  word		*temp;

  memset((void *) result, 0, 3 * sizeof(Capability));
  message->FnRc = Err_Null;

  temp = (word *) full_cap;
  
  if ((temp[0] eq 0) && (temp[1] eq 0))
   {	/* the processor has just been booted, and this is the first	*/
   	/* time that protection is being handled.			*/
	/* First, obtain a default object for the processor. This	*/
	/* includes alter access, courtesy of the Processor Manager.	*/
     processor = Locate(Null(Object), ProcessorName);
     if (processor eq Null(Object))
      { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
        goto done;
      }
   }
  else
   {	/* The protection is being reset. This means that the existing	*/
   	/* capability must be used in order to have alter access.	*/
     processor = NewObject(ProcessorName, full_cap);
     if (processor eq Null(Object))
      { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
        goto done;
      }
   }

	/* Remember the full capability, including alter access		*/
  result[2] = processor->Access;

	/* Now refine the access to produce a capability for the owner	*/
  if (Refine(processor, ~AccMask_A) < Err_Null)
   { 
     message->FnRc = Result2(processor);
     goto done;
   }
  result[0] = processor->Access;

	/* Go back to alter access, and produce a read-only capability */
  processor->Access = result[2];
  if (Refine(processor, AccMask_R | AccMask_Z) < Err_Null)
   {
     message->FnRc = Result2(processor);
     goto done;
   }
  result[1] = processor->Access;
  
	/* Go back to alter access, and protect the processor */
  processor->Access = result[2];
  if (Protect(processor, Null(char), matrix) < Err_Null) 
   { 
     message->FnRc = Result2(processor);
     goto done;
   }

done:
  Reply(message, (int) message->FnRc,
	(message->FnRc eq Err_Null) ? 3 * sizeof(Capability) : 0,
	(BYTE *) result);
}

/*}}}*/
/*{{{  Revoke capabilities */
/**
*** Currently a no-op
**/
static void	do_Revoke(NA_Message *message)
{ message = message;
}
/*}}}*/
/*{{{  Update processor's name */

/**
*** Update the name of a processor. For example, if the current name is /00
*** change it to /Net/00. Arg1 contains the length of the new network name.
**/
static void	do_Cupdate(NA_Message *message)
{ Object	*processor	= Null(Object);
  WORD	rc;
  
  processor	= Locate(Null(Object), ProcessorName);
  if (processor eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }

  rc = Rename(processor, Null(char), message->Data);
  
done:
  Reply(message, (int) rc, 0, NULL);
  if (processor ne Null(Object)) Close(processor);
}

/*}}}*/
/*{{{  Update neighbour's (I/O processor) name */

/**
*** Update the name of an I/O processor at the other end of the specified
*** link. For example, change it from /IO to /Net/IO.
**/
static void	do_UpdateIO(NA_Message *message)
{ word		link = message->Arg1;
  char		linkbuf[10];	/* link.267\0 */
  Object	*processor	= Null(Object);
  word		rc;
    
  processor	= Locate(Null(Object), ProcessorName);
  if (processor eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }
   
  strcpy(linkbuf, "link.");
  if (link eq 0)
   strcat(linkbuf, "0");	/* addint() does not cope with 0 */
  else
   addint(linkbuf, link);
   
  rc = Rename(processor, linkbuf, message->Data);

done:
  Reply(message, (int) rc, 0, NULL);
  if (processor ne Null(Object)) Close(processor);  
}

/*}}}*/
/*{{{  Clean out processor */

/**-----------------------------------------------------------------------------
*** This routine should clean out the processor.
*** Essentially it performs several walkdirs.
*** 3) two WalkDirs of /tasks to find any programs that should not be running.
***    There are occasional problems killing off programs so the final
***    kill_task is not done until the end, after the reply is sent.
*** 2) a WalkDir of /loader to delete any unused libraries
*** 3) possibly a WalkDir of /pipe if the pipe server is running
*** 4) ditto for /fifo
*** 5) ditto for /ram
**/
static word	WalkDir(Object *x, WordFnPtr fn);
static bool	pipe_running	= FALSE;
static bool	fifo_running	= FALSE;
static bool	ram_running	= FALSE;
static word	kill_task(Object *task);
static word	kill_something(Object *whatever);
static word	cleaning_date;

static void	do_Clean(NA_Message *message)
{ Object	*procman	= Locate(Null(Object), "/tasks");
  Object	*loader		= Locate(Null(Object), "/loader");
  word		 running_tasks	= 0;

  cleaning_date = message->Arg1;

  if (procman ne Null(Object))
   { running_tasks = WalkDir(procman, &kill_task);   /* generates SIGINT */
     if (running_tasks > 0)
      { Delay(running_tasks * (OneSec / 10));
        WalkDir(procman, &kill_task);	/* generates SIGKILL	*/
      }
   }

  if (loader ne Null(Object))
   { (void) WalkDir(loader, &kill_something); Close(loader); }

  if (pipe_running)
   { Object	*pipe_server = Locate(Null(Object), "/pipe");
     if (pipe_server ne Null(Object))
      { (void) WalkDir(pipe_server, &kill_something);
        Close(pipe_server);
      }
   }
   
  if (fifo_running)
   { Object	*fifo_server = Locate(Null(Object), "/fifo");
     if (fifo_server ne Null(Object))
      { (void) WalkDir(fifo_server, &kill_something);
        Close(fifo_server);
      }
   }
   
  if (ram_running)
   { Object	*ram_server = Locate(Null(Object), "/ram");
     if (ram_server ne Null(Object))
      { (void) WalkDir(ram_server, &kill_something);
        Close(ram_server);
      }
   }

  Reply(message, (int) Err_Null, 0, NULL);   

  if (running_tasks > 0)
   { (void)WalkDir(procman, &kill_task);	/* performs KillTask(), or dies	*/
     Close(procman);
   }
}

static word WalkDir(Object *dir, WordFnPtr fn)
{ Stream  	*s;
  WORD		size, i;
  DirEntry	*entry, *cur;
  Object	*item;
  word		 result = 0;
  
  if ((dir->Type & Type_Flags) eq Type_Stream) return(0);
   
  s = Open(dir, Null(char), O_ReadOnly);
  if (s eq Null(Stream))
   { IOdebug("netagent: error cleaning %s (%x)", dir->Name, Result2(dir));
     return(0); 
   }

  size = GetFileSize(s);
  if (size eq 0) return(0);

  entry = (DirEntry *) Malloc(size);
  if (entry == Null(DirEntry)) 
   { IOdebug("netagent: out of memory cleaning %s", dir->Name);
     Close(s); 
     return(0);
   }
     
  if ((size = Read(s, (BYTE *) entry, size, -1)) < 0)
   { IOdebug("netagent: read error cleaning %s", dir->Name);
     Close(s);
     return(0);
   }

  Close(s);
      
  cur = entry;
  for (i = 0; i < size; cur++, i += sizeof(DirEntry) )
   { if ( (!strcmp(cur->Name, ".")) || (!strcmp(cur->Name, "..")) )
      continue;

     item = Locate(dir, cur->Name);
     if (item ne Null(Object))
      { result += (*fn)(item);
        Close(item);
      }
   }

  Free(entry);
  return(result);
}

	/* delete something from a ram-disk or similar */
static word	kill_something(Object *x)
{ if ((x->Type & Type_Flags) eq Type_Directory)
   WalkDir(x, &kill_something);
  Delete(x, Null(char));
  return(0);
}

	/* kill a task. Several tasks are exempt from this. 		*/
	/* Also, commands started by the Network Server are exempt	*/
static	word kill_task(Object *task)
{ char		*name = objname(task->Name);
  ObjInfo	info;
      
  if (	!strncmp(name, "netagent.", 9)	||
	!strncmp(name, "login.", 6)	||
	!strncmp(name, "Null.", 5)	||
	!strncmp(name, "Loader.", 7)	||
  	!strncmp(name, "ProcMan.", 8))
   return(0);

  if (!strncmp(name, "Fifo.", 5)) { fifo_running = TRUE; return(0); }
  if (!strncmp(name, "Pipe.", 5)) { pipe_running = TRUE; return(0); }
  if (!strncmp(name, "Ram.", 4))  { ram_running = TRUE;  return(0); }
  
  if ((ObjectInfo(task, Null(char), (BYTE *) &info) < Err_Null) || 
      (info.Dates.Creation <= cleaning_date))
   return(0);

  (void) Delete(task, Null(char));
  return(1);
}

/*}}}*/
/*{{{  Clear name table */
/**
*** Clearing the names involves sending a message to the processor manager.
*** Currently no special capability is required. The network server does not
*** expect a reply.
**/
static void	do_ClearNames(NA_Message *message)
{ Object	*procman = Null(Object);
  word		rc = Err_Null;
  MsgBuf	*r = New(MsgBuf);

  if (r eq Null(MsgBuf))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }

  procman = Locate(Null(Object), "/tasks");  
  if (procman eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_ProcMan; goto done; }

  InitMCB(&(r->mcb), MsgHdr_Flags_preserve, NullPort, NullPort, 
          FC_GSP + FG_Reconfigure);
  r->mcb.Control = r->control;
  r->mcb.Data	 = r->data;
  MarshalCommon(&(r->mcb), procman, Null(char));
  SendIOC(&(r->mcb));

done:
  if (r ne Null(MsgBuf)) Free(r);
  if (procman ne Null(Object)) Close(procman);
  message = message;
}
/*}}}*/
/*{{{  Terminate processor */
/**
*** Terminate(). This is slightly nasty because the pipe has to be
*** closed first.
**/
static	void	do_Terminate(NA_Message *message)
{
#if PIPEIO
  Close(Stdin);
	/* This delay appears to be needed with the 1.2.2 nucleus */
  Delay(OneSec / 10);
#endif

  Terminate();
  message = message;
}
/*}}}*/
#ifdef __TRAN
/*{{{  Parsytec-style reset */
/**
*** Perform a Parsytec reset down the link specified by Arg1 of the message.
*** Do not bother to send back a reply.
**/
static void	do_ParsytecReset(NA_Message *message)
{ int link = message->Arg1;
  Parsytec_Reset(link);
}
/*}}}*/
/*{{{  Transputer bootstrap */

/**-----------------------------------------------------------------------------
*** do_TransputerBoot(). This code should be kept in step with rboot.c
*** There is a second argument to specify a Parsytec reset. Arg1 of the message
*** is the link number. Arg2 is the size of the remaining data. This
*** consists of a nucleus string, possibly empty to indicate that the same
*** nucleus should be used, but always aligned to a four byte boundary.
*** This is followed by the configuration vector.
***
*** The routine returns a similar result to the system BootLink() routine,
*** but all the work is done the hard way
***
*** NOTE: in Helios 1.3 the option to use the system's BootLink() routine has
*** been removed, as it was never enabled. Also, the various delays involved
*** have been removed as there is no known justification for them. The
*** only hardware for which a delay during the bootstrap is required, as
*** far as I know, is a Parsytec SuperCluster where a delay is needed after
*** asserting the reset to allow the memory parity hardware to settle down.
*** This delay has been moved to Parsytec_Reset().
***
*** The netagent without delays has been tested extensively on a T.Node and
*** on a MultiCluster. Bootstrap appears to have become more reliable.
**/

static MPtr	determine_image(char *, word *);
static void	transputer_init_link(int);
static void	transputer_set_link(int);
static int	transputer_check_link(int);
static int	transputer_BootLink(word link, MPtr image, Config *config, word csize);

static void	do_TransputerBoot(NA_Message *message, bool parsytec)
{ BYTE		*nucleus_string = message->Data;
  Config	*config;
  int		link = message->Arg1;
  int		length;
  word		rc = Err_Null;
  MPtr		system_image;

  length = strlen(nucleus_string) + 1;
  length = (length + 3) & ~3;
  config = (Config *) &(nucleus_string[length]);
  length = message->Size - length;	/* now length of config vector */

  system_image = determine_image(nucleus_string, &rc);
  if ( MNull_(system_image) ) goto done;

  config->ImageSize = MWord_(system_image,0);
  config->Date	    = GetDate();

  transputer_init_link(link);
  
  if (parsytec) Parsytec_Reset(link);

  rc = transputer_BootLink(link, system_image, config, length);
  if (rc eq Err_Null)
   { transputer_set_link(link);
     rc = transputer_check_link(link);
   }
   
done:
  if ((strlen(nucleus_string) > 0) && (!MNull_(system_image)))
   Free(MtoC_(system_image));

  Reply(message, rc, 0, NULL);
}

/**
*** Figure out which nucleus to use. If the string provided is empty
*** then use the current nucleus. Otherwise try to locate and read in
*** the specified nucleus.
**/
static	MPtr determine_image(char *name, word *rc)
{ Object	*nuc;
  ObjInfo	info;
  MPtr		image = GetSysBase();
  Stream	*s;
  BYTE		*buffer;
  
  if (strlen(name) eq 0) return(image);
  
  nuc = Locate(Null(Object), name);
  if (nuc eq Null(Object))
   { *rc = EC_Error + SS_NetServ + EG_Unknown + EO_File; 
     return NullMPtr;
   }

  if ((nuc->Type & Type_Flags) ne Type_Stream)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Invalid + EO_File;
     return NullMPtr;
   }
   
  if (ObjectInfo(nuc, Null(char), (BYTE *) &info) < Err_Null)   
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_File;
     return NullMPtr;
   }
   
  if (info.Size <= 0)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_WrongSize + EO_File;
     return NullMPtr;
   }

  buffer = Malloc(info.Size);
  if (buffer eq Null(BYTE))
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_NoMemory + EO_File;
     return NullMPtr;
   }

  s = Open(nuc, Null(char), O_ReadOnly);
  Close(nuc);
  if (s eq Null(Stream))
   { Free(buffer);
     *rc = EC_Error + SS_NetServ + EG_Open + EO_File;
     return NullMPtr;
   }
   
  if (Read(s, buffer, info.Size, -1) ne info.Size)
   { Free(buffer);
     buffer = Null(BYTE);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_Stream;
   }
  Close(s);
  return(CtoM_(buffer));
}

/**
*** If I am about to attempt a bootstrap down a link, that link had better
*** be in a sensible state.
**/
static void transputer_init_link(int link)
{ LinkInfo info;
  LinkConf conf;

  if (LinkData(link, &info) ne Err_Null) return;

  if (info.Mode eq Link_Mode_Dumb) return;
  conf.Mode 	= Link_Mode_Dumb;
  conf.State	= Link_State_Dumb;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);

  reset_link(link);
}

/**
*** After a bootstrap, ensure that the link is in a sensible state.
*** Note that the newly-booted processor almost immediately sends
*** an info exchange, so the booting processor must not send its own
*** info. Hence the correct state is pending, not intelligent.
**/
static void transputer_set_link(int link)
{ LinkInfo	info;
  LinkConf	conf;
  
  if (LinkData(link, &info) ne Err_Null) return;

  if ((info.Mode eq Link_Mode_Intelligent) &&
      (info.State eq Link_State_Running))
   return;
  conf.Mode 	= Link_Mode_Intelligent;
  conf.State	= Link_State_Dead;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);
}

/**
*** The network agent checks the booting link. If the remote processor has come
*** up then it will have enabled the link by now, and it can be used by the
*** networking software. If not then the netagent polls for a while, waiting
*** for the link.
**/
static	int	transputer_check_link(int link)
{ LinkInfo	info;
  int		rc;
  int		i;

  for (i = 0; i < 100; i++)    
   { if ((rc = LinkData(link, &info)) ne Err_Null) return(rc);
     if ((info.Mode eq Link_Mode_Intelligent) &&
         (info.State eq Link_State_Running))
      break;
     else
      Delay(10000); /* 10 milliseconds * 100 loops */
   }

  if ((info.Mode ne Link_Mode_Intelligent) ||
      (info.State ne Link_State_Running))
   return(EC_Error + SS_NetServ + EG_Boot + EO_Processor);

  return(Err_Null);
}

/**
*** Perform a Parsytec-style reset on the specified link.
**/
#define Reset_Address	0x000000C0
static void Parsytec_Reset(int link)
{ uword *reg = (uword *) Reset_Address;
  *reg = 0;
  *reg = 1;
  *reg = 2;
  *reg = 3;
  *reg = 1 << link;
  Delay(5000);
  *reg = 0;
  Delay(10000);
}

/**
*** Manual bootstrap. This involves the following stages.
*** 1) send in nboot.i, held in a slot in the system image
*** 2) send in a control byte to nboot.i to read in the system image
*** 3) send in the whole system image
*** 4) send in the configuration vector
**/
static int transputer_BootLink(word link, MPtr image, Config *config, word confsize)
{ UBYTE	temp[4];
  MPtr  nboot;
  word  nboot_size;
  word	image_size;
  int	rc;

  nboot		= MRTOA_(MInc_(image,IVecBootStrap*sizeof(WORD)));
  nboot_size	= MWord_(image,IVecProcMan*sizeof(WORD))
		  - MWord_(image,IVecBootStrap*sizeof(WORD)) + 4;


  temp[0] = (UBYTE) nboot_size;
  if ((rc = LinkOut(1, link, temp, 2 * OneSec)) ne Err_Null)
   return(Boot_BootstrapSize | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(nboot_size, link, MtoC_(nboot), 2 *OneSec) ne Err_Null)
   return(Boot_BootstrapCode | EG_Timeout | EC_Error | SS_NetServ);

	/* There should be a short delay between the nboot start-up and	*/
	/* sending in the nucleus, because nboot performs a resetch.	*/
	/* Delays during this time should be safe because nboot knows	*/
	/* the bootlink and hence cannot be fould up by other		*/
	/* processors...						*/
  for (rc = 0; rc < 1024; rc++)
   temp[0] += rc;

  temp[0] = 4;			/* bootstrap command */
  if (LinkOut(1, link, temp, 2 * OneSec) ne Err_Null)
   return(Boot_ControlByte | EG_Timeout | EC_Error | SS_NetServ);

  image_size = MWord_(image,0);
  if (LinkOut(image_size, link, MtoC_(image), 3 * OneSec) ne Err_Null)
   return(Boot_Image | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(sizeof(WORD), link, (BYTE *) &confsize, 2 * OneSec) ne Err_Null)
   return(Boot_ConfigSize | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(confsize, link, (BYTE *) config, 2 * OneSec) ne Err_Null)
   return(Boot_ConfigVector | EG_Timeout | EC_Error | SS_NetServ);
  return(Err_Null);
}

/*}}}*/
#endif
#ifdef __C40
/*{{{  C40 bootstrap */

/**
*** C40 bootstrap. Arg1 of the message is the link number that should be
*** used. Arg2 is the size of the remaining data. This consists of a
*** nucleus string, possibly empty to indicate that the current nucleus
*** should be used, but always aligned to a four-byte boundary. This
*** is followed by the configuration vector. The code used at present is
*** very similar to the transputer version.
**/
static MPtr	determine_image(char *, word *);
static void	C40_init_link(int);
static void	C40_set_link(int);
static word	C40_check_link(word);
static word	C40_BootLink(word link, MPtr image, C40_Bootstrap *);

static void do_C40Boot(NA_Message *message)
{ C40_Bootstrap *boot_info;
  word		 link = message->Arg1;
  word		 rc = Err_Null;
  MPtr		system_image;

  boot_info	= (C40_Bootstrap *) message->Data;
  if (boot_info->Nucleus ne 0)
   system_image = determine_image(RTOA(boot_info->Nucleus), &rc);
  else
   system_image = determine_image(NULL, &rc);
  if ( MNull_(system_image) ) goto done;

  boot_info->Config.ImageSize	= MWord_(system_image, 0);
  boot_info->Config.Date	= GetDate();

  C40_init_link((int) link);
  rc = C40_BootLink(link, system_image, boot_info);
  if (rc eq Err_Null)
   { C40_set_link((int)link);
     rc = C40_check_link(link);
   }

done:
  if ((boot_info->Nucleus ne 0) && !MNull_(system_image))
   Free(MtoC_(system_image));

  Reply(message, (int) rc, 0, NULL);
}
/**
*** Figure out which nucleus to use. If the string provided is empty
*** then use the current nucleus. Otherwise try to locate and read in
*** the specified nucleus.
**/
static	MPtr determine_image(char *name, word *rc)
{ Object	*nuc;
  ObjInfo	info;
  MPtr		image = GetSysBase();
  Stream	*s;
  BYTE		*buffer;
  
  if ((name eq NULL) || (strlen(name) eq 0)) return(image);
  
  nuc = Locate(Null(Object), name);
  if (nuc eq Null(Object))
   { *rc = EC_Error + SS_NetServ + EG_Unknown + EO_File; 
     return(NullMPtr);
   }

  if ((nuc->Type & Type_Flags) ne Type_Stream)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Invalid + EO_File;
     return(NullMPtr);
   }
   
  if (ObjectInfo(nuc, Null(char), (BYTE *) &info) < Err_Null)   
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_File;
     return(NullMPtr);
   }
   
  if (info.Size <= 0)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_WrongSize + EO_File;
     return(NullMPtr);
   }

  buffer = Malloc(info.Size);
  if (buffer eq Null(BYTE))
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_NoMemory + EO_File;
     return(NullMPtr);
   }

  s = Open(nuc, Null(char), O_ReadOnly);
  Close(nuc);
  if (s eq Null(Stream))
   { Free(buffer);
     *rc = EC_Error + SS_NetServ + EG_Open + EO_File;
     return(NullMPtr);
   }
   
  if (Read(s, buffer, info.Size, -1) ne info.Size)
   { Free(buffer);
     buffer = Null(BYTE);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_Stream;
   }
  Close(s);
  return(CtoM_(buffer));
}

/**
*** If I am about to attempt a bootstrap down a link, that link had better
*** be in a sensible state.
**/
static void C40_init_link(int link)
{ LinkInfo info;
  LinkConf conf;

  if (LinkData(link, &info) ne Err_Null) return;

  if (info.Mode eq Link_Mode_Dumb) return;

  conf.Mode 	= Link_Mode_Dumb;
  conf.State	= Link_State_Dumb;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);
}

/**
*** After a bootstrap, ensure that the link is in a sensible state.
*** Note that the newly-booted processor almost immediately sends
*** an info exchange, so the booting processor must not send its own
*** info. Hence the correct state is pending, not intelligent.
**/
static void C40_set_link(int link)
{ LinkInfo	info;
  LinkConf	conf;
  
  if (LinkData(link, &info) ne Err_Null) return;

  if ((info.Mode eq Link_Mode_Intelligent) &&
      (info.State eq Link_State_Running))
   return;

  conf.Mode 	= Link_Mode_Intelligent;
  conf.State	= Link_State_Dead;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);
}

/**
*** The network agent checks the booting link. If the remote processor has come
*** up then it will have enabled the link by now, and it can be used by the
*** networking software. If not then the netagent polls for a while, waiting
*** for the link.
**/
static	word	C40_check_link(word link)
{ LinkInfo	info;
  word		rc;
  int		i;

  for (i = 0; i < 100; i++)    
   { if ((rc = LinkData(link, &info)) ne Err_Null) return(rc);
     if ((info.Mode eq Link_Mode_Intelligent) &&
         (info.State eq Link_State_Running))
      break;
     else
      Delay(10000); /* 10 milliseconds * 100 loops */
   }

  if ((info.Mode ne Link_Mode_Intelligent) ||
      (info.State ne Link_State_Running))
   return(EC_Error + SS_NetServ + EG_Boot + EO_Processor);

  return(Err_Null);
}

/**
*** Manual bootstrap. This involves the following stages.
*** 1) Send in magic numbers for the memory
*** 2) Send in C40boot.i, held in a slot in the system image
*** 3) Send in more magic numbers
*** 4) Receive bootstrap executing acknowledgement
*** 5) Send hardware configuration flags to booter
*** 6) If appropriate, send in the supplied IDROM
*** 7) Send in the whole system image
*** 8) Send in the configuration vector
**/
static word C40_BootLink(word link, MPtr image, C40_Bootstrap *boot_info)
{ WORD	temp[4];
  MPtr	c40boot;
  word  c40boot_size;
  word	image_size;
  word	rc;

	/* BLV - should load the bootstrap if a special one has been	*/
	/* specified in the C40_Bootstrap structure.			*/
  c40boot	= MRTOA_(MInc_(image,IVecBootStrap*sizeof(WORD)));
  c40boot_size	= MWord_(image,IVecProcMan*sizeof(WORD))
		  - MWord_(image,IVecBootStrap*sizeof(WORD)) + 4;

	/* If an IDROM is specified then the bus control registers from	*/
	/* the IDROM are used rather than the defaults.			*/
  if (boot_info->Hwconfig & (HW_PseudoIDROM | HW_ReplaceIDROM))
   { temp[0] = boot_info->Idrom.GBCR;
     temp[1] = boot_info->Idrom.LBCR;
   }
  else
   { temp[0] = 0x3e39fff0;		/* Global bus memory control word */
     temp[1] = 0x3e39fff0;		/* Local  bus memory control word */
   }
  temp[2] = c40boot_size / sizeof(WORD);/* Block size			  */
  temp[3] = 0x002ffc00;			/* Load address			  */

  /* Send C40 boot protocol header */
  if ((rc = LinkOut(16, link, temp, 2 * OneSec)) ne Err_Null)
   return(Boot_BootstrapSize | EG_Timeout | EC_Error | SS_NetServ);

  /* Send Helios-C40 bootstrap */
  if (MP_LinkOut(c40boot_size/sizeof(WORD), link, c40boot, 2 *OneSec) ne Err_Null)
   return(Boot_BootstrapCode | EG_Timeout | EC_Error | SS_NetServ);

  temp[0] = 0;				/* terminator	*/
  temp[1] = 0;				/* IVTP		*/
  temp[2] = 0;				/* TVTP		*/
  temp[3] = 0x00300000;			/* IACK		*/

  /* Send C40 boot protocol tail */
  if ((rc = LinkOut(16, link, temp, 2 * OneSec)) ne Err_Null)
   return(Boot_ProtocolTail | EG_Timeout | EC_Error | SS_NetServ);

  /* Receive bootstrap acknowledgement from bootstrap code */
  if ((rc = LinkIn(4, link, temp, 2 * OneSec)) ne Err_Null)
   return(Boot_Acknowledgement | EG_Timeout | EC_Error | SS_NetServ);
  if (temp[0] != 1) /* bootstrap ack is always 1 */
   return(Boot_Acknowledgement2 | EG_Timeout | EC_Error | SS_NetServ);

  /* Send hardware configuration flags to bootstrap code */
  if ((rc = LinkOut(4, link, (BYTE *) &(boot_info->Hwconfig), 2 * OneSec)) ne Err_Null)
   return(Boot_Hwconfig | EG_Timeout | EC_Error | SS_NetServ);

  /* Send the IDRom if appropriate			*/
  if (boot_info->Hwconfig & (HW_PseudoIDROM | HW_ReplaceIDROM))
   if ((rc = LinkOut(sizeof(IDROM), link, (BYTE *) &(boot_info->Idrom), 2 * OneSec)) ne Err_Null)
    return(Boot_Idrom | EG_Timeout | EC_Error | SS_NetServ);

  /* Send Helios-C40 nucleus */
  image_size = MWord_(image,0);
  if (MP_LinkOut(image_size/sizeof(WORD), link, image, 2 * OneSec) ne Err_Null)
   return(Boot_Image | EG_Timeout | EC_Error | SS_NetServ);
  
  /* Sending size of config */
  if (LinkOut(sizeof(WORD), link, (BYTE *) &(boot_info->ConfigSize), 2 * OneSec) ne Err_Null)
   return(Boot_ConfigSize | EG_Timeout | EC_Error | SS_NetServ);

  /* Sending config */
  if (LinkOut(boot_info->ConfigSize, link, (BYTE *) &(boot_info->Config), 2 * OneSec) ne Err_Null)
   return(Boot_ConfigVector | EG_Timeout | EC_Error | SS_NetServ);
  return(Err_Null);
}

/*}}}*/
#endif

@


1.38
log
@memory reduction
@
text
@d18 1
a18 1
/* RcsId: $Header: /hsrc/network/RCS/netagent.c,v 1.37 1993/07/02 17:12:47 bart Exp $*/
d392 1
d398 1
d409 1
d414 2
d419 2
a420 2
{ int		link = message->Arg1;
  int		mode = message->Arg2;
d500 1
d505 1
a505 1
{ int		link = message->Arg1;
d530 1
d533 1
d606 1
a606 1
  Reply(message, message->FnRc,
d610 1
d621 1
d637 1
a637 1
  Reply(message, rc, 0, NULL);
d640 1
d643 1
d649 1
a649 1
{ int		link = message->Arg1;
d652 1
a652 1
  int		rc;
d667 1
a667 1
  Reply(message, rc, 0, NULL);
d670 1
d673 1
d696 1
a696 1
  int		 running_tasks	= 0;
d735 1
a735 1
  Reply(message, Err_Null, 0, NULL);   
d824 1
d886 1
d1148 1
d1153 1
d1165 2
a1166 2
static int	C40_check_link(int);
static int	C40_BootLink(word link, MPtr image, C40_Bootstrap *);
d1170 1
a1170 2
  int		 link = message->Arg1;
  int		 length;
d1184 1
a1184 1
  C40_init_link(link);
d1187 1
a1187 1
   { C40_set_link(link);
d1195 1
a1195 1
  Reply(message, rc, 0, NULL);
d1307 1
a1307 1
static	int	C40_check_link(int link)
d1309 1
a1309 1
  int		rc;
d1339 1
a1339 1
static int C40_BootLink(word link, MPtr image, C40_Bootstrap *boot_info)
d1344 1
a1344 1
  int	rc;
d1411 1
@


1.37
log
@Fixed C40 numbers again.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /hsrc/network/RCS/netagent.c,v 1.36 1993/06/16 13:37:09 bart Exp bart $";
@


1.36
log
@Changed the magic numbers used for the global and local bus control
registers in a C40 bootstrap
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /hsrc/network/RCS/netagent.c,v 1.35 1993/02/19 18:56:00 bart Exp bart $";
d1342 2
a1343 2
   { temp[0] = 0x3d39fff0;		/* Global bus memory control word */
     temp[1] = 0x3d39fff0;		/* Local  bus memory control word */
@


1.35
log
@An MPtr was being used as a C pointer.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.34 1993/01/26 16:40:56 bart Exp bart $";
d1342 2
a1343 2
   { temp[0] = 0x3e4a4000;		/* Global bus memory control word */
     temp[1] = 0x3e4a4000;		/* Local  bus memory control word */
@


1.34
log
@Now runs at higher priority so that it can clean out errant programs
with a slightly greater chance of succeeding.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: netagent.c,v 1.33 93/01/07 14:10:57 bart Exp $";
d1164 1
a1164 1
  boot_info->Config.ImageSize	= *((word *) system_image);
@


1.33
log
@1) speeded up the cleaners for the common case where a released processor
   is no longer running any user code.
2) for C40 bootstrap, if idrom information is supplied as part of the
   bootstrap info then the initial values for global and local bus control
   registers are extracted from the idrom info, instead of always defaulting
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/netagent.c,v 1.29 1992/11/24 17:28:43 nick Exp $";
d43 1
d117 4
d356 4
@


1.32
log
@Also fixed transputer compiler-time errors, but without using GnuEmacs
automatic reformatting!
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.30 1992/12/03 16:49:16 paul Exp $";
d662 1
a662 1
static void	WalkDir(Object *x, VoidFnPtr fn);
d666 2
a667 2
static void	kill_task(Object *task);
static void	kill_something(Object *whatever);
d671 3
a673 2
{ Object	*procman = Locate(Null(Object), "/tasks");
  Object	*loader	 = Locate(Null(Object), "/loader");
d678 5
a682 3
   { WalkDir(procman, &kill_task);	/* generates SIGINT	*/
     Delay(OneSec);
     WalkDir(procman, &kill_task);	/* generates SIGKILL	*/
d686 1
a686 1
   { WalkDir(loader, &kill_something); Close(loader); }
d691 1
a691 1
      { WalkDir(pipe_server, &kill_something);
d699 1
a699 1
      { WalkDir(fifo_server, &kill_something);
d707 1
a707 1
      { WalkDir(ram_server, &kill_something);
d714 2
a715 2
  if (procman ne Null(Object))
   { WalkDir(procman, &kill_task);	/* performs KillTask(), or dies	*/
d720 1
a720 1
static void WalkDir(Object *dir, VoidFnPtr fn)
d725 1
d727 1
a727 1
  if ((dir->Type & Type_Flags) eq Type_Stream) return;
d732 1
a732 1
     return; 
d736 1
a737 1
  if (size eq 0) return;
d742 1
a742 1
     return;
d748 1
a748 1
     return;
d760 1
a760 1
      { (*fn)(item);
d766 1
d770 1
a770 1
static void	kill_something(Object *x)
d774 1
d779 1
a779 1
static	void kill_task(Object *task)
d783 10
a792 8
  if (!strncmp(name, "netagent.", 9))	return;
  if (!strncmp(name, "login.", 6))	return;
  if (!strncmp(name, "Null.", 5))	return;
  if (!strncmp(name, "Loader.", 7))	return;
  if (!strncmp(name, "ProcMan.", 8))	return;
  if (!strncmp(name, "Fifo.", 5)) { fifo_running = TRUE; return; }
  if (!strncmp(name, "Pipe.", 5)) { pipe_running = TRUE; return; }
  if (!strncmp(name, "Ram.", 4))  { ram_running = TRUE;  return; }
d794 3
a796 3
  if (ObjectInfo(task, Null(char), (BYTE *) &info) < Err_Null)
   return;
  if (info.Dates.Creation <= cleaning_date) return;
d799 1
d1244 1
d1267 1
a1321 1

d1326 10
a1335 2
  temp[0] = 0x3e4a4000;			/* Global bus memory control word */
  temp[1] = 0x3e4a4000;			/* Local  bus memory control word */
@


1.31
log
@fixed transputer compile time errors
@
text
@d6 1
a6 1
--             Copyright (C) 1990 - 1992, Perihelion Software Ltd.      --
d18 1
a18 3
#ifdef __TRAN
static char *rcsid = "$Header: /hsrc/network/RCS/netagent.c,v 1.30 1992/12/03 16:49:16 paul Exp nickc $";
#endif
d21 7
a27 7
 *** The netagent can be compiled to work in two different ways, affecting
 *** the way in which it communicates with the Network Server. The first
 *** option involves a pipe created by the Network Server, supplied in an
 *** environment. The second involves the netagent installing itself as
 *** as a server and performing low-level message transactions. This
 *** compile-time option determines the communication.
 **/
d58 2
a59 2
 *** Ensure that the C library (plus posix and fplib) are not loaded
 **/
d61 23
a83 23
  { VoidFnPtr junk;
    junk = &_stack_error;
    IOdebug("Netagent: stack overflow in %s at %x",p->Name,&p);
    Exit(0x0080 | SIGSTAK);
  }
  /*}}}*/
  /*{{{  Prototypes etc. */
  /**
   *** These routines support the various requests. The Network Server sends
   *** NA_Message structures to the netagent which include a function code.
   *** The structure and the various function codes are defined in netaux.h
   *** There is a separate handler for every function code. Particular
   *** processors may be unable to cope with particular function codes.
   **/
  static void	do_SetLinkMode(NA_Message *);
  static void	do_Protect(NA_Message *);
  static void	do_Revoke(NA_Message *);
  static void	do_Cupdate(NA_Message *);
  static void	do_Clean(NA_Message *);
  static void	do_ClearNames(NA_Message *);
  static void	do_UpdateIO(NA_Message *);
  static void	do_GetLinkMode(NA_Message *);
  static void	do_Terminate(NA_Message *);
d85 3
a87 3
  static void	do_TransputerBoot(NA_Message *, bool);
  static void	do_ParsytecReset(NA_Message *);
  static void	Parsytec_Reset(int link);
d90 1
a90 1
  static void	do_C40Boot(NA_Message *);
d92 3
a94 3
  
  static char	ProcessorName[IOCDataMax];
  
d98 1
a98 1
  /*}}}*/
d100 16
a115 11
  /*{{{  main() : receive requests from the Network Server via a pipe */
  /**
   *** Get the environment and the standard streams, which are a pipe from and
   *** to the network server. The same pipe is used bi-directionally.
   *** Then loop for ever reading request packets and invoke suitable handling
   *** routines.
   **/
  static Stream	*Stdin;
  static Stream	*Stdout;
  static BYTE	Datavec[IOCDataMax];
  static void	CommunicationsBreakdown(int);
d117 31
a147 4
  int main(void)
  { Environ	env;
    NA_Message	message;
    word		rc;
d149 13
a161 45
    if (GetEnv(MyTask->Port, &env) < Err_Null)
      { IOdebug("netagent: failed to receive environment");
	Exit(0x100);
      }
    if ((env.Strv[0] eq Null(Stream)) || (env.Strv[0] eq (Stream *) MinInt))
      { IOdebug("netagent: failed to get communication streams");
	Exit(0x100);
      }
    Stdin		= env.Strv[0];
    Stdout    	= env.Strv[0];
    MachineName(ProcessorName);
    
    /* Initial communication */
    if (Read(Stdin, (BYTE *) &rc, sizeof(word), 5 * OneSec) ne sizeof(word))
      { IOdebug("netagent(%s): failed to get initial data", ProcessorName);
	Exit(0x100);
      }
    if (Write(Stdin, (BYTE *) &rc, sizeof(word), 5 * OneSec) ne sizeof(word))
      { IOdebug("netagent(%s): failed to respond to initial data", ProcessorName);
	Exit(0x100);
      }
    
    forever
      { if (Read(Stdin, (BYTE *) &message, sizeof(NA_Message), MainReadTimeout) ne
	    sizeof(NA_Message))
	  CommunicationsBreakdown(1);
	
	message.Data = Datavec;
	if (message.Size > 0)
	  if (Read(Stdin, message.Data, message.Size, ExtraReadTimeout) ne message.Size)
	    CommunicationsBreakdown(2);
	
	switch(message.FnRc)
	  {	case NA_Quit		: Exit(0);
	  case NA_Noop		: /* Just keep running */	break;
	  case NA_SetLinkMode	: do_SetLinkMode(&message);	break;
	  case NA_Protect		: do_Protect(&message);		break;
	  case NA_Revoke		: do_Revoke(&message);		break;
	  case NA_Cupdate		: do_Cupdate(&message);		break;
	  case NA_Clean		: do_Clean(&message);		break;
	  case NA_ClearNames	: do_ClearNames(&message);	break;
	  case NA_UpdateIO	: do_UpdateIO(&message);	break;
	  case NA_GetLinkMode	: do_GetLinkMode(&message);	break;
	  case NA_Terminate	: do_Terminate(&message);	break;
	    
d163 3
a165 3
	  case NA_TransputerBoot	: do_TransputerBoot(&message, FALSE);	break;
	  case NA_ParsytecBoot	: do_TransputerBoot(&message, TRUE); 	break;
	  case NA_ParsytecReset	: do_ParsytecReset(&message);		break;
d167 1
a167 1
	    
d169 1
a169 1
	  case NA_C40Boot		: do_C40Boot(&message);		break;
d171 30
a200 30
	    
	    default : IOdebug("Netagent(%s): unexpected request 0x%x", ProcessorName,
			      message.FnRc);
	    Exit(0x100);
	  }
      }
  }
  
  /**
   *** If there are processor failures then the netagent may lose communication
   *** with the Network Server. The netagent should fail silently, as the
   *** Network Server contains recovery code to restart the agent etc.
   **/
  static void	CommunicationsBreakdown(int x)
  { /* IOdebug("netagent(%s): comms breakdown %d", ProcessorName, x); */
    Exit(0x100 | x);
  }
  
  /**
   *** Send a reply message
   **/
  static void	Reply(NA_Message *message, int rc, int size, BYTE *data)
  { message = message;
    if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
      CommunicationsBreakdown(3);
    if (size > 0)
      if (Write(Stdout, data, size, ReplyTimeout) ne size)
	CommunicationsBreakdown(4);
  }
  /*}}}*/
d202 15
a216 15
  /*{{{  main() : receive requests via message passing */
  /*{{{  forward declarations and statics */
  /* This variable is used to keep track of the last received	*/
  /* message. If no message is received for a certain period of	*/
  /* time (30 seconds) the netagent aborts.			*/
  static word		LastMessage;
  
  static void		do_open(ServInfo *servinfo);
  
  static ObjNode		Netagent_Root;
  static DispatchInfo Netagent_Info = {
      (DirNode *)	&Netagent_Root,
      NullPort,
      SS_NetServ,
      Null(char),
d219 27
a245 28
	    { do_open,		3000 },
	      { InvalidFn,		2000 },	/* Create	*/
	      { DoLocate,		2000 },
	      { DoObjInfo,		2000 },
	      { InvalidFn,		2000 },	/* ServerInfo	*/
	      { InvalidFn,		2000 },	/* Delete	*/
	      { InvalidFn,		2000 },	/* Rename	*/
	      { InvalidFn,		2000 },	/* Link		*/
	      { InvalidFn,		2000 },	/* Protect	*/
	      { InvalidFn,		2000 },	/* SetDate	*/
	      { InvalidFn,		2000 }, /* Refine	*/
	      { InvalidFn,		2000 },	/* CloseObj	*/
	      { InvalidFn,		2000 },	/* Revoke	*/
	      { InvalidFn,		2000 },	/* Reserved1	*/
	      { InvalidFn,		2000 },	/* Reserved2	*/
	  }
    };
  /*}}}*/
  /*{{{  monitor thread, to abort the netagent if necessary */
  static void netagent_monitor(void)
  { LastMessage	= GetDate();
    
    forever
      { Delay(5 * OneSec);
	if ((GetDate() - LastMessage) > 30)
	  { AbortPort(Netagent_Info.ReqPort, EC_Fatal);
	    break;
	  }
d247 68
a314 67
  }
  /*}}}*/
  /*{{{  do_open() */
  static void do_open(ServInfo *servinfo)
  { MCB		*m	= servinfo->m;
    MsgBuf	*r;
    ObjNode	*f;
    Port		 stream_port;
    NA_Message	*message= (NA_Message *) m->Control;
    BYTE		*data	= m->Data;
    
    f = GetTarget(servinfo);
    if (f == Null(ObjNode))
      { ErrorMsg(m, EO_File); return; }
    
    r = New(MsgBuf);
    if (r eq Null(MsgBuf))
      { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Message); return; }
    
    FormOpenReply(r, m, f, Flags_Closeable, servinfo->Pathname);
    r->mcb.MsgHdr.Reply	= stream_port	= NewPort();
    PutMsg(&r->mcb);
    Free(r);
    
    f->Account++;
    UnLockTarget(servinfo);
    
    forever
      { word	errcode;
	
	m->MsgHdr.Dest	= stream_port;
	m->Timeout		= 30 * OneSec;
	m->Data		= data;
	m->Control		= (WORD *) message;
	errcode		= GetMsg(m);
	m->MsgHdr.FnRc	= SS_NetServ;
	
	if (errcode < Err_Null) break;	/* exit on any error */
	if ((errcode & FC_Mask) eq FC_GSP)
	  { if ((errcode & FG_Mask) eq FG_Close)
	      { if (m->MsgHdr.Reply ne NullPort)
		  { m->MsgHdr.FnRc	= 0;
		    ErrorMsg(m, Err_Null);
		  }
	      }
	  else
	    ErrorMsg(m, EC_Error + EG_Invalid + EO_Message);
	    break;
	  }
	
	message		= (NA_Message *) m->Control;
	message->Data	= m->Data;
	LastMessage	= GetDate();
	
	switch(message->FnRc)
	  {	case NA_Quit		: /* wait for the close */
		case NA_Noop		: /* Just keep running */	break;
		case NA_SetLinkMode	: do_SetLinkMode(message);	break;
		case NA_Protect		: do_Protect(message);		break;
		case NA_Revoke		: do_Revoke(message);		break;
		case NA_Cupdate		: do_Cupdate(message);		break;
		case NA_Clean		: do_Clean(message);		break;
		case NA_ClearNames	: do_ClearNames(message);	break;
		case NA_UpdateIO	: do_UpdateIO(message);		break;
		case NA_GetLinkMode	: do_GetLinkMode(message);	break;
		case NA_Terminate	: do_Terminate(message);	break;
		  
d316 3
a318 3
		case NA_TransputerBoot	: do_TransputerBoot(message, FALSE);	break;
		case NA_ParsytecBoot	: do_TransputerBoot(message, TRUE); 	break;
		case NA_ParsytecReset	: do_ParsytecReset(message);		break;
d320 1
a320 1
		  
d322 1
a322 1
		case NA_C40Boot		: do_C40Boot(message);		break;
d324 4
a327 5
		  
		  default : IOdebug("Netagent(%s): unexpected request 0x%x", ProcessorName,
				    message->FnRc);
		  Exit(0x100);
		}
d329 25
a353 3
    
    if (--(f->Account) eq 0)
      AbortPort(Netagent_Info.ReqPort, EC_Fatal);
d355 15
a369 12
  /*}}}*/
  /*{{{  Reply() */
  static void Reply(NA_Message *message, int fnrc, int size, BYTE *data)
  { MCB	*m;
    
    /* The NA_Message is the control vector. I can step	*/
    /* back to get the MCB.					*/
    m = (MCB *) ((BYTE *) message - sizeof(MCB));
    InitMCB(m, 0, m->MsgHdr.Reply, NullPort, fnrc);
    m->MsgHdr.DataSize	= size;
    m->Data		= data;
    PutMsg(m);
d371 10
a380 34
  /*}}}*/
  
  int main(void)
  { Object	*nametable_entry;
    
      { extern int SafetySize; /* in the server library */
	SafetySize = 0;
      }
    InitNode(&Netagent_Root, ".netagent", Type_File, 0, DefFileMatrix);
    InitList(&Netagent_Root.Contents);
    Netagent_Root.Parent	= Null(DirNode);
    
    MachineName(ProcessorName);
    
      { NameInfo	 info;
	Object	*this_processor = Locate(Null(Object), ProcessorName);
	info.Port		= Netagent_Info.ReqPort	= NewPort();
	info.Flags		= Flags_StripName;
	info.Matrix		= DefNameMatrix;
	info.LoadData	= NULL;    
	nametable_entry	= Create(this_processor, ".netagent", Type_Name,
				 sizeof(NameInfo), (BYTE *) &info);
	Close(this_processor);
      }
    
    if (nametable_entry ne Null(Object))
      { Fork(2000, &netagent_monitor, 0);
	Dispatch(&Netagent_Info);
	Delete(nametable_entry, Null(char));  /* after an AbortPort() */
      }
    
    Exit(0);
  }
  /*}}}*/
d382 6
a387 6
  /*{{{  Set link mode */
  /**
   *** Set the link specified by Arg1 to the mode specified by Arg2. This mode
   *** may be 0, 1, 2, or 3. For now ignore any errors.
   **/
  /*{{{  hardware link resets */
d389 8
a396 8
  /* perform resetch_()'s on a particular link		*/
  static void reset_link(int link)
  { int	x;
    int	*links	= (int *) MinInt;
    
    if ((x = resetch_(links[link])) != MinInt) runp_(x);
    if ((x = resetch_(links[link + 4])) != MinInt) runp_(x);
  }
d398 3
a400 3
  static void reset_link(int link)
  { link = link;
  }
d402 7
a408 1
  /*}}}*/
d410 9
a418 15
  static void	do_SetLinkMode(NA_Message *message)
  { int		link = message->Arg1;
    int		mode = message->Arg2;
    LinkInfo	info;
    LinkConf	conf;
    
    if (LinkData(link, &info) < Err_Null) return;
    conf.Id	= info.Id;
    conf.Flags	= info.Flags | Link_Flags_report;
    
    /* A dumb link that has been allocated must not be changed. */
    if ((info.Mode eq Link_Mode_Dumb) && (info.State eq Link_State_Running))
      goto done;
    
    /* If the link was not connected or dumb, reset the hardware now*/
d420 5
a424 5
    /* BLV - this causes bootstrap failures during the cross-link	*/
    /* phase. This is highly suspicious, as the link guardian	*/
    /* should not be touching the link at the moment.		*/
    if (info.Mode ne Link_Mode_Intelligent)
      reset_link(link);
d426 45
a470 45
    
    switch(mode)
      { case RmL_NotConnected :
	  conf.Mode	= Link_Mode_Null;
	  conf.State	= Link_State_Null;
	  break;
	  
	case RmL_Dumb :
	  conf.Mode	= Link_Mode_Dumb;
	  conf.State	= Link_State_Dumb;
	  break;
	  
	case RmL_Running :
	  conf.Mode	= Link_Mode_Intelligent;
	  conf.State	= Link_State_Running;
	  break;
	  
	case RmL_Pending :
	  /* Unfortunately the Network Server does not	*/
	  /* currently keep track of which links were used*/
	  /* for bootstrap. Hence it could try to set	*/
	  /* bootlinks back to pending mode...		*/
	  conf.Mode	= Link_Mode_Intelligent;
	  if ((info.Mode eq Link_Mode_Intelligent) &&
	      (info.State eq Link_State_Running))
	    conf.State = Link_State_Running;
	  else
	    conf.State	= Link_State_Dead;
	  break;
	  
	case RmL_Dead :
	  conf.Mode	= Link_Mode_Intelligent;
	  conf.State	= Link_State_Crashed;
	  break;
	  
	  default	  : return;
	}
    
    /* Configure the link. Then possibly enable the link or reset	*/
    /* the link hardware.						*/
    if (Configure(conf) < Err_Null)
      IOdebug("netagent(%s): failed to configure link %d", ProcessorName, link);
    elif ((mode eq RmL_Running) &&
	  ((info.Mode ne Link_Mode_Intelligent) || (info.State ne Link_State_Running)))
      EnableLink(link);
d472 4
a475 4
    /* BLV - this causes reboots to fail. I suspect that the link	*/
    /* guardian is still timing out, i.e. the configure does not	*/
    /* block until the link guardian has setttled down.		*/
    elif ((mode ne RmL_Running) && (mode ne RmL_Pending))
d478 60
a537 5
    
  done:
    
    Reply(message, RmE_Success, 0, NULL);
  }
d539 2
a540 57
  /*}}}*/
  /*{{{  Get link mode */
  /**
   *** Get the current link mode
   **/
  static void	do_GetLinkMode(NA_Message *message)
  { int		link = message->Arg1;
    int		mode;
    LinkInfo	info;
    
    if (LinkData(link, &info) < Err_Null)
      { Reply(message, RmE_BadLink, 0, NULL); return; }
    
    switch(info.Mode)
      { case	Link_Mode_Null : mode = RmL_NotConnected; break;
      case	Link_Mode_Dumb : mode = RmL_Dumb; break;
      case	Link_Mode_Intelligent :
	if (info.State eq Link_State_Running)
	  mode = RmL_Intelligent;
	elif (info.State eq Link_State_Dead)
	  mode = RmL_Pending;
	else
	  mode = RmL_Dead;
	break;
	
	default :	Reply(message, RmE_BadLink, 0, NULL);
	return;
      }
    
    Reply(message, RmE_Success, sizeof(WORD), (BYTE *) &mode);
  }
  /*}}}*/
  /*{{{  Protect processor */
  /**
   *** do_Protect(). This is used to set up the protection needed. The routine
   *** should return three capabilities. The first is the owner capability,
   *** which is passed on to the Taskforce Manager when the processor gets
   *** allocated. The second is read-only, which may or may not be handed out.
   *** The third is the full capability, which only the Network
   *** Server needs. This full capability is the only capability in the whole
   *** network which allows the access matrix to be altered again, and hence
   *** it may be needed by this routine.
   **/
  static void	do_Protect(NA_Message *message)
  { Matrix	matrix		= (Matrix) message->Arg1;
    Capability	*full_cap	= (Capability *) message->Data;
    Capability	result[3];
    Object	*processor;
    word		*temp;
    
    memset((void *) result, 0, 3 * sizeof(Capability));
    message->FnRc = Err_Null;
    
    temp = (word *) full_cap;
    
    if ((temp[0] eq 0) && (temp[1] eq 0))
      {	/* the processor has just been booted, and this is the first	*/
d544 4
a547 5
	processor = Locate(Null(Object), ProcessorName);
	if (processor eq Null(Object))
	  { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
	    goto done;
	  }
d549 3
a551 2
    else
      {	/* The protection is being reset. This means that the existing	*/
d553 4
a556 5
	processor = NewObject(ProcessorName, full_cap);
	if (processor eq Null(Object))
	  { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
	    goto done;
	  }
d558 74
d633 37
a669 110
    /* Remember the full capability, including alter access		*/
    result[2] = processor->Access;
    
    /* Now refine the access to produce a capability for the owner	*/
    if (Refine(processor, ~AccMask_A) < Err_Null)
      { 
	message->FnRc = Result2(processor);
	goto done;
      }
    result[0] = processor->Access;
    
    /* Go back to alter access, and produce a read-only capability */
    processor->Access = result[2];
    if (Refine(processor, AccMask_R | AccMask_Z) < Err_Null)
      {
	message->FnRc = Result2(processor);
	goto done;
      }
    result[1] = processor->Access;
    
    /* Go back to alter access, and protect the processor */
    processor->Access = result[2];
    if (Protect(processor, Null(char), matrix) < Err_Null) 
      { 
	message->FnRc = Result2(processor);
	goto done;
      }
    
  done:
    Reply(message, message->FnRc,
	  (message->FnRc eq Err_Null) ? 3 * sizeof(Capability) : 0,
	  (BYTE *) result);
  }
  /*}}}*/
  /*{{{  Revoke capabilities */
  /**
   *** Currently a no-op
   **/
  static void	do_Revoke(NA_Message *message)
  { message = message;
  }
  /*}}}*/
  /*{{{  Update processor's name */
  /**
   *** Update the name of a processor. For example, if the current name is /00
   *** change it to /Net/00. Arg1 contains the length of the new network name.
   **/
  static void	do_Cupdate(NA_Message *message)
  { Object	*processor	= Null(Object);
    WORD	rc;
    
    processor	= Locate(Null(Object), ProcessorName);
    if (processor eq Null(Object))
      { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }
    
    rc = Rename(processor, Null(char), message->Data);
    
  done:
    Reply(message, rc, 0, NULL);
    if (processor ne Null(Object)) Close(processor);
  }
  /*}}}*/
  /*{{{  Update neighbour's (I/O processor) name */
  /**
   *** Update the name of an I/O processor at the other end of the specified
   *** link. For example, change it from /IO to /Net/IO.
   **/
  static void	do_UpdateIO(NA_Message *message)
  { int		link = message->Arg1;
    char		linkbuf[10];	/* link.267\0 */
    Object	*processor	= Null(Object);
    int		rc;
    
    processor	= Locate(Null(Object), ProcessorName);
    if (processor eq Null(Object))
      { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }
    
    strcpy(linkbuf, "link.");
    if (link eq 0)
      strcat(linkbuf, "0");	/* addint() does not cope with 0 */
    else
      addint(linkbuf, link);
    
    rc = Rename(processor, linkbuf, message->Data);
    
  done:
    Reply(message, rc, 0, NULL);
    if (processor ne Null(Object)) Close(processor);  
  }
  /*}}}*/
  /*{{{  Clean out processor */
  /**-----------------------------------------------------------------------------
   *** This routine should clean out the processor.
   *** Essentially it performs several walkdirs.
   *** 3) two WalkDirs of /tasks to find any programs that should not be running.
   ***    There are occasional problems killing off programs so the final
   ***    kill_task is not done until the end, after the reply is sent.
   *** 2) a WalkDir of /loader to delete any unused libraries
   *** 3) possibly a WalkDir of /pipe if the pipe server is running
   *** 4) ditto for /fifo
   *** 5) ditto for /ram
   **/
  static void	WalkDir(Object *x, VoidFnPtr fn);
  static bool	pipe_running	= FALSE;
  static bool	fifo_running	= FALSE;
  static bool	ram_running	= FALSE;
  static void	kill_task(Object *task);
  static void	kill_something(Object *whatever);
  static word	cleaning_date;
  
@


1.30
log
@changed names of all WP_ functions to MP_
@
text
@d6 1
a6 1
--             Copyright (C) 1990, Perihelion Software Ltd.             --
d18 3
a20 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/netagent.c,v 1.29 1992/11/24 17:28:43 nick Exp paul $";
d23 7
a29 7
*** The netagent can be compiled to work in two different ways, affecting
*** the way in which it communicates with the Network Server. The first
*** option involves a pipe created by the Network Server, supplied in an
*** environment. The second involves the netagent installing itself as
*** as a server and performing low-level message transactions. This
*** compile-time option determines the communication.
**/
d60 2
a61 2
*** Ensure that the C library (plus posix and fplib) are not loaded
**/
d63 23
a85 23
{ VoidFnPtr junk;
  junk = &_stack_error;
  IOdebug("Netagent: stack overflow in %s at %x",p->Name,&p);
  Exit(0x0080 | SIGSTAK);
}
/*}}}*/
/*{{{  Prototypes etc. */
/**
*** These routines support the various requests. The Network Server sends
*** NA_Message structures to the netagent which include a function code.
*** The structure and the various function codes are defined in netaux.h
*** There is a separate handler for every function code. Particular
*** processors may be unable to cope with particular function codes.
**/
static void	do_SetLinkMode(NA_Message *);
static void	do_Protect(NA_Message *);
static void	do_Revoke(NA_Message *);
static void	do_Cupdate(NA_Message *);
static void	do_Clean(NA_Message *);
static void	do_ClearNames(NA_Message *);
static void	do_UpdateIO(NA_Message *);
static void	do_GetLinkMode(NA_Message *);
static void	do_Terminate(NA_Message *);
d87 3
a89 3
static void	do_TransputerBoot(NA_Message *, bool);
static void	do_ParsytecReset(NA_Message *);
static void	Parsytec_Reset(int link);
d92 1
a92 1
static void	do_C40Boot(NA_Message *);
d94 3
a96 3

static char	ProcessorName[IOCDataMax];

d100 1
a100 1
/*}}}*/
d102 62
a163 62
/*{{{  main() : receive requests from the Network Server via a pipe */
/**
*** Get the environment and the standard streams, which are a pipe from and
*** to the network server. The same pipe is used bi-directionally.
*** Then loop for ever reading request packets and invoke suitable handling
*** routines.
**/
static Stream	*Stdin;
static Stream	*Stdout;
static BYTE	Datavec[IOCDataMax];
static void	CommunicationsBreakdown(int);

int main(void)
{ Environ	env;
  NA_Message	message;
  word		rc;
  
  if (GetEnv(MyTask->Port, &env) < Err_Null)
   { IOdebug("netagent: failed to receive environment");
     Exit(0x100);
   }
  if ((env.Strv[0] eq Null(Stream)) || (env.Strv[0] eq (Stream *) MinInt))
   { IOdebug("netagent: failed to get communication streams");
     Exit(0x100);
   }
  Stdin		= env.Strv[0];
  Stdout    	= env.Strv[0];
  MachineName(ProcessorName);

	/* Initial communication */
  if (Read(Stdin, (BYTE *) &rc, sizeof(word), 5 * OneSec) ne sizeof(word))
   { IOdebug("netagent(%s): failed to get initial data", ProcessorName);
     Exit(0x100);
   }
  if (Write(Stdin, (BYTE *) &rc, sizeof(word), 5 * OneSec) ne sizeof(word))
   { IOdebug("netagent(%s): failed to respond to initial data", ProcessorName);
     Exit(0x100);
   }

  forever
   { if (Read(Stdin, (BYTE *) &message, sizeof(NA_Message), MainReadTimeout) ne
   		 sizeof(NA_Message))
	CommunicationsBreakdown(1);

     message.Data = Datavec;
     if (message.Size > 0)
      if (Read(Stdin, message.Data, message.Size, ExtraReadTimeout) ne message.Size)
       CommunicationsBreakdown(2);
    
    switch(message.FnRc)
     {	case NA_Quit		: Exit(0);
	case NA_Noop		: /* Just keep running */	break;
	case NA_SetLinkMode	: do_SetLinkMode(&message);	break;
	case NA_Protect		: do_Protect(&message);		break;
	case NA_Revoke		: do_Revoke(&message);		break;
	case NA_Cupdate		: do_Cupdate(&message);		break;
	case NA_Clean		: do_Clean(&message);		break;
	case NA_ClearNames	: do_ClearNames(&message);	break;
	case NA_UpdateIO	: do_UpdateIO(&message);	break;
	case NA_GetLinkMode	: do_GetLinkMode(&message);	break;
	case NA_Terminate	: do_Terminate(&message);	break;

d165 3
a167 3
	case NA_TransputerBoot	: do_TransputerBoot(&message, FALSE);	break;
	case NA_ParsytecBoot	: do_TransputerBoot(&message, TRUE); 	break;
	case NA_ParsytecReset	: do_ParsytecReset(&message);		break;
d169 1
a169 1

d171 1
a171 1
	case NA_C40Boot		: do_C40Boot(&message);		break;
d173 30
a202 30

       default : IOdebug("Netagent(%s): unexpected request 0x%x", ProcessorName,
       				message.FnRc);
		 Exit(0x100);
     }
   }
}

/**
*** If there are processor failures then the netagent may lose communication
*** with the Network Server. The netagent should fail silently, as the
*** Network Server contains recovery code to restart the agent etc.
**/
static void	CommunicationsBreakdown(int x)
{ /* IOdebug("netagent(%s): comms breakdown %d", ProcessorName, x); */
  Exit(0x100 | x);
}

/**
*** Send a reply message
**/
static void	Reply(NA_Message *message, int rc, int size, BYTE *data)
{ message = message;
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(3);
  if (size > 0)
   if (Write(Stdout, data, size, ReplyTimeout) ne size)
    CommunicationsBreakdown(4);
}
/*}}}*/
d204 15
a218 15
/*{{{  main() : receive requests via message passing */
/*{{{  forward declarations and statics */
	/* This variable is used to keep track of the last received	*/
	/* message. If no message is received for a certain period of	*/
	/* time (30 seconds) the netagent aborts.			*/
static word		LastMessage;

static void		do_open(ServInfo *servinfo);

static ObjNode		Netagent_Root;
static DispatchInfo Netagent_Info = {
	(DirNode *)	&Netagent_Root,
	NullPort,
	SS_NetServ,
	Null(char),
d221 28
a248 27
		{ do_open,		3000 },
		{ InvalidFn,		2000 },	/* Create	*/
		{ DoLocate,		2000 },
		{ DoObjInfo,		2000 },
		{ InvalidFn,		2000 },	/* ServerInfo	*/
		{ InvalidFn,		2000 },	/* Delete	*/
		{ InvalidFn,		2000 },	/* Rename	*/
		{ InvalidFn,		2000 },	/* Link		*/
		{ InvalidFn,		2000 },	/* Protect	*/
		{ InvalidFn,		2000 },	/* SetDate	*/
		{ InvalidFn,		2000 }, /* Refine	*/
		{ InvalidFn,		2000 },	/* CloseObj	*/
		{ InvalidFn,		2000 },	/* Revoke	*/
		{ InvalidFn,		2000 },	/* Reserved1	*/
		{ InvalidFn,		2000 },	/* Reserved2	*/
	}
};
/*}}}*/
/*{{{  monitor thread, to abort the netagent if necessary */
static void netagent_monitor(void)
{ LastMessage	= GetDate();

  forever
   { Delay(5 * OneSec);
     if ((GetDate() - LastMessage) > 30)
      { AbortPort(Netagent_Info.ReqPort, EC_Fatal);
        break;
d250 67
a316 68
   }
}
/*}}}*/
/*{{{  do_open() */
static void do_open(ServInfo *servinfo)
{ MCB		*m	= servinfo->m;
  MsgBuf	*r;
  ObjNode	*f;
  Port		 stream_port;
  NA_Message	*message= (NA_Message *) m->Control;
  BYTE		*data	= m->Data;

  f = GetTarget(servinfo);
  if (f == Null(ObjNode))
   { ErrorMsg(m, EO_File); return; }

  r = New(MsgBuf);
  if (r eq Null(MsgBuf))
   { ErrorMsg(m, EC_Error + EG_NoMemory + EO_Message); return; }

  FormOpenReply(r, m, f, Flags_Closeable, servinfo->Pathname);
  r->mcb.MsgHdr.Reply	= stream_port	= NewPort();
  PutMsg(&r->mcb);
  Free(r);

  f->Account++;
  UnLockTarget(servinfo);

  forever
   { word	errcode;

     m->MsgHdr.Dest	= stream_port;
     m->Timeout		= 30 * OneSec;
     m->Data		= data;
     m->Control		= (WORD *) message;
     errcode		= GetMsg(m);
     m->MsgHdr.FnRc	= SS_NetServ;

     if (errcode < Err_Null) break;	/* exit on any error */
     if ((errcode & FC_Mask) eq FC_GSP)
      { if ((errcode & FG_Mask) eq FG_Close)
         { if (m->MsgHdr.Reply ne NullPort)
            { m->MsgHdr.FnRc	= 0;
	      ErrorMsg(m, Err_Null);
	    }
	 }
	else
	 ErrorMsg(m, EC_Error + EG_Invalid + EO_Message);
	break;
      }

     message		= (NA_Message *) m->Control;
     message->Data	= m->Data;
     LastMessage	= GetDate();

     switch(message->FnRc)
      {	case NA_Quit		: /* wait for the close */
	case NA_Noop		: /* Just keep running */	break;
	case NA_SetLinkMode	: do_SetLinkMode(message);	break;
	case NA_Protect		: do_Protect(message);		break;
	case NA_Revoke		: do_Revoke(message);		break;
	case NA_Cupdate		: do_Cupdate(message);		break;
	case NA_Clean		: do_Clean(message);		break;
	case NA_ClearNames	: do_ClearNames(message);	break;
	case NA_UpdateIO	: do_UpdateIO(message);		break;
	case NA_GetLinkMode	: do_GetLinkMode(message);	break;
	case NA_Terminate	: do_Terminate(message);	break;

d318 3
a320 3
	case NA_TransputerBoot	: do_TransputerBoot(message, FALSE);	break;
	case NA_ParsytecBoot	: do_TransputerBoot(message, TRUE); 	break;
	case NA_ParsytecReset	: do_ParsytecReset(message);		break;
d322 1
a322 1

d324 1
a324 1
	case NA_C40Boot		: do_C40Boot(message);		break;
d326 52
a377 4

        default : IOdebug("Netagent(%s): unexpected request 0x%x", ProcessorName,
       				message->FnRc);
		 Exit(0x100);
d379 2
a380 25
   }

  if (--(f->Account) eq 0)
   AbortPort(Netagent_Info.ReqPort, EC_Fatal);
}
/*}}}*/
/*{{{  Reply() */
static void Reply(NA_Message *message, int fnrc, int size, BYTE *data)
{ MCB	*m;

		/* The NA_Message is the control vector. I can step	*/
		/* back to get the MCB.					*/
  m = (MCB *) ((BYTE *) message - sizeof(MCB));
  InitMCB(m, 0, m->MsgHdr.Reply, NullPort, fnrc);
  m->MsgHdr.DataSize	= size;
  m->Data		= data;
  PutMsg(m);
}
/*}}}*/

int main(void)
{ Object	*nametable_entry;

  { extern int SafetySize; /* in the server library */
    SafetySize = 0;
d382 1
a382 26
  InitNode(&Netagent_Root, ".netagent", Type_File, 0, DefFileMatrix);
  InitList(&Netagent_Root.Contents);
  Netagent_Root.Parent	= Null(DirNode);

  MachineName(ProcessorName);

  { NameInfo	 info;
    Object	*this_processor = Locate(Null(Object), ProcessorName);
    info.Port		= Netagent_Info.ReqPort	= NewPort();
    info.Flags		= Flags_StripName;
    info.Matrix		= DefNameMatrix;
    info.LoadData	= NULL;    
    nametable_entry	= Create(this_processor, ".netagent", Type_Name,
		sizeof(NameInfo), (BYTE *) &info);
    Close(this_processor);
  }

  if (nametable_entry ne Null(Object))
   { Fork(2000, &netagent_monitor, 0);
     Dispatch(&Netagent_Info);
     Delete(nametable_entry, Null(char));  /* after an AbortPort() */
   }

  Exit(0);
}
/*}}}*/
d384 6
a389 6
/*{{{  Set link mode */
/**
*** Set the link specified by Arg1 to the mode specified by Arg2. This mode
*** may be 0, 1, 2, or 3. For now ignore any errors.
**/
/*{{{  hardware link resets */
d391 8
a398 8
	/* perform resetch_()'s on a particular link		*/
static void reset_link(int link)
{ int	x;
  int	*links	= (int *) MinInt;

  if ((x = resetch_(links[link])) != MinInt) runp_(x);
  if ((x = resetch_(links[link + 4])) != MinInt) runp_(x);
}
d400 3
a402 3
static void reset_link(int link)
{ link = link;
}
d404 17
a420 17
/*}}}*/

static void	do_SetLinkMode(NA_Message *message)
{ int		link = message->Arg1;
  int		mode = message->Arg2;
  LinkInfo	info;
  LinkConf	conf;
  
  if (LinkData(link, &info) < Err_Null) return;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags | Link_Flags_report;
   
	/* A dumb link that has been allocated must not be changed. */
  if ((info.Mode eq Link_Mode_Dumb) && (info.State eq Link_State_Running))
   goto done;

	/* If the link was not connected or dumb, reset the hardware now*/
d422 51
a472 51
	/* BLV - this causes bootstrap failures during the cross-link	*/
	/* phase. This is highly suspicious, as the link guardian	*/
	/* should not be touching the link at the moment.		*/
  if (info.Mode ne Link_Mode_Intelligent)
   reset_link(link);
#endif

  switch(mode)
   { case RmL_NotConnected :
   		    conf.Mode	= Link_Mode_Null;
   		    conf.State	= Link_State_Null;
   		    break;

     case RmL_Dumb :
     		    conf.Mode	= Link_Mode_Dumb;
     		    conf.State	= Link_State_Dumb;
     		    break;
     		    
     case RmL_Running :
       		    conf.Mode	= Link_Mode_Intelligent;
     		    conf.State	= Link_State_Running;
     		    break;
     
     case RmL_Pending :
     			/* Unfortunately the Network Server does not	*/
     			/* currently keep track of which links were used*/
     			/* for bootstrap. Hence it could try to set	*/
     			/* bootlinks back to pending mode...		*/
     		    conf.Mode	= Link_Mode_Intelligent;
     		    if ((info.Mode eq Link_Mode_Intelligent) &&
     		    	(info.State eq Link_State_Running))
     		     conf.State = Link_State_Running;
     		    else
		     conf.State	= Link_State_Dead;
     		    break;

     case RmL_Dead :
		    conf.Mode	= Link_Mode_Intelligent;
		    conf.State	= Link_State_Crashed;
		    break;

     default	  : return;
   }

	/* Configure the link. Then possibly enable the link or reset	*/
	/* the link hardware.						*/
  if (Configure(conf) < Err_Null)
   IOdebug("netagent(%s): failed to configure link %d", ProcessorName, link);
  elif ((mode eq RmL_Running) &&
        ((info.Mode ne Link_Mode_Intelligent) || (info.State ne Link_State_Running)))
   EnableLink(link);
d474 4
a477 4
	/* BLV - this causes reboots to fail. I suspect that the link	*/
	/* guardian is still timing out, i.e. the configure does not	*/
	/* block until the link guardian has setttled down.		*/
   elif ((mode ne RmL_Running) && (mode ne RmL_Pending))
d480 5
a484 60

done:

  Reply(message, RmE_Success, 0, NULL);
}

/*}}}*/
/*{{{  Get link mode */
/**
*** Get the current link mode
**/
static void	do_GetLinkMode(NA_Message *message)
{ int		link = message->Arg1;
  int		mode;
  LinkInfo	info;

  if (LinkData(link, &info) < Err_Null)
   { Reply(message, RmE_BadLink, 0, NULL); return; }

  switch(info.Mode)
   { case	Link_Mode_Null : mode = RmL_NotConnected; break;
     case	Link_Mode_Dumb : mode = RmL_Dumb; break;
     case	Link_Mode_Intelligent :
			     	if (info.State eq Link_State_Running)
			     	 mode = RmL_Intelligent;
			     	elif (info.State eq Link_State_Dead)
			     	 mode = RmL_Pending;
		     		else
		     		 mode = RmL_Dead;
				break;

     default :	Reply(message, RmE_BadLink, 0, NULL);
		return;
   }

  Reply(message, RmE_Success, sizeof(WORD), (BYTE *) &mode);
}
/*}}}*/
/*{{{  Protect processor */
/**
*** do_Protect(). This is used to set up the protection needed. The routine
*** should return three capabilities. The first is the owner capability,
*** which is passed on to the Taskforce Manager when the processor gets
*** allocated. The second is read-only, which may or may not be handed out.
*** The third is the full capability, which only the Network
*** Server needs. This full capability is the only capability in the whole
*** network which allows the access matrix to be altered again, and hence
*** it may be needed by this routine.
**/
static void	do_Protect(NA_Message *message)
{ Matrix	matrix		= (Matrix) message->Arg1;
  Capability	*full_cap	= (Capability *) message->Data;
  Capability	result[3];
  Object	*processor;
  word		*temp;

  memset((void *) result, 0, 3 * sizeof(Capability));
  message->FnRc = Err_Null;

  temp = (word *) full_cap;
d486 57
a542 2
  if ((temp[0] eq 0) && (temp[1] eq 0))
   {	/* the processor has just been booted, and this is the first	*/
d546 5
a550 4
     processor = Locate(Null(Object), ProcessorName);
     if (processor eq Null(Object))
      { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
        goto done;
d552 2
a553 3
   }
  else
   {	/* The protection is being reset. This means that the existing	*/
d555 24
a578 4
     processor = NewObject(ProcessorName, full_cap);
     if (processor eq Null(Object))
      { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
        goto done;
d580 91
a670 58
   }

	/* Remember the full capability, including alter access		*/
  result[2] = processor->Access;

	/* Now refine the access to produce a capability for the owner	*/
  if (Refine(processor, ~AccMask_A) < Err_Null)
   { 
     message->FnRc = Result2(processor);
     goto done;
   }
  result[0] = processor->Access;

	/* Go back to alter access, and produce a read-only capability */
  processor->Access = result[2];
  if (Refine(processor, AccMask_R | AccMask_Z) < Err_Null)
   {
     message->FnRc = Result2(processor);
     goto done;
   }
  result[1] = processor->Access;
  
	/* Go back to alter access, and protect the processor */
  processor->Access = result[2];
  if (Protect(processor, Null(char), matrix) < Err_Null) 
   { 
     message->FnRc = Result2(processor);
     goto done;
   }

done:
  Reply(message, message->FnRc,
	(message->FnRc eq Err_Null) ? 3 * sizeof(Capability) : 0,
	(BYTE *) result);
}
/*}}}*/
/*{{{  Revoke capabilities */
/**
*** Currently a no-op
**/
static void	do_Revoke(NA_Message *message)
{ message = message;
}
/*}}}*/
/*{{{  Update processor's name */
/**
*** Update the name of a processor. For example, if the current name is /00
*** change it to /Net/00. Arg1 contains the length of the new network name.
**/
static void	do_Cupdate(NA_Message *message)
{ Object	*processor	= Null(Object);
  WORD	rc;
  
  processor	= Locate(Null(Object), ProcessorName);
  if (processor eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }

  rc = Rename(processor, Null(char), message->Data);
a671 53
done:
  Reply(message, rc, 0, NULL);
  if (processor ne Null(Object)) Close(processor);
}
/*}}}*/
/*{{{  Update neighbour's (I/O processor) name */
/**
*** Update the name of an I/O processor at the other end of the specified
*** link. For example, change it from /IO to /Net/IO.
**/
static void	do_UpdateIO(NA_Message *message)
{ int		link = message->Arg1;
  char		linkbuf[10];	/* link.267\0 */
  Object	*processor	= Null(Object);
  int		rc;
    
  processor	= Locate(Null(Object), ProcessorName);
  if (processor eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }
   
  strcpy(linkbuf, "link.");
  if (link eq 0)
   strcat(linkbuf, "0");	/* addint() does not cope with 0 */
  else
   addint(linkbuf, link);
   
  rc = Rename(processor, linkbuf, message->Data);

done:
  Reply(message, rc, 0, NULL);
  if (processor ne Null(Object)) Close(processor);  
}
/*}}}*/
/*{{{  Clean out processor */
/**-----------------------------------------------------------------------------
*** This routine should clean out the processor.
*** Essentially it performs several walkdirs.
*** 3) two WalkDirs of /tasks to find any programs that should not be running.
***    There are occasional problems killing off programs so the final
***    kill_task is not done until the end, after the reply is sent.
*** 2) a WalkDir of /loader to delete any unused libraries
*** 3) possibly a WalkDir of /pipe if the pipe server is running
*** 4) ditto for /fifo
*** 5) ditto for /ram
**/
static void	WalkDir(Object *x, VoidFnPtr fn);
static bool	pipe_running	= FALSE;
static bool	fifo_running	= FALSE;
static bool	ram_running	= FALSE;
static void	kill_task(Object *task);
static void	kill_something(Object *whatever);
static word	cleaning_date;

d878 1
a878 1
static MPtr	*determine_image(char *, word *);
@


1.29
log
@Some rogue IOdebugs removed.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/netagent.c,v 1.28 1992/11/23 16:58:39 nick Exp nick $";
d1326 1
a1326 1
  if (WP_LinkOut(c40boot_size/sizeof(WORD), link, c40boot, 2 *OneSec) ne Err_Null)
d1355 1
a1355 1
  if (WP_LinkOut(image_size/sizeof(WORD), link, image, 2 * OneSec) ne Err_Null)
@


1.28
log
@Altered to use MPtrs's for access to bootstrap and nucleus. C40 bootstrap
also uses WP_LinkOut to send bootstrap and nucleus.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.26 1992/10/26 11:00:19 bart Exp $";
a1308 2
IOdebug("C40_BootLink: image %x",image);

a1315 2
IOdebug("C40_BootLink: c40boot %x size %x",c40boot,c40boot_size);
  
@


1.27
log
@quick fix to cope with GetSysBase() return changed to WPTR
@
text
@d876 1
a876 1
static BYTE	*determine_image(char *, word *);
d880 1
a880 1
static int	transputer_BootLink(word link, void *image, Config *config, word csize);
d888 1
a888 1
  BYTE		*system_image;
d896 1
a896 1
  if (system_image eq Null(BYTE)) goto done;
d898 1
a898 1
  config->ImageSize = *((word *) system_image);
d905 1
a905 1
  rc = transputer_BootLink(link, (void *) system_image, config, length);
d912 2
a913 2
  if ((strlen(nucleus_string) > 0) && (system_image ne Null(BYTE)))
   Free(system_image);
d923 1
a923 1
static	BYTE *determine_image(char *name, word *rc)
d926 1
a926 6
#ifdef __C40
/* @@@@@@ MUST CHANGE TO COPE WITH NUCLEUS ON GLOBAL BUS */
  BYTE		*image = C40CAddress(GetSysBase());
#else
  BYTE		*image = (BYTE *) GetSysBase();
#endif
d935 1
a935 1
     return(Null(BYTE));
d941 1
a941 1
     return(Null(BYTE));
d947 1
a947 1
     return(Null(BYTE));
d953 1
a953 1
     return(Null(BYTE));
d960 1
a960 1
     return(Null(BYTE));
d968 1
a968 1
     return(Null(BYTE));
d977 1
a977 1
  return(buffer);
d1072 1
a1072 1
static int transputer_BootLink(word link, void *image, Config *config, word confsize)
d1074 1
a1074 1
  void  *nboot;
d1079 3
a1081 5
  { word *sysimage	= (word *) image;
    int  offset    	= sysimage[IVecBootStrap];
    nboot		= (BYTE *) &(sysimage[IVecBootStrap]) + offset;
    nboot_size		= sysimage[IVecProcMan] - sysimage[IVecBootStrap] + 4;
  }
d1083 1
d1088 1
a1088 1
  if (LinkOut(nboot_size, link, nboot, 2 *OneSec) ne Err_Null)
d1103 2
a1104 2
  image_size = *((word *) image);
  if (LinkOut(image_size, link, image, 3 * OneSec) ne Err_Null)
d1126 1
a1126 1
static BYTE	*determine_image(char *, word *);
d1130 1
a1130 1
static int	C40_BootLink(word link, BYTE *image, C40_Bootstrap *);
d1137 1
a1137 1
  BYTE		*system_image;
d1144 1
a1144 1
  if (system_image eq Null(BYTE)) goto done;
d1157 2
a1158 2
  if ((boot_info->Nucleus ne 0) && (system_image ne Null(BYTE)))
   Free(system_image);
d1167 1
a1167 1
static	BYTE *determine_image(char *name, word *rc)
d1170 1
a1170 1
  BYTE		*image = (BYTE *) GetSysBase();
d1179 1
a1179 1
     return(Null(BYTE));
d1185 1
a1185 1
     return(Null(BYTE));
d1191 1
a1191 1
     return(Null(BYTE));
d1197 1
a1197 1
     return(Null(BYTE));
d1204 1
a1204 1
     return(Null(BYTE));
d1212 1
a1212 1
     return(Null(BYTE));
d1221 1
a1221 1
  return(buffer);
d1302 1
a1302 1
static int C40_BootLink(word link, BYTE *image, C40_Bootstrap *boot_info)
d1304 1
a1304 1
  void  *c40boot;
d1309 2
d1314 3
a1316 5
  { word *sysimage	= (word *) image;
    int  offset    	= sysimage[IVecBootStrap];
    c40boot		= (BYTE *) &(sysimage[IVecBootStrap]) + offset;
    c40boot_size	= sysimage[IVecProcMan] - sysimage[IVecBootStrap] + 4;
  }
d1318 2
d1330 1
a1330 1
  if (LinkOut(c40boot_size, link, c40boot, 2 *OneSec) ne Err_Null)
d1358 2
a1359 2
  image_size = *((word *) image);
  if (LinkOut(image_size, link, image, 2 * OneSec) ne Err_Null)
@


1.26
log
@minor optimisation
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.25 1992/10/07 13:31:18 bart Exp $";
d926 4
d931 1
@


1.25
log
@Re-arranged the cleaners to reduce the probability of crashes.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: netagent.c,v 1.24 92/09/19 12:03:11 bart Exp $";
a774 1
  Object	*temp;
d778 4
a782 2
  if (!strncmp(name, "Loader.", 7))	return;
  if (!strncmp(name, "Null.", 5))	return;
d784 1
a784 3
  if (!strncmp(name, "ProcMan.", 8))	return;
  if (!strncmp(name, "Ram.", 4)) { ram_running = TRUE; return; }
  if (!strncmp(name, "login.", 6)) return;
d790 1
a790 4
  temp = Locate(task, Null(char));
  if (temp eq Null(Object)) return;
  (void) Delete(temp, Null(char));
  Close(temp);
@


1.24
log
@Fixed NULL pointer problem in the new C40 bootstrap code
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.23 1992/09/15 18:22:32 bart Exp bart $";
d654 3
a656 1
*** 1) two WalkDirs of /tasks to find any programs that should not be running
a666 1
static void	kill_task2(Object *task);
d677 1
a677 1
   { WalkDir(procman, &kill_task);
d679 1
a679 2
     WalkDir(procman, &kill_task2);
     Close(procman); 
d710 5
d773 1
a773 1
static	void gen_kill_task(Object *task, int addition)
a792 1
  temp->FnMod |= addition;
a794 8
}

static void kill_task(Object *task)
{ gen_kill_task(task, 1);
}

static void kill_task2(Object *task)
{ gen_kill_task(task, 2);
@


1.23
log
@In theory the C40 bootstrap code now supports IDRom information supplied
in the resource map. This is currently untested.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.22 1992/09/01 11:23:06 bart Exp $";
d1183 1
a1183 1
  if (strlen(name) eq 0) return(image);
@


1.22
log
@Increased the number of loops after sending in nboot.i, just to be on the
safe side.
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/netagent.c,v 1.20 1992/07/09 17:23:33 paul Exp $";
d43 1
d1139 1
a1139 1
static int	C40_BootLink(word link, BYTE *image, Config *config, word csize);
d1142 4
a1145 5
{ BYTE		*nucleus_string	= message->Data;
  Config	*config;
  int		link = message->Arg1;
  int		length;
  word		rc = Err_Null;
d1148 5
a1152 6
  length = strlen(nucleus_string) + 1;
  length = (length + 3) & ~3;
  config = (Config *) &(nucleus_string[length]);
  length = message->Size - length;	/* now length of config vector */

  system_image = determine_image(nucleus_string, &rc);
d1155 2
a1156 2
  config->ImageSize	= *((word *) system_image);
  config->Date		= GetDate();
d1159 1
a1159 1
  rc = C40_BootLink(link, system_image, config, length);
d1166 1
a1166 1
  if ((strlen(nucleus_string) > 0) && (system_image ne Null(BYTE)))
d1307 3
a1309 5
*** 6) Send in the whole system image
*** 7) Send in the configuration vector
***
*** At some point some of the various magic numbers may have to be set
*** more intelligently.
d1311 1
a1311 1
static int C40_BootLink(word link, BYTE *image, Config *config, word confsize)
d1313 2
a1314 2
  void  *nboot;
  word  nboot_size;
d1317 4
a1320 1
    
d1323 2
a1324 2
    nboot		= (BYTE *) &(sysimage[IVecBootStrap]) + offset;
    nboot_size		= sysimage[IVecProcMan] - sysimage[IVecBootStrap] + 4;
d1329 1
a1329 1
  temp[2] = nboot_size / sizeof(WORD);	/* Block size			  */
d1337 1
a1337 1
  if (LinkOut(nboot_size, link, nboot, 2 *OneSec) ne Err_Null)
d1347 1
a1347 1
   return(Boot_ControlByte | EG_Timeout | EC_Error | SS_NetServ);
d1351 1
a1351 1
   return(Boot_Clear1 | EG_Timeout | EC_Error | SS_NetServ);
d1353 1
a1353 1
   return(Boot_Clear2 | EG_Timeout | EC_Error | SS_NetServ);
d1356 2
a1357 1
  temp[0] = 0; /* should be set with HW_xxx flags in config.h */
d1359 4
a1362 2
  if ((rc = LinkOut(4, link, temp, 2 * OneSec)) ne Err_Null)
   return(Boot_Clear3 | EG_Timeout | EC_Error | SS_NetServ);
d1370 1
a1370 1
  if (LinkOut(sizeof(WORD), link, (BYTE *) &confsize, 2 * OneSec) ne Err_Null)
d1374 1
a1374 1
  if (LinkOut(confsize, link, (BYTE *) config, 2 * OneSec) ne Err_Null)
@


1.21
log
@Fix to allow for resetch's inside nboot.i
@
text
@d1104 1
a1104 1
  for (rc = 0; rc < 255; rc++)
@


1.20
log
@fixes for C40 booting - multiprocessor C40 systems are go!
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /m/giga/HeliosRoot/Helios/network/RCS/netagent.c,v 1.19 1992/05/08 16:36:25 bart Exp paul $";
d1098 8
@


1.19
log
@1) changed the communication between netserv and netagent from pipes to
   client-server message passing
2) folded the network server sources
@
text
@d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.18 1992/03/26 16:28:29 bart Exp $";
d1298 4
a1301 2
*** 4) Send in the whole system image
*** 5) Send in the configuration vector
d1322 1
a1322 1
  temp[3] = 0x002ff800;			/* Load address			  */
d1324 1
d1328 1
d1337 1
d1340 14
a1353 1
  
d1358 1
d1362 1
@


1.18
log
@cleaned up Parsytec-specific delays
@
text
@d13 1
a13 2
--	enabling/disabling links. It communicates with the Network	--
--	Server via a pipe, i.e. stdin/stdout.				--
d18 1
a18 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.17 1992/03/25 18:19:15 bart Exp $";
d20 10
d33 1
d42 1
a73 1
static void	do_Quit(NA_Message *);
a91 3
static void	CommunicationsBreakdown(int);
static Stream	*Stdin;
static Stream	*Stdout;
a96 2


d98 2
a99 1
/*{{{  main() : receive requests from the Network Server */
d106 5
d137 1
a137 1
   
d142 5
d149 1
a149 1
     {	case NA_Quit		: do_Quit(&message); 		break;
d184 2
a185 2
{ x = x;
  Exit(0x100);
d187 12
d200 47
a246 5
/*{{{  Quit */
static void	do_Quit(NA_Message *message)
{ (void) Close(Stdin);
  Exit(0x100);
  message = message;
d249 132
d386 6
d393 10
a407 1
  int		rc;
a411 1

d417 7
a423 9
#ifdef __TRAN
	/* If the link was not connected or dumb, reset the hardware	*/
	/* Similarly, if the intended mode is not intelligent		*/
  if ((info.Mode ne Link_Mode_Intelligent) ||
      ((mode ne RmL_Running) && (mode ne RmL_Pending)))
   { word *links = (word *) MinInt;
     resetch_(&(links[link]));
     resetch_(&(links[link + 4]));
   }
d463 2
d470 7
d480 1
a480 3
  rc = 0;
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(15);
a491 1
  int		rc;
d494 1
a494 1
   { rc = RmE_BadLink; goto done; }
d507 3
a509 1
     default : rc = RmE_BadLink; goto done;
d512 1
a512 8
  rc = RmE_Success;     

done:
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(14);
  if (rc eq RmE_Success)
   if (Write(Stdout, (BYTE *) &mode, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
    CommunicationsBreakdown(15);  
d527 2
a528 2
{ Matrix	matrix = (Matrix) message->Arg1;
  Capability	full_cap;
a529 1
  char		proc_name[IOCDataMax];
d533 1
a533 1
  memset((void *) result, 0, 2 * sizeof(Capability));
d536 1
a536 7
	/* Read a capability from the Network Server */      
  if (Read(Stdin, (BYTE *) &full_cap, sizeof(Capability), ExtraReadTimeout) ne
  	sizeof(Capability))
   CommunicationsBreakdown(5);

  MachineName(proc_name);
  temp = (word *) &full_cap;
d543 1
a543 1
     processor = Locate(Null(Object), proc_name);
d552 1
a552 1
     processor = NewObject(proc_name, &full_cap);
d588 3
a590 8
  if (Write(Stdout, (BYTE *) &(message->FnRc), sizeof(word), ReplyTimeout)
      ne sizeof(word))
   CommunicationsBreakdown(6);
  if (message->FnRc eq Err_Null)
   if (Write(Stdout, (BYTE *) result, 3 * sizeof(Capability), ReplyTimeout)
       ne (3 * sizeof(Capability)))
    CommunicationsBreakdown(7);
     
d607 1
a607 3
{ char		*buffer		= (char *) Malloc(message->Arg1);
  char		*curname	= (char *) Malloc(IOCDataMax);
  Object	*processor	= Null(Object);
d610 1
a610 9
  if ((buffer eq Null(char)) || (curname eq Null(char)))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }

  if (Read(Stdin, (BYTE *) buffer, message->Arg1, ExtraReadTimeout) ne
  	message->Arg1)
   CommunicationsBreakdown(8);

  MachineName(curname);
  processor	= Locate(Null(Object), curname);
d614 1
a614 1
  rc = Rename(processor, Null(char), buffer);
d617 1
a617 4
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(9);
  if (buffer ne Null(char)) Free(buffer);
  if (curname ne Null(char)) Free(curname);
a627 2
  char		*buffer		= (char *) Malloc(message->Arg2);
  char		*procname 	= (char *) Malloc(IOCDataMax);
d632 1
a632 9
  if ((buffer eq Null(char)) || (procname eq Null(char)))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }
  
  if (Read(Stdin, (BYTE *) buffer, message->Arg2, ExtraReadTimeout) ne
  	message->Arg2)
   CommunicationsBreakdown(10);
   
  MachineName(procname);
  processor	= Locate(Null(Object), procname);
d642 1
a642 1
  rc = Rename(processor, linkbuf, buffer);
d645 1
a645 4
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(11);
  if (buffer ne Null(char)) Free(buffer);
  if (procname ne Null(char)) Free(procname);
d669 1
a669 2
{ WORD	rc = Err_Null;
  Object	*procman = Locate(Null(Object), "/tasks");
d707 2
a708 3
   
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(12);
d837 3
a839 1
{ Close(Stdin);
d842 2
d890 1
a890 1
{ BYTE		*nucleus_string;
a896 7
  nucleus_string = Malloc(message->Arg2);
  if (nucleus_string eq Null(BYTE))
   { IOdebug("Netagent: out of memory"); Exit(0x100); }
  if (Read(Stdin, nucleus_string, message->Arg2, ExtraReadTimeout)
  	 ne message->Arg2)
   CommunicationsBreakdown(2);

d900 1
a900 1
  length = message->Arg2 - length;	/* now length of config vector */
d922 1
a922 4
  if (Write(Stdout, (BYTE *) &rc, sizeof(word), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(3);
   
  return;
d1004 1
a1004 5
	/* reset the appropriate link channels	*/
  { word *links	= (word *) MinInt;
    resetch_(&(links[link]));		/* output channel	*/
    resetch_(&(links[link + 4]));	/* and input channel	*/
  }
d1051 1
a1051 7
   { 
#ifdef SYSDEB
     IOdebug("netagent on %s, bootstrap error, kernel on remote processor has failed to handshake.",
   		ProcessorName);
#endif
     return(EC_Error + SS_NetServ + EG_Boot + EO_Processor);
   }
a1052 14
#ifdef SYSDEB
  { char		buf[16];
    Object	*temp;
    strcpy(buf, "/link.0/tasks");
    buf[6] = link + '0';
    temp = Locate(Null(Object), buf);
    if (temp eq Null(Object))
     { IOdebug("netagent on %s, bootstrap error, kernel on remote processor has started but processor manager has failed",
   		ProcessorName);
       return(EC_Error + SS_NetServ + EG_Boot + EO_ProcMan);
     }
  }
#endif

a1103 1
#if 1
a1105 3
#else
  { BYTE *junk = image;
    int   i, j;
a1106 17
    if (LinkOut(4, link, image, 2 * OneSec) ne Err_Null)
     { IOdebug("netagent: failed to send image size");
       return(Boot_Image | EG_Timeout | EC_Error | SS_NetServ);
     }
    for (i = 4; i < image_size; i += 1024)
     { if ((i + 1024) > image_size)
        j = image_size - i;
       else
        j = 1024;
       if (LinkOut(j, link, &(junk[i]), 4 * OneSec) ne Err_Null)
        { IOdebug("netagent: failed to send rest of image: i is %d", i);
          return(Boot_Image | EG_Timeout | EC_Error | SS_NetServ);
        }
     }
  }
#endif

d1133 1
a1133 1
{ BYTE		*nucleus_string;
a1139 6
  nucleus_string = Malloc(message->Arg2);
  if (nucleus_string eq Null(BYTE))
   { IOdebug("Netagent: out of memory"); Exit(0x100); }
  if (Read(Stdin, nucleus_string, message->Arg2, ExtraReadTimeout) ne message->Arg2)
   CommunicationsBreakdown(2);

d1143 1
a1143 1
  length = message->Arg2 - length;	/* now length of config vector */
d1162 1
a1162 3
  if (Write(Stdout, (BYTE *) &rc, sizeof(word), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(3);
  return;
d1288 1
a1288 21
   { 
#ifdef SYSDEB
     IOdebug("netagent on %s, bootstrap error, kernel on remote processor has failed to handshake.",
   		ProcessorName);
#endif
     return(EC_Error + SS_NetServ + EG_Boot + EO_Processor);
   }

#ifdef SYSDEB
  { char		buf[16];
    Object	*temp;
    strcpy(buf, "/link.0/tasks");
    buf[6] = link + '0';
    temp = Locate(Null(Object), buf);
    if (temp eq Null(Object))
     { IOdebug("netagent on %s, bootstrap error, kernel on remote processor has started but processor manager has failed",
   		ProcessorName);
       return(EC_Error + SS_NetServ + EG_Boot + EO_ProcMan);
     }
  }
#endif
@


1.17
log
@Various changes including:
1) first attempt at C40 support
2) RmLib execute support (not yet fully tested)
3) faster bootstrap, taskforce load, and better mapping
@
text
@d19 1
a19 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.16 1992/01/15 11:04:39 bart Exp $";
d691 11
d708 1
a708 1
static int	transputer_BootLink(word link, void *image, Config *config, word csize, bool parsytec);
d738 1
a738 4
  if (parsytec)
   { Parsytec_Reset(link);
     Delay(10000);	/* according to Hajo */
   }
d740 1
a740 1
  rc = transputer_BootLink(link, (void *) system_image, config, length, parsytec);
a742 1
     if (parsytec) Delay(100000);
d865 1
a865 2
*** After a suitable delay, controlled in do_TransputerBoot() above, the
*** network agent checks the booting link. If the remote processor has come
d867 2
a868 1
*** networking software.
d922 1
a922 1
  Delay(5000);	/* According to Hajo */
d924 1
d934 1
a934 1
static int transputer_BootLink(word link, void *image, Config *config, word confsize, bool parsytec)
a953 3
  if (parsytec)
   Delay(50000);		/* A delay for nboot.i to settle down */

a982 3
  if (parsytec)
   Delay(50000);	/* and another one, for the nucleus to settle down */
  
a1036 1
     Delay(OneSec);	/* BLV - temporary, for the other processor to come up */
d1151 1
a1151 2
*** After a suitable delay, controlled in do_C0Boot() above, the
*** network agent checks the booting link. If the remote processor has come
d1153 2
a1154 1
*** networking software.
d1156 1
a1156 1
static	int C40_check_link(int link)
d1159 11
a1169 2
    
  if ((rc = LinkData(link, &info)) ne Err_Null) return(rc);
@


1.16
log
@Major update of networking sources, to incorporate the fault-tolerance
work as demonstrated at the IED meeting 10.1.92
@
text
@d19 1
d21 1
a21 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.14 1991/07/10 13:49:14 bart Exp $";
a22 15
/**
*** !!!!!!!!! NOTE TO ALL OEMS AND SOURCE LICENSEES !!!!!!!!!
***
*** If there are problems with booting networks these can usually be resolved
*** by changing this file, in particular by compiling with the HANDBOOT
*** option and fiddling with the timeouts. The master copy of this file
*** is maintained by Perihelion Software, so if you make any important
*** changes let me know or they will not be propagated into future releases
*** of Helios. Please give full details of why a particular change was
*** considered necessary.
***
*** Bart Veer
**/
#define HANDBOOT

d31 1
d37 1
a37 1
#include <asm.h>
d46 1
a46 8
*** These support the various requests. 
***
*** Future expansion, particularly heterogeneous networks. This should
*** involve mainly recompiling the network agent for all the different
*** processors and adding new requests. For example, to support H1
*** processors there would be a new message NA_H1Boot, or something
*** like that. This file may end up with quite a lot of conditional
*** compilation.
d48 15
a63 3
#ifdef __TRAN
static void	do_TransputerBoot(NA_Message *, bool);
#endif
d70 3
d74 1
d76 1
d78 4
a81 3
static void	do_UpdateIO(NA_Message *);
static void	do_GetLinkMode(NA_Message *);
static void	do_Terminate(NA_Message *);
a82 1

a90 8
/**
*** Ensure that the C library (plus posix and fplib) are not loaded
**/
static void _stack_error(Proc *p)
{
  /*_Trace(0xabcdef01,p);*/
  IOdebug("Netagent stack overflow in %s at %x",p->Name,&p);	
}
d92 2
d103 1
a103 1
  int		request_number = 1;
d116 11
a126 1
  
d130 1
a130 5
      { if (request_number eq 1)
         IOdebug("netagent: failed to get first request");
      	CommunicationsBreakdown(1);
      }
    request_number++;
d133 12
a144 1
     { case	NA_Quit			: do_Quit(&message);		break;
d146 3
a148 4
       case	NA_TransputerBoot	: do_TransputerBoot(&message, FALSE);
       				  	  break;
       case	NA_ParsytecBoot		: do_TransputerBoot(&message, TRUE);
       					  break;
d150 3
a152 8
       case	NA_SetLinkMode		: do_SetLinkMode(&message);	break;
       case	NA_Protect		: do_Protect(&message);		break;
       case	NA_Revoke		: do_Revoke(&message);		break;
       case	NA_Cupdate		: do_Cupdate(&message);		break;
       case	NA_Clean		: do_Clean(&message);		break;
       case	NA_ClearNames		: do_ClearNames(&message);	break;
#ifdef __TRAN
       case	NA_ParsytecReset	: do_ParsytecReset(&message);	break;
d154 4
a157 7
       case	NA_UpdateIO		: do_UpdateIO(&message);	break;
       case	NA_GetLinkMode		: do_GetLinkMode(&message);	break;
       case	NA_Terminate		: do_Terminate(&message);	break;
       default	:
       	IOdebug("Netagent(%s): unexpected request 0x%x", ProcessorName,
       		message.FnRc);
       	Exit(0x100);
d162 5
d168 1
a168 8
{ 
#ifdef SYSDEB
  IOdebug("Netagent (%s): warning, communications breakdown during operation %d",
		ProcessorName, x);
#if 0	
  IOdebug("Netagent: pipe %s, flags 0x%x, result2 %x", Stdin->Name, Stdin->Flags, Stdin->Result2);
#endif
#endif
d171 2
a172 5

/**-----------------------------------------------------------------------------
*** A quit message. After this the network server will close the output pipe
*** and then the input pipe, so this routine does the same and exits.
**/
d174 1
a174 2
{ 
  (void) Close(Stdin);
d178 2
a179 78

#ifdef __TRAN
/**-----------------------------------------------------------------------------
*** do_TransputerBoot(). This code should be kept in step with rboot.c
*** There is a second argument to specify a Parsytec reset, and the exact work
*** done depends on whether or not HANDBOOT is defined. Arg1 of the message
*** is the link number. Arg2 is the size of the remaining data. This
*** consists of a nucleus string, possibly empty to indicate that the same
*** nucleus should be used, but always aligned to a four byte boundary.
*** This is followed by the configuration vector.
***
*** The routine returns the result of BootLink().
**/

static BYTE	*determine_image(char *, word *);
static void	transputer_init_link(int);
static void	transputer_set_link(int);
static int	transputer_check_link(int);
static void	Parsytec_Reset(int link);
#ifdef HANDBOOT
static int	My_BootLink(word link, void *image, Config *config, word csize);
#define BootLink	My_BootLink
#endif

static void	do_TransputerBoot(NA_Message *message, bool parsytec)
{ BYTE		*nucleus_string;
  Config	*config;
  int		link = message->Arg1;
  int		length;
  word		rc = Err_Null;
  BYTE		*system_image;

  nucleus_string = Malloc(message->Arg2);
  if (nucleus_string eq Null(BYTE))
   { IOdebug("Netagent: out of memory"); Exit(0x100); }
  if (Read(Stdin, nucleus_string, message->Arg2, ExtraReadTimeout)
  	 ne message->Arg2)
   CommunicationsBreakdown(2);

  length = strlen(nucleus_string) + 1;
  length = (length + 3) & ~3;
  config = (Config *) &(nucleus_string[length]);
  length = message->Arg2 - length;	/* now length of config vector */

  system_image = determine_image(nucleus_string, &rc);
  if (system_image eq Null(BYTE)) goto done;

  config->ImageSize = *((word *) system_image);
  config->Date	    = GetDate();

  transputer_init_link(link);
  
  if (parsytec)
   { Parsytec_Reset(link);
     Delay(10000);	/* according to Hajo */
   }

  rc = BootLink(link, (void *) system_image, config, length);
  if (rc eq Err_Null)
   { transputer_set_link(link);
#if 1
     Delay(100000);
#else
     Delay(50000);
#endif     
     rc = transputer_check_link(link);
   }
   
done:
  if ((strlen(nucleus_string) > 0) && (system_image ne Null(BYTE)))
   Free(system_image);

  if (Write(Stdout, (BYTE *) &rc, sizeof(word), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(3);
   
  return;
}

a180 225
*** Figure out which nucleus to use. If the string provided is empty
*** then use the current nucleus. Otherwise try to locate and read in
*** the specified nucleus.
**/
static	BYTE *determine_image(char *name, word *rc)
{ Object	*nuc;
  ObjInfo	info;
  BYTE		*image = (BYTE *) GetSysBase();
  Stream	*s;
  BYTE		*buffer;
  
  if (strlen(name) eq 0) return(image);
  
  nuc = Locate(Null(Object), name);
  if (nuc eq Null(Object))
   { *rc = EC_Error + SS_NetServ + EG_Unknown + EO_File; 
     return(Null(BYTE));
   }

  if ((nuc->Type & Type_Flags) ne Type_Stream)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Invalid + EO_File;
     return(Null(BYTE));
   }
   
  if (ObjectInfo(nuc, Null(char), (BYTE *) &info) < Err_Null)   
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_File;
     return(Null(BYTE));
   }
   
  if (info.Size <= 0)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_WrongSize + EO_File;
     return(Null(BYTE));
   }

  buffer = Malloc(info.Size);
  if (buffer eq Null(BYTE))
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_NoMemory + EO_File;
     return(Null(BYTE));
   }

  s = Open(nuc, Null(char), O_ReadOnly);
  Close(nuc);
  if (s eq Null(Stream))
   { Free(buffer);
     *rc = EC_Error + SS_NetServ + EG_Open + EO_File;
     return(Null(BYTE));
   }
   
  if (Read(s, buffer, info.Size, -1) ne info.Size)
   { Free(buffer);
     buffer = Null(BYTE);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_Stream;
   }
  Close(s);
  return(buffer);
}

/**
*** If I am about to attempt a bootstrap down a link, that link had better
*** be in a sensible state. The correct mode depends on whether or not 
*** hand bootstrap is used.
**/
static void transputer_init_link(int link)
{ LinkInfo info;
  LinkConf conf;

  if (LinkData(link, &info) ne Err_Null) return;

#ifdef HANDBOOT   
  if (info.Mode eq Link_Mode_Dumb) return;
  conf.Mode 	= Link_Mode_Dumb;
  conf.State	= Link_State_Dumb;
#else
  if (info.Mode eq Link_Mode_Intelligent) return;
  conf.Mode	= Link_Mode_Intelligent;
  conf.State	= Link_State_Crashed;
#endif
  
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);

#ifdef HANDBOOT
	/* reset the appropriate link channels	*/
  { word *links	= (word *) MinInt;
    resetch_(&(links[link]));		/* output channel	*/
    resetch_(&(links[link + 4]));	/* and input channel	*/
  }
#endif
}

/**
*** After a bootstrap, ensure that the link is in a sensible state.
*** Note that the newly-booted processor almost immediately sends
*** an info exchange, so the booting processor must not send its own
*** info. Hence the correct state is pending, not intelligent.
**/
static void transputer_set_link(int link)
{ LinkInfo	info;
  LinkConf	conf;
  
  if (LinkData(link, &info) ne Err_Null) return;

  if ((info.Mode eq Link_Mode_Intelligent) &&
      (info.State eq Link_State_Running))
   return;
  conf.Mode 	= Link_Mode_Intelligent;
  conf.State	= Link_State_Dead;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);
}

/**
*** After a suitable delay, controlled in do_TransputerBoot() above, the
*** network agent checks the booting link. If the remote processor has come
*** up then it will have enabled the link by now, and it can be used by the
*** networking software.
**/
static	int	transputer_check_link(int link)
{ LinkInfo	info;
  int		rc;
    
  if ((rc = LinkData(link, &info)) ne Err_Null) return(rc);
  if ((info.Mode ne Link_Mode_Intelligent) ||
      (info.State ne Link_State_Running))
   { 
#ifdef SYSDEB
     IOdebug("netagent on %s, bootstrap error, kernel on remote processor has failed to handshake.",
   		ProcessorName);
#endif
     return(EC_Error + SS_NetServ + EG_Boot + EO_Processor);
   }

#ifdef SYSDEB
  { char		buf[16];
    Object	*temp;
    strcpy(buf, "/link.0/tasks");
    buf[6] = link + '0';
    temp = Locate(Null(Object), buf);
    if (temp eq Null(Object))
     { IOdebug("netagent on %s, bootstrap error, kernel on remote processor has started but processor manager has failed",
   		ProcessorName);
       return(EC_Error + SS_NetServ + EG_Boot + EO_ProcMan);
     }
  }
#endif

  return(Err_Null);
}

/**
*** Perform a Parsytec-style reset on the specified link.
**/
#define Reset_Address	0x000000C0
static void Parsytec_Reset(int link)
{ uword *reg = (uword *) Reset_Address;
  *reg = 0;
  *reg = 1;
  *reg = 2;
  *reg = 3;
  *reg = 1 << link;
  Delay(5000);	/* According to Hajo */
  *reg = 0;
}

#ifdef HANDBOOT
/**
*** Manual bootstrap. This involves the following stages.
*** 1) send in nboot.i, held in a slot in the system image
*** 2) send in a control byte to nboot.i to read in the system image
*** 3) send in the whole system image
*** 4) send in the configuration vector
**/
static int My_BootLink(word link, void *image, Config *config, word confsize)
{ UBYTE	temp[4];
  void  *nboot;
  word  nboot_size;
  word	image_size;
  int	rc;
    
  { word *sysimage	= (word *) image;
    int  offset    	= sysimage[IVecBootStrap];
    nboot		= (BYTE *) &(sysimage[IVecBootStrap]) + offset;
    nboot_size		= sysimage[IVecProcMan] - sysimage[IVecBootStrap] + 4;
  }

  temp[0] = (UBYTE) nboot_size;
  if ((rc = LinkOut(1, link, temp, 2 * OneSec)) ne Err_Null)
   return(Boot_BootstrapSize | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(nboot_size, link, nboot, 2 *OneSec) ne Err_Null)
   return(Boot_BootstrapCode | EG_Timeout | EC_Error | SS_NetServ);
#if 1
  Delay(50000);		/* A delay for nboot.i to settle down */
#else
  Delay(20000);
#endif
  temp[0] = 4;		/* bootstrap command */
  if (LinkOut(1, link, temp, 2 * OneSec) ne Err_Null)
   return(Boot_ControlByte | EG_Timeout | EC_Error | SS_NetServ);

  image_size = *((word *) image);
  if (LinkOut(image_size, link, image, 2 * OneSec) ne Err_Null)
   return(Boot_Image | EG_Timeout | EC_Error | SS_NetServ);
#if 1
  Delay(50000);	/* and another one, for the nucleus to settle down */
#endif
  
  if (LinkOut(sizeof(WORD), link, (BYTE *) &confsize, 2 * OneSec) ne Err_Null)
   return(Boot_ConfigSize | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(confsize, link, (BYTE *) config, 2 * OneSec) ne Err_Null)
   return(Boot_ConfigVector | EG_Timeout | EC_Error | SS_NetServ);
  return(Err_Null);
}
#endif

#endif /* __TRAN */

/**-----------------------------------------------------------------------------
a182 3
***
*** For efficiency, multiple link modes may be set in one go. In that
*** case Arg1 will be -1, and arg2 will be the number of links;
a183 1
static void	do_MultipleLinks(NA_Message *message);
d190 1
a191 3
  if (link eq -1)
   { do_MultipleLinks(message); return; }
   
d194 2
a195 6
  conf.Flags	= info.Flags;
  if ((mode & RmL_Report) ne 0)	/* implies that the report flag should be set */
   { 
     conf.Flags |= Link_Flags_report;
     mode &= ~ RmL_Report;
   }
d199 13
a211 2
   return;
   
d223 1
a223 1
     case RmL_Intelligent :
d229 4
d234 5
a238 1
     		    conf.State	= Link_State_Dead;
d250 10
a259 10
   IOdebug("netagent(%s): failed to configure link %d", ProcessorName,
	conf.Id);
  if (mode eq RmL_Intelligent) EnableLink(link);
#ifdef __TRAN
  elif (mode eq RmL_NotConnected)
   { word *links = (word *) MinInt;
     resetch_(&(links[link]));
     resetch_(&(links[link + 4]));
   }
#endif
d262 10
a271 16
static void	do_MultipleLinks(NA_Message *message)
{ int	number_links	= message->Arg2;
  int	link;
  BYTE	link_modes_buffer[16];
  BYTE	*link_modes;
  
  if (number_links > 16)
   { link_modes = (BYTE *) Malloc(number_links);
     if (link_modes eq Null(BYTE))
      { IOdebug("Netagent: out of memory"); Exit(0x100); }
   }
  else
   link_modes = link_modes_buffer;
   
  if (Read(Stdin, link_modes, number_links, ExtraReadTimeout) ne number_links)
   CommunicationsBreakdown(4);
d273 2
a274 37
  for (link = 0; link < number_links; link++)
   { LinkInfo	info;
     LinkConf	conf;
     
     if (LinkData(link, &info) < Err_Null) continue;
     conf.Id	= info.Id;
     conf.Flags	= info.Flags;
     if (link_modes[link] & RmL_Report)
      { 
        conf.Flags		|= Link_Flags_report;
        link_modes[link]	&= ~RmL_Report;
      }
      
    	/* a dumb link that has been allocated must not be changed */
     if ((info.Mode eq Link_Mode_Dumb) && (info.State eq Link_State_Running))
      continue;
      
     switch(link_modes[link])
      { case	RmL_NotConnected :
      			conf.Mode	= Link_Mode_Null;
      			conf.State	= Link_State_Null;
      			break;
      	case	RmL_Dumb	:
      			conf.Mode	= Link_Mode_Dumb;
      			conf.State	= Link_State_Dumb;
      			break;
      	case	RmL_Intelligent :
      			conf.Mode	= Link_Mode_Intelligent;
      			conf.State	= Link_State_Running;
      			break;
      	case	RmL_Pending	:
      			conf.Mode	= Link_Mode_Intelligent;
      			conf.State	= Link_State_Dead;
      			break;
      	default	: IOdebug("netagent: invalid link mode %d", link_modes[link]);
      		  Exit(0x100);
      }
d276 12
a287 2
     (void) Configure(conf);
     if (link_modes[link] eq RmL_Intelligent) EnableLink(link);
d290 8
a297 1
  if (number_links > 16) Free(link_modes);
d299 3
a301 2

/**-----------------------------------------------------------------------------
d389 3
a391 2

/**-----------------------------------------------------------------------------
d395 1
a395 1
{
d397 3
a399 2

/**-----------------------------------------------------------------------------
d430 3
a432 2

/**-----------------------------------------------------------------------------
d471 2
a472 1

a504 3
	/* This has to be repeated several times, because libraries	*/
	/* may depend on other libraries which depend on yet other	*/
	/* libraries...							*/  
d624 3
a626 2
	
/**-----------------------------------------------------------------------------
d628 2
a629 2
*** Currently no special capability is required. The network server expects
*** a single reply, mostly for synchronisation.
d635 1
a635 1
  
a652 2
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(13);
d655 14
a668 1

d670 2
a671 1
/**-----------------------------------------------------------------------------
d679 2
a680 2
#endif

d682 9
a690 1
*** Get the current link mode
d692 173
a864 4
static void	do_GetLinkMode(NA_Message *message)
{ int		link = message->Arg1;
  int		mode;
  LinkInfo	info;
d866 1
d868 8
a875 2
  if (LinkData(link, &info) < Err_Null)
   { rc = RmE_BadLink; goto done; }
d877 8
a884 12
  switch(info.Mode)
   { case	Link_Mode_Null : mode = RmL_NotConnected; break;
     case	Link_Mode_Dumb : mode = RmL_Dumb; break;
     case	Link_Mode_Intelligent :
			     	if (info.State eq Link_State_Running)
			     	 mode = RmL_Intelligent;
			     	elif (info.State eq Link_State_Dead)
			     	 mode = RmL_Pending;
		     		else
		     		 mode = RmL_Dead;
				break;
     default : rc = RmE_BadLink; goto done;
d887 13
a899 1
  rc = RmE_Success;     
d901 138
d1040 6
a1045 5
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(14);
  if (rc eq RmE_Success)
   if (Write(Stdout, (BYTE *) &mode, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
    CommunicationsBreakdown(15);  
d1047 19
d1067 45
a1111 3
/**-----------------------------------------------------------------------------
*** Terminate(). This is slightly nasty because the pipe has to be
*** closed first.
d1113 12
a1124 6
static	void	do_Terminate(NA_Message *message)
{ Close(Stdin);
	/* This delay appears to be needed with the 1.2.2 nucleus */
  Delay(OneSec / 10);
  Terminate();
  message = message;
d1127 116
@


1.15
log
@Major update of networking sources, to match Helios1_2_2_native_beta
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /users/bart/netbak/network/RCS/netagent.c,v 1.3 1991/08/20 13:56:21 bart Exp $";
d49 3
d127 1
a127 1
   { if (Read(Stdin, (BYTE *) &message, sizeof(NA_Message), MainReadTimeout) <
d234 1
a234 1
  
d256 1
a256 1
  
d349 8
d460 1
a460 1
   return(Boot_BootstrapCode | EG_Timeout);
d540 5
d552 7
@


1.14
log
@Added support for the NA_Terminate request, needed for native networks.
Put in conditionally compiled extra tests during the bootstrap
process. Compiled out some messages for the release system.
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /usr/sparkygiga/Helios/network/RCS/netagent.c,v 1.9 90/12/17 14:28:39 bart Exp $";
d49 1
d96 1
a96 1
  _Trace(0xabcdef01,p);
d165 2
a167 2
#if 0		
  IOdebug("Netagent: pipe %s, flags 0x%x", Stdin->Name, Stdin->Flags);
d330 1
a330 1
  
d359 1
a359 1
   
d532 3
a534 1
  (void) Configure(conf);
d1008 2
d1013 1
@


1.13
log
@stack checking now enabled. Also, changed bootstrap timings yet again
following visit to Parsytec.
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /users/bart/hsrc/network/RCS/netagent.c,v 1.12 1991/03/17 14:46:24 bart Exp $";
d79 1
d91 9
d150 1
d153 1
a153 1
		message.FnRc);
d160 3
a162 1
{ IOdebug("Netagent (%s): warning, communications breakdown during operation %d",
d164 2
a165 1
#if 0
d378 1
a378 1
  
d382 7
a388 1
   return(EC_Error + SS_NetServ + EG_Boot + EO_Processor);
d390 14
d412 1
a412 3
{ uword *reg;

  reg = (uword *) Reset_Address;
d768 1
a768 1
*** 1) a WalkDir of /tasks to find any programs that should not be running
d794 1
a794 1
     Close(procman);
d900 1
a900 1

d911 1
a911 1
	
d919 1
a919 1

d999 3
a1001 2
/**
*** Ensure that the C library (plus posix and fplib) are not loaded
d1003 4
a1006 4
static void _stack_error(Proc *p)
{
_Trace(0xabcdef01,p);
	IOdebug("Netagent stack overflow in %s at %x",p->Name,&p);	
d1008 1
@


1.12
log
@Added login to the list of programs that are not exterminated by the
cleaners. In a single-user system it is possible for login to run on the
same processor as the tfm, so when the tfm exits that processor is cleaned
out. Login used to be cleaned out as well, giving two login prompts in
short succession.
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /giga/HeliosRoot/Helios/network/RCS/netagent.c,v 1.11 91/02/27 16:57:12 bart Exp Locker: bart $";
d44 1
a48 4
#pragma -s1		/* disable stack checking */
#pragma -f0		/* and vector stack */
#pragma -g0		/* and do not put the names into the code */

d378 3
a380 1
{ uword *reg = (uword *) Reset_Address;
d417 1
a417 1
#if 0
d429 1
a429 1
#if 0
d967 8
@


1.11
log
@1) reduced timeout for main loop
2) added processor name to some diagnostic messages
3) cleaned up delete-task code
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /giga/Helios/network/RCS/netagent.c,v 1.10 91/02/27 16:10:27 bart Exp Locker: bart $";
d748 1
d760 5
a764 1
   { WalkDir(procman, &kill_task); Close(procman); }
d856 1
a856 1
static	void kill_task(Object *task)
d868 1
d876 1
a876 1
  temp->FnMod |= 2;
d881 8
@


1.10
log
@unknown changes, but preparing for 1.2.1 release
@
text
@d1 953
a953 959
/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- netagent.c								--
--                                                                      --
--	This program is run by the Network Server on the various	--
--	processors in order to perform various operations, such as	--
--	enabling/disabling links. It communicates with the Network	--
--	Server via a pipe, i.e. stdin/stdout.				--
--                                                                      --
--	Author:  BLV 14/8/90						--
--                                                                      --
------------------------------------------------------------------------*/

static char *rcsid = "$Header: /usr/sparkygiga/Helios/network/RCS/netagent.c,v 1.9 90/12/17 14:28:39 bart Exp $";

/**
*** !!!!!!!!! NOTE TO ALL OEMS AND SOURCE LICENSEES !!!!!!!!!
***
*** If there are problems with booting networks these can usually be resolved
*** by changing this file, in particular by compiling with the HANDBOOT
*** option and fiddling with the timeouts. The master copy of this file
*** is maintained by Perihelion Software, so if you make any important
*** changes let me know or they will not be propagated into future releases
*** of Helios. Please give full details of why a particular change was
*** considered necessary.
***
*** Bart Veer
**/
#define HANDBOOT

#include <stdio.h>
#include <syslib.h>
#include <task.h>
#include <codes.h>
#include <nonansi.h>
#include <string.h>
#include <root.h>
#include "private.h"
#include "rmlib.h"
#include "netaux.h"

#pragma -s1		/* disable stack checking */
#pragma -f0		/* and vector stack */
#pragma -g0		/* and do not put the names into the code */

#ifndef eq
#define eq ==
#define ne !=
#endif

/**
*** These support the various requests. 
***
*** Future expansion, particularly heterogeneous networks. This should
*** involve mainly recompiling the network agent for all the different
*** processors and adding new requests. For example, to support H1
*** processors there would be a new message NA_H1Boot, or something
*** like that. This file may end up with quite a lot of conditional
*** compilation.
**/
static void	do_Quit(NA_Message *);
#ifdef __TRAN
static void	do_TransputerBoot(NA_Message *, bool);
#endif
static void	do_SetLinkMode(NA_Message *);
static void	do_Protect(NA_Message *);
static void	do_Revoke(NA_Message *);
static void	do_Cupdate(NA_Message *);
static void	do_Clean(NA_Message *);
static void	do_ClearNames(NA_Message *);
#ifdef __TRAN
static void	do_ParsytecReset(NA_Message *);
#endif
static void	do_UpdateIO(NA_Message *);
static void	do_GetLinkMode(NA_Message *);
static void	CommunicationsBreakdown(int);

static Stream	*Stdin;
static Stream	*Stdout;
static char	ProcessorName[IOCDataMax];

#define	MainReadTimeout		(5 * 60 * OneSec)
#define ExtraReadTimeout	(10 * OneSec)
#define ReplyTimeout		(60 * OneSec)

/**
*** Get the environment and the standard streams, which are a pipe from and
*** to the network server. The same pipe is used bi-directionally.
*** Then loop for ever reading request packets and invoke suitable handling
*** routines.
**/
int main(void)
{ Environ	env;
  NA_Message	message;
  int		request_number = 1;
  
  if (GetEnv(MyTask->Port, &env) < Err_Null)
   { IOdebug("netagent: failed to receive environment");
     Exit(0x100);
   }
  if ((env.Strv[0] eq Null(Stream)) || (env.Strv[0] eq (Stream *) MinInt))
   { IOdebug("netagent: failed to get communication streams");
     Exit(0x100);
   }
  Stdin		= env.Strv[0];
  Stdout    	= env.Strv[0];
  MachineName(ProcessorName);
  
  forever
   { if (Read(Stdin, (BYTE *) &message, sizeof(NA_Message), MainReadTimeout) <
   		 sizeof(NA_Message))
      { if (request_number eq 1)
         IOdebug("netagent: failed to get first request");
      	CommunicationsBreakdown(1);
      }
    request_number++;
    
    switch(message.FnRc)
     { case	NA_Quit			: do_Quit(&message);		break;
#ifdef __TRAN
       case	NA_TransputerBoot	: do_TransputerBoot(&message, FALSE);
       				  	  break;
       case	NA_ParsytecBoot		: do_TransputerBoot(&message, TRUE);
       					  break;
#endif
       case	NA_SetLinkMode		: do_SetLinkMode(&message);	break;
       case	NA_Protect		: do_Protect(&message);		break;
       case	NA_Revoke		: do_Revoke(&message);		break;
       case	NA_Cupdate		: do_Cupdate(&message);		break;
       case	NA_Clean		: do_Clean(&message);		break;
       case	NA_ClearNames		: do_ClearNames(&message);	break;
#ifdef __TRAN
       case	NA_ParsytecReset	: do_ParsytecReset(&message);	break;
#endif
       case	NA_UpdateIO		: do_UpdateIO(&message);	break;
       case	NA_GetLinkMode		: do_GetLinkMode(&message);	break;
       default	:
       	IOdebug("Netagent: unexpected request 0x%x", message.FnRc);
       	Exit(0x100);
     }
   }
}

static void	CommunicationsBreakdown(int x)
{ IOdebug("Netagent: communications breakdown during operation %d", x);
  IOdebug("Netagent: pipe %s, flags 0x%x", Stdin->Name, Stdin->Flags);
  Exit(0x100);
}

/**-----------------------------------------------------------------------------
*** A quit message. After this the network server will close the output pipe
*** and then the input pipe, so this routine does the same and exits.
**/
static void	do_Quit(NA_Message *message)
{ 
  (void) Close(Stdin);
  Exit(0x100);
  message = message;
}

#ifdef __TRAN
/**-----------------------------------------------------------------------------
*** do_TransputerBoot(). This code should be kept in step with rboot.c
*** There is a second argument to specify a Parsytec reset, and the exact work
*** done depends on whether or not HANDBOOT is defined. Arg1 of the message
*** is the link number. Arg2 is the size of the remaining data. This
*** consists of a nucleus string, possibly empty to indicate that the same
*** nucleus should be used, but always aligned to a four byte boundary.
*** This is followed by the configuration vector.
***
*** The routine returns the result of BootLink().
**/

static BYTE	*determine_image(char *, word *);
static void	transputer_init_link(int);
static void	transputer_set_link(int);
static int	transputer_check_link(int);
static void	Parsytec_Reset(int link);
#ifdef HANDBOOT
static int	My_BootLink(word link, void *image, Config *config, word csize);
#define BootLink	My_BootLink
#endif

static void	do_TransputerBoot(NA_Message *message, bool parsytec)
{ BYTE		*nucleus_string;
  Config	*config;
  int		link = message->Arg1;
  int		length;
  word		rc = Err_Null;
  BYTE		*system_image;

  nucleus_string = Malloc(message->Arg2);
  if (nucleus_string eq Null(BYTE))
   { IOdebug("Netagent: out of memory"); Exit(0x100); }
  if (Read(Stdin, nucleus_string, message->Arg2, ExtraReadTimeout)
  	 ne message->Arg2)
   CommunicationsBreakdown(2);

  length = strlen(nucleus_string) + 1;
  length = (length + 3) & ~3;
  config = (Config *) &(nucleus_string[length]);
  length = message->Arg2 - length;	/* now length of config vector */

  system_image = determine_image(nucleus_string, &rc);
  if (system_image eq Null(BYTE)) goto done;

  config->ImageSize = *((word *) system_image);
  config->Date	    = GetDate();
  
  transputer_init_link(link);
  
  if (parsytec)
   { Parsytec_Reset(link);
     Delay(10000);	/* according to Hajo */
   }

  rc = BootLink(link, (void *) system_image, config, length);
  if (rc eq Err_Null)
   { transputer_set_link(link);
#if 0
     Delay(100000);
#else
     Delay(50000);
#endif     
     rc = transputer_check_link(link);
   }
   
done:
  if ((strlen(nucleus_string) > 0) && (system_image ne Null(BYTE)))
   Free(system_image);
  
  if (Write(Stdout, (BYTE *) &rc, sizeof(word), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(3);
   
  return;
}

/**
*** Figure out which nucleus to use. If the string provided is empty
*** then use the current nucleus. Otherwise try to locate and read in
*** the specified nucleus.
**/
static	BYTE *determine_image(char *name, word *rc)
{ Object	*nuc;
  ObjInfo	info;
  BYTE		*image = (BYTE *) GetSysBase();
  Stream	*s;
  BYTE		*buffer;
  
  if (strlen(name) eq 0) return(image);
  
  nuc = Locate(Null(Object), name);
  if (nuc eq Null(Object))
   { *rc = EC_Error + SS_NetServ + EG_Unknown + EO_File; 
     return(Null(BYTE));
   }

  if ((nuc->Type & Type_Flags) ne Type_Stream)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Invalid + EO_File;
     return(Null(BYTE));
   }
   
  if (ObjectInfo(nuc, Null(char), (BYTE *) &info) < Err_Null)   
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_File;
     return(Null(BYTE));
   }
   
  if (info.Size <= 0)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_WrongSize + EO_File;
     return(Null(BYTE));
   }

  buffer = Malloc(info.Size);
  if (buffer eq Null(BYTE))
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_NoMemory + EO_File;
     return(Null(BYTE));
   }

  s = Open(nuc, Null(char), O_ReadOnly);
  Close(nuc);
  if (s eq Null(Stream))
   { Free(buffer);
     *rc = EC_Error + SS_NetServ + EG_Open + EO_File;
     return(Null(BYTE));
   }
   
  if (Read(s, buffer, info.Size, -1) ne info.Size)
   { Free(buffer);
     buffer = Null(BYTE);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_Stream;
   }
  Close(s);
  return(buffer);
}

/**
*** If I am about to attempt a bootstrap down a link, that link had better
*** be in a sensible state. The correct mode depends on whether or not 
*** hand bootstrap is used.
**/
static void transputer_init_link(int link)
{ LinkInfo info;
  LinkConf conf;
  
  if (LinkData(link, &info) ne Err_Null) return;

#ifdef HANDBOOT   
  if (info.Mode eq Link_Mode_Dumb) return;
  conf.Mode 	= Link_Mode_Dumb;
  conf.State	= Link_State_Dumb;
#else
  if (info.Mode eq Link_Mode_Intelligent) return;
  conf.Mode	= Link_Mode_Intelligent;
  conf.State	= Link_State_Crashed;
#endif
  
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);
}

/**
*** After a bootstrap, ensure that the link is in a sensible state.
*** Note that the newly-booted processor almost immediately sends
*** an info exchange, so the booting processor must not send its own
*** info. Hence the correct state is pending, not intelligent.
**/
static void transputer_set_link(int link)
{ LinkInfo	info;
  LinkConf	conf;
  
  if (LinkData(link, &info) ne Err_Null) return;
   
  if ((info.Mode eq Link_Mode_Intelligent) &&
      (info.State eq Link_State_Running))
   return;
  conf.Mode 	= Link_Mode_Intelligent;
  conf.State	= Link_State_Dead;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);
}

/**
*** After a suitable delay, controlled in do_TransputerBoot() above, the
*** network agent checks the booting link. If the remote processor has come
*** up then it will have enabled the link by now, and it can be used by the
*** networking software.
**/
static	int	transputer_check_link(int link)
{ LinkInfo	info;
  int		rc;
  
  if ((rc = LinkData(link, &info)) ne Err_Null) return(rc);
  if ((info.Mode ne Link_Mode_Intelligent) ||
      (info.State ne Link_State_Running))
   return(EC_Error + SS_NetServ + EG_Boot + EO_Processor);

  return(Err_Null);
}

/**
*** Perform a Parsytec-style reset on the specified link.
**/
#define Reset_Address	0x000000C0
static void Parsytec_Reset(int link)
{ uword *reg = (uword *) Reset_Address;
  *reg = 0;
  *reg = 1;
  *reg = 2;
  *reg = 3;
  *reg = 1 << link;
  Delay(5000);	/* According to Hajo */
  *reg = 0;
}

#ifdef HANDBOOT
/**
*** Manual bootstrap. This involves the following stages.
*** 1) send in nboot.i, held in a slot in the system image
*** 2) send in a control byte to nboot.i to read in the system image
*** 3) send in the whole system image
*** 4) send in the configuration vector
**/
static int My_BootLink(word link, void *image, Config *config, word confsize)
{ UBYTE	temp[4];
  void  *nboot;
  word  nboot_size;
  word	image_size;
  int	rc;
    
  { word *sysimage	= (word *) image;
    int  offset    	= sysimage[IVecBootStrap];
    nboot		= (BYTE *) &(sysimage[IVecBootStrap]) + offset;
    nboot_size		= sysimage[IVecProcMan] - sysimage[IVecBootStrap] + 4;
  }

  temp[0] = (UBYTE) nboot_size;
  if ((rc = LinkOut(1, link, temp, 2 * OneSec)) ne Err_Null)
   return(Boot_BootstrapSize | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(nboot_size, link, nboot, 2 *OneSec) ne Err_Null)
   return(Boot_BootstrapCode | EG_Timeout);
#if 0
  Delay(50000);		/* A delay for nboot.i to settle down */
#else
  Delay(20000);
#endif
  temp[0] = 4;		/* bootstrap command */
  if (LinkOut(1, link, temp, 2 * OneSec) ne Err_Null)
   return(Boot_ControlByte | EG_Timeout | EC_Error | SS_NetServ);

  image_size = *((word *) image);
  if (LinkOut(image_size, link, image, 2 * OneSec) ne Err_Null)
   return(Boot_Image | EG_Timeout | EC_Error | SS_NetServ);
#if 0
  Delay(50000);	/* and another one, for the nucleus to settle down */
#endif
  
  if (LinkOut(sizeof(WORD), link, (BYTE *) &confsize, 2 * OneSec) ne Err_Null)
   return(Boot_ConfigSize | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(confsize, link, (BYTE *) config, 2 * OneSec) ne Err_Null)
   return(Boot_ConfigVector | EG_Timeout | EC_Error | SS_NetServ);
  return(Err_Null);
}
#endif

#endif /* __TRAN */

/**-----------------------------------------------------------------------------
*** Set the link specified by Arg1 to the mode specified by Arg2. This mode
*** may be 0, 1, 2, or 3. For now ignore any errors.
***
*** For efficiency, multiple link modes may be set in one go. In that
*** case Arg1 will be -1, and arg2 will be the number of links;
**/
static void	do_MultipleLinks(NA_Message *message);

static void	do_SetLinkMode(NA_Message *message)
{ int		link = message->Arg1;
  int		mode = message->Arg2;
  LinkInfo	info;
  LinkConf	conf;
  
  if (link eq -1)
   { do_MultipleLinks(message); return; }
   
  if (LinkData(link, &info) < Err_Null) return;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  if ((mode & RmL_Report) ne 0)	/* implies that the report flag should be set */
   { 
     conf.Flags |= Link_Flags_report;
     mode &= ~ RmL_Report;
   }
   
	/* A dumb link that has been allocated must not be changed. */
  if ((info.Mode eq Link_Mode_Dumb) && (info.State eq Link_State_Running))
   return;
   
  switch(mode)
   { case RmL_NotConnected :
   		    conf.Mode	= Link_Mode_Null;
   		    conf.State	= Link_State_Null;
   		    break;

     case RmL_Dumb :
     		    conf.Mode	= Link_Mode_Dumb;
     		    conf.State	= Link_State_Dumb;
     		    break;
     		    
     case RmL_Intelligent :
       		    conf.Mode	= Link_Mode_Intelligent;
     		    conf.State	= Link_State_Running;
     		    break;
     
     case RmL_Pending :
     		    conf.Mode	= Link_Mode_Intelligent;
     		    conf.State	= Link_State_Dead;
     		    break;

     default	  : return;
   }

  (void) Configure(conf);
  if (mode eq RmL_Intelligent) EnableLink(link);
}

static void	do_MultipleLinks(NA_Message *message)
{ int	number_links	= message->Arg2;
  int	link;
  BYTE	link_modes_buffer[16];
  BYTE	*link_modes;
  
  if (number_links > 16)
   { link_modes = (BYTE *) Malloc(number_links);
     if (link_modes eq Null(BYTE))
      { IOdebug("Netagent: out of memory"); Exit(0x100); }
   }
  else
   link_modes = link_modes_buffer;
   
  if (Read(Stdin, link_modes, number_links, ExtraReadTimeout) ne number_links)
   CommunicationsBreakdown(4);

  for (link = 0; link < number_links; link++)
   { LinkInfo	info;
     LinkConf	conf;
     
     if (LinkData(link, &info) < Err_Null) continue;
     conf.Id	= info.Id;
     conf.Flags	= info.Flags;
     if (link_modes[link] & RmL_Report)
      { 
        conf.Flags		|= Link_Flags_report;
        link_modes[link]	&= ~RmL_Report;
      }
      
    	/* a dumb link that has been allocated must not be changed */
     if ((info.Mode eq Link_Mode_Dumb) && (info.State eq Link_State_Running))
      continue;
      
     switch(link_modes[link])
      { case	RmL_NotConnected :
      			conf.Mode	= Link_Mode_Null;
      			conf.State	= Link_State_Null;
      			break;
      	case	RmL_Dumb	:
      			conf.Mode	= Link_Mode_Dumb;
      			conf.State	= Link_State_Dumb;
      			break;
      	case	RmL_Intelligent :
      			conf.Mode	= Link_Mode_Intelligent;
      			conf.State	= Link_State_Running;
      			break;
      	case	RmL_Pending	:
      			conf.Mode	= Link_Mode_Intelligent;
      			conf.State	= Link_State_Dead;
      			break;
      	default	: IOdebug("netagent: invalid link mode %d", link_modes[link]);
      		  Exit(0x100);
      }

     (void) Configure(conf);
     if (link_modes[link] eq RmL_Intelligent) EnableLink(link);
   }

  if (number_links > 16) Free(link_modes);
}

/**-----------------------------------------------------------------------------
*** do_Protect(). This is used to set up the protection needed. The routine
*** should return three capabilities. The first is the owner capability,
*** which is passed on to the Taskforce Manager when the processor gets
*** allocated. The second is read-only, which may or may not be handed out.
*** The third is the full capability, which only the Network
*** Server needs. This full capability is the only capability in the whole
*** network which allows the access matrix to be altered again, and hence
*** it may be needed by this routine.
**/
static void	do_Protect(NA_Message *message)
{ Matrix	matrix = (Matrix) message->Arg1;
  Capability	full_cap;
  Capability	result[3];
  char		proc_name[IOCDataMax];
  Object	*processor;
  word		*temp;

  memset((void *) result, 0, 2 * sizeof(Capability));
  message->FnRc = Err_Null;

	/* Read a capability from the Network Server */      
  if (Read(Stdin, (BYTE *) &full_cap, sizeof(Capability), ExtraReadTimeout) ne
  	sizeof(Capability))
   CommunicationsBreakdown(5);

  MachineName(proc_name);
  temp = (word *) &full_cap;
  
  if ((temp[0] eq 0) && (temp[1] eq 0))
   {	/* the processor has just been booted, and this is the first	*/
   	/* time that protection is being handled.			*/
	/* First, obtain a default object for the processor. This	*/
	/* includes alter access, courtesy of the Processor Manager.	*/
     processor = Locate(Null(Object), proc_name);
     if (processor eq Null(Object))
      { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
        goto done;
      }
   }
  else
   {	/* The protection is being reset. This means that the existing	*/
   	/* capability must be used in order to have alter access.	*/
     processor = NewObject(proc_name, &full_cap);
     if (processor eq Null(Object))
      { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
        goto done;
      }
   }

	/* Remember the full capability, including alter access		*/
  result[2] = processor->Access;

	/* Now refine the access to produce a capability for the owner	*/
  if (Refine(processor, ~AccMask_A) < Err_Null)
   { 
     message->FnRc = Result2(processor);
     goto done;
   }
  result[0] = processor->Access;

	/* Go back to alter access, and produce a read-only capability */
  processor->Access = result[2];
  if (Refine(processor, AccMask_R | AccMask_Z) < Err_Null)
   {
     message->FnRc = Result2(processor);
     goto done;
   }
  result[1] = processor->Access;
  
	/* Go back to alter access, and protect the processor */
  processor->Access = result[2];
  if (Protect(processor, Null(char), matrix) < Err_Null) 
   { 
     message->FnRc = Result2(processor);
     goto done;
   }

done:
  if (Write(Stdout, (BYTE *) &(message->FnRc), sizeof(word), ReplyTimeout)
      ne sizeof(word))
   CommunicationsBreakdown(6);
  if (message->FnRc eq Err_Null)
   if (Write(Stdout, (BYTE *) result, 3 * sizeof(Capability), ReplyTimeout)
       ne (3 * sizeof(Capability)))
    CommunicationsBreakdown(7);
     
}

/**-----------------------------------------------------------------------------
*** Currently a no-op
**/
static void	do_Revoke(NA_Message *message)
{
}

/**-----------------------------------------------------------------------------
*** Update the name of a processor. For example, if the current name is /00
*** change it to /Net/00. Arg1 contains the length of the new network name.
**/
static void	do_Cupdate(NA_Message *message)
{ char		*buffer		= (char *) Malloc(message->Arg1);
  char		*curname	= (char *) Malloc(IOCDataMax);
  Object	*processor	= Null(Object);
  WORD	rc;
  
  if ((buffer eq Null(char)) || (curname eq Null(char)))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }

  if (Read(Stdin, (BYTE *) buffer, message->Arg1, ExtraReadTimeout) ne
  	message->Arg1)
   CommunicationsBreakdown(8);

  MachineName(curname);
  processor	= Locate(Null(Object), curname);
  if (processor eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }

  rc = Rename(processor, Null(char), buffer);
  
done:
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(9);
  if (buffer ne Null(char)) Free(buffer);
  if (curname ne Null(char)) Free(curname);
  if (processor ne Null(Object)) Close(processor);
}

/**-----------------------------------------------------------------------------
*** Update the name of an I/O processor at the other end of the specified
*** link. For example, change it from /IO to /Net/IO.
**/
static void	do_UpdateIO(NA_Message *message)
{ int		link = message->Arg1;
  char		*buffer		= (char *) Malloc(message->Arg2);
  char		*procname 	= (char *) Malloc(IOCDataMax);
  char		linkbuf[10];	/* link.267\0 */
  Object	*processor	= Null(Object);
  int		rc;
    
  if ((buffer eq Null(char)) || (procname eq Null(char)))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }
  
  if (Read(Stdin, (BYTE *) buffer, message->Arg2, ExtraReadTimeout) ne
  	message->Arg2)
   CommunicationsBreakdown(10);
   
  MachineName(procname);
  processor	= Locate(Null(Object), procname);
  if (processor eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }
   
  strcpy(linkbuf, "link.");
  if (link eq 0)
   strcat(linkbuf, "0");	/* addint() does not cope with 0 */
  else
   addint(linkbuf, link);
   
  rc = Rename(processor, linkbuf, buffer);

done:
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(11);
  if (buffer ne Null(char)) Free(buffer);
  if (procname ne Null(char)) Free(procname);
  if (processor ne Null(Object)) Close(processor);  
}

/**-----------------------------------------------------------------------------
*** This routine should clean out the processor.
*** Essentially it performs several walkdirs.
*** 1) a WalkDir of /tasks to find any programs that should not be running
*** 2) a WalkDir of /loader to delete any unused libraries
*** 3) possibly a WalkDir of /pipe if the pipe server is running
*** 4) ditto for /fifo
*** 5) ditto for /ram
**/
static void	WalkDir(Object *x, VoidFnPtr fn);
static bool	pipe_running	= FALSE;
static bool	fifo_running	= FALSE;
static bool	ram_running	= FALSE;
static void	kill_task(Object *task);
static void	kill_something(Object *whatever);
static word	cleaning_date;

static void	do_Clean(NA_Message *message)
{ WORD	rc = Err_Null;
  Object	*procman = Locate(Null(Object), "/tasks");
  Object	*loader	 = Locate(Null(Object), "/loader");

  cleaning_date = message->Arg1;

  if (procman ne Null(Object))
   { WalkDir(procman, &kill_task); Close(procman); }

	/* This has to be repeated several times, because libraries	*/
	/* may depend on other libraries which depend on yet other	*/
	/* libraries...							*/  
  if (loader ne Null(Object))
   { WalkDir(loader, &kill_something); Close(loader); }

  if (pipe_running)
   { Object	*pipe_server = Locate(Null(Object), "/pipe");
     if (pipe_server ne Null(Object))
      { WalkDir(pipe_server, &kill_something);
        Close(pipe_server);
      }
   }
   
  if (fifo_running)
   { Object	*fifo_server = Locate(Null(Object), "/fifo");
     if (fifo_server ne Null(Object))
      { WalkDir(fifo_server, &kill_something);
        Close(fifo_server);
      }
   }
   
  if (ram_running)
   { Object	*ram_server = Locate(Null(Object), "/ram");
     if (ram_server ne Null(Object))
      { WalkDir(ram_server, &kill_something);
        Close(ram_server);
      }
   }
   
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(12);
}

static void WalkDir(Object *dir, VoidFnPtr fn)
{ Stream  	*s;
  WORD		size, i;
  DirEntry	*entry, *cur;
  Object	*item;
  
  if ((dir->Type & Type_Flags) eq Type_Stream) return;
   
  s = Open(dir, Null(char), O_ReadOnly);
  if (s eq Null(Stream))
   { IOdebug("netagent: error cleaning %s (%x)", dir->Name, Result2(dir));
     return; 
   }

  size = GetFileSize(s);

  if (size eq 0) return;
  entry = (DirEntry *) Malloc(size);
  if (entry == Null(DirEntry)) 
   { IOdebug("netagent: out of memory cleaning %s", dir->Name);
     Close(s); 
     return;
   }
     
  if ((size = Read(s, (BYTE *) entry, size, -1)) < 0)
   { IOdebug("netagent: read error cleaning %s", dir->Name);
     Close(s);
     return;
   }

  Close(s);
      
  cur = entry;
  for (i = 0; i < size; cur++, i += sizeof(DirEntry) )
   { if ( (!strcmp(cur->Name, ".")) || (!strcmp(cur->Name, "..")) )
      continue;

     item = Locate(dir, cur->Name);
     if (item ne Null(Object))
      { (*fn)(item);
        Close(item);
      }
   }

  Free(entry);
}

	/* delete something from a ram-disk or similar */
static void	kill_something(Object *x)
{ if ((x->Type & Type_Flags) eq Type_Directory)
   WalkDir(x, &kill_something);
  Delete(x, Null(char));
}

	/* kill a task. Several tasks are exempt from this. 		*/
	/* Also, commands started by the Network Server are exempt	*/
static	void kill_task(Object *task)
{ char		*name = objname(task->Name);
  Object	*temp;
  int		i;
  ObjInfo	info;
      
  if (!strncmp(name, "netagent.", 9))	return;
  if (!strncmp(name, "Fifo.", 5)) { fifo_running = TRUE; return; }
  if (!strncmp(name, "Loader.", 7))	return;
  if (!strncmp(name, "Null.", 5))	return;
  if (!strncmp(name, "Pipe.", 5)) { pipe_running = TRUE; return; }
  if (!strncmp(name, "ProcMan.", 8))	return;
  if (!strncmp(name, "Ram.", 4)) { ram_running = TRUE; return; }

  if (ObjectInfo(task, Null(char), (BYTE *) &info) < Err_Null)
   return;
  if (info.Dates.Creation <= cleaning_date) return;

#if 0  
  for (i = 0; i < 3; i++)
   { temp = Locate(task, Null(char));
     if (temp eq Null(Object)) break;
     (void) Delete(temp, Null(char));
     Close(temp);
   } 
#else
  temp = Locate(task, Null(char));
  if (temp eq Null(Object)) return;
  temp->FnMod |= 2;
  (void) Delete(temp, Null(char));
  Close(temp);
#endif
}
	
/**-----------------------------------------------------------------------------
*** Clearing the names involves sending a message to the processor manager.
*** Currently no special capability is required. The network server expects
*** a single reply, mostly for synchronisation.
**/
static void	do_ClearNames(NA_Message *message)
{ Object	*procman = Null(Object);
  word		rc = Err_Null;
  MsgBuf	*r = New(MsgBuf);
  
  if (r eq Null(MsgBuf))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }

  procman = Locate(Null(Object), "/tasks");  
  if (procman eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_ProcMan; goto done; }

  InitMCB(&(r->mcb), MsgHdr_Flags_preserve, NullPort, NullPort, 
          FC_GSP + FG_Reconfigure);
  r->mcb.Control = r->control;
  r->mcb.Data	 = r->data;
  MarshalCommon(&(r->mcb), procman, Null(char));
  SendIOC(&(r->mcb));

done:
  if (r ne Null(MsgBuf)) Free(r);
  if (procman ne Null(Object)) Close(procman);
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(13);
  message = message;
}

#ifdef __TRAN
/**-----------------------------------------------------------------------------
*** Perform a Parsytec reset down the link specified by Arg1 of the message.
*** Do not bother to send back a reply.
**/
static void	do_ParsytecReset(NA_Message *message)
{ int link = message->Arg1;
  Parsytec_Reset(link);
}
#endif

/**-----------------------------------------------------------------------------
*** Get the current link mode
**/
static void	do_GetLinkMode(NA_Message *message)
{ int		link = message->Arg1;
  int		mode;
  LinkInfo	info;
  int		rc;

  if (LinkData(link, &info) < Err_Null)
   { rc = RmE_BadLink; goto done; }

  switch(info.Mode)
   { case	Link_Mode_Null : mode = RmL_NotConnected; break;
     case	Link_Mode_Dumb : mode = RmL_Dumb; break;
     case	Link_Mode_Intelligent :
			     	if (info.State eq Link_State_Running)
			     	 mode = RmL_Intelligent;
			     	elif (info.State eq Link_State_Dead)
			     	 mode = RmL_Pending;
		     		else
		     		 mode = RmL_Dead;
				break;
     default : rc = RmE_BadLink; goto done;
   }

  rc = RmE_Success;     

done:
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(14);
  if (rc eq RmE_Success)
   if (Write(Stdout, (BYTE *) &mode, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
    CommunicationsBreakdown(15);  
}

@


1.9
log
@Two changes. First, the transputer code dealing with booting up processors
is now less optimistic about whether or not it succeeds. The previous
assumption was that if all the data could be sent in then the processors
was booted. The new assumption is that if the remote processor manages
to enable the connecting link then it has booted. This avoids some timing
problems where both processors try to enable the link at the same time.
The second change involves a tidy up of the cleaners, area deleting tasks,
where NHG has made it easier to exterminate programs.
@
text
@d1 959
a959 959
/*------------------------------------------------------------------------
--                                                                      --
--           H E L I O S   N E T W O R K I N G   S O F T W A R E	--
--           ---------------------------------------------------	--
--                                                                      --
--             Copyright (C) 1990, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- netagent.c								--
--                                                                      --
--	This program is run by the Network Server on the various	--
--	processors in order to perform various operations, such as	--
--	enabling/disabling links. It communicates with the Network	--
--	Server via a pipe, i.e. stdin/stdout.				--
--                                                                      --
--	Author:  BLV 14/8/90						--
--                                                                      --
------------------------------------------------------------------------*/

static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netagent.c,v 1.8 90/12/01 15:31:05 bart Exp $";

/**
*** !!!!!!!!! NOTE TO ALL OEMS AND SOURCE LICENSEES !!!!!!!!!
***
*** If there are problems with booting networks these can usually be resolved
*** by changing this file, in particular by compiling with the HANDBOOT
*** option and fiddling with the timeouts. The master copy of this file
*** is maintained by Perihelion Software, so if you make any important
*** changes let me know or they will not be propagated into future releases
*** of Helios. Please give full details of why a particular change was
*** considered necessary.
***
*** Bart Veer
**/
#define HANDBOOT

#include <stdio.h>
#include <syslib.h>
#include <task.h>
#include <codes.h>
#include <nonansi.h>
#include <string.h>
#include <root.h>
#include "private.h"
#include "rmlib.h"
#include "netaux.h"

#pragma -s1		/* disable stack checking */
#pragma -f0		/* and vector stack */
#pragma -g0		/* and do not put the names into the code */

#ifndef eq
#define eq ==
#define ne !=
#endif

/**
*** These support the various requests. 
***
*** Future expansion, particularly heterogeneous networks. This should
*** involve mainly recompiling the network agent for all the different
*** processors and adding new requests. For example, to support H1
*** processors there would be a new message NA_H1Boot, or something
*** like that. This file may end up with quite a lot of conditional
*** compilation.
**/
static void	do_Quit(NA_Message *);
#ifdef __TRAN
static void	do_TransputerBoot(NA_Message *, bool);
#endif
static void	do_SetLinkMode(NA_Message *);
static void	do_Protect(NA_Message *);
static void	do_Revoke(NA_Message *);
static void	do_Cupdate(NA_Message *);
static void	do_Clean(NA_Message *);
static void	do_ClearNames(NA_Message *);
#ifdef __TRAN
static void	do_ParsytecReset(NA_Message *);
#endif
static void	do_UpdateIO(NA_Message *);
static void	do_GetLinkMode(NA_Message *);
static void	CommunicationsBreakdown(int);

static Stream	*Stdin;
static Stream	*Stdout;
static char	ProcessorName[IOCDataMax];

#define	MainReadTimeout		(5 * 60 * OneSec)
#define ExtraReadTimeout	(10 * OneSec)
#define ReplyTimeout		(60 * OneSec)

/**
*** Get the environment and the standard streams, which are a pipe from and
*** to the network server. The same pipe is used bi-directionally.
*** Then loop for ever reading request packets and invoke suitable handling
*** routines.
**/
int main(void)
{ Environ	env;
  NA_Message	message;
  int		request_number = 1;
  
  if (GetEnv(MyTask->Port, &env) < Err_Null)
   { IOdebug("netagent: failed to receive environment");
     Exit(0x100);
   }
  if ((env.Strv[0] eq Null(Stream)) || (env.Strv[0] eq (Stream *) MinInt))
   { IOdebug("netagent: failed to get communication streams");
     Exit(0x100);
   }
  Stdin		= env.Strv[0];
  Stdout    	= env.Strv[0];
  MachineName(ProcessorName);
  
  forever
   { if (Read(Stdin, (BYTE *) &message, sizeof(NA_Message), MainReadTimeout) <
   		 sizeof(NA_Message))
      { if (request_number eq 1)
         IOdebug("netagent: failed to get first request");
      	CommunicationsBreakdown(1);
      }
    request_number++;
    
    switch(message.FnRc)
     { case	NA_Quit			: do_Quit(&message);		break;
#ifdef __TRAN
       case	NA_TransputerBoot	: do_TransputerBoot(&message, FALSE);
       				  	  break;
       case	NA_ParsytecBoot		: do_TransputerBoot(&message, TRUE);
       					  break;
#endif
       case	NA_SetLinkMode		: do_SetLinkMode(&message);	break;
       case	NA_Protect		: do_Protect(&message);		break;
       case	NA_Revoke		: do_Revoke(&message);		break;
       case	NA_Cupdate		: do_Cupdate(&message);		break;
       case	NA_Clean		: do_Clean(&message);		break;
       case	NA_ClearNames		: do_ClearNames(&message);	break;
#ifdef __TRAN
       case	NA_ParsytecReset	: do_ParsytecReset(&message);	break;
#endif
       case	NA_UpdateIO		: do_UpdateIO(&message);	break;
       case	NA_GetLinkMode		: do_GetLinkMode(&message);	break;
       default	:
       	IOdebug("Netagent: unexpected request 0x%x", message.FnRc);
       	Exit(0x100);
     }
   }
}

static void	CommunicationsBreakdown(int x)
{ IOdebug("Netagent: communications breakdown during operation %d", x);
  IOdebug("Netagent: pipe %s, flags 0x%x", Stdin->Name, Stdin->Flags);
  Exit(0x100);
}

/**-----------------------------------------------------------------------------
*** A quit message. After this the network server will close the output pipe
*** and then the input pipe, so this routine does the same and exits.
**/
static void	do_Quit(NA_Message *message)
{ 
  (void) Close(Stdin);
  Exit(0x100);
  message = message;
}

#ifdef __TRAN
/**-----------------------------------------------------------------------------
*** do_TransputerBoot(). This code should be kept in step with rboot.c
*** There is a second argument to specify a Parsytec reset, and the exact work
*** done depends on whether or not HANDBOOT is defined. Arg1 of the message
*** is the link number. Arg2 is the size of the remaining data. This
*** consists of a nucleus string, possibly empty to indicate that the same
*** nucleus should be used, but always aligned to a four byte boundary.
*** This is followed by the configuration vector.
***
*** The routine returns the result of BootLink().
**/

static BYTE	*determine_image(char *, word *);
static void	transputer_init_link(int);
static void	transputer_set_link(int);
static int	transputer_check_link(int);
static void	Parsytec_Reset(int link);
#ifdef HANDBOOT
static int	My_BootLink(word link, void *image, Config *config, word csize);
#define BootLink	My_BootLink
#endif

static void	do_TransputerBoot(NA_Message *message, bool parsytec)
{ BYTE		*nucleus_string;
  Config	*config;
  int		link = message->Arg1;
  int		length;
  word		rc = Err_Null;
  BYTE		*system_image;

  nucleus_string = Malloc(message->Arg2);
  if (nucleus_string eq Null(BYTE))
   { IOdebug("Netagent: out of memory"); Exit(0x100); }
  if (Read(Stdin, nucleus_string, message->Arg2, ExtraReadTimeout)
  	 ne message->Arg2)
   CommunicationsBreakdown(2);

  length = strlen(nucleus_string) + 1;
  length = (length + 3) & ~3;
  config = (Config *) &(nucleus_string[length]);
  length = message->Arg2 - length;	/* now length of config vector */

  system_image = determine_image(nucleus_string, &rc);
  if (system_image eq Null(BYTE)) goto done;

  config->ImageSize = *((word *) system_image);
  config->Date	    = GetDate();
  
  transputer_init_link(link);
  
  if (parsytec)
   { Parsytec_Reset(link);
     Delay(10000);	/* according to Hajo */
   }

  rc = BootLink(link, (void *) system_image, config, length);
  if (rc eq Err_Null)
   { transputer_set_link(link);
#if 0
     Delay(100000);
#else
     Delay(50000);
#endif     
     rc = transputer_check_link(link);
   }
   
done:
  if ((strlen(nucleus_string) > 0) && (system_image ne Null(BYTE)))
   Free(system_image);
  
  if (Write(Stdout, (BYTE *) &rc, sizeof(word), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(3);
   
  return;
}

/**
*** Figure out which nucleus to use. If the string provided is empty
*** then use the current nucleus. Otherwise try to locate and read in
*** the specified nucleus.
**/
static	BYTE *determine_image(char *name, word *rc)
{ Object	*nuc;
  ObjInfo	info;
  BYTE		*image = (BYTE *) GetSysBase();
  Stream	*s;
  BYTE		*buffer;
  
  if (strlen(name) eq 0) return(image);
  
  nuc = Locate(Null(Object), name);
  if (nuc eq Null(Object))
   { *rc = EC_Error + SS_NetServ + EG_Unknown + EO_File; 
     return(Null(BYTE));
   }

  if ((nuc->Type & Type_Flags) ne Type_Stream)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Invalid + EO_File;
     return(Null(BYTE));
   }
   
  if (ObjectInfo(nuc, Null(char), (BYTE *) &info) < Err_Null)   
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_File;
     return(Null(BYTE));
   }
   
  if (info.Size <= 0)
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_WrongSize + EO_File;
     return(Null(BYTE));
   }

  buffer = Malloc(info.Size);
  if (buffer eq Null(BYTE))
   { Close(nuc);
     *rc = EC_Error + SS_NetServ + EG_NoMemory + EO_File;
     return(Null(BYTE));
   }

  s = Open(nuc, Null(char), O_ReadOnly);
  Close(nuc);
  if (s eq Null(Stream))
   { Free(buffer);
     *rc = EC_Error + SS_NetServ + EG_Open + EO_File;
     return(Null(BYTE));
   }
   
  if (Read(s, buffer, info.Size, -1) ne info.Size)
   { Free(buffer);
     buffer = Null(BYTE);
     *rc = EC_Error + SS_NetServ + EG_Broken + EO_Stream;
   }
  Close(s);
  return(buffer);
}

/**
*** If I am about to attempt a bootstrap down a link, that link had better
*** be in a sensible state. The correct mode depends on whether or not 
*** hand bootstrap is used.
**/
static void transputer_init_link(int link)
{ LinkInfo info;
  LinkConf conf;
  
  if (LinkData(link, &info) ne Err_Null) return;

#ifdef HANDBOOT   
  if (info.Mode eq Link_Mode_Dumb) return;
  conf.Mode 	= Link_Mode_Dumb;
  conf.State	= Link_State_Dumb;
#else
  if (info.Mode eq Link_Mode_Intelligent) return;
  conf.Mode	= Link_Mode_Intelligent;
  conf.State	= Link_State_Crashed;
#endif
  
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);
}

/**
*** After a bootstrap, ensure that the link is in a sensible state.
*** Note that the newly-booted processor almost immediately sends
*** an info exchange, so the booting processor must not send its own
*** info. Hence the correct state is pending, not intelligent.
**/
static void transputer_set_link(int link)
{ LinkInfo	info;
  LinkConf	conf;
  
  if (LinkData(link, &info) ne Err_Null) return;
   
  if ((info.Mode eq Link_Mode_Intelligent) &&
      (info.State eq Link_State_Running))
   return;
  conf.Mode 	= Link_Mode_Intelligent;
  conf.State	= Link_State_Dead;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  (void) Configure(conf);
}

/**
*** After a suitable delay, controlled in do_TransputerBoot() above, the
*** network agent checks the booting link. If the remote processor has come
*** up then it will have enabled the link by now, and it can be used by the
*** networking software.
**/
static	int	transputer_check_link(int link)
{ LinkInfo	info;
  int		rc;
  
  if ((rc = LinkData(link, &info)) ne Err_Null) return(rc);
  if ((info.Mode ne Link_Mode_Intelligent) ||
      (info.State ne Link_State_Running))
   return(EC_Error + SS_NetServ + EG_Boot + EO_Processor);

  return(Err_Null);
}

/**
*** Perform a Parsytec-style reset on the specified link.
**/
#define Reset_Address	0x000000C0
static void Parsytec_Reset(int link)
{ uword *reg = (uword *) Reset_Address;
  *reg = 0;
  *reg = 1;
  *reg = 2;
  *reg = 3;
  *reg = 1 << link;
  Delay(5000);	/* According to Hajo */
  *reg = 0;
}

#ifdef HANDBOOT
/**
*** Manual bootstrap. This involves the following stages.
*** 1) send in nboot.i, held in a slot in the system image
*** 2) send in a control byte to nboot.i to read in the system image
*** 3) send in the whole system image
*** 4) send in the configuration vector
**/
static int My_BootLink(word link, void *image, Config *config, word confsize)
{ UBYTE	temp[4];
  void  *nboot;
  word  nboot_size;
  word	image_size;
  int	rc;
    
  { word *sysimage	= (word *) image;
    int  offset    	= sysimage[IVecBootStrap];
    nboot		= (BYTE *) &(sysimage[IVecBootStrap]) + offset;
    nboot_size		= sysimage[IVecProcMan] - sysimage[IVecBootStrap] + 4;
  }

  temp[0] = (UBYTE) nboot_size;
  if ((rc = LinkOut(1, link, temp, 2 * OneSec)) ne Err_Null)
   return(Boot_BootstrapSize | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(nboot_size, link, nboot, 2 *OneSec) ne Err_Null)
   return(Boot_BootstrapCode | EG_Timeout);
#if 0
  Delay(50000);		/* A delay for nboot.i to settle down */
#else
  Delay(20000);
#endif
  temp[0] = 4;		/* bootstrap command */
  if (LinkOut(1, link, temp, 2 * OneSec) ne Err_Null)
   return(Boot_ControlByte | EG_Timeout | EC_Error | SS_NetServ);

  image_size = *((word *) image);
  if (LinkOut(image_size, link, image, 2 * OneSec) ne Err_Null)
   return(Boot_Image | EG_Timeout | EC_Error | SS_NetServ);
#if 0
  Delay(50000);	/* and another one, for the nucleus to settle down */
#endif
  
  if (LinkOut(sizeof(WORD), link, (BYTE *) &confsize, 2 * OneSec) ne Err_Null)
   return(Boot_ConfigSize | EG_Timeout | EC_Error | SS_NetServ);

  if (LinkOut(confsize, link, (BYTE *) config, 2 * OneSec) ne Err_Null)
   return(Boot_ConfigVector | EG_Timeout | EC_Error | SS_NetServ);
  return(Err_Null);
}
#endif

#endif /* __TRAN */

/**-----------------------------------------------------------------------------
*** Set the link specified by Arg1 to the mode specified by Arg2. This mode
*** may be 0, 1, 2, or 3. For now ignore any errors.
***
*** For efficiency, multiple link modes may be set in one go. In that
*** case Arg1 will be -1, and arg2 will be the number of links;
**/
static void	do_MultipleLinks(NA_Message *message);

static void	do_SetLinkMode(NA_Message *message)
{ int		link = message->Arg1;
  int		mode = message->Arg2;
  LinkInfo	info;
  LinkConf	conf;
  
  if (link eq -1)
   { do_MultipleLinks(message); return; }
   
  if (LinkData(link, &info) < Err_Null) return;
  conf.Id	= info.Id;
  conf.Flags	= info.Flags;
  if ((mode & RmL_Report) ne 0)	/* implies that the report flag should be set */
   { 
     conf.Flags |= Link_Flags_report;
     mode &= ~ RmL_Report;
   }
   
	/* A dumb link that has been allocated must not be changed. */
  if ((info.Mode eq Link_Mode_Dumb) && (info.State eq Link_State_Running))
   return;
   
  switch(mode)
   { case RmL_NotConnected :
   		    conf.Mode	= Link_Mode_Null;
   		    conf.State	= Link_State_Null;
   		    break;

     case RmL_Dumb :
     		    conf.Mode	= Link_Mode_Dumb;
     		    conf.State	= Link_State_Dumb;
     		    break;
     		    
     case RmL_Intelligent :
       		    conf.Mode	= Link_Mode_Intelligent;
     		    conf.State	= Link_State_Running;
     		    break;
     
     case RmL_Pending :
     		    conf.Mode	= Link_Mode_Intelligent;
     		    conf.State	= Link_State_Dead;
     		    break;

     default	  : return;
   }

  (void) Configure(conf);
  if (mode eq RmL_Intelligent) EnableLink(link);
}

static void	do_MultipleLinks(NA_Message *message)
{ int	number_links	= message->Arg2;
  int	link;
  BYTE	link_modes_buffer[16];
  BYTE	*link_modes;
  
  if (number_links > 16)
   { link_modes = (BYTE *) Malloc(number_links);
     if (link_modes eq Null(BYTE))
      { IOdebug("Netagent: out of memory"); Exit(0x100); }
   }
  else
   link_modes = link_modes_buffer;
   
  if (Read(Stdin, link_modes, number_links, ExtraReadTimeout) ne number_links)
   CommunicationsBreakdown(4);

  for (link = 0; link < number_links; link++)
   { LinkInfo	info;
     LinkConf	conf;
     
     if (LinkData(link, &info) < Err_Null) continue;
     conf.Id	= info.Id;
     conf.Flags	= info.Flags;
     if (link_modes[link] & RmL_Report)
      { 
        conf.Flags		|= Link_Flags_report;
        link_modes[link]	&= ~RmL_Report;
      }
      
    	/* a dumb link that has been allocated must not be changed */
     if ((info.Mode eq Link_Mode_Dumb) && (info.State eq Link_State_Running))
      continue;
      
     switch(link_modes[link])
      { case	RmL_NotConnected :
      			conf.Mode	= Link_Mode_Null;
      			conf.State	= Link_State_Null;
      			break;
      	case	RmL_Dumb	:
      			conf.Mode	= Link_Mode_Dumb;
      			conf.State	= Link_State_Dumb;
      			break;
      	case	RmL_Intelligent :
      			conf.Mode	= Link_Mode_Intelligent;
      			conf.State	= Link_State_Running;
      			break;
      	case	RmL_Pending	:
      			conf.Mode	= Link_Mode_Intelligent;
      			conf.State	= Link_State_Dead;
      			break;
      	default	: IOdebug("netagent: invalid link mode %d", link_modes[link]);
      		  Exit(0x100);
      }

     (void) Configure(conf);
     if (link_modes[link] eq RmL_Intelligent) EnableLink(link);
   }

  if (number_links > 16) Free(link_modes);
}

/**-----------------------------------------------------------------------------
*** do_Protect(). This is used to set up the protection needed. The routine
*** should return three capabilities. The first is the owner capability,
*** which is passed on to the Taskforce Manager when the processor gets
*** allocated. The second is read-only, which may or may not be handed out.
*** The third is the full capability, which only the Network
*** Server needs. This full capability is the only capability in the whole
*** network which allows the access matrix to be altered again, and hence
*** it may be needed by this routine.
**/
static void	do_Protect(NA_Message *message)
{ Matrix	matrix = (Matrix) message->Arg1;
  Capability	full_cap;
  Capability	result[3];
  char		proc_name[IOCDataMax];
  Object	*processor;
  word		*temp;

  memset((void *) result, 0, 2 * sizeof(Capability));
  message->FnRc = Err_Null;

	/* Read a capability from the Network Server */      
  if (Read(Stdin, (BYTE *) &full_cap, sizeof(Capability), ExtraReadTimeout) ne
  	sizeof(Capability))
   CommunicationsBreakdown(5);

  MachineName(proc_name);
  temp = (word *) &full_cap;
  
  if ((temp[0] eq 0) && (temp[1] eq 0))
   {	/* the processor has just been booted, and this is the first	*/
   	/* time that protection is being handled.			*/
	/* First, obtain a default object for the processor. This	*/
	/* includes alter access, courtesy of the Processor Manager.	*/
     processor = Locate(Null(Object), proc_name);
     if (processor eq Null(Object))
      { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
        goto done;
      }
   }
  else
   {	/* The protection is being reset. This means that the existing	*/
   	/* capability must be used in order to have alter access.	*/
     processor = NewObject(proc_name, &full_cap);
     if (processor eq Null(Object))
      { message->FnRc = EC_Error + SS_NetServ + EG_NoMemory + EO_Processor;
        goto done;
      }
   }

	/* Remember the full capability, including alter access		*/
  result[2] = processor->Access;

	/* Now refine the access to produce a capability for the owner	*/
  if (Refine(processor, ~AccMask_A) < Err_Null)
   { 
     message->FnRc = Result2(processor);
     goto done;
   }
  result[0] = processor->Access;

	/* Go back to alter access, and produce a read-only capability */
  processor->Access = result[2];
  if (Refine(processor, AccMask_R) < Err_Null)
   {
     message->FnRc = Result2(processor);
     goto done;
   }
  result[1] = processor->Access;
  
	/* Go back to alter access, and protect the processor */
  processor->Access = result[2];
  if (Protect(processor, Null(char), matrix) < Err_Null) 
   { 
     message->FnRc = Result2(processor);
     goto done;
   }

done:
  if (Write(Stdout, (BYTE *) &(message->FnRc), sizeof(word), ReplyTimeout)
      ne sizeof(word))
   CommunicationsBreakdown(6);
  if (message->FnRc eq Err_Null)
   if (Write(Stdout, (BYTE *) result, 3 * sizeof(Capability), ReplyTimeout)
       ne (3 * sizeof(Capability)))
    CommunicationsBreakdown(7);
     
}

/**-----------------------------------------------------------------------------
*** Currently a no-op
**/
static void	do_Revoke(NA_Message *message)
{
}

/**-----------------------------------------------------------------------------
*** Update the name of a processor. For example, if the current name is /00
*** change it to /Net/00. Arg1 contains the length of the new network name.
**/
static void	do_Cupdate(NA_Message *message)
{ char		*buffer		= (char *) Malloc(message->Arg1);
  char		*curname	= (char *) Malloc(IOCDataMax);
  Object	*processor	= Null(Object);
  WORD	rc;
  
  if ((buffer eq Null(char)) || (curname eq Null(char)))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }

  if (Read(Stdin, (BYTE *) buffer, message->Arg1, ExtraReadTimeout) ne
  	message->Arg1)
   CommunicationsBreakdown(8);

  MachineName(curname);
  processor	= Locate(Null(Object), curname);
  if (processor eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }

  rc = Rename(processor, Null(char), buffer);
  
done:
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(9);
  if (buffer ne Null(char)) Free(buffer);
  if (curname ne Null(char)) Free(curname);
  if (processor ne Null(Object)) Close(processor);
}

/**-----------------------------------------------------------------------------
*** Update the name of an I/O processor at the other end of the specified
*** link. For example, change it from /IO to /Net/IO.
**/
static void	do_UpdateIO(NA_Message *message)
{ int		link = message->Arg1;
  char		*buffer		= (char *) Malloc(message->Arg2);
  char		*procname 	= (char *) Malloc(IOCDataMax);
  char		linkbuf[10];	/* link.267\0 */
  Object	*processor	= Null(Object);
  int		rc;
    
  if ((buffer eq Null(char)) || (procname eq Null(char)))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }
  
  if (Read(Stdin, (BYTE *) buffer, message->Arg2, ExtraReadTimeout) ne
  	message->Arg2)
   CommunicationsBreakdown(10);
   
  MachineName(procname);
  processor	= Locate(Null(Object), procname);
  if (processor eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_Processor; goto done; }
   
  strcpy(linkbuf, "link.");
  if (link eq 0)
   strcat(linkbuf, "0");	/* addint() does not cope with 0 */
  else
   addint(linkbuf, link);
   
  rc = Rename(processor, linkbuf, buffer);

done:
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(11);
  if (buffer ne Null(char)) Free(buffer);
  if (procname ne Null(char)) Free(procname);
  if (processor ne Null(Object)) Close(processor);  
}

/**-----------------------------------------------------------------------------
*** This routine should clean out the processor.
*** Essentially it performs several walkdirs.
*** 1) a WalkDir of /tasks to find any programs that should not be running
*** 2) a WalkDir of /loader to delete any unused libraries
*** 3) possibly a WalkDir of /pipe if the pipe server is running
*** 4) ditto for /fifo
*** 5) ditto for /ram
**/
static void	WalkDir(Object *x, VoidFnPtr fn);
static bool	pipe_running	= FALSE;
static bool	fifo_running	= FALSE;
static bool	ram_running	= FALSE;
static void	kill_task(Object *task);
static void	kill_something(Object *whatever);
static word	cleaning_date;

static void	do_Clean(NA_Message *message)
{ WORD	rc = Err_Null;
  Object	*procman = Locate(Null(Object), "/tasks");
  Object	*loader	 = Locate(Null(Object), "/loader");

  cleaning_date = message->Arg1;

  if (procman ne Null(Object))
   { WalkDir(procman, &kill_task); Close(procman); }

	/* This has to be repeated several times, because libraries	*/
	/* may depend on other libraries which depend on yet other	*/
	/* libraries...							*/  
  if (loader ne Null(Object))
   { WalkDir(loader, &kill_something); Close(loader); }

  if (pipe_running)
   { Object	*pipe_server = Locate(Null(Object), "/pipe");
     if (pipe_server ne Null(Object))
      { WalkDir(pipe_server, &kill_something);
        Close(pipe_server);
      }
   }
   
  if (fifo_running)
   { Object	*fifo_server = Locate(Null(Object), "/fifo");
     if (fifo_server ne Null(Object))
      { WalkDir(fifo_server, &kill_something);
        Close(fifo_server);
      }
   }
   
  if (ram_running)
   { Object	*ram_server = Locate(Null(Object), "/ram");
     if (ram_server ne Null(Object))
      { WalkDir(ram_server, &kill_something);
        Close(ram_server);
      }
   }
   
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(12);
}

static void WalkDir(Object *dir, VoidFnPtr fn)
{ Stream  	*s;
  WORD		size, i;
  DirEntry	*entry, *cur;
  Object	*item;
  
  if ((dir->Type & Type_Flags) eq Type_Stream) return;
   
  s = Open(dir, Null(char), O_ReadOnly);
  if (s eq Null(Stream))
   { IOdebug("netagent: error cleaning %s (%x)", dir->Name, Result2(dir));
     return; 
   }

  size = GetFileSize(s);

  if (size eq 0) return;
  entry = (DirEntry *) Malloc(size);
  if (entry == Null(DirEntry)) 
   { IOdebug("netagent: out of memory cleaning %s", dir->Name);
     Close(s); 
     return;
   }
     
  if ((size = Read(s, (BYTE *) entry, size, -1)) < 0)
   { IOdebug("netagent: read error cleaning %s", dir->Name);
     Close(s);
     return;
   }

  Close(s);
      
  cur = entry;
  for (i = 0; i < size; cur++, i += sizeof(DirEntry) )
   { if ( (!strcmp(cur->Name, ".")) || (!strcmp(cur->Name, "..")) )
      continue;

     item = Locate(dir, cur->Name);
     if (item ne Null(Object))
      { (*fn)(item);
        Close(item);
      }
   }

  Free(entry);
}

	/* delete something from a ram-disk or similar */
static void	kill_something(Object *x)
{ if ((x->Type & Type_Flags) eq Type_Directory)
   WalkDir(x, &kill_something);
  Delete(x, Null(char));
}

	/* kill a task. Several tasks are exempt from this. 		*/
	/* Also, commands started by the Network Server are exempt	*/
static	void kill_task(Object *task)
{ char		*name = objname(task->Name);
  Object	*temp;
  int		i;
  ObjInfo	info;
      
  if (!strncmp(name, "netagent.", 9))	return;
  if (!strncmp(name, "Fifo.", 5)) { fifo_running = TRUE; return; }
  if (!strncmp(name, "Loader.", 7))	return;
  if (!strncmp(name, "Null.", 5))	return;
  if (!strncmp(name, "Pipe.", 5)) { pipe_running = TRUE; return; }
  if (!strncmp(name, "ProcMan.", 8))	return;
  if (!strncmp(name, "Ram.", 4)) { ram_running = TRUE; return; }

  if (ObjectInfo(task, Null(char), (BYTE *) &info) < Err_Null)
   return;
  if (info.Dates.Creation <= cleaning_date) return;

#if 0  
  for (i = 0; i < 3; i++)
   { temp = Locate(task, Null(char));
     if (temp eq Null(Object)) break;
     (void) Delete(temp, Null(char));
     Close(temp);
   } 
#else
  temp = Locate(task, Null(char));
  if (temp eq Null(Object)) return;
  temp->FnMod |= 2;
  (void) Delete(temp, Null(char));
  Close(temp);
#endif
}
	
/**-----------------------------------------------------------------------------
*** Clearing the names involves sending a message to the processor manager.
*** Currently no special capability is required. The network server expects
*** a single reply, mostly for synchronisation.
**/
static void	do_ClearNames(NA_Message *message)
{ Object	*procman = Null(Object);
  word		rc = Err_Null;
  MsgBuf	*r = New(MsgBuf);
  
  if (r eq Null(MsgBuf))
   { rc = EC_Error + SS_NetServ + EG_NoMemory + EO_Message; goto done; }

  procman = Locate(Null(Object), "/tasks");  
  if (procman eq Null(Object))
   { rc = EC_Error + SS_NetServ + EG_Unknown + EO_ProcMan; goto done; }

  InitMCB(&(r->mcb), MsgHdr_Flags_preserve, NullPort, NullPort, 
          FC_GSP + FG_Reconfigure);
  r->mcb.Control = r->control;
  r->mcb.Data	 = r->data;
  MarshalCommon(&(r->mcb), procman, Null(char));
  SendIOC(&(r->mcb));

done:
  if (r ne Null(MsgBuf)) Free(r);
  if (procman ne Null(Object)) Close(procman);
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(13);
  message = message;
}

#ifdef __TRAN
/**-----------------------------------------------------------------------------
*** Perform a Parsytec reset down the link specified by Arg1 of the message.
*** Do not bother to send back a reply.
**/
static void	do_ParsytecReset(NA_Message *message)
{ int link = message->Arg1;
  Parsytec_Reset(link);
}
#endif

/**-----------------------------------------------------------------------------
*** Get the current link mode
**/
static void	do_GetLinkMode(NA_Message *message)
{ int		link = message->Arg1;
  int		mode;
  LinkInfo	info;
  int		rc;

  if (LinkData(link, &info) < Err_Null)
   { rc = RmE_BadLink; goto done; }

  switch(info.Mode)
   { case	Link_Mode_Null : mode = RmL_NotConnected; break;
     case	Link_Mode_Dumb : mode = RmL_Dumb; break;
     case	Link_Mode_Intelligent :
			     	if (info.State eq Link_State_Running)
			     	 mode = RmL_Intelligent;
			     	elif (info.State eq Link_State_Dead)
			     	 mode = RmL_Pending;
		     		else
		     		 mode = RmL_Dead;
				break;
     default : rc = RmE_BadLink; goto done;
   }

  rc = RmE_Success;     

done:
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
   CommunicationsBreakdown(14);
  if (rc eq RmE_Success)
   if (Write(Stdout, (BYTE *) &mode, sizeof(WORD), ReplyTimeout) ne sizeof(WORD))
    CommunicationsBreakdown(15);  
}

@


1.8
log
@the network agent was not enabling all the links it should be enabling
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netagent.c,v 1.4 90/09/20 17:42:29 bart Exp $";
d35 1
a35 1
#define	HANDBOOT
d183 1
d231 1
d333 4
a336 1
*** After a bootstrap, ensure that the link is in a sensible state
d348 1
a348 1
  conf.State	= Link_State_Running;
d355 18
d864 2
a865 1
  
d871 8
a878 1
   }  
@


1.7
log
@the cleaners are now careful not to kill off programs started by the
Network Server
@
text
@d86 1
d113 2
a114 1

d120 1
a120 1
      	 CommunicationsBreakdown(1);
d439 3
a441 2
  if (mode & RmL_Report)	/* implies that the report flag should be set */
   { conf.Flags |= Link_Flags_report;
d502 2
a503 1
      { conf.Flags		|= Link_Flags_report;
d531 1
d533 1
d656 1
a656 1
   
d730 1
a730 1
  
@


1.6
log
@sources update after visit to Parsytec 22.10.90-31.10.90

@
text
@d430 1
a430 1

d437 5
a441 1

d498 5
a502 1
     
d716 1
d723 2
a724 1
  message = message;
d816 2
a817 3
	/* kill a task. Several tasks are exempt from this 	*/
	/* BLV - commands run by the network server should also	*/
	/* be exempt, somehow.					*/
d822 2
a823 1
    
d831 5
@


1.5
log
@minor bug fixes in time for Helios 1.2 beta1 release
@
text
@d81 2
a82 1
static void	CommunicationsBreakdown(void);
d87 4
d100 2
a101 1

d114 1
a114 1
   { if (Read(Stdin, (BYTE *) &message, sizeof(NA_Message), -1) <
d116 6
a121 2
      	 CommunicationsBreakdown();
     
d140 1
a140 1
       
d148 3
a150 2
static void	CommunicationsBreakdown(void)
{ IOdebug("Netagent: communications breakdown, fault 0x%x", Result2(Stdin));
d198 3
a200 2
  if (Read(Stdin, nucleus_string, message->Arg2, -1) ne message->Arg2)
   CommunicationsBreakdown();
d217 1
a217 1
     Delay(10000);	/* 10 milliseconds */
d222 7
a228 1
   transputer_set_link(link);
d234 2
a235 2
  if (Write(Stdout, (BYTE *) &rc, sizeof(word), -1) ne sizeof(WORD))
   CommunicationsBreakdown();
d358 1
a358 1
  Delay(10000);	/* 10 Msec */
d389 5
a393 2
  Delay(1000);		/* One millisecond for nboot.i to settle down */

d401 4
a404 1

d467 1
d484 2
a485 2
  if (Read(Stdin, link_modes, number_links, 5 * OneSec) ne number_links)
   CommunicationsBreakdown();
d547 1
a547 1
  if (Read(Stdin, (BYTE *) &full_cap, sizeof(Capability), 5 * OneSec) ne
d549 1
a549 1
   CommunicationsBreakdown();
d604 1
a604 1
  if (Write(Stdout, (BYTE *) &(message->FnRc), sizeof(word), 5 * OneSec)
d606 1
a606 1
   CommunicationsBreakdown();
d608 1
a608 1
   if (Write(Stdout, (BYTE *) result, 3 * sizeof(Capability), 5 * OneSec)
d610 1
a610 1
    CommunicationsBreakdown();
d634 1
a634 1
  if (Read(Stdin, (BYTE *) buffer, message->Arg1, 5 * OneSec) ne
d636 1
a636 1
   CommunicationsBreakdown();
d646 2
a647 2
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), 5 * OneSec) ne sizeof(WORD))
   CommunicationsBreakdown();
d668 1
a668 1
  if (Read(Stdin, (BYTE *) buffer, message->Arg2, 5 * OneSec) ne
d670 1
a670 1
   CommunicationsBreakdown();
d686 2
a687 2
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), 5 * OneSec) ne sizeof(WORD))
   CommunicationsBreakdown();
d695 14
a708 2
BLV implement
**/
d711 86
a796 2
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), 5 * OneSec) ne sizeof(WORD))
   CommunicationsBreakdown();
d799 30
d856 2
a857 2
  if (Write(Stdout, (BYTE *) &rc, sizeof(WORD), 5 * OneSec) ne sizeof(WORD))
   CommunicationsBreakdown();
d871 37
@


1.4
log
@transputer bootstraps now compiled in only for transputer version
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netagent.c,v 1.3 90/09/14 18:05:52 bart Exp Locker: bart $";
d95 1
a95 1
  
@


1.3
log
@Put in the handboot option, for now
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netagent.c,v 1.2 90/09/14 12:48:58 bart Exp Locker: bart $";
d68 1
d70 1
d77 1
d79 1
d114 1
d119 1
d126 1
d128 1
d154 1
d166 1
d390 2
d710 1
d719 1
@


1.2
log
@some silly C type casting cleaned up, not picked up by the old compiler
@
text
@d20 1
a20 1
static char *rcsid = "$Header: /usr/perihelion/Helios/network/RCS/netagent.c,v 1.1 90/09/12 14:34:41 jon Exp Locker: bart $";
d35 1
@


1.1
log
@Initial revision
@
text
@d20 1
a20 1
static char *rcsid = "$Header$";
d185 1
a185 1
  if (system_image eq Null(void)) goto done;
d202 1
a202 1
  if ((strlen(nucleus_string) > 0) && (system_image ne Null(void)))
@
