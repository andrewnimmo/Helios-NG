head	1.68;
access;
symbols
	Helios_1_3_1:1.68
	Helios_C40_1_3_Official_Release:1.63
	Alenia_release:1.61
	Helios1_3:1.57
	C40_Field_Test_2:1.56
	C40_Field_Test_R1:1.50
	Helios13_beta:1.50
	Helios1_2_2:1.41
	Helios1_2_2Beta:1.39
	Helios1_2_1:1.32
	Helios1_2:1.20
	V1_2Beta0:1.4;
locks; strict;
comment	@ * @;


1.68
date	93.09.01.17.53.50;	author bart;	state Exp;
branches;
next	1.67;

1.67
date	93.08.06.12.43.48;	author bart;	state Exp;
branches;
next	1.66;

1.66
date	93.07.29.11.04.50;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	93.07.26.16.19.50;	author paul;	state Exp;
branches;
next	1.64;

1.64
date	93.07.09.13.08.43;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	93.03.04.15.50.49;	author bart;	state Exp;
branches;
next	1.62;

1.62
date	93.02.02.15.43.24;	author bart;	state Exp;
branches;
next	1.61;

1.61
date	92.12.04.17.02.57;	author bart;	state Exp;
branches;
next	1.60;

1.60
date	92.12.04.16.46.48;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	92.12.04.16.09.20;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	92.11.20.17.40.33;	author nick;	state Exp;
branches;
next	1.57;

1.57
date	92.10.26.10.43.54;	author bart;	state Exp;
branches;
next	1.56;

1.56
date	92.10.08.09.33.17;	author bart;	state Exp;
branches;
next	1.55;

1.55
date	92.09.15.15.59.48;	author paul;	state Exp;
branches;
next	1.54;

1.54
date	92.09.04.09.20.01;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	92.09.02.16.05.53;	author bart;	state Exp;
branches;
next	1.52;

1.52
date	92.08.14.12.58.58;	author bart;	state Exp;
branches;
next	1.51;

1.51
date	92.08.04.16.23.59;	author paul;	state Exp;
branches;
next	1.50;

1.50
date	92.06.21.19.00.47;	author bart;	state Exp;
branches;
next	1.49;

1.49
date	92.06.17.10.09.07;	author paul;	state Exp;
branches;
next	1.48;

1.48
date	92.06.16.16.07.14;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	92.06.15.11.12.35;	author paul;	state Exp;
branches;
next	1.46;

1.46
date	92.06.12.12.56.38;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	92.05.18.14.08.42;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	92.05.02.10.42.08;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	92.04.21.10.27.52;	author paul;	state Exp;
branches;
next	1.42;

1.42
date	92.04.16.00.23.37;	author paul;	state Exp;
branches;
next	1.41;

1.41
date	91.10.14.09.19.40;	author paul;	state Exp;
branches;
next	1.40;

1.40
date	91.10.01.16.01.32;	author nick;	state Exp;
branches;
next	1.39;

1.39
date	91.08.13.14.17.09;	author nick;	state Exp;
branches;
next	1.38;

1.38
date	91.08.05.12.42.08;	author nick;	state Exp;
branches;
next	1.37;

1.37
date	91.07.11.12.29.23;	author nick;	state Exp;
branches;
next	1.36;

1.36
date	91.06.19.22.31.28;	author paul;	state Exp;
branches;
next	1.35;

1.35
date	91.06.17.15.44.55;	author bart;	state Exp;
branches;
next	1.34;

1.34
date	91.06.04.17.06.04;	author nick;	state Exp;
branches;
next	1.33;

1.33
date	91.05.30.13.51.14;	author chris;	state Exp;
branches;
next	1.32;

1.32
date	91.03.25.16.38.52;	author paul;	state Exp;
branches;
next	1.31;

1.31
date	91.03.20.13.31.36;	author paul;	state Exp;
branches;
next	1.30;

1.30
date	91.02.25.15.59.42;	author nick;	state Exp;
branches;
next	1.29;

1.29
date	91.02.19.11.20.35;	author nick;	state Exp;
branches;
next	1.28;

1.28
date	91.02.19.10.57.41;	author nick;	state Exp;
branches;
next	1.27;

1.27
date	91.02.13.17.30.16;	author paul;	state Exp;
branches;
next	1.26;

1.26
date	91.02.11.17.12.33;	author nick;	state Exp;
branches;
next	1.25;

1.25
date	91.02.07.17.42.48;	author paul;	state Exp;
branches;
next	1.24;

1.24
date	91.02.07.17.25.46;	author nick;	state Exp;
branches;
next	1.23;

1.23
date	91.02.07.16.01.25;	author paul;	state Exp;
branches;
next	1.22;

1.22
date	91.01.22.17.28.08;	author paul;	state Exp;
branches;
next	1.21;

1.21
date	91.01.04.12.41.01;	author nick;	state Exp;
branches;
next	1.20;

1.20
date	90.11.29.13.07.31;	author paul;	state Exp;
branches;
next	1.19;

1.19
date	90.11.29.11.27.23;	author nick;	state Exp;
branches;
next	1.18;

1.18
date	90.11.27.19.16.17;	author nick;	state Exp;
branches;
next	1.17;

1.17
date	90.11.18.21.46.23;	author paul;	state Exp;
branches;
next	1.16;

1.16
date	90.11.15.16.09.57;	author nick;	state Exp;
branches;
next	1.15;

1.15
date	90.11.08.16.33.29;	author nick;	state Exp;
branches;
next	1.14;

1.14
date	90.11.02.16.28.20;	author paul;	state Exp;
branches;
next	1.13;

1.13
date	90.11.01.16.33.59;	author nick;	state Exp;
branches;
next	1.12;

1.12
date	90.10.23.19.27.54;	author paul;	state Exp;
branches;
next	1.11;

1.11
date	90.10.19.11.13.50;	author nick;	state Exp;
branches;
next	1.10;

1.10
date	90.10.18.17.56.32;	author nick;	state Exp;
branches;
next	1.9;

1.9
date	90.10.16.10.28.24;	author nick;	state Exp;
branches;
next	1.8;

1.8
date	90.10.04.18.19.17;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	90.09.29.16.38.16;	author nick;	state Exp;
branches;
next	1.6;

1.6
date	90.09.29.16.32.06;	author nick;	state Exp;
branches;
next	1.5;

1.5
date	90.09.25.18.20.45;	author paul;	state Exp;
branches;
next	1.4;

1.4
date	90.09.05.18.22.17;	author nick;	state Exp;
branches;
next	1.3;

1.3
date	90.09.05.13.08.12;	author nick;	state Exp;
branches;
next	1.2;

1.2
date	90.08.28.13.21.57;	author nick;	state Exp;
branches;
next	1.1;

1.1
date	90.08.28.13.06.49;	author nick;	state Exp;
branches;
next	;


desc
@Processor Manager
@


1.68
log
@Now that the server library is compiled with stack checking and
with a vector stack, the transputer stack size for various threads
has had to be upped from 1200 to 1250 bytes.
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--                     H E L I O S   N U C L E U S                      --
--                     ---------------------------                      --
--                                                                      --
--             Copyright (C) 1987, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- procman.c								--
--                                                                      --
--	Processor Manager						--
--                                                                      --
--	Author:  NHG 16/8/87						--
--                                                                      --
------------------------------------------------------------------------*/
/* SccsId: %W%	%G% (C) 1987, Perihelion Software Ltd. 	*/
/* $Id: procman.c,v 1.67 1993/08/06 12:43:48 bart Exp bart $ */

#include <helios.h>	/* standard header */

#define __in_procman 1	/* flag that we are in this module */

#define FORKIOCWORKER 1	/* Fork a new thread for each IOC request	*/

#define REALSEARCH	/* set if we are using real parallel search	*/

#define TIMEOUTS 1	/* set to 1 if timeouts are to be used		*/

#define TESTSYS	0	/* test links for flow control			*/

#define PMTRACE(x) 	/* _Trace(0xbbbb0000|(x))			*/

/*--------------------------------------------------------
-- 		     Include Files			--
--------------------------------------------------------*/

#include <stdarg.h>
#include <stddef.h>
#include <string.h>
#include <queue.h>
#include <root.h>
#include <config.h>
#include <message.h>
#include <link.h>
#include <task.h>
#include <sem.h>
#include <protect.h>
#include <codes.h>
#include <gsp.h>
#include <process.h>
#include <syslib.h>
#include <servlib.h>
#include <module.h>
#include <nonansi.h>

#ifdef __TRAN
# include <asm.h>	/* for testerr_() */
#endif
#ifdef __ARM
# include <arm.h>	/* For EnterSVC/UserMode() */
#endif

#include <signal.h>	/* for SIGALRM */

extern word CallWithModTab(word arg1, word arg2, WordFnPtr fn, word *modtab);


/*--------------------------------------------------------
--		Data Definitions 			--
--------------------------------------------------------*/

typedef struct NameEntry {
	ObjNode		ObjNode;	/* node in servlib structures	*/
	Node		HashNode;	/* link in hash table		*/
	Port		Server;		/* server port			*/
	word		*LoadData;	/* auto load data		*/
	word		Confidence;	/* in aliveness of server	*/
	word		Distance;	/* distance from this processor */
} NameEntry;

typedef struct NameDir {
	DirNode		DirNode;	/* node in servlib structures	*/
	Node		HashNode;	/* link in hash table		*/
	Port		Server;		/* server port			*/
	word		*LoadData;	/* auto load data		*/
	word		Confidence;	/* in aliveness of server	*/	
	word		Distance;	/* distance from this processor */
} NameDir;

typedef struct TaskEntry {
	ObjNode		ObjNode;	/* node in servlib strucures	*/
	Task		*Task;		/* pointer to task struct	*/
	Stream		*Code;		/* Stream struct for loaded code*/
	word		UseCount;	/* number of opens		*/
	word		AlarmTime;	/* seconds until an alarm	*/
	Port		ProgInfoPort;	/* port to send prog info to 	*/
	word		ProgInfoMask;	/* mask of info bits		*/
	word		ProgInfoSent;	/* # of proginfos sent		*/
	word		TermCode;	/* termination code		*/
	bool		Running;	/* true if task is running	*/
	word		KillState;	/* task deletion state		*/
	Port		SignalPort;	/* port for signal delivery	*/
} TaskEntry;
#define Status		ObjNode.Account	/* visible status word		*/

typedef struct SockEntry {
	ObjNode		ObjNode;	/* node in servlib structures	*/
	Node		HashNode;	/* link in hash table		*/
	Port		Server;		/* reqport of server process	*/
	word		Protocol;	/* protocol type		*/
	word		Confidence;	/* in aliveness of server	*/
	word		Distance;	/* distance from this processor */
} SockEntry;
#define	BackLog		ObjNode.Size	/* pending connection backlog	*/
#define WaitQ		ObjNode.Contents/* queue of Waiters		*/
#define Users		ObjNode.Account /* number of users		*/

#define		HashSize	31		/* should be prime	*/

static Semaphore	HashLock;		/* Hash table lock	*/

static List		HashTable[HashSize];	/* the table		*/

static NameDir		*NameTableRoot;		/* name table root	*/

static NameDir		*ThisMc;		/* name table entry for me */

static DirNode		TaskTable;		/* task table root	*/

static TaskEntry	MyTaskEntry;		/* Task table entry for ProcMan */

static Port		NameTabReqPort;		/* name table server port */

static LinkInfo	*ParentLink;			/* the link which booted us */

static RootStruct	*Root;

static SockEntry	*DotSocket;		/* socket server entry	*/

static word		SockId = 1;		/* anonymous socket nos	*/

static word		TaskErr;		/* NewTask error	*/

static word		TaskId = 1;		/* task identifier counter */

#define			SearchSize	32	/* multiple of 2 */
static word		SearchTable[SearchSize];/* id's of recent searches */
static word		STOffset = 0;		/* offset into table (mod SearchSize) */
static word		IdSeed;			/* seed for Id		*/


static struct {
	word	IOCs;		/* number of IOCs		*/
	word	Servers;	/* open task servers		*/
	word	NameEntries;	/* number of NameTable entries	*/
	word	Tasks;		/* number of tasks		*/
	word	MsgBufs;	/* number of message buffers	*/
	word	Misc;		/* miscellaneous memory		*/
	word	Workers;	/* other worker processes	*/
} DbInfo;

static Semaphore KillLock;

static Semaphore SearchLock;

static Semaphore DbgLock;

#define DB_IOC1		1
#define DB_IOC2		2
#define DB_IOC3		4
#define DB_SEARCH	8
#define DB_LINK		16
#define DB_SEARCHWK	32
#define DB_MEM		64
#define DB_TASKS	128
#define DB_INFO		0x01000000
#define DB_ARM		0x10000000

#ifdef __TRAN
static word dbmask = 0;
#else
static word dbmask = 0;
#endif

#define debugging(x) (dbmask&(x))

#ifdef __TRAN
# define returnlink_(x) (((void **)(&(x)))[-2])
#else
# if defined(__C40) || defined(__ARM)
# define returnlink_(x)	NULL
# else
void *_linkreg(void);
# define returnlink_(x) (_linkreg()) /* return pointer to callers code */
# endif
#endif

/*--------------------------------------------------------
--		Stack handling				--
--------------------------------------------------------*/

#if defined(__TRAN) && !defined(PMDEBUG)
	/* Transputer Helios does not have automatic stack extension.	*/
	/* Please do not change these sizes. BLV.			*/
# define PMSTACKSIZE		1250
# define NTSTACKSIZE		1250
# define SOCKSTACKSIZE		1250
# define ClockStackSize		1000
# define IOCStackSize		1000
# define LinkIOCStack		1000
# define NSReqStackSize		1250
# define SearchStackSize	1000
# define DbgWorkStackSize	400

#else
#if defined(STACKEXTENSION)
	/* Some processors have automatic stack extension support.	*/
	/* N.B. stack checking must be used !!!				*/
	/* The sizes are a compromise between memory efficiency and	*/
	/* excessive stack extension with the fragmentation that would	*/
	/* result. N.B. stack sizes passed to the server library must	*/
	/* allow for a servinfo structure, 536 bytes plus a jump buffer,*/
	/* which will be held on the stack. NewProcess() should handle	*/
	/* the jump buffer extra. NSReqStackSize is similarly		*/
	/* affected.							*/
# define PMSTACKSIZE		1200
# define NTSTACKSIZE		1000
# define SOCKSTACKSIZE		1200

# define IOCStackSize		750
# define LinkIOCStack		750
# define NSReqStackSize		1000
# define SearchStackSize	750
# define DbgWorkStackSize	500

#ifndef STACKCHECK
#error Stack checking must be enabled when compiling this module.
#endif

#else
	/* These sizes should be used on the transputer when debugging	*/
	/* is enabled, on any processor without automatic stack		*/
	/* extension, or when porting to a new processor.		*/
# define PMSTACKSIZE		3000
# define NTSTACKSIZE		3000
# define SOCKSTACKSIZE		3000

# define IOCStackSize		4000
# define LinkIOCStack		4000
# define NSReqStackSize		4000
# define SearchStackSize	4000
# define DbgWorkStackSize	2000
#endif
#endif

#ifdef STACKCHECK
	/* Stack checking within the Processor Manager is controlled	*/
	/* by -DSTACKCHECK on the command line, not by -ps1 or similar	*/
	/* pragmas. On the transputer the stack overflow routine is	*/
	/* part of the C library, not part of the kernel, so the	*/
	/* Processor Manager must supply its own routine.		*/
#ifdef __TRAN
extern void _Trace(...);
#    pragma -s1

static void _stack_error(Proc *p)
{
	_Trace(0xaaaaaaaa,p);
	IOdebug("ProcMan stack overflow in %s at %x",p->Name,&p);	
}
#endif

	/* Enable stack checking if -DSTACKCHECK			*/
#    pragma -s0

#else

	/* Otherwise disable stack checking.				*/
# pragma -s1

#endif

/*--------------------------------------------------------
--		External References			--
--------------------------------------------------------*/

extern int splitname(char *, char, char *);
extern word KillTask(Task *);
extern _BootLink(word id, void *image, Config *conf, word confsize);
extern word _cputime(void);
extern word _ldtimer(word pri);
extern void ErrorMsg(MCB *, word );
extern void IOputs(char *s);

/*--------------------------------------------------------
--		Forward References			--
--------------------------------------------------------*/
#if defined(PMDEBUG)
# if 0 /* defined(__TRAN) */
static void NullTest(void);
void TestNull(void);
# endif
static void *PMalloc(int size);
static void PFree(void *m);
static bool PFork(int ssize, VoidFnPtr f, int asize, ... );
# undef New
# define New(_type)	(_type *)PMalloc(sizeof(_type))
#else
# define PMalloc	Malloc
# define PFree	Free
# define PFork	Fork
#endif
static void RunInit(void);
static TaskEntry *NewTask(string name,MPtr prog,Port parent,Matrix access, bool dirlocked);
static void IOC(TaskEntry *);
static void LinkIOC(LinkInfo *);
#if 0
static void DoBootLink(MsgBuf *m, LinkInfo *link, string name);
#endif
#if FORKIOCWORKER
static void CallIOCWorker(MsgBuf *m, TaskEntry *entry);
#endif
static MsgBuf *IOCWorker(MsgBuf *m, LinkInfo *link, string clientname);
static void protect(IOCCommon *req, NameEntry *n, bool local);
static void NSRequest(MsgBuf *m, DirNode *d,DispatchInfo *info);
static bool PrivateProtocol(TaskEntry *entry, MsgBuf *m);
static void LinkIOCWorker(MsgBuf *m, LinkInfo *link, NameEntry *n);
static void LinkFault(MsgBuf *m, LinkInfo *link, word code);
static MsgBuf *Search(string name, LinkInfo *link, word id);
static void SearchWorker(MsgBuf *m, LinkInfo *link);
static word HandleException(MCB *m, TaskEntry *task);
static void GenProgInfo(TaskEntry *entry);
static void DestroyTask(TaskEntry *entry);
static void LoadServer(NameEntry *n);
static Port DefaultAct( char *name, word *data );
static void dbg(char *, ... );
static void dbgworker(string dbline);
static NameEntry *NewName(NameDir *,string,word,word,Port,Matrix,word *,bool);
static word hash(char *s);
static string makename(string,string);
static void getpath(string s, DirNode *d);
static NameEntry *AddName(string name, Port port, word Flags);
static void AddHash(NameDir *n);
static void DoSignal(word signal, TaskEntry *entry);
static word NewId(void);
static void RemName(NameEntry *n);

static void do_serverinfo(ServInfo *);

static void pm_open(ServInfo *);
static void pm_create(ServInfo *);
static void pm_delete(ServInfo *);
static bool pm_private(ServInfo *);

static DispatchInfo ProcManInfo = {
	&TaskTable,
	NullPort,
	SS_ProcMan,
	NULL,
	{ (VoidFnPtr)pm_private, PMSTACKSIZE },
	{
		{ pm_open,	PMSTACKSIZE	},
		{ pm_create,	PMSTACKSIZE	},
		{ DoLocate,	0		},
		{ DoObjInfo,	0		},
		{ do_serverinfo,0		},
		{ pm_delete,	PMSTACKSIZE },
		{ DoRename,	0		},
		{ InvalidFn,	0		},
		{ DoProtect,	0		},
		{ DoSetDate,	0		},
		{ DoRefine,	0		},
		{ NullFn,	0		},
		{ DoRevoke,	0		},
		{ InvalidFn,	0		},
		{ InvalidFn,	0		}
	}
};
 
static void nt_open(ServInfo *);
static void nt_create(ServInfo *);
static void nt_delete(ServInfo *);
static void nt_rename(ServInfo *);

static DispatchInfo NameTableInfo = {
	NULL,
	NullPort,
	SS_NameTable,
	"",
	{ NULL,	0 },
	{
		{ nt_open,	NTSTACKSIZE	},
		{ nt_create,	NTSTACKSIZE	},
		{ DoLocate,	0		},
		{ DoObjInfo,	0		},
		{ do_serverinfo,0		},
		{ nt_delete,	NTSTACKSIZE },
		{ nt_rename,	NTSTACKSIZE },
		{ DoLink,	0		},
		{ DoProtect,	0		},
		{ DoSetDate,	0		},
		{ DoRefine,	0		},
		{ NullFn,	0		},
		{ DoRevoke,	0		},
		{ InvalidFn,	0		},
		{ InvalidFn,	0		}
	}
};

static word so_private(ServInfo *);

static DispatchInfo SocketInfo = {
	NULL,
	NullPort,
	SS_ProcMan,
	"",
	{ (VoidFnPtr)so_private,SOCKSTACKSIZE},
	{
		{ InvalidFn,	0		},
		{ InvalidFn,	0		},
		{ DoLocate,	0		},
		{ DoObjInfo,	0		},
		{ do_serverinfo,0		},
		{ InvalidFn,	0		},
		{ InvalidFn,	0		},
		{ DoLink,	0		},
		{ DoProtect,	0		},
		{ DoSetDate,	0		},
		{ DoRefine,	0		},
		{ NullFn,	0		},
		{ DoRevoke,	0		},
		{ InvalidFn,	0		},
		{ InvalidFn,	0		 }
	}
};

/*--------------------------------------------------------
-- main							--
--							--
-- Manager entry point					--
--							--
--------------------------------------------------------*/

int main()
{
	int i;
	Config *config = GetConfig();
	MPtr prog = MInc_(GetSysBase(),(config->FirstProg+1)*sizeof(MPtr));
	LinkNode *Parent;
	string myname, parentname;
	int len;
	char name[NameMax];

	/* as this is set before Dispatch(), incoming requests will be */
	/* handled at this priority */
	SetPriority(HighServerPri);

	Root = GetRoot();

	InitSemaphore(&DbgLock,1);

	InitSemaphore(&KillLock,1);

	InitSemaphore(&SearchLock,1);
	
#ifdef never /* defined(PMDEBUG) */
	PFork(ClockStackSize,NullTest,0);
#endif

	/* compatability ... */
	if( config->MyName == -1 ) myname = "/00";
	else myname = (string)RTOA(config->MyName);
	if( config->ParentName == -1 ) parentname = "/IO";
	else parentname = (string)RTOA(config->ParentName);

	IdSeed = *(word *)myname;
	MyTask->TaskEntry = &MyTaskEntry;	/* set before first malloc */
						/* so checktags gets taskname */

	InitSemaphore(&HashLock,1);

	for( i = 0 ; i < HashSize ; i++ ) InitList( &HashTable[i] );

	ThisMc = (NameDir *)(NameTableInfo.Root = 
				(DirNode *)(NameTableRoot = New(NameDir)));
	DbInfo.NameEntries++;
	InitNode( (ObjNode *)&NameTableRoot->DirNode, "", Type_Directory, 
		Flags_StripName|Flags_Seekable, DefNameMatrix );
 	InitList( &NameTableRoot->DirNode.Entries );
	NameTableRoot->DirNode.Key = 0;		/* all roots have same key */
	NameTableRoot->DirNode.Parent = NULL;
	NameTableRoot->DirNode.Nentries = 0;
	NameTableRoot->Confidence = 1000;
	NameTableRoot->Distance = 0;

	/* set up parent link before we crunch mcname */
	Parent = (LinkNode *)PMalloc(sizeof(LinkNode) + IOCDataMax);
	DbInfo.Misc += sizeof(LinkNode) + IOCDataMax;
	InitNode( &Parent->ObjNode, "..", Type_Link, 0, DefNameMatrix );
	NewCap(&Parent->Cap,(ObjNode *)&NameTableRoot->DirNode,AccMask_Full);
	strcpy(Parent->Link,myname);

	ProcManInfo.ParentName = Parent->Link;

	/* create initial name tree */
	while( *myname == c_dirchar ) myname++;
	while((len=splitname(name,c_dirchar,myname))!=0)
	{
		NameDir *d = ThisMc;
		ThisMc = New(NameDir);
		DbInfo.NameEntries++;		
		InitNode( (ObjNode *)&ThisMc->DirNode, name, Type_Directory, 
			Flags_StripName|Flags_Seekable, DefNameMatrix );
		InitList( &ThisMc->DirNode.Entries );
		ThisMc->DirNode.Parent = (DirNode *)d;
		ThisMc->DirNode.Nentries = 0;
		ThisMc->Confidence = 1000;
		Insert(&d->DirNode,(ObjNode *)&ThisMc->DirNode, FALSE);
		AddHash(ThisMc);
		myname+=len;
	}

	/* Processors own node is only name node which allows	*/
	/* its access matrix to be altered. And then only by a	*/
	/* local client.					*/
	ThisMc->DirNode.Matrix = DefNameMatrix|AccMask_A;
	
	/* set up /tasks directory */

	NameTabReqPort = NameTableInfo.ReqPort = NewPort();

	InitNode( (ObjNode *)&TaskTable, "tasks", Type_Directory, Flags_StripName|Flags_Seekable, DefRootMatrix );

	InitList( &TaskTable.Entries );
	TaskTable.Nentries = 0;
	TaskTable.Parent = (DirNode *)Parent;

	(void)NewName(ThisMc,"tasks",Type_Name,Flags_StripName,
		ProcManInfo.ReqPort=NewPort(),DefNameMatrix,NULL,FALSE);

	/* build a TaskEntry for myself */
	InitNode(&MyTaskEntry.ObjNode, "ProcMan.0", Type_Task, 0, DefTaskMatrix );
	Insert(&TaskTable, &MyTaskEntry.ObjNode, FALSE );
	MyTaskEntry.Task = MyTask;
	MyTaskEntry.Running = true;
	MyTaskEntry.UseCount = 0;
	MyTaskEntry.AlarmTime = 0;
	MyTaskEntry.ProgInfoPort = NullPort;
	MyTaskEntry.ProgInfoMask = 0;
	MyTaskEntry.ProgInfoSent = 0;
	MyTaskEntry.Code = 0;
	MyTaskEntry.KillState = 0;
	
	/* install an IOC port for processor manager */
	MyTask->IOCPort = NewPort();

	/* and fork an IOC for myself */
	PFork(IOCStackSize,IOC,4,&MyTaskEntry);

	ParentLink = NULL; /* if still NULL after search we must be a ROM loaded system */

	/* start up the link IOCs */
	{
		LinkInfo **linkv = Root->Links;
		while( *linkv != NULL )
		{
			if( ((*linkv)->Flags & Link_Flags_parent) != 0 )
			{
				ParentLink = *linkv;
				AddName(parentname,ParentLink->RemoteIOCPort,Flags_CacheName);
			}
			PFork(LinkIOCStack,LinkIOC,4,*linkv++);
		}

#ifdef __ABC
		if (ParentLink == NULL)
		/* (GetRoot()->Flags & Root_Flags_ROM) */
			/* default to link 0 for any possible future IO Server connection */
			AddName(parentname,Root->Links[0]->RemoteIOCPort,Flags_CacheName);
#endif
	}

	/* start up any other servers */
	while( MWord_(prog,0) )
	{
		MPtr p = MRTOA_(prog);
		if( ModuleWord_(p,Type) == T_Program )
		{
			word e;
			MCB m;
			char name[NameMax];
			Port SyncPort = NewPort();

			/*IOdebug("Starting server: %s",p->Module.Name);*/

			ModuleName_(name,p);
			(void)NewTask(makename(name,name),p,
					SyncPort,DefTaskMatrix,FALSE);

			/* && get ack message */
			InitMCB(&m,0,SyncPort,NullPort,0);

			while((e = GetMsg(&m)) != 0x456 );
			FreePort(SyncPort);

			/*IOdebug("Launched server: %s",p->Module.Name);*/
		}
		prog = MInc_(prog,sizeof(MPtr));
	}

#if 0
	/* BLV - is this causing problems ? */
	/* return acknowledge message to booter				*/
	/* except if it is an IO proc, or if we are a ROM booted system */
	/* The code returned looks like a link state change message, so	*/
	/* it will be sent to the network server by the booter.		*/
	if ( ParentLink != NULL && !(ParentLink->Flags & Link_Flags_ioproc))
	{
		word e;
		MCB m;

		InitMCB(&m,MsgHdr_Flags_preserve,
			ParentLink->RemoteIOCPort,NullPort,
				EC_Error|SS_ProcMan|EG_Broken|0x123);
		e = PutMsg(&m);
	}
#endif

#if 0
# undef Type_Auto
# define Type_Auto Type_Name
#endif

#ifndef __ABC /* these are part of the system image for ABC's Helios/ARM */
	(void)NewName(ThisMc,"ram" ,Type_Auto|Type_Directory,Flags_StripName,NullPort,DefNameMatrix,NULL,FALSE);
	(void)NewName(ThisMc,"null",Type_Auto|Type_Stream,Flags_StripName,NullPort,DefNameMatrix,NULL,FALSE);
#endif
	(void)NewName(ThisMc,"fifo",Type_Auto|Type_Directory,Flags_StripName,NullPort,DefNameMatrix,NULL,FALSE);
	(void)NewName(ThisMc,"pipe",Type_Auto|Type_Directory,Flags_StripName,NullPort,DefNameMatrix,NULL,FALSE);

	DotSocket = (SockEntry *)NewName(ThisMc,".socket",Type_Socket,0,NullPort,DefNameMatrix,NULL,FALSE);

	/* if we are a ROM loaded system or booted by IO Server, run init prog */
	/* BLV - Also if the rootnode flag is set */
	if( ParentLink == NULL || (ParentLink->Flags & Link_Flags_ioproc) ||
               (GetRoot()->Flags & Root_Flags_rootnode) )
	    	PFork(PMSTACKSIZE,RunInit,0);

	/*IOdebug("Procman dispatch - sys started");*/


#if TESTSYS
	{
		static void TestSys(void);
		PFork(PMSTACKSIZE,TestSys,0);
	}
#endif
	/* and finally drop into processor manager dispatcher */
	Dispatch(&ProcManInfo);
}

#if TESTSYS
static void TestSys(void)
{
	int xoff = 0;
	int stopped[4];
	RootStruct *root = GetRoot();
	int i;
	int dd = 0;
	
	for( i = 0; i < 4 ; i++ ) stopped[i] = 0;

	for(;;)
	{
		Delay(OneSec/4);
# if 0
		if( dd == 2 ) 
		{
			dd = 0;
			IOdebug("root %x fl %x links %x %x %x %x",root,root->Flags,
						root->Links[0]->Flags,
						root->Links[1]->Flags,
						root->Links[2]->Flags,
						root->Links[3]->Flags);
		}
		else dd++;
		
		if( root->Flags & Root_Flags_xoffed ) IOdebug("root xoff set");
		for( i = 0; root->Links[i] != NULL ; i++)
		{
			LinkInfo *link = root->Links[i];
			if( link->Flags & Link_Flags_stopped )
				IOdebug("link %d stopped",link->Id);
		}
# else
		if( root->Flags & Root_Flags_xoffed ) 
		{
			if( !xoff ) xoff=1,dbg("root xoff set");
		}
		elif( xoff ) xoff=0,dbg("root xoff cleared");
		
		for( i = 0; root->Links[i] != NULL ; i++)
		{
			LinkInfo *link = root->Links[i];
			if( link->Flags & Link_Flags_stopped )
			{
				if( !stopped[i] )
					stopped[i]=1,dbg("link %d stopped",i);
			}
			elif( stopped[i] ) 
				stopped[i]=0,dbg("link %d restarted",i);
		}
# endif
	}
}

#endif

/*--------------------------------------------------------
-- RunInit						--
--							--
-- Run init program					--
--							--
--------------------------------------------------------*/

static void RunInit(void)
{
	Object *o, *code;
	Stream *s;
	char name[NameMax];
	TaskEntry *e;
	
#ifdef __ABC
	/* ROM system startup support - only definite fs server available at boot */
	o = Locate(NULL,"/rom/sys/helios/lib/init");
#else
	o = Locate(NULL,"/helios/lib/init");
#endif

	if( o == NULL ) { IOdebug("Cannot find init"); return; }
	
	code = Load(NULL,o);
	
	if( code == NULL ) { IOdebug("Cannot load init %lx",Result2(o)); return; }
	
	s = Open(code,NULL,O_Execute);
	
	if( s == NULL ) { IOdebug("Cannot open init"); return; }
	
	e = NewTask(makename("init",name),(MPtr)s->Server,NullPort,
				DefTaskMatrix,FALSE);
				
	if( e == NULL ) { IOdebug("Cannot execute init"); return; }
	
	e->Code = s;
	
	Close( code );
	Close( o );
}

#if 0
# if defined(PMDEBUG)
#  if defined(__TRAN)

#define TESTSIZE	1024
#define TESTVAL(x)	(0xaa0000aa|((x)<<8))
/*#define TESTVAL(x)	(0)*/

static void NullTest()
{
	int i;
	word *null = NULL;
	bool firstnull = true;
	word errors = GetRoot()->Errors;
	DbInfo.Workers++;
	
	forever
	{
#  ifdef SYSDEB
		while( GetRoot()->Errors > errors )
		{
			IOdebug("%s Error Flag Set!!",ThisMc->DirNode.Name);
			errors = GetRoot()->Errors;
		}
#  endif
		if(debugging(DB_NULLTEST))
		{

			if( firstnull )
			{
				for( i = 0 ; i < TESTSIZE ; null[i++] = TESTVAL(i) );
				firstnull = false;
			}
			else 
				TestNull();
		}
		Delay(OneSec);
	}
}

void TestNull()
{
	int i;
	word *null = NULL;

	for( i = 0 ; i < TESTSIZE ; i++ )
		if( null[i] != TESTVAL(i) )
		{
			dbg("\t\t\t\t\t\t %s %x -> %x",
				ThisMc->DirNode.Name,i,null[i]);
			null[i] = TESTVAL(i);
		}
}
#  endif
# endif
#endif

/*--------------------------------------------------------
-- NewTask						--
--							--
-- Create a task and get it going			--
--							--
--------------------------------------------------------*/

static TaskEntry *NewTask(string name,MPtr prog,Port parent,Matrix access,bool dirlocked)
{
	TaskEntry **IOCArg = Null(TaskEntry *);
	word e 		 = Err_Null;
	Task *task 	 = New(Task);
	TaskEntry *entry = New(TaskEntry);

PMTRACE(0x01);
	if ( task == Null(Task) || entry == Null(TaskEntry) ) 
	{
		e = EC_Error+SS_ProcMan+EG_NoMemory+EO_Task;
		goto Fail;
	}

	task->Program	 = prog;
	InitPool(&task->MemPool);
	task->Port	 = NewPort();
	task->Parent	 = parent;
	task->IOCPort	 = NewPort();
	task->Flags	 = (dbmask>>8)&0xff;
	task->ExceptCode = (VoidFnPtr)DefaultException;
	task->ExceptData = Null(byte);
	task->TaskEntry	 = entry;

	InitNode( &entry->ObjNode, name, Type_Task, 0, access);

	entry->Task	 = task;
	entry->Code	 = NULL;
	entry->UseCount  = 0;
	entry->AlarmTime = 0;
	entry->Running   = true;
	entry->ProgInfoPort	= NullPort;
	entry->ProgInfoMask	= 0;
	entry->ProgInfoSent	= 0;
	entry->TermCode	 = 0;
	entry->KillState = 0;
	entry->SignalPort = NullPort;

	IOCArg = (TaskEntry **)NewProcess(IOCStackSize,IOC,sizeof(Task *));

	if( IOCArg == NULL ) goto Fail;

	*IOCArg = entry;
	
	if( ( e = TaskInit(task) ) != Err_Null ) goto Fail;

	Insert( &TaskTable, &entry->ObjNode, dirlocked );

#ifdef __TRAN
	RunProcess((void *)((int)IOCArg|1)); /* oring with one sets low pri */
#else
	ExecProcess((void *)IOCArg, HighServerPri);
#endif

	DbInfo.Tasks++;

	return entry;
Fail:
#ifdef SYSDEB
IOdebug("%s NewTask failed e = %x %x %x %x",ThisMc->DirNode.Name,e,IOCArg,task,entry);
#endif

	if( IOCArg != Null(TaskEntry *) ) ZapProcess((void *)IOCArg);
	if( task != Null(Task) ) PFree((void *)task);
	if( entry != Null(TaskEntry) ) PFree((void *)entry);
	TaskErr = e;
	return Null(TaskEntry);
}

/*--------------------------------------------------------
-- IOC							--
--							--
-- I/O Controller process				--
--							--
--------------------------------------------------------*/

static void
IOC(TaskEntry * entry )
{
	Task		*task = entry->Task;
	MsgBuf		*m = NULL;
	uword		starttime = 0;
	word		alarmset = false;
	word		slosh = 0;
	word		e;

PMTRACE(0x02);

	DbInfo.IOCs++;
	
	forever
	{
		alarmset = false;
		
		if( m == NULL )	{ m = New(MsgBuf); DbInfo.MsgBufs++; }

		if( m == NULL ) { Delay(OneSec); continue; }

		
		
		m->mcb.Control 	= m->control;
		m->mcb.Data 	= m->data;
		m->mcb.MsgHdr.Dest = task->IOCPort;
	
		if( entry->AlarmTime != 0 )
		{
			m->mcb.Timeout 	= (entry->AlarmTime>100)?OneSec*100:
							entry->AlarmTime*OneSec;
			m->mcb.Timeout -= slosh*10000;
			starttime = _cputime();
			alarmset = true;
		}
		else m->mcb.Timeout = IOCTimeout;	
		e = GetMsg(&m->mcb);

		if( alarmset )
		{
			uword time = (_cputime()-starttime)+slosh;

			slosh = time % 100;
			if((entry->AlarmTime -= (time/100)) <= 0)
			{
				alarmset = false;
				entry->AlarmTime = 0;
				slosh = 0;
				DoSignal(SIGALRM,entry);
			}
		}
		
		if( e == EK_Timeout ) {
			continue;
		}

		if( m->mcb.MsgHdr.FnRc < Err_Null ) 
		{
			if ( !HandleException(&m->mcb,entry) )
			{
				PFree(m);
				DbInfo.MsgBufs--;
				DbInfo.IOCs--;
				return;
			}
		}
		else {
			/* we have a message, check it is GSP protocol		*/
			if ( (m->mcb.MsgHdr.FnRc & FC_Mask) != FC_GSP )
			{
				if( !PrivateProtocol(entry,  m ) )
				{
					m->mcb.MsgHdr.FnRc = EC_Error|SS_IOC|EG_FnCode;
					ErrorMsg(&m->mcb,0);
				}
			}
#if FORKIOCWORKER
			else
			{
				if( !PFork(IOCStackSize,CallIOCWorker,8,m,entry)) 
				{
					m->mcb.MsgHdr.FnRc = EC_Error|SS_IOC|EG_NoMemory|EO_Message;
					ErrorMsg(&m->mcb,0);
				}
				else m = NULL;
			}
#else
			else m = IOCWorker(m, NULL, entry->ObjNode.Name);
#endif
		}
	}
	
}

#if FORKIOCWORKER
static void CallIOCWorker(MsgBuf *m, TaskEntry *entry)
{
	m = IOCWorker(m, NULL, entry->ObjNode.Name);
	if( m != NULL ) { PFree(m); DbInfo.MsgBufs--; }
}
#endif

/*--------------------------------------------------------
-- IOCWorker						--
--							--
-- This procedure does the actual work of the IOC. It	--
-- is called directly from IOC() and is Forked as a	--
-- process from LinkIOC().				--
--							--
--------------------------------------------------------*/

static MsgBuf *IOCWorker(MsgBuf *m, LinkInfo *link, string clientname)
{
	MCB		*mcb = &m->mcb;
	NameEntry	*n = NULL;
	word		context, pathname, next;
	IOCCommon	*req;
	byte		*dvec = mcb->Data;
	word 		len = 0;
	byte		name[NameMax];
	word		e;
	NameDir		*d = NULL;
	word		start;
	word		retries = (mcb->MsgHdr.FnRc & FR_Mask) >> FR_Shift;

	
	req = (IOCCommon *)mcb->Control;
	context = req->Context;
	pathname = req->Name;
	start = next = req->Next;

#ifdef PMDEBUG
	if(debugging(DB_IOC1))
		dbg("%s IOC: %s %F %N %N %d",ThisMc->DirNode.Name,
			clientname,
			mcb->MsgHdr.FnRc,
			context==-1?NULL:&dvec[context],
			pathname==-1?NULL:&dvec[pathname],
			next);

# if 0
	if( debugging(DB_INFO))
	{
		dbg("ProcMan: %d IOCs %d NameEntries %d Tasks",
				DbInfo.IOCs,DbInfo.NameEntries,DbInfo.Tasks);
		dbg("         %d MsgBufs %d Workers %d Misc %d Servers",
				DbInfo.MsgBufs,DbInfo.Workers,DbInfo.Misc,DbInfo.Servers);
		dbg("Heap: size %d free %d largest %d %d%% free",
				Malloc(-3),Malloc(-1),Malloc(-2),Malloc(-4));
				
		dbmask ^= DB_INFO;
	}
# endif
#endif

Again:

	if( dvec[next] == 0 && next < pathname ) next = pathname;

	while( dvec[next] == c_dirchar ) next++;

	len = splitname( name, c_dirchar, &dvec[next] );
PMTRACE(0x03);
	/* lookup name in name table		*/

	/* if the target object appears to be the name server	*/
	/* pass the request on to the server itself.		*/

	if ( len == 0 )
	{
		/* this is a bijou kludgette to allow us to use Link.n	*/
		/* to refer to neighbours				*/

	  
		if(link!=NULL && d == NULL ) d = ThisMc;
	nsreq:
		if(context == -1 || (pathname > 0 && next >= pathname) )
		{
			int Class = req->Access.Access;
			if( link == NULL ) Class = AccMask_V;
			req->Access.Access = UpdMask(Class,ThisMc->DirNode.Matrix);
		}

		req->Next = next;
		if( !PFork(NSReqStackSize,NSRequest,12,m,d,&NameTableInfo) )
			goto memerr;
		return NULL;
	}
	elif( d == NULL )  
	{
			/* if we find . and .. here, map onto / */
		if( name[0] == '.' && (name[1] == 0 ||
		    (name[1] == '.' && name[2] == 0 ))
		   ) n = (NameEntry *)NameTableRoot; 
		else
		{
			/* look it up in the hash table */
			List *l = &HashTable[hash(name)];
			Node *node = l->Head;
			Wait(&HashLock);
			while( n=NULL,node->Next != NULL )
			{
				n = (NameEntry *)((word)node - offsetof(NameEntry,HashNode));
				if( strcmp(name,n->ObjNode.Name) == 0 ) break;
				node = node->Next;
			}
			Signal(&HashLock);
		}
	}
	else n  = (NameEntry *)Lookup(&d->DirNode, name, FALSE);

	/* The following is a really nasty kludge to	*/
	/* support the installation and removal of 	*/
	/* names in the	nameserver by servers.		*/

	if(
	    (dvec[next+len] == 0) &&			/* end of name ?	*/
	    (
	      ( (mcb->MsgHdr.FnRc == FG_Create) &&	/* create request	*/
	        (n == NULL) && 				/* does not exist	*/
	        (pathname != -1) &&			/* pathname used	*/
	        (next+len > pathname)			/* entered pathname	*/
	      ) ||
	      ( (mcb->MsgHdr.FnRc == FG_Delete) &&	/* delete request	*/
	        (pathname == -1) && 			/* no path name		*/
	        (n != NULL)				/* and it exists	*/
	      )
	    )
	  )	    
	{
		if( n != NULL ) d = (NameDir *)n, next+=len;
		elif( d == NULL ) d = ThisMc;
		goto nsreq;
	}
	elif( n == Null(NameEntry) ) 
	{
		if( d == ThisMc )
		{
			mcb->MsgHdr.FnRc = EC_Error|SS_IOC|EG_Unknown|EO_Name;
			ErrorMsg(mcb, 0);
			return m;
		}
		else
		{
			MsgBuf *mm;
			string fullname = (string)PMalloc(IOCDataMax);
			if( d == NULL ) d = NameTableRoot;
			if( fullname == NULL ) 
			{
			memerr:
				mcb->MsgHdr.FnRc = EC_Error|SS_IOC|EG_NoMemory|EO_Name;
				ErrorMsg(mcb, 0);
				return m;
			}
			else DbInfo.Misc += IOCDataMax;
			getpath(fullname,&d->DirNode);
			pathcat(fullname,name);

			/* Serialize searches here with SearchLock. Once locked*/
			/* we must look again for the required node since we  */
			/* may have been blocked by another search for this   */
			/* same name.					      */

			Wait(&SearchLock);

			n = (NameEntry *)Lookup(&d->DirNode, name, FALSE);
			
			if( n == NULL )
			{
				mm = Search( fullname, link, NewId() ); 

				if( mm != NULL )
				{
					n = AddName((string)mm->data,mm->mcb.MsgHdr.Reply,Flags_CacheName|mm->control[1]);
					PFree(mm);
					DbInfo.MsgBufs--;
				}
#ifdef PMDEBUG
				else if(debugging(DB_SEARCH))
					dbg("Search for %s failed",fullname);
#endif
			}

			Signal(&SearchLock);

			PFree(fullname);
			DbInfo.Misc -= IOCDataMax;
		}
	}

	if( n == Null(NameEntry) ) 
	{
		mcb->MsgHdr.FnRc = EC_Error|SS_IOC|EG_Unknown|EO_Name;
		ErrorMsg(mcb, 0);
		return m;
	}

#ifdef PMDEBUG
	if(debugging(DB_IOC2))
		dbg("IOC: n = %s %T",n->ObjNode.Name,n->ObjNode.Type);
#endif

	switch( n->ObjNode.Type )
	{
	case Type_Name|Type_Directory:
	case Type_Name|Type_Stream:
	case Type_Name|Type_Private:
	case Type_Name:
		if( n->ObjNode.Flags & Flags_StripName ) next += len;
		break;
#if 1
	case Type_Auto|Type_Directory:
	case Type_Auto|Type_Stream:
	case Type_Auto|Type_Private:
	case Type_Auto:
		if( n->ObjNode.Flags & Flags_StripName ) next += len;
		break;
#endif
	case Type_Directory:
		next += len;
		d = (NameDir *)n;
		goto Again;

	case Type_Socket|Type_Directory:
	case Type_Socket|Type_Stream:
	case Type_Socket|Type_Private:
	case Type_Socket:
		req->Next = next+len;
		if( !PFork(NSReqStackSize,NSRequest,12,m,n,&SocketInfo) )
			goto memerr;
		return NULL;

	default:
		mcb->MsgHdr.FnRc = EC_Error|SS_IOC|EG_Invalid|EO_Name;
		ErrorMsg(mcb, 0 );
		return m;
	}

#ifdef PMDEBUG
	if(debugging(DB_IOC2))
		dbg("IOC: n = %s port = %x",n->ObjNode.Name,n->Server);
#endif
	if( n->Server == NullPort ) 
	{
		LoadServer( n );
		if( n->Server == NullPort )
		{
			mcb->MsgHdr.FnRc = EC_Error|SS_IOC|EG_Create|EO_Server;
			ErrorMsg(mcb,0);
			return m;
		}
	}
	/* see whether we have lost confidence in this server */
	if( retries == 0 ) n->Confidence = 10;
	elif( (n->Confidence -= retries) < 0 )
	{
		RemName(n);
		mcb->MsgHdr.FnRc = (retries > 8 ) ? 
					EC_Error|SS_IOC|EG_Broken|EO_Server:
					EC_Warn|SS_IOC|EG_Broken|EO_Server;
		ErrorMsg(mcb,0);
		return m;
	}

	if(context == -1 || (pathname > 0 && next >= pathname) )
		protect(req,n,link==NULL);

	mcb->MsgHdr.Flags |= MsgHdr_Flags_preserve;
	mcb->MsgHdr.Dest = n->Server;
	mcb->Timeout = IOCTimeout;
	mcb->MsgHdr.FnRc &= ~FR_Mask;
	
	/* update current pos */

	if( n->ObjNode.Flags & Flags_ResetContext ) req->Next = 1;
	else req->Next = next;
PMTRACE(0x04);
	Wait( &n->ObjNode.Lock );	/* wait for access	*/

#ifdef PMDEBUG
	if(debugging(DB_IOC2))
		dbg("IOC: Fwd %d %d %d %x",context,pathname,next,mcb->MsgHdr.Dest);

	if(debugging(DB_IOC3)) dbg("IOC: msg = %x %x %x %F",mcb->MsgHdr);
#endif

	while( (e = PutMsg(mcb)) < Err_Null && (e & EC_Mask) == EC_Recover );

#ifdef PMDEBUG
	if(debugging(DB_IOC3)) dbg("IOC: Passed On e = %E",e);
#endif

	/* if the PutMsg failed, pass the error back to client	*/
	if( e < Err_Null )
	{
		if( mcb->MsgHdr.Reply != NullPort )
			SendException(mcb->MsgHdr.Reply,e);
		if( --n->Confidence < 0 ) 
		{
			RemName(n);
			return m;
		}
	}
	
	Signal( &n->ObjNode.Lock );	/* and release		*/
	return m;
}

/* Messages without a context, or where the context has been	*/
/* passed, must have their access rights restricted.		*/
/* The exact behaviour here depends on whether the client and	*/
/* server are either local or remote. 				*/
/* When both are local we restrict access to the V class of the */
/* processor's access matrix.					*/
/* When just the server is remote the mask is retricted to a	*/
/* single class dependent on its distance.			*/
/* When just the client is remote the mask will have been	*/
/* restricted by the previous case in the client's IOC so we	*/
/* select the appropriate row from the processors matrix.	*/
/* When both are remote it is just passing through and no action*/
/* is necessary (I don't think this case arises).		*/

static void protect(IOCCommon *req, NameEntry *n, bool local)
{
	int Class = req->Access.Access;
	if( (n->ObjNode.Flags & Flags_CacheName) == 0)
	{
		/* sending to local server */
		if( local ) Class = AccMask_V;
		Class = UpdMask(Class,ThisMc->DirNode.Matrix);
	}
	else
	{
		/* sending to another processor */
		if( local ) switch( n->Distance )
		{
		case 0:  Class = AccMask_V; break; 
		case 1:  Class = AccMask_X; break; 
		case 2:  Class = AccMask_Y; break; 
		default: Class = AccMask_Z; break; 
		}
	}
	req->Access.Access = Class;
}

/*--------------------------------------------------------
-- NsRequest						--
--							--
-- Handle a request which is directed to the name server--
-- itself.						--
--							--
--------------------------------------------------------*/

static void NSRequest(MsgBuf *m, DirNode *d,DispatchInfo *info)
{
	ServInfo servinfo;
	word fncode = m->mcb.MsgHdr.FnRc;

#ifdef PMDEBUG
	if(debugging(DB_IOC2))
		dbg("NSRequest %F directory %s",
			m->mcb.MsgHdr.FnRc,d==NULL?"<>":d->Name);
#endif
PMTRACE(0x05);
	DbInfo.Workers++;

	
	if( setjmp(servinfo.Escape) != 0 )
	{
		PFree(m);
		DbInfo.MsgBufs--;
		DbInfo.Workers--;
		UnLockTarget(&servinfo);
		return;
	}

	servinfo.m = &m->mcb;
	servinfo.Context = d==NULL?info->Root:d;
	servinfo.Target = (ObjNode *)(servinfo.Context);
	servinfo.TargetLocked = FALSE;
	servinfo.FnCode = m->mcb.MsgHdr.FnRc;
	servinfo.DispatchInfo = info;
	m->mcb.MsgHdr.FnRc = info->SubSys;

	if ( m->mcb.MsgHdr.FnRc & FC_Mask != FC_GSP )
	{
		ErrorMsg(&m->mcb,EC_Error+EG_FnCode );
		PFree(m);
		DbInfo.MsgBufs--;
		DbInfo.Workers--;
		return;
	}

	if( d == NULL )	d = GetContext( &servinfo );
	else getpath(servinfo.Pathname,d);

	if( d == Null(DirNode) ) ErrorMsg(&m->mcb,0);
	else
	{
		word fn = fncode & FG_Mask;
		WordFnPtr f;

		if( fn < FG_Open || fn > FG_LastIOCFn )
		{
			f = (WordFnPtr)info->PrivateProtocol.Fn;
			if( (f == NULL) || (!f(&servinfo)) )
			{
				m->mcb.MsgHdr.FnRc = Err_Null;
				ErrorMsg(&m->mcb,EC_Error+info->SubSys+EG_FnCode );
			}
		}
		else {
			f = (WordFnPtr)info->Fntab[(fn-FG_Open) >> FG_Shift].Fn;
			(*f)(&servinfo);
		}
	}
	
	UnLockTarget(&servinfo);
	
	PFree( m );
	DbInfo.MsgBufs--;
	DbInfo.Workers--;
}

static void getpath(string s, DirNode *d)
{
	if( d != (DirNode *)NameTableRoot )
	 { if ((d->Parent == NULL) || (d->Parent == d))
	    {
#ifdef SYSDEB
	      if (d->Parent == NULL)
	 	dbg("getpath, DirNode %s, no parent", d->Name);
	      else
		dbg("getpath, DirNode %s is its own parent", d->Name);
#endif
	      *s = '\0';
	      pathcat(s, d->Name);

		/* BLV - possibly the name should be removed at this point */
	      return;	    
	    }
	   else
  	    getpath(s,d->Parent);
	 }
	else
	 *s = '\0';
	pathcat(s,d->Name);
}

/*--------------------------------------------------------
-- PrivateProtocol					--
--							--
-- Handle any private protocol messages between IOC and	--
-- task.						--
--							--
--------------------------------------------------------*/

static bool PrivateProtocol(TaskEntry *entry, MsgBuf *m)
{
	switch(m->mcb.MsgHdr.FnRc & FG_Mask )
	{
	/* the task is asking for the current name of the machine */
	case FG_MachineName:
	{
		NameDir *n = (NameDir *)(NameTableRoot->DirNode.Entries.Head);
		char *name = m->data;

		InitMCB(&m->mcb,0,m->mcb.MsgHdr.Reply,NullPort,0);

		*name = '\0';

		while( n->DirNode.Type & Type_Directory )
		{
			strcat(name,"/");
			strcat(name,n->DirNode.Name);	
			n = (NameDir *)(n->DirNode.Entries.Head);
		}

		m->mcb.MsgHdr.DataSize = strlen(name)+1;
		PutMsg(&m->mcb);

		return true;
	}
	
	/* the task is asking for an alarm signal in the given number of secs */
	case FG_Alarm:
	{
		word oldalarm = entry->AlarmTime;
		
		entry->AlarmTime = m->control[0];

		InitMCB(&m->mcb,0,m->mcb.MsgHdr.Reply,NullPort,0);

		MarshalWord(&m->mcb,oldalarm);

		PutMsg(&m->mcb);
		
		return true;
	}
	
	case FG_SetSignalPort:
	{
		Port old = entry->SignalPort;

#ifndef __TRAN	/* PAB's fix to change signal timing problem */
		entry->SignalPort = m->control[0];
#else
		entry->SignalPort = m->mcb.MsgHdr.Reply;
#endif
#ifdef PMDEBUG
	if(debugging(DB_TASKS)) dbg("%s: FG_SetSignalPort %x -> %x",entry->ObjNode.Name,old,entry->SignalPort);
#endif

		InitMCB(&m->mcb,0,m->mcb.MsgHdr.Reply,old,0);

		PutMsg(&m->mcb);
		return true;
	}

	default:
		return false;
	}
}

/*--------------------------------------------------------
-- LinkIOC						--
--							--
-- Process attached to a link which acts as agent for	--
-- remote processes.					--
--							--
--------------------------------------------------------*/

static void LinkIOC(LinkInfo *link)
{
	MsgBuf *	m;
	byte		name[NameMax];
	byte *		dbline = (byte *)PMalloc(128); /* just starting must work */
	int		dbpos = 0 ;
	NameEntry *	n;
#ifdef SYSDEB
	RootStruct *	root = GetRoot();
#endif
	word		e;
	
	DbInfo.IOCs++;
	DbInfo.Misc += 128;
	
	strcpy(name,"link.");
	if(link->Id==0) strcat(name,"0"); /* addint will not handle 0 */
	else addint(name,link->Id);
	
	n = NewName(ThisMc,name,Type_Name,Flags_StripName|Flags_LinkName,
		link->RemoteIOCPort,DefNameMatrix,NULL,FALSE);

	forever
	{
		m = New(MsgBuf);
		
		if( m == NULL ) { Delay(OneSec); continue; }
		
		DbInfo.MsgBufs++;
Label1:
		m->mcb.MsgHdr.Dest 	= link->LocalIOCPort;
		m->mcb.Timeout		= IOCTimeout;
		m->mcb.Control		= m->control;
		m->mcb.Data		= m->data;
		while( ( e = GetMsg(&m->mcb) ) == EK_Timeout );

		if( e == 0x22222222 )
		{
			int i;
			for( i = 0; i < m->mcb.MsgHdr.DataSize; i++ )
			{
				byte c = m->data[i];
				dbline[dbpos++] = c;
				if( c == '\n' || dbpos >= 127 )
				{
					dbline[dbpos] = '\0';
					PFork(DbgWorkStackSize ,dbgworker, 4, dbline);
					while( (dbline = (char *)PMalloc(128)) == NULL ) Delay(OneSec);
					DbInfo.Misc += 128;
					dbpos = 0;
				}
			}

			goto Label1;
		}
#ifdef PMDEBUG		
		if(debugging(DB_LINK))
			dbg("Link %d message %x %x %x %F",link->Id,m->mcb.MsgHdr);
#endif
		
		if( e < 0 ) 
		{
			if( (e&EG_Mask) == EG_Broken ) goto linkworker;
			else goto Label1;
		}
		else switch( e & FG_Mask )
		{
		case FG_Search:
			e = PFork(SearchStackSize,SearchWorker,8,m,link);
			if( e==0 )
			{
			forkfail:
#ifdef PMDEBUG
IOdebug("%s forkfail %d %M",ThisMc->DirNode.Name,e,&m->mcb);
#endif
				InitMCB(&m->mcb,0,m->mcb.MsgHdr.Reply,
					NullPort,EC_Error|SS_ProcMan|EG_NoMemory);
				PutMsg(&m->mcb);
				goto Label1;
			}
			break;

#if 0			
		case FG_BootLink:
			DoBootLink(m,link,name);
			break;
#endif
					
#ifdef SYSDEB
		case FG_FollowTrail:
		{
			PortInfo pi;
			Port port = m->mcb.Control[0];
			word e = GetPortInfo(port,&pi);
			Task *owner = (Task *)(pi.Owner);
			Port surr = pi.Surrogate;
			
			if( e != Err_Null ) 
			{
				dbg("%s Trail %x Invalid Port: %E",ThisMc->DirNode.Name,port,e);
			}
			else switch( pi.Type )
			{
			case T_Free:
				dbg("%s Trail %x Free !!",ThisMc->DirNode.Name,port);
				break;

			case T_Local:
				dbg("%s Trail %x Local Owner %s",ThisMc->DirNode.Name,port,
					owner==NULL?"Kernel":owner->TaskEntry->ObjNode.Name);
				break;
				
			default:
			case T_Surrogate:
			case T_Trail:
			case T_Permanent:
				dbg("%s Trail %x %s Owner %s link %d -> %x",ThisMc->DirNode.Name,port,
					(pi.Type!=T_Trail)?"Surrogate":"Trail",
					(owner==NULL)?"Kernel":owner->TaskEntry->ObjNode.Name,
					pi.Link,surr);
				InitMCB(&m->mcb,MsgHdr_Flags_preserve,
					root->Links[pi.Link]->RemoteIOCPort,
					NullPort,FG_FollowTrail);
				MarshalWord(&m->mcb,surr);
				PutMsg(&m->mcb);
			}
			goto Label1;	/* re-use mcb */
		}
#endif
		default:
		linkworker:
			e = PFork(IOCStackSize,LinkIOCWorker,12,m,link,n);
			if( e==0 ) goto forkfail;
			break;
		}
	}
}

static void LinkIOCWorker(MsgBuf *m, LinkInfo *link, NameEntry *n)
{
	word e = m->mcb.MsgHdr.FnRc;
PMTRACE(0x06);
	DbInfo.Workers++;
	
	if( e < 0 )
	{
#ifdef PMDEBUG
		if( (e & EG_Mask) == EG_Broken )
		{
			/*IOdebug("Link %d has changed state: code %E conf %x",link->Id,e,*(word *)link);*/
			LinkFault(m,link,e);
		}
		else	IOdebug("Link %d IOC got error %E",link->Id,e);

#else
		if( (e & EG_Mask) == EG_Broken ) LinkFault(m,link,e);
#endif
	}
	else m = IOCWorker(m,link,n->ObjNode.Name);

	if( m != NULL ) { PFree(m); DbInfo.MsgBufs--; }
	DbInfo.Workers--;
}

static void dbgworker(string dbline)
{
	RootStruct *root = GetRoot();

#ifdef __ARM
	EnterSVCMode();	/* as we are writing to root struct */
#endif
	DbInfo.Workers++;
	Wait(&root->IODebugLock);
	IOputs(dbline);
	Signal(&root->IODebugLock);	
	PFree(dbline); DbInfo.Misc -= 128;
	DbInfo.Workers--;
#ifdef __ARM
	EnterUserMode();	/* as we are writing to root struct */
#endif
}

#if 0
static void DoBootLink(MsgBuf *m, LinkInfo *link, string name)
{
	word e = Err_Null;
	MCB mcb;

	e = _BootLink(link->Id,NULL,(Config *)&m->data,m->mcb.MsgHdr.DataSize);

	if( e >= Err_Null )
	{
		InitMCB(&mcb,0,link->LocalIOCPort,NullPort,0);
		mcb.Data = m->data;
		mcb.Control = m->control;
		while( (e = GetMsg(&mcb)) != 0x123 );
		e = Err_Null;
	}

	name = name;
	m->mcb.MsgHdr.FnRc = e;
	ErrorMsg(&m->mcb,0);
	
	PFree(m);
	DbInfo.MsgBufs--;
}
#endif

static void LinkFault(MsgBuf *m, LinkInfo *link, word code)
{
	char mcname[100];

	getpath(mcname,&ThisMc->DirNode);

	InitMCB(&m->mcb,MsgHdr_Flags_preserve,NullPort,NullPort,
		FC_GSP|SS_NetServ|FG_NetStatus);
	
	/* fake IOCCommon */	
	MarshalWord(&m->mcb,-1);
	MarshalString(&m->mcb,"/ns");
	MarshalWord(&m->mcb,1);
	MarshalWord(&m->mcb,-1);
	MarshalWord(&m->mcb,-1);
	
	/* message parameters... */
	
	MarshalString(&m->mcb,mcname);		/* subnet/terminal name	*/
	MarshalWord(&m->mcb,link->Id);		/* link number		*/
	MarshalWord(&m->mcb,link->Mode);	/* link mode		*/
	MarshalWord(&m->mcb,link->State);	/* link state		*/
	
#if 0
	/* in case any of our cached names point through the dead link	*/
	/* remove them all here.					*/
	/* BLV - too likely to cause a deadlock				*/	
	RemName((NameEntry *)NameTableRoot);	
#endif

	SendIOC(&m->mcb);		/* send to ns but ignore reply */ 
	
	code=code;
}

/*--------------------------------------------------------
-- Search						--
--							--
-- Distributed search code.				--
--							--
--------------------------------------------------------*/

static MsgBuf *Search(string name, LinkInfo *srclink, word id)
{
	MsgBuf *m = Null(MsgBuf);
	Port reply;
	word e = -1;
	word i;
	word nlinks = 0;
	word maxlinks = GetConfig()->NLinks;
	word timeouts = 3;
#ifdef __TRAN
	bool used[4];	/* We know Tranny only has 4 links */
#else
	bool *used = (bool *)PMalloc(sizeof(bool)*((int)maxlinks));
#endif
#ifdef PMDEBUG
	if(debugging(DB_SEARCH))
		dbg("Search(%s,link.%d,%x)",name,srclink==NULL?-1:srclink->Id,id);
#endif
PMTRACE(0x07);
#ifndef __TRAN
	if( used == NULL ) return NULL;
#endif

	m = New(MsgBuf);

	if( m == Null(MsgBuf) ) 
	{
#ifndef __TRAN
		PFree(used);
#endif
		return NULL;
	}

	DbInfo.MsgBufs++;
	
	m->mcb.Control = m->control;
	m->mcb.Data    = m->data;

	reply = NewPort();

	/* fire off a search request to each active link */
	for( i = 0; i < maxlinks ; i++ )
	{
		LinkInfo *link = Root->Links[i];

		used[i] = FALSE;
		
		if( link==srclink ) continue;
		
		if( (link->Mode  != Link_Mode_Intelligent) ||
		    (link->State != Link_State_Running) ) continue;
			
		nlinks++;
		used[i] = TRUE;

		InitMCB(&m->mcb,MsgHdr_Flags_preserve,
			link->RemoteIOCPort,reply,FC_Private+FG_Search);

		MarshalString(&m->mcb,name);
		MarshalWord(&m->mcb,id);
		MarshalWord(&m->mcb,i);
#ifdef PMDEBUG
		if(debugging(DB_SEARCH))
			dbg("Search: link %d for %s id = %x",link->Id,m->data,id);
#endif

		if( (e = PutMsg(&m->mcb)) < Err_Null) nlinks--,used[i]=FALSE;
	}

	/* while we wait for replies we must release the lock	*/
	/* in case they loop back.				*/
	Signal(&SearchLock);

	while( nlinks )
	{
		m->mcb.MsgHdr.ContSize = 0;
		m->mcb.MsgHdr.Dest = reply;
		m->mcb.Timeout = OneSec;
		m->control[0] = 0;
		m->control[1] = 0;		/* default flags	*/
		m->control[2] = -1;

		e = GetMsg(&m->mcb);

		/* no matter what the result, ensure that the control	*/
		/* vector has 3 words in it, and control[2] is source	*/
		/* link or -1.						*/
		if( m->mcb.MsgHdr.ContSize == 0 ) MarshalWord(&m->mcb,-1);
		if( m->mcb.MsgHdr.ContSize == 1 ) MarshalWord(&m->mcb,0);
		if( m->mcb.MsgHdr.ContSize == 2 )
		{
			for( i = 0; i < maxlinks; i++ )
			{
				LinkInfo *link = Root->Links[i];
				if( used[i] && (link->Flags & Link_Flags_ioproc ) )
				{
					MarshalWord(&m->mcb,i);
					break;
				}
			}
			if( i == maxlinks ) MarshalWord(&m->mcb,-1);
		}
		
		if( e >= Err_Null ) 
		{
#ifdef PMDEBUG			
			if(debugging(DB_SEARCH))
				dbg("Search: %s found, port: %x flags %x id: %x",
					m->data,m->mcb.MsgHdr.Reply,m->control[1],id);
#endif
			break;	/* throw all other replies away */
		}
		elif( (e&SS_Mask) == SS_Kernel )
		{
			if( e == EK_Timeout )
				if( timeouts-- == 0 ) break;
			/* Re-check the links. If a link has stopped working */
			/* decrement nlinks.				     */
			for( i = 0; i < maxlinks; i++ )
			{
				LinkInfo *link = Root->Links[i];
				if( !used[i] ) continue;
				if( (link->Mode  != Link_Mode_Intelligent) ||
				    (link->State != Link_State_Running) )
				    used[i] = FALSE, nlinks--;
			}
		}
		elif( (e&(EC_Mask|EG_Mask|EO_Mask)) == EC_Error|EG_Unknown|EO_Server )
		{
			/* Not found reply.				*/
			int mylink = (int)(m->control[2]);
			if( mylink >= 0 ) used[mylink] = FALSE,nlinks--;
		}
	}

	Wait(&SearchLock);

	FreePort(reply);
#ifndef __TRAN
	PFree(used);
#endif
	if( e >= 0 ) return m;

	PFree(m);
	DbInfo.MsgBufs--;
	
	return NULL;
}

/*--------------------------------------------------------
-- SearchWorker						--
--							--
-- Distributed search code. run from Link IOC.		--
--							--
--------------------------------------------------------*/

static void SearchWorker(MsgBuf *m, LinkInfo *link)
{
	word i, id;
	char *sname = m->data;
	NameDir *d = NULL;
	NameEntry *n = NULL;
	int len;
	char name[NameMax];
	MsgBuf *mm;
	word hislink;
		
	Wait(&SearchLock);

	DbInfo.Workers++;
PMTRACE(0x08);	
#ifdef PMDEBUG
	if(debugging(DB_SEARCHWK))
		dbg("SearchWorker for %s id = %x from link %d[%d]",
			sname,m->control[1],link->Id,m->control[2]);
#endif

	hislink = m->control[2];

	/* check we have not already seen this search */
	
	id = m->control[1];
	for( i = 0; i < SearchSize ; i++ ) 
		if( SearchTable[i] == id ) goto failed;

	/* enter id into table */
	SearchTable[ (STOffset++) & (SearchSize - 1) ] = id;
	
	/* see if we have it here */
	/* first hash into name table */

	while( *sname == c_dirchar ) sname++;

	len = splitname(name,c_dirchar,sname);

	if( len != 0 )
	{
		List *l = &HashTable[hash(name)];
		Node *node = l->Head;
		Wait(&HashLock);
		while( n=NULL,node->Next != NULL )
		{
			n = (NameEntry *)((word)node - offsetof(NameEntry,HashNode));
			if( strcmp(name,n->ObjNode.Name) == 0 ) break;
			node = node->Next;
		}
		Signal(&HashLock);
	}

	/* if the initial hash fails to find anything, search for it.	*/
	/* if it is server name we have found something, otherwise we	*/
	/* need to search down the name tree from here.			*/
	if( n == NULL ) goto search;
	else {
		if( (n->ObjNode.Type & ~Type_Flags) == Type_Name ) goto found;
		else d = (NameDir *)n, sname += len;
	}

	/* now run down directories */
	while((len=splitname(name,c_dirchar,sname))!=0)
	{
		n = (NameEntry *)Lookup(&d->DirNode,name,FALSE);
		if( n == NULL ) goto search;
		sname += len;
		d = (NameDir *)n;
	}
	goto found;

search:
	/* pass request on to neighbours */
	
	mm = Search( m->data, link, id );
#ifdef PMDEBUG
	if(mm == NULL && debugging(DB_SEARCH))
		dbg("Search in SearchWork for %s failed",m->data);
#endif

	if( mm == NULL ) goto failed;

#ifdef PMDEBUG	
	if(debugging(DB_SEARCHWK))
		dbg("Found in search %s port: %x flags: %x",mm->data,mm->mcb.MsgHdr.Reply,mm->control[1]);
#endif

	mm->mcb.MsgHdr.Dest = m->mcb.MsgHdr.Reply;
	mm->control[2] = hislink;
	PFree(m); DbInfo.MsgBufs--;
	m = mm;
	goto done;
	
found:
	/* We have found an entry for this name, but only respond if it	*/
	/* is one of ours, otherwise pass search on.			*/
	if( (n->ObjNode.Flags & Flags_CacheName) != 0 )
	{
#ifdef PMDEBUG		
		if(debugging(DB_SEARCHWK))		
			dbg("Found CacheName %s, searching",n->ObjNode.Name);
#endif
		goto search;
	}
	/* found it locally , pass back link IOC port. */
	InitMCB(&m->mcb,
#if 1
		0,
#else
		/* This is a bit of a kludge to stop undelivered messages */
		/* destroying their reply trail. 			  */
		MsgHdr_Flags_exception,
#endif
		m->mcb.MsgHdr.Reply,
		(((n->ObjNode.Type&~Type_Flags)==Type_Socket) && (n != (NameEntry *)DotSocket)) 
			? n->Server : link->LocalIOCPort,
		0);

	MarshalOffset(&m->mcb);
	getpath(m->data,(DirNode *)&n->ObjNode);
	MarshalWord(&m->mcb,Flags_ResetContext);
	MarshalWord(&m->mcb,hislink);

	m->mcb.MsgHdr.DataSize = strlen(m->data)+1;

#ifdef PMDEBUG	
	if(debugging(DB_SEARCHWK))
		dbg("Found locally %s port = %x",m->data,m->mcb.MsgHdr.Reply);
#endif
	goto done;

failed:
#ifdef PMDEBUG
	if(debugging(DB_SEARCHWK)) dbg("Search for %s failed",m->data);
#endif
	InitMCB(&m->mcb,0,m->mcb.MsgHdr.Reply,NullPort,
		EC_Error|SS_ProcMan|EG_Unknown|EO_Server);
	MarshalWord(&m->mcb,-1);
	MarshalWord(&m->mcb,0);
	MarshalWord(&m->mcb,hislink);

done:
	PutMsg(&m->mcb);
	PFree(m); DbInfo.MsgBufs--;
	DbInfo.Workers--;
	Signal(&SearchLock);
}

/*--------------------------------------------------------
-- HandleException					--
--							--
-- Handle any exception/error messages sent to the IOC	--
-- by its Task.						--
-- Returns true if the IOC is to continue and false if	--
-- it is to terminate.					--
--							--
--------------------------------------------------------*/

static word HandleException(MCB *m, TaskEntry *entry)
{
	Task *task = entry->Task;
	word e = m->MsgHdr.FnRc;
	word code = (m->Control)[0];

#ifdef PMDEBUG
	if(debugging(DB_TASKS))
		dbg("ProcMan: %s Exception e %E code %x",entry->ObjNode.Name,e,code);
#endif
	if( (e & (EC_Mask|EG_Mask)) != (EC_Error|EG_Exception) )
		return true;

PMTRACE(0x09);
	switch( e & EE_Mask )
	{
	default:
		return true;

	case EE_Kill:
#ifdef PMDEBUG	
		if(debugging(DB_TASKS))
			dbg("Kill %s parent %x",entry->ObjNode.Name,
						task->Parent);
#endif
		Wait(&entry->ObjNode.Lock);
		entry->Status += 1000;

		Wait(&KillLock);
		e = KillTask(task);
		Signal(&KillLock);

		entry->Status += 1000;

		entry->Running = false;

		entry->TermCode = code;

		GenProgInfo(entry);

		entry->Status += 1000;

		Close(entry->Code);
		entry->Code = NULL;

		if( entry->UseCount == 0 ) DestroyTask(entry);
		else Signal(&entry->ObjNode.Lock);

		return false;
	}
}

static void GenProgInfo(TaskEntry *entry)
{		
	MCB m;
	word e = 0;
#ifdef __TRAN
	Task *task = entry->Task;
#endif
	
#ifdef PMDEBUG			
		if(debugging(DB_TASKS))
			dbg("Generating %s proginfo %x",
				entry->ObjNode.Name,entry->TermCode);
#endif

	if( (entry->ProgInfoMask != 0) && 
		(entry->ProgInfoPort != NullPort) )
	{
		word f = MsgHdr_Flags_preserve;
		if( entry->ProgInfoSent ) f |= MsgHdr_Flags_sacrifice;

		InitMCB(&m,(byte)f,entry->ProgInfoPort,NullPort,entry->TermCode);
			
		entry->Status += 100;
		e = PutMsg(&m);
		entry->Status += 100;
		entry->ProgInfoSent++;
	}

#ifdef __TRAN /* required for Charlies netserver, should not be needed for Barts */
# if 1
	/* the following will vanish eventually */
	elif( task->Parent != NullPort )
	{
		InitMCB(&m,MsgHdr_Flags_preserve,
			task->Parent,NullPort,entry->TermCode);
		entry->Status += 100;
		e = PutMsg(&m);
	}
# endif
#endif
#ifdef PMDEBUG
		if(e != 0 && debugging(DB_TASKS))
			dbg("%s ProgInfo PutMsg e = %x",entry->ObjNode.Name,e);
#endif
}

/*--------------------------------------------------------
-- DestroyTask						--
--							--
-- Delete the task data structures. This will only	--
-- happen if the task has exited and there are no open	--
-- streams to it.					--
--							--
--------------------------------------------------------*/

static void DestroyTask(TaskEntry *entry)
{
	Task *task = entry->Task;
	char  name[NameMax];

	if( entry->Running || entry->UseCount > 0 ) return;
PMTRACE(0x0a);
#ifdef PMDEBUG
	if(debugging(DB_TASKS)) dbg("Destroy Task %s",entry->ObjNode.Name);
#endif

	/* To avoid deadlocks we must release the lock on the task here	*/
	/* get the root lock, and then re-acquire the task lock. By	*/
	/* getting the root lock we can be sure that no-one else is	*/
	/* waiting for this task. Note that we must re-test the conditions*/
	/* after getting the locks to ensure that nothing has changed.	*/
 	strcpy(name, entry->ObjNode.Name);
	Signal(&entry->ObjNode.Lock);
	Wait(&TaskTable.Lock);
	/* BLV - check that the task has not disappeared in the meantime. */
	entry = (TaskEntry *) Lookup(&TaskTable, name,TRUE);
	if (entry == NULL)
	 { Signal(&TaskTable.Lock);
	   return;
	 }
	Wait(&entry->ObjNode.Lock);
	
	if( entry->Running || entry->UseCount > 0 ) 
	{
		Signal(&entry->ObjNode.Lock);
		Signal(&TaskTable.Lock);
		return;
	}
	
	FreePort(task->Port);

	FreePort(task->IOCPort);

	FreePort(task->Parent);

	FreePool(&task->MemPool);

	Unlink(&entry->ObjNode, TRUE);

	if( entry->Code != NULL ) Close(entry->Code);

	PFree(task);

	FreePort(entry->ProgInfoPort);

	PFree(entry);

	DbInfo.Tasks--;
	
	Signal(&TaskTable.Lock);
}


#if 0
/*--------------------------------------------------------
-- AsyncException					--
--							--
-- Call exception code asyncronously. 			--
-- Used if there is no standard signal port to send	--
-- signal to.						--
--							--
-- This should be called via CallWithModTab() so that	--
-- the signal stack that is used comes from the target	--
-- tasks own memory.					--
--							--
--------------------------------------------------------*/

static void AsyncException(Task *task, word signal)
{
	PFork(PMSTACKSIZE, CallException, 8, task, signal);
}
#endif

/*--------------------------------------------------------
-- DoSignal						--
--							--
-- Send a signal to the task.				--
--							--
--------------------------------------------------------*/

static void DoSignal(word signal, TaskEntry *entry)
{
	if( entry->SignalPort != NullPort )
	{
		/* deliver the signal via a message to the task's signal port */
		SendException(entry->SignalPort,EC_Recover|SS_ProcMan|EG_Exception|EE_Signal|signal);
	}
	else
	{
#if 0
	/* Exception code is now only called in a syncronous manner */
	/* There should be no need to fork this thread. */

		/*
		 * Signal port has not been set yet, so call its exception
		 * code. As syncronous signals also use CallException, we
		 * have to fork off a thread here (it used to be done in
		 * individual language runtime's). The CallWithModTab() is to
		 * force the signal stack to be allocated from the receiving
		 * tasks memory pool.
		 */

		CallWithModTab(	(word)entry->Task, signal,
			(WordFnPtr) AsyncException,
			entry->Task->ModTab);
#else
		/* Call low level exception handler, This will either call */
		/* Exit, or when CLib is loaded, call raise() (not on TRAN). */
		/* It is used to support hardware exceptions. */
		Task *task = entry->Task;
		CallException(task,signal);
#endif
	}
}


/*--------------------------------------------------------
-- LoadServer						--
--							--
-- The given server is not loaded, do so.		--
-- This a achieved by causing the autoload code to be   --
-- executed.						--
--							--
--------------------------------------------------------*/

static void LoadServer(NameEntry *n)
{
PMTRACE(0x0b);
	n->Server = DefaultAct( n->ObjNode.Name, n->LoadData );
	/* change type to Type_Name */
	n->ObjNode.Type = (n->ObjNode.Type & Type_Flags) | Type_Name;
	
}

static Port DefaultAct( char *name, word *data )
{
	Object *libdir= NULL;
	Object *servercode = NULL;
	Object *server = NULL;
	Stream *s = NULL;
	Port result = NullPort;
	MPtr p;
	char tname[NameMax];
	TaskEntry *t;

	data = data;		/* keep compiler happy */

	libdir = Locate(NULL,"/helios/lib");

	if( libdir == NULL ) goto done;

	servercode = Locate(libdir,name);

	if( servercode == NULL ) goto done;

	server = Load(NULL,servercode);

	if( server == NULL ) goto done;

	s = Open(server,NULL,O_Execute);

	p = (MPtr)(s->Server);

	ModuleName_(tname,p);
	
	t = NewTask(makename(tname,tname),p,
		NullPort,DefTaskMatrix,FALSE);

	if( t == NULL ) { Close(s); goto done; }

	t->Code = s;

	result = t->Task->Port;

done:
	Close(libdir);
	Close(servercode);
	Close(server);

	return result;
}

/*--------------------------------------------------------
-- Action procedures					--
--							--
-- Process individual packet actions			--
-- These are common to both name server and processor	--
-- manager.						--
--							--
--------------------------------------------------------*/

static void do_serverinfo(ServInfo *servinfo)
{
	RootStruct *root = GetRoot();
	MCB *m = servinfo->m;
	int i;
	int NLinks = (int)(GetConfig()->NLinks);
	int mctype = (int)MachineType();
	char *name = (char *)PMalloc(IOCDataMax);
	
	InitMCB(m,0,m->MsgHdr.Reply,NullPort,Err_Null);

	if( name == NULL )
	{
		m->MsgHdr.FnRc = EC_Error|SS_IOC|EG_NoMemory|EO_Name;
		ErrorMsg(m, 0);
		return;
	}
	
	getpath(name,&ThisMc->DirNode);
	
	/* build a ProcStats structure in the data vector */
	
	MarshalData(m,4,(byte *)&mctype);
	MarshalData(m,4,(byte *)&root->LoadAverage);
	MarshalData(m,4,(byte *)&root->Latency);
	MarshalData(m,4,(byte *)&root->MaxLatency);
	MarshalData(m,4,(byte *)&root->FreePool->Max);
	MarshalData(m,4,(byte *)&root->FreePool->Size);
	MarshalData(m,4,(byte *)&root->LocalMsgs);
	MarshalData(m,4,(byte *)&root->BufferedMsgs);	
	MarshalData(m,4,(byte *)&root->Errors);
	MarshalData(m,4,(byte *)&root->EventCount);		
	MarshalData(m,4,(byte *)&NLinks);		
	
	for( i = 0; root->Links[i] != NULL ; i++ )
	{
		LinkInfo *link = root->Links[i];
		MarshalData(m,4,(byte *)link);
		MarshalData(m,4,(byte *)&link->MsgsIn);
		MarshalData(m,4,(byte *)&link->MsgsOut);
		MarshalData(m,4,(byte *)&link->MsgsLost);		
	}
	
	MarshalString(m,name);
	
	PFree(name);

	PutMsg(m);
}

/*--------------------------------------------------------
-- Processor Manager Specific Actions.			--
--							--
--------------------------------------------------------*/

static void pm_open(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	MsgBuf *r;
	TaskEntry *t;
	IOCMsg2 *req = (IOCMsg2 *)(m->Control);
	Port reqport;
	char *pathname = servinfo->Pathname;
	int mode = (int)(req->Arg.Mode & O_Mask);
	Port proginfo_port	= NullPort;
	int  proginfo_count	= 0;

PMTRACE(0x0c);
#ifdef PMDEBUG
	if(debugging(DB_TASKS))
		dbg("PM Open from %x %s",m->MsgHdr.Reply,m->Data);
#endif

	t = (TaskEntry *)GetTarget(servinfo);

	if( t == Null(TaskEntry) )
	{
		ErrorMsg(m,EO_Task);
		return;
	}

	unless( CheckMask(req->Common.Access.Access,mode) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected);
		return;
	}

	r = New(MsgBuf);

	if( r == Null(MsgBuf) )
	{
		ErrorMsg(m,EC_Error+EG_NoMemory);
		return;
	}

	reqport = NewPort();
	FormOpenReply(r,m,&t->ObjNode,Flags_Closeable, pathname);
	r->mcb.MsgHdr.Reply = reqport;
	PutMsg(&r->mcb);
	PFree(r);

	if( t->ObjNode.Type == Type_Directory )
	{
		DirServer(servinfo,m,reqport);
		FreePort(reqport);
		return;
	}

	t->UseCount++;
	t->Status += 10000;
	
	UnLockTarget(servinfo);
	
	DbInfo.Servers++;
	
	forever
	{
		word e;
		m->MsgHdr.Dest = reqport;
		m->Timeout = OneSec*5;
		e = GetMsg(m);
	
		if( e == EK_Timeout )
		{
			/* BLV - if a processor crashes then a stream connection	*/
			/* to a running task may be broken. The TFM etc. will		*/
			/* automatically ReOpen() the connection and install another	*/
			/* ProgramInfo port on the new stream. However the old stream	*/
			/* must have a way of exiting. Hence the routine keeps track	*/
			/* of the last ProgInfo port installed on this stream and	*/
			/* shuts down when appropriate. Also, if the parent has		*/
			/* completely lost track of this child without reopening	*/
			/* the entry should eventually disappear (as if the processor	*/
			/* had crashed...						*/
			if( !t->Running ) {
				if ((proginfo_port == NullPort) || 
				    (proginfo_port != t->ProgInfoPort) ||
				    (++proginfo_count > 16))
					break;
				else
					GenProgInfo(t);	
			}
			continue;
		}

		if( e < Err_Null ) continue;

#ifdef PMDEBUG
		if(debugging(DB_TASKS))
			dbg("Procman Stream message %F from %x",
				m->MsgHdr.FnRc,m->MsgHdr.Reply);
#endif
PMTRACE(0x0d);
		Wait(&t->ObjNode.Lock);

		switch( m->MsgHdr.FnRc & FG_Mask )
		{
		case FG_SendEnv:
			unless( mode & O_WriteOnly ) goto badmode;

			m->MsgHdr.Dest = t->Task->Port;
			m->Timeout = IOCTimeout;
			t->Status += 1;
			PutMsg(m);
			t->Status += 1;
			break;

		case FG_Signal:
			unless( mode & O_WriteOnly ) goto badmode;
			/* BLV - do not send signals to tasks that have already died	*/
			unless(t->Running) {
				ErrorMsg(m, EC_Error + EG_Broken + EO_Program);
				break;
			}
			t->Status += 10;
			m->MsgHdr.FnRc = SS_ProcMan;
			
			ErrorMsg(m,0);

			DoSignal(m->Control[0],t);
			
#ifdef PMDEBUG
			if(debugging(DB_TASKS)) dbg("Signal of %s done",t->ObjNode.Name);
#endif
			t->Status += 10;

			break;

		case FG_ProgramInfo:
			unless( mode & O_ReadOnly ) goto badmode;
		{
			Port port = m->MsgHdr.Reply;
			word mask = m->Control[0];
			mask &= PS_Terminate;

			FreePort(t->ProgInfoPort);

			t->Status += 200;			
			t->ProgInfoPort = (mask==0)?NullPort:port;
			proginfo_port = t->ProgInfoPort;
			t->ProgInfoMask = mask;
			InitMCB(m,(mask==0)?0:MsgHdr_Flags_preserve,
					port,NullPort,Err_Null);
			MarshalWord(m,mask);
			MarshalWord(m,1);

			PutMsg(m);

			t->Status -= 100;
			if( !t->Running ) GenProgInfo(t);
			break;
		}

			
		case FG_Close:
#ifdef PMDEBUG		
			if(debugging(DB_TASKS))
				dbg("Task %s closed",t->ObjNode.Name);
#endif
			if( m->MsgHdr.Reply != NullPort ) ErrorMsg(m,0);
			m->MsgHdr.FnRc = SS_ProcMan;
			goto done;

		default:
			ErrorMsg(m,EC_Error+EG_FnCode+EO_Task);
			break;
		badmode:
			ErrorMsg(m,EC_Error+EG_Protected+EO_Task);
			break;
		}
		Signal(&t->ObjNode.Lock);
	}

	Wait(&t->ObjNode.Lock);
done:
	DbInfo.Servers--;
	t->UseCount--;
	t->Status -= 10000;
	if( !t->Running && t->UseCount == 0 ) DestroyTask(t);
	else Signal(&t->ObjNode.Lock);
	
	FreePort(reqport);
}

static void pm_create( ServInfo * servinfo )
{
	MCB *		m = servinfo->m;
	MsgBuf * 	r;
	DirNode *	d;
	TaskEntry *	t;
	IOCCreate *	req  = (IOCCreate *)(m->Control);
	TaskInfo *	info = (TaskInfo *)&(m->Data[req->Info]);
	Object *	o;
	Stream *	s;
	char		name[ NameMax ];
	char *		pathname = servinfo->Pathname;
	
PMTRACE(0x0e);
	
#ifdef PMDEBUG
	if(debugging(DB_TASKS))
		dbg("PM Create from %x",m->MsgHdr.Reply);
#endif

	d = (DirNode *)GetTarget(servinfo);

	if( d == Null(DirNode) )
	{
		ErrorMsg(m,EO_Directory);
		return;
	}

	unless( CheckMask(req->Common.Access.Access,AccMask_W) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Directory);
		return;
	}

	o = NewObject(RTOA(info->Name),&info->Cap);

	if( o == Null(Object) )
	{
		ErrorMsg(m,EC_Error+EG_Invalid+EO_Program);
		return;
	}

	if( ReLocate(o) < Err_Null )
	{
		m->MsgHdr.FnRc = Result2(o);
		ErrorMsg(m,0);
		return;
	}
	
	/* if the object is not a program, or is in a remote	*/
	/* loader, it must be loaded locally.			*/
	if( (o->Type != Type_Program) || (o->Flags & Flags_Remote) )
	{
		Object *o1;
		word e = 0;
		
		o1 = Load(Null(Object),o);
		e = Result2(o);
		
		if( o1 != NULL && o1->Type != Type_Program ) 
		{
			e = EC_Error|SS_ProcMan|EG_Invalid|EO_Program;
			Close(o1);
		}
			
		if( o1 == NULL || e < Err_Null )
		{
			m->MsgHdr.FnRc = e;
			ErrorMsg(m,0);
			Close(o);
			return;
		}
		Close(o);
		o = o1;
	}

	s = Open(o,NULL,O_Execute);

	if( s == Null(Stream) )
	{
		m->MsgHdr.FnRc = Result2(o);
		ErrorMsg(m,0);
		Close(o);
		return;
	}

	r = New(MsgBuf);

	if( r == Null(MsgBuf) )
	{
		ErrorMsg(m,EC_Error+EG_NoMemory);
		Close(o);Close(s);
		return;
	}
	DbInfo.MsgBufs++;
	
	t = NewTask(makename(o->Name,name),(MPtr)s->Server,
			m->MsgHdr.Reply,info->Matrix&DefTaskMatrix,TRUE);

	if( t == Null(TaskEntry) )
	{
		ErrorMsg(m,TaskErr);
		PFree(r); DbInfo.MsgBufs--;
		Close(s);Close(o);
		return;
	}

	t->Code = s;

	pathcat(pathname,name);

	/* give creator full access rights */
	req->Common.Access.Access = AccMask_Full;
	
	FormOpenReply(r,m,&t->ObjNode, 0, pathname);
	
	r->mcb.MsgHdr.Flags |= MsgHdr_Flags_preserve;

#ifdef PMDEBUG
	if(debugging(DB_TASKS))
		dbg("%s Parent = %x",t->ObjNode.Name,t->Task->Parent);
#endif
	PutMsg(&r->mcb);

	Close(o);

	PFree(r); DbInfo.MsgBufs--;
	
	return;	
}

static void pm_delete(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	TaskEntry *t;
	IOCCommon *req = (IOCCommon *)(m->Control);
PMTRACE(0x0f);
	t = (TaskEntry *)GetTarget(servinfo);

	if( t == NULL )
	{
		ErrorMsg(m,EO_Task);
		return;
	}

#ifdef PMDEBUG
	if(debugging(DB_TASKS)) dbg("pm_delete %s",t->ObjNode.Name);
#endif
	
	unless( CheckMask(req->Access.Access,AccMask_D) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Task);
		return;
	}

	if( t->ObjNode.Type != Type_Task )
	{
		ErrorMsg(m,EC_Error+EG_WrongFn+EO_Directory);
		return;
	}

	ErrorMsg(m,Err_Null);

	/* BLV - do not send signals to tasks that have already	*/
	/* died.						*/
	unless(t->Running) return;
	
	t->KillState += (servinfo->FnCode & FF_Mask);

	switch( t->KillState++ )
	{
	case 0:
		DoSignal(SIGINT,t);
		break;
		
	case 1:
		DoSignal(SIGKILL,t);
		break;
	
	default:
		InitMCB(m,0,t->Task->IOCPort,NullPort,
			EC_Error|SS_ProcMan|EG_Exception|EE_Kill);
		MarshalWord(m,0xFF80|SIGKILL);
		PutMsg(m);
	}
}

#ifdef PMDEBUG
static bool dbprocrunning = FALSE;
static void dbinfoproc(void);
#endif

static bool pm_private(ServInfo *servinfo)
{
	switch( servinfo->FnCode & FG_Mask )
	{
	default:
		dbg("ProcMan unknown function in pm_private: %lx",servinfo->FnCode);
		return false;
		
	case FG_Debug:
		dbmask ^= servinfo->m->Control[5];
#ifdef PMDEBUG
		if( servinfo->m->Control[5] & DB_INFO )
		{
			if( dbprocrunning ) dbprocrunning = FALSE;
			else Fork(2000,dbinfoproc,0);
		}
		
#endif
		return true;
		
	case FG_SetFlags:
	{
		MCB *m = servinfo->m;
		TaskEntry *t = (TaskEntry *)GetTarget(servinfo);
		IOCCommon *req = (IOCCommon *)m->Control;
		
		if( t == Null(TaskEntry) ) { ErrorMsg(m,EO_Task); return true; }

		unless( CheckMask(req->Access.Access,AccMask_W) ) 
		{ ErrorMsg(m,EC_Error+EG_Protected); return true; }

		t->Task->Flags ^= m->Control[5];	
		break;
	}

	case FG_Reconfigure:
	{
		NameDir *d = ThisMc;
		while( (d = (NameDir *)d->DirNode.Parent) != NULL )
		{
			WalkList(&d->DirNode.Entries,(WordFnPtr)RemName);
		}
		return true;
	}

	}

	return false;
}

/*--------------------------------------------------------
-- Name Server Specific Actions.			--
--							--
--------------------------------------------------------*/

static void nt_open(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	MsgBuf *r;
	NameDir *d;
	IOCMsg2 *req = (IOCMsg2 *)(m->Control);
	Port reqport;
	char *pathname = servinfo->Pathname;

PMTRACE(0x11);

	d = (NameDir *)GetTarget(servinfo);

	if( d == NULL )
	{
		ErrorMsg(m,EO_Directory);
		return;
	}

	/* only a directory may be opened for listing		*/
	unless( d->DirNode.Type & Type_Directory )
	{
		ErrorMsg(m,EC_Error+EG_WrongFn+EO_Name);
		return;
	}

	unless( CheckMask(req->Common.Access.Access,(int)(req->Arg.Mode & O_Mask)) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Directory);
		return;
	}

	r = New(MsgBuf);

	if( r == Null(MsgBuf) )
	{
		ErrorMsg(m,EC_Error+EG_NoMemory);
		return;
	}
	DbInfo.MsgBufs++;
	
	FormOpenReply(r,m,(ObjNode *)&d->DirNode,Flags_Closeable, pathname);

	reqport = NewPort();
	r->mcb.MsgHdr.Reply = reqport;

	PutMsg(&(r->mcb));

	PFree(r); DbInfo.MsgBufs--;

	DirServer(servinfo,m,reqport);

	FreePort(reqport);
}

static void nt_create(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	MsgBuf *r;
	NameEntry *n;
	NameDir *d;
	IOCCreate *req = (IOCCreate *)(m->Control);
	NameInfo *info = (NameInfo *)&(m->Data[req->Info]);
	char *name;
	char *pathname = servinfo->Pathname;
	word e;
PMTRACE(0x12);

	d = (NameDir *)GetTargetDir(servinfo);

	if( d == Null(NameDir) )
	{
		ErrorMsg(m,EO_Name);

		return;
	}

	unless( CheckMask(req->Common.Access.Access,AccMask_W) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Directory);
		return;
	}

	n = (NameEntry *)GetTargetObj(servinfo);

	if( n != NULL )
	{
		ErrorMsg(m,EC_Error|EG_Create|EO_Name);

		return;
	}
	
	r = New(MsgBuf);

	if( r == Null(MsgBuf) )
	{
		ErrorMsg(m,EC_Error+EG_NoMemory);
		return;
	}
	DbInfo.MsgBufs++;
	
	name = objname(pathname);

	n = NewName(d,name,req->Type,info->Flags,info->Port,info->Matrix&DefNameMatrix,
		info->LoadData,TRUE);

	/* Only the capability returned as a result of this	*/
	/* request contains the right to delete the name.	*/
	
	req->Common.Access.Access = AccMask_D;
	
	FormOpenReply(r,m,&n->ObjNode, 0, pathname);

	e = PutMsg(&r->mcb);

	PFree(r); DbInfo.MsgBufs--;

	return;
}

static void nt_rename(ServInfo *servinfo)
{
	IOCMsg2 *req = (IOCMsg2 *)(servinfo->m->Control);
	byte *data = servinfo->m->Data;
	NameDir *d;
	char *name;
	char *toname = &data[req->Arg.ToName];
	char mcname[100];
	int mpos, tpos;
PMTRACE(0x13);

	d = (NameDir *)GetTarget(servinfo);

	if( d != ThisMc )
	{
		ErrorMsg(servinfo->m,EC_Error|EG_WrongFn|EO_Name);
		return;
	}

	if( *toname != c_dirchar ) goto badname;

	getpath(mcname,&ThisMc->DirNode);

	mpos = strlen(mcname);
	tpos = strlen(toname);

	until( mpos == 0 )
		if( mcname[--mpos] != toname[--tpos] ) goto badname;


	Wait(&HashLock);

	d = NameTableRoot;
	
	while(tpos != 0)
	{
		NameDir *n = New(NameDir);

		if( n == NULL ) 
		{
			ErrorMsg(servinfo->m,EC_Error|EG_NoMemory);
			Signal(&HashLock);
			return;
		}
		DbInfo.NameEntries++;
		
		toname[tpos] = '\0';

		while( toname[--tpos] != c_dirchar );

		name = &toname[tpos+1];

		/* add new root */
		InitNode((ObjNode *)&n->DirNode,"",Type_Directory,
			Flags_StripName|Flags_Seekable, DefNameMatrix );
		InitList(&n->DirNode.Entries);
		n->DirNode.Parent = NULL;
		n->DirNode.Nentries = 0;
		NameTableInfo.Root = (DirNode *)(NameTableRoot = n);
		n->DirNode.Key = d->DirNode.Key;
		n->Server = NullPort;
		n->LoadData = NULL;
		n->Confidence = 1000;
		n->Distance = 0;
		strcpy(d->DirNode.Name,name);
		Insert(&n->DirNode,(ObjNode *)&d->DirNode, FALSE);
		AddHash(d);
		d = n;
	}

	getpath(ProcManInfo.ParentName,&ThisMc->DirNode);
	
	Signal(&HashLock);

	ErrorMsg(servinfo->m,Err_Null);
	return;

badname:
	ErrorMsg(servinfo->m,EC_Error|EG_Invalid|EO_Name);
	return;

}

static void nt_delete(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	NameEntry *n;
	IOCCommon *req = (IOCCommon *)(m->Control);
PMTRACE(0x14);

	n = (NameEntry *)GetTarget(servinfo);

	if( n == NULL )
	{
		ErrorMsg(m,EO_Name);
		return;
	}

	unless( CheckMask(req->Access.Access,AccMask_D) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Name);
		return;
	}

	if( (NameDir *)n == ThisMc )
	{
		NameDir *d = ThisMc;
		while( (d = (NameDir *)d->DirNode.Parent) != NULL )
		{
			WalkList(&d->DirNode.Entries,(WordFnPtr)RemName);
		}	
		ErrorMsg(m,Err_Null);	
		return;
	}
	
	if( ((n->ObjNode.Type & ~Type_Flags) != Type_Name) ||
	    ((n->ObjNode.Flags & Flags_CacheName) != 0) )
	{
		ErrorMsg(m,EC_Error+EG_WrongFn+EO_Directory);
		return;
	}

	Wait(&HashLock);
	Unlink(&n->ObjNode, FALSE);
	Remove(&n->HashNode);
	Signal(&HashLock);

	PFree(n); DbInfo.NameEntries--;
	
	ErrorMsg(m,Err_Null);
	
	servinfo->TargetLocked = FALSE;
}

/*--------------------------------------------------------
-- NewName						--
--							--
-- Install a new entry into the name table.		--
--							--
--------------------------------------------------------*/

static NameEntry *
NewName(
	NameDir *	d,
	string		name,
	word		type,
	word		flags,
	Port		port,
	Matrix		matrix,
	word *		loaddata,
	bool		dirlocked )
{
	NameEntry *n;

PMTRACE(0x15);

	/* BLV - only insert name if the server is not already part	*/
	/* of the nucleus.						*/
	if (Lookup(&d->DirNode, name, dirlocked) != NULL)
	 return(NULL);

	n = New(NameEntry);
	if( n == Null(NameEntry) ) return n;
	
	DbInfo.NameEntries++;

	InitNode( &n->ObjNode, name, (int)type, (int)flags, matrix );
	n->ObjNode.Size = 0;
	InitList(&n->ObjNode.Contents); /* just in case */
	n->Server = port;
	n->LoadData = loaddata;
	n->Confidence = 10;		/* start with some confidence */
	Insert(&d->DirNode,&n->ObjNode,dirlocked);
	Wait(&HashLock);
	AddHash((NameDir *)n);
	Signal(&HashLock);

	return n;
}

static int distance(NameDir *n)
{
	int dist = 0;
	NameDir *t = ThisMc;

	unless( n->DirNode.Flags & Flags_CacheName ) return 0;
	
	do {
		n = (NameDir *)n->DirNode.Parent;
	} while( n->DirNode.Flags & Flags_CacheName );

	while( t != n ) 
	{
		dist++;
		t = (NameDir *)t->DirNode.Parent;
	}

	return dist;
}

static void AddHash(NameDir *n)
{
	NameDir *x = n;
	List *l = &HashTable[hash(n->DirNode.Name)];
	Node *node;

PMTRACE(0x16);
	x->Distance = distance(n);

	node = l->Head;	

	until( node->Next == NULL )
	{
		n = (NameDir *)((word)node - offsetof(NameEntry,HashNode));
		if( n->Distance > x->Distance ) break;
		node = node->Next;
	}

	PreInsert(node,&x->HashNode);
}

static NameEntry *AddName(string name, Port port, word Flags)
{
	word len;
	char part[NameMax];
	NameEntry *n = NULL;
	NameDir *d = NameTableRoot;
	NameDir *nd;

	while( *name == c_dirchar ) name++;

	while( (len = splitname(part, c_dirchar, name )) != 0 )
	{
PMTRACE(0x17);
		n = (NameEntry *)Lookup(&d->DirNode,part,FALSE);

		if( n == NULL )	
		{
			if( name[len] == 0 )
			{
				n = NewName(d,part,(word)Type_Name,Flags,
					port,(Matrix)DefNameMatrix,(word *)NULL,FALSE);
				break;
			}
			else {
				nd = New(NameDir);

				if( nd == NULL ) return NULL;
				DbInfo.NameEntries++;
				
				Wait(&HashLock);

				InitNode( (ObjNode *)&nd->DirNode, 
					part, 
					Type_Directory,
					Flags_CacheName|Flags_StripName|Flags_Seekable, 
					DefNameMatrix 
					);

				InitList(&nd->DirNode.Entries);
				nd->DirNode.Nentries = 0;
				nd->Server = NullPort;
				nd->LoadData = NULL;

				Insert(&d->DirNode,(ObjNode *)&nd->DirNode,FALSE);

				AddHash(nd);

				Signal(&HashLock);

				name += len;
				d = nd;
			}
		}
		else {
			if( name[len] == 0 ) break;

			if( (n->ObjNode.Type & ~Type_Flags) == Type_Name )
			{
				nd = (NameDir *)n;
				Wait(&nd->DirNode.Lock);
				/* convert name entry to a directory */
				nd->DirNode.Type = Type_Directory;
				nd->DirNode.Flags |= Flags_StripName|Flags_Seekable;
				InitList(&nd->DirNode.Entries);
				nd->DirNode.Nentries = 0;
				Signal(&nd->DirNode.Lock);
			}
			name += len;
			d = (NameDir *)n;
		}
	}

	return n;
}


static void RemName1(NameEntry *n)
{
	/* check that node is still on list, if not then we have just	*/
	/* waited for another process to do the same job as us		*/
	if( n->ObjNode.Node.Next == &n->ObjNode.Node ) return;
PMTRACE(0x18);
	/* if it is a directory, remove its children first */
	if( (n->ObjNode.Type & Type_Flags) == Type_Directory )
	{
		NameDir *d = (NameDir *)n;

		WalkList(&d->DirNode.Entries,(WordFnPtr)RemName1);
		if( d->DirNode.Nentries != 0 ) return;
	}

	if( (n->ObjNode.Flags & Flags_CacheName) == 0 ) return;
		
	/* now remove name entry from hash table and parent directory	*/
	Remove(&n->HashNode);
	Unlink(&n->ObjNode,FALSE);
	if( n->Server != NullPort ) FreePort(n->Server);
	PFree(n); DbInfo.NameEntries--;
}

static void RemName(NameEntry *n)
{
	Wait(&HashLock);
	RemName1(n);
	Signal(&HashLock);
}

static word hash(char *s)
{
        char *p;
        unsigned long h = 0, g;
        for( p = s ; *p != 0 ; p++ )
        {
                h = (h << 4) + *p;
                if( (g = h & 0xf0000000L) != 0 )
                {
                        h = h ^ (g >> 24);
                        h = h ^ g;
                }
        }
        return (word)(h % HashSize);
}

static word NewId(void)
{
	return SearchTable[ (STOffset++) & (SearchSize - 1) ] = 
					NewKey()+(IdSeed++)+_ldtimer(0);
}

static string makename(string obj,string name)
{
	string s = objname(obj);

	if( s != name ) strcpy(name,s);
	strcat(name,".");
	(void)addint(name,TaskId++);

	return name;
}

static char dbg_msg[128];
static int dbg_args[10];

static void dbg(char *str, ... )
{
	int i;
	va_list a;
	va_start(a,str);
	Wait(&DbgLock);
	getpath(dbg_msg,&ThisMc->DirNode);
	strcat(dbg_msg,": ");
	strcat(dbg_msg,str);
	for( i = 0 ; i < 10 ; i++ ) dbg_args[i] = va_arg(a,int);
	IOdebug(dbg_msg,dbg_args[0],dbg_args[1],dbg_args[2],dbg_args[3],
			dbg_args[4],dbg_args[5],dbg_args[6],dbg_args[7],
			dbg_args[8],dbg_args[9]);
	Signal(&DbgLock);
	va_end(a);
}

/* AF_HELIOS socket domain handling */

#include <sys/types.h>
#include <sys/socket.h>

#define RemoteBit	8

typedef struct Waiter
{
	Node		Node;
	word		EndTime;
	SockEntry	*Socket;
	word		Type;
	Port		Reply;
	void		*Addr;		/* used only by Connect & SendMessage */
	word		Size;		/* used only by RecvMessage	*/
} Waiter;

#define FreeWaiter(www) if(www->Addr!=NULL) PFree(www->Addr); PFree(www);

static Waiter *NewWaiter(word type, Port reply, SockEntry *s)
{
	Waiter *w = New(Waiter);
	
	if( w == NULL ) return NULL;
	
	w->Type = type;
	w->Reply = reply;
	w->EndTime = (word)GetDate()+10;
	w->Socket = s;
	w->Addr = NULL;
	w->Size = 0;
	
	return w;
}

static bool findtype(Waiter *w, word type) { return w->Type==type; }

static word replyselect(Waiter *w, int flags)
{
	if( ((w->Type & FG_Mask) == FG_Select) && (w->Type & flags) )
	{
		MCB mcb;
		Remove(&w->Node);
		InitMCB(&mcb,0,w->Reply,NullPort,flags);
		PutMsg(&mcb);
		FreeWaiter(w);
		return 1;
	}
	return 0;
}

static word killselect(Waiter *w)
{
	if( (w->Type & FG_Mask) == FG_Select)
	{
		Remove(&w->Node);
		FreePort(w->Reply);
		FreeWaiter(w);
		return 1;
	}
	return 0;
}

static void *copystruct(word size, void *str)
{
	void *v;

	if( size == 0 || str == NULL ) return NULL;
	
	v = PMalloc((int)size);
	if( v == NULL ) return NULL;
	
	memcpy(v,str,(int)size);
	
	return v;
}

static void MarshalAddr(MCB *mcb, int family, void *addr, word addrsize)
{
	int dsize;
	byte *data;
	int sasize = 2 + (int)addrsize;
	
	if( addr == NULL )
	{ 
		MarshalWord(mcb,-1);
		return;
	}
	
	MarshalOffset(mcb);
	
	MarshalData(mcb, sizeof(word), (byte *)&sasize );

	dsize = mcb->MsgHdr.DataSize;
	data = mcb->Data + dsize;
	
	*data++ = family & 0xff;
	*data++ = (family>>8) & 0xff;
	
	memcpy(data,addr,(int)addrsize);
	
	mcb->MsgHdr.DataSize = dsize + sasize;
}

static void MakeConnection(Waiter *acc, Waiter *conn)
{
	SockEntry *s = acc->Socket;
	MsgBuf *m;
	MCB *mcb;
	word proto = s->Protocol & 0xff;
	byte *addr = (byte *)conn->Addr;
	
	m = New(MsgBuf);
	
	if( m == NULL )
	{
		AddTail(&s->WaitQ,&acc->Node);
		AddTail(&s->WaitQ,&conn->Node);
		return;
	}
	
	mcb = &m->mcb;
	mcb->Control = m->control;
	mcb->Data = m->data;
	
	if( proto == 1 ) /* stream socket, make a pipe */
	{
		Object *pipe;
		Object *pipeman;
		char *name = m->data;	/* temp */
		word count = 1;
		NameEntry *n;
	
		/* force the pipe server to be loaded */	
		n = (NameEntry *)Lookup(&ThisMc->DirNode,"pipe",FALSE);
		if( n->Server == NullPort ) LoadServer(n);
			
		Signal(&s->ObjNode.Lock);
		pipeman = Locate(NULL,"/pipe");
		Wait(&s->ObjNode.Lock);

		if( pipeman == NULL ) goto fail;

		forever
		{
			count %= 1000;
			
			strcpy(name,"stream.socket.");
			addint(name,count);
			Signal(&s->ObjNode.Lock);
			pipe = Create(pipeman,name,Type_Pipe,0,0);
			Wait(&s->ObjNode.Lock);
			if( pipe != NULL ) break;

			count++;
		}

		InitMCB(mcb,0,conn->Reply,NullPort,Err_Null);
		
		MarshalWord(mcb,Type_Pseudo);
		MarshalWord(mcb,pipe->Flags|O_ReadWrite);
		MarshalCap(mcb,&pipe->Access);
		MarshalString(mcb,pipe->Name);
		MarshalWord(mcb, NullPort);
				
		PutMsg(mcb);
		
		mcb->MsgHdr.Dest = acc->Reply;

			/* BLV - fix 4.3.93, ProcMan and the system	  */
			/* library disagreed about the structure returned */
		mcb->MsgHdr.ContSize--;
		
		MarshalAddr(mcb, AF_HELIOS, addr+2, (word)strlen(addr+2)+1);
		
		PutMsg(mcb);
		
		Close(pipe);
		Close(pipeman);
	}
	elif( proto == 3 )	/* raw protocol interface 	*/
	{
		word e;
		/* This generates replies just like a stream socket */
		/* except that the two ports are simply exchanged   */		

		InitMCB(mcb,MsgHdr_Flags_preserve,
				conn->Reply,acc->Reply,Err_Null);
		
		MarshalWord(mcb,Type_Socket);
		MarshalWord(mcb,O_ReadWrite);
		MarshalWord(mcb,-1);
		MarshalWord(mcb,-1);
		MarshalOffset(mcb);
		getpath(mcb->Data+mcb->MsgHdr.DataSize,(DirNode *)&s->ObjNode);
		mcb->MsgHdr.DataSize += strlen(mcb->Data+mcb->MsgHdr.DataSize)+1;

		e = PutMsg(mcb);

		mcb->MsgHdr.Dest = acc->Reply;
		mcb->MsgHdr.Reply = conn->Reply;

		MarshalAddr(mcb, AF_HELIOS, addr+2, (word)strlen(addr+2)+1);
		
		e = PutMsg(mcb);
	}

	FreeWaiter(acc); FreeWaiter(conn);
	PFree(m);	/* BLV - fix memory leak	*/
	return;				

fail:
	InitMCB(mcb,0,acc->Reply,NullPort,EC_Error|SS_ProcMan|EG_WrongFn|EO_Socket);
	PutMsg(mcb);
	mcb->MsgHdr.Dest = conn->Reply;	
	PutMsg(mcb);
	FreeWaiter(acc); FreeWaiter(conn);
	PFree(m);	/* BLV - fix memory leak	*/
}

static void DoAccept(MCB *m, SockEntry *s)
{
	Waiter *w, *w1;
	
	if( s->BackLog == 0 )
	{
		ErrorMsg(m,EC_Error|EG_WrongFn|EO_Socket);
		return;
	}
	
	w = NewWaiter(FG_Accept,m->MsgHdr.Reply,s);

	if( w == NULL ) 
	{
		ErrorMsg(m,EC_Error|EG_NoMemory|EO_Socket);
		return;
	}
		
	if( (w1 = (Waiter *)SearchList(&s->WaitQ,findtype,FG_Connect)) == NULL )
		AddTail(&s->WaitQ,&w->Node);
	else 
	{
		Remove(&w1->Node);
		MakeConnection(w,w1);
	}
}

static bool ForwardRequest(MCB *m, SockEntry *s, word fn, char *name)
{
	MsgBuf *mm;
	SockEntry *n;
	Port dest = NullPort;

	n = (SockEntry *)Lookup(&ThisMc->DirNode,name,FALSE);

	if( n != NULL ) dest = n->Server;
	else {
		/* do a Search for the required socket */
		Wait(&SearchLock);
		mm = Search( name, NULL, NewId() ); 
		Signal(&SearchLock);
		if( mm != NULL ) dest = mm->mcb.MsgHdr.Reply;
		PFree(mm);
	}
	
	if( dest == NullPort )
	{
		/* return an error if it is not found */
		ErrorMsg(m,EC_Error|EG_Unknown|EO_Socket);
		return FALSE;
	}
	else
	{
		word e;

		/* pass request on if it was found, adding the name of	*/
		/* this socket to the message.				*/
		
		MarshalAddr(m, AF_HELIOS, s->ObjNode.Name, (word)strlen(s->ObjNode.Name)+1);		
		m->MsgHdr.Flags = 0;
		m->MsgHdr.Dest = dest;
		m->MsgHdr.FnRc = fn | RemoteBit;
		
		e = PutMsg(m);
	}

	return TRUE;
}

static void DoConnectIn(MCB *m, SockEntry *s)
{
	Waiter *w1, *w;
	
	if( (s->Protocol & 0xf) == 2 )	/* DataGram connect	*/
	{
		Capability New;
		InitMCB(m,0,m->MsgHdr.Reply,s->Server,SS_ProcMan|RemoteBit);
		MarshalWord(m,Type_Socket);
		MarshalWord(m,Flags_Server|Flags_Closeable|Flags_Selectable|O_ReadWrite);
		NewCap(&New,&s->ObjNode,AccMask_Full);
		MarshalCap(m,&New);
		getpath(m->Data+m->MsgHdr.DataSize,(DirNode *)&s->ObjNode);
		m->MsgHdr.DataSize += strlen(m->Data+m->MsgHdr.DataSize)+1;

		PutMsg(m);

		s->Users++;

		return;
	}
	
	w = NewWaiter(FG_Connect,m->MsgHdr.Reply,s);

	if( w == NULL ) 
	{
		ErrorMsg(m,EC_Error|EG_NoMemory|EO_Socket);
		return;
	}

	w->Addr = copystruct(*(word *)(m->Data + m->Control[1]),m->Data + m->Control[1] + 4);
	
	if( (w1 = (Waiter *)SearchList(&s->WaitQ,findtype,FG_Accept)) == NULL )
	{
		AddTail(&s->WaitQ,&w->Node);
		WalkList(&s->WaitQ,replyselect,O_ReadOnly);
	}
	else 
	{
		Remove(&w1->Node);
		MakeConnection(w1,w);
	}
}

static void DoSelect(MCB *m, SockEntry *s, word fn)
{
	Waiter *w1, *w;
	word flags = fn & FF_Mask;

	if( (s->Protocol & 0xf) == 1 || (s->Protocol & 0xf) == 3 )
	{
		/* stream/raw select, look for a Connect */
		if( (w1 = (Waiter *)SearchList(&s->WaitQ,findtype,FG_Connect)) != NULL )
		{
			m->MsgHdr.FnRc = O_ReadOnly;
			ErrorMsg(m,0);
			return;
		}
	}
	elif( (s->Protocol & 0xf) == 2 )
	{
		/* DataGram select, look for either recv or send or an	*/
		/* opposite select.					*/

		int result = 0;

		if( flags & O_ReadOnly )
		{
			if( SearchList(&s->WaitQ,findtype,FG_SendMessage) ||
			    WalkList(&s->WaitQ,replyselect,O_WriteOnly)	   )
				result |= O_ReadOnly;
		}

		if( flags & O_WriteOnly )
		{
			if( SearchList(&s->WaitQ,findtype,FG_RecvMessage) ||
			    WalkList(&s->WaitQ,replyselect,O_ReadOnly)	   )
				result |= O_WriteOnly;
		}

		if( result )
		{
			m->MsgHdr.FnRc = result;
			ErrorMsg(m,0);
			return;
		}
	}

	/* no immediate match found, add a waiter, first get rid of any */
	/* outstanding selects.						*/
	
	WalkList(&s->WaitQ,killselect);
		
	w  = NewWaiter(FG_Select|flags,m->MsgHdr.Reply,s);

	if( w == NULL ) 
	{
		ErrorMsg(m,EC_Error|EG_NoMemory|EO_Socket);
		return;
	}

	w->EndTime = -1;	/* wait forever */
			
	AddTail(&s->WaitQ,&w->Node);
}

static void SwapDataGram(Waiter *send, Waiter *recv)
{
	MsgBuf *m;
	MCB *mcb;
	byte *addr   = (byte *)send->Addr;
	SockEntry *s = send->Socket;

	m = New(MsgBuf);
	
	if( m == NULL )
	{
		AddTail(&s->WaitQ,&send->Node);
		AddTail(&s->WaitQ,&recv->Node);
		return;
	}
	
	mcb = &m->mcb;
	mcb->Control = m->control;
	mcb->Data = m->data;

	InitMCB(mcb,0,send->Reply,recv->Reply,Err_Null);
	
	MarshalWord(mcb,0);
	MarshalWord(mcb,recv->Size);
	MarshalWord(mcb,0);
	MarshalWord(mcb,-1);
	MarshalAddr(mcb,AF_HELIOS,s->ObjNode.Name,(word)strlen(s->ObjNode.Name)+1);
	MarshalAddr(mcb,AF_HELIOS,addr+2,(word)strlen(addr+2)+1);

	PutMsg(mcb);
	
	FreeWaiter(send);
	FreeWaiter(recv);
	PFree(m);
}

static void DoSendMessage(MCB *m, SockEntry *s)
{
	Waiter *w1, *w;
	DataGram *dg = (DataGram *)m->Control;

	w = NewWaiter(FG_SendMessage,m->MsgHdr.Reply,s);
	w->EndTime = dg->Timeout==-1?-1:GetDate()+(dg->Timeout/OneSec);
	
	if( w == NULL ) 
	{
		ErrorMsg(m,EC_Error|EG_NoMemory|EO_Socket);
		return;
	}

	w->Addr = copystruct(*(word *)(m->Data + dg->SourceAddr),m->Data + dg->SourceAddr + 4);
	w->Size = dg->DataSize;

	if( (w1 = (Waiter *)SearchList(&s->WaitQ,findtype,FG_RecvMessage)) == NULL )
	{
		AddTail(&s->WaitQ,&w->Node);
		WalkList(&s->WaitQ,replyselect,O_ReadOnly);
	}
	else 
	{
		Remove(&w1->Node);
		SwapDataGram(w,w1);
	}	
}

static void DoRecvMessage(MCB *m, SockEntry *s)
{
	Waiter *w, *w1;
	DataGram *dg = (DataGram *)m->Control;

	if( (s->Protocol & 0xf) != 2 )
	{
		ErrorMsg(m,EC_Error|EG_Invalid|EO_Socket);
		return;
	}
	
	w = NewWaiter(FG_RecvMessage,m->MsgHdr.Reply,s);
	w->EndTime = dg->Timeout==-1?-1:GetDate()+(dg->Timeout/OneSec);

	if( w == NULL ) 
	{
		ErrorMsg(m,EC_Error|EG_NoMemory|EO_Socket);
		return;
	}

	w->Size = dg->DataSize;
			
	if( (w1 = (Waiter *)SearchList(&s->WaitQ,findtype,FG_SendMessage)) == NULL )
	{
		AddTail(&s->WaitQ,&w->Node);
		WalkList(&s->WaitQ,replyselect,O_WriteOnly);
		
	}
	else 
	{
		Remove(&w1->Node);
		SwapDataGram(w1,w);
	}
}

static void DoGetInfo(MCB *mcb, SockEntry *s, word fn)
{
	word level = mcb->Control[0];
	word option = mcb->Control[1];

/* IOdebug("DoGetInfo %s %x",s->ObjNode.Name,fn); */
	switch( level )
	{
	case SOL_SYSTEM:		/* system	*/
		switch( option )
		{
		default: goto badopt;
		case SO_HOSTID:
		case SO_HOSTNAME:
			goto badopt;
		}
		break;
		
	case SOL_SOCKET:		/* socket	*/
		switch( option )
		{
		case SO_SOCKNAME:
			InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,Err_Null);
			MarshalWord(mcb, level );
			MarshalWord(mcb, option );
			MarshalAddr(mcb,AF_HELIOS,s->ObjNode.Name,(word)strlen(s->ObjNode.Name)+1);
			PutMsg(mcb);
			break;
			
		case SO_PEERNAME:
			default:
		badopt:
			ErrorMsg(mcb,EC_Error|EG_Parameter|2);
			break;
		}
		break;
	
	default:
		ErrorMsg(mcb,EC_Error|EG_Parameter|1);
		break;
	}
}

static void DoSetInfo(MCB *mcb, SockEntry *s, word fn)
{
	word level = mcb->Control[0];
	word option = mcb->Control[1];

/* IOdebug("DoSetInfo %s %x",s->ObjNode.Name,fn); */
	switch( level )
	{
	case SOL_SYSTEM:		/* system	*/
		switch( option )
		{
		default: goto badopt;
		case SO_HOSTID:
		case SO_HOSTNAME:
			goto badopt;
		}
		break;
		
	case SOL_SOCKET:		/* socket	*/
		switch( option )
		{
		case SO_PEERNAME:
		case SO_SOCKNAME:
		default:
		badopt:
			ErrorMsg(mcb,EC_Error|EG_Parameter|2);
			break;
		}
		break;
	
	default:
		ErrorMsg(mcb,EC_Error|EG_Parameter|1);
		break;
	}
}

static word dotimeout(Waiter *w)
{
	if ( w->EndTime > 0 && GetDate() >= w->EndTime )
	{
		MCB mcb;
		Remove(&w->Node);
		InitMCB(&mcb,0,w->Reply,NullPort,
			EC_Recover|SS_ProcMan|EG_Timeout|EO_Socket);
		PutMsg(&mcb);
		FreeWaiter(w);
	}
	return 1;
}

static void SocketServer(SockEntry *s)
{
	MsgBuf *m;
	MCB *mcb;
		
	while( (m = New(MsgBuf)) == NULL ) Delay(OneSec);

	mcb = &m->mcb;
	mcb->Control = m->control;
	mcb->Data = m->data;
	
	forever
	{
		word e;

		mcb->MsgHdr.Dest = s->Server;
		mcb->Timeout = OneSec*2;

		e = GetMsg(mcb);

		if( e == EK_Timeout )
		{
			Wait(&s->ObjNode.Lock);
			WalkList(&s->WaitQ,dotimeout,s);
			Signal(&s->ObjNode.Lock);
			continue;
		}	
		
		if( e < Err_Null ) continue;

		Wait(&s->ObjNode.Lock);

/*		IOdebug("SocketServer %s msg %M",s->ObjNode.Name,mcb);*/
		
		mcb->MsgHdr.FnRc = SS_ProcMan;

		switch( e & (FG_Mask|FF_Mask) )
		{
		case FG_Listen:
			if( (s->Protocol & 0xf) == 1 || 
			    (s->Protocol & 0xf) == 3 ) 
			{
				s->BackLog = mcb->Control[0];
				ErrorMsg(mcb,0);
			}
			else goto badfn;
			break;
			
		case FG_Accept:		DoAccept(mcb,s);	break;
		case FG_Connect|RemoteBit:	
					DoConnectIn(mcb,s);	break;
		
		case FG_Select|O_ReadOnly:
		case FG_Select|O_WriteOnly:
		case FG_Select|O_ReadWrite:
					DoSelect(mcb,s,e);	break;
		
		case FG_SendMessage|RemoteBit:
					DoSendMessage(mcb,s);	break;
		case FG_RecvMessage:	DoRecvMessage(mcb,s);	break;
			
		case FG_SendMessage:
		{
			DataGram *dg = (DataGram *)mcb->Control;
			ForwardRequest(mcb,s,e,mcb->Data+dg->DestAddr+6);
		}
					break;
		case FG_GetInfo:
		case FG_GetInfo|RemoteBit:
					DoGetInfo(mcb,s,e);	break;
					
		case FG_SetInfo:
		case FG_SetInfo|RemoteBit:
					DoSetInfo(mcb,s,e);	break;
					
		case FG_Connect:	
		{
			ConnectRequest *req = (ConnectRequest *)mcb->Control;
			if( !ForwardRequest(mcb,s,e,mcb->Data+req->DestAddr+6) )
				break;
		}
		case FG_Close:
		case FG_Close|RemoteBit:
			s->Users--;
			if( s->Users == 0 ) goto done;
			break;

		badfn:
		default:
			ErrorMsg(mcb,EC_Error|EG_WrongFn|EO_Socket);
			break;
		}
		
		Signal(&s->ObjNode.Lock);
	}
	
done:
	Signal(&s->ObjNode.Lock);
	Wait(&HashLock);
	Remove(&s->HashNode);
	Unlink(&s->ObjNode,FALSE);
	if( s->Server != NullPort ) FreePort(s->Server);
	Signal(&HashLock);
	PFree(s); DbInfo.NameEntries--;
	PFree(m);	/* BLV - fix memory leak	*/
}

static word DoBind(ServInfo *servinfo) 
{
	SockEntry *s = (SockEntry *)servinfo->Context;
	SockEntry *n;
	MCB *m = servinfo->m;
	MsgBuf *r;
	char *name;
	char *pathname = servinfo->Pathname;
		
	if( s != DotSocket )
	{
		ErrorMsg(m,EC_Error|EG_WrongFn|EO_Socket);
		return TRUE;
	}

	r = New(MsgBuf);	
	
	if( r == NULL )
	{
		ErrorMsg(m,EC_Error+EG_NoMemory);
		return TRUE;		
	}

	if( m->Control[6] == -1 )
	{
		strcat(pathname,".");
		addint(pathname,SockId++);
		name = objname(pathname);
	}
	else 
	{
		char *p;
		struct sockaddr { short so_family; char so_name[1]; } *addr;
		
		addr = (struct sockaddr *)&m->Data[m->Control[6]+4];
		name = addr->so_name;

		for( p = name; *p ; p++ )
			if( *p == c_dirchar )
			{
				ErrorMsg(m,EC_Error|EG_Invalid|EO_Name);
				PFree(r);	/* BLV - fix memory leak */
				return TRUE;
			}
		getpath(pathname,&ThisMc->DirNode);
		pathcat(pathname,name);
	}

	UnLockTarget(servinfo);
	
	n = (SockEntry *)Lookup(&ThisMc->DirNode,name,FALSE);
		
	if ( n == NULL )
	{
		n = (SockEntry *)NewName(ThisMc,name,(word)Type_Socket,0L,NullPort,
				(Matrix)DefNameMatrix,(word *)NULL,FALSE);
	
		if( n == NULL ) goto nomem;
		n->Protocol = m->Control[5];
		n->BackLog = 0;
		n->Users = 1;
		InitList(&n->WaitQ);
		n->Server = NewPort();
		if( !PFork(SOCKSTACKSIZE,SocketServer,sizeof(n),n) )
		{
		nomem:
			ErrorMsg(m,EC_Error|EG_NoMemory|EO_Socket);
			PFree(r);	/* BLV - fix memory leak	*/
			return TRUE;
		}
	}
	else
	{
		if( n->ObjNode.Type != Type_Socket )
		{
			ErrorMsg(m,EC_Error|EG_Invalid|EO_Socket);
			PFree(r);	/* BLV - fix memory leak	*/
			return TRUE;
		}
		if( n->Protocol != m->Control[5] )
		{
			ErrorMsg(m,EC_Error|EG_Parameter|4);
			PFree(r);	/* BLV - fix memory leak	*/
			return TRUE;			
		}
		n->Users++;
	}
	
	FormOpenReply(r,m,&n->ObjNode, Flags_Closeable|Flags_Selectable, pathname);
	r->mcb.MsgHdr.Reply = n->Server;
	PutMsg(&r->mcb);
	PFree(r);
	return TRUE;
}

static word so_private(ServInfo *servinfo)
{
	MCB *mcb = servinfo->m;
	
	if( (servinfo->FnCode & FG_Mask) == FG_Bind ) return DoBind(servinfo);
	else ErrorMsg(mcb,EC_Error|SS_ProcMan|EG_WrongFn|EO_Socket);
	
	return FALSE;
}


#ifdef PMDEBUG

static int MemAlloced = 0;
static int NForks = 0;


# if 0
static int MemSize(void *v)
{
	int *vv = (int *)v;
	int sz = vv[-2];
	if( sz < 0 ) sz = -sz;
	return sz;
}
# endif

static void *PMalloc(int size)
{
	void *v = Malloc(size);
	
	if( v ) MemAlloced += (int)MemSize(v);
	
	if( debugging(DB_MEM) )
		IOdebug("PMalloc(%d)=%x[%d] from %s",
		size, v, MemSize(v), procname(returnlink_(size)));

	if( MemAlloced > 500000 )
	{
/*		if( !dbprocrunning ) Fork(2000,dbinfoproc,0); */
		dbmask |= DB_IOC1|DB_MEM;
	}

	return v;
}

static void PFree(void *v)
{
	if( v ) MemAlloced -= (int)MemSize(v);
	if( debugging(DB_MEM) )
		IOdebug("PFree(%x[%d]) from %s",v,MemSize(v),
		procname(returnlink_(v)));
		
	Free(v);
}

static bool PFork(int ssize, VoidFnPtr f, int asize, ... )
{
#ifdef __TRAN
	int *args = (&asize)+1;
#else
	/* currently there is no Fork for > 3 args in  Procman */
	word args[4];
	va_list	argp;
	int i;
#endif
	bool res;

#ifndef __TRAN
	va_start(argp, asize);

	for (i = 0;  i < (asize / sizeof(word)) ; i++)
		args[i] = va_arg(argp, word); /* get args */

	va_end(argp);
#endif

	res = Fork(ssize,f,asize,args[0],args[1],args[2]);

	if( res ) NForks++;
	
	if( debugging(DB_MEM) ) 
	{
#ifdef __TRAN
		fncast fc;
		fc.vfn = f;
		IOdebug("PFork %s(%x,%x,%x) from %s %s",
			procname(fc.vp),
			args[0],args[1],args[2],
			procname(returnlink_(ssize)),
			res?"OK":"FAILED");
#else
	  IOdebug("PFork %s(%x,%x,%x) from %s %s",
		  procname(f),
		  args[ 0 ], args[ 1 ], args[ 2 ],
		  procname(NULL),
		  res ? "OK" : "FAILED" );	  
#endif
	}
	
	return res;
}

static word dbtask(TaskEntry *t)
{
	char mode = 'C';
	
	if( t->UseCount > 0 ) mode = 'E';
	if( (t->Status % 10) != 0 ) mode = 'R';
	if( !t->Running ) mode = 'D';
	if( t->ProgInfoSent != 0 ) mode = 'P';
	
	IOdebug("%s[%d,%c] %",t->ObjNode.Name,t->UseCount,mode);
	return 1;
}

static void dbinfoproc(void)
{
	RootStruct *root = GetRoot();
	Config *config = GetConfig();
	int i;
	
	dbprocrunning = TRUE;
	
	while( dbprocrunning )
	{
		dbg("INFO: ------------------------------------------------------------");
		dbg("INFO: FreePool Max %d Size %d",root->FreePool->Max,root->FreePool->Size);
		dbg("INFO: Buffers Max %d Used %d Pool %d",root->MaxBuffers,root->BufferCount,root->BuffPoolSize);
		dbg("INFO: heap size %d, free %d, largest block %d", Malloc(-3), Malloc(-1), Malloc(-2));
		dbg("INFO: Tasks:%"); WalkList(&TaskTable.Entries,dbtask,0); IOdebug("");
		dbg("INFO: Load Av %d Latency %d Max %d",root->LoadAverage,root->Latency,root->MaxLatency);
		root->MaxLatency = 0;
		dbg("INFO: Local Traffic %d Events %d Errors %d",root->LocalMsgs,root->EventCount,root->Errors);
		for( i = 0; i < config->NLinks; i++ )
		{
			LinkInfo *l = root->Links[i];
			dbg("INFO: Link %d St %d Md %d Fl %x Msgs: In %d Out %d Lost %d",
				l->Id,l->State,l->Mode,l->Flags,
				l->MsgsIn,l->MsgsOut,l->MsgsLost);
		}
		dbg("INFO: IOCs %d Servers %d NameEntries %d Tasks %d",
			DbInfo.IOCs,DbInfo.Servers,DbInfo.NameEntries,DbInfo.Tasks);
		dbg("INFO: MsgBufs %d Misc %d Workers %d",
			DbInfo.MsgBufs,DbInfo.Misc,DbInfo.Workers);
		Delay(OneSec*5);
	}
}

#endif

/* -- End of procman.c */

@


1.67
log
@Attempting to reduce memory requirements by using smaller stacks etc.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.64 1993/07/09 13:08:43 nickc Exp $ */
d205 3
a207 3
# define PMSTACKSIZE		1200
# define NTSTACKSIZE		1200
# define SOCKSTACKSIZE		1200
d211 1
a211 1
# define NSReqStackSize		1200
@


1.66
log
@fixed compile time warnings
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.65 1993/07/26 16:19:50 paul Exp nickc $ */
d199 85
d310 2
a311 2
# define PFree		Free
# define PFork		Fork
d337 1
a337 1
static void dbgworker(string name, string dbline);
a354 6
#if defined(__TRAN) && !defined(PMDEBUG)
# define PMSTACKSIZE 1200
#else
# define PMSTACKSIZE 3000
#endif

d360 1
a360 1
	{ (VoidFnPtr)pm_private,2000 },
d362 5
a366 10
		{ pm_open,	PMSTACKSIZE },
#ifdef __ARM
		/* to cope with large module inits i.e. X! */
		{ pm_create,	4000 /*PMSTACKSIZE*/ },
#else
		{ pm_create,	PMSTACKSIZE },
#endif
		{ DoLocate,	PMSTACKSIZE },
		{ DoObjInfo,	PMSTACKSIZE },
		{ do_serverinfo,PMSTACKSIZE },
d368 9
a376 9
		{ DoRename,	PMSTACKSIZE },
		{ InvalidFn,	PMSTACKSIZE },
		{ DoProtect,	PMSTACKSIZE },
		{ DoSetDate,	PMSTACKSIZE },
		{ DoRefine,	PMSTACKSIZE },
		{ NullFn,	PMSTACKSIZE },
		{ DoRevoke,	PMSTACKSIZE },
		{ InvalidFn,	PMSTACKSIZE },
		{ InvalidFn,	PMSTACKSIZE }
a384 6
#if defined(__TRAN) && !defined(PMDEBUG)
# define NTSTACKSIZE 1200
#else
# define NTSTACKSIZE 3000
#endif

d392 5
a396 5
		{ nt_open,	NTSTACKSIZE },
		{ nt_create,	NTSTACKSIZE },
		{ DoLocate,	NTSTACKSIZE },
		{ DoObjInfo,	NTSTACKSIZE },
		{ do_serverinfo,NTSTACKSIZE },
d399 8
a406 8
		{ DoLink,	NTSTACKSIZE },
		{ DoProtect,	NTSTACKSIZE },
		{ DoSetDate,	NTSTACKSIZE },
		{ DoRefine,	NTSTACKSIZE },
		{ NullFn,	NTSTACKSIZE },
		{ DoRevoke,	NTSTACKSIZE },
		{ InvalidFn,	NTSTACKSIZE },
		{ InvalidFn,	NTSTACKSIZE }
a411 6
#if defined(__TRAN) && !defined(PMDEBUG)
# define SOCKSTACKSIZE 1200
#else
# define SOCKSTACKSIZE 3000
#endif

d417 1
a417 1
	{ (VoidFnPtr)so_private,2000},
d419 15
a433 15
		{ InvalidFn,	SOCKSTACKSIZE },
		{ InvalidFn,	SOCKSTACKSIZE },
		{ DoLocate,	SOCKSTACKSIZE },
		{ DoObjInfo,	SOCKSTACKSIZE },
		{ do_serverinfo,SOCKSTACKSIZE },
		{ InvalidFn,	SOCKSTACKSIZE },
		{ InvalidFn,	SOCKSTACKSIZE },
		{ DoLink,	SOCKSTACKSIZE },
		{ DoProtect,	SOCKSTACKSIZE },
		{ DoSetDate,	SOCKSTACKSIZE },
		{ DoRefine,	SOCKSTACKSIZE },
		{ NullFn,	SOCKSTACKSIZE },
		{ DoRevoke,	SOCKSTACKSIZE },
		{ InvalidFn,	SOCKSTACKSIZE },
		{ InvalidFn,	SOCKSTACKSIZE }
a436 57
#ifdef __TRAN
# define ClockStackSize		1000
# define IOCStackSize		1000
# define LinkIOCStack		1000
# define NSReqStackSize		1200
# define SearchStackSize	1000
# define DbgWorkStackSize	400
#else
/* @@@@@@ These stacks can probably be reduced considerably */
# define IOCStackSize		4000
# define LinkIOCStack		4000
# define NSReqStackSize		(4000 + sizeof(jmp_buf))
# define SearchStackSize	4000
# define DbgWorkStackSize	2048
#endif


#ifdef STACKCHECK
#  ifdef __TRAN
void _Trace(...);
#    pragma -s1

static void _stack_error(Proc *p)
{
_Trace(0xaaaaaaaa,p);
	IOdebug("ProcMan stack overflow in %s at %x",p->Name,&p);	
}
#    pragma -s0
#  elif defined (__ARM) || defined(__C40)

#    ifdef __ARM
#      pragma no_check_stack
#    else
#      pragma -s1
#    endif

#ifndef __C40
static void __stack_overflow(void)
{
	IOdebug("ProcMan stack overflow!!");
}
static void __stack_overflow_1(void)
{
	IOdebug("ProcMan stack overflow!");
}
#endif


#    ifdef __ARM
#      pragma check_stack
#    else
#      pragma -s0
#    endif
#  endif

#endif

d647 1
a647 1
	    	PFork(3000,RunInit,0);
d655 1
a655 1
		PFork(3000,TestSys,0);
a937 1

a1306 1

a1567 1

d1580 1
a1580 5
#ifdef __TRAN
					PFork(DbgWorkStackSize ,dbgworker, 8, name, dbline);
#else
					PFork(DbgWorkStackSize ,dbgworker, 8, name, dbline);
#endif
d1698 1
a1698 1
static void dbgworker(string name, string dbline)
a1705 1
	name = name;
d2280 1
a2280 1
	PFork(2500, CallException, 8, task, signal);
a2521 1

d4153 1
a4153 1
		if( !PFork(2000,SocketServer,sizeof(n),n) )
d4201 1
d4215 1
a4215 1

d4227 1
d4237 1
d4261 1
a4261 1
	
d4284 1
d4314 1
d4334 1
a4334 1
#endif /* PMDEBUG */
d4337 1
@


1.65
log
@merged with ARM changes
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.64 1993/07/09 13:08:43 nickc Exp paul $ */
d225 2
a226 2
# define PFree	Free
# define PFork	Fork
d1799 1
a1799 1
	bool *used = (bool *)PMalloc(sizeof(bool)*maxlinks);
a4204 1

d4218 1
a4218 1
	
a4229 1

a4238 1
		
d4262 1
a4262 1

a4284 1

d4333 1
a4333 1
#endif
@


1.64
log
@fixed conflicts with C++
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.63 1993/03/04 15:50:49 bart Exp nickc $ */
d54 1
d59 3
d190 1
a190 1
# ifdef __C40
a261 4
#ifdef __ARM
static void ExecErrorHandler(word signal, char *errmsg, word *regs, bool unrecoverable);
bool DefineExecErrorHandler(VoidFnPtr ErrorHandler);
#endif
a448 6
#ifdef __ARM
	/* register handler for executive critical errors */
	/* - must be done here so that we can use IOdebugs */
	DefineExecErrorHandler(ExecErrorHandler);
#endif

d570 1
a570 2
#ifdef __ARM
# if 0 /* PAB DBG */
a574 1
# endif
d629 1
a629 1
#ifndef __ARM /* these are part of the system image for Helios/ARM */
d728 1
a728 1
#ifdef __ARM
d1703 4
d1714 3
a4199 192
#ifdef __ARM
/* This should really be in the kernel, but then it cannot access the */
/* IOdebugs it needs to report the error condition */

extern Task *_Task_;	/* entry in kernel modtab holding task pointer */
void my_backtrace(int *fp,int *sp,int *pc);
bool TaskName(word *dp, char *name);

static void ExecErrorHandler(word signal, char *errmsg, word *regs, bool unrecoverable)
{
	char taskname[NameMax];

	if (unrecoverable)
	{
		bool valid;

		IOdebug("Unrecoverable Error!");
		IOdebug("[\nSignal #  : %x",signal);
		IOdebug("Error     : %s",errmsg);

# if 1
		valid = TaskName((word *)(regs[9]), taskname);
		IOdebug("Task      : %s", taskname);
# else
		/* index into procman private struct to get task name */
		IOdebug("Task      : %s", (char *)((word *)(_Task_->TaskEntry)+2));
# endif
		my_backtrace((int *)regs[11],(int *)regs[13],(int *)regs[15]); /*fp,sp,pc*/
		IOdebug("Registers:   r0/a1:%x   r1/a2:%x   r2/a3:%x   r3/a4:%x",regs[0],regs[1], regs[2],regs[3]);

		IOdebug("             r4/v1:%x  r5/v2:%x  r6/v3:%x  r7/v4:%x", regs[4], regs[5],regs[6],regs[7]);

		IOdebug("             r8/v5:%x  r9/dp:%x r10/sl:%x r11/fp:%x",regs[8],regs[9],regs[10],regs[11]);

		IOdebug("            r12/ip:%x r13/sp:%x r14/lk:%x r15/pc:%x",regs[12],regs[13],regs[14],regs[15]);

		if (valid)
		{
			MCB m;
			word e = SIGABRT;

			IOputs("\nAction    : ABORTING THIS TASK\n]\n");

			/* send exception to task IOC to kill us off */
			InitMCB(&m,MsgHdr_Flags_exception,MyTask->IOCPort,NullPort,
			EC_Error|SS_ProcMan|EG_Exception|EE_Kill);
			/* IOC exception expects signal number in control vec */
			m.Control = &e;
			m.MsgHdr.ContSize = 1;
			PutMsg(&m);
		}
		else
			IOputs("\nAction    : HALTING THIS THREAD\n]\n");
		StopProcess();
	}
	else	/* raise an syncronous signal */
	{
#ifdef SYSDEB /* so we always get a register dump */
	  IOdebug("Signal # %x",signal) ;

	  (void)TaskName((word *)(regs[9]), taskname);
  	  IOdebug("Task      : %s", taskname);

	  my_backtrace((int *)regs[11],(int *)regs[13],(int *)regs[15]); /*fp,sp,pc*/
	  IOdebug("Registers:   r0/a1:%x   r1/a2:%x   r2/a3:%x   r3/a4:%x",regs[0],regs[1], regs[2],regs[3]);

	  IOdebug("             r4/v1:%x  r5/v2:%x  r6/v3:%x  r7/v4:%x", regs[4], regs[5],regs[6],regs[7]);

	  IOdebug("             r8/v5:%x  r9/dp:%x r10/sl:%x r11/fp:%x",regs[8],regs[9],regs[10],regs[11]);

	  IOdebug("            r12/ip:%x r13/sp:%x r14/lk:%x r15/pc:%x",regs[12],regs[13],regs[14],regs[15]);
#endif
		CallException(_Task_, signal);
	}
}

/*> c.backtrace <*/
/*---------------------------------------------------------------------------*/
/* _backtrace: non-terminating backtrace information
 * called by the following assembler fragment
 * |my_postmortem|
 *       MOV     a3,lk
 *       MOV     a2,sp
 *       MOV     a1,fp
 *       B       |my_backtrace|
 *
 * At the moment this code only dumps the function names and does NOT
 * IOputs the entry state of the functions (though this information can
 * be derived from the registers referenced in the entry STM instruction)
 */

void my_backtrace(int *fp,int *sp,int *pc)
{
 /* step down through the frame-pointer list printing function names */
 IOputs("Backtrace : fp = [") ;

 while (fp != 0) /* frame-pointer reference */
  {
   int  *z ;
   int   i ;
   char *name = "cannot be found" ;

   z = (int *)((fp[0] & 0x03fffffc) - 12) ;
   sp = (int *)fp[-2] ;

   /* I search up to 10 words before the STM looking for the marker that */
   /* shows me where the function name is.                               */
   for (i = 0; (i < 10); i++)
    {
     int w = *--z ;

     if ((w & 0xffff0000) == 0xff000000)
      {
       name = (char *)z - (w & 0xffff) ;
       break ;
      }
    }

   IOputs(name) ; IOputs(", ");
   fp = (int *)fp[-3] ;
  }

 IOputs("<top of frame>]\n") ;

 return ;
}


# if 1

/* get validated taskname from dp reg. */
bool TaskName(word *dp, char *name)
{
	word *km;
	int i;
	ObjNode *objnode;
	Task *tp;
	char *tn;
	Pool *syspool, *freepool;

	syspool = &(GetRoot()->SysPool);
	freepool = GetRoot()->FreePool;

	if (InPool((void *)dp,syspool)) {
		strcpy(name,"System Task");
		return false;
	}
	if(InPool((void *)dp,freepool)) {
		strcpy(name,"Error: ModuleTable in FreePool");
		return false;
	}

	if (*dp != (word) dp) { /* check its a module table pointer */
		strcpy(name,"Error: No Module Table");
		return false;
	}

#  ifdef __SMT
	km = (word *) *(dp + 2); /* kernel module */

	tp = (Task *) *(km); /* first data entry holds task pointer */
#  else
	km = (word *) *(dp + 1); /* kernel module */

	tp = (Task *) *(km + 48); /* entry 48 points at task struct */
#  endif

	/* get first element of taskentry */
	objnode = (ObjNode *) tp->TaskEntry;

	tn = objnode->Name;

	for (i =0 ; i<NameMax; i++)
	{
		if (tn[i] == '\0') {
			strcpy(name, tn);
			return true;
		}
/*		if (!isprint(tn[i])) {*/
		if (tn[i] < 32 || tn[i] > 128) {
			strcpy(name, "Error: Corrupt task name");
			return false;
		}
	}

	strcpy(name, "Error: Invalid task Name");
	return false;
}
# endif
#endif


d4272 9
a4280 1
#ifdef __C40
d4286 1
a4286 7
#else
		fncast fc;
		fc.vfn = f;
		IOdebug("PFork %s(%x,%x,%x) from %s %s",
				procname(fc.vp),args[0],args[1],args[2],procname(returnlink_(ssize)),
					res?"OK":"FAILED");
#endif /* __C40 */
d4288 1
a4288 1
	
@


1.63
log
@There was a disagreement between the Processor Manager and the
System Library about the information returned for an Accept request.
This only mattered if the daemon wanted the address of the client,
a rare event.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.62 1993/02/02 15:43:24 bart Exp bart $ */
d747 1
a747 1
	if( code == NULL ) { IOdebug("Cannot load init %x",Result2(o)); return; }
d1084 3
a1086 3
			int class = req->Access.Access;
			if( link == NULL ) class = AccMask_V;
			req->Access.Access = UpdMask(class,ThisMc->DirNode.Matrix);
d1151 1
a1151 1
			string fullname = PMalloc(IOCDataMax);
d1331 1
a1331 1
	int class = req->Access.Access;
d1335 2
a1336 2
		if( local ) class = AccMask_V;
		class = UpdMask(class,ThisMc->DirNode.Matrix);
d1343 4
a1346 4
		case 0:  class = AccMask_V; break; 
		case 1:  class = AccMask_X; break; 
		case 2:  class = AccMask_Y; break; 
		default: class = AccMask_Z; break; 
d1349 1
a1349 1
	req->Access.Access = class;
d1541 1
a1541 1
	MsgBuf 		*m;
d1543 1
a1543 1
	byte		*dbline = PMalloc(128); /* just starting must work */
d1545 1
a1545 1
	NameEntry	*n;
d1547 1
a1547 1
	RootStruct	*root = GetRoot();
d1591 1
a1591 1
					while( (dbline = PMalloc(128)) == NULL ) Delay(OneSec);
d1800 1
a1800 1
	bool *used = PMalloc(sizeof(bool)*maxlinks);
d2413 1
a2413 1
	char *name = PMalloc(IOCDataMax);
d2848 1
a2848 1
		dbg("ProcMan unknown function in pm_private: %x",servinfo->FnCode);
d3510 1
a3510 1
	byte *addr = conn->Addr;
d3695 1
a3695 1
		Capability new;
d3699 2
a3700 2
		NewCap(&new,&s->ObjNode,AccMask_Full);
		MarshalCap(m,&new);
d3799 1
a3799 1
	byte *addr = send->Addr;
@


1.62
log
@Fixed the IOC to run at HighServerPri like the rest of the Processor Manager.
This was causing various timeouts in heavily loaded systems.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.61 1992/12/04 17:02:57 bart Exp bart $ */
d3569 4
@


1.61
log
@fixed bug in MakeConnection() which could use the two ends of the
socket to do a FreePort() with an uninitialised bit of memory.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.60 1992/12/04 16:46:48 nickc Exp $ */
d879 1
a879 1
	ExecProcess((void *)IOCArg, StandardPri);
@


1.60
log
@fixed compile time warnings
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.59 1992/12/04 16:09:20 nickc Exp nickc $ */
d3563 1
@


1.59
log
@removed procname()
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.58 1992/11/20 17:40:33 nick Exp nickc $ */
d1546 1
d1548 1
d1800 1
a1800 1
	bool *used = PMalloc(sizeof(bool)*(int)maxlinks);
@


1.58
log
@Now uses MPtr's to access all code.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.55 1992/09/15 15:59:48 paul Exp $ */
a4390 60
static char procnamebuf[256];

#ifdef __C40

static char *procname(VoidFnPtr fn)
{
	if (fn == NULL) {
		/* find the name of the function that called our parent */
		int x = _backtrace(procnamebuf, NULL);
		if (x == NULL)
			return "Unknown Function";

		if (_backtrace(procnamebuf, x) == NULL)
			return "Unknown Function";

		return procnamebuf;
	} else {
		/* find the name of the function that is passed as arg */
		fncast fc;
		MPtr x;
		int s;
		
		fc.vfn = fn;
		x = (MPtr)fc.w;

		x = MInc_(x,-4);
		s = MWord_(x,0) & 0xFF;
		x = MInc_(x,-s);

		MData_(procnamebuf,x,offsetof(Proc,Name),sizeof(procnamebuf));
		
		return procnamebuf;
	}
}
#else
static char *procname(void *fn)
{
	MPtr x;

# ifdef __ARM
	x = (MPtr)(((int)fn)&~0xfc000003); /* remove status bits */
# else
	x = (MPtr)(((int)fn)&~3);
# endif	
	while( (MWord_(x,0) & T_Mask) != T_Valid ) x = MInc_(x,-4);
	
	switch( MWord_(x,0) )
	{
	case T_Proc:
		MData_(procnamebuf,x,offsetof(Proc,Name),sizeof(procnamebuf));
		return procnamebuf;
	case T_Module:
	case T_Program:
		ModuleName_(procnamebuf,x);	
		return procnamebuf;
	}

	return("<Unknown type>");
}
#endif
@


1.57
log
@1) Fixed bug in distributed search code when accessing DotSocket on a
   specific processor. There was no Server port so the processor doing
   the searching would end up trying a LoadServer().
2) Fixed various problems relating to program termination. If an open
   stream to a task was broken and reopened then the first stream would
   never go away, therefore the task would never go away. Also the various
   bits of the code that sent signals or tried to KillTask() did not bother
   to check that the task was still running.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.56 1992/10/08 09:33:17 bart Exp $ */
d225 1
a225 1
static TaskEntry *NewTask(string name,Program *prog,Port parent,Matrix access, bool dirlocked);
d443 1
a443 1
	RPTR *prog = config->LoadBase + config->FirstProg + 1;
d587 1
a587 1
	while( *prog )
d589 2
a590 2
		Program *p = (Program *)RTOA(*prog);
		if( p->Module.Type == T_Program )
d599 2
a600 1
			(void)NewTask(makename(p->Module.Name,name),p,
d611 1
a611 1
		prog++;
d753 1
a753 1
	e = NewTask(makename("init",name),(Program *)s->Server,NullPort,
d828 1
a828 1
static TaskEntry *NewTask(string name,Program *prog,Port parent,Matrix access,bool dirlocked)
d917 1
a917 1

d1685 1
a1685 1

d2344 1
d2354 1
a2354 1
	Program *p;
d2374 1
a2374 1
	p = (Program *)(s->Server);
d2376 3
a2378 1
	t = NewTask(makename(p->Module.Name,tname),p,
d2745 1
a2745 1
	t = NewTask(makename(o->Name,name),(Program *)s->Server,
d2812 2
a2813 2
		/* BLV - do not send signals to tasks that have already	*/
		/* died.						*/
d2815 1
a2815 1

d3370 1
a3370 1
	strcpy(name,s);
a4390 1
#ifdef __C40
d4393 2
d4409 6
a4414 1
		char *x = _FuncToDataConvert(fn);
d4416 3
a4418 2
		if (x == NULL)
			return "Unknown Function";
d4420 3
a4422 3
		x -= *(x - 4) + 4;

		return x;
d4428 2
d4431 1
a4431 1
	word *x = (word *)(((int)fn)&~0xfc000003); /* remove status bits */
d4433 1
a4433 1
	word *x = (word *)(((int)fn)&~3);
d4435 1
a4435 1
	while( (*x & T_Mask) != T_Valid ) x--;
d4437 1
a4437 1
	switch( *x )
d4440 2
a4441 1
		return ((Proc *)x)->Name;
d4444 2
a4445 1
		return ((Module *)x)->Name;
@


1.56
log
@Fixed missing Signal() in an error condition which could leave the
world locked.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.55 1992/09/15 15:59:48 paul Exp bart $ */
d916 1
a916 1
	
d1684 1
a1684 1
	
d2056 2
a2057 1
		(n->ObjNode.Type&~Type_Flags)==Type_Socket?n->Server:link->LocalIOCPort,
a2342 1
	
d2464 2
d2525 18
a2542 1
			if( !t->Running ) GenProgInfo(t);			
d2570 5
d2600 1
d2807 4
@


1.55
log
@fixed DefaultException to be called in a syncronous manner
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.54 1992/09/04 09:20:01 nickc Exp $ */
d3024 1
@


1.54
log
@fixed compile time warnings
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.53 1992/09/02 16:05:53 bart Exp nickc $ */
d458 1
a2108 1

d2264 1
a2264 1
#ifndef __TRAN
d2300 4
a2303 1
#ifndef __TRAN
a2315 3

		/* @@@@@@ Alternatively, we could just call DefaultException() */
		/* in the syslib - via CallWithModTab() */
d2317 3
a2319 3
		/* else support old signal mechanism as early transputer */
		/* versions of some language runtime's may still use it */
		/* (Their runtimes Exception handlers automatically forked) */
@


1.53
log
@1) fixed uninitialised variable in SearchWorker()
2) removed memory leaks in the socket code (some leaks anyway)
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.52 1992/08/14 12:58:58 bart Exp bart $ */
d61 3
d411 1
d420 1
d422 1
d902 2
a903 2
static void IOC(entry)
TaskEntry *entry;
d2310 1
a2310 1
		CallWithModTab(	entry->Task, signal,
d3123 10
a3132 8
static NameEntry *NewName(d,name,type,flags,port,matrix,loaddata,dirlocked)
NameDir *d;
string name;
word type,flags;
Port port;
Matrix matrix;
word *loaddata;
bool dirlocked;
d3207 1
a3207 1
	NameEntry *n;
d4364 1
a4364 1
		word x = _backtrace(procnamebuf, NULL);
@


1.52
log
@Put a safety check into getpath(), to get around sporadic problems in
the name table handling.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.51 1992/08/04 16:23:59 paul Exp bart $ */
d1939 1
a1939 1
	NameEntry *n;
d3559 1
a3559 1
	
d3568 1
d4043 1
d4087 1
d4113 1
d4122 1
d4128 1
@


1.51
log
@full procname function and increased non transputer stack sizes
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.50 1992/06/21 19:00:47 bart Exp paul $ */
d1425 20
a1444 2
	if( d != (DirNode *)NameTableRoot ) getpath(s,d->Parent);
	else *s = '\0';
@


1.50
log
@1) Removed the acknowledgement back to parent, which did not serve any
   useful purpose.
2) a link change no longer causes the name table to be freed
3) Possible fixed C40 deadlock problems.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.49 1992/06/17 10:09:07 paul Exp $ */
d183 3
d188 1
d270 1
a270 1
# define PMSTACKSIZE 2000
d311 1
a311 1
# define NTSTACKSIZE 2000
d344 1
a344 1
# define SOCKSTACKSIZE 2000
d378 1
d380 6
a385 12
# ifdef __C40
	/* @@@@@@ probably don't need these set so high */
#  define IOCStackSize		4000
#  define LinkIOCStack		4000
#  define NSReqStackSize	4000
#  define SearchStackSize	4000
# else
#  define IOCStackSize		2000
#  define LinkIOCStack		2000
#  define NSReqStackSize	3000
#  define SearchStackSize	2000
# endif
d646 1
a935 3
#if 0 /*defined(__C40) && defined(SYSDEB)*/
	IOdebug("IOC: %s, req %x", task->Program->Module.Name, e);
#endif
d1558 5
a1562 1
					PFork(400,dbgworker,8,name,dbline); 
d1604 1
a1604 1
#ifdef SYSDEB	
a3316 1

d4325 28
a4352 1
#ifndef __C40
a4372 6
#else
/* @@@@@@ yet to be implemented */
static char *procname(void *fn)
{
	return("<procname not implemented in 'C40 version>");
}
d4443 1
a4443 1
		  procname( _FuncToDataConvert( f ) ),
d4445 1
a4445 1
		  procname( returnlink_( ssize ) ),
@


1.49
log
@removed debugging
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.48 1992/06/16 16:07:14 nickc Exp $ */
d607 2
d623 1
d1264 1
a1264 1
	
d1740 1
d1743 1
a1743 1
	
d1745 1
d2184 1
d2197 1
d2200 6
d2830 1
a2830 1
	return false;	/* XXX - added by NC becuase of compiler warning - is this correct ??? */	
@


1.48
log
@temporary check in so that paul can help me fix a bug
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.47 1992/06/15 11:12:35 paul Exp nickc $ */
a2241 2
  IOdebug( "AsyncException: called" );
  
a2242 2

  IOdebug( "AsyncException: parent return" );  
a2270 2
	  IOdebug( "DoSignal: calling async execption handler for signal %d, task %x, modtab %x",
		  signal, entry->Task, entry->Task->ModTab );
a2274 3

	  IOdebug( "DoSignal: call returned" );
	  
@


1.47
log
@all c40 specific code is bracketed with __C40 not __HELIOSC40
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.46 1992/06/12 12:56:38 nickc Exp $ */
d2242 2
d2245 2
d2275 2
d2282 3
d2524 1
d2526 1
d2528 1
d2533 1
@


1.46
log
@fixed IOdebug message
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.45 1992/05/18 14:08:42 nickc Exp nickc $ */
d4403 1
a4403 1
#ifdef __HELIOSC40
d4415 1
a4415 1
#endif /* __HELIOSC40 */
@


1.45
log
@removed spurious debugging messages
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.44 1992/05/02 10:42:08 nickc Exp nickc $ */
d4403 7
d4415 1
@


1.44
log
@removced compiler warnings
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.43 1992/04/21 10:27:52 paul Exp nickc $ */
d932 1
d1023 1
d1069 3
a1071 1
		/* to refer to neighbours				*/ 
d1118 1
a1118 1
	        (pathname != -1) &&			/* pathname used		*/
d1364 1
a2592 2
	/* IOdebug( "pm_create: called" ); */
	
a2705 2
	/* IOdebug( "pm_create: finished" ); */

a2888 2
	/* IOdebug( "nt_create: called" ); */
	
a2937 2
	/* IOdebug( "nt_create: finished" ); */

d3815 1
a3815 1
IOdebug("DoGetInfo %s %x",s->ObjNode.Name,fn);
d3858 1
a3858 1
IOdebug("DoSetInfo %s %x",s->ObjNode.Name,fn);
@


1.43
log
@removed dbg
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.42 1992/04/16 00:23:37 paul Exp $ */
d1761 1
a1761 1
	bool *used = PMalloc(sizeof(bool)*maxlinks);
d1879 1
a1879 1
			int mylink = m->control[2];
d2120 1
d2122 2
a2123 1

d2136 1
a2136 1
		InitMCB(&m,f,entry->ProgInfoPort,NullPort,entry->TermCode);
d2362 2
a2363 2
	int NLinks = GetConfig()->NLinks;
	int mctype = MachineType();
d2420 1
a2420 1
	int mode = req->Arg.Mode&O_Mask;
d2573 1
a2573 1
static void pm_create(ServInfo *servinfo)
d2575 10
a2584 10
	MCB *m = servinfo->m;
	MsgBuf *r;
	DirNode *d;
	TaskEntry *t;
	IOCCreate *req = (IOCCreate *)(m->Control);
	TaskInfo *info = (TaskInfo *)&(m->Data[req->Info]);
	Object *o;
	Stream *s;
	char name[NameMax];
	char *pathname = servinfo->Pathname;
d2587 3
d2702 4
d2811 2
d2846 1
a2846 1
	unless( CheckMask(req->Common.Access.Access,req->Arg.Mode&O_Mask) ) 
d2887 3
d2895 1
d2910 1
d2938 4
d3107 1
a3107 1
	InitNode( &n->ObjNode, name, type, flags, matrix );
d3123 1
a3123 1
	word dist = 0;
d3181 2
a3182 2
				n = NewName(d,part,Type_Name,Flags,
					port,DefNameMatrix,NULL,FALSE);
d3351 1
a3351 1
	w->EndTime = GetDate()+10;
d3387 1
a3387 1
static void *copystruct(int size, void *str)
d3393 1
a3393 1
	v = PMalloc(size);
d3396 1
a3396 1
	memcpy(v,str,size);
d3405 1
a3405 1
	int sasize = 2 + addrsize;
d3423 1
a3423 1
	memcpy(data,addr,addrsize);
d3492 1
a3492 1
		MarshalAddr(mcb, AF_HELIOS, addr+2, strlen(addr+2)+1);
d3521 1
a3521 1
		MarshalAddr(mcb, AF_HELIOS, addr+2, strlen(addr+2)+1);
d3596 1
a3596 1
		MarshalAddr(m, AF_HELIOS, s->ObjNode.Name, strlen(s->ObjNode.Name)+1);		
d3739 2
a3740 2
	MarshalAddr(mcb,AF_HELIOS,s->ObjNode.Name,strlen(s->ObjNode.Name)+1);
	MarshalAddr(mcb,AF_HELIOS,addr+2,strlen(addr+2)+1);
d3813 1
a3813 1
static word DoGetInfo(MCB *mcb, SockEntry *s, word fn)
d3838 1
a3838 1
			MarshalAddr(mcb,AF_HELIOS,s->ObjNode.Name,strlen(s->ObjNode.Name)+1);
d3856 1
a3856 1
static word DoSetInfo(MCB *mcb, SockEntry *s, word fn)
d4063 1
a4063 1
	if( n == NULL )
d4065 2
a4066 2
		n = (SockEntry *)NewName(ThisMc,name,Type_Socket,0,NullPort,
				DefNameMatrix,NULL,FALSE);
d4354 1
a4354 1
	if( v ) MemAlloced += MemSize(v);
d4371 1
a4371 1
	if( v ) MemAlloced -= MemSize(v);
@


1.42
log
@fixes for the C40
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.41 1991/10/14 09:19:40 paul Exp $ */
d932 1
a932 1
#ifdef __C40
@


1.41
log
@SMT -> __SMT
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.40 1991/10/01 16:01:32 nick Exp paul $ */
d375 12
a386 4
# define IOCStackSize		2000
# define LinkIOCStack		2000
# define NSReqStackSize		3000
# define SearchStackSize	2000
d391 1
a391 1
# ifdef __TRAN
d393 1
a393 1
#  pragma -s1
d400 9
a408 3
#  pragma -s0
# elif defined (__ARM)
#  pragma no_check_stack
d417 8
a424 2
#  pragma check_stack
# endif
a452 1

d472 2
a539 1
	MyTask->TaskEntry = &MyTaskEntry;
d592 1
d595 1
d598 1
d601 1
d875 4
a878 1
/*IOdebug("%s NewTask failed e = %x %x %x %x",ThisMc->DirNode.Name,e,IOCArg,task,entry);*/
a903 3
#if 0 /* __ARM DBG to get ^c working */
	SetPriority(HighServerPri);
#endif
d932 3
a934 1

d938 1
d949 3
a951 1
		if( e == EK_Timeout ) continue;
d1021 1
a1021 1
	
a1235 1

d1352 1
a1352 1
	
a1386 1

a1454 1

d1480 1
a1480 1
#ifdef __ARM /* PAB's fix to signal change timing problem */
a1524 1

d1803 1
a1803 1
		
a2092 1

a2093 1

d2127 1
a2127 1
			
d2142 1
a2142 1
#ifndef __ARM /* required for Charlies netserver, should not be needed for Barts */
d2419 1
a2439 1

d2447 1
a2447 1
	
d2496 1
d2532 1
d2534 1
d3097 1
d3108 1
a3108 1
	do {	
d3154 1
a3154 1
PMTRACE(0x17);		
a3200 1

d3213 1
d4291 1
d4312 7
d4361 1
a4361 1
#if 1 /*def __TRAN*/
d4371 1
a4371 1
#if 0 /*ndef __TRAN	*/
@


1.40
log
@ForwardRequest now returns a boolean indicating whether it managed to
forward the request or not. When forwarding a Connect request this is
used to decide whether the local socket server should quit or carry on.
This fixes a bug where starting a client before a server caused things
to hang.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.39 1991/08/13 14:17:09 nick Exp $ */
d4224 1
a4224 1
#  ifdef SMT
@


1.39
log
@DoBootLink() and all references to it compiled out, it is no longer used.
The 0x123 nucleus sync message now made to look like a link mode change
message. The network server will now see such a message each time it boots
a processor, but with an Intelligent/Running Mode/State.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.38 1991/08/05 12:42:08 nick Exp $ */
d3518 1
a3518 1
static void ForwardRequest(MCB *m, SockEntry *s, word fn, char *name)
d3540 1
a3540 1
		return;
d3556 2
d3937 2
a3938 1
			ForwardRequest(mcb,s,e,mcb->Data+req->DestAddr+6);
@


1.38
log
@Fork converted to PFork for CallIOCWorker.
In PMalloc, enable debugging if allocations exceed 500K.
Contents of DbInfo structure reported in periodic INFO reports.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.36 1991/06/19 22:31:28 paul Exp $ */
d221 1
d223 1
d585 2
d593 2
a594 1
			ParentLink->RemoteIOCPort,NullPort,0x123);
d1563 2
a1564 1
			
d1568 2
d1631 1
a1631 1
			IOdebug("Link %d has changed state: code %E conf %x",link->Id,e,*(word *)link);
d1658 1
d1682 1
@


1.37
log
@In SearchWorker the variable "hislink" was not set until after a looped
search was detected. In this case the uninitialized value of hislink was
passed back to the neighbour where it was used to index the "used" array
in Search unchecked. This resulted in aparrently random words in memory
being zeroed, the actual locations depending on the memory layout of
the neighbour processor.
@
text
@d942 1
a942 1
				if( !Fork(IOCStackSize,CallIOCWorker,8,m,entry)) 
d4292 6
d4385 4
@


1.36
log
@increase stack size for ARM taskinit (pm_create) as large module init
requirements (ok it was X!) can cause it to overflow
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.35 1991/06/17 15:44:55 bart Exp $ */
d1789 1
d1794 22
d1817 1
a1817 1
		if( (e = GetMsg(&m->mcb) ) >= Err_Null ) 
d1826 1
a1826 1
		elif( e == EK_Timeout )
d1828 2
a1829 1
			if( timeouts-- == 0 ) break;
d1841 1
a1841 1
		elif( e&(EC_Mask|EG_Mask|EO_Mask) == EC_Error|EG_Unknown|EO_Server )
d1845 1
a1845 17
			if( m->mcb.MsgHdr.ContSize < 3 )
			{
				/* If the reply control vector is < 3	*/
				/* then this is an IOproc. Look for an	*/
				/* IOproc in the links.			*/
				for( i = 0; i < maxlinks; i++ )
				{
					LinkInfo *link = Root->Links[i];
					if( used[i] && (link->Flags & Link_Flags_ioproc ) )
					{
						mylink = i;
						break;
					}
				}
			}
			used[mylink] = FALSE;
			nlinks--;
d1891 2
d1896 2
a1897 1
	for( i = 0; i < SearchSize ; i++ ) if( SearchTable[i] == id ) goto failed;
a1898 2
	hislink = m->mcb.MsgHdr.ContSize > 2 ? m->control[2] : -1;

d1957 1
a1957 1
	
d1959 1
@


1.35
log
@Two changes:
 1) the size of the search table is now controlled by a manifest, rather
    than by constants 32 and 0x1f throughout the code.
 2) names are only inserted if they are not yet present. This is
    necessary if we are going to embed the pipe server and similar code
    in the nucleus.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.34 1991/06/04 17:06:04 nick Exp bart $ */
d275 4
d280 1
a795 1

d843 1
@


1.34
log
@FORKIOCWORKER option to cause IOC to fork a worker for each request added
and enabled.
Timeout on search reply reduced to OneSec and number of timeouts
reduced to 3, this means that no distributed seach can take more than
3 or 4 seconds.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.33 1991/05/30 13:51:14 chris Exp nick $ */
d139 3
a141 2
static word		SearchTable[32];	/* id's of recent searches */
static word		STOffset = 0;		/* offset into table (mod 32) */
d1881 1
a1881 1
	for( i = 0; i < 32 ; i++ ) if( SearchTable[i] == id ) goto failed;
d1886 1
a1886 1
	SearchTable[ (STOffset++)&0x1f ] = id;
d3022 1
a3022 1
	NameEntry *n = New(NameEntry);
d3026 6
d3215 1
a3215 1
	return SearchTable[ (STOffset++)&0x1f ] = 
@


1.33
log
@Start init if Root_Flags_rootnode is set in config vector.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.32 1991/03/25 16:38:52 paul Exp chris $ */
d23 2
d221 3
d933 11
d945 1
d951 8
d1716 1
a1716 1
	word timeouts = 6;
d1774 1
a1774 1
		if( (e = PutMsg(&m->mcb)) < Err_Null) nlinks--;
d1784 1
a1784 1
		m->mcb.Timeout = OneSec*3;
@


1.32
log
@made taskname[] in ARM exec error handler common to the subblocks
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.31 1991/03/20 13:31:36 paul Exp paul $ */
d597 3
a599 1
	if( ParentLink == NULL || (ParentLink->Flags & Link_Flags_ioproc) )
@


1.31
log
@if SYSDEB always print debugging in exec error handler, as almost all
signals are now recoverable. (ARM)
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.30 91/02/25 15:59:42 nick Exp $ */
d4015 2
a4018 1
		char taskname[NameMax];
@


1.30
log
@KILLLOCK and SEARCHLOCK conditional compilation flags removed.
All global variables and procedures made static where necessary.
Search() altered to re-test links on timeouts, this is to cope with
reconfiguration.
RemName altered to eliminate a potential race condition.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.29 91/02/19 11:20:35 nick Exp $ */
d4060 16
d4077 1
@


1.29
log
@Trail following compiled out for production nucleus]
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.28 91/02/19 10:57:41 nick Exp Locker: nick $ */
a26 4
#define KILLLOCK 1	/* serialize KillTask calls			*/

#define SEARCHLOCK 1	/* serialize Search requests			*/

d111 1
a111 1
Semaphore	HashLock;			/* Hash table lock	*/
d113 1
a113 1
List		HashTable[HashSize];		/* the table		*/
d115 1
a115 1
NameDir		*NameTableRoot;			/* name table root	*/
d117 1
a117 1
NameDir		*ThisMc;			/* name table entry for me */
d119 1
a119 1
NameEntry	NameServerEntry;		/* dummy entry for NS	*/
d121 1
a121 1
DirNode		TaskTable;			/* task table root	*/
d123 1
a123 1
TaskEntry	MyTaskEntry;			/* Task table entry for ProcMan */
d125 1
a125 1
Port		NameTabReqPort;			/* name table server port */
d127 1
a127 1
LinkInfo	*ParentLink;			/* the link which booted us */
d129 1
a129 1
RootStruct	*Root;
d131 1
a131 1
SockEntry	*DotSocket;			/* socket server entry	*/
d133 1
a133 1
word		SockId = 1;			/* anonymous socket nos	*/
d135 1
a135 1
word		TaskErr;			/* NewTask error	*/
d137 3
a139 1
word		TaskId = 1;			/* task identifier counter */
a140 3
word		SearchTable[32];		/* id's of recent searches */
word		STOffset = 0;			/* offset into table (mod 32) */
word		IdSeed;				/* seed for Id		*/
d142 1
a142 2

struct {
d152 1
a152 3
#if KILLLOCK
Semaphore KillLock;
#endif
d154 1
a154 3
#if SEARCHLOCK
Semaphore SearchLock;
#endif
d156 1
a156 1
Semaphore DbgLock;
d170 1
a170 1
word dbmask = 0;
d172 1
a172 1
word dbmask = 0;
d178 1
a178 1
# define returnlink_(x) (((word *)(&(x)))[-2])
d193 2
d215 1
a215 1
TaskEntry *NewTask(string name,Program *prog,Port parent,Matrix access, bool dirlocked);
d232 1
a232 3
void ErrorMsg(MCB *, word );
void *searchlist( List *, char *);
void dbg(char *, ... );
d234 5
a238 5
NameEntry *NewName(NameDir *,string,word,word,Port,Matrix,word *,bool);
word hash(char *s);
string makename(string,string);
void getpath(string s, DirNode *d);
NameEntry *AddName(string name, Port port, word Flags);
d240 3
a242 3
void DoSignal(word signal, TaskEntry *entry);
word NewId(void);
void RemName(NameEntry *n);
d244 1
a244 1
void ExecErrorHandler(word signal, char *errmsg, word *regs, bool unrecoverable);
d374 1
a374 1
void _stack_error(Proc *p)
a424 1
#if KILLLOCK
a425 1
#endif
a426 1
#if SEARCHLOCK
a427 1
#endif
d604 1
a604 1
		void TestSys(void);
d613 1
a613 1
void TestSys(void)
d775 1
a775 1
TaskEntry *NewTask(string name,Program *prog,Port parent,Matrix access,bool dirlocked)
d1353 1
a1353 1
void getpath(string s, DirNode *d)
d1670 2
d1688 7
a1694 1

d1700 4
d1706 7
a1712 1
	if( m == Null(MsgBuf) ) return NULL;
d1722 1
a1722 1
	for( i = 0; Root->Links[i] != NULL ; i++ )
d1726 2
d1734 1
d1741 1
a1741 1

d1754 1
a1754 1
	while( nlinks-- )
d1757 1
a1757 1
		m->mcb.Timeout = IOCTimeout;	/* wait no more than 20 secs */
d1770 36
d1811 3
a1813 1

d1838 2
a1839 1
	
d1846 2
a1847 2
		dbg("SearchWorker for %s id = %x from link %d",
			sname,m->control[1],link->Id);
d1855 2
d1948 1
d1962 5
a1966 1
	InitMCB(&m->mcb,0,m->mcb.MsgHdr.Reply,NullPort,EC_Error);
a2013 1
#if KILLLOCK
d2015 1
a2015 1
#endif
a2017 1
#if KILLLOCK
d2019 1
a2019 1
#endif
d2170 1
a2170 1
void DoSignal(word signal, TaskEntry *entry)
d2673 1
a2673 1
extern bool dbprocrunning;
d2985 1
a2985 1
NameEntry *NewName(d,name,type,flags,port,matrix,loaddata,dirlocked)
d3056 1
a3056 1
NameEntry *AddName(string name, Port port, word Flags)
d3132 1
a3132 1
void RemName(NameEntry *n)
d3134 3
d3143 1
a3143 1
		WalkList(&d->DirNode.Entries,(WordFnPtr)RemName);
a3149 1
	Wait(&HashLock);
a3152 1
	Signal(&HashLock);
d3156 6
d3163 1
a3163 1
word hash(char *s)
d3179 1
a3179 1
word NewId(void)
d3185 1
a3185 1
string makename(string obj,string name)
d3200 1
a3200 1
void dbg(char *str, ... )
a3463 1
	int proto = s->Protocol & 0xf;
d4013 1
a4013 1
void ExecErrorHandler(word signal, char *errmsg, word *regs, bool unrecoverable)
d4184 1
a4184 1
char *procname(void *fn)
d4264 3
d4268 1
a4268 1
				procname((void *)f),args[0],args[1],args[2],procname(returnlink_(ssize)),
d4270 1
a4273 2

bool dbprocrunning = FALSE;
@


1.28
log
@MY change is in the bits set in the search reply message. Many changes by
PAB, but since he just went away without checking this back in I dont
know what they are or even whether they are finished.]
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.27 91/02/13 17:30:16 paul Exp $ */
d1543 1
a1543 1
		
d1583 1
a1583 1

a3137 1
#ifdef PMDEBUG
a3157 1
#endif
@


1.27
log
@get past finickity ARM compiler by correct cast
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.26 91/02/11 17:12:33 nick Exp $ */
d58 1
a58 1
#include <asm.h>	/* for testerr_() */
d187 2
a188 2
#ifdef __HELIOSTRAN
#define returnlink_(x) (((word *)(&(x)))[-2])
d191 1
a191 1
#define returnlink_(x) (_linkreg()) /* return pointer to callers code */
d215 2
a216 2
#undef New
#define New(_type)	(_type *)PMalloc(sizeof(_type))
d218 3
a220 3
#define PMalloc	Malloc
#define PFree	Free
#define PFork	Fork
d253 1
a253 2

#ifdef __HELIOSARM
d266 1
a266 1
#define PMSTACKSIZE 1200
d268 1
a268 1
#define PMSTACKSIZE 2000
d302 1
a302 1
#define NTSTACKSIZE 1200
d304 1
a304 1
#define NTSTACKSIZE 2000
d335 1
a335 1
#define SOCKSTACKSIZE 1200
d337 1
a337 1
#define SOCKSTACKSIZE 2000
d366 5
a370 5
#define ClockStackSize		1000
#define IOCStackSize		1000
#define LinkIOCStack		1000
#define NSReqStackSize		1200
#define SearchStackSize		1000
d372 4
a375 4
#define IOCStackSize		2000
#define LinkIOCStack		2000
#define NSReqStackSize		3000
#define SearchStackSize		2000
d390 1
a390 1
# elif defined (__HELIOSARM)
d421 1
a421 1
#ifdef __HELIOSARM
d551 2
a552 2
#ifdef __HELIOSARM
#if 0 /* PAB DBG */
d557 1
a558 1
#endif
d597 2
a598 2
#undef Type_Auto
#define Type_Auto Type_Name
d601 1
a601 1
#ifndef __HELIOSARM /* these are part of the system image for Helios/ARM */
d640 1
a640 1
#if 0
d659 1
a659 1
#else
d677 1
a677 1
#endif
d726 2
a727 2
#if defined(PMDEBUG)
# if defined(__TRAN)
d743 1
a743 1
# ifdef SYSDEB
d749 1
a749 1
# endif
d778 1
a780 1
#endif
d873 1
a873 1
#if 0 /* __HELIOSARM DBG to get ^c working */
d983 1
a983 1
#if 0
d995 1
a996 1
#endif
d1889 2
d2015 2
a2016 2
#ifndef __HELIOSARM /* required for Charlies netserver, should not be needed for Barts */
#if 1
d2025 1
a2026 1
#endif
d2092 1
d2094 19
d2128 20
a2147 1
		/* else support old signal mechanism */
d2150 1
d2154 1
d3157 1
d3950 1
a3950 1
#ifdef __HELIOSARM
d3969 1
a3969 1
#if 1
d3972 1
a3972 1
#else
d3975 1
a3975 1
#endif
d3987 3
d3993 6
a3998 1
			SendException(_Task_->IOCPort,EC_Error|SS_Executive|EG_Exception|EE_Kill);
d4001 1
a4001 1
			IOputs("\nAction    : Halting this process\n]\n");
d4004 1
a4004 1
	else	/* raise a signal */
d4060 1
a4060 1
#if 1
d4089 1
a4089 1
#ifdef SMT
d4093 1
a4093 1
#else
d4097 1
a4097 1
#endif
d4120 1
a4122 1
#endif
a4123 1

d4131 1
a4131 1
#ifdef __ARM
d4133 1
a4133 1
#else
d4135 1
a4135 1
#endif	
d4150 1
a4150 1
#if 0
d4158 1
a4158 1
#endif
d4185 1
d4187 6
d4194 10
a4203 2
	
	/* currently there is no Fork for > 3 args in  Procman */
d4205 1
a4205 1
	
d4209 2
a4210 2
		IOdebug("PFork %s from %s %s",
				procname((void *)f),procname(returnlink_(ssize)),
a4261 3



@


1.26
log
@SEARCHLOCK conditional compilation flags removed, now default.
Potential problem with multiple searches fixed.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.25 91/02/07 17:42:48 paul Exp $ */
d1107 1
a1107 1
			n = Lookup(&d->DirNode, name, FALSE);
@


1.25
log
@fixed again for finicky ARM compiler
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.24 91/02/07 17:25:46 nick Exp $ */
d1099 6
a1104 1
#if SEARCHLOCK			
d1106 4
a1109 6
#endif
			mm = Search( fullname, link, NewId() ); 
#if SEARCHLOCK			
			Signal(&SearchLock);
#endif
			if( mm != NULL )
d1111 8
a1118 4
				n = AddName((string)mm->data,mm->mcb.MsgHdr.Reply,Flags_CacheName|mm->control[1]);
				PFree(mm);
				DbInfo.MsgBufs--;
			}
d1120 2
a1121 2
			else if(debugging(DB_SEARCH))
				dbg("Search for %s failed",fullname);
d1123 4
a1743 1
#if SEARCHLOCK
d1747 1
a1747 1
#endif
a1765 1
#if SEARCHLOCK
a1766 1
#endif
a1794 1
#if SEARCHLOCK
a1795 1
#endif
a1917 1
#if SEARCHLOCK	
a1918 1
#endif
@


1.24
log
@TESTSYS option added to report link Xon/Xoff operations - debug only.
Potential deadlock in DestroyTask removed.
Sacrifice bit is set on all but first ProgInfo messages to prevent congestion.
NEWSIGNALS flag tests removed - now default behaviour.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.22 91/01/22 17:28:08 paul Exp $ */
d3092 1
a3092 1
#ifdef PMTRACE
d3094 2
a3095 2
char dbg_msg[128];
int dbg_args[10];
@


1.23
log
@/IO removed for ROM systems, Task SignalPort set from control vector.
@
text
@d31 2
d93 1
a96 1
#ifdef NEWSIGNALS
a97 1
#endif
d527 1
d617 6
d627 57
d824 1
a826 1
#ifdef NEWSIGNALS
a827 1
#endif
a1415 1
#ifdef NEWSIGNALS
a1433 1
#endif	
d1974 3
d1999 4
a2002 2
		InitMCB(&m,MsgHdr_Flags_preserve,
			entry->ProgInfoPort,NullPort,entry->TermCode);
d2007 1
d2047 16
d2071 1
a2071 1
	Unlink(&entry->ObjNode, FALSE);
d2082 2
a2093 1
#ifdef NEWSIGNALS
a2107 2
#else /* old signal handling */
# ifdef __HELIOSARM
a2108 35
void AsyncCallException(Task *task, word reason);

void DoSignal(word signal, TaskEntry *entry)
{
	Task *task = entry->Task;

/* Asyncronous exceptions such as ^C, SIGALARM, etc are sent asyncronously */
/* to task i.e. a process for the task as a whole is started. */
/* @@@@@@ Perhaps all processes in a task should receive the signal - probems! */ 

	if( task->ExceptCode == NULL ) return;
	
	CallWithModTab(	(word)task, signal,
			(WordFnPtr)AsyncCallException,
			task->ModTab);
}

void AsyncCallException(Task *task, word reason)
{
	/* now we are guaranteed to be using processes memory */
	/* Fork off to the Default exception handler */
	PFork(1000, task->ExceptCode, 8, reason, task->ExceptData);
}

# else /* __TRAN */
void DoSignal(word signal, TaskEntry *entry)
{
	Task *task = entry->Task;
	CallException(task,signal);
}
# endif
#endif



d3094 2
a3095 2
static char dbg_msg[128];
static int dbg_args[10];
d4151 8
a4158 1
	IOdebug("%s[%d,%c] %",t->ObjNode.Name,t->UseCount,t->Running?'R':'H');
d4172 1
a4172 1
		dbg("INFO: --------------------------------------------------------------");
@


1.22
log
@for arm version, run init from known loaded server i.e. /rom/sys/init.
Also quick bodged fix for ^c timing problem, (not a complete fix, just
makes the odds a lot better) by running the IOC at higher priority.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.21 91/01/04 12:41:01 nick Exp $ */
d551 1
d557 1
d810 1
a810 1
#ifdef __HELIOSARM /* DBG to get ^c working */
d1356 4
d1361 1
d1365 1
d1367 1
d3046 2
a3047 2
char dbg_msg[128];
int dbg_args[10];
@


1.21
log
@SubFunction field of Delete request added to kill state of a Task, this
allows client (specifically TFM) to destroy a task atomically.
When a task is destroyed its return code is set to SIGKILL.
A new debugging option allows machine info to be printed every 5 s.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.20 90/11/29 13:07:31 paul Exp $ */
d631 4
d636 1
d808 3
@


1.20
log
@added a cast to get past the finikity ARM C compiler
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.19 90/11/29 11:27:23 nick Exp $ */
d910 1
d923 1
d1961 1
d2490 2
d2505 1
a2505 1
		MarshalWord(m,-1);
d2510 5
d2525 8
d4082 1
d4084 34
d4121 1
@


1.19
log
@All cached names are removed from the nametable before sending a link
state change message to /ns, this avoids any problems with cached names
which point through a dead link.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.18 90/11/27 19:16:17 nick Exp $ */
d1590 1
a1590 1
	RemName(NameTableRoot);	
@


1.18
log
@bug which zapped memory on renames to large names fixed
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.17 90/11/18 21:46:23 paul Exp Locker: nick $ */
d1513 1
a1513 1
			dbg("Link %d has changed state: code %E",link->Id,e);
d1516 1
a1516 1
		else	dbg("Link %d IOC got error %E",link->Id,e);
d1587 5
@


1.17
log
@procinfo now returns the true number of links on the processor
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.16 90/11/15 16:09:57 nick Exp $ */
d472 2
a473 2
	Parent = (LinkNode *)PMalloc(sizeof(LinkNode) + strlen(myname));
	DbInfo.Misc += sizeof(LinkNode) + strlen(myname);
@


1.16
log
@config->FirstProg used to find start of servers in Ivec
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.15 90/11/08 16:33:29 nick Exp Locker: nick $ */
d2114 1
a2114 1
	int four = 4;
d2141 1
a2141 1
	MarshalData(m,4,(byte *)&four);		
@


1.15
log
@LinkFault message altered according to Bart's requirements
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.14 90/11/02 16:28:20 paul Exp Locker: nick $ */
d415 1
a415 1
	RPTR *prog = config->LoadBase + IVecServers;
@


1.14
log
@fixed procname function for the ARM
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.13 90/11/01 16:33:59 nick Exp $ */
d1582 4
a1585 5
	MarshalWord(&m->mcb,1);		/* UP message		*/
	MarshalString(&m->mcb,mcname);	/* subnet/terminal name	*/
	MarshalWord(&m->mcb,code);	/* reporting subsystem	*/
	MarshalWord(&m->mcb,0);		/* fault code		*/
	MarshalWord(&m->mcb,link->Id);	/* link number		*/
@


1.13
log
@debugging improved. Multiple GetProgramInfo's allowed. several other tidies.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.11 90/10/19 11:13:50 nick Exp $ */
d186 7
d3990 2
a3991 4
#ifdef __HELIOSARM
	/* @@@@@@ ARM C should be upgraded to prefix fn with proc_type */
	return((char *)((int *)fn - 1) - ( *((int *)fn - 1) & 0x00ffffff));

d3994 1
a3994 1
	
d4005 2
a4006 1
#endif
d4027 1
a4027 1
		size, v, MemSize(v), procname((void *)((&size)[-2])));
d4037 1
a4037 1
		procname((void *)((int *)(&v))[-2]));
d4054 1
a4054 1
				procname((void *)f),procname((void *)((&ssize)[-2])),
@


1.12
log
@no change
@
text
@d770 1
a770 1
IOdebug("%s NewTask failed e = %x %x %x %x",ThisMc->DirNode.Name,e,IOCArg,task,entry);
d1108 1
a1108 1
					EC_Recover|SS_IOC|EG_Broken|EO_Server;
d1135 1
a1135 1
	e = PutMsg(mcb);		/* send it		*/
d1338 3
d1523 1
d1526 3
a1528 1
	IOdebug("%s%",dbline);
d1789 3
d1793 1
d1945 3
d1982 1
a1982 1
		/* deliver the signal via a message to the task's own port */
d2270 3
a2272 6
			if( t->ProgInfoPort != NullPort )
			{
				ErrorMsg(m,EC_Error|EG_InUse|EO_Task);
				break;
			}
			t->Status += 100;			
d2280 1
a2280 1
			t->Status += 100;
d2458 3
a2491 1
	
d2757 11
d2999 4
a3004 1
	int x[10];
a3007 1
	for( i = 0 ; i < 10 ; i++ ) x[i] = va_arg(a,int);
d3009 7
a3015 1
	IOdebug(str,x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9]);
d3352 1
a3352 1
	if( (s->Protocol & 0xf) == 1 )
d3354 1
a3354 1
		/* stream select, look for a Connect */
@


1.11
log
@Added ReLocate call for object passed in Execute request. NewObject no-
longer locates, so type of object would have been Pseudo.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.10 90/10/18 17:56:32 nick Exp $ */
@


1.10
log
@some minor tidies.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.9 90/10/16 10:28:24 nick Exp Locker: nick $ */
d2318 1
a2318 1

d2347 7
@


1.9
log
@Bug in Send/RecvMessage timeout calculation fixed. Calls to ForwardRequest
made less kludgy.
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.8 90/10/04 18:19:17 paul Exp $ */
d630 1
a630 1
	if( code == NULL ) { IOdebug("Cannot load init"); return; }
d1375 1
a1375 1
	n = NewName(ThisMc,name,Type_Name,Flags_StripName,
d1522 1
a1522 1
	IOputs(dbline);
@


1.8
log
@convert arm system to use NEWSIGNALS
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.7 90/09/29 16:38:16 nick Exp $ */
d3377 1
a3377 1
		
d3411 1
a3411 1
	
d3413 1
a3413 1
	w->EndTime = GetDate()+(dg->Timeout/OneSec);
d3423 1
a3423 1
			
d3440 1
a3440 1
	
d3448 1
a3448 1
	w->EndTime = GetDate()+(dg->Timeout/OneSec);
d3626 4
a3629 1
				ForwardRequest(mcb,s,e,mcb->Data+mcb->Control[4]+6);
d3639 5
a3643 1
		case FG_Connect:	ForwardRequest(mcb,s,e,mcb->Data+mcb->Control[0]+6);
@


1.7
log
@#if instead of #ifdef
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.6 90/09/29 16:32:06 nick Exp Locker: nick $ */
d1964 17
a1980 1
#ifdef __HELIOSARM
d2006 1
a2006 2
#else /* __TRAN */

a2008 13
#ifdef NEWSIGNALS
	if( entry->SignalPort != NullPort )
	{
		/* deliver the signal via a message to the task's own port */
		SendException(entry->SignalPort,EC_Recover|SS_ProcMan|EG_Exception|EE_Signal|signal);
	}
	else
	{
		/* else support old signal mechanism */
		Task *task = entry->Task;
		CallException(task,signal);
	}
#else
a2010 1
#endif
d2012 1
@


1.6
log
@some protection added to task server, various tidies
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.5 90/09/25 18:20:45 paul Exp Locker: nick $ */
d3936 1
a3936 1
#if __HELIOSARM
@


1.5
log
@arm changes
@
text
@d17 1
a17 1
/* $Id: procman.c,v 1.4 90/09/05 18:22:17 nick Exp Locker: nick $ */
d2151 1
a2151 1

d2166 1
a2166 1
	unless( CheckMask(req->Common.Access.Access,req->Arg.Mode&O_Mask) ) 
d2228 1
d2237 1
d2249 1
d2286 3
d3956 1
d3964 1
@


1.4
log
@revoke added, MakeConnection improved
@
text
@d17 1
a17 1
/* $Id$ */
d3887 5
d3895 1
d3930 5
d3947 1
d3965 3
a3967 2
		IOdebug("PMalloc(%d)=%x[%d] from %s",size,v,MemSize(v),procname((&size)[-2]));
		
d3975 2
a3976 1
		IOdebug("PFree(%x[%d]) from %s",v,MemSize(v),procname(((int *)(&v))[-2]));
d3993 1
a3993 1
				procname(f),procname((&ssize)[-2]),
@


1.3
log
@*** empty log message ***
@
text
@d16 1
a16 1
/* SccsId: %W%	%G% (C) 1987, Perihelion Software Ltd. */
d282 4
a285 1
		{ NullFn,	1000 }
d318 4
a321 1
		{ NullFn,	1000 },
d351 4
a354 1
		{ NullFn,	1000 },
d602 1
a602 1
	    	PFork(2000,RunInit,0);
d1252 1
a1252 1
		if( fn < FG_Open || fn > FG_CloseObj )
d3085 1
d3142 2
a3143 1
		MarshalOffset(mcb);
d3152 1
d3163 1
d3167 1
a3167 1
		PutMsg(mcb);
d3171 2
a3172 1
		MarshalOffset(mcb);
d3174 1
a3174 2
		PutMsg(mcb);
		
d3193 1
a3193 1
	if( s->BackLog == 0 || (s->Protocol & 0xf) != 1 ) 
d3224 1
a3224 1
	
a3234 1
	
d3243 2
d3253 1
a3253 1
		PutMsg(m);
d3595 7
a3601 2
			s->BackLog = mcb->Control[0];
			ErrorMsg(mcb,0);
d3635 1
a3635 1

d3989 2
@


1.2
log
@spurious #endif removed
@
text
@d17 1
a17 8
/* $Id: procman.c,v 1.1 90/08/28 13:06:49 nick Exp Locker: nick $
 *
 * $Log:	procman.c,v $
 * Revision 1.1  90/08/28  13:06:49  nick
 * Initial revision
 * 
 *
 */
@


1.1
log
@Initial revision
@
text
@d17 1
a17 2
#endif
/* $Id$
d19 4
a22 1
 * $Log$
@
