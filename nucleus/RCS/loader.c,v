head	1.37;
access;
symbols
	Helios_1_3_1:1.37
	Helios_C40_1_3_Official_Release:1.31
	Alenia_release:1.28
	Helios1_3:1.23
	C40_Field_Test_2:1.23
	C40_Field_Test_R1:1.20
	Helios13_beta:1.20
	Helios1_2_2:1.17
	Helios1_2_2Beta:1.16
	Helios1_2_1:1.14
	Helios1_2:1.7
	V1_2Beta0:1.3;
locks
	paulw:1.23; strict;
comment	@ * @;


1.37
date	93.09.01.17.55.33;	author bart;	state Exp;
branches;
next	1.36;

1.36
date	93.08.06.12.43.48;	author bart;	state Exp;
branches;
next	1.35;

1.35
date	93.08.03.17.03.27;	author paul;	state Exp;
branches;
next	1.34;

1.34
date	93.07.26.16.19.24;	author paul;	state Exp;
branches;
next	1.33;

1.33
date	93.07.09.13.08.53;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	93.06.15.12.50.53;	author bart;	state Exp;
branches;
next	1.31;

1.31
date	93.04.20.12.57.21;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	93.03.11.17.07.19;	author bart;	state Exp;
branches;
next	1.29;

1.29
date	93.02.04.18.22.32;	author nick;	state Exp;
branches;
next	1.28;

1.28
date	92.12.17.11.15.38;	author nick;	state Exp;
branches;
next	1.27;

1.27
date	92.11.24.17.29.27;	author nick;	state Exp;
branches;
next	1.26;

1.26
date	92.11.20.17.36.22;	author nick;	state Exp;
branches;
next	1.25;

1.25
date	92.11.17.11.44.48;	author paul;	state Exp;
branches;
next	1.24;

1.24
date	92.11.12.14.37.06;	author paul;	state Exp;
branches;
next	1.23;

1.23
date	92.09.04.09.43.25;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	92.07.31.16.18.45;	author paul;	state Exp;
branches;
next	1.21;

1.21
date	92.07.16.10.09.54;	author paul;	state Exp;
branches;
next	1.20;

1.20
date	92.02.26.17.08.35;	author paul;	state Exp;
branches;
next	1.19;

1.19
date	91.12.12.16.08.17;	author paul;	state Exp;
branches;
next	1.18;

1.18
date	91.12.12.16.06.22;	author paul;	state Exp;
branches;
next	1.17;

1.17
date	91.10.14.09.19.53;	author paul;	state Exp;
branches;
next	1.16;

1.16
date	91.06.17.12.54.54;	author bart;	state Exp;
branches;
next	1.15;

1.15
date	91.05.15.15.44.29;	author bart;	state Exp;
branches;
next	1.14;

1.14
date	91.03.25.16.44.00;	author paul;	state Exp;
branches;
next	1.13;

1.13
date	91.02.28.11.52.07;	author nick;	state Exp;
branches;
next	1.12;

1.12
date	91.02.28.10.42.59;	author nick;	state Exp;
branches;
next	1.11;

1.11
date	91.02.07.17.38.48;	author nick;	state Exp;
branches;
next	1.10;

1.10
date	91.02.07.17.23.00;	author nick;	state Exp;
branches;
next	1.9;

1.9
date	91.01.04.12.38.54;	author nick;	state Exp;
branches;
next	1.8;

1.8
date	90.12.07.17.01.45;	author nick;	state Exp;
branches;
next	1.7;

1.7
date	90.11.16.14.00.08;	author nick;	state Exp;
branches;
next	1.6;

1.6
date	90.11.02.16.27.25;	author paul;	state Exp;
branches;
next	1.5;

1.5
date	90.11.01.16.41.39;	author nick;	state Exp;
branches;
next	1.4;

1.4
date	90.09.25.18.15.34;	author paul;	state Exp;
branches;
next	1.3;

1.3
date	90.09.05.18.20.02;	author nick;	state Exp;
branches;
next	1.2;

1.2
date	90.09.05.13.06.43;	author nick;	state Exp;
branches;
next	1.1;

1.1
date	90.08.28.13.05.24;	author nick;	state Exp;
branches;
next	;


desc
@Program loader and shared code manager
@


1.37
log
@Now that the server library is compiled with stack checking and
with a vector stack, the transputer stack size for various threads
has had to be upped from 1200 to 1250 bytes.
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--                     H E L I O S   N U C L E U S                      --
--                     ---------------------------                      --
--                                                                      --
--             Copyright (C) 1987, Perihelion Software Ltd.             --
--                        All Rights Reserved.                          --
--                                                                      --
-- loader.c								--
--                                                                      --
--	Server to manage all loaded code and libraries.			--
--                                                                      --
--	Author:  NHG 16/8/87						--
--                                                                      --
------------------------------------------------------------------------*/
/* $Id: loader.c,v 1.36 1993/08/06 12:43:48 bart Exp bart $ */
/* Copyright (C) 1987, Perihelion Software Ltd.				*/


#include <helios.h>	/* standard header */

#define __in_loader 1	/* flag that we are in this module */

#define TIMEOUTS 0

#define SEARCHCODE	0

#ifdef __C40
#define	READBUFFER	1
#else
#define	READBUFFER	0
#endif

	/* BLV - option to check all loaded code every ten seconds */
#define CONTINUOUS_CHECKING 0

/* #define debug(x)	if( MyTask->Flags & (Task_Flags_servlib)) IOdebug x */
#define debug(x)	/* IOdebug("%s: %",mcname);IOdebug x */

/*--------------------------------------------------------
-- 		     Include Files			--
--------------------------------------------------------*/

#include <string.h>
#include <codes.h>
#include <config.h>
#include <module.h>
#include <syslib.h>
#include <servlib.h>
#include <root.h>
#include <link.h>
#include <process.h>
#include <task.h>
#ifdef __TRAN
#include <asm.h>
#endif

/*----------------------------------------------------------------
--	Stack Handling						--
----------------------------------------------------------------*/

#if defined(__TRAN) && !defined(SYSDEB)
	/* Transputer Helios does not have automatic stack extension.	*/
	/* Please do not change these sizes. Some bits of the loader,	*/
	/* particularly the resident library stuff, involves recursion.	*/
#  define bigstack 3000
#  define defstack 1250
#else
#if defined(STACKEXTENSION)
	/* Some processors have automatic stack extension support.	*/
	/* N.B. stack checking must be used !!!				*/
	/* The sizes are a compromise between memory efficiency and	*/
	/* excessive stack extension with the fragmentation that would	*/
	/* result. N.B. stack sizes passed to the server library must	*/
	/* allow for a servinfo structure, 536 bytes plus a jump buffer,*/
	/* which will be held on the stack. NewProcess() should handle	*/
	/* the jump buffer extra.					*/
#define bigstack	1000
#define defstack	1000

#ifndef STACKCHECK
#error Stack checking must be enabled when compiling this module.
#endif

#else
	/* These sizes should be used on the transputer when debugging	*/
	/* is enabled, on any processor without automatic stack		*/
	/* extension, or when porting to a new processor.		*/
#  define bigstack 4000
#  define defstack 2000
# endif
#endif

#ifdef STACKCHECK
	/* Stack checking within the Loader is controlled		*/
	/* by -DSTACKCHECK on the command line, not by -ps1 or similar	*/
	/* pragmas. On the transputer the stack overflow routine is	*/
	/* part of the C library, not part of the kernel, so the	*/
	/* Loader must supply its own routine.				*/
#ifdef __TRAN
extern void _Trace(...);
#    pragma -s1

static void _stack_error(Proc *p)
{
	_Trace(0xaaaaaaaa,p);
	IOdebug("Loader stack overflow in %s at %x",p->Name,&p);	
}
#endif

	/* Enable stack checking if -DSTACKCHECK			*/
#    pragma -s0

#else

	/* Otherwise disable stack checking.				*/
# pragma -s1

#endif

/*--------------------------------------------------------
--		Private Data Definitions 		--
--------------------------------------------------------*/

typedef struct Image  {
	ObjNode		ObjNode;	/* node for directory struct	*/
#define UseCount 	ObjNode.Account	/* number of users		*/
	word		Retain;		/* true if to remain loaded despite no users */
	word		Closing;	/* true if being closed		*/
	MPtr		Image;		/* pointer to actual code	*/
	Carrier		*ImageCarrier;	/* Carrier for code		*/
	Object		*Object;	/* Object for image source	*/
	word		Flags;		/* image header flag word	*/
	word		CheckSum;	/* image checksum		*/
	Buffer		Buf;		/* structure for DoRead		*/
	ImageHdr	Hdr;		/* image header			*/
} Image;

char		mcname[100];

word		*CodePoolType = NULL;	/* Type of pools for code	*/

DirNode		Root;			/* root of loader directory	*/

Pool		CodePool;		/* Memory pool for loader code */

Object		*LibDir = NULL;		/* library directory		*/

NameInfo	LoaderInfo =
		{
			NullPort,
			Flags_StripName,
			DefNameMatrix,
			(word *)NULL
		};

#if CONTINUOUS_CHECKING
static void checker_process(void);
#endif

#ifdef SYSDEB
#define CheckLock(p,x)\
if( TestSemaphore(&((DirNode *)(x))->Lock) > 0 ) IOdebug("%s: %s: %s not locked",mcname,p,((DirNode *)(x))->Name);
# if 0
#define WaitObj(o) WaitLock(&(o)->Lock,(o)->Name)
void WaitLock(Semaphore *s,char *name)
{
	int i;
	for( i = 0; i < 10; i++ ) 
	{
		if( TestWait(s) ) return;
		Delay(OneSec/100);
	}
	while( !TestWait(s) )
	{
		IOdebug("%s: Loader %s locked",mcname,name);
		Delay(OneSec*2);
	}
}
# else
#  define WaitLock(s,n) Wait(s)
#  define WaitObj(o) Wait(&(o)->Lock)
# endif
# define SEMDBG 0
#else
#define CheckLock(p,x)
#define WaitLock(s,n) Wait(s)
#define WaitObj(o) Wait(&(o)->Lock)
# define SEMDBG 0
#endif

# if !SEMDBG
#define InitSemDbg()
#define NameSem(s,n)
# endif

static void do_open(ServInfo *);
static void do_create(ServInfo *);
static void do_delete(ServInfo *);
static void do_link(ServInfo *);
static void do_closeobj(ServInfo *);

/* private protocol functions */
#if SEARCHCODE
static bool do_search(ServInfo *servinfo);
#endif
static bool do_private(ServInfo *);
	bool RomCreate(ServInfo *);

static DispatchInfo LoaderDInfo = {
	&Root,
	NullPort,
	SS_Loader,
	NULL,
	{ (VoidFnPtr)do_private,bigstack },
	{
		{ do_open,	bigstack },
		{ do_create,	bigstack },
		{ DoLocate,	0	 },
		{ DoObjInfo,	0	 },
		{ NullFn,       0	 },
		{ do_delete,	defstack },
		{ DoRename,	0	 },
		{ do_link,	defstack },
		{ DoProtect,	0	 },
		{ DoSetDate,	0	 },
		{ DoRefine,	0	 },
		{ do_closeobj,	defstack },
		{ DoRevoke,	0	 },
		{ InvalidFn,	0	 },
		{ InvalidFn,	0	 }
	}
};

Image *NewImage(DirNode *, Carrier *, string, word, word, Matrix, word size);
word bindfn(Image *i);
word progsize(MPtr);
word checksum(MPtr, word size);
void check(Image *);
Image *makelink(DirNode *d, string lname, string name, Capability *cap);
Carrier *LoadImage(string name, Capability *cap, word pos, int bindp,
				Object **objp, word *size);
Carrier *LoadObject(Object *obj, word pos, bool bindp, word *size);
Image *LoadLibrary(string name);
Carrier *AllocCode(word size);
void FreeCode(Carrier *code);
word BindLibraries(MPtr image, bool readonly);
void UnbindLibraries(MPtr image);
Carrier *ReadStream(Stream *s, word *size);
void ReadImage(MCB *, Image *);
void WriteImage(MCB *, Image *);
word LoadCache(Image *i);
Buffer *ImageReadBuffer(word pos, Image *i);
#if SEARCHCODE
Image *SearchLoad(char *name);
#endif
void DestroyImage(Image *i);
bool AllocSMT(MPtr image);

Capability fplibcap = { 0xff, { 0, 0, 0, 0, 0, 0, 0 } };
Capability posixcap = { 0xff, { 0, 0, 0, 0, 0, 0, 0 } };
Capability clibcap  = { 0xff, { 0, 0, 0, 0, 0, 0, 0 } };

#if SEARCHCODE
Semaphore SearchLock;
Semaphore SearchTabLock;
#endif

#define MagicKey 0x87654321;

#define READSIZE	(16*1024)	/* size for data reads	*/
#define MINREADSIZE	(4*1024)	/* minimum buffer size	*/

/*--------------------------------------------------------
-- main							--
--							--
-- Entry point of loader				--
--							--
--------------------------------------------------------*/

int main()
{
	/* for romable Helios */
	MPtr ivec = GetSysBase();	/* from root.h */

	Image *i;
	MPtr m;
	Object *nte;
	word j;

	InitSemDbg();

#if SEARCHCODE
	InitSemaphore(&SearchLock,1); 
	NameSem(&SearchLock,"SearchLock");

	InitSemaphore(&SearchTabLock,1); 
	NameSem(&SearchTabLock,"SearchTabLock");
#endif
	
	/* as this is set before Dispatch(), incoming requests will be */
	/* handled at this priority */
	SetPriority(HighServerPri);

	InitPool(&CodePool);
#ifdef __ARM
	EnterSVCMode();		/* Writing to root struct, so enter SVC mode. */
#endif
	GetRoot()->LoaderPool = &CodePool;
#ifdef __ARM
	EnterUserMode();	/* Finished writing to root struct. */
#endif
	InitNode( (ObjNode *)&Root, "loader", Type_Directory, 0, DefRootMatrix );
	InitList( &(Root.Entries) );
	Root.Nentries = 0;
	Root.Key = MagicKey;
	NameSem(&Root.Lock,"RootLock");
	LoaderDInfo.ReqPort = LoaderInfo.Port = NewPort();

	/* .. of root is a link to our machine root	*/
	{
		Object *o;
		LinkNode *Parent;

		MachineName(mcname);
		o = Locate(NULL,mcname);

		Parent = (LinkNode *)Malloc(sizeof(LinkNode) + (word)strlen(mcname));	
		InitNode( &Parent->ObjNode, "..", Type_Link, 0, DefLinkMatrix );
		NameSem(&Parent->ObjNode.Lock,"Parent");
		Parent->Cap = o->Access;
		strcpy(Parent->Link,mcname);
		Root.Parent = (DirNode *)Parent;

		nte = Create(o,"loader",Type_Name,sizeof(NameInfo),
			(byte *)&LoaderInfo);

		Close(o);
	}

	WaitLock(&Root.Lock,"Root,Lock");

	/* scan image vector and install all recognisable modules */
	for( j = 1; MWord_(ivec,j*sizeof(MPtr)) != 0; j++ )
	{
		word type;
		MPtr mm = MInc_(ivec,j*sizeof(MPtr));
		Carrier *c;
		char name[32];
	        m = MRTOA_(mm);

	        switch ( ModuleWord_(m,Type) )
	        {
	        case T_Module:  type = Type_Module;  break;
	        case T_Program: type = Type_Program; break;
	        case T_Device:  type = Type_Device;  break;
	        case T_DevInfo:	type = Type_File;    break;
	        default: continue;
	        }

		ModuleName_(name,m);

		/* @@@@@@ note that any programs included in the nucleus */
		/* will have slightly erroneous sizes displayed by the */
		/* loader as any code stubs generated by the linker will */
		/* not be counted by procsize. */

		c = (Carrier *)AllocMem(sizeof(Carrier),&CodePool);
		c->Addr = m;
		c->Size = progsize(m)/sizeof(word);
		c->Type = 0;

		i = NewImage(&Root,c,name,type,0,-1, 0);

		if( type == Type_Program ) i->UseCount=1;
		i->Retain = true;
		i->ObjNode.Matrix &= ~(0x40404040);
	}


	/* use BindLibraries to set use counts */
	WalkList(&Root.Entries,bindfn);

	Signal(&Root.Lock);

	/* reply to procman that we have started */
	{
		MCB m;
		word e;
		InitMCB(&m,0,MyTask->Parent,NullPort,0x456);
		e = PutMsg(&m);
	}

#if CONTINUOUS_CHECKING
	Fork(2000, &checker_processor, 0);
#endif

#ifdef __C40
	/* The following is a rather grubby way of deciding whether	*/
	/* the loader should try to put the code in the global bus.	*/
	/* If ivec, which is the start of the Nucleus, is C addressable	*/
	/* then we put the code into the default memory area, otherwise	*/
	/* we put it in global memory.					*/

	if( C40CAddress(ivec) == 0 )
	{
		CodePoolType    = (word *)Malloc(sizeof(word)*4);
		CodePoolType[0] = RAMType_Indirect|RAMType_Global|RAMType_Dynamic;
		CodePoolType[1] = RAMType_Indirect|RAMType_Global|RAMType_Static;
		CodePoolType[2] = RAMType_Indirect|RAMType_Local|RAMType_Dynamic;
		CodePoolType[3] = 0;
		
	}
#endif


	Dispatch(&LoaderDInfo);

	Delete(nte,NULL);

	Close(nte);
}

word bindfn(Image *i)
{
	BindLibraries(i->Image,TRUE);
	return 0;
}

/*--------------------------------------------------------
-- BLV, a thread which checks every piece of loaded	--
-- code at regular intervals.				--
--------------------------------------------------------*/

#if CONTINUOUS_CHECKING
static void checker_process()
{ ObjNode *f;

  forever
   { Delay(10 * OneSec);
     Wait(&Root.Lock);
     for (f = Head_(ObjNode, Root.Entries); 
     	  !EndOfList_(f);
     	  f = Next_(ObjNode, f) )
      check((Image *) f);
     Signal(&Root.Lock);
   }
}
#endif

/*--------------------------------------------------------
-- NewImage						--
--							--
-- Add an image entry to the directory			--
--							--
--------------------------------------------------------*/

Image *NewImage(DirNode *dir, Carrier *image, string name, word type, word flags,
	Matrix matrix, word size)
{
	Image *i = New(Image);
debug(("NewImage %s i %x[%x] s %d",name,image,image->Addr,size));
	if( i == Null(Image) ) return Null(Image);

	matrix &= (type==Type_Module)?DefModuleMatrix:DefProgMatrix;

	InitNode(&i->ObjNode,name,(int)type,(int)flags,matrix);
	NameSem(&i->ObjNode.Lock,i->ObjNode.Name);
	i->ObjNode.Key = MagicKey;
	
	i->UseCount 	  = 0;
	i->Retain 	  = false;
	i->Closing 	  = false;
	i->ImageCarrier   = image;
	i->Image	  = image->Addr;
	
	/* if we have no image header, work out the size by hand */
	i->ObjNode.Size = (size == 0) ? progsize(i->Image) : size;
	i->ObjNode.Size += sizeof(ImageHdr);

	i->Flags = 0;
	i->CheckSum = checksum(i->Image, i->ObjNode.Size - sizeof(ImageHdr));	
	i->Object = NULL;
	
	Insert( dir, &i->ObjNode, TRUE );

	return i;
}

word progsize(MPtr m)
{
	word size = 0;

	while( MWord_(m,0) != 0 )
	{
		size += ModuleWord_(m,Size);
		m = ModuleNext_(m);
	}

	return size + 4;
}

word checksum(MPtr p, word size)
{
	word csum = 0;
	word i;
#ifdef __TRAN
	word *pp = (word *)p;
	for( i = 0 ; i < size/sizeof(word) ; i++ ) csum = sum_(csum,*pp++);
#else
	for( i = 0 ; i < size ; i+=4 )
		csum = (word)((unsigned long)csum + (unsigned long)MWord_(p,i));
#endif
	return csum;
}

void check(Image *i)
{
/* return; */
	if( i->ObjNode.Type == Type_CacheName ) return;
	if( i->CheckSum != checksum(i->Image, i->ObjNode.Size - sizeof(ImageHdr)) )
	{
		IOdebug("WARNING: Corruption of %s detected in %s",i->ObjNode.Name,mcname);
		i->Retain = false;
	}
}	

Image *makelink(DirNode *d, string lname, string name, Capability *cap)
{
	Image *i;
	Object *o;

	o = NewObject(name,cap);

	if( o == NULL ) return NULL;
		
	i = New(Image);

	if( i == NULL ) { Close(o); return NULL; }
	
	memset(i,0,sizeof(Image));
	
	InitNode(&i->ObjNode,lname,Type_CacheName,0,DefProgMatrix);
	NameSem(&i->ObjNode.Lock,i->ObjNode.Name);	
	i->ObjNode.Key = MagicKey;
	
	i->Object = o;

	Insert( d, &i->ObjNode, TRUE );

	return i;
}

static int strlcmp(char *s1, char *s2)
{
	forever
	{
		char c1 = *s1;
		char c2 = *s2;
		if( 'A' <= c1 && c1 <= 'Z' ) c1 += ('a'-'A');
		if( 'A' <= c2 && c2 <= 'Z' ) c2 += ('a'-'A');		
		if( c1 != c2 ) return c1-c2;
		if( c1 == 0 ) return 0;
		s1++,s2++;
	}
}

static bool FindImage(Image *i, char *name )
{
#if 1
	char *oname = objname(name);
	return (strlcmp(oname,i->ObjNode.Name)==0);
#else
	int nlen;
	char *oname;
	int olen;

	/* if there is no Object, compare last item with node name */
	
	if( i->Object != NULL ) oname = i->Object->Name;
	else return strcmp(i->ObjNode.Name,objname(name))==0;

	nlen = strlen(name);
	olen = strlen(oname);
	
	/* one string is a complete substring of the other, then we	*/
	/* assume they reference the same object.			*/
	
	while( olen && nlen )
		if( oname[olen--] != name[nlen--] ) return false;
		
	return true;
#endif
}

Image *LookupImage( char *name )
{
	return (Image *)SearchList(&Root.Entries,FindImage,name);
}

extern ObjNode *GetTargetObj1(ServInfo *servinfo)
{
	DirNode *d = (DirNode *)servinfo->Target;
	ObjNode *o = Null(ObjNode);
	MCB *m = servinfo->m;
	IOCCommon *req = (IOCCommon *)(m->Control);
	byte *data = m->Data;
	word next = req->Next;
	word len = 0;
	char name[NameMax];
	char *pathname = servinfo->Pathname;

	/* If the context is the target we have artificially stepped	*/
	/* back to its parent. Step back down here, except if the	*/
	/* context is the root, when we have not stepped back.		*/
	if( next == -1 || data[next] == '\0' )
	{
		/* if target is root then context == target here */
		if( servinfo->Context == (DirNode *)servinfo->Target ) 
		{ LockTarget(servinfo); o = servinfo->Target; goto found; }

		/* else step on down to context */
		WaitObj(servinfo->Context);

		o = servinfo->Target = (ObjNode *)servinfo->Context;
		goto found;
	}

	if( (len = splitname(name, c_dirchar, &data[next] )) == 0 )
	{
		m->MsgHdr.FnRc |= EC_Error+EG_Name;
		return NULL;
	}

	/* special case . and .. */
	if( name[0] == '.' && name[1] == '\0' )
	{
		req->Next = next+len;		
		return (ObjNode *)d;
	}
	elif( name[0] == '.' && name[1] == '.' && name[2] == '\0') 
	{
		int l = strlen(pathname);
		while( pathname[l--] != c_dirchar );
		pathname[l+1] = '\0';
		o = (ObjNode *)(d->Parent);
		servinfo->Target = (ObjNode *)o;
		WaitObj(o);
		req->Access.Access = UpdMask(req->Access.Access,o->Matrix);
		goto found;
	}
	else 
	{
		o = (ObjNode *)Lookup( d, name, TRUE );
		pathcat(pathname, name );
	}

	if( o == NULL )
	{
		/* if the required object is not found, we keep its	*/
		/* parent dir locked and set as the target.		*/
		m->MsgHdr.FnRc |= EC_Error+EG_Name;
		return NULL;
	}

	req->Access.Access = UpdMask(req->Access.Access,o->Matrix);

	/* lock o and set as target */
	WaitObj( o );
	servinfo->Target = o;

	/* This is general code for all above variations. We come here	*/
	/* with o locked.						*/
found:
	req->Next = next+len;
	
	return servinfo->Target = o;
}

/*--------------------------------------------------------
-- Action Procedures					--
--							--
--------------------------------------------------------*/

static void do_open(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	MsgBuf *r;
	Image *i;
	DirNode *d;
	IOCMsg2 *req = (IOCMsg2 *)(m->Control);
	Port reqport;
	byte *data;
	word mode = req->Arg.Mode;
	string pathname = servinfo->Pathname;
	word e;

	r = New(MsgBuf);

	if( r == Null(MsgBuf) )
	{
		ErrorMsg(m,EC_Error+EG_NoMemory);
		return;
	}

	d = GetTargetDir(servinfo);

	if( d == Null(DirNode) )
	{
		ErrorMsg(m,Err_Null);
		return;
	}
		
	i = (Image *)GetTargetObj1(servinfo);

	if( i == Null(Image) )
	{
		ErrorMsg(m,Err_Null);
		Free(r);
		return;
	}

	CheckLock("do_open",&Root);
	CheckLock("do_open",i);
	
	/* here we have i locked */		

	unless( CheckMask(req->Common.Access.Access,(AccMask)(req->Arg.Mode & Flags_Mode)) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Program);
		return;
	}


	if( i->ObjNode.Type == Type_Directory )
	{
		/* the only directory we have is the root, hence must not*/
		/* unlock it here					 */
		reqport = NewPort();
		FormOpenReply(r,m,&i->ObjNode,Flags_Closeable, pathname);
		r->mcb.MsgHdr.Reply = reqport;
		PutMsg(&r->mcb);
		Free((void *)r);
		DirServer(servinfo,m,reqport);
		FreePort(reqport);
		return;
	}
	elif( i->ObjNode.Type == Type_CacheName )
	{
		word r;

		/* We must do this with the root locked since we may	*/
		/* need to load some more libraries & do not want to	*/
		/* clash with other loads.				*/

		r = LoadCache(i);

		Signal(&Root.Lock);
		
		if( !r )
		{
			ErrorMsg(m,EC_Error+EG_Create+EO_Program);
			return;
		}
	}
	else Signal(&Root.Lock);

	switch( req->Arg.Mode & Flags_Mode )
	{
	case O_Execute:
		FormOpenReply(r,m,&i->ObjNode,Flags_Closeable,pathname);
		MarshalWord(&r->mcb,(word)i->Image);
		i->UseCount++;
		e = PutMsg(&r->mcb);
		Free((void *)r);
		return;

	case O_ReadOnly:
	case O_Create|O_WriteOnly:
		reqport = NewPort();
		FormOpenReply(r,m,&i->ObjNode,Flags_Closeable,pathname);
		r->mcb.MsgHdr.Reply = reqport;
		i->UseCount++;
		PutMsg(&r->mcb);
		Free((void *)r);
		break;


	default:
		ErrorMsg(m,EC_Error+EG_WrongFn);
		Free((void *)r);
		return;
	}

	/* Here we are reading the module/program, possibly for	*/
	/* shipment to another processor. This file may only be	*/
	/* read serially, and it is prepended by an image header*/
	/* to allow it to be read in by another loader.		*/
	
	data = m->Data;

	UnLockTarget(servinfo);
	
	forever
	{
		m->MsgHdr.Dest = reqport;
		m->Timeout = StreamTimeout;
		m->Data = data;

		e = GetMsg(m);
#if TIMEOUTS
		if( e == EK_Timeout ) break;
#endif
		if( e < Err_Null ) continue;

		WaitObj( &i->ObjNode );

		i->ObjNode.Dates.Access = GetDate();

		switch( m->MsgHdr.FnRc & FG_Mask )
		{
		case FG_Read:
			if( mode != O_ReadOnly ) goto moderror;
			ReadImage(m,i);
			break;
#if 0		
		case FG_Write:
			if( mode != O_WriteOnly ) goto moderror;
			WriteImage(m,i);
			break;
		
#endif		
		case FG_Close:
			if( m->MsgHdr.Reply != NULL ) ErrorMsg(m,Err_Null);
			FreePort(reqport);
			i->UseCount--;
			Signal( &i->ObjNode.Lock );
			return;

		case FG_GetSize:
		{
			InitMCB(m,0,m->MsgHdr.Reply,NullPort,Err_Null);
			MarshalWord(m,i->ObjNode.Size);
			PutMsg(m);
			break;
		}

		case FG_Seek:
		case FG_SetSize:
			ErrorMsg(m,EC_Error+EG_WrongFn+EO_Module);
			break;
		default:
		moderror:
			ErrorMsg(m,EC_Error+EG_FnCode+EO_Module);
			break;
		}
		Signal( &i->ObjNode.Lock );
	}
}

static void do_create(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	MsgBuf *r;
	DirNode *d;
	Image *i;
	MPtr p;
	Carrier *c;
	IOCCreate *req = (IOCCreate *)(m->Control);
	LoadInfo *info = (LoadInfo *)&(m->Data[req->Info]);
	string name;
	char *pathname = servinfo->Pathname;

	d = (DirNode *)GetTarget(servinfo);

	if( d != &Root )
	{
		ErrorMsg(m,EO_Program);
		return;
	}

	/* here we have d (==Root) locked */

	CheckLock("do_create",&Root);

	unless( CheckMask(req->Common.Access.Access,AccMask_W) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Directory);
		return;
	}

	name = objname( info->Name );

	i = (Image *)LookupImage( info->Name );

	if( i != NULL ) 
	{
		/* lock both object and root to avoid clashes	*/
		
		WaitObj( &i->ObjNode );
		if( i->ObjNode.Type == Type_CacheName )
		{
			word r;
			
			r = LoadCache(i);
			
			if( !r )
			{
				ErrorMsg(m,EC_Error+EG_Create+EO_Program);
				Signal(&i->ObjNode.Lock);
				return;
			}
		}

		check(i);
		
		p = i->Image;
		Signal(&i->ObjNode.Lock);
	}
	else
	{
		Object *o = NULL;
		word type;
		word size;

#if SEARCHCODE		
		i = SearchLoad(objname(info->Name));
		if( i != NULL )
		{
			p = i->Image;
			goto gotimage;
		}
#endif		
		c = LoadImage(info->Name, &info->Cap, info->Pos, true, &o,
			&size);

		if( c == NULL ) 
		{
			ErrorMsg(m,EC_Error+EG_Create+EO_Program);
			if (o != NULL) Close(o);
			return;
		}
		p = (MPtr)c->Addr;

		switch( ModuleWord_(p,Type) )
		{
		case T_Module	: type = Type_Module; break;
		case T_Program	: type = Type_Program; break;
		case T_Device	: type = Type_Device; break;
		default:
			ErrorMsg(m,EC_Error+EG_Invalid+EO_Program);
			FreeCode(c);
			return;
		}
		i = NewImage(d,c,name,type,0,info->Matrix, size);
		i->Object = o;
	}
	
#if SEARCHCODE
gotimage:
#endif
	pathcat( pathname, name );

	if( i == Null(Image) )
	{
		ErrorMsg(m,EC_Error+EG_Create+EO_Program);
		return;
	}

	r = New(MsgBuf);

	if( r == Null(MsgBuf) )
	{
		ErrorMsg(m,EC_Error+EG_NoMemory);
		return;
	}

	/* give creator full rights */
	req->Common.Access.Access = AccMask_Full;
	
	FormOpenReply(r,m,&i->ObjNode, 0, pathname);

	PutMsg(&r->mcb);

	i->ObjNode.Dates.Access = GetDate();

	Free(r);
}

static void do_delete(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	IOCCommon *req = (IOCCommon *)(m->Control);
	Image *i;
	

	i = (Image *)GetTarget(servinfo);
	
	if( i == NULL )
	{
		ErrorMsg(m,EO_Module);
		return;
	}
	
	unless( CheckMask(req->Access.Access,AccMask_D) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Module);
		return;
	}

	if( i->ObjNode.Type == Type_Directory )
	{
		ErrorMsg(m,EC_Error+EG_Delete);
		return;
	}

	i->Retain = false;

	/* Reply to user now, so rest is done in parallel		*/
	
	ErrorMsg(m,Err_Null);

	check(i);
	
	servinfo->TargetLocked = false;
	
	DestroyImage(i);		
}

static void do_link(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	IOCMsg3 *req = (IOCMsg3 *)(m->Control);
	byte *data = m->Data;
	DirNode *d;
	ObjNode *o;
	Image *i;
	char *pathname = servinfo->Pathname;

	
	d = GetTargetDir(servinfo);

	if( d == Null(DirNode) )
	{
		ErrorMsg(m,EO_Directory);
		return;
	}

	unless( CheckMask(req->Common.Access.Access,AccMask_W) ) 
	{
		ErrorMsg(m,EC_Error+EG_Protected+EO_Directory);
		return;
	}

	o = (ObjNode *)GetTargetObj(servinfo);

	if( o != NULL )
	{
		if( o->Type == Type_CacheName )
		{
			ErrorMsg(m,EC_Error+EG_Create);
			return;
		}
		else {
			/* If it exists and is not a CacheName, simply make */
			/* sure it stays loaded!!			    */
			/* This only usually happens if we are trying to    */
			/* cache the ln command!!			    */
			((Image *)o)->Retain = true;
			ErrorMsg(m,Err_Null);
			return;
		}
	}
	else m->MsgHdr.FnRc = servinfo->DispatchInfo->SubSys;
	
	/* We now know that there is not an existing entry with the	*/
	/* desired name. Install the link.				*/

	i = makelink(d,objname(pathname),&data[req->Name],&req->Cap);

	if( i == NULL )
	{
		ErrorMsg(m,EC_Error+EG_NoMemory);
		return;
	}

	ErrorMsg(m, Err_Null);	
}

static void do_closeobj(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	Image *i;

	i = (Image *)GetTarget(servinfo);

	if( i == NULL )
	{
		ErrorMsg(m,EC_Error|EO_Program);
		return;
	}
	else ErrorMsg(m,Err_Null);

	check(i);
	
	i->UseCount--;

	servinfo->TargetLocked = false;

	DestroyImage(i);
}

void DestroyImage(Image *i)
{
	if( i->Closing ) goto done;
debug(("DestroyImage %s",i->ObjNode.Name));
	while( i->UseCount == 0 && !i->Retain )
	{

	/* We ensure that we do not delete the object until at least 5	*/
	/* seconds after it was last touched. This avoids the problem	*/
	/* of locating a program in the loader, only to fail on the open*/

		int time = GetDate()-i->ObjNode.Dates.Access;

		i->Closing = true;
		
		if( time < 5 )
		{
			time = 5 - time;
			Signal(&i->ObjNode.Lock);
			Delay(OneSec*time);
			WaitObj( &i->ObjNode );
			i->Closing = false;
			continue;
		}

		/* To avoid deadlocks, we must relinquish the object	*/
		/* lock to get the root, then the object again. After	*/
		/* this we must re-test the conditions on which we have	*/
		/* decided to kill the image.				*/
		
		Signal(&i->ObjNode.Lock);
		WaitLock(&Root.Lock,"Root.Lock");
		WaitObj(&i->ObjNode);
		
		if( i->UseCount > 0 || i->Retain || 
		    (GetDate()-i->ObjNode.Dates.Access) < 5)
		{
			Signal(&Root.Lock);
			i->Closing = false;
			continue;
		}	

		if( i->ObjNode.Type == Type_CacheName )
		{
			Unlink(&i->ObjNode,TRUE);
			Signal(&Root.Lock);
			Close(i->Object);
			Free(i);
			return;
		}

		UnbindLibraries(i->Image);

#ifdef __SMT
		/* If removing resident library, remove its shared code */
		/* pointer table as well. */
		if( ModuleWord_(i->Image,Type) == T_Module ) {
			RootStruct *root = GetRoot();

# ifdef __ARM
			/* Writing to root struct, so enter SVC mode. */
			EnterSVCMode();
# endif
			Wait(&root->cpi_op);
			/* free modules shared code pointer table */
# ifdef __C40
			FreeMem((void*)(C40CAddress(root->cpi[ModuleWord_(i->Image,Id)])));
# else
			FreeMem((void*)(root->cpi[ModuleWord_(i->Image,Id)]));
# endif
			root->cpi[ModuleWord_(i->Image,Id)] = NULL;
			Signal(&root->cpi_op);
# ifdef __ARM
			/* Finished writing to root struct, so re-enter */
			/* user mode. */
			EnterUserMode();
# endif
		}
#endif

		FreeCode(i->ImageCarrier);
		Unlink(&i->ObjNode,TRUE);
		Signal(&Root.Lock);
		Close(i->Object);
		Free(i);
		return;		
	}
done:
	Signal(&i->ObjNode.Lock);
}

/*--------------------------------------------------------
-- ReadImage						--
--							--
-- Process a request to read data from a loaded image.	--
--							--
--------------------------------------------------------*/

void ReadImage(MCB *m, Image *i)
{
	ReadWrite *r = (ReadWrite *)(m->Control);
	word pos = r->Pos;
	word size = r->Size;
	word isize = i->ObjNode.Size;
#if READBUFFER
	char *buffer;
	int readsize;

	for
	(
		readsize = READSIZE, buffer = NULL;
		readsize > MINREADSIZE && buffer == NULL;
		readsize -= MINREADSIZE
	) buffer = (char *)Malloc(readsize);

	if( buffer == NULL ) goto done;

	i->Buf.Data = buffer;
	i->Buf.Max = readsize;
#endif
debug(("ReadImage %s pos %d size %d isize %d",i->ObjNode.Name,pos,size,isize));
	if( pos < 0 || pos > isize )
	{
		ErrorMsg(m,EC_Error+EG_Parameter+1);
		goto done;
	}
	if( pos == isize )
	{
		m->MsgHdr.FnRc = ReadRc_EOF;
		ErrorMsg(m,0);
		goto done;
	}

	if( pos + size > isize ) r->Size = isize - pos;

	DoRead(m,ImageReadBuffer,i);

done:

#if READBUFFER
	if( buffer ) Free(buffer);
#endif
	return;
}

#if READBUFFER
Buffer *ImageReadBuffer(word pos, Image *i)
{
	Buffer *b = &i->Buf;
	word dsize;
debug(("ImageReadBuffer pos %d",pos));	

	if( pos == 0 )
	{
		ImageHdr *h = (ImageHdr *)b->Data;
		b->Pos = 0;
		b->Size = sizeof(ImageHdr);
		h->Magic = Image_Magic;
		h->Flags = i->Flags;
		h->Size = i->ObjNode.Size-sizeof(ImageHdr);
		return b;
	}

	if( pos < sizeof(ImageHdr) || pos >= i->ObjNode.Size ) return NULL;

	dsize = i->ObjNode.Size - pos;
	if( dsize > b->Max ) dsize = b->Max;
debug(("ReadBuffer pos %d dsize %d",pos,dsize));
	b->Pos = pos;
	b->Size = dsize;

	MData_(b->Data,i->Image,pos-sizeof(ImageHdr),dsize);

	return b;
}	
#else
Buffer *ImageReadBuffer(word pos, Image *i)
{
	Buffer *b = &i->Buf;
debug(("ImageReadBuffer pos %d",pos));	
	if( pos == 0 )
	{
		ImageHdr *h = &i->Hdr;
		b->Pos = 0;
		b->Size = b->Max = sizeof(ImageHdr);
		b->Data = (byte *)h;
		h->Magic = Image_Magic;
		h->Flags = i->Flags;
		h->Size = i->ObjNode.Size-sizeof(ImageHdr);
		return b;
	}
	
	if( pos < sizeof(ImageHdr) || pos >= i->ObjNode.Size ) return NULL;

	b->Pos = sizeof(ImageHdr);
	b->Size = b->Max = i->ObjNode.Size - sizeof(ImageHdr);
	b->Data = (char *)i->Image;
	return b;		
}
#endif

#if 0
/*--------------------------------------------------------
-- WriteImage						--
--							--
-- Write an image file into memory. 			--
--							--
--------------------------------------------------------*/

void WriteImage(MCB *m, Image *i)
{
	ReadWrite *r = (ReadWrite *)m->Control;
	word pos = r->Pos;
	word size = r->Size;
	
	if( pos < 0 )
	{
		ErrorMsg(m,EC_Error|EG_Parameter|1);
		return;
	}

	DoWrite(m,ImageWriteBuffer,i);
}

Buffer *ImageWriteBuffer(word pos, Image *i)
{
	Buffer *b = &i->Buf;
	
	if( pos == 0 )
	{
		ImageHdr *h = &i->Hdr;
		b->Pos = 0;
		b->Size = sizeof(ImageHdr);
		b->Max = 4096;
		b->Data = (byte *)h;
		return b;
		
	}
}
#endif
/*--------------------------------------------------------
-- LoadImage						--
--							--
-- Read an image file into memory. 			--
--							--
--------------------------------------------------------*/

Carrier *LoadImage(string name, Capability *cap, word pos, int bindp,
	Object **objp, word *size)
{
	Object *o = NULL;
debug(("LoadImage %s",name));
	CheckLock("LoadImage",&Root);

	o = NewObject(name,cap);
	
	if( o == NULL ) return NULL;

	*objp = o;
	
	return LoadObject(o, pos, bindp, size);
}

Carrier *LoadObject(Object *o, word pos, bool bindp, word *size)
{
	Stream *s;
	Carrier *image = NULL;
debug(("LoadObject %O",o));
	CheckLock("LoadObject",&Root);

	s = Open(o,NULL,O_ReadOnly);

	if( s == NULL ) return NULL;

	/* if necessary, seek to given file posn */
	if( pos != 0 ) Seek(s,S_Beginning,pos);

	if( (image = ReadStream(s, size)) == NULL ) goto done;

#ifdef __SMT
	if( ModuleWord_(image->Addr,Type) == T_Module )
		if( !AllocSMT(image->Addr) )
		{
			FreeCode(image);
			return NULL;
		}
#endif
	
	if( bindp && !BindLibraries((MPtr)image->Addr,FALSE) )
	{
		FreeCode(image);
		image = NULL;
	}

done:
	Close(s);

	return image;
}

Carrier *ReadStream(Stream *s, word *retsize)
{
	ImageHdr hdr;
	Carrier *c = NULL;
	word size;
	char *buffer = NULL;
	word readsize = READSIZE;
#if READBUFFER
	MPtr image;
#endif

debug(("ReadStream %S",s));
#if READBUFFER
	for
	(
		readsize = READSIZE;
		readsize > MINREADSIZE && buffer == NULL;
		readsize -= MINREADSIZE
	) buffer = (char *)Malloc(readsize);

	if( buffer == NULL ) goto done;
#endif
	
	size = Read(s,(byte *)&hdr,sizeof(ImageHdr),-1);

	if( size != sizeof(ImageHdr) || hdr.Magic != Image_Magic ) 
		goto done;

	c = AllocCode(hdr.Size);

	if( c == NULL ) goto done;
	
#if !READBUFFER
	/* If we are not using a read buffer, then the code must be	*/
	/* directly addressable, so the following assignment is OK.	*/
	
	buffer = c->Addr;
#else
	/* Otherwise, get the MPtr so we can copy to it		*/

	image = c->Addr;
#endif

	/* return true size of image to caller */
	*retsize = hdr.Size;

	{
		word got = 0;
		word dsize = readsize - sizeof(hdr);
		while( got != hdr.Size )
		{
			if( dsize > hdr.Size - got ) dsize = (int)hdr.Size - got;
			size = Read(s,buffer,dsize,-1);
			if( size <= 0 ) break;

#if READBUFFER
			SetMData_(image,got,buffer,dsize);
#else
			buffer += dsize;
#endif

			got += dsize;

			/* The first read adjusts us to a READSIZE boundary */
			/* READSIZE should be a multiple of the disc block  */
			/* size (a multiple of 4k should usually be OK)	    */
			dsize = readsize;
		}
		size = got;
	}

	if( size != hdr.Size ) 
	{
debug(("ReadStream failed"));
		FreeCode(c);
		c = NULL;
	}

done:
#if READBUFFER
	if( buffer != NULL ) Free(buffer);
#endif
	return c;
}

/*--------------------------------------------------------
-- AllocCode						--
-- FreeCode						--
--							--
-- Code space management. On some systems the code is	--
-- kept in a seperate pool to the data. This is handled	--
-- here.						--
--							--
--------------------------------------------------------*/

word InitCodeSpace()
{
	return 1;
}

Carrier *AllocCode(word size)
{
	Carrier *image = NULL;

#ifdef __C40
	if( CodePoolType != NULL )
	{
		int i;
		word wsize = (size + sizeof(word)-1)/sizeof(word);
		for( i = 0; CodePoolType[i] != 0; i++ )
		{
			image = AllocSpecial(wsize,CodePoolType[i],&CodePool);
			if( image != NULL ) return image;
		}
	}
	if( image == NULL )
#endif
	{
		void *p = AllocMem(size,&CodePool);
		if( p == NULL ) return NULL;

		image = (Carrier *)AllocMem(sizeof(Carrier),&CodePool);
		if( image == NULL ) { FreeMem(p); return NULL; }

		image->Addr = CtoM_(p);
		image->Size = (size + sizeof(word)-1)/sizeof(word);
		image->Type = 0;

	}

	return image;

}

void FreeCode(Carrier *c)
{
#ifdef __C40
	Memory *mem = (Memory *)(((char *)c)-sizeof(Memory));

	if( mem->Size & Memory_Size_Carrier )
	{
		FreeMem(c);
		return;
	}
#endif

	FreeMem(MtoC_(c->Addr));
	FreeMem(c);
}

/*--------------------------------------------------------
-- BindLibraries					--
--							--
-- Bind any ResRef library references to the named	--
-- library if it exists.				--
--							--
--------------------------------------------------------*/

word BindLibraries(MPtr image, bool readonly)
{
	MPtr	m			= image;
	bool	resident_library	= (ModuleWord_(m,Type) == T_Module);
	
debug(("BindLibraries %x",image));	
	CheckLock("BindLibraries",&Root);

	while( ModuleWord_(m,Type) != 0 )
	{
		if( ModuleWord_(m,Type) == T_ResRef )
		{
			bool loaded = false;
			char name[32];
			Image *i;

			ModuleName_(name,m);

			i = (Image *)Lookup(&Root,name,TRUE);

#if SEARCHCODE			
			if( i == NULL )	i = SearchLoad(name);
#endif
			if( i == NULL ) i = LoadLibrary(name);
			if( i == NULL ) return false;		
			
			WaitObj(&i->ObjNode);
			
			if ( i->ObjNode.Type != Type_CacheName ) loaded = true;
			else loaded = LoadCache(i);

			if( !readonly )
				SetResRefModule_(m,(word)i->Image);

			/* BLV - checking loaded resident libraries when binding	*/
			/* a resident library is expensive. The kernel gets checked	*/
			/* many times for every taskforce component. Instead the check	*/
			/* should only be done for real user programs.			*/
			if (!resident_library)
				check(i);
			
			i->UseCount++;
				
			Signal(&i->ObjNode.Lock);
			if( !loaded ) return false;
		}
		m = ModuleNext_(m);
	}

	return true;
}

void UnbindLibraries(MPtr image)
{
	MPtr	m			= image;
	bool	resident_library	= (ModuleWord_(m,Type) == T_Module);

debug(("UnbindLibraries %x",image));	
	CheckLock("UnbindLibraries",&Root);
	
	while( ModuleWord_(m,Type) != 0 )
	{
		if( ModuleWord_(m,Type) == T_ResRef )
		{
			char name[32];
			Image *i;

			ModuleName_(name,m);

			i = (Image *)Lookup(&Root,name,TRUE);
			
			WaitObj(&i->ObjNode);

			i->UseCount--;

			/* BLV - UnbindLibraries is recursive and can lead to a	*/
			/* the kernel and syslib being checked many times. This	*/
			/* test avoids some of the overheads.			*/
			if (!resident_library)			
				check(i);

			if( i->UseCount == 0 && !i->Retain )
			{
#ifdef __SMT
				RootStruct *root = GetRoot();

# ifdef __ARM
				/* Writing to root struct, so enter SVC mode. */
				EnterSVCMode();
# endif
				Wait(&root->cpi_op);
				/* free modules shared code pointer table */
# ifdef __C40
				FreeMem((void*)(C40CAddress(root->cpi[ModuleWord_(m,Id)])));
# else
				FreeMem((void*)(root->cpi[ModuleWord_(m,Id)]));
# endif
				root->cpi[ModuleWord_(m,Id)] = NULL;
				Signal(&root->cpi_op);
# ifdef __ARM
				/* Finished writing to root struct, so */
				/* re-enter user mode. */
				EnterUserMode();
# endif
#endif
				UnbindLibraries(i->Image);
				FreeCode(i->ImageCarrier);
				Unlink(&i->ObjNode,TRUE);
				Close(i->Object);
				Free(i);		
			}
			Signal(&i->ObjNode.Lock);
			
		}
		m = ModuleNext_(m);
	}
}

#ifdef __SMT
#define CPISLOTINC	32	/* minimum granularity of CPI size increases */

/* Enlarge the size of the shared code pointer table index */
bool EnlargeCPI(int maxid)
{
	RootStruct *root = GetRoot();
	word newsize = (word)maxid + CPISLOTINC;
	word *newCPI = (word *)AllocMem(newsize * sizeof(word), &root->SysPool);

#ifdef SYSDEB
	IOdebug("Enlarging SMT Code Pointer Index table (%x->%x)",root->cpislots,newsize);
#endif
	if(newCPI == NULL)
		return FALSE;

#ifndef __TRAN
	/* Tran alloc automatically zeros memory */
	{
		word *newslotp = newCPI + root->cpislots;
		word i;

		for(i = newsize - root->cpislots; i > 0; i--)
			newslotp[i-1] = NULL;
	}
#endif

	/* root->cpi_op semaphore is assumed to be in use! */
	memcpy((void *)newCPI, (void *)(root->cpi), (int)root->cpislots * sizeof(word));
	FreeMem((void *)(root->cpi));

	root->cpislots = newsize;
	root->cpi = newCPI;

	return TRUE;
}

bool AllocSMT(MPtr image)
{
	RootStruct *root = GetRoot();
	word id = ModuleWord_(image,Id);

#ifdef __ARM
	/* Writing to root struct, so enter SVC mode. */
	EnterSVCMode();
#endif

	Wait(&root->cpi_op);

	if(id >= root->cpislots)
		if (!EnlargeCPI( (int)id)) {
			Signal(&root->cpi_op);
#ifdef __ARM
			/* Finished writing to root struct, so re-enter user mode. */
			EnterUserMode();
#endif
			return FALSE;
		}

	if (root->cpi[id] != 0)
#ifdef SYSDEB
		IOdebug("SMT error: Duplicate Shared code pointer index (%d, %s)", id, ((Module *)image)->Name);
#else
		IOdebug("ERROR: internal error in loader");
#endif			

#ifdef __C40
	if ((root->cpi[id] = C40WordAddress(AllocMem(ModuleWord_(image,MaxCodeP), &root->SysPool))) == NULL) {
		Signal(&root->cpi_op);
		return FALSE;
	}
#else
	if ((root->cpi[id] = (word)AllocMem(ModuleWord_(image,MaxCodeP), &root->SysPool)) == NULL) {
		Signal(&root->cpi_op);
# ifdef __ARM
		/* Finished writing to root struct, so re-enter user mode. */
		EnterUserMode();
# endif
		return FALSE;
	}
#endif

	/* Note that this shared code pointer table needs initialising */
	root->cpi[id] |= 1;
		
	Signal(&root->cpi_op);

#ifdef __ARM
	/* Finished writing to root struct, so re-enter user mode. */
	EnterUserMode();
#endif
	return TRUE;
}

#endif

Image *LoadLibrary(string name)
{
	Image *i = NULL;
	MPtr image;
	Carrier *c;
	Stream *s;
	Object *o = NULL;
#ifdef __TRAN
	char xname[100];
#endif
	char lname[NameMax];
	bool lcdone = FALSE;
	word size;
debug(("LoadLibrary %s",name));
	CheckLock("LoadLibrary",&Root);

	strcpy(lname,name);
	
	if( LibDir == NULL ) LibDir = Locate(NULL,"/helios/lib");

again:
	if( o == NULL ) o = Locate(LibDir,lname);

#ifdef __TRAN
	if( o == NULL )
	{
		char *suffix;
		int t = MachineType();

		strcpy(xname,lname);

		switch( t )
		{
		case 801:
		case 805:
		case 800: suffix = ".t8"; break;
		default:  IOdebug("Unknown processor type %d, T4 assumed",t);
		case 400:
		case 414:
		case 425: suffix = ".t4"; break;		
		}

		strcat(xname,suffix);

		o = Locate(LibDir,xname);
	}
#endif

	if( o == NULL && !lcdone)
	{
		char *p;
		for( p = lname; *p; p++ )
			if( 'A' <= *p && *p <= 'Z' ) *p = *p - 'A' + 'a';
		lcdone = TRUE;
		goto again;
	}

	if( o == NULL ) return NULL;

	s = Open(o,NULL,O_ReadOnly);
	
	if( s == NULL ) { Close(o); return NULL; }
	
	if( (c = ReadStream(s, &size)) == NULL ) goto done;

	image = (MPtr)c->Addr;
	
#ifdef __SMT
	if( !AllocSMT(image) )
	{
		FreeCode(c);
		return NULL;
	}
#endif
	i = NewImage(&Root, c, name, Type_Module, 0, -1, size);

	WaitObj(&i->ObjNode);
	BindLibraries(image,FALSE);
	
	i->Retain = true;
	i->CheckSum = checksum(image, i->ObjNode.Size - sizeof(ImageHdr));
	i->Object = o;
			
	Signal(&i->ObjNode.Lock);
done:
	Close(s);

	return i;

}

word LoadCache(Image *i)
{
	word type;
	Matrix matrix;
	Carrier *c;
	MPtr p;
	Object *o = i->Object;
	word size;
debug(("LoadCache %s",i->ObjNode.Name));
	CheckLock("LoadCache",i);
	CheckLock("LoadCache",&Root);
	
	c = LoadObject(o, 0, true, &size);

	if( c == NULL ) return false;

	p = (MPtr)c->Addr;
	
	switch( ModuleWord_(p,Type) )
	{
	case T_Module:
		type = Type_Module;
		matrix = DefModuleMatrix;
		break;
	case T_Program:
		type = Type_Program;
		matrix = DefProgMatrix;
		break;
	case T_Device:
		type = Type_Device;
		matrix = DefProgMatrix;
		break;
	default:
		return false;
	}

	i->ObjNode.Type = type;
	i->ObjNode.Matrix = matrix;
	i->UseCount = 0;
	i->Retain = true;
	i->Image = p;
	i->Flags = 0;

	i->ObjNode.Size = size + sizeof(ImageHdr);

	i->CheckSum = checksum(p, size);
	
	return true;
}


static bool do_private(ServInfo *servinfo)
{
	switch (servinfo->FnCode & FG_Mask)
	{
#if SEARCHCODE
		case FG_ServerSearch:
			return (do_search(servinfo));
			break;
#endif
		case FG_RomCreate:
			return (RomCreate(servinfo));
			break;

		default:
			return FALSE;
	}
}

#if SEARCHCODE
word SearchTab[32];
word STPos = 0;

word NewSeq()
{
  extern word _ldtimer( int );
  
	word v = GetDate()+_ldtimer(0);
	WaitLock(&SearchTabLock,"SearchTabLock");
	SearchTab[(STPos++)&0x1f] = v;
	Signal(&SearchTabLock);	
	return v;
}

void MarshalDataWord(MCB *mcb, word w)
{
	MarshalData(mcb,sizeof(word),(byte *)&w);
}

Object *SearchCode1(char *name, word id, word fromlink);

Image *SearchLoad(char *name)
{
	Object *o = NULL;
	Image *i = NULL;
	byte *p = NULL;
	word type;
	word size;

/*IOdebug("%s: SearchLoad %s",mcname,name);*/
	
	o = SearchCode1(name,NewSeq(),-1);

	if( o == NULL ) goto done;

	i = Lookup(&Root,name,TRUE);
if( i ) IOdebug("%s: SearchLoad %s already loaded",mcname,name);	
	if( i != NULL ) 
	{
		Close(o);
		goto done;
	}

	p = LoadObject(o, 0, FALSE, &size);
	
	if( p == NULL ) goto done;

	switch( *(word *)p )
	{
	default:
	case T_Module	: type = Type_Module; break;
	case T_Program	: type = Type_Program; break;
	case T_Device	: type = Type_Device; break;
	}

	i = NewImage(&Root,(void *)p,name,type,0,-1, size);
	i->Object = o;
/*if( i ) IOdebug("%s: SearchLoad got %s from %O",mcname,i->ObjNode.Name,o);*/
	
	WaitObj( &i->ObjNode );
	
	if( !BindLibraries(p,FALSE) )
	{
		Unlink(&i->ObjNode,TRUE);
		FreeMem(p);
		Close(o);
		Free(i);
		i = NULL;
		
	}
	else 
	{
		i->CheckSum = checksum(p, i->ObjNode.Size - sizeof(ImageHdr));
		Signal( &i->ObjNode.Lock );
	}

done:	
	return i;


}

Object *SearchCode1(char *name, word id, word fromlink)
{
	MsgBuf *m;
	Port reply;	
	int i;
	word e = 0;
	Object *o = NULL;
	Capability cap;
	MCB *mcb;
	int nlinks = (int)(GetConfig()->NLinks);
	int nreplies = 0;

	m = New(MsgBuf);
	
	if( m == NULL ) return NULL;

	mcb = &m->mcb;
	mcb->Control = m->control;
	mcb->Data = m->data;
	
	reply = NewPort();
	
	InitMCB(mcb,MsgHdr_Flags_preserve,NullPort,reply,FC_GSP|FG_ServerSearch);
	
	MarshalString(mcb,"/link.X/loader");
	MarshalString(mcb,name);
	MarshalWord(mcb,1);
	NewCap(&cap,(ObjNode *)&Root,AccMask_R);
	MarshalCap(mcb,&cap);
	MarshalWord(mcb,id);
	MarshalWord(mcb,MachineType());

	for( i = 0; i < nlinks; i++ )
	{
		if( i != fromlink )
		{
			static LinkInfo link;
			LinkData(i,&link);
			if( (link.Mode  != Link_Mode_Intelligent) ||
			    (link.State != Link_State_Running)    ||
			    (link.Flags & Link_Flags_stopped) ) continue;
			mcb->Data[6] = '0'+i;
			SendIOC(mcb);
			nreplies++;
		}
	}

	InitMCB(mcb,0,reply,NullPort,0);
	mcb->Timeout = 2*OneSec;

	/* must unlock root while we wait since we will get loop-backs	*/
	/* note that searchlock is kept to serialize all searches	*/
	
	Signal(&Root.Lock);

	for( i = 0; i < nreplies; i++ )
	{
		e = GetMsg(mcb);
		if( e == EK_Timeout ) break;
		if( e > 0 ) break;
	}
	/* Order of waits is important here to avoid deadlock	*/
	WaitLock(&Root.Lock,"Root.Lock");

	FreePort(reply);
	
	if( e >= 0 )
	{
		StrDesc *sd = (StrDesc *)mcb->Data;
		o = NewObject(sd->Name,&sd->Cap);
		o->Flags = sd->Mode;
	}

	Free(m);
	return o;
}

static bool do_search(ServInfo *servinfo)
{
	int i;
	Image *image;
	Capability cap;
	MCB *mcb = servinfo->m;	
	char *pathname = servinfo->Pathname;
	word mode;
	Object *o = NULL;
	word id = mcb->Control[5];
	word type = mcb->Control[6];
	
	WaitLock(&SearchTabLock,"SearchTabLock");
			
	for( i = 0; i < 32 ; i++ ) if( id == SearchTab[i] ) 
	{
		Signal(&SearchTabLock);		
		goto fail;
	}

	SearchTab[(STPos++)&0x1f] = id;
	
	Signal(&SearchTabLock);
	
	image = (Image *)GetTarget(servinfo);

	/* Fail if we know nothing about this image, or if the requester  */
	/* is a different machine type to us, and there is some suspicion */
	/* that this is a machine-dependant library.			  */
	
	if( image == NULL || 
#ifdef __TRAN
		( type/100 != MachineType()/100 &&
#else
		(type != MachineType() &&
#endif
		 strlcmp(objname(image->Object->Name),objname(pathname))!=0)
	  ) 
	{
#if 1
		goto fail;
#else
		PortInfo pi;
		GetPortInfo(mcb->MsgHdr.Reply,&pi);
		o = SearchCode1(objname(servinfo->Pathname),id,pi.Link);
		if( o == NULL ) goto fail;
		pathname = o->Name;
		cap = o->Access;
		mode = o->Flags;	
#endif
	}
#if 1
	else if( image->ObjNode.Type == Type_CacheName )
	{
		/* if this is a cache name, return the referenced object */
		pathname = image->Object->Name;
		cap = image->Object->Access;
		mode = image->Object->Flags;
	}
#endif
	else
	{
		pathname = servinfo->Pathname;
		NewCap(&cap,&image->ObjNode,AccMask_R);
		mode = image->ObjNode.Flags|Flags_Closeable|O_ReadOnly;
	}
	
	InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,0);
	MarshalOffset(mcb);
	MarshalDataWord(mcb,mode);
	MarshalDataWord(mcb,0);
	MarshalData(mcb,sizeof(cap),(byte *)&cap);
	MarshalData(mcb,(word)strlen(pathname)+1,pathname);
	goto done;

fail:
	InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,EC_Error);

done:
	if( o != NULL ) Close(o);	
	PutMsg(mcb);
	return TRUE;
}
#endif	/* SEARCHCODE */

/* Private protocol message */
typedef struct ROMCreate {
	IOCCommon	Common;
	Offset		Name;
	word		Addr;
} ROMCreate;

bool RomCreate(ServInfo *servinfo)
{
	MCB *m = servinfo->m;
	ROMCreate *req = (ROMCreate *)(m->Control);
	Carrier *c;
	MPtr mod;
	Image *i;
	word type;
	MPtr addr = (MPtr)req->Addr;		/* Get image's addr from msg */
	char *name = &(m->Data[req->Name]);	/* Get name from msg */

	/*IOdebug("Loader:Rom Create: %s @@ %x",name,addr);*/

	/* check magic */
	if (MWord_(addr,0) != Image_Magic)
		return FALSE;

	/* get module address here */
	mod = MInc_(addr,sizeof(ImageHdr));

        switch ( ModuleWord_(mod,Type) )
        {
        case T_Module:  type = Type_Module;  break;
        case T_Program: type = Type_Program; break;
        case T_Device:  type = Type_Device;  break;
        case T_DevInfo:	type = Type_File;    break;
        default:	return FALSE;
        }

	c = (Carrier *)AllocMem(sizeof(Carrier),&CodePool);
	c->Addr = mod;
	c->Size = 0;
	
        
	i = NewImage(&Root, c, name, type, 0, -1, 0);
#if 0
	if( type == Type_Program ) i->UseCount=1;
#endif
	i->Retain = true;
	
	return TRUE;
}


/* -- End of loader.c */



@


1.36
log
@Attempting to reduce memory requirements by using smaller stacks etc.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.34 1993/07/26 16:19:24 paul Exp paul $ */
d67 1
a67 1
#  define defstack 1200
@


1.35
log
@fixed problems with ARM merge.
@
text
@d58 63
a209 13
#ifdef __TRAN
# ifdef SYSDEB
#  define bigstack 4000
#  define defstack 2000
# else
#  define bigstack 3000
#  define defstack 1200
# endif
#else
# define bigstack 4000
# define defstack 2000
#endif

d219 3
a221 3
		{ DoLocate,	defstack },
		{ DoObjInfo,	defstack },
		{ NullFn,       defstack },
d223 1
a223 1
		{ DoRename,	defstack },
d225 3
a227 3
		{ DoProtect,	defstack },
		{ DoSetDate,	defstack },
		{ DoRefine,	defstack },
d229 3
a231 3
		{ DoRevoke,	defstack },
		{ InvalidFn,	defstack },
		{ InvalidFn,	defstack }
a272 16

#ifdef __TRAN
#  ifdef STACKCHECK
#    pragma -s1

void _Trace(...);

void _stack_error(Proc *p)
{
_Trace(0xaaaaaaaa,p);
	IOdebug("%s: Loader stack overflow in %s at %x", mcname, p->Name,&p);	
}
#    pragma -s0
#  endif

#endif
@


1.34
log
@merged with ARM changes
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.33 1993/07/09 13:08:53 nickc Exp $ */
d1144 1
a1144 1
#ifdef __C40
d1146 3
a1148 3
#else
			FreeMem((void*)(root->cpi[i->Image.m->Id]));
#endif
a1382 1
	MPtr image;
a1383 1

d1386 3
d1515 1
a1517 1
#ifdef __C40
d1569 1
a1569 1
				SetResRefModule_(m,i->Image);
d1697 1
a1697 1
# ifdef __ARM
d1700 1
a1700 1
# endif
d1707 4
d1742 1
a1742 1
# ifdef __ARM
d1745 1
a1745 1
# endif
@


1.33
log
@fixed conflicts with C++
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.32 1993/06/15 12:50:53 bart Exp nickc $ */
d272 3
d276 3
a278 1

d1138 4
d1151 5
d1622 4
d1628 1
a1628 1
#ifdef __C40
d1630 1
a1630 1
#else
d1632 1
a1632 1
#endif
d1635 5
d1696 5
d1704 2
a1705 1
		if (!EnlargeCPI( (int)id))
d1707 1
d1717 4
a1720 2
	if ((root->cpi[id] = C40WordAddress(AllocMem(ModuleWord_(image,MaxCodeP), &root->SysPool))) == NULL)
			return FALSE;
d1722 8
a1729 2
	if ((root->cpi[id] = (word)AllocMem(ModuleWord_(image,MaxCodeP), &root->SysPool)) == NULL)
			return FALSE;
d1737 4
@


1.32
log
@1) the stack checking options were in a mess. The C40 and ARM versions
   were never actually compiled in.
2) the amount of checksumming was excessive, and was causing stack overflow
   problems. I have eliminated checksumming when binding or unbinding
   resident libraries with other resident libraries.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.31 1993/04/20 12:57:21 nickc Exp $ */
d368 1
a368 1
		CodePoolType = Malloc(sizeof(word)*4);
d1178 1
a1178 1
	) buffer = Malloc(readsize);
d1382 1
a1382 1
	) buffer = Malloc(readsize);
d1485 1
a1485 1
		image = AllocMem(sizeof(Carrier),&CodePool);
d1639 1
a1639 1
	word *newCPI = AllocMem(newsize * sizeof(word), &root->SysPool);
@


1.31
log
@fixed compile time warnings
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.30 1993/03/11 17:07:19 bart Exp nickc $ */
d76 2
a102 1
extern char mcname[];
d233 1
a233 1
	IOdebug("Loader stack overflow in %s at %x",p->Name,&p);	
a235 23

#  elif defined (__ARM) || defined(__C40)

#    ifdef __ARM
#      pragma no_check_stack
#    else
#      pragma -s1
#    endif

static void __stack_overflow(void)
{
	IOdebug("Loader stack overflow!!");
}
static void __stack_overflow_1(void)
{
	IOdebug("Loader stack overflow!");
}

#    ifdef __ARM
#      pragma check_stack
#    else
#      pragma -s0
#    endif
a246 2
char mcname[100];

d1524 3
a1526 1
	MPtr m = image;
d1529 1
a1529 1
	
d1556 6
a1561 1
			check(i);
d1576 3
a1578 1
	MPtr m = image;
d1597 5
a1601 1
			check(i);
d2161 1
@


1.30
log
@1) fixed message port leak. If the loader tried to read an existing
   but invalid file, e.g. a shell script, it was failing to close an
   Object.
2) removed do_ServerInfo() which just called NullFn()
3) compiled out all references to search code, rather than just making
   the search routines return NULL, to reduce nucleus size.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.29 1993/02/04 18:22:32 nick Exp $ */
d279 1
a279 1
	int j;
d491 1
a491 1
	int i;
d943 2
d946 1
d1435 2
a1436 2
		int got = 0;
		int dsize = readsize-sizeof(hdr);
@


1.29
log
@Carriers for nucleus objects contained a Size which was 4 times
too big. Fixed.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.28 1992/12/17 11:15:38 nick Exp nick $ */
a136 1
static void do_serverinfo(ServInfo *);
d140 1
d142 1
d170 1
a170 1
		{ do_serverinfo,defstack },
d203 1
d205 1
d213 1
d216 1
d283 1
d289 1
d907 1
a907 1
		Object *o;
d910 2
a911 1
		
d918 1
a918 1
		
d925 1
a1071 5
static void do_serverinfo(ServInfo *servinfo)
{
	NullFn(servinfo);
}

d1355 1
a1355 1
	
d1561 1
d1563 1
d1858 1
d1862 1
a1862 1

d1872 1
a1895 1
#if SEARCHCODE
d1952 1
a1952 3
#else
	return NULL;
#endif
a1956 1
#if SEARCHCODE
a2029 1
#endif
a2033 1
#if SEARCHCODE
a2113 1
#endif
d2115 1
a2115 1
/*#endif*/
@


1.28
log
@Code tables now initialized for libraries that are loaded explicitly
as well as those that are loaded implicitly.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.27 1992/11/24 17:29:27 nick Exp nick $ */
d348 1
a348 1
		c->Size = progsize(m);
@


1.27
log
@There were problems when the loader ran out of global memory and started
using local memory for code which did not occur when using only one or
the other. Problem was converting the size into a word count.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.26 1992/11/20 17:36:22 nick Exp nick $ */
d204 1
d1361 9
d1669 25
d1696 10
d1774 1
d1776 2
a1777 29
		RootStruct *root = GetRoot();
		word id = ModuleWord_(image,Id);

		Wait(&root->cpi_op);

		if(id >= root->cpislots)
			if (!EnlargeCPI( (int)id))
				goto error;

		if (root->cpi[id] != 0)
#ifdef SYSDEB
			IOdebug("SMT error: Duplicate Shared code pointer index (%d, %s)", id, ((Module *)image)->Name);
#else
			IOdebug("ERROR: internal error in loader");
#endif			

#ifdef __C40
		root->cpi[id] = (root->cpi[id]);
		if ((root->cpi[id] = C40WordAddress(AllocMem(ModuleWord_(image,MaxCodeP), &root->SysPool))) == NULL)
			goto error;
#else
		if ((root->cpi[id] = (word)AllocMem(ModuleWord_(image,MaxCodeP), &root->SysPool)) == NULL)
			goto error;
#endif

		/* Note that this shared code pointer table needs initialising */
		root->cpi[id] |= 1;
		
		Signal(&root->cpi_op);
a1794 5
#ifdef __SMT
error:
	FreeCode(c);
	return NULL;
#endif
@


1.26
log
@Now uses MPtr's to access all code. Every piece of code now has
a carrier, which allows the code to be in a different memory pool
from normal.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.23 1992/09/04 09:43:25 nickc Exp $ */
d1479 1
a1479 1
		size = (size + sizeof(word)-1)/sizeof(word);
d1482 2
a1483 2
			image = AllocSpecial(size,CodePoolType[i],&CodePool);
			if( image != NULL ) break;
d1496 1
a1496 1
		image->Size = size;
@


1.25
log
@nucleus now returned as a word pointer in C40 versions
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.24 1992/11/12 14:37:06 paul Exp $ */
d28 6
d38 1
a38 1
#define debug(x)	/* IOdebug x */
d67 2
a68 6
	union {
		Module	*m;		/* pointer to resident module	*/
		Program	*p;		/* pointer to loaded program	*/
		byte    *b;		/* row of bytes			*/
		void	*a;		/* generic pointer		*/
	} Image;
d76 2
d183 1
a183 1
Image *NewImage(DirNode *, void *, string, word, word, Matrix, word size);
d185 2
a186 2
word progsize(Program *);
word checksum(void *p, word size);
d189 3
a191 3
byte *LoadImage(string name, Capability *cap, word pos, int bindp,
Object **objp, word *size);
byte *LoadObject(Object *obj, word pos, bool bindp, word *size);
d193 5
a197 3
word BindLibraries(byte *image, bool readonly);
void UnbindLibraries(void *image);
byte *ReadStream(Stream *s, word *size);
d215 1
d268 1
a268 6
#ifdef __C40
	/* @@@@@@ THIS WILL HAVE TO CHANGE FOR CODE ON GLOBAL BUS */
	RPTR *ivec = (RPTR *)C40CAddress(GetSysBase());	/* from root.h */
#else
	RPTR *ivec = (RPTR *)GetSysBase();	/* from root.h */
#endif
d271 1
a271 1
	Module *m;
d321 1
a321 1
	for( j = 1; ivec[j] != 0; j++ )
d324 6
a329 2
	        m = (Module *)RTOA(ivec[j]);
	        switch ( m->Type )
d338 2
a343 1
		i = NewImage(&Root,(void *)m,m->Name,type,0,-1, 0);
d345 7
d375 19
d403 1
a403 1
	BindLibraries(i->Image.b,TRUE);
d435 1
a435 1
Image *NewImage(DirNode *dir, void *image, string name, word type, word flags,
d439 1
a439 1

d448 6
a453 5
	i->UseCount = 0;
	i->Retain = false;
	i->Closing = false;
	i->Image.a = (void *)image;

d455 1
a455 1
	i->ObjNode.Size = (size == 0) ? progsize((Program *)image) : size;
d459 1
a459 1
	i->CheckSum = checksum(image, i->ObjNode.Size - sizeof(ImageHdr));	
d467 1
a467 1
word progsize(Program *p)
a469 1
	Module *m = (Module *)p;
d471 1
a471 1
	while( *(word *)m != 0 )
d473 2
a474 2
		size += m->Size;
		m = (Module *)(((int)m) + m->Size);
d480 1
a480 1
word checksum(void *p, word size)
d484 1
a485 1
#ifdef __TRAN
d488 2
a489 2
	for( i = 0 ; i < size/sizeof(word) ; i++ )
		csum = (word)((unsigned long)csum + (unsigned long)*pp++);
d498 1
a498 1
	if( i->CheckSum != checksum(i->Image.a, i->ObjNode.Size - sizeof(ImageHdr)) )
d749 1
a749 1
		MarshalWord(&r->mcb,(word)i->Image.a);
d844 2
a845 1
	void *p;
d894 1
a894 1
		p = i->Image.a;
d906 1
a906 1
			p = i->Image.a;
d910 1
a910 1
		p = LoadImage(info->Name, &info->Cap, info->Pos, true, &o,
d913 1
a913 1
		if( p == NULL ) 
d918 1
d920 1
a920 1
		switch( *(word *)p )
d927 1
a927 1
			Free(p);
d930 1
a930 1
		i = NewImage(d,p,name,type,0,info->Matrix, size);
d1093 1
a1093 1

d1141 1
a1141 1
		UnbindLibraries(i->Image.a);
d1146 1
a1146 1
		if( i->Image.m->Type == T_Module ) {
d1152 1
a1152 1
			FreeMem((void*)(C40CAddress(root->cpi[i->Image.m->Id])));
d1156 1
a1156 1
			root->cpi[i->Image.m->Id] = NULL;
d1161 1
a1161 1
		FreeMem((void *)i->Image.a);
d1184 4
a1187 1
	word isize = i->ObjNode.Size+sizeof(ImageHdr);
d1189 13
d1205 1
a1205 1
		return;
d1211 1
a1211 1
		return;
d1217 7
d1226 1
d1230 2
d1235 28
d1269 1
a1269 1
		h->Size = i->ObjNode.Size;
d1273 2
a1274 3
	pos -= sizeof(ImageHdr);
	if( pos < 0 || pos >= i->ObjNode.Size ) return NULL;
	
d1276 2
a1277 2
	b->Size = b->Max = i->ObjNode.Size;
	b->Data = i->Image.b;
d1280 1
d1328 1
a1328 1
byte *LoadImage(string name, Capability *cap, word pos, int bindp,
d1332 1
a1332 1

d1344 1
a1344 1
byte *LoadObject(Object *o, word pos, bool bindp, word *size)
d1347 2
a1348 2
	byte *image = NULL;

a1355 1
#if 1
d1357 1
a1357 4
#else
	/* original code !!! */
	if( pos != 0 ) Seek(s,pos,S_Beginning);
#endif	
d1360 1
a1360 1
	if( bindp && !BindLibraries(image,FALSE) )
d1362 1
a1362 1
		FreeMem((void *)image);
d1372 1
a1372 1
byte *ReadStream(Stream *s, word *retsize)
d1375 2
a1376 1
	byte *image;
d1379 15
d1397 1
a1397 1
		return NULL;
d1399 1
a1399 1
	if( (image = AllocMem(hdr.Size,&CodePool)) == Null(byte) ) return NULL;
d1401 13
a1416 3
#if 0
	size = Read(s,image,hdr.Size,-1);
#else
d1419 1
a1419 1
		int dsize = READSIZE-sizeof(hdr);
d1423 1
a1423 1
			size = Read(s,&image[got],dsize,-1);
d1426 6
d1433 1
d1437 1
a1437 1
			dsize = READSIZE;
d1441 1
a1441 1
#endif
d1444 3
a1446 2
		FreeMem(image);
		return NULL;
d1449 52
d1502 1
d1505 16
d1529 1
a1529 1
word BindLibraries(byte *image, bool readonly)
d1531 2
a1532 2
	Module *m = (Module *)image;

d1535 1
a1535 1
	while( *(word *)m != 0 )
d1537 1
a1537 1
		if( m->Type == T_ResRef )
d1540 2
a1541 1
			Image *i = (Image *)Lookup(&Root,m->Name,TRUE);
d1543 6
a1548 2
			if( i == NULL )	i = SearchLoad(m->Name);
			if( i == NULL ) i = LoadLibrary(m->Name);
d1557 1
a1557 1
				((ResRef *)m)->Module = i->Image.m;
d1566 1
a1566 1
		m = (Module *)((word)m + m->Size);
d1572 1
a1572 1
void UnbindLibraries(void *image)
d1574 2
a1575 2
	Module *m = (Module *)image;
	
d1578 1
a1578 1
	while( *(word *)m != 0 )
d1580 1
a1580 1
		if( m->Type == T_ResRef )
d1582 6
a1587 1
			Image *i = (Image *)Lookup(&Root,m->Name,TRUE);
d1603 1
a1603 1
				FreeMem((void*)(C40CAddress(root->cpi[m->Id])));
d1605 1
a1605 1
				FreeMem((void*)(root->cpi[m->Id]));
d1607 1
a1607 1
				root->cpi[m->Id] = NULL;
d1610 2
a1611 2
				UnbindLibraries(i->Image.a);
				FreeMem((void *)i->Image.a);
d1619 1
a1619 1
		m = (Module *)((word)m + m->Size);
d1664 2
a1665 1
	byte *image;
d1674 1
a1674 1

d1724 1
a1724 1
	if( (image = ReadStream(s, &size)) == NULL ) goto done;
d1726 2
d1731 1
a1731 1
		word id = ((Module *)image)->Id;
d1748 1
a1748 1
		if ((root->cpi[id] = C40WordAddress(AllocMem(((Module *)image)->MaxCodeP, &root->SysPool))) == NULL)
d1751 1
a1751 1
		if ((root->cpi[id] = (word)AllocMem(((Module *)image)->MaxCodeP, &root->SysPool)) == NULL)
d1761 1
a1761 1
	i = NewImage(&Root, (void *)image, name, Type_Module, 0, -1, size);
d1778 1
a1778 1
	FreeMem(image);
d1787 2
a1788 1
	void *p;
d1791 1
a1791 1

d1795 1
a1795 1
	p = LoadObject(o, 0, true, &size);
d1797 1
a1797 1
	if( p == NULL ) return false;
d1799 3
a1801 1
	switch( *(word *)p )
d1823 1
a1823 1
	i->Image.a = p;
d1826 1
a1826 1
	i->ObjNode.Size = size;
d1828 1
a1828 1
	i->CheckSum = checksum(p, i->ObjNode.Size - sizeof(ImageHdr));
d1938 1
d2012 1
d2017 1
d2098 1
d2113 2
a2114 1
	Module *mod;
d2117 1
a2117 1
	word *addr = (word *)req->Addr;		/* Get image's addr from msg */
d2123 1
a2123 1
	if (*addr != Image_Magic)
d2127 1
a2127 1
        mod = (Module *) (addr + (sizeof(ImageHdr)/sizeof(word)));
d2129 1
a2129 1
        switch ( mod->Type )
d2138 6
a2143 1
	i = NewImage(&Root, (void *)mod, name, type, 0, -1, 0);
@


1.24
log
@fixed for new parameters to C40WordAddress
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.23 1992/09/04 09:43:25 nickc Exp paul $ */
d261 4
d266 1
@


1.23
log
@fixed compile time warnings
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.22 1992/07/31 16:18:45 paul Exp nickc $ */
d1542 1
a1542 1
		if ((root->cpi[id] = C40WordAddress((word)AllocMem(((Module *)image)->MaxCodeP, &root->SysPool))) == NULL)
@


1.22
log
@fixed to give correct size of image
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.21 1992/07/16 10:09:54 paul Exp $ */
d298 1
a298 1
		Parent = (LinkNode *)Malloc(sizeof(LinkNode) + strlen(mcname));	
d406 1
a406 1
	InitNode(&i->ObjNode,name,type,flags,matrix);
d451 1
a451 1
		csum = (word)((unsigned)csum + (unsigned)*pp++);
d667 1
a667 1
	unless( CheckMask(req->Common.Access.Access,req->Arg.Mode&Flags_Mode) ) 
d1306 1
a1306 1
			if( dsize > hdr.Size - got ) dsize = hdr.Size - got;
d1427 1
a1427 1
	word newsize = maxid + CPISLOTINC;
d1440 1
a1440 1
		int i;
d1448 1
a1448 1
	memcpy((void *)newCPI, (void *)(root->cpi), root->cpislots * sizeof(word));
d1530 1
a1530 1
			if (!EnlargeCPI(id))
d1647 2
d1732 1
a1732 1
	word e;
d1736 1
a1736 1
	int nlinks = GetConfig()->NLinks;
d1876 1
a1876 1
	MarshalData(mcb,strlen(pathname)+1,pathname);
@


1.21
log
@fixes for stack size, but mainly deletion of shared code pointer tables
for the C40
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.20 1992/02/26 17:08:35 paul Exp $ */
d179 1
a179 1
Image *NewImage(DirNode *, void *, string, word, word, Matrix);
d185 3
a187 2
byte *LoadImage(string name, Capability *cap, word pos, int bindp, Object **objp);
byte *LoadObject(Object *obj, word pos, bool bindp);
d191 1
a191 1
byte *ReadStream(Stream *s);
d326 7
a332 1
		i = NewImage(&Root,(void *)m,m->Name,type,0,-1);
d397 2
a398 1
Image *NewImage(DirNode *dir, void *image, string name, word type, word flags, Matrix matrix)
d414 5
a418 3
	
	i->ObjNode.Size = progsize((Program *)image);
	
d420 1
a420 1
	i->CheckSum = checksum(image, i->ObjNode.Size);	
d460 1
a460 1
	if( i->CheckSum != checksum(i->Image.a, i->ObjNode.Size) )
d862 1
d871 2
a872 1
		p = LoadImage(info->Name,&info->Cap,info->Pos,true,&o);
d890 1
a890 1
		i = NewImage(d,p,name,type,0,info->Matrix);
d1234 2
a1235 1
byte *LoadImage(string name, Capability *cap, word pos, int bindp, Object **objp)
d1247 1
a1247 1
	return LoadObject(o,pos,bindp);
d1250 1
a1250 1
byte *LoadObject(Object *o, word pos, bool bindp)
d1268 1
a1268 1
	if( (image = ReadStream(s)) == NULL ) goto done;
d1282 1
a1282 1
byte *ReadStream(Stream *s)
d1295 3
d1469 1
d1520 1
a1520 1
	if( (image = ReadStream(s)) == NULL ) goto done;
d1555 1
a1555 1
	i = NewImage(&Root,(void *)image,name,Type_Module,0,-1);
d1561 1
a1561 1
	i->CheckSum = checksum(image, i->ObjNode.Size);
d1583 1
d1588 2
a1589 2
	p = LoadObject(o,0,true);
	
d1617 1
a1617 1
	i->ObjNode.Size = progsize((Program *)p);
d1619 1
a1619 1
	i->CheckSum = checksum(p, i->ObjNode.Size);
d1668 2
d1684 1
a1684 1
	p = LoadObject(o,0,FALSE);
d1687 1
a1687 1
	
d1696 1
a1696 1
	i = NewImage(&Root,(void *)p,name,type,0,-1);
d1713 1
a1713 1
		i->CheckSum = checksum(p, i->ObjNode.Size);
d1922 1
a1922 1
	i = NewImage(&Root,(void *)mod,name,type,0,-1);
d1930 1
@


1.20
log
@c40 fix
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.19 1991/12/12 16:08:17 paul Exp $ */
d141 8
a148 3
#ifndef SYSDEB
#define bigstack 3000
#define defstack 1200
d150 2
a151 2
#define bigstack 4000
#define defstack 2000
d1090 19
d1293 1
d1383 3
d1387 1
a1401 1

d1413 1
a1413 1
	
d1515 1
a1515 1
# if 1
d1517 11
a1527 2
			IOdebug("SMT error: Duplicate Shared code pointer index");
# endif			
d1530 1
a1531 3
#ifdef __C40
		root->cpi[id] = C40WordAddress(root->cpi[id]);
#endif
d1547 1
a1547 1
	Signal(&i->ObjNode.Lock);		
d1563 1
a1563 1
	Matrix matrix;	
@


1.19
log
@beter adjustment!
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.17 1991/10/14 09:19:53 paul Exp $ */
d1494 3
@


1.18
log
@adjusted for c40
@
text
@d222 1
a222 1
#      pragma -s0
d237 1
a237 1
#      pragma -s1
@


1.17
log
@SMT -> __SMT
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.16 1991/06/17 12:54:54 bart Exp paul $ */
d205 2
a206 2
# ifdef STACKCHECK
#  pragma -s1
d215 10
a224 3
#  pragma -s0
# elif defined (__HELIOSARM)
#  pragma no_check_stack
d233 8
a240 2
#  pragma check_stack
# endif
a1572 1
/*#ifndef __HELIOSARM		*/
d1576 1
a1576 1
/*#endif*/
a1584 2

/*#ifndef __HELIOSARM */ /* do_search could be knocked out for single processor versions */
@


1.16
log
@There is a new compile-time option CONTINUOUS_CHECKING, responsible
for checking every piece of loaded code at regular intervals. This
can help to catch certain memory corruption problems.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.15 1991/05/15 15:44:29 bart Exp bart $ */
d1340 1
a1340 1
#ifdef SMT
d1363 1
a1363 1
#ifdef SMT
d1464 1
a1464 1
#ifdef SMT
d1502 1
a1502 1
#ifdef SMT
@


1.15
log
@Changed access mask of objects embedded in the nucleus to deny
Delete access to everybody. This is necessary if we intend to support
putting resident libraries into the nucleus without the Network Agent
being able to delete them.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.14 1991/03/25 16:44:00 paul Exp $ */
d28 3
d88 4
d178 1
d327 4
d343 21
@


1.14
log
@fix for new version of AllocMem that doesn't zero memory that it allocates
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.13 91/02/28 11:52:07 nick Exp $ */
d53 1
a53 1
typedef struct Image {
d302 1
@


1.13
log
@type 805 added
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.12 91/02/28 10:42:59 nick Exp Locker: nick $ */
d1336 2
a1337 1
	word *newCPI = AllocMem((maxid | CPISLOTINC) * sizeof(word), &root->SysPool);
d1339 3
d1345 11
d1360 1
a1360 1
	root->cpislots = maxid | CPISLOTINC;
@


1.12
log
@Machine type 801 added, also test for processor equivalence in search
only uses the hundreds, not the digits so 414/425/400 match as will
800 and 801.
Note: for the next version we must change the machine type so we can
obtain a better indication of processor capabilities.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.11 91/02/07 17:38:48 nick Exp Locker: nick $ */
d1384 1
@


1.11
log
@SEMDBG was not defined for non-debugging systems, fixed
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.10 91/02/07 17:23:00 nick Exp Locker: nick $ */
d1383 1
d1715 3
d1719 1
@


1.10
log
@Many changes, mostly in a fruitless attempt to isolate a deadlock caused
by the SEARCHCODE option, for now this option is left disabled.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.9 91/01/04 12:38:54 nick Exp $ */
d106 2
a107 2
# define WaitLock(s,n) Wait(s)
# define WaitObj(o) Wait(&(o)->Lock)
d109 1
a109 5
#define SEMDBG 0
# if !SEMDBG
#define InitSemDbg()
#define NameSem(s,n)
# endif
d114 1
d116 5
@


1.9
log
@ReadStream now copes with reads smaller than it expected.
MachineType sent in SearchCode, positive responses sent back only if
the module in not mc-specific, or the machines are the same.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.8 90/12/07 17:01:45 nick Exp $ */
d26 1
d88 26
d116 2
d132 1
d135 4
d180 1
a180 1
Object *SearchCode(char *name);
d188 1
d239 7
a245 1
	InitSemaphore(&SearchLock,1);
d258 1
a258 1
	
d271 1
d282 1
a282 1
	Wait(&Root.Lock);
d345 1
d419 1
d498 1
a498 1
		Wait(&servinfo->Context->Lock);
d523 1
a523 1
		Wait(&o->Lock);
d544 1
a544 1
	Wait( &o->Lock );
d691 1
a691 1
		Wait( &i->ObjNode.Lock );
d750 1
a750 1
	if( d == NULL )
d774 1
a774 1
		Wait(&i->ObjNode.Lock);
d798 8
d827 1
a827 1

d1004 1
a1004 1
			Wait(&i->ObjNode.Lock);
d1015 2
a1016 2
		Wait(&Root.Lock);
		Wait(&i->ObjNode.Lock);
d1155 1
a1155 3
	o = SearchCode(objname(name));

	if( o == NULL ) o = NewObject(name,cap);
d1259 3
a1261 5
			if( i == NULL )
			{
				i = LoadLibrary(m->Name);
				if( i == NULL ) return false;		
			}	
d1263 1
a1263 1
			Wait(&i->ObjNode.Lock);
d1296 1
a1296 1
			Wait(&i->ObjNode.Lock);
d1364 1
a1364 7
/*#ifndef __HELIOSARM*/
	o = SearchCode(name);
/*#endif*/

	if( o == NULL )
	{
		strcpy(lname,name);
d1366 1
a1366 3
		if( LibDir == NULL )
			LibDir = Locate(NULL,"/helios/lib");
	}
d1436 1
a1436 1
	Wait(&i->ObjNode.Lock);
d1529 1
d1531 1
d1542 1
a1542 1
Object *SearchCode(char *name)
d1544 56
a1599 1
#if 0
a1600 6
#else
	Object *o;
	Wait(&SearchLock);
	o = SearchCode1(name,NewSeq(),-1);
	Signal(&SearchLock);
	return o;
d1612 3
a1614 1
	MCB *mcb;	
d1636 1
a1636 5
#ifdef __TRAN
	for( i = 0; i < 4; i++ )
#else
	for( i = GetConfig()->NLinks-1; i >= 0; i-- )
#endif
d1640 5
d1647 1
d1652 1
a1652 1
	mcb->Timeout = 5*OneSec;
d1654 2
a1655 1
	/* must unlock while we wait since we will get loop-backs */
a1656 1
	Signal(&SearchLock);	
d1658 2
a1659 5
#ifdef __TRAN
	for( i = 0; i < 4; i++ )
#else
	for( i = GetConfig()->NLinks-1; i >= 0; i-- )
#endif
d1666 1
a1666 2
	Wait(&Root.Lock);
	Wait(&SearchLock);
d1693 1
a1693 1
	Wait(&SearchLock);
d1695 5
a1699 1
	for( i = 0; i < 32 ; i++ ) if( id == SearchTab[i] ) goto fail;
d1703 2
a1755 1
	Signal(&SearchLock);
@


1.8
log
@searches only succeed if the original file had the same name as the loaded
object. This is because a T4 could get a T8 fplib from it neighbour otherwise.
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.7 90/11/16 14:00:08 nick Exp $ */
d1169 1
a1169 1
			if( size != dsize ) break;
d1541 2
a1542 1
	
d1600 2
a1601 1

d1610 4
d1615 3
a1617 1
		strlcmp(objname(image->Object->Name),objname(pathname))!=0) 
@


1.7
log
@bug in destroying cached names fixed
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.6 90/11/02 16:27:25 paul Exp Locker: nick $ */
d1595 1
a1595 1
	char *pathname;
d1608 2
a1609 1
	if( image == NULL ) 
@


1.6
log
@fixed do_search for implementations with less than 4 links - i.e. ARM!
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.5 90/11/01 16:41:39 nick Exp Locker: paul $ */
d976 2
a977 1
			Unlink(&i->ObjNode,FALSE);
@


1.5
log
@Many changes. Load from neighbour implemented, better locking discipline
should avoid any deadlocks. 
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.4 90/09/25 18:15:34 paul Exp $ */
d1315 1
a1315 1
#ifdef __TRAN
d1317 1
a1317 1
#endif
d1466 1
a1466 1
#ifdef __TRAN		
d1470 1
a1470 1
#endif
d1480 1
a1480 1
#ifdef __TRAN
d1541 1
d1543 3
d1561 1
d1563 3
d1654 1
a1654 1
#endif
@


1.4
log
@arm changes
@
text
@d16 1
a16 1
/* $Id: loader.c,v 1.3 90/09/05 18:20:02 nick Exp Locker: nick $ */
d26 4
d43 1
d56 1
d63 1
d70 1
a70 1
DirNode		Root;			/* root of loader directory */
d84 6
d135 3
a137 2
LinkNode *makelink(DirNode *d, string lname, string name, Capability *cap, bool dirlocked);
byte *LoadImage(string name, Capability *cap, word pos, int bindp);
d146 2
a147 1
Stream *SearchCode(char *name);
d153 2
d157 1
d192 2
a195 3
#if 0
	RPTR *ivec = (RPTR *)0x80001000;	/* yuk! */
#else
d198 1
a198 1
#endif
a200 1
	Program *p;
d204 2
a223 1
		char mcname[100];
d240 2
d260 1
d264 1
a264 27
#if 0
# ifndef __HELIOSARM
	/* install links to Clib and Posix from parent */
	{
		int i;
		LinkInfo *parent = NULL;
		char parname[50];
		char libname[50];
		RootStruct *root = GetRoot();
		
		for( i = 0; root->Links[i] != NULL ; i++ )
			if( root->Links[i]->Flags & Link_Flags_parent )
				parent = root->Links[i];

		if (parent) /* ROM based systems have no parent */
		{
			if( parent->Flags & Link_Flags_ioproc )
			{
				strcpy(parname,"/helios/lib/");
			}
			else
			{
				strcpy(parname,"/link.");
				if( parent->Id == 0 ) strcat(parname,"0");
				else addint(parname,parent->Id);
				strcat(parname,"/loader/");
			}
a265 13
			NewCap(&posixcap,(ObjNode *)&Root,0xff);
			strcpy(libname,parname);
			strcat(libname,"Posix");
			makelink(&Root,"Posix",libname,&posixcap,FALSE);

			NewCap(&clibcap,(ObjNode *)&Root,0xff);
			strcpy(libname,parname);
			strcat(libname,"Clib");
			makelink(&Root,"Clib",libname,&clibcap,FALSE);
		}
	}
# endif
#endif
a286 20
#if 0
makefplink()
{
	char libname[100];
	char *suffix;
	int t;
	switch( t=MachineType() )
	{
	case 800: suffix = ".t8"; break;
	default:  IOdebug("Unknown processor type %d, T414 assumed",t);
	case 414: suffix = ".t4"; break;
	case 425: suffix = ".t4"; break;
	}
	strcpy(libname,fplibname);
	strcat(libname,suffix);
	
	(void) makelink(&Root,"FpLib",libname,&fplibcap,FALSE);	
}
#endif

a297 2
/*debug("NewImage (%x,%x,%s,%x,%x,%x)",dir,image,name,type,flags,matrix);*/

d307 1
d314 3
a317 2
	Insert( dir, &i->ObjNode, TRUE );
/*debug("NewImage %x",i);*/
d351 2
a352 1
return;
d355 1
a355 1
		IOdebug("WARNING: Corruption of %s detected",i->ObjNode.Name);
d360 40
a399 1
LinkNode *makelink(DirNode *d, string lname, string name, Capability *cap, bool dirlocked)
d401 25
a425 2
	int size = sizeof(LinkNode) + strlen(name);
	LinkNode *l;
d427 3
a429 16
	if( size < sizeof(Image) ) size = sizeof(Image);
	
	l = (LinkNode *)Malloc(size);

	if( l == NULL ) return NULL;

	InitNode(&l->ObjNode, lname, Type_CacheName, 0, DefProgMatrix );
	l->ObjNode.Key = MagicKey;
	
	l->Cap = *cap;

	strcpy(l->Link,name);

	Insert( d, &l->ObjNode, dirlocked );
	
	return l;
d432 78
d544 2
a545 2

	i = (Image *)GetTargetObj(servinfo);
d553 5
a557 1
		
d568 2
d583 4
a586 1
		Wait(&Root.Lock);
d588 1
d597 1
d614 1
d649 2
d667 1
a703 2
/*debug("Loader Create");*/

d706 1
a706 1
	if( d == Null(DirNode) )
d712 4
d724 1
a724 1
	i = (Image *)Lookup( d, name, TRUE );
d728 3
d740 1
d748 1
d752 1
d754 1
a754 1
		p = LoadImage(info->Name,&info->Cap,info->Pos,true);
d773 1
d799 2
d825 1
a825 2
	if( i->ObjNode.Type == Type_Directory || 
	    i->ObjNode.Type == Type_CacheName )
d831 6
d839 3
a841 17
	if( i->UseCount != 0 )
	{
		/* if the module is in use, clear the retain flags so that */
		/* it will be deleted when the usecount goes to zero.	*/
		i->Retain = false;
		ErrorMsg(m,EC_Error|EG_InUse|EO_Module);
		return;
	}

	Wait(&Root.Lock);
	UnbindLibraries(i->Image.a);	
	FreeMem(i->Image.a);
	Unlink(&i->ObjNode,TRUE);
	Free(i);
	Signal(&Root.Lock);
		
	ErrorMsg(m,Err_Null);
d851 1
a851 1
	LinkNode *l;
a854 2
/* debug("Loader do_link %s %s",pathname,&data[req->Name]); */

d871 1
a871 1
	if( o != Null(ObjNode) )
d893 1
a893 1
	l = makelink(d,objname(pathname),&data[req->Name],&req->Cap,TRUE);
d895 1
a895 1
	if( l == Null(LinkNode) )
a905 2
	char *pathname = servinfo->Pathname;

d914 1
d916 6
a921 1
	i = (Image *)GetTarget(servinfo);
d927 36
a962 2
	if( i->UseCount == 0 && !i->Retain )
	{
d964 18
d985 4
a988 2
		Free(i);		
		Signal(&Root.Lock);		
d990 2
a991 2

	ErrorMsg(m,Err_Null);
d1096 18
a1113 1
byte *LoadImage(string name, Capability *cap, word pos, int bindp)
d1117 2
d1120 1
a1120 1
	s = NewStream(name,cap,O_ReadOnly);
d1122 1
a1122 1
	if( s == Null(Stream) ) return NULL;
a1139 1

a1150 1

d1163 1
a1165 1
			int dsize = 10000;
d1170 4
d1199 2
d1205 1
d1208 1
a1208 1
			if( i == Null(Image) )
d1213 5
a1217 4
			elif ( i->ObjNode.Type == Type_CacheName )
			{
				if( !LoadCache(i) ) return false;
			}
d1225 3
a1227 1

d1238 3
a1240 1

d1246 2
d1267 1
d1270 2
d1306 1
d1312 6
a1317 2
	
	s = SearchCode(name);
d1319 1
a1319 1
	if( s == NULL )
d1328 1
a1328 1
	if( s == NULL ) s = Open(LibDir,lname,O_ReadOnly);
d1331 1
a1331 1
	if( s == NULL )
d1341 3
a1343 2
		default:  IOdebug("Unknown processor type %d, T414 assumed",t);
		case 414: suffix = ".t4"; break;
d1349 1
a1349 1
		s = Open(LibDir,xname,O_ReadOnly);
d1353 1
a1353 1
	if( s == NULL && !lcdone)
d1362 1
a1362 1
	if( s == NULL ) return NULL;
d1364 4
d1395 1
d1400 3
a1402 1
		
a1416 1
	LinkNode *l = (LinkNode *)i;
d1420 4
d1425 1
a1425 1
	p = LoadImage(l->Link,&l->Cap,0,true);
d1457 1
a1457 1
		
d1462 1
a1462 1
bool do_private(ServInfo *servinfo)
d1466 1
d1470 1
a1470 1

d1480 2
d1497 16
a1512 1
Stream *SearchCode(char *name)
d1518 1
a1518 1
	Stream *s = NULL;
d1521 1
a1521 1
	
d1525 1
a1525 1
	
d1539 1
a1539 1
	MarshalWord(mcb,NewSeq());
d1543 5
a1547 2
		mcb->Data[6] = '0'+i;
		SendIOC(mcb);
d1552 2
d1555 2
d1563 3
d1572 2
a1573 1
		s = NewStream(sd->Name,&sd->Cap,sd->Mode);
d1575 1
a1575 1
	
d1577 1
a1577 1
	return s;
d1580 1
a1580 1
bool do_search(ServInfo *servinfo)
d1586 4
d1591 3
a1593 2
	for( i = 0; i < 32 ; i++ )
		if( mcb->Control[5] == SearchTab[i] ) goto fail;
d1595 2
d1598 30
d1629 1
a1629 3
	if( image == NULL ) goto fail;

	InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,0);		
d1631 1
a1631 1
	MarshalDataWord(mcb,image->ObjNode.Flags|Flags_Closeable|O_ReadOnly);
a1632 1
	NewCap(&cap,&image->ObjNode,AccMask_R);
d1634 1
a1634 1
	MarshalData(mcb,strlen(servinfo->Pathname)+1,servinfo->Pathname);
d1641 2
d1646 1
@


1.3
log
@revoke added
@
text
@d16 2
a17 2
/* SccsId: %W% %G% Copyright (C) 1987, Perihelion Software Ltd.*/
/* $Id$ */
d19 1
d1062 9
d1082 23
d1110 1
d1112 1
d1164 23
d1197 7
a1203 1
	return i;	
d1415 1
@


1.2
log
@*** empty log message ***
@
text
@a18 1

d89 1
d97 1
a97 1
	{ (VoidFnPtr)do_private,2000 },
d99 2
a100 2
		{ do_open,	2000 },
		{ do_create,	2000 },
d110 4
a113 1
		{ do_closeobj,	defstack }
a1350 1

@


1.1
log
@Initial revision
@
text
@d17 1
a17 5
/* $Id$
 *
 * $Log$
 *
 */
@
