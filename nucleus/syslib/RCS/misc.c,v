head	1.31;
access;
symbols
	Helios_1_3_1:1.31
	Helios_C40_1_3_Official_Release:1.30
	Alenia_release:1.25
	Helios1_3:1.24
	C40_Field_Test_2:1.24
	C40_Field_Test_R1:1.20
	Helios13_beta:1.20
	Helios1_2_2:1.16
	Helios1_2_2Beta:1.15
	Helios1_2_1:1.14
	Helios1_2:1.12
	V1_2Beta0:1.4;
locks; strict;
comment	@ * @;


1.31
date	93.07.09.13.36.31;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	93.04.28.14.11.23;	author bart;	state Exp;
branches;
next	1.29;

1.29
date	93.04.20.17.20.58;	author bart;	state Exp;
branches;
next	1.28;

1.28
date	93.04.20.12.57.56;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	93.04.15.15.08.33;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	93.03.27.20.44.00;	author bart;	state Exp;
branches;
next	1.25;

1.25
date	92.12.07.19.28.31;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	92.09.07.13.40.24;	author paul;	state Exp;
branches;
next	1.23;

1.23
date	92.09.04.10.24.43;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	92.09.04.10.01.02;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	92.08.14.10.46.02;	author bart;	state Exp;
branches;
next	1.20;

1.20
date	92.06.03.19.02.57;	author paul;	state Exp;
branches;
next	1.19;

1.19
date	92.05.05.10.38.46;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	92.05.01.16.45.33;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	92.04.21.11.12.49;	author bart;	state Exp;
branches;
next	1.16;

1.16
date	91.10.17.07.39.55;	author paul;	state Exp;
branches;
next	1.15;

1.15
date	91.08.05.12.28.40;	author nick;	state Exp;
branches;
next	1.14;

1.14
date	91.02.07.16.50.03;	author nick;	state Exp;
branches;
next	1.13;

1.13
date	91.01.04.12.21.54;	author nick;	state Exp;
branches;
next	1.12;

1.12
date	90.11.28.11.25.48;	author nick;	state Exp;
branches;
next	1.11;

1.11
date	90.11.21.10.46.20;	author nick;	state Exp;
branches;
next	1.10;

1.10
date	90.11.02.16.32.44;	author paul;	state Exp;
branches;
next	1.9;

1.9
date	90.11.01.15.30.03;	author nick;	state Exp;
branches;
next	1.8;

1.8
date	90.10.24.00.55.29;	author paul;	state Exp;
branches;
next	1.7;

1.7
date	90.10.19.11.05.33;	author nick;	state Exp;
branches;
next	1.6;

1.6
date	90.10.19.10.51.19;	author nick;	state Exp;
branches;
next	1.5;

1.5
date	90.10.19.10.48.30;	author nick;	state Exp;
branches;
next	1.4;

1.4
date	90.09.05.12.54.33;	author nick;	state Exp;
branches;
next	1.3;

1.3
date	90.08.28.18.17.38;	author nick;	state Exp;
branches;
next	1.2;

1.2
date	90.08.28.12.50.49;	author nick;	state Exp;
branches;
next	1.1;

1.1
date	90.08.28.12.08.24;	author nick;	state Exp;
branches;
next	;


desc
@Syslib internal support routines plus
miscellaneous external routines
@


1.31
log
@fixed conflicts with C++
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--                     H E L I O S   N U C L E U S                      --
--                     ---------------------------                      --
--                                                                      --
--            Copyright (C) 1987-1990, Perihelion Software Ltd.         --
--                        All Rights Reserved.                          --
--                                                                      --
-- syslib/misc.c							--
--                                                                      --
--	System Library internal support routines, plus a few external	--
--	routines which do not fit any other category.			--
--                                                                      --
--	Author:  NHG 16/8/87						--
--		 NHG 03/8/90						--
--                                                                      --
------------------------------------------------------------------------*/
/* $Id: misc.c,v 1.30 1993/04/28 14:11:23 bart Exp nickc $ */

#define _in_misc

#include "sys.h"
#include <root.h>
#include <config.h>
#include <stdarg.h>

static void AddObject(Object *o);
static void AddStream(Stream *s);
static WORD CheckObject(Object *obj, word options);
static WORD CheckStream(Stream *str, word options);
static WORD IOCMsg(MCB *m, void *data);
static word CloseObject(Object *object);

/*--------------------------------------------------------
--		Private Data Definitions 		--
--------------------------------------------------------*/

STATIC Semaphore	BufLock;	/* lock on buffer list		*/

STATIC MsgBuf		*IOCBuf;	/* IOC message buffer		*/

static word		IOCBufCount;	/* Number of buffers in use	*/

STATIC	Semaphore	ObjectLock;	/* lock on Object list		*/
			
STATIC List		Objects; 	/* list of Objects		*/

STATIC	Semaphore	StreamLock;	/* lock on Stream list		*/
			
STATIC	List		Streams;	/* list of Streams		*/

STATIC bool 		Terminating;	/* TRUE if program is quitting	*/

#ifdef SYSDEB
static Semaphore 	SysDebugLock;	/* serializes all SysDebugs	*/ 
#endif

/*--------------------------------------------------------
-- _SysLib_Init						--
--							--
-- Initialisation routine for syslib. This is called	--
-- from the module initialisation routine before the	--
-- program is entered.					--
--							--
--------------------------------------------------------*/

PRIVATE void _SysLib_Init(void)
{
	InitList(&Objects);
	InitList(&Streams);
	InitSemaphore(&ObjectLock,1);
	InitSemaphore(&StreamLock,1);
	
	InitSemaphore(&BufLock,1);
	IOCBuf = NULL;
	IOCBufCount = 0;

#ifdef SYSDEB
	InitSemaphore(&SysDebugLock,1);
#endif
	
	{
		extern Semaphore PipeLock;
		extern List PipeList;
		InitList(&PipeList);
		InitSemaphore(&PipeLock,1);
	}
}

/*--------------------------------------------------------
-- NewMsgBuf						--
-- FreeMsgBuf						--
--							--
-- Message buffer management. A single buffer is kept	--
-- permanently, but extras are allocated dynamically	--
-- when needed.						--
--							--
--------------------------------------------------------*/

static MCB *NewMsgBuf(int dsize)
{
	MsgBuf *m;

	if( dsize < IOCDataMax ) dsize = IOCDataMax;
retry:
	Wait(&BufLock);
	
	if( dsize == IOCDataMax && IOCBuf != NULL ) 
	{
		m = IOCBuf;
		IOCBuf = *(MsgBuf **)m;
	}
	else 
	{
		m = (MsgBuf *)Malloc(sizeof(MsgBuf) + (word)dsize - IOCDataMax);
		if( m == NULL )
		{
			Signal(&BufLock);
			Delay(OneSec);
			goto retry;
		}
		IOCBufCount++;
	}
	m->size = dsize;
	m->mcb.Control = m->control;
	m->mcb.Data = m->data;

#ifdef SYSDEB
	SysDebug(memory)("NewMsgBuf %x from %s",m,procname(returnlink_(dsize)));
#endif

	Signal(&BufLock);

	return &m->mcb;
}

static void FreeMsgBuf( MCB *mcb )
{
	MsgBuf *m = (MsgBuf *)mcb;
	
	if( m == NULL ) return;
	
#ifdef SYSDEB
	SysDebug(memory)("FreeMsgBuf %x from %s",mcb,procname(returnlink_(mcb)));
#endif

	if( m->size > IOCDataMax ) 
	{
		Free(m);
		IOCBufCount++;
	}
	else
	{
		Wait(&BufLock);
		*(MsgBuf **)m = IOCBuf;
		IOCBuf = m;
		Signal(&BufLock);
	}
}

/*
 * BLV - code to preallocate a set number of message buffers. In the
 * networking software during bootstrap and taskforce start-up there
 * are a large number of parallel system library calls going on, each
 * one resulting in a separate message buffer. These buffers are spread
 * over various heaps, resulting in horrible memory fragmentation. This
 * routine can be used to avoid such problems.
 */
void PreallocMsgBufs(int n)
{ MCB	*m	= Null(MCB);
  MCB	*New	= Null(MCB);

  while (n-- > 0)
   { New = NewMsgBuf(0);
     if (New == NULL) break;
     *(MCB **) New = m;
     m = New;
   }

  while (New != NULL)
   { m = New;
     New = *(MCB **)m;
     FreeMsgBuf(m);
   }
}

/*--------------------------------------------------------
-- CopyObject						--
--							--
-- make a copy of the given object, but allocate a new	--
-- reply port for it. An error is produced if the	--
-- object is closeable.					--
--							--
--------------------------------------------------------*/

PUBLIC Object *CopyObject(Object *source)
{
	word oblen;
	Object *obj = NULL;
	word rc = 0;
	
#ifdef SYSDEB
	SysDebug(ioc)("CopyObject(%O)",source);
#endif

	if( CheckObject(source,0) != Err_Null ) return NULL;

	if( source->Flags & Flags_Closeable ) 
	{
		rc = EC_Error|SS_SysLib|EG_WrongFn|EO_Object;
		goto Done;
	}

	oblen = sizeof(Object) + (word)strlen(source->Name) + SafetyMargin;

	obj = (Object *)Malloc(oblen);

	if( obj == Null(Object) ) 
	{
		rc = EC_Error+SS_SysLib+EG_NoMemory+EO_Object;
		goto Done;
	}
	else memcpy((byte *)obj,(byte *)source,(int)oblen);

	obj->Reply = NewPort();

	AddObject( obj );

Done:

#ifdef SYSDEB
	SysDebug(ioc)("CopyObject: %E %O",rc,obj);
#endif
	source->Result2 = rc;

	return obj;
}

/*--------------------------------------------------------
-- NewObject						--
--							--
-- Create a new object structure from the name and	--
-- capability provided. These should have been derived	--
-- from a capability initially. The new object is give	--
-- Type Pseudo. It will only be Located at the server	--
-- if/when it is first touched.				--
--							--
--------------------------------------------------------*/

Object *NewObject(string name, Capability *cap)
{
	Object *obj;
	word oblen = sizeof(Object) + (word)strlen(name) + SafetyMargin;

	obj = (Object *)Malloc(oblen);

	if( obj == NULL ) return NULL;

	memclr( (void *)obj, (int)oblen );

	obj->Type = Type_Pseudo;
	obj->Access = *cap;
	strcpy(obj->Name,name);

	AddObject( obj );
	
	return obj;
}

/*--------------------------------------------------------
-- ReLocate						--
--							--
-- Do a locate operation on the given object. This is	--
-- normally called from CheckObject to check a pseudo	--
-- object created by NewObject.				--
--							--
--------------------------------------------------------*/

extern word ReLocate( Object *obj )
{
	MCB *mcb;
	IOCReply1 *rep;
	Port reply = NewPort();
	word rc;
	
	mcb = NewMsgBuf(0);	
	rep = (IOCReply1 *)mcb->Control;
	
	InitMCB(mcb,MsgHdr_Flags_preserve,
		MyTask->IOCPort,reply,FC_GSP+FG_Locate);

	MarshalString(mcb,obj->Name);
	MarshalWord(mcb,-1);
	MarshalWord(mcb,1);
	MarshalCap(mcb,&obj->Access);
	
	if( (rc = IOCMsg(mcb,NULL)) >= Err_Null )
	{
		obj->Type = rep->Type;
		obj->Flags = rep->Flags;
		obj->Result2 = 0;
		obj->FnMod = rc;
		obj->Timeout = IOCTimeout;
		obj->Reply = reply;
		obj->Access = rep->Access;
		strcpy(obj->Name,mcb->Data+rep->Pathname);
	}
	else 
	{
		FreePort(reply);
		obj->Result2 = rc;
	}
	
#ifdef SYSDEB
	SysDebug(ioc)("ReLocate: %E %O",rc,obj);
#endif

	FreeMsgBuf(mcb);
	
	return rc;
}

/*--------------------------------------------------------
-- NewStream						--
--							--
-- Create a stream structure from the supplied 		--
-- parameters and then re-open it. This is used to 	--
-- open up streams which have been passed as name/cap	--
-- pairs.						--
--							--
--------------------------------------------------------*/

Stream *NewStream(string name,Capability *cap, word mode)
{
	Stream *stream;
	word stlen = sizeof(Stream) + (word)strlen(name) + SafetyMargin;

#ifdef SYSDEB
	SysDebug(stream)("NewStream(%N,%C,%x)",name,cap,mode);
#endif

	stream = (Stream *)Malloc(stlen);

	if( stream == NULL ) return NULL;

	stream->Server = NullPort;
	stream->Type = Type_Pseudo;
	stream->Flags = Flags_Stream|mode;
	stream->Access = *cap;
	stream->Reply = NewPort();
	InitSemaphore( &stream->Mutex, 1 );
	stream->Pos = 0;
	stream->FnMod = 0;
	stream->Timeout = IOCTimeout;
	strcpy(stream->Name,name);

	AddStream ( stream );	

	/* if the stream has the OpenOnGet bit set, open it here */
	if( mode & Flags_OpenOnGet )
	{
		ReOpen(stream);

		stream->FnMod &= ~FR_Mask;
	
		if( stream->Result2 < Err_Null )
		{
			Wait(&StreamLock);
			Remove( &stream->Node );	
			Signal(&StreamLock);	
			Free(stream);
			return NULL;
		}
	}

	return stream;	
}

/*--------------------------------------------------------
-- PseudoStream						--
--							--
-- Create a pseudo stream structure from the supplied	--
-- object and mode. This can be used in place of a	--
-- real stream structure for environments etc.		--
-- If we try to use it then it will be ReOpened.	--
--							--
--------------------------------------------------------*/

Stream *PseudoStream(Object *object, word mode)
{
	Stream *s;
#ifdef SYSDEB
	SysDebug(stream)("PseudoStream(%O,%x)",object,mode);
#endif

	if( CheckObject(object,0) != Err_Null ) return NULL;

#if 1
	s = NewStream(object->Name,&object->Access,object->Flags|mode);
#else	
	s = NewStream(object->Name,&object->Access,0);

	if( s == NULL ) return NULL;
	
	s->Flags |= object->Flags|mode;	
	
	/* For pipes, do a CloseObject call when they are closed */
	
	if( object->Type == Type_Pipe ) s->Flags |= Flags_Closeable;
#endif
	return s;
}

/*--------------------------------------------------------
-- CopyStream						--
--							--
-- Generate a complete copy of the given stream. If the	--
-- stream has a reply port, this is re-allocated.	--
-- This function is a little dangerous since we will end--
-- up with more Stream structures than the server is	--
-- aware of. To try and alleviate this I clear the	--
-- Closeable flag in the copy so it will close silently.--
--							--
--------------------------------------------------------*/

PUBLIC Stream *CopyStream(Stream *s)
{
	Stream *s1;
	int len;

#ifdef SYSDEB
	SysDebug(stream)("CopyStream(%x=%S) from %s",s,s,procname(returnlink_(s)));
#endif
	if( CheckStream(s,C_ReOpen) != Err_Null ) return NULL;

	len = sizeof(Stream) + strlen(s->Name) + SafetyMargin;

	s1 = (Stream *)Malloc(len);

	if( s1 == NULL )
	{ s->Result2 = EC_Error|SS_SysLib|EG_NoMemory|EO_Stream; return NULL; }

	memcpy(s1,s,len);

	if( s1->Reply != NullPort ) s1->Reply = NewPort();

	if( s->Type == Type_Pipe ) 
	{
		if( !CopyPipe(s,s1) )
		{
			FreePort(s1->Reply);
			Free(s1);
			s->Result2 = EC_Error|SS_SysLib|EG_InUse|EO_Pipe;
			return NULL;
		}
	}

	s1->Flags &= ~Flags_Closeable;
	
	InitSemaphore(&s1->Mutex,1);

	AddStream(s1);

#ifdef SYSDEB
	SysDebug(stream)("CopyStream: %x %S)",s1,s1);
#endif
	return s1;
}

/*--------------------------------------------------------
-- Close						--
--							--
-- Close the stream or object down. This is a poly-	--
-- morphic function which should be applied to all	--
-- streams and objects. This is only a hint so we	--
-- do not have to try too hard to get it through.	--
-- Note also that Close avoids getting hung up on any	--
-- semaphores.						--
-- 							--
--------------------------------------------------------*/

PUBLIC word
Close( Stream * stream )
{
	word e = Err_Null;
	Object *object = (Object *)stream;
#ifdef SYSDEB
	SysDebug(stream)("Close(%O) called from %s",object,procname(returnlink_(stream)));
#endif
	if( object == NULL ) return Err_Null;
	
	/* start by aborting any current operations on the stream/object */
	
	unless( Terminating ) Abort(object);

	if( closebits_(stream->Flags)&closebits_(Flags_Stream) )
	{	

		if((e = CheckStream(stream,C_Close)) != Err_Null) return e; 
		
		if( stream->Type == Type_Pipe ) PipeClose(stream);

		/* ensure all waiters are away from stream, then claim it ourself */
		while( TestWait(&stream->Mutex) == FALSE)
			Abort((Object *)stream);
	
		e = CloseStream(stream);

		stream->Type = 0;

		Free(stream);

	}
	else 
	{  
		if((e = CheckObject(object,C_Close)) != Err_Null) return e;
		
		e = CloseObject(object);

		object->Type = 0;

		Free(object);
	}

	return e;	
}

PRIVATE word CloseStream(Stream *stream)
{
	word e = Err_Null;

#ifdef SYSDEB
		SysDebug(stream)("Close %S flags: %x",stream,stream->Flags);
#endif

	if( stream->Type == Type_Pseudo ) goto close1;

	switch( closebits_(stream->Flags) )
	{	

	/* a served closeable stream */
	case closebits_(Flags_Stream|Flags_Closeable|Flags_Server):
	{
#ifdef SYSDEB
		SysDebug(stream)("Close Served Closeable Stream(%S)",stream);
#endif
		SendException(stream->Server,FC_GSP+FG_Close|stream->FnMod);
		break;
	}
	
	/* an un-served closeable stream */
	case closebits_(Flags_Stream|Flags_Closeable):
	{
		MCB mcb;
		word control[5];
		word e;
#ifdef SYSDEB
		SysDebug(stream)("Close UnServed Closeable Stream(%S)",stream);
#endif
		InitMCB(&mcb,MsgHdr_Flags_preserve,
			MyTask->IOCPort,NullPort,FC_GSP+FG_CloseObj|stream->FnMod);
		mcb.Control = control;
		mcb.Data = stream->Name;
		mcb.MsgHdr.DataSize = strlen(stream->Name)+1;
		MarshalWord(&mcb,0);
		MarshalWord(&mcb,-1);
		MarshalWord(&mcb,1);
		MarshalCap(&mcb,&stream->Access);

		e = PutMsg(&mcb);

		break;
	}
	
	/* a served stream which need not be closed */
	case closebits_(Flags_Stream|Flags_Server):
#ifdef SYSDEB
		SysDebug(stream)("Close Served Stream(%S)",stream);
#endif
		if( !Terminating ) FreePort(stream->Server);
		break;
			
	/* an un-served stream which need not be closed */
	case closebits_(Flags_Stream):
#ifdef SYSDEB
		SysDebug(stream)("Close UnServed Stream(%S)",stream);
#endif
		break;

	default:
#ifdef SYSDEB
		SysDebug(stream)("Close Impossible Stream(%S)",stream);
#endif
		return EC_Error+SS_SysLib+EG_Invalid+EO_Stream;

	} /* end of switch */

close1:
	if( !Terminating ) FreePort(stream->Reply);	
	return e;
}

static word CloseObject(Object *object)
{
	word e = Err_Null;

#ifdef SYSDEB
		SysDebug(ioc)("Close %O flags: %x",object,object->Flags);
#endif
	
	switch( closebits_(object->Flags) )
	{
	/* a closeable object */
	case closebits_(Flags_Closeable):
	{
		MCB mcb;
		word control[5];
#ifdef SYSDEB
		SysDebug(ioc)("Close Closeable Object(%O)",object);
#endif
		InitMCB(&mcb,MsgHdr_Flags_preserve,
			MyTask->IOCPort,NullPort,FC_GSP+FG_CloseObj|object->FnMod);
		mcb.Control = control;
		mcb.Data = object->Name;
		mcb.MsgHdr.DataSize = strlen(object->Name)+1;
		MarshalWord(&mcb,0);
		MarshalWord(&mcb,-1);
		MarshalWord(&mcb,1);
		MarshalCap(&mcb,&object->Access);

		PutMsg(&mcb);

		break;
	}
	

	/* an object which need not be closed */
	case closebits_(0):
#ifdef SYSDEB
		SysDebug(ioc)("Close Normal Object(%O)",object);
#endif
		break;

	default:
#ifdef SYSDEB
		SysDebug(ioc)("Close Impossible Object(%O)",object);
#endif
		return EC_Error+SS_SysLib+EG_Invalid+EO_Object;

	} /* end of switch */

	if( !Terminating ) FreePort(object->Reply);

	return e;
}


/*--------------------------------------------------------
-- Result2						--
--							--
-- Extract error code/second result from object struct	--
-- 							--
--------------------------------------------------------*/

PUBLIC WORD
Result2( Object * object )
{
	return object->Result2;
}

/*--------------------------------------------------------
-- Abort						--
--							--
-- Abort operations on the given object/stream.		--
-- 							--
--------------------------------------------------------*/

PUBLIC WORD
Abort( Object * object )
{
	Stream *stream = (Stream *)object;
	word e = EC_Error|SS_SysLib|EG_Exception|EE_Abort;
	
#ifdef SYSDEB
	SysDebug(ioc)("Abort(%O)",object);
#endif
	switch( closebits_(object->Flags) )
	{
	case closebits_(Flags_Stream|Flags_Closeable|Flags_Server):
	case closebits_(Flags_Stream|Flags_Server):
		if( stream->Type == Type_Pipe ) PipeAbort(stream);
		else AbortPort(stream->Server,e);	
		/* drop through */
	case closebits_(Flags_Stream|Flags_Closeable):
	case closebits_(Flags_Stream):
	case closebits_(Flags_Closeable):
	case closebits_(0):
		AbortPort(stream->Reply, e);
		/* Free the reply port here. This will be re-allocated in */
		/* CheckStream/CheckObject if needed.			  */
		FreePort(stream->Reply);
		return Err_Null;

	default:
		return EC_Error+SS_SysLib+EG_Invalid+EO_Object;
	}
}

/*--------------------------------------------------------
-- AddObject						--
-- AddStream						--
--							--
-- Add a new object/stream to appropriate list. They	--
-- will be removed by CheckObject/Stream.		--
--							--
--------------------------------------------------------*/

static void AddObject(Object *o)
{
	Wait(&ObjectLock);
	AddTail( &Objects, &o->Node );
	Signal(&ObjectLock);	
}

static void AddStream(Stream *s)
{
	Wait(&StreamLock);
	AddTail( &Streams, &s->Node );
	Signal(&StreamLock);	
}

/*--------------------------------------------------------
-- CheckObject						--
-- CheckStream						--
--							--
-- Check the integrity of an object or stream struct	--
--							--
--------------------------------------------------------*/

static WORD CheckObject(Object *obj, word options)
{
	Object *o;
	PortInfo p;
	
	if( obj == NULL ) goto fail;

	Wait(&ObjectLock);

	for( o = Head_(Object,Objects) ; !EndOfList_(o) ; o = Next_(Object,o) )
	{
		if( o == obj )
		{
			if( options & C_Close ) Remove(&obj->Node);
			break;
		}
	}
	
	Signal(&ObjectLock);

	if( o != obj || o->Type == 0 ) goto fail;

	if( (options & C_Locate) && o->Type == Type_Pseudo ) return ReLocate(o);
	elif( GetPortInfo(o->Reply,&p) != Err_Null ) o->Reply = NewPort();
	
	return Err_Null;

fail:
#ifdef SYSDEB
	SysDebug(error)("Invalid object passed to %s: %x %O",
		procname(returnlink_(obj)),obj,obj);
#endif
	return EC_Error|SS_SysLib|EG_Invalid|EO_Object; 
}

static WORD CheckStream(Stream *str, word options)
{
	Stream *s;
	PortInfo p;
	
	if( str == NULL ) goto fail;

	Wait(&StreamLock);

	for( s = Head_(Stream,Streams) ; !EndOfList_(s) ; s = Next_(Stream,s) )
	{
		if( s == str ) 
		{
			if( options & C_Close ) Remove(&str->Node);
			break;
		}
	}

	Signal(&StreamLock);

	if( s != str || s->Type == 0 ) goto fail;

	if( (options & C_ReOpen) && s->Type == Type_Pseudo )
	 { word result;
	   Wait(&(s->Mutex));
	   if (s->Type == Type_Pseudo)
	    result = ReOpen(s);
	   else
	    result = Err_Null;
	   Signal(&(s->Mutex));
	   return(result);
	  }
	elif( !(options & C_Close) && GetPortInfo(s->Reply,&p) != Err_Null ) 
	 s->Reply = NewPort();

	return Err_Null;

fail:
#ifdef SYSDEB
	SysDebug(error)("Invalid stream passed to %s: %x %S",
			procname(returnlink_(str)),str,str);
#endif

	return EC_Error|SS_SysLib|EG_Invalid|EO_Stream; 
}

/*--------------------------------------------------------
-- SendIOC						--
--							--
-- Send a pre-constructed message to the IOC.		--
--							--
--------------------------------------------------------*/

PUBLIC void SendIOC(MCB *m)
{

#ifdef SYSDEB
	SysDebug(ioc)("SendIOC(%M)",m);
#endif

	m->MsgHdr.Dest = MyTask->IOCPort;

	PutMsg(m);
}

/*--------------------------------------------------------
-- SendMsg						--
--							--
-- Transmit a message using the procedure arguments as  --
-- an mcb.						--
--							--
--------------------------------------------------------*/

PUBLIC WORD SendMsg(word flagsize, ...)
{
	MCB *mcb = (MCB *)(&flagsize);
#ifdef SYSDEB
	SysDebug(process)("SendMsg(%M)",mcb);
#endif
	return PutMsg(mcb);
}

/*--------------------------------------------------------
-- XchMsg						--
--							--
-- Transmit a message and then receive a reply using	--
-- the same MCB.					--
--							--
--------------------------------------------------------*/

PUBLIC WORD
XchMsg1( MCB * mcb )
{
	return XchMsg(mcb,0);
}

/*--------------------------------------------------------
-- IOCMsg						--
--							--
-- Send a message to the IOC and cope with errors and	--
-- retries.						--
--							--
--------------------------------------------------------*/

static WORD IOCMsg(MCB *m, void *data)
{
	word r;
	MCB t;
	word time;

	t = *m;			/* struct copy of MCB */

	t.Timeout = OneSec;	/* tx should finish v. fast */

	/* set up client MCB for rx */
	m->MsgHdr.Dest = m->MsgHdr.Reply;	
	if( data != NULL ) m->Data = (byte *)data;
	
	forever
	{
	  extern word _ldtimer( int );
	  
		time = _ldtimer(0);
		
		r = XchMsg(&t,m);
		
		time = _ldtimer(0) - time;

		
		/* if the result is successful, or an error too serious	*/
		/* for us to handle here, return.			*/
		if( (r >= Err_Null) || ((r&EC_Mask) >= EC_Error) ) goto done;

		/* otherwise increment the retry count and do it again	*/
		t.MsgHdr.FnRc = (t.MsgHdr.FnRc & ~FR_Mask) |
				((t.MsgHdr.FnRc+FR_Inc) & FR_Mask);

		/* we just loop until we succeed or we get a real error	*/
#ifdef SYSDEB
		SysDebug(error)("IOCMsg Retry: error %E new fn %F",r,t.MsgHdr.FnRc);
#endif

	}
done:
	m->Timeout = time;
	
	return r;
}

PRIVATE WORD StreamMsg(MCB *mcb, Stream *stream)
{
	word e;
	MCB tx;
	
	tx = *mcb;
	mcb->MsgHdr.Dest = mcb->MsgHdr.Reply;	
	
	while( ( e = XchMsg(&tx,mcb) ) < Err_Null )
	{
#ifdef SYSDEB
		SysDebug(error)("StreamMsg XchMsg Error %x",e);
#endif	
		/* Recoverable errors are handled by XchMsg. 	*/
		/* Anything more serious than a warning should	*/
		/* be reported. Warnings can be handled here by	*/
		/* ReOpening the stream.			*/
		if( (e & EC_Mask) > EC_Warn ) break;

		if( (e = ReOpen(stream)) < Err_Null ) break;
		
		/* ReOpen can re-assign the ports */
		tx.MsgHdr.Dest = stream->Server;
		tx.MsgHdr.Reply = mcb->MsgHdr.Dest = stream->Reply;
	}
	
	return e;
}

/*--------------------------------------------------------
-- NewPort						--
-- FreePort						--
--							--
-- Routines to allocate and free ports from the kernel	--
-- and to keep track of them.				--
-- 							--
--------------------------------------------------------*/

#ifdef __TRAN
PUBLIC Port _SysNewPort(void) { return NewPort(); }
PUBLIC void _SysFreePort(Port p) { FreePort(p); }
#endif

#ifdef __TRAN
/*--------------------------------------------------------
-- BootLink						--
--							--
-- Boot the processor through a given link.		--
--							--
--------------------------------------------------------*/

PUBLIC WORD BootLink(word linkid, void *image, Config *config, word confsize)
{
	word rc = Err_Null;
	MCB *mcb;
	Port reply = NewPort();
	LinkInfo *link = GetRoot()->Links[linkid];

#ifdef SYSDEB
	SysDebug(process)("BootLink(%d,%P,%P,%d)",linkid,image,config,confsize);
#endif
	
	if( linkid < 0 || linkid > 3 ) return EC_Error|SS_SysLib|EG_Invalid|EO_Link;

	mcb = NewMsgBuf(0);
	
	InitMCB(mcb,0,link->LocalIOCPort,reply,FC_Private|FG_BootLink);

	MarshalData(mcb,confsize,(byte *)config);

	rc = XchMsg(mcb,0);

#ifdef SYSDEB
	SysDebug(process)("BootLink: %E",rc);
	if( mcb->MsgHdr.Reply != NullPort ) SysDebug(error)("BootLink: Non-Null Reply port %x",mcb->MsgHdr.Reply);
#endif
	if( mcb->MsgHdr.Reply != NullPort ) FreePort(mcb->MsgHdr.Reply);
	FreePort(reply);

	FreeMsgBuf(mcb);
	
	return rc;
}
#endif /* __TRAN */

#ifdef SYSDEB

static char SysDebugMsg[128];
static char SysDebugMcName[50];
word SysDebugArgs[10];

static void _SysDebug(char *str, ... )
{
	Wait(&SysDebugLock);
	
	/* If any flags except info are set, output message */
/*	if( MyTask->Flags != Task_Flags_info) */
	{
		int i;
		va_list a;
		
		va_start(a,str);
		
		for( i = 0 ; i < 10 ; i++ ) SysDebugArgs[i] = va_arg(a,int);
		
		if( SysDebugMcName[0] == 0 ) 
		{
			word of = MyTask->Flags;
			MyTask->Flags = 0;
			MachineName(SysDebugMcName);
			MyTask->Flags = of;
		}
		
		strcpy(SysDebugMsg,SysDebugMcName);
		strcat(SysDebugMsg,"-");
		strcat(SysDebugMsg,(char *)(MyTask->TaskEntry)+8);
		strcat(SysDebugMsg,": ");
		strcat(SysDebugMsg,str);
		
		IOdebug(SysDebugMsg,SysDebugArgs[0],SysDebugArgs[1],
			SysDebugArgs[2],SysDebugArgs[3],SysDebugArgs[4],
			SysDebugArgs[5],SysDebugArgs[6],SysDebugArgs[7],
			SysDebugArgs[8],SysDebugArgs[9]);
	}
	
	/* If info is set print Objects & Streams and clear bit	*/
	if(MyTask->Flags&Task_Flags_info)
	{
		Object *o;
		Stream *s;

		MyTask->Flags ^= Task_Flags_info;
		
		Wait(&ObjectLock);
		for( o = Head_(Object,Objects) ; !EndOfList_(o) ; o = Next_(Object,o) )
			IOdebug("%O",o);
		Signal(&ObjectLock);

		Wait(&StreamLock);
		for( s = Head_(Stream,Streams) ; !EndOfList_(s) ; s = Next_(Stream,s) )
			IOdebug("%S",s);
		Signal(&StreamLock);

		IOdebug("Message Buffers: %d",IOCBufCount);

		IOdebug("Memory: free %d largest %d",Malloc(-1),Malloc(-2));
		
	}
	
	Signal(&SysDebugLock);
}

#endif

/* end of misc.c */
@


1.30
log
@Reverting back to the 1.25 version. This is the transputer 1.3 release
except for stripping out some unnecessary functions. The various attempted
bug fixes between 1.25 and 1.29 have all caused lots of problems with
control-C, shutting down internal pipes, delays during termination, etc.
In theory these bug fixes are sensible, but it is too difficult to get
the system running with these fixes.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.25 1992/12/07 19:28:31 nickc Exp $ */
d171 1
a171 1
  MCB	*new	= Null(MCB);
d174 4
a177 4
   { new = NewMsgBuf(0);
     if (new == NULL) break;
     *(MCB **) new = m;
     m = new;
d180 3
a182 3
  while (new != NULL)
   { m = new;
     new = *(MCB **)m;
d216 1
a216 1
	obj = Malloc(oblen);
d255 1
a255 1
	obj = Malloc(oblen);
d342 1
a342 1
	stream = Malloc(stlen);
d438 1
a438 1
	s1 = Malloc(len);
d891 1
a891 1
	if( data != NULL ) m->Data = data;
@


1.29
log
@Switching to low priority inside Close() is a really bad idea. If the Close()
is invoked from inside a signal handler in a taskforce component then the
Close() will be blocked until the taskforce stops computing and tries to
communicate. This could take a very long time.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.28 1993/04/20 12:57:56 nickc Exp $ */
a25 1
#include <process.h>
d496 2
a497 3
	if ( closebits_(stream->Flags)&closebits_(Flags_Stream) )
	  {	
	    if ((e = CheckStream(stream,C_Close)) != Err_Null) return e; 
d499 3
a501 1
	    if ( stream->Type == Type_Pipe ) PipeClose(stream);
d503 11
a513 39
	    /*
	     * Before closing the stream have to grab the Mutex semaphore.
	     * But if some other thread has the semaphore and we Wait on
	     * it, then we will hang up, the other thread will never receive
	     * a reply to its GetMsg() and so the world will lock.  Instead
	     * we check to see if some other thread has the Mutex semaphore
	     * and if it does then we Abort any operations on the stream.
	     * We have to repeat this operation until we finally gain access
	     * to the Mutex semaphore, without ever having been hung up ourselves.
	     * We have to be careful, however, that we perform this test and
	     * abort sequence at low priority, as otherwise, if we were at
	     * high priority, we could spin forever, without letting the other
	     * threads in to notice the Abort and release the Mutex.
	     *
	     * BLV - Not quite. If the other thread is in GetMsg() then it is
	     * currently at system pri so it will wake up, but it will be
	     * suspended when GetMsg() returns and before it can call Signal().
	     * Unfortunately switching priority is a really bad idea, as it
	     * can cause this thread to be suspended while a foreground
	     * thread is calculating away indefinitely, e.g. if this thread is
	     * a signal handler. Instead I put in a minimum delay. This means
	     * that this thread can be suspended for up to 1 millisecond
	     * because of the timer granularity, very unfortunate if the
	     * program is trying to exit, but I cannot think of a better
	     * solution short of redesigning the relevant code.
	     */
	    
	    while( TestWait(&stream->Mutex) == FALSE)
	      {
		Abort((Object *)stream);
		Delay(1);
	      }
	    
	    e = CloseStream(stream);
	    
	    stream->Type = 0;
	    
	    Free(stream);
	  }
a686 1
	
d691 2
a692 2
	  
		AbortPort(stream->Server,e);	
a694 6
		if ( stream->Type == Type_Pipe )
		  {
		    PipeAbort(stream);
		  }
	  
		/* drop through again */
a698 1
	  
a701 1

a803 1
	   
@


1.28
log
@removed spurious debugging
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.27 1993/04/15 15:08:33 nickc Exp nickc $ */
a498 3
	    word oldPri;

	  
d516 12
a529 4
	    oldPri = GetPriority();
		
	    SetPriority( LowBackgroundPri );
		
d533 1
a534 2
	    
	    SetPriority( oldPri );
@


1.27
log
@another fix to the "processess taking a long time to terminate" bug (cf pipe.c v1.29), this time more believable.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.26 1993/03/27 20:44:00 bart Exp nickc $ */
a836 2
	   
	   if (s->Type == Type_Pipe) _Trace( 0, 0, 3 );
@


1.26
log
@In Close() the call to PipeAbort() never happened, because the flags were
not right. I have moved the call to PipeAbort() down.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.25 1992/12/07 19:28:31 nickc Exp $ */
d26 1
d497 27
a523 4
	if( closebits_(stream->Flags)&closebits_(Flags_Stream) )
	{	

		if((e = CheckStream(stream,C_Close)) != Err_Null) return e; 
d525 13
a537 13
		if( stream->Type == Type_Pipe ) PipeClose(stream);

		/* ensure all waiters are away from stream, then claim it ourself */
		while( TestWait(&stream->Mutex) == FALSE)
			Abort((Object *)stream);
	
		e = CloseStream(stream);

		stream->Type = 0;

		Free(stream);

	}
d711 1
d716 1
d720 5
a724 1
		if( stream->Type == Type_Pipe ) PipeAbort(stream);
d730 1
d734 1
d837 3
@


1.25
log
@removed spurious code
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.24 1992/09/07 13:40:24 paul Exp nickc $ */
d691 1
a691 2
		if( stream->Type == Type_Pipe ) PipeAbort(stream);
		else AbortPort(stream->Server,e);	
d694 2
@


1.24
log
@fixed loop during exit to use the correct Semaphore function
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.23 1992/09/04 10:24:43 nickc Exp $ */
d962 1
d965 1
a965 1

d967 1
d1007 1
@


1.23
log
@fixed more compile time warnings
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.22 1992/09/04 10:01:02 nickc Exp nickc $ */
d504 2
a505 2
		while( TestSemaphore(&stream->Mutex) != 1) Abort((Object *)stream);
		Wait(&stream->Mutex);
@


1.22
log
@fixed compile time warnings
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.21 1992/08/14 10:46:02 bart Exp nickc $ */
a31 1
static word CloseStream(Stream *stream);
d67 1
a67 1
static void _SysLib_Init(void)
d528 1
a528 1
static word CloseStream(Stream *stream)
d924 1
a924 1
static WORD StreamMsg(MCB *mcb, Stream *stream)
@


1.21
log
@Fixed problem with multiple ReOpen()'s on the same stream. This occurred if
an application tried to write to stdout and stderr in parallel.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.20 1992/06/03 19:02:57 paul Exp $ */
d260 1
a260 1
	memclr( (void *)obj, oblen );
d483 2
a484 2
PUBLIC word Close(stream)
Stream *stream;
d666 2
a667 2
PUBLIC WORD Result2(object)
Object *object;
d679 2
a680 2
PUBLIC WORD Abort(object)
Object *object;
d866 2
a867 2
PUBLIC WORD XchMsg1(mcb)
MCB *mcb;
d896 2
a897 1
		
@


1.20
log
@removed debug
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.19 1992/05/05 10:38:46 nickc Exp $ */
d798 12
a809 2
	if( (options & C_ReOpen) && s->Type == Type_Pseudo ) return ReOpen(s);
	elif( !(options & C_Close) && GetPortInfo(s->Reply,&p) != Err_Null ) s->Reply = NewPort();
@


1.19
log
@added a few debugging messages
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.18 1992/05/01 16:45:33 nickc Exp nickc $ */
a875 2
	KDebug( ("IOCMsg: called, data = %x\n", data ) );
	
a888 2
		/* KDebug(("IOCMsg: calling XchMsh\n" )); */
		
a889 2
		
		/* KDebug(("IOCMsg: XchMsh returned %x\n", r )); */
@


1.18
log
@removed most compiler warnings
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.17 1992/04/21 11:12:49 bart Exp nickc $ */
d876 2
d888 1
d890 3
d894 3
d898 1
@


1.17
log
@Added the library routine PreallocMsgBufs(). This is useful for highly
parallel programs such as the Network Server and TFM to avoid
spreading system message buffers over large numbers of heaps, thus
fragmenting memory.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.16 1991/10/17 07:39:55 paul Exp $ */
d116 1
a116 1
		m = (MsgBuf *)Malloc(sizeof(MsgBuf)+dsize-IOCDataMax);
d215 1
a215 1
	oblen = sizeof(Object) + strlen(source->Name) + SafetyMargin;
d224 1
a224 1
	else memcpy((byte *)obj,(byte *)source,oblen);
d254 1
a254 1
	word oblen = sizeof(Object) + strlen(name) + SafetyMargin;
d337 1
a337 1
	word stlen = sizeof(Stream) + strlen(name) + SafetyMargin;
@


1.16
log
@fixed compilation error with cast[orrect cast for polymorphic Abort - C40 C
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.15 1991/08/05 12:28:40 nick Exp $ */
a88 1

d162 26
d875 1
a875 1
	
a886 1
		
a887 1

@


1.15
log
@When closing a stream, loop until all waiters are free, then claim stream
before freeing it. Eliminates possible race condition.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.14 91/02/07 16:50:03 nick Exp $ */
d480 1
a480 1
		while( TestSemaphore(&stream->Mutex) != 1) Abort(stream);
@


1.14
log
@All MsgBufs of standard size obtained by Task are now kept.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.13 91/01/04 12:21:54 nick Exp $ */
d479 4
d513 1
a513 1
	
d980 1
a980 1
	if( MyTask->Flags & ~Task_Flags_info)
@


1.13
log
@result of ReOpen checked in StreamMsg, debug messages improved.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.12 90/11/28 11:25:48 nick Exp $ */
d43 2
d77 1
d110 5
a114 1
	if( dsize == IOCDataMax && IOCBuf != NULL ) m = IOCBuf, IOCBuf = NULL;
d124 1
d149 5
a153 1
	if( m->size > IOCDataMax ) Free(m);
d157 2
a158 2
		if( IOCBuf == NULL ) IOCBuf = m;
		else Free(m);
d1022 2
@


1.12
log
@bug in stream ReOpen code in StreamMsg fixed
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.11 90/11/21 10:46:20 nick Exp Locker: nick $ */
d890 2
a891 1
		ReOpen(stream);
d956 1
d973 11
a983 1
		strcpy(SysDebugMsg,(char *)(MyTask->TaskEntry)+8);
@


1.11
log
@bug in StreamMsg which caused it to ignore server timeouts fixed.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.10 90/11/02 16:32:44 paul Exp $ */
d892 2
a893 2
		mcb->MsgHdr.Dest = stream->Server;
		mcb->MsgHdr.Reply = stream->Reply;
@


1.10
log
@Made all calls to procname use the returnlink_() macro
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.9 90/11/01 15:30:03 nick Exp Locker: paul $ */
d874 6
a879 2

	while( ( e = XchMsg(mcb,0) ) < Err_Null )
@


1.9
log
@improvements to NewStream, CopyStream, and debugging messages.
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.7 90/10/19 11:05:33 nick Exp $ */
d730 1
a730 1
		procname(((word *)(&obj))[-2]),obj,obj);
d765 1
a765 1
			procname(((word *)(&str))[-2]),str,str);
@


1.8
log
@no change
@
text
@d39 1
a39 1
STATIC Semaphore	BufLock;	/* lock on buffer list */
d41 1
a41 1
STATIC MsgBuf		*IOCBuf;	/* IOC message buffer	*/
d43 1
a43 1
STATIC	Semaphore	ObjectLock;	/* lock on Object list */
d45 1
a45 1
STATIC List		Objects; 	/* list of Objects */
d47 1
a47 1
STATIC	Semaphore	StreamLock;	/* lock on Stream list */
d49 1
a49 1
STATIC	List		Streams;	/* list of Streams */
d51 6
d72 1
d75 4
d106 1
d122 4
d134 6
d355 1
d361 15
a375 2
	
	return NewStream(object->Name,&object->Access,object->Flags|mode);
d385 2
a386 1
-- aware of.						--
d394 4
a397 1
	
d403 1
a403 1
	
d406 1
a406 1
	
d408 1
a408 1
	
d421 2
d424 2
d427 4
a430 1
	
d451 3
a453 1

d458 1
a458 1
	Abort(object);
d469 2
d472 1
d480 2
d505 1
a505 1
	SysDebug(stream)("Close Served Closeable Stream(%S)",stream);
d540 1
a540 1
		FreePort(stream->Server);
d559 1
a559 1
	FreePort(stream->Reply);	
d612 1
a612 1
	FreePort(object->Reply);
d645 1
a645 1
	SysDebug(ioc)("Abort()");
d729 2
a730 1
	SysDebug(error)("Invalid object: %O",obj);
d764 2
a765 1
	SysDebug(error)("Invalid stream: %S",str);
d949 4
d955 2
a959 1
		int x[10];
d965 1
a965 3
		for( i = 0 ; i < 10 ; i++ ) x[i] = va_arg(a,int);
		
		IOdebug("%s:%",(char *)(MyTask->TaskEntry)+8);
d967 8
a974 1
		IOdebug(str,x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9]);
d998 2
@


1.7
log
@safety margin added to Stream and Object structure sizes
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.6 90/10/19 10:51:19 nick Exp Locker: nick $ */
a65 1
	
@


1.6
log
@ReLocate() made external
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.5 90/10/19 10:48:30 nick Exp Locker: nick $ */
d157 1
a157 1
	oblen = sizeof(Object) + strlen(source->Name) + 1;
d196 1
a196 1
	word oblen = sizeof(Object) + strlen(name) + 1;
d279 1
a279 1
	word stlen = sizeof(Stream) + strlen(name) + 1;
d361 1
a361 1
	len = sizeof(Stream)+strlen(s->Name)+1;
@


1.5
log
@root.h included
@
text
@d18 1
a18 1
/* $Id: misc.c,v 1.4 90/09/05 12:54:33 nick Exp Locker: nick $ */
d222 1
a222 1
static word ReLocate( Object *obj )
@


1.4
log
@*** empty log message ***
@
text
@d18 1
a18 1
/* $Id$ */
d23 1
@


1.3
log
@CopyStream can now copy pipes
@
text
@d18 1
a18 8
/* $Id: misc.c,v 1.1 90/08/28 12:08:24 nick Exp Locker: nick $
 *
 * $Log:	misc.c,v $
 * Revision 1.1  90/08/28  12:08:24  nick
 * Initial revision
 * 
 *
 */
@


1.2
log
@Close now checks for NULL argument and lets it through quietly
@
text
@a366 3
	if( s->Flags & Flags_OpenOnGet )
	{ s->Result2 = EC_Error|SS_SysLib|EG_WrongFn|EO_Stream; return NULL; }
	
d377 13
d413 1
a413 1

@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
/* $Id$
d20 4
a23 1
 * $Log$
d401 2
@
