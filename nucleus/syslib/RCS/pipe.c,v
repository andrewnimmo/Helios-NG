head	1.32;
access;
symbols
	Helios_1_3_1:1.32
	Helios_C40_1_3_Official_Release:1.30
	Alenia_release:1.25
	Helios1_3:1.24
	C40_Field_Test_2:1.23
	C40_Field_Test_R1:1.18
	Helios13_beta:1.18
	Helios1_2_2:1.17
	Helios1_2_2Beta:1.17
	Helios1_2_1:1.14
	Helios1_2:1.8
	V1_2Beta0:1.3;
locks; strict;
comment	@ * @;


1.32
date	93.08.06.12.42.03;	author bart;	state Exp;
branches;
next	1.31;

1.31
date	93.07.09.13.36.22;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	93.04.15.15.07.26;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	93.04.01.14.03.42;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	93.03.27.20.45.56;	author bart;	state Exp;
branches;
next	1.27;

1.27
date	93.02.03.11.16.27;	author bart;	state Exp;
branches;
next	1.26;

1.26
date	93.01.26.13.02.26;	author paul;	state Exp;
branches;
next	1.25;

1.25
date	92.12.07.19.28.41;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	92.10.23.14.18.37;	author bart;	state Exp;
branches;
next	1.23;

1.23
date	92.09.04.10.40.45;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	92.09.04.10.23.19;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	92.08.14.13.19.04;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	92.07.31.09.43.01;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	92.07.09.17.09.31;	author paul;	state Exp;
branches;
next	1.18;

1.18
date	92.05.01.16.45.21;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	91.08.13.14.10.33;	author nick;	state Exp;
branches;
next	1.16;

1.16
date	91.08.05.12.30.01;	author nick;	state Exp;
branches;
next	1.15;

1.15
date	91.04.11.16.50.56;	author nick;	state Exp;
branches;
next	1.14;

1.14
date	91.02.07.16.52.05;	author nick;	state Exp;
branches;
next	1.13;

1.13
date	91.01.16.12.25.37;	author nick;	state Exp;
branches;
next	1.12;

1.12
date	91.01.16.11.45.51;	author nick;	state Exp;
branches;
next	1.11;

1.11
date	90.12.10.15.39.06;	author nick;	state Exp;
branches;
next	1.10;

1.10
date	90.12.07.12.13.27;	author nick;	state Exp;
branches;
next	1.9;

1.9
date	90.12.07.11.58.04;	author nick;	state Exp;
branches;
next	1.8;

1.8
date	90.11.27.14.22.26;	author nick;	state Exp;
branches;
next	1.7;

1.7
date	90.11.01.16.23.16;	author nick;	state Exp;
branches;
next	1.6;

1.6
date	90.11.01.15.34.02;	author nick;	state Exp;
branches;
next	1.5;

1.5
date	90.10.16.10.21.08;	author nick;	state Exp;
branches;
next	1.4;

1.4
date	90.09.29.15.56.54;	author nick;	state Exp;
branches;
next	1.3;

1.3
date	90.09.05.12.55.26;	author nick;	state Exp;
branches;
next	1.2;

1.2
date	90.08.28.18.10.42;	author nick;	state Exp;
branches;
next	1.1;

1.1
date	90.08.28.12.11.56;	author nick;	state Exp;
branches;
next	;


desc
@point-to-point pipe protocol
@


1.32
log
@Sorting out stack checking options.
@
text
@/*------------------------------------------------------------------------
--                                                                      --
--                     H E L I O S   N U C L E U S                      --
--                     ---------------------------                      --
--                                                                      --
--            Copyright (C) 1987,1990, Perihelion Software Ltd.         --
--                        All Rights Reserved.                          --
--                                                                      --
-- syslib/pipe.c							--
--                                                                      --
--	Point-to-point pipe protocol handling				--
--									--
--                                                                      --
--	Author:  NHG 16/8/87						--
--		 NHG 03/8/90						--
--                                                                      --
------------------------------------------------------------------------*/
/* SccsId:	 %W%	%G% Copyright (C) 1987, Perihelion Software Ltd.*/
/* $Id: pipe.c,v 1.31 1993/07/09 13:36:22 nickc Exp $ */

#define _in_pipe

#include "sys.h"
#include <nonansi.h>
#include <process.h>

/*----------------------------------------------------------------
--	Stack Handling						--
----------------------------------------------------------------*/

#if defined(__TRAN) && !defined(SYSDEB)
	/* Transputer Helios does not have automatic stack extension.	*/
# define pipestack 2000
#else
#if defined(STACKEXTENSION)
	/* Some processors have automatic stack extension support.	*/
	/* N.B. stack checking must be used !!!				*/
#define pipestack	800

#ifndef STACKCHECK
#error Stack checking must be enabled when compiling this module.
#endif

#else
	/* This size should be used on the transputer when debugging	*/
	/* is enabled, on any processor without automatic stack		*/
	/* extension, or when porting to a new processor.		*/
#  define pipestack 4000
# endif
#endif

#if defined(STACKCHECK) && defined(__TRAN)
extern void _Trace(...);
#pragma -s1

static void _stack_error(Proc *p)
{
	_Trace(0xaaaaaaaa,p);
	IOdebug("Loader stack overflow in %s at %x",p->Name,&p);	
}
#pragma -s0
#endif

#define RemoteBit	0x00000008

#define FG_NewPort	(FG_Abort+0x10)

#define Code_Connect	0xa1
#define Code_Timeout	0xa2
#define Code_Close	0xa3
#define Code_Connect1	0xa4

#define TfrInc		IOCDataMax
#define MaxPipeTfr	(60*1024)
#define InitPipeTfr	MaxPipeTfr

struct P
{
	MCB *	req;
	Port	ack;
	uword	pos;
};

typedef struct PipeInfo
{
	Node		Node;
	int		State;
	Stream *	Stream1;
	Stream *	Stream2;
	Port		ServerPort;
	Port		DataPort;
	Port		RemotePort;
	struct
	{
		byte *	buf;
		word	max;
		word	size;
		word	read;
		word	got;
		word	newmax;
	} Pending;
	struct P	Read, Write;
	Port		ReadSelect;
	Port		WriteSelect;
	MCB *		PendingWrite;
	word		MaxTfr;
	uword		ReadPos;
	uword		WritePos;
} PipeInfo;


STATIC Semaphore PipeLock;

STATIC List PipeList;

static MCB *DoPipeWrite( PipeInfo *p, MCB *mcb);
static MCB *ExchangeData(PipeInfo *p);
static Port InitProtocol(PipeInfo *p);

#ifdef SYSDEB
#pragma -s0
#endif

static MCB *DoPipeRead(PipeInfo *p, MCB *mcb)
{
	ReadWrite *rw = (ReadWrite *)mcb->Control;
	word size = rw->Size;
	uword pos = rw->Pos;
	
#ifdef SYSDEB
	SysDebug(pipe)("%x PipeRead %d pos %d pending %d",p,size,rw->Pos,p->Pending.size);
#endif

	if( p->Read.req != NULL )
	{
		FreeMsgBuf(p->Read.req);
		p->Read.req = NULL;
	}

	/* Adaptive message sizes...					  */
	/* If the pos of this read is the same as the last one we saw, it */
	/* must be a retry. If so, reduce the maximum transfer size. If	  */
	/* not, and the current tfr size is < max, increase it. Note that */
	/* while the size is decreased multiplicatively, is is only	  */
	/* increased additively.					  */
	if( p->ReadPos == pos )
	{
		p->MaxTfr /= 2;
		if( p->MaxTfr < TfrInc ) p->MaxTfr = TfrInc;
	}
	else
	{
		/* pos can be > than ReadPos because it may be advanced	*/
		/* by writes. It should be impossible for it to be <	*/
		if( p->MaxTfr < MaxPipeTfr ) p->MaxTfr += TfrInc;
	}
	
	if( p->WriteSelect != NullPort )
	{
		SendException(p->WriteSelect,O_WriteOnly);
		p->WriteSelect = NullPort;
	}

	if( p->Pending.size > 0 )
	{
		MCB m;
		word tfr;

		p->Read.req = NULL;
		InitMCB(&m,0,mcb->MsgHdr.Reply,NullPort,ReadRc_EOD);
		tfr = size;
		if( tfr > p->Pending.size ) tfr = p->Pending.size;
		if( tfr > p->MaxTfr ) tfr = p->MaxTfr;
		m.Data = p->Pending.buf+p->Pending.read;
		m.MsgHdr.DataSize = (unsigned short)tfr;
		PutMsg(&m);

		p->Read.ack = mcb->MsgHdr.Reply;
		p->Read.pos = pos;

		return mcb;
	}

	p->Read.req = mcb;	

	if( p->Write.req ) return ExchangeData(p);
	elif( rw->Timeout == 0 || (p->State & O_WriteOnly) == 0 )
	{
		word rc = (p->State & O_WriteOnly)?(EC_Recover|SS_Pipe|EG_Timeout|EO_Pipe):ReadRc_EOF;

		InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,rc);
		PutMsg(mcb);
		p->Read.ack = mcb->MsgHdr.Reply;
		p->Read.req = NULL;
		p->Read.pos = pos;

		return mcb;
	}
	
	return NULL;
}

static MCB *DoReadAck(PipeInfo *p, MCB *mcb)
{
	word got = mcb->Control[0];
	
#ifdef SYSDEB
	SysDebug(pipe)("%x ReadAck %d %s",p,got,p->Write.ack?"WriteAck":"");
#endif
	InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,Err_Null);
	PutMsg(mcb);

	p->Read.ack = NullPort;
	if( got > 0 ) p->ReadPos = p->Read.pos;
	
	if( p->Write.ack )
	{
		InitMCB(mcb,0,p->Write.ack,NullPort,WriteRc_Done);
		MarshalWord(mcb,got);
		PutMsg(mcb);
		p->Write.ack = NullPort;
		if( got > 0 ) p->WritePos = p->Write.pos;
	}
	
	if( got > 0 && p->Pending.size > 0 )
	{
		p->Pending.size -= got;
		if( p->Pending.size == 0 )
		{
			p->Pending.read = 0;
			p->Pending.got = 0;
			if( p->Pending.newmax != p->Pending.max )
			{
				byte *newbuf = (byte *)Malloc(p->Pending.newmax);
				if( newbuf )
				{
					Free(p->Pending.buf);
					p->Pending.buf = newbuf;
					p->Pending.max = p->Pending.newmax;
				}
				else p->Pending.newmax = p->Pending.max;
			}
		}
		else p->Pending.read += got;
		if( p->Write.req ) FreeMsgBuf(DoPipeWrite(p,p->Write.req));
		if( p->WriteSelect != NullPort )
		{
			SendException(p->WriteSelect,O_WriteOnly);
			p->WriteSelect = NullPort;
		}
	}

	return mcb;	
}

static MCB *DoPipeWrite( PipeInfo *p, MCB *mcb)
{
	ReadWrite *rw = (ReadWrite *)mcb->Control;
	word pos      = rw->Pos;
	word size     = rw->Size;
	word timeout  = rw->Timeout;
	word got      = p->Pending.got;
	word avail    = p->Pending.max - got;
	word idata    = mcb->MsgHdr.DataSize;
	word e;

	
#ifdef SYSDEB
	SysDebug(pipe)("%x PipeWrite %d pos %d avail %d",p,size,rw->Pos,avail);
#endif
	if( p->Write.req != NULL && p->Write.req != mcb )
	{
#if 1
		FreeMsgBuf(p->Write.req);
		p->Write.req = NULL;
#else
		InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,
				EC_Error|SS_Pipe|EG_InUse|EO_Pipe);
		PutMsg(mcb);
		return mcb;
#endif	
	}

	/* Adaptive message sizes... */
	if( p->WritePos == pos )
	{
		p->MaxTfr /= 2;
		if( p->MaxTfr < TfrInc ) p->MaxTfr = TfrInc;

		/* This is a write retry, however, the reader	*/
		/* has got this data.				*/
		/* Hence we must junk this write.		*/
		/* Do this by sending the writer a WriteRc_Already */
		/* message with the appropriate size set.	*/
		/* Essentially this just repeats the ACK which	*/
		/* was lost.					*/
		InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,WriteRc_Already);
		MarshalWord(mcb,size);
		PutMsg(mcb);
		return mcb;
	}
	else if( p->MaxTfr < MaxPipeTfr ) p->MaxTfr += TfrInc;
	
	/* if there is no reader, report a broken pipe	*/
	unless( p->State & O_ReadOnly )
	{
		InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,EC_Error|SS_Pipe|EG_Broken|EO_Pipe);
		p->Write.req = NULL;
		return mcb;
	}

	if( p->ReadSelect != NullPort )
	{
		SendException(p->ReadSelect,O_ReadOnly);
		p->ReadSelect = NullPort;
	}
	
	p->Write.req = mcb;
	
	if( p->Read.req ) return ExchangeData(p);
	elif( idata )
	{
		/* Immediate data, accept as much as possible, and bounce */
		/* the request back.					*/
		if( avail > 0 )
		{
			if( idata > avail ) idata = avail;
			memcpy(p->Pending.buf+got,mcb->Data,(int)idata);
			p->Pending.got += idata;
			p->Pending.size += idata;
			p->WritePos = pos;
			p->Write.req = NULL;
			InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,WriteRc_Done);
			MarshalWord(mcb,idata);
			PutMsg(mcb);
			return mcb;
		}
		/* else let it wait */
	}
	elif( avail > 0 )
	{
		MCB m;
		WriteReply rep;
		Port dataport = p->DataPort;
		word tfr = size;
		
		if( tfr > avail ) tfr = avail;
		
		if( tfr > p->MaxTfr ) tfr = p->MaxTfr;

		m.Control = (word *)&rep;

		p->Write.req = NULL;
		
		rep.first = tfr;
		rep.rest = tfr;
		rep.max = tfr;

		InitMCB(&m,MsgHdr_Flags_preserve,mcb->MsgHdr.Reply,dataport,WriteRc_Sizes);
		m.MsgHdr.ContSize = 3;
		e = PutMsg(&m);

		m.MsgHdr.Dest = dataport;
		m.Data = p->Pending.buf+got;
		if( e >= 0 ) e = GetMsg(&m);

		if( m.MsgHdr.DataSize != tfr ) e = EC_Error;
		else got += tfr;
		
		InitMCB(&m,0,mcb->MsgHdr.Reply,NullPort,WriteRc_Done);
		rep.first = e<0?e:tfr;

		m.MsgHdr.ContSize = 1;
		PutMsg(&m);	

		p->Pending.got = got;
		p->Pending.size += tfr;
		p->WritePos = pos;
				
		return mcb;
	}
	
	if( timeout == 0 )
	{
#if 1
		rw->Timeout = OneSec;
#else
		InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,EC_Recover|SS_Pipe|EG_Timeout|EO_Pipe);
		PutMsg(mcb);
#endif
	}
	
	return NULL;
}

static MCB *ExchangeData(PipeInfo *p)
{
	MCB *	   rmcb = p->Read.req;
	MCB *	   wmcb = p->Write.req;
	MCB	   m;
	WriteReply r;
	int	   rsize  = (int)((ReadWrite *)(rmcb->Control))->Size;
	int	   tfr    = (int)((ReadWrite *)(wmcb->Control))->Size;
	Port	   reader = rmcb->MsgHdr.Reply;
	Port	   writer = wmcb->MsgHdr.Reply;
	word	   idata  = wmcb->MsgHdr.DataSize;
	
	p->Read.pos   = ((ReadWrite *)(rmcb->Control))->Pos;
	p->Write.pos  = ((ReadWrite *)(wmcb->Control))->Pos;

#ifdef SYSDEB
	SysDebug(pipe)("%x PipeXch %x[%d] -> %x[%d]",p,writer,tfr,reader,rsize);
#endif
	m.Control = (word *)&r;

	p->Read.req = p->Write.req = NULL;

	if( tfr > rsize ) tfr = rsize;
	
	if( idata )
	{
		/* send writer's immediate data to reader */
		InitMCB(&m,0,reader,NullPort,ReadRc_EOD);
		m.Data = wmcb->Data;
		m.MsgHdr.DataSize = tfr;
		PutMsg(&m);		
	}
	else
	{
		word bsize = tfr;
		if( bsize > p->MaxTfr ) bsize = p->MaxTfr;
	
		/* tell writer to send data directly to reader */
		InitMCB(&m,MsgHdr_Flags_preserve,writer,reader,WriteRc_Sizes);
		r.first = bsize;
		r.rest = r.first;
		r.max = tfr;
		m.MsgHdr.ContSize = 3;
		PutMsg(&m);

		/* the writer will now send its data to the reader	*/
	}
	
	p->Read.ack = rmcb->MsgHdr.Reply;
	p->Write.ack = wmcb->MsgHdr.Reply;
		
	FreeMsgBuf(rmcb);
	return wmcb;
}


static MCB *DoPipeSelect(PipeInfo *p, MCB *mcb)
{
	word mode = mcb->MsgHdr.FnRc & Flags_Mode;
	Port port = mcb->MsgHdr.Reply;
	word rep = 0;

#ifdef SYSDEB
	SysDebug(pipe)("%x PipeSelect",p);
#endif
	if( mode & O_ReadOnly )
	{
		FreePort(p->ReadSelect); p->ReadSelect = NullPort;
		if( p->WriteSelect || p->Pending.size > 0 || 
		    p->Write.req || (p->State & O_WriteOnly) == 0 ) 
			rep |= O_ReadOnly;
		else p->ReadSelect = port;
	}
	elif( mode & O_WriteOnly )
	{
		FreePort(p->WriteSelect); p->WriteSelect = NullPort;
		if( p->ReadSelect || p->Read.req ||
		    (p->State & O_ReadOnly) == 0 ) rep |= O_WriteOnly;
		else p->WriteSelect = port;	
	}
	
	if( rep ) 
	{
		InitMCB(mcb,0,port,NullPort,rep);
		PutMsg(mcb);
	}
	
	return mcb;
}

static void AbortRequest(struct P *p, word code)
{
	MCB *mcb = p->req;
	if( mcb == NULL ) return;
	InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,code);
	PutMsg(mcb);
	FreeMsgBuf(p->req);
	p->req = NULL;
}

static MCB *DoPipeClose(PipeInfo *p, MCB *mcb)
{
	Port reply = mcb->MsgHdr.Reply;

#ifdef SYSDEB
	SysDebug(pipe)("%x PipeClose %x &= ~%x",p,p->State,(mcb->MsgHdr.FnRc&FF_Mask));
#endif

	p->State &= (int)(~(mcb->MsgHdr.FnRc & FF_Mask));

	if( !Terminating ) AbortRequest(&p->Read,ReadRc_EOF);

	AbortRequest(&p->Write,EC_Error|SS_Pipe|EG_Broken|EO_Pipe);
	if( !Terminating && p->ReadSelect )
	{
		InitMCB(mcb,0,p->ReadSelect,NullPort,O_ReadOnly);
		PutMsg(mcb);
		p->ReadSelect = NULL;
	}
	if( p->WriteSelect )
	{
		InitMCB(mcb,0,p->WriteSelect,NullPort,O_WriteOnly);
		PutMsg(mcb);
		p->WriteSelect = NULL;
	}
	if( reply != NullPort )
	{
		InitMCB(mcb,0,reply,NullPort,0);
		PutMsg(mcb);
	}

	return mcb;
}

static MCB *DoPipeAbort(PipeInfo *p, MCB *mcb)
{
	AbortRequest(&p->Read,EC_Error|SS_Pipe|EG_Exception|EE_Abort);
	AbortRequest(&p->Write,EC_Error|SS_Pipe|EG_Exception|EE_Abort);
	return mcb;
}

static void DoTimeout( struct P *p)
{
	if( p->req != NULL )
	{
		ReadWrite *rw = (ReadWrite *)p->req->Control;
		rw->Timeout-=OneSec*2;
		if( rw->Timeout <= 0 )
		{
			AbortRequest(p,EC_Recover|SS_Pipe|EG_Timeout|EO_Pipe);
		}
	}
}

static MCB  *DoPipeGSize(PipeInfo *p, MCB *mcb)
{
#ifdef SYSDEB
	SysDebug(pipe)("%x PipeGSize",p);
#endif
	InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,Err_Null);
	MarshalWord(mcb,p->Pending.size);
	PutMsg(mcb);
	return mcb;
}

static MCB  *DoPipeSSize(PipeInfo *p, MCB *mcb)
{
	int newsize = (int)(mcb->Control[0]);
	word rc = Err_Null;
	
#ifdef SYSDEB
	SysDebug(pipe)("%x PipeSSize %d",p,newsize);
#endif
	if( p->Pending.size == 0 )
	{
		byte *newbuf = (byte *)Malloc(newsize);
		if( newbuf )
		{
			Free(p->Pending.buf);
			p->Pending.buf = newbuf;
			p->Pending.max = newsize;
		}
	}
	
	p->Pending.newmax = newsize;
	

	InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,rc);
	PutMsg(mcb);	
	
	return mcb;
}

static void PipeServer(PipeInfo *p)
{
	MCB *mcb = NULL;
	Port serverport = p->ServerPort;
	PortInfo info;

	while( p->State )
	{
		word e;

		if( p->PendingWrite )
		{
			mcb = p->PendingWrite;
			p->PendingWrite = NULL;
			e = mcb->MsgHdr.FnRc;
			goto dispatch;
		}

		if( mcb == NULL ) mcb = NewMsgBuf(0);
		
		InitMCB(mcb,0,serverport,NullPort,0);
		mcb->Timeout = OneSec*2;

		e = GetMsg(mcb);

		if( e == EK_Timeout ) 
		{
			e = GetPortInfo(p->RemotePort,&info);
			if ( e != Err_Null )
			{
#ifdef SYSDEB
				SysDebug(error)("%x PipeServer GetPortInfo Error %E",p,e);
#endif
				AbortRequest(&p->Read,EC_Warn|SS_Pipe);
				AbortRequest(&p->Write,EC_Warn|SS_Pipe);
				continue;
			}

			DoTimeout(&p->Read);
			DoTimeout(&p->Write);
			continue;
		}
				
		if( e < Err_Null )
		{
#ifdef SYSDEB
			SysDebug(error)("%x PipeServer GetMsg Error %E",p,e);
#endif
#if 0
			if ( Terminating ) StopProcess();
#endif
			
			AbortRequest(&p->Read,EC_Warn|SS_Pipe);
			AbortRequest(&p->Write,EC_Warn|SS_Pipe);

			continue;
		}
		

	dispatch:
#if 0
#ifdef SYSDEB
		SysDebug(pipe)("%x PipeServer %F",p,e);
#endif
#endif
		
		switch( e & FG_Mask )
		{
		case FG_Read:	 mcb = DoPipeRead(p,mcb);	break;
		case FG_ReadAck: mcb = DoReadAck(p,mcb);	break;
		case FG_Write:	 mcb = DoPipeWrite(p,mcb);	break;
		case FG_Select:	 mcb = DoPipeSelect(p,mcb);	break;
		case FG_GetSize: mcb = DoPipeGSize(p,mcb);	break;
		case FG_SetSize: mcb = DoPipeSSize(p,mcb);	break;
		case FG_Abort:	 mcb = DoPipeAbort(p,mcb);	break;
		case FG_Close:	 mcb = DoPipeClose(p,mcb);	break;
		case FG_NewPort:
				FreePort(serverport);
				serverport = p->ServerPort;
				break;
		default:
			InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,
				EC_Error|SS_Pipe|EG_WrongFn|EO_Pipe);
			PutMsg(mcb);
		}
	}

#ifdef SYSDEB
	SysDebug(pipe)("%x PipeServer quitting",p);
#endif

	if( Terminating ) return;
	Wait(&PipeLock);
	Remove(&p->Node);
	FreeMsgBuf(mcb);
	FreePort(p->ServerPort);
	FreePort(p->DataPort);
	Free(p->Pending.buf);
	Free(p);
	Signal(&PipeLock);

	return;	
}

#ifdef SYSDEB

#pragma -s1

void _stack_error(Proc *p)
{
	IOdebug("Pipe stack overflow in %s at %x",p->Name,&p);	
}
#endif 

static Port InitProtocol(PipeInfo *p)
{
	Stream *s = p->Stream1;
	word e;
	MCB *mcb = NewMsgBuf(0);
	Port port;

again:
	/* send off a connect message to pipe server	*/
	InitMCB(mcb,MsgHdr_Flags_preserve,s->Server,s->Reply,0);

	e = PutMsg(mcb);

again1:
	InitMCB(mcb,0,s->Reply,NullPort,0);
	if( e >= 0 ) e = GetMsg(mcb);

	switch( e )
	{
	case Code_Connect:
	case Code_Connect1:
		break;		/* simple case drop straight out    */

	case Code_Timeout:	/* other side not yet ready, retry  */
		goto again;
		
	case FG_Write:		/* The other side's write got here	*/
				/* before the server's reply, squirrel	*/
				/* it away for later consumption.	*/
		p->PendingWrite = mcb;
		mcb = NewMsgBuf(0);
		e = 0;
		goto again1;
		
	case Code_Close:	/* other end has simply closed	    */
	default:		/* an error of some sort	    */
#ifdef SYSDEB
		SysDebug(error)("Pipe Init error: %x (called from %s)",e,procname(returnlink_(s)));
#if 0
		IOdebug("Pipe Init error: %x (called from %s)",e,procname(returnlink_(s)));
		back_trace();
#endif
#endif
		if( (e&EG_Mask) == EG_Timeout ) goto again;
		if (e == Code_Close)
		 s->Result2 = ReadRc_EOF;
		else
		 s->Result2 = e;
		FreeMsgBuf(mcb);
		return NullPort;
	}
	port = mcb->MsgHdr.Reply;
	FreeMsgBuf(mcb);
	return port;
}

static PipeInfo *InitPipe(Stream *s)
{
	PipeInfo *p;
	Port server;
	PipeInfo **process = NULL;
	
	p = New(PipeInfo);
	
	if( p == NULL ) 
	{
		CloseStream(s); s->Type = Type_Pseudo;
		s->Result2 = EC_Error|SS_SysLib|EG_NoMemory|EO_Pipe;
		return NULL;
	}

	if( s->Flags & O_ReadOnly ) 
	{
		process = (PipeInfo **)NewProcess(pipestack,PipeServer,sizeof(p));
	
		if( process == NULL )
		{
			Free(p);
			CloseStream(s);	s->Type = Type_Pseudo;
			s->Result2 = EC_Error|SS_SysLib|EG_NoMemory|EO_Pipe;
			return NULL;
		}
	}

	memset(p,0,sizeof(PipeInfo));

	p->Stream1 = s;
	
	server = InitProtocol(p);

	if( server == NullPort )
	{
		Free(p);
		if (process != NULL)
		  ZapProcess((void *)process);
		CloseStream(s); s->Type = Type_Pseudo;
		return NULL;
	}

	/* The pipe is connected */

	Wait(&PipeLock);
	AddTail(&PipeList,&p->Node);
	Signal(&PipeLock);

#ifdef SYSDEB
	SysDebug(pipe)("%x InitPipe s %x",p,s);
#endif
	
	p->Stream2        = NULL;
	s->Server	  = server;
	s->Flags	 |= Flags_Extended|Flags_Fast;
	s->Timeout	  = IOCTimeout;
	p->Pending.max	  = 2048;
	p->Pending.newmax = 2048;
	p->DataPort       = NewPort();
	p->RemotePort     = server;
	p->MaxTfr         = InitPipeTfr;
	p->ReadPos        = 1;
	p->WritePos       = 1;
				
	p->State = (int)(O_WriteOnly | (s->Flags & O_ReadWrite));

	if( p->State & O_ReadOnly )
	{
		p->ServerPort = s->Reply;
		s->Reply = NewPort();

		p->Pending.buf = (byte *)Malloc(p->Pending.max);
		if( p->Pending.buf == NULL )
		{
			p->Pending.max = 0;
			p->Pending.newmax = 0;
		}

		p->Pending.read = 0;
		p->Pending.got = 0;
		p->Pending.size = 0;
	
		*process = p;
			
		ExecProcess( (void *)process, HighServerPri );
	}
	else p->ServerPort = NULL;
	
	return p;
}

static word GetPipe(PipeInfo *p, Stream *s) 
{ return (p->Stream1 == s) || (p->Stream2 == s); }

PRIVATE word FindPorts(Stream *s, word fn, Port *server, Port *reply)
{
	PipeInfo *p;

	if( s->Type != Type_Pipe ) *server = s->Server;
	else
	{
		Wait( &PipeLock );
		p = (PipeInfo *)SearchList(&PipeList,GetPipe,s);
		Signal( &PipeLock );

		if( p == NULL ) 
		{
			p = InitPipe(s);
			if( p == NULL )
			{
				if( fn == FG_Write && s->Result2 == ReadRc_EOF )
				{
					s->Result2 = EC_Error|SS_Pipe|EG_Broken|EO_Pipe;
				}
				return s->Result2;
			}
		}
		
		switch( fn )
		{
		case FG_Read:
		case FG_GetSize:
		case FG_SetSize:
		case FG_Select|O_ReadOnly:
			unless( p->State & O_ReadOnly ) return EC_Error|SS_Pipe|EG_Broken|EO_Pipe;
			*server = p->ServerPort;
			break;
		case FG_Select|O_WriteOnly:
		default:
			*server = s->Server;
			break;
		}
	}

	if( (GetReady(s->Reply)&EG_Mask) == EG_Invalid ) s->Reply = NewPort();
	
	*reply = s->Reply;

	return 0;
}

PRIVATE word PipeReOpen(Stream *s, word code, word rc)
{
	Stream *s1 = s, *s2;
	PipeInfo *p;
	Port port;
	word e;

	Wait( &PipeLock );
	p = (PipeInfo *)SearchList(&PipeList,GetPipe,s);
	Signal( &PipeLock );

	if( p == NULL ) return EC_Error|SS_Pipe|EG_Broken|EO_Pipe;
#ifdef SYSDEB
	SysDebug(error)("PipeReOpen: %S",s);
#endif
	s2 = p->Stream2;

	if( s1 == p->Stream1 ) { if( s2 ) Wait(&s2->Mutex); }
	elif( s1 == s2 )
	{
		s1 = p->Stream1;
		Wait(&s1->Mutex);
	}

	/* ReOpen will re-allocate these		*/
	FreePort(s1->Server);
	FreePort(s1->Reply);
	s1->Server = s1->Reply = NullPort;

	e = ReOpen(s1);
#ifdef SYSDEB
	if( e < 0 ) SysDebug(error)("PipeReOpen: ReOpen error %x %S",e,s);
#endif
	if( e < Err_Null ) goto done;

	port = InitProtocol(p);
#ifdef SYSDEB
	if( port == 0 ) SysDebug(error)("PipeReOpen: Init error %x %S",s1->Result2,s);
#endif
	if( port == NullPort ) { e = s1->Result2; goto done; }

	p->RemotePort = port;
	s1->Flags |= Flags_Extended|Flags_Fast;	
	s1->Server = port;
	
	if( s2 )
	{
		s2->Server = port;
		FreePort(s2->Reply);
		s2->Reply = NewPort();
		s2->Flags |= Flags_Extended|Flags_Fast;
	}
	
	if( p->State & O_ReadOnly )
	{
		Port oldsp = p->ServerPort;
		p->ServerPort = s1->Reply;
		SendException(oldsp,FG_NewPort);
		s1->Reply = NewPort();
	}
	
done:
#ifdef SYSDEB
	SysDebug(error)("PipeReOpen: done %x %S",e,s);
#endif
	if( s == s2 ) Signal(&s1->Mutex);
	else if( s2 ) Signal(&s2->Mutex);
	
	return e;
}

PRIVATE word PipeClose(Stream *s)
{
	PipeInfo *p;
	bool freepipe = false;

	
	Wait( &PipeLock );
	p = (PipeInfo *)SearchList(&PipeList,GetPipe,s);
	Signal( &PipeLock );

	if( p != NULL )
	{
		if( p->State & s->Flags & O_ReadOnly ) 
		{
			MCB mcb;
			Port port = NewPort();

			InitMCB(&mcb,0,p->ServerPort,port,FG_Close|O_ReadOnly);
			XchMsg(&mcb,NULL);
			FreePort(port);
		}
		else freepipe = !Terminating;
/*		if( p->State & s->Flags & O_WriteOnly ) */

#if 1
		/* Do close syncronously so that rest of close code doesn't */
		/* free the port, before the receiver gets the pipe close.  */
		{
			MCB mcb;

			InitMCB(&mcb,0,s->Server,NullPort,FG_Close|O_WriteOnly);
			mcb.Timeout = 10 * OneSec;

			PutMsg(&mcb);
		}	
#else
		SendException(s->Server,FG_Close|O_WriteOnly);
#endif
		if( p->Stream1 == s ) p->Stream1 = NULL;
		elif( p->Stream2 == s ) p->Stream2 = NULL;
		if( freepipe && p->Stream1 == NULL && p->Stream2 == NULL )
		{
			Wait(&PipeLock);
			Remove(&p->Node);
			FreePort(p->DataPort);
			Free(p->Pending.buf);
			Free(p);		
			Signal(&PipeLock);
		}

		FreePort(s->Server);

		return true;
	}
	else
	{
		/* A pipe which has been opened but not connected,	*/
		/* do a FreePort on the server port which will get rid	*/
		/* of the dangling trail.				*/
		FreePort(s->Server);
	}
	
	return false;
}

PRIVATE void PipeAbort(Stream *s)
{
	PipeInfo *p;
	
	Wait( &PipeLock );
	p = (PipeInfo *)SearchList(&PipeList,GetPipe,s);
	Signal( &PipeLock );

	if( p != NULL )
	{
		MCB mcb;
		InitMCB(&mcb,MsgHdr_Flags_preserve,s->Server,NullPort,FG_Abort|O_WriteOnly);
		PutMsg(&mcb);		
		if( p->ServerPort )
		{
			mcb.MsgHdr.Dest = p->ServerPort;
			mcb.MsgHdr.FnRc = FG_Abort|O_ReadOnly;
			PutMsg(&mcb);
		}
		
	}
}

PRIVATE bool CopyPipe(Stream *old, Stream *New)
{
	PipeInfo *p;
	
	Wait( &PipeLock );
	p = (PipeInfo *)SearchList(&PipeList,GetPipe,old);
	Signal( &PipeLock );

	if( p == NULL )
	{
		p = InitPipe(old);
		if( p == NULL ) return false;
	}
	
#ifdef SYSDEB
	SysDebug(pipe)("%x CopyPipe %x -> %x",p,old,New);
#endif

	if( p->Stream1 == old && p->Stream2 == NULL )
	{
		p->Stream2 = New;
		return true;
	}
	return false;
}

PRIVATE Port PipeSelect(Stream *s, word mode)
{
	Port server;
	Port reply = NullPort;
	MCB mcb;

	if( mode & O_WriteOnly )
	{
		if(FindPorts(s,FG_Select|O_WriteOnly,&server,&reply) == Err_Null)
		{
			InitMCB(&mcb,MsgHdr_Flags_preserve,server,reply,FG_Select|O_WriteOnly);
			PutMsg(&mcb);	
		}
	}
	if( mode & O_ReadOnly )
	{
		if(FindPorts(s,FG_Select|O_ReadOnly,&server,&reply) == Err_Null)
		{
			InitMCB(&mcb,MsgHdr_Flags_preserve,server,reply,FG_Select|O_ReadOnly);
			PutMsg(&mcb);	
		}
	}
	return reply;
}

#ifdef __TRAN
PUBLIC word GrabPipe(Stream *s, Port *ports)
{
	return EC_Error|SS_Pipe|EG_Invalid|EO_Pipe;
}

PUBLIC word UnGrabPipe(Stream *s)
{
	return EC_Error|SS_Pipe|EG_Invalid|EO_Pipe;
}
#endif /* __TRAN */

/* end of pipe.c */
@


1.31
log
@fixed conflicts with C++
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.30 1993/04/15 15:07:26 nickc Exp nickc $ */
d27 37
d776 1
a776 1
		process = (PipeInfo **)NewProcess(2000,PipeServer,sizeof(p));
@


1.30
log
@removed comment
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.29 1993/04/01 14:03:42 nickc Exp nickc $ */
d197 1
a197 1
				byte *newbuf = Malloc(p->Pending.newmax);
d534 1
a534 1
		byte *newbuf = Malloc(newsize);
d794 1
a794 1
		p->Pending.buf = Malloc(p->Pending.max);
d1023 1
a1023 1
PRIVATE bool CopyPipe(Stream *old, Stream *new)
d1038 1
a1038 1
	SysDebug(pipe)("%x CopyPipe %x -> %x",p,old,new);
d1043 1
a1043 1
		p->Stream2 = new;
@


1.29
log
@Hmm, sort of fixed problem with terminating tasks taking excessivly long periods of time to clean up their pipes
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.28 1993/03/27 20:45:56 bart Exp nickc $ */
a967 29
			/*
			 * XXX - NC - 1/4/1993 (after 12:00)
			 *
			 * This fixes a problem with closing pipes, but I don't
			 * know why it fixes the problem ...
			 * The problem is that if you run
			 *   remote 00 ls
			 * or
			 *   wsh 00
			 * on a C40 with the Task Force Manager running, (you only
			 * need one processor, although the problem occurs if you
			 * have more than one), then about one time in three the
			 * problem will take an excessive amount of time (>= 40 seconds)
			 * to terminate after it has finished executing.  I have traced
			 * the problem to the call to WalkList(&Streams,Close) in TidyUp()
			 * called from Exit() in nucleus/syslib/task.c.  It turns out
			 * that one of the Close() calls for one of the pipes (between
			 * TFM and command ?) is taking a very long time to return.
			 * Putting debuggin in Close() does not work, (Helios hangs up),
			 * and putting debugging in this function has strange effects.
			 * If you enable the Delay() just before the PutMsg() below then
			 * the problem goes away.  If you disable the first Delay() and
			 * enable the Delay() just after the PutMsg() then the problem is
			 * accentuated!  (These effects are also observed if you use a for
			 * loop instead of a Delay() ).
			 */
#if 1			
		Delay( OneSec / 1000 );
#endif
d969 1
a969 5
		}
#if 0
		Delay( OneSec / 1000 );
#endif
	
@


1.28
log
@In the PipeServer() there was a call to StopProcess() if Terminating and
an unexpected error code was received. This could cause deadlock conditions
during termination because it is possible to get kernel exceptions on
this port. Eliminating the call to StopProcess() appears to be safe.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.27 1993/02/03 11:16:27 bart Exp $ */
d462 1
d489 1
d603 1
d606 1
d940 1
d968 29
d999 4
d1017 1
d1019 1
@


1.27
log
@The PipeServer thread is now given HighServerPri by an appropriate
argument to ExecProcess() rather than by an explicit call to
SetPriority().
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.26 1993/01/26 13:02:26 paul Exp bart $ */
d598 1
d600 1
@


1.26
log
@uprated the priority of the pipe server
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.25 1992/12/07 19:28:41 nickc Exp $ */
a555 2
	SetPriority(HighServerPri);
	
d801 1
a801 1
		ExecProcess( (void *)process, StandardPri );
@


1.25
log
@removed spurious code
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.24 1992/10/23 14:18:37 bart Exp nickc $ */
d556 1
@


1.24
log
@Pipes did not recover if a signal was received while a ReOpen() was
going on.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.23 1992/09/04 10:40:45 nickc Exp $ */
d1066 1
d1076 1
@


1.23
log
@fixed more compile time warnings
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.22 1992/09/04 10:23:19 nickc Exp nickc $ */
d705 4
a708 1
		s->Result2 = ReadRc_EOF;
@


1.22
log
@fixed compile time warnings
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.21 1992/08/14 13:19:04 nickc Exp nickc $ */
d809 1
a809 1
static word FindPorts(Stream *s, word fn, Port *server, Port *reply)
@


1.21
log
@minor cosmetic changes
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.20 1992/07/31 09:43:01 nickc Exp nickc $ */
d718 1
a718 1
	PipeInfo **process;
d751 2
a752 1
		ZapProcess((void *)process);
d856 1
a856 1
static word PipeReOpen(Stream *s, word code, word rc)
d927 1
a927 1
static word PipeClose(Stream *s)
d989 1
a989 1
static void PipeAbort(Stream *s)
d1012 1
a1012 1
static bool CopyPipe(Stream *old, Stream *new)
d1038 1
a1038 1
static Port PipeSelect(Stream *s, word mode)
@


1.20
log
@added (commented out) debugging
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.19 1992/07/09 17:09:31 paul Exp nickc $ */
d42 1
a42 1
	MCB	*req;
d51 2
a52 2
	Stream		*Stream1;
	Stream		*Stream2;
d58 1
a58 1
		byte	*buf;
d68 1
a68 1
	MCB		*PendingWrite;
d143 1
a143 1
						
d159 1
d222 6
a227 6
	word pos = rw->Pos;
	word size = rw->Size;
	word timeout = rw->Timeout;
	word got = p->Pending.got;
	word avail = p->Pending.max - got;
	word idata = mcb->MsgHdr.DataSize;
d230 1
d556 1
d612 1
d637 1
d647 2
@


1.19
log
@fix for pipe close delays
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.18 1992/05/01 16:45:21 nickc Exp $ */
d692 4
@


1.18
log
@removed most compiler warnings
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.17 1991/08/13 14:10:33 nick Exp nickc $ */
d153 1
d465 1
d467 1
d570 1
a570 1
		
d919 1
a919 1
	
d930 1
d937 15
a951 1
			SendException(s->Server,FG_Close|O_WriteOnly);
@


1.17
log
@The message port for the far end of a pipe is now stored in the PipeInfo
structure (RemotePort).
A GetPortInfo() call is made on the RemotePort on each timeout in the
PipeServer. This allows it to detect link failures and provoke a reopen.
Close now always send a close message to the far end to break down the
trail.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.16 1991/08/05 12:30:01 nick Exp $ */
d138 1
a138 1
		m.MsgHdr.DataSize = tfr;
d288 1
a288 1
			memcpy(p->Pending.buf+got,mcb->Data,idata);
d358 3
a360 3
	MCB *rmcb = p->Read.req;
	MCB *wmcb = p->Write.req;
	MCB m;
d362 5
a366 5
	int rsize = ((ReadWrite *)(rmcb->Control))->Size;
	int tfr   = ((ReadWrite *)(wmcb->Control))->Size;
	Port reader = rmcb->MsgHdr.Reply;
	Port writer = wmcb->MsgHdr.Reply;
	word idata = wmcb->MsgHdr.DataSize;
d463 1
a463 1
	p->State &= ~(mcb->MsgHdr.FnRc&FF_Mask);
d519 1
a519 1
	int newsize = mcb->Control[0];
d538 1
a538 1
done:
d626 1
a626 1
done:
a702 1
	word e;
d752 5
a756 5
	p->Stream2 = NULL;
	s->Server = server;
	s->Flags |= Flags_Extended|Flags_Fast;
	s->Timeout = IOCTimeout;
	p->Pending.max = 2048;
d758 5
a762 5
	p->DataPort = NewPort();
	p->RemotePort = server;
	p->MaxTfr = InitPipeTfr;
	p->ReadPos = 1;
	p->WritePos = 1;
d764 1
a764 1
	p->State = O_WriteOnly | (s->Flags & O_ReadWrite);
@


1.16
log
@Replaced long Delay with a StopProcess during Pipe shutdown.
Calls to FreePort added to PipeClose ot ensure that trails go away.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.15 1991/04/11 16:50:56 nick Exp $ */
d55 1
a112 3
#ifdef SYSDEB
_SysDebug("%x: o %d n %d New MaxTfr %d R",p,p->ReadPos,rw->Pos,p->MaxTfr);
#endif
d249 1
a249 3
#ifdef SYSDEB
_SysDebug("%x: o %d n %d New MaxTfr %d W",p,p->WritePos,rw->Pos,p->MaxTfr);
#endif
d549 2
a550 1
	
d572 11
d599 1
d760 1
a856 1

d869 1
a874 1

a880 1
	
d883 1
d933 1
a933 1
		if( p->State & s->Flags & O_WriteOnly )
@


1.15
log
@Select request is now returned if the other end of the pipe has
closed since last select (caused a timing bug in X}
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.14 91/02/07 16:52:05 nick Exp $ */
d113 1
a113 1
IOdebug("%x: o %d n %d New MaxTfr %d R",p,p->ReadPos,rw->Pos,p->MaxTfr);
d252 1
a252 1
IOdebug("%x: o %d n %d New MaxTfr %d W",p,p->WritePos,rw->Pos,p->MaxTfr);
d466 1
d585 1
a585 1
			while( Terminating ) Delay(OneSec*100);
d937 1
d939 7
@


1.14
log
@WriteRc_Already used to reply to retries of writes we have already seen.
Immediate data in Write requests now supported.
Stack checking now enabled for pipe process in debug system.
Failure to create pipe process in Init now handled more cleanly.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.13 91/01/16 12:25:37 nick Exp $ */
d428 2
a429 1
		if( p->WriteSelect || p->Pending.size > 0 || p->Write.req ) 
d436 2
a437 1
		if( p->ReadSelect || p->Read.req ) rep |= O_WriteOnly;
@


1.13
log
@IOdebugs compiled out
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.12 91/01/16 11:45:51 nick Exp Locker: nick $ */
d25 1
d38 1
d44 1
d69 2
a70 2
	word		ReadPos;
	word		WritePos;
d82 4
d90 1
a90 1
	word pos = rw->Pos;
a97 1
#if 1
a99 6
#else
		InitMCB(mcb,0,mcb->MsgHdr.Reply,NullPort,
			EC_Error|SS_Pipe|EG_InUse|EO_Pipe);
		PutMsg(mcb);
		return mcb;
#endif
d116 6
a121 1
	elif( p->MaxTfr < MaxPipeTfr ) p->MaxTfr += TfrInc;
d138 1
d144 1
a144 1
		p->ReadPos = pos;
d151 1
a151 5
	if( p->Write.req ) 
	{
		p->ReadPos = pos;
		return ExchangeData(p);
	}
d159 1
d177 2
a178 1

d182 1
a182 1
		mcb->MsgHdr.ContSize = 1;	
d185 1
d227 1
d254 11
d266 1
a266 1
	elif( p->MaxTfr < MaxPipeTfr ) p->MaxTfr += TfrInc;
d284 2
a285 1
	if( p->Read.req ) 
d287 16
a302 2
		p->WritePos = pos;
		return ExchangeData(p);
d304 1
a304 2
	
	if( (timeout==0)?(size<avail):(avail>0) )
a317 1
		p->WritePos = pos;
d342 1
d370 4
a382 2

	if( tfr > p->MaxTfr ) tfr = p->MaxTfr;
d384 20
a403 7
	/* tell writer to send data directly to reader */
	InitMCB(&m,MsgHdr_Flags_preserve,writer,reader,WriteRc_Sizes);
	r.first = tfr;
	r.rest = r.first;
	r.max = tfr;
	m.MsgHdr.ContSize = 3;
	PutMsg(&m);
d405 2
a406 1
	/* the writer will now send its data to the reader	*/
d629 10
d693 2
a694 1

d699 1
d703 14
d726 2
d743 2
a744 2
	s->Flags |= Flags_Extended|Flags_NoIData|Flags_Fast;
	s->Timeout = OneSec;
d748 3
a750 3
	p->MaxTfr = MaxPipeTfr;
	p->ReadPos = -1;
	p->WritePos = -1;
d759 2
a760 1
		while( p->Pending.buf == NULL ) 
d762 2
a763 8
			p->Pending.buf = Malloc(p->Pending.max);
			if( p->Pending.buf == NULL ) Delay(OneSec);
			else
			{
				p->Pending.read = 0;
				p->Pending.got = 0;
				p->Pending.size = 0;
			}
d765 8
a772 7
		
		if( !Fork(3000,PipeServer,sizeof(p),p) )
		{
			Free(p);
			s->Result2 = EC_Error|SS_SysLib|EG_NoMemory|EO_Pipe;
			return NULL;
		}
d859 3
d866 3
d872 1
a872 1
	s1->Flags |= Flags_Extended|Flags_NoIData;	
d880 1
a880 1
		s2->Flags |= Flags_Extended|Flags_NoIData;
d892 3
@


1.12
log
@Adaptive message size adjustment added. Whenever a Read or Write retry is
seen, the message size is halved. On successful transfers the size is
increased by IOCDataMax. Hopefully this will keep traffic flowing in the
face of congestion without significantly contributing to it.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.11 90/12/10 15:39:06 nick Exp $ */
d112 1
d114 1
d245 1
d247 1
@


1.11
log
@when a pending write arrived, initpipe was going back to putmsg not getmsg.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.10 90/12/07 12:13:27 nick Exp Locker: nick $ */
d35 3
d65 3
d83 2
a84 1

d101 14
d136 2
a137 1
				
d143 5
a147 1
	if( p->Write.req ) return ExchangeData(p);
d215 1
d238 9
a261 1
	if( p->Read.req ) return ExchangeData(p);
d263 6
d277 2
d283 1
d345 2
d349 1
a349 1
	r.first = tfr>60000?60000:tfr;
d664 2
a665 1
	s->Flags |= Flags_Extended|Flags_NoIData;
d669 4
a672 1
		
@


1.10
log
@syntax error fixed
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.9 90/12/07 11:58:04 nick Exp $ */
d538 1
d545 1
a560 1
IOdebug("setup pending write");
d563 2
a564 1
		goto again;
@


1.9
log
@when an init failure is encountered during read,an EOF is returned not
a broken pipe error.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.8 90/11/27 14:22:26 nick Exp Locker: nick $ */
d673 1
a673 1
					s->Result2 = return EC_Error|SS_Pipe|EG_Broken|EO_Pipe;
@


1.8
log
@reply to read select was sending write bit back
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.7 90/11/01 16:23:16 nick Exp Locker: nick $ */
d570 1
a570 2
		e = EC_Error|SS_Pipe|EG_Broken|EO_Pipe;
		s->Result2 = e;
d669 8
a676 1
			if( p == NULL ) return s->Result2;
@


1.7
log
@unprotected SysDebug removed
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.6 90/11/01 15:34:02 nick Exp Locker: nick $ */
d221 1
a221 1
		SendException(p->ReadSelect,O_WriteOnly);
@


1.6
log
@Many improvements, pipes can now re-connect after failure, a potential
race condition in the initialisation code has been dealt with.
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.5 90/10/16 10:21:08 nick Exp $ */
a686 1
		SysDebug(pipe)("%x: FindPorts %F s %x r %x",p,fn,*server,s->Reply);
@


1.5
log
@Acknowlege added for local closes, avoids problems on program termination
@
text
@d19 1
a19 1
/* $Id: pipe.c,v 1.4 90/09/29 15:56:54 nick Exp $ */
d26 1
a26 1
#define progname_ ((char *)(MyTask->TaskEntry)+8)
d28 1
a28 1
#define RemoteBit	0x00000008
d61 1
d71 1
d79 13
a91 1
	SysDebug(pipe)("%x PipeRead %d pending %d",p,size,p->Pending.size);
d93 2
d175 1
a175 1
		if( p->Write.req ) DoPipeWrite(p,p->Write.req);
d196 1
a196 1
	SysDebug(pipe)("%x PipeWrite %d avail %d",p,size,avail);
d198 13
d215 1
d368 1
a368 1
	AbortRequest(&p->Read,ReadRc_EOF);
d370 1
a370 1
	if( p->ReadSelect )
d404 1
d406 1
d452 2
a453 1

d457 9
a465 1
		
d468 1
a468 1
		InitMCB(mcb,0,p->ServerPort,NullPort,0);
d480 17
a496 2
		if( e < Err_Null ) continue;

d507 4
d521 1
d528 1
a528 1
	Free(p);	
d532 1
a532 1
static PipeInfo *InitPipe(Stream *s)
d534 1
a534 1
	PipeInfo *p;
d536 2
a537 11
	MCB mcb;

	p = New(PipeInfo);
	
	if( p == NULL ) 
	{
		s->Result2 = EC_Error|SS_SysLib|EG_NoMemory|EO_Pipe;
		return NULL;
	}
	memset(p,0,sizeof(PipeInfo));

d539 2
a540 2
	/* now send off a connect message to pipe server	*/
	InitMCB(&mcb,MsgHdr_Flags_preserve,s->Server,s->Reply,0);
d542 1
a542 1
	e = PutMsg(&mcb);
d544 2
a545 2
	InitMCB(&mcb,0,s->Reply,NullPort,0);
	if( e >= 0 ) e = GetMsg(&mcb);
d555 9
a563 1
			
a564 1
		e = EC_Error|SS_Pipe|EG_Broken|EO_Pipe;
d566 3
d570 31
a601 1
		s->Result2 = e;
a614 1
	p->Stream1 = s;
d616 2
a617 2
	s->Server = mcb.MsgHdr.Reply;
	s->Flags |= Flags_Extended|Flags_NoIData|Flags_NoReOpen;
d641 1
a641 1
		if( !Fork(2000,PipeServer,sizeof(p),p) )
d687 1
d697 63
d771 1
a771 1
		if( p->ServerPort && (s->Flags & O_ReadOnly) ) 
d779 2
a780 2
		else freepipe = true;
		if( s->Flags & O_WriteOnly )
d784 1
a784 1
		if( freepipe )
d799 1
a799 1
static word PipeAbort(Stream *s)
d830 5
a834 1
	if( p == NULL ) return false;
@


1.4
log
@memory leakages fixed
@
text
@d19 1
a19 1
/* $Id$ */
a324 1

d333 1
d352 5
d526 1
a526 1
	s->Flags |= Flags_Extended|Flags_NoIData;
d617 7
a623 1
			SendException(p->ServerPort,FG_Close|O_ReadOnly);
@


1.3
log
@*** empty log message ***
@
text
@d240 3
d245 1
d458 1
a524 12

	while( p->Pending.buf == NULL ) 
	{
		p->Pending.buf = Malloc(p->Pending.max);
		if( p->Pending.buf == NULL ) Delay(OneSec);
		else
		{
			p->Pending.read = 0;
			p->Pending.got = 0;
			p->Pending.size = 0;
		}
	}
d532 13
d603 2
a604 1

d613 1
d618 9
@


1.2
log
@added ability to have two streams on a pipe so it may
be used bi-directionally simultaneously
@
text
@d19 1
a19 5
/* $Id$
 *
 * $Log$
 *
 */
@


1.1
log
@Initial revision
@
text
@d49 2
a50 1
	Stream		*Stream;
d80 3
d127 3
d183 3
d262 3
d295 3
d334 3
d375 3
d389 3
d453 3
d512 4
d517 2
a518 1
	p->Stream = s;
d555 2
a556 1
static word GetPipe(PipeInfo *p, Stream *s) { return p->Stream == s; }
d608 6
a613 2
		if( p->ServerPort ) SendException(p->ServerPort,FG_Close|O_ReadOnly);
		SendException(s->Server,FG_Close|O_WriteOnly);
d641 22
@
